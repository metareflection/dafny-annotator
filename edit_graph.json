{
    "nodes": [
        {
            "id": "root",
            "type": "root",
            "content": "",
            "parents": [],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-0",
            "type": "idea",
            "content": "1. A program that verifies the correctness of a binary search algorithm, ensuring it always returns the correct index for a target element in a sorted array.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-1",
            "type": "idea",
            "content": "2. A program that checks the correctness of a sorting algorithm, verifying that the output list is always sorted in ascending order.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-2",
            "type": "idea",
            "content": "3. A program that verifies the properties of a stack data structure, ensuring LIFO behavior and correct handling of push/pop operations.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-3",
            "type": "idea",
            "content": "4. A program that confirms the correctness of an algorithm that finds the greatest common divisor of two integers using the Euclidean method.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-4",
            "type": "idea",
            "content": "5. A program that ensures a queue implementation respects FIFO order and correct behavior of enqueue/dequeue operations.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-5",
            "type": "idea",
            "content": "6. A program that verifies the implementation of a linked list, checking for correct insertion and deletion operations.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-6",
            "type": "idea",
            "content": "7. A program that checks the properties of a binary search tree, ensuring correct insertion and deletion while maintaining the BST property.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-7",
            "type": "idea",
            "content": "8. A program that verifies the correctness of a depth-first search algorithm on a graph, ensuring it visits all vertices.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-8",
            "type": "idea",
            "content": "9. A program that confirms the proper implementation of Dijkstra\u2019s algorithm, verifying shortest path calculations.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-9",
            "type": "idea",
            "content": "10. A program that verifies a recursive Fibonacci sequence generator, ensuring correct computation of Fibonacci numbers.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-10",
            "type": "idea",
            "content": "11. A program that confirms the correctness of a matrix multiplication function, ensuring the output matrix is accurate.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-11",
            "type": "idea",
            "content": "12. A program that checks the properties of a circular buffer, verifying correct wraparound behavior and capacity limits.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-12",
            "type": "idea",
            "content": "13. A program that verifies the correctness of an algorithm that determines if a string is a palindrome, ensuring it correctly handles edge cases.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-13",
            "type": "idea",
            "content": "14. A program that confirms the correctness of a function that merges two sorted arrays, ensuring the merged output is sorted.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-14",
            "type": "idea",
            "content": "15. A program that verifies the implementation of a set data structure, ensuring it correctly handles element uniqueness.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-15",
            "type": "idea",
            "content": "16. A program that checks the correctness of a function that computes factorials, verifying it handles large inputs without overflow.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-16",
            "type": "idea",
            "content": "17. A program that verifies an algorithm that finds the minimum spanning tree of a graph using Kruskal\u2019s method.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-17",
            "type": "idea",
            "content": "18. A program that confirms the correctness of a balanced parentheses checker, ensuring it handles nested structures properly.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-18",
            "type": "idea",
            "content": "19. A program that verifies the implementation of a priority queue, ensuring correct ordering of elements based on priority.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-19",
            "type": "idea",
            "content": "20. A program that checks the properties of a hash map, verifying correct handling of collisions and consistent retrieval.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-20",
            "type": "idea",
            "content": "21. A program that verifies a binary heap implementation, ensuring it maintains the heap property during operations.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-21",
            "type": "idea",
            "content": "22. A program that confirms the correctness of a merge sort algorithm, verifying sorted output irrespective of input size.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-22",
            "type": "idea",
            "content": "23. A program that checks the correctness of a function that reverses a linked list, ensuring nodes are correctly reordered.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-23",
            "type": "idea",
            "content": "24. A program that verifies the implementation of a balanced binary tree, ensuring height differences between subtrees remain constrained.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-24",
            "type": "idea",
            "content": "25. A program that ensures a recursive binary search tree traversal outputs nodes in sorted order.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-25",
            "type": "idea",
            "content": "26. A program that verifies the correctness of a function that calculates the power of a number using exponentiation by squaring.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-26",
            "type": "idea",
            "content": "27. A program that checks the properties of a simple cache, ensuring it correctly follows the least recently used (LRU) policy.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-27",
            "type": "idea",
            "content": "28. A program that verifies the implementation of a Breadth-First Search algorithm, ensuring it correctly explores all nodes at the present depth level.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-28",
            "type": "idea",
            "content": "29. A program that ensures a recursive quicksort algorithm correctly partitions and sorts arrays.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-29",
            "type": "idea",
            "content": "30. A program that verifies the correctness of a function that checks for anagrams, ensuring it correctly handles strings of different lengths.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-30",
            "type": "idea",
            "content": "31. A program that checks the properties of a binary tree, verifying correct pre-order, in-order, and post-order traversals.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-31",
            "type": "idea",
            "content": "32. A program that verifies a palindrome partitioning algorithm, ensuring it finds all possible palindromic partitions of a string.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-32",
            "type": "idea",
            "content": "33. A program that confirms the correctness of an algorithm that finds the longest common subsequence between two strings.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-33",
            "type": "idea",
            "content": "34. A program that verifies the implementation of a trie data structure, ensuring efficient insertion and search operations.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-34",
            "type": "idea",
            "content": "35. A program that checks the correctness of a function that computes the edit distance between two strings, ensuring all insertions, deletions, and substitutions are considered.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-35",
            "type": "idea",
            "content": "36. A program that verifies a dynamic programming solution for the knapsack problem, ensuring optimal selection of items.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-36",
            "type": "idea",
            "content": "37. A program that ensures an implementation of a minimal perfect hash function correctly maps keys to unique slots.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-37",
            "type": "idea",
            "content": "38. A program that verifies the correctness of an algorithm that determines if two binary trees are identical.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-38",
            "type": "idea",
            "content": "39. A program that checks the properties of a depth-limited search algorithm, ensuring it respects depth boundaries.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-39",
            "type": "idea",
            "content": "40. A program that verifies the implementation of a bit manipulation technique to swap two numbers without a temporary variable.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-40",
            "type": "idea",
            "content": "41. A program that confirms the correctness of an algorithm that performs matrix transposition, ensuring rows and columns are swapped.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-41",
            "type": "idea",
            "content": "42. A program that verifies the correctness of a function that generates all permutations of a given string.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-42",
            "type": "idea",
            "content": "43. A program that ensures a function correctly identifies all prime numbers up to a given limit using the Sieve of Eratosthenes.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-43",
            "type": "idea",
            "content": "44. A program that checks the correctness of an implementation of a circular doubly linked list, verifying correct forward and backward traversal.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-44",
            "type": "idea",
            "content": "45. A program that verifies a recursive algorithm for solving the Tower of Hanoi problem, ensuring minimal moves are used.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-45",
            "type": "idea",
            "content": "46. A program that confirms the correctness of a function that finds the median of an unsorted list using the median of medians approach.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-46",
            "type": "idea",
            "content": "47. A program that verifies the implementation of a graph coloring algorithm, ensuring no two adjacent vertices share the same color.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-47",
            "type": "idea",
            "content": "48. A program that checks the properties of a function that calculates the nth Catalan number, ensuring correct combinatorial calculations.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-48",
            "type": "idea",
            "content": "49. A program that verifies the correctness of a function that finds all subsets of a given set, ensuring no subset is omitted.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-49",
            "type": "idea",
            "content": "50. A program that confirms the correctness of an algorithm that implements the Floyd-Warshall algorithm for all-pairs shortest paths.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-50",
            "type": "idea",
            "content": "51. A program that verifies the implementation of a function that solves Sudoku puzzles, ensuring valid board configurations.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-51",
            "type": "idea",
            "content": "52. A program that ensures the correctness of a function that calculates the binomial coefficient using Pascal\u2019s triangle.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-52",
            "type": "idea",
            "content": "53. A program that checks the correctness of a function that implements the Rabin-Karp algorithm for substring search.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-53",
            "type": "idea",
            "content": "54. A program that verifies an algorithm that finds the convex hull of a set of points in a 2D plane.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-54",
            "type": "idea",
            "content": "55. A program that confirms the correctness of a function that calculates the least common multiple of two integers.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-55",
            "type": "idea",
            "content": "56. A program that verifies the implementation of a Bloom filter, ensuring correct probabilistic membership testing.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-56",
            "type": "idea",
            "content": "57. A program that checks the properties of a maximum flow algorithm, ensuring correct calculation of flow values in a network.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-57",
            "type": "idea",
            "content": "58. A program that verifies the correctness of a function that determines if a number is a power of two.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-58",
            "type": "idea",
            "content": "59. A program that ensures an algorithm that finds the longest increasing subsequence in an array is correct.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-59",
            "type": "idea",
            "content": "60. A program that verifies the implementation of a function that determines if a graph is bipartite.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-60",
            "type": "idea",
            "content": "61. A program that confirms the correctness of a function that simulates the Monty Hall problem, ensuring statistical accuracy.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-61",
            "type": "idea",
            "content": "62. A program that verifies the properties of a function that generates random numbers using a linear congruential generator.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-62",
            "type": "idea",
            "content": "63. A program that checks the correctness of a function that implements the Boyer-Moore majority vote algorithm.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-63",
            "type": "idea",
            "content": "64. A program that verifies an algorithm that performs topological sorting on a directed acyclic graph.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-64",
            "type": "idea",
            "content": "65. A program that ensures the correctness of a function that calculates the number of unique paths in a grid with obstacles.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-65",
            "type": "idea",
            "content": "66. A program that verifies the implementation of a dynamic programming solution for the coin change problem.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-66",
            "type": "idea",
            "content": "67. A program that confirms the correctness of an algorithm that solves the traveling salesman problem using dynamic programming.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-67",
            "type": "idea",
            "content": "68. A program that verifies the correctness of a function that finds the maximum subarray sum using Kadane\u2019s algorithm.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-68",
            "type": "idea",
            "content": "69. A program that checks the properties of a function that generates Gray codes for a given number of bits.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-69",
            "type": "idea",
            "content": "70. A program that verifies a function that checks if a given Sudoku board is valid according to game rules.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-70",
            "type": "idea",
            "content": "71. A program that ensures an implementation of a function that computes the square root of a number using Newton\u2019s method.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-71",
            "type": "idea",
            "content": "72. A program that verifies the correctness of a function that solves the 8-queens problem, ensuring no two queens attack each other.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-72",
            "type": "idea",
            "content": "73. A program that confirms the correctness of a function that calculates the derivative of a polynomial function.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-73",
            "type": "idea",
            "content": "74. A program that verifies a function that finds the intersection of two linked lists, ensuring it correctly identifies shared nodes.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-74",
            "type": "idea",
            "content": "75. A program that checks the correctness of an algorithm that flattens a binary tree into a linked list in-place.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-75",
            "type": "idea",
            "content": "76. A program that verifies the properties of a function that calculates Pascal\u2019s triangle up to a given number of rows.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-76",
            "type": "idea",
            "content": "77. A program that ensures a function that calculates the dot product of two vectors is correct.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-77",
            "type": "idea",
            "content": "78. A program that verifies the correctness of a function that performs integer division without using the division operator.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-78",
            "type": "idea",
            "content": "79. A program that confirms the correctness of an algorithm that calculates the area of a polygon given its vertex coordinates.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-79",
            "type": "idea",
            "content": "80. A program that verifies the implementation of an algorithm that finds the longest palindrome substring in a given string.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-80",
            "type": "idea",
            "content": "81. A program that checks the correctness of a function that determines if a number is a perfect square.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-81",
            "type": "idea",
            "content": "82. A program that verifies a function that implements the Gale-Shapley algorithm for the stable marriage problem.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-82",
            "type": "idea",
            "content": "83. A program that ensures the correctness of a function that calculates the determinant of a matrix using Laplace expansion.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-83",
            "type": "idea",
            "content": "84. A program that verifies the implementation of an algorithm that finds the largest rectangle in a histogram.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-84",
            "type": "idea",
            "content": "85. A program that confirms the correctness of a function that computes the inverse of a matrix using Gaussian elimination.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-85",
            "type": "idea",
            "content": "86. A program that verifies the correctness of a function that performs polynomial multiplication using the Karatsuba algorithm.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-86",
            "type": "idea",
            "content": "87. A program that checks the properties of a function that generates all possible combinations of a set of elements.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-87",
            "type": "idea",
            "content": "88. A program that verifies the implementation of an algorithm that solves the knapsack problem using a greedy approach.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-88",
            "type": "idea",
            "content": "89. A program that ensures a function that calculates the Hamming distance between two strings is correct.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-89",
            "type": "idea",
            "content": "90. A program that verifies the correctness of a function that performs addition of two large integers stored as strings.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-90",
            "type": "idea",
            "content": "91. A program that confirms the correctness of a function that computes the nth triangular number.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-91",
            "type": "idea",
            "content": "92. A program that verifies the implementation of a function that shuffles an array using the Fisher-Yates algorithm.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-92",
            "type": "idea",
            "content": "93. A program that checks the correctness of a function that determines if a point lies inside a given polygon.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-93",
            "type": "idea",
            "content": "94. A program that verifies the correctness of a function that implements the A* search algorithm for pathfinding.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-94",
            "type": "idea",
            "content": "95. A program that ensures an implementation of a function that calculates the Gini coefficient for a set of values.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-95",
            "type": "idea",
            "content": "96. A program that verifies the correctness of a function that finds the longest common prefix among a list of strings.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-96",
            "type": "idea",
            "content": "97. A program that confirms the correctness of an algorithm that calculates the eigenvalues of a matrix using the QR algorithm.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-97",
            "type": "idea",
            "content": "98. A program that verifies the implementation of a function that finds all bridges in an undirected graph.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-98",
            "type": "idea",
            "content": "99. A program that checks the properties of a function that generates Fibonacci numbers using matrix exponentiation.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-99",
            "type": "idea",
            "content": "100. A program that verifies the correctness of a function that generates a random permutation of an array, ensuring each permutation is equally likely.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "d2b17135-3231-42b5-822d-aea7cce9e61b",
            "type": "program",
            "content": "method SimulateMontyHallSwitch(numTrials: nat) returns (winProbability: real)\n  requires numTrials > 0\n  ensures 0.0 <= winProbability <= 1.0\n{\n  var wins := 0;\n  var trials := 0;\n  while trials < numTrials\n    invariant 0 <= trials <= numTrials\n    invariant 0 <= wins <= trials\n  {\n    // Simulate a single trial of the Monty Hall problem with switching\n    var prizeDoor := trials % 3; // Assume prize is behind door 0, 1, or 2\n    var chosenDoor := (trials + 1) % 3; // Player's initial choice\n    // Player always switches, so they win if their initial choice was not the prize door\n    if chosenDoor != prizeDoor {\n      wins := wins + 1;\n    }\n    trials := trials + 1;\n  }\n  winProbability := wins as real / numTrials as real;\n}",
            "parents": [
                "idea-60"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "SUCCESS"
            }
        },
        {
            "id": "a695d42b-636a-4b6b-8ef8-9cce677f5da1",
            "type": "program",
            "content": "method IsPerfectSquare(n: nat) returns (result: bool)\n  ensures result == (exists k: nat :: k * k == n)\n{\n  var k: nat := 0;\n  result := false;\n  while k * k <= n\n    invariant 0 <= k <= n + 1\n    invariant forall i: nat :: 0 <= i < k ==> i * i != n\n  {\n    if k * k == n {\n      result := true;\n      return;\n    }\n    k := k + 1;\n  }\n}",
            "parents": [
                "idea-80"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "c980037e-b846-4ab2-9e88-d0a63d54dd1c",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i: int :: 0 <= i < length ==> (forall j: int :: 0 <= j < i ==> arr[j] < arr[i])\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis: array<int> := new int[n];\n  for i := 0 to n - 1 {\n    lis[i] := 1;\n  }\n  for i := 1 to n - 1\n    invariant 1 <= i <= n\n    invariant forall k: int :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n  {\n    for j := 0 to i - 1\n      invariant 0 <= j <= i - 1\n      invariant forall k: int :: 0 <= k < j ==> arr[k] < arr[j] ==> lis[k] <= lis[j]\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n    }\n  }\n  length := 0;\n  for i := 0 to n - 1\n    invariant 0 <= i <= n\n    invariant 0 <= length <= i\n  {\n    if lis[i] > length {\n      length := lis[i];\n    }\n  }\n}",
            "parents": [
                "idea-58"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "0531bc00-ee02-4b47-b00c-5cf1fb944264",
            "type": "program",
            "content": "class Vector3D {\n  var x: int\n  var y: int\n  var z: int\n  constructor(x: int, y: int, z: int) \n    ensures this.x == x && this.y == y && this.z == z\n  {\n    this.x := x;\n    this.y := y;\n    this.z := z;\n  }\n  method CrossProduct(other: Vector3D) returns (result: Vector3D)\n    ensures result.x == this.y * other.z - this.z * other.y\n    ensures result.y == this.z * other.x - this.x * other.z\n    ensures result.z == this.x * other.y - this.y * other.x\n  {\n    var cx := this.y * other.z - this.z * other.y;\n    var cy := this.z * other.x - this.x * other.z;\n    var cz := this.x * other.y - this.y * other.x;\n    result := new Vector3D(cx, cy, cz);\n  }\n}",
            "parents": [
                "idea-99"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "SUCCESS"
            }
        },
        {
            "id": "7dd7dcfd-6654-459a-a74a-17572d0913de",
            "type": "program",
            "content": "method ComputeTriangularNumber(n: nat) returns (t: nat)\n  requires n >= 0\n  ensures t == n * (n + 1) / 2\n{\n  var sum := 0;\n  var i := 0;\n  while i <= n\n    invariant 0 <= i <= n + 1\n    invariant sum == i * (i - 1) / 2\n  {\n    sum := sum + i;\n    i := i + 1;\n  }\n  t := sum;\n}",
            "parents": [
                "idea-90"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "SUCCESS"
            }
        },
        {
            "id": "794e1df6-3d8c-4b78-9124-c9b4a9af8a94",
            "type": "program",
            "content": "// A simple program to verify that a given configuration of queens on a chessboard is valid\n// i.e., no two queens attack each other.\nmethod IsValidQueenConfiguration(board: seq<seq<bool>>) returns (valid: bool)\n  requires |board| == 8 && forall row :: 0 <= row < |board| ==> |board[row]| == 8\n  ensures valid == true <==> (forall i, j, k, l :: 0 <= i < 8 && 0 <= j < 8 && 0 <= k < 8 && 0 <= l < 8 && board[i][j] && board[k][l] ==> (i == k && j == l) || (i != k && j != l && i - j != k - l && i + j != k + l))\n{\n  valid := true;\n  var n := 8;\n  // Check each pair of queens to ensure they do not attack each other\n  for i := 0 to n - 1 {\n    for j := 0 to n - 1 {\n      if board[i][j] {\n        for k := 0 to n - 1 {\n          for l := 0 to n - 1 {\n            if board[k][l] && (i != k || j != l) {\n              // Check if they are in the same row, column, or diagonal\n              if i == k || j == l || i - j == k - l || i + j == k + l {\n                valid := false;\n                return;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
            "parents": [
                "idea-71"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "42a245c5-087e-49a8-a953-173c5572d97b",
            "type": "program",
            "content": "method IsPerfectSquare(n: nat) returns (result: bool)\n  ensures result == (exists k: nat :: k * k == n)\n{\n  var k: nat := 0;\n  result := false;\n  while k * k <= n\n    invariant 0 <= k <= n + 1\n    invariant forall i: nat :: 0 <= i < k ==> i * i != n\n    invariant result == (exists i: nat :: 0 <= i < k && i * i == n)\n  {\n    if k * k == n {\n      result := true;\n      return;\n    }\n    k := k + 1;\n  }\n  assert forall i: nat :: 0 <= i < k ==> i * i != n;\n}",
            "parents": [
                "a695d42b-636a-4b6b-8ef8-9cce677f5da1"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "SUCCESS"
            }
        },
        {
            "id": "idea-100",
            "type": "idea",
            "content": "101. A program that checks the implementation of an AVL tree, ensuring that all operations maintain the tree's balanced property.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-101",
            "type": "idea",
            "content": "102. A program that confirms the correctness of a function that implements a simple cryptographic hash function, ensuring consistent output for identical inputs.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-102",
            "type": "idea",
            "content": "103. A program that verifies the correctness of a function that calculates the intersection area of two overlapping rectangles.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-103",
            "type": "idea",
            "content": "104. A program that checks the properties of a function that evaluates postfix expressions, ensuring correct operator precedence and evaluation.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-104",
            "type": "idea",
            "content": "105. A program that verifies the implementation of a trie data structure, ensuring correct insertion, deletion, and search operations.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-105",
            "type": "idea",
            "content": "106. A program that confirms the correctness of a function that computes the greatest common divisor of multiple integers using a generalization of the Euclidean method.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-106",
            "type": "idea",
            "content": "107. A program that ensures the correctness of a function that finds the maximum product of a contiguous subarray.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-107",
            "type": "idea",
            "content": "108. A program that verifies the implementation of a function that performs radix sort on a list of integers.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-108",
            "type": "idea",
            "content": "109. A program that checks the correctness of a function that calculates the cosine similarity between two vectors.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-109",
            "type": "idea",
            "content": "110. A program that confirms the correctness of an algorithm that generates all valid combinations of n pairs of parentheses.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-110",
            "type": "idea",
            "content": "111. A program that verifies the properties of a function that implements a simple neural network forward pass.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-111",
            "type": "idea",
            "content": "112. A program that ensures the correctness of a function that calculates the shortest path in a weighted grid, accounting for obstacles.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-112",
            "type": "idea",
            "content": "113. A program that verifies a function that models predator-prey dynamics using the Lotka-Volterra equations.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-113",
            "type": "idea",
            "content": "114. A program that checks the correctness of a function that calculates the sum of all even Fibonacci numbers up to a given limit.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-114",
            "type": "idea",
            "content": "115. A program that confirms the correctness of a function that generates a spanning tree using Prim's algorithm.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-115",
            "type": "idea",
            "content": "116. A program that verifies the implementation of a function that simulates a simple random walk in two dimensions.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-116",
            "type": "idea",
            "content": "117. A program that ensures the correctness of a function that calculates the harmonic mean of a list of numbers.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-117",
            "type": "idea",
            "content": "118. A program that verifies the properties of a function that converts infix expressions to postfix notation.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-118",
            "type": "idea",
            "content": "119. A program that checks the correctness of a function that generates all possible palindromic subsequences of a string.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-119",
            "type": "idea",
            "content": "120. A program that confirms the correctness of a function that performs matrix exponentiation efficiently using squaring.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-120",
            "type": "idea",
            "content": "121. A program that verifies the implementation of a function that calculates the cumulative distribution function of a normal distribution.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-121",
            "type": "idea",
            "content": "122. A program that ensures the correctness of a function that performs Huffman encoding on a set of characters.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-122",
            "type": "idea",
            "content": "123. A program that verifies a function that implements the simplex algorithm for solving linear programming problems.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-123",
            "type": "idea",
            "content": "124. A program that checks the properties of a function that determines the number of connected components in a graph.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-124",
            "type": "idea",
            "content": "125. A program that confirms the correctness of a function that calculates the running median of a stream of integers.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-125",
            "type": "idea",
            "content": "126. A program that verifies the implementation of a function that calculates the geometric mean of a set of numbers.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-126",
            "type": "idea",
            "content": "127. A program that ensures the correctness of a function that solves the n-rooks problem, ensuring no two rooks attack each other.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-127",
            "type": "idea",
            "content": "128. A program that verifies a function that implements the Boyer-Moore string search algorithm for efficient pattern matching.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-128",
            "type": "idea",
            "content": "129. A program that checks the correctness of a function that calculates the volume of a tetrahedron given its vertices.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-129",
            "type": "idea",
            "content": "130. A program that confirms the correctness of a function that performs binary exponentiation for fast power computation.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-130",
            "type": "idea",
            "content": "131. A program that verifies the implementation of a function that solves systems of linear equations using matrix inversion.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-131",
            "type": "idea",
            "content": "132. A program that ensures the correctness of a function that calculates the entropy of a set of probabilities.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-132",
            "type": "idea",
            "content": "133. A program that verifies the properties of a function that performs convolution on two discrete sequences.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-133",
            "type": "idea",
            "content": "134. A program that checks the correctness of a function that generates all possible binary trees with a given number of nodes.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-134",
            "type": "idea",
            "content": "135. A program that confirms the correctness of a function that calculates the convex hull using the gift wrapping algorithm.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-135",
            "type": "idea",
            "content": "136. A program that verifies the implementation of a function that simulates a basic cellular automaton like Conway's Game of Life.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-136",
            "type": "idea",
            "content": "137. A program that ensures the correctness of a function that calculates the number of inversions in an array.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-137",
            "type": "idea",
            "content": "138. A program that verifies a function that implements a basic sentiment analysis algorithm on text data.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-138",
            "type": "idea",
            "content": "139. A program that checks the properties of a function that performs depth-first traversal on a tree, ensuring correct visitation order.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-139",
            "type": "idea",
            "content": "140. A program that confirms the correctness of a function that calculates the dot product of two matrices.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-140",
            "type": "idea",
            "content": "141. A program that verifies the implementation of a function that finds the longest path in a directed acyclic graph.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-141",
            "type": "idea",
            "content": "142. A program that ensures the correctness of a function that determines if a given sequence of operations is valid for a stack.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-142",
            "type": "idea",
            "content": "143. A program that verifies a function that efficiently finds the kth smallest element in an unsorted array.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-143",
            "type": "idea",
            "content": "144. A program that checks the correctness of a function that calculates the area of intersection between two circles.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-144",
            "type": "idea",
            "content": "145. A program that confirms the correctness of a function that determines if a graph contains a cycle.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-145",
            "type": "idea",
            "content": "146. A program that verifies the implementation of a function that performs K-means clustering on a set of data points.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-146",
            "type": "idea",
            "content": "147. A program that ensures the correctness of a function that computes the intersection of two sets using hash tables.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-147",
            "type": "idea",
            "content": "148. A program that verifies a function that implements a priority queue using a binary search tree.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-148",
            "type": "idea",
            "content": "149. A program that checks the correctness of a function that calculates the average path length of a given tree.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-149",
            "type": "idea",
            "content": "150. A program that confirms the correctness of a function that generates all minimal vertex covers of a graph.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-150",
            "type": "idea",
            "content": "151. A program that verifies the implementation of a function that calculates the nth number in the Padovan sequence.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-151",
            "type": "idea",
            "content": "152. A program that ensures the correctness of a function that solves a given maze using a backtracking algorithm.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-152",
            "type": "idea",
            "content": "153. A program that verifies the properties of a function that calculates the Chebyshev distance between two points.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-153",
            "type": "idea",
            "content": "154. A program that checks the correctness of a function that implements a simple finite state machine for pattern recognition.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-154",
            "type": "idea",
            "content": "155. A program that confirms the correctness of a function that calculates the number of derangements of a set.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-155",
            "type": "idea",
            "content": "156. A program that verifies the implementation of a function that performs a circular convolution on two sequences.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-156",
            "type": "idea",
            "content": "157. A program that ensures the correctness of a function that determines the edit distance between two sequences using Wagner-Fischer algorithm.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-157",
            "type": "idea",
            "content": "158. A program that verifies a function that calculates the number of trailing zeros in a factorial.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-158",
            "type": "idea",
            "content": "159. A program that checks the correctness of a function that finds the centroid of a complex polygon.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-159",
            "type": "idea",
            "content": "160. A program that confirms the correctness of a function that implements a simple genetic algorithm for optimization.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-160",
            "type": "idea",
            "content": "161. A program that verifies the implementation of a function that calculates the volume of an n-dimensional hypercube.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-161",
            "type": "idea",
            "content": "162. A program that ensures the correctness of a function that solves the coin change problem using a greedy strategy.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-162",
            "type": "idea",
            "content": "163. A program that verifies the properties of a function that models simple harmonic motion.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-163",
            "type": "idea",
            "content": "164. A program that checks the correctness of a function that calculates the number of spanning trees in a graph using Kirchhoff's theorem.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-164",
            "type": "idea",
            "content": "165. A program that confirms the correctness of a function that finds all Hamiltonian paths in a graph.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-165",
            "type": "idea",
            "content": "166. A program that verifies the implementation of a function that performs polynomial regression on a dataset.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-166",
            "type": "idea",
            "content": "167. A program that ensures the correctness of a function that calculates the nth Lucas number using a recursive approach.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-167",
            "type": "idea",
            "content": "168. A program that verifies a function that implements a simple queue using two stacks.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-168",
            "type": "idea",
            "content": "169. A program that checks the correctness of a function that calculates the determinant of a sparse matrix.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-169",
            "type": "idea",
            "content": "170. A program that confirms the correctness of a function that generates random graphs using the Erd\u0151s\u2013R\u00e9nyi model.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-170",
            "type": "idea",
            "content": "171. A program that verifies the implementation of a function that performs run-length encoding on a sequence of characters.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-171",
            "type": "idea",
            "content": "172. A program that ensures the correctness of a function that determines if a word can be formed by characters on a Boggle board.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-172",
            "type": "idea",
            "content": "173. A program that verifies a function that calculates the longest path in a binary tree without repeating nodes.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-173",
            "type": "idea",
            "content": "174. A program that checks the correctness of a function that performs orthogonalization of vectors using the Gram-Schmidt process.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-174",
            "type": "idea",
            "content": "175. A program that confirms the correctness of a function that simulates the spread of an infection on a grid using cellular automata.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-175",
            "type": "idea",
            "content": "176. A program that verifies the implementation of a function that calculates the number of partitions of a number.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-176",
            "type": "idea",
            "content": "177. A program that ensures the correctness of a function that finds all cycles in a directed graph.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-177",
            "type": "idea",
            "content": "178. A program that verifies the properties of a function that calculates the cross-correlation of two signals.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-178",
            "type": "idea",
            "content": "179. A program that checks the correctness of a function that generates all permutations of a multiset.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-179",
            "type": "idea",
            "content": "180. A program that confirms the correctness of a function that solves the knight's tour problem on a chessboard.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-180",
            "type": "idea",
            "content": "181. A program that verifies the implementation of a function that performs binary search on a rotated sorted array.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-181",
            "type": "idea",
            "content": "182. A program that ensures the correctness of a function that calculates the number of unique binary search trees for a given number of nodes.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-182",
            "type": "idea",
            "content": "183. A program that verifies a function that implements an LRU cache using a doubly linked list and a hash map.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-183",
            "type": "idea",
            "content": "184. A program that checks the correctness of a function that calculates the eigenvectors of a matrix.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-184",
            "type": "idea",
            "content": "185. A program that confirms the correctness of a function that determines if two graphs are isomorphic.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-185",
            "type": "idea",
            "content": "186. A program that verifies the implementation of a function that performs symbolic differentiation of algebraic expressions.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-186",
            "type": "idea",
            "content": "187. A program that ensures the correctness of a function that models population growth using the logistic equation.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-187",
            "type": "idea",
            "content": "188. A program that verifies a function that calculates the number of ways to tile a 2xn board with 2x1 dominoes.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-188",
            "type": "idea",
            "content": "189. A program that checks the correctness of a function that calculates the spectral radius of a matrix.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-189",
            "type": "idea",
            "content": "190. A program that confirms the correctness of a function that performs text segmentation on a string using dynamic programming.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-190",
            "type": "idea",
            "content": "191. A program that verifies the implementation of a function that simulates a basic particle system in 2D space.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-191",
            "type": "idea",
            "content": "192. A program that ensures the correctness of a function that calculates the number of ways to climb a staircase with variable step sizes.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-192",
            "type": "idea",
            "content": "193. A program that verifies a function that implements a basic perceptron learning algorithm for binary classification.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-193",
            "type": "idea",
            "content": "194. A program that checks the correctness of a function that calculates the maximum clique size in a graph.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-194",
            "type": "idea",
            "content": "195. A program that confirms the correctness of a function that generates all Steiner trees for a given set of points.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-195",
            "type": "idea",
            "content": "196. A program that verifies the implementation of a function that performs spectral clustering on a graph.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-196",
            "type": "idea",
            "content": "197. A program that ensures the correctness of a function that simulates a Markov chain given a transition matrix.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-197",
            "type": "idea",
            "content": "198. A program that verifies a function that calculates the number of paths through a grid with weighted edges.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "idea-198",
            "type": "idea",
            "content": "199. A program that checks the correctness of a function that simulates a simple queueing system using discrete event simulation.",
            "parents": [
                "root"
            ],
            "statistics": {},
            "properties": {}
        },
        {
            "id": "105af003-9dd9-47a7-b9ee-1f7c1a96c6e4",
            "type": "program",
            "content": "method SimulateMontyHallSwitch(numTrials: nat) returns (winProbability: real)\n  requires numTrials > 0\n  ensures 0.0 <= winProbability <= 1.0\n{\n  var wins := 0;\n  var trials := 0;\n  while trials < numTrials\n    invariant 0 <= trials <= numTrials\n    invariant 0 <= wins <= trials\n  {\n    // Simulate a single trial of the Monty Hall problem with switching\n    var carDoor := trials % 3; // Assume car is behind door 0, 1, or 2\n    var chosenDoor := (trials + 1) % 3; // Contestant's initial choice\n    // If the contestant switches, they win if their initial choice was wrong\n    if chosenDoor != carDoor {\n      wins := wins + 1;\n    }\n    trials := trials + 1;\n  }\n  winProbability := wins as real / numTrials as real;\n}",
            "parents": [
                "idea-60"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "SUCCESS"
            }
        },
        {
            "id": "f390dd04-9155-464e-b156-a9079e20eb98",
            "type": "program",
            "content": "method IsPerfectSquare(n: nat) returns (result: bool)\n  ensures result <==> exists k: nat :: k * k == n\n{\n  var k: nat := 0;\n  result := false;\n  while k * k <= n\n    invariant 0 <= k <= n + 1\n    invariant forall i: nat :: 0 <= i < k ==> i * i != n\n  {\n    if k * k == n {\n      result := true;\n      return;\n    }\n    k := k + 1;\n  }\n}",
            "parents": [
                "idea-80"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "4625c197-546d-449c-ac06-6ed45dcf8f1f",
            "type": "program",
            "content": "method Swap(a: array<int>, i: int, j: int)\n  requires 0 <= i < a.Length && 0 <= j < a.Length\n  modifies a\n  ensures a[i] == old(a[j]) && a[j] == old(a[i]) && (forall k :: k != i && k != j ==> a[k] == old(a[k]))\n{\n  var temp := a[i];\n  a[i] := a[j];\n  a[j] := temp;\n}\nmethod Shuffle(a: array<int>)\n  requires a.Length > 0\n  modifies a\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures (forall i, j :: 0 <= i < j < a.Length ==> a[i] != a[j])\n{\n  var n := a.Length;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    {\n      var j := i + (if n - i == 1 then 0 else (n - i) % (n - i));\n      Swap(a, i, j);\n      i := i + 1;\n    }\n}",
            "parents": [
                "idea-99"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "bb5ab683-8962-4f77-82e2-290c9cbc8c62",
            "type": "program",
            "content": "// A Dafny program to calculate the area of a simple polygon using the Shoelace formula.\nmethod CalculatePolygonArea(vertices: seq<(real, real)>) returns (area: real)\n  requires |vertices| >= 3 // A polygon must have at least 3 vertices\n  requires vertices[0] == vertices[|vertices| - 1] // The polygon must be closed\n  ensures area >= 0.0\n{\n  var n := |vertices| - 1;\n  var sum1 := 0.0;\n  var sum2 := 0.0;\n  // Loop through each vertex and apply the Shoelace formula\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant sum1 == sum1 + sum2\n  {\n    sum1 := sum1 + vertices[i].0 * vertices[i + 1].1;\n    sum2 := sum2 + vertices[i + 1].0 * vertices[i].1;\n    i := i + 1;\n  }\n  area := 0.5 * (sum1 - sum2);\n}",
            "parents": [
                "idea-78"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "3803a3ca-da34-4a1b-8cf7-61aa3bb9676f",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n}",
            "parents": [
                "idea-18"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "5d87e78b-9ce9-4aeb-b2c9-d38c121a2aa5",
            "type": "program",
            "content": "method QuickSort(a: array<int>, lo: int, hi: int)\n  requires 0 <= lo <= hi <= a.Length\n  modifies a\n  ensures forall i, j :: lo <= i <= j < hi ==> a[i] <= a[j]\n{\n  if lo < hi {\n    var p := Partition(a, lo, hi);\n    QuickSort(a, lo, p);\n    QuickSort(a, p + 1, hi);\n  }\n}\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIndex: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIndex < hi\n  ensures forall i :: lo <= i < pivotIndex ==> a[i] <= a[pivotIndex]\n  ensures forall i :: pivotIndex < i < hi ==> a[pivotIndex] <= a[i]\n{\n  var pivot := a[lo];\n  var i := lo;\n  var j := hi;\n  while i < j\n    invariant lo <= i <= j <= hi\n    invariant forall k :: lo <= k < i ==> a[k] <= pivot\n    invariant forall k :: j <= k < hi ==> a[k] >= pivot\n  {\n    while i < j && a[i] <= pivot\n      invariant lo <= i < hi\n      invariant forall k :: lo <= k < i ==> a[k] <= pivot\n    {\n      i := i + 1;\n    }\n    while i < j && a[j - 1] >= pivot\n      invariant lo < j <= hi\n      invariant forall k :: j <= k < hi ==> a[k] >= pivot\n    {\n      j := j - 1;\n    }\n    if i < j {\n      a[i], a[j - 1] := a[j - 1], a[i];\n    }\n  }\n  pivotIndex := j - 1;\n  a[lo], a[pivotIndex] := a[pivotIndex], a[lo];\n}",
            "parents": [
                "idea-28"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "775329f6-3267-4f17-b9d7-56f5fe0f1959",
            "type": "program",
            "content": "method DotProduct(a: seq<int>, b: seq<int>) returns (result: int)\n  requires |a| == |b|\n  ensures result == DotProductSpec(a, b)\n{\n  var sum := 0;\n  var i := 0;\n  while i < |a|\n    invariant 0 <= i <= |a|\n    invariant sum == DotProductSpec(a[..i], b[..i])\n  {\n    sum := sum + a[i] * b[i];\n    i := i + 1;\n  }\n  result := sum;\n}\nfunction DotProductSpec(a: seq<int>, b: seq<int>): int\n  requires |a| == |b|\n{\n  if |a| == 0 then 0 else a[0] * b[0] + DotProductSpec(a[1..], b[1..])\n}",
            "parents": [
                "idea-76"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "c48e1814-ca50-4b6e-b86c-3be0ef5feb3b",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "idea-142"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "461a19c5-2dee-4ed7-b53d-1a140c742aa9",
            "type": "program",
            "content": "class Rectangle {\n  var x1: int;\n  var y1: int;\n  var x2: int;\n  var y2: int;\n  constructor(x1: int, y1: int, x2: int, y2: int)\n    requires x1 <= x2 && y1 <= y2\n  {\n    this.x1 := x1;\n    this.y1 := y1;\n    this.x2 := x2;\n    this.y2 := y2;\n  }\n}\nmethod IntersectionArea(r1: Rectangle, r2: Rectangle) returns (area: int)\n  ensures area >= 0\n{\n  var ix1 := if r1.x1 > r2.x1 then r1.x1 else r2.x1;\n  var iy1 := if r1.y1 > r2.y1 then r1.y1 else r2.y1;\n  var ix2 := if r1.x2 < r2.x2 then r1.x2 else r2.x2;\n  var iy2 := if r1.y2 < r2.y2 then r1.y2 else r2.y2;\n  if ix1 < ix2 && iy1 < iy2 {\n    var width := ix2 - ix1;\n    var height := iy2 - iy1;\n    area := width * height;\n  } else {\n    area := 0;\n  }\n}",
            "parents": [
                "idea-102"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "SUCCESS"
            }
        },
        {
            "id": "a992a39d-f971-4a83-9b44-f7d6b173928e",
            "type": "program",
            "content": "class Graph {\n  var adjacencyMatrix: array2<bool>;\n  constructor(n: nat) \n    requires n > 0\n    ensures adjacencyMatrix.Length0 == n && adjacencyMatrix.Length1 == n\n  {\n    adjacencyMatrix := new bool[n, n];\n  }\n  method AddEdge(u: nat, v: nat)\n    requires 0 <= u < adjacencyMatrix.Length0 && 0 <= v < adjacencyMatrix.Length1\n    ensures adjacencyMatrix[u, v] == true && adjacencyMatrix[v, u] == true\n  {\n    adjacencyMatrix[u, v] := true;\n    adjacencyMatrix[v, u] := true;\n  }\n  method CountConnectedComponents() returns (count: nat)\n    ensures 0 <= count <= adjacencyMatrix.Length0\n  {\n    var visited := new bool[adjacencyMatrix.Length0];\n    count := 0;\n    for i := 0 to adjacencyMatrix.Length0\n      invariant 0 <= i <= adjacencyMatrix.Length0\n      invariant count <= i\n      invariant forall j: nat :: 0 <= j < i ==> visited[j]\n    {\n      if (!visited[i]) {\n        count := count + 1;\n        ExploreComponent(i, visited);\n      }\n    }\n  }\n  method ExploreComponent(node: nat, visited: array<bool>)\n    requires 0 <= node < adjacencyMatrix.Length0\n    modifies visited\n    ensures visited[node]\n  {\n    visited[node] := true;\n    for j := 0 to adjacencyMatrix.Length1\n      invariant 0 <= j <= adjacencyMatrix.Length1\n      invariant visited[node]\n      invariant forall k: nat :: 0 <= k < j ==> (adjacencyMatrix[node, k] ==> visited[k])\n    {\n      if (adjacencyMatrix[node, j] && !visited[j]) {\n        ExploreComponent(j, visited);\n      }\n    }\n  }\n}",
            "parents": [
                "idea-123"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "SUCCESS"
            }
        },
        {
            "id": "c38461f0-ed34-4bda-9e59-64250a060952",
            "type": "program",
            "content": "method IsValidStackSequence(operations: seq<string>) returns (isValid: bool)\n  ensures isValid == (forall i :: 0 <= i < |operations| ==> operations[i] == \"push\" || operations[i] == \"pop\")\n{\n  var stackSize := 0;\n  isValid := true;\n  // Loop through each operation in the sequence\n  for i := 0 to |operations| \n    invariant 0 <= stackSize\n    invariant 0 <= i <= |operations|\n    invariant isValid == (forall j :: 0 <= j < i ==> operations[j] == \"push\" || operations[j] == \"pop\")\n  {\n    if operations[i] == \"push\" {\n      stackSize := stackSize + 1;\n    } else if operations[i] == \"pop\" {\n      if stackSize == 0 {\n        isValid := false;\n        return;\n      }\n      stackSize := stackSize - 1;\n    } else {\n      isValid := false;\n      return;\n    }\n  }\n}",
            "parents": [
                "idea-141"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "3c2f899e-79cd-47ea-ae6e-93786ee03d82",
            "type": "program",
            "content": "method SieveOfEratosthenes(limit: nat) returns (primes: seq<bool>)\n  requires limit >= 2\n  ensures |primes| == limit + 1\n  ensures forall i :: 2 <= i <= limit ==> primes[i] <==> (forall j :: 2 <= j * j <= i ==> i % j != 0)\n{\n  var isPrime := new bool[limit + 1];\n  isPrime[0], isPrime[1] := false, false;\n  for i := 2 to limit {\n    isPrime[i] := true;\n  }\n  var p := 2;\n  while p * p <= limit\n    invariant 2 <= p <= limit\n    invariant forall i :: 2 <= i < p ==> isPrime[i] <==> (forall j :: 2 <= j * j <= i ==> i % j != 0)\n  {\n    if isPrime[p] {\n      var multiple := p * p;\n      while multiple <= limit\n        invariant p * p <= multiple <= limit + 1\n        invariant forall k :: p * p <= k < multiple ==> !isPrime[k]\n      {\n        isPrime[multiple] := false;\n        multiple := multiple + p;\n      }\n    }\n    p := p + 1;\n  }\n  primes := isPrime[..];\n}",
            "parents": [
                "idea-42"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "1b42a007-47ee-4da1-b6fd-eb3739294b97",
            "type": "program",
            "content": "// A simple Dafny program to calculate the derivative of a polynomial\n// represented as a list of coefficients. The polynomial is of the form:\n// a_n * x^n + a_(n-1) * x^(n-1) + ... + a_1 * x + a_0\n// The derivative is: n * a_n * x^(n-1) + (n-1) * a_(n-1) * x^(n-2) + ... + a_1\nmethod Derivative(coefficients: seq<int>) returns (derivative: seq<int>)\n  requires |coefficients| > 0\n  ensures |derivative| == if |coefficients| == 1 then 0 else |coefficients| - 1\n  ensures forall i :: 0 <= i < |derivative| ==> derivative[i] == coefficients[i + 1] * (i + 1)\n{\n  var n := |coefficients|;\n  derivative := [];\n  var i := 0;\n  while i < n - 1\n    invariant 0 <= i <= n - 1\n    invariant |derivative| == i\n    invariant forall j :: 0 <= j < i ==> derivative[j] == coefficients[j + 1] * (j + 1)\n  {\n    derivative := derivative + [coefficients[i + 1] * (i + 1)];\n    i := i + 1;\n  }\n}",
            "parents": [
                "idea-72"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "SUCCESS"
            }
        },
        {
            "id": "f02c5b3b-595c-47dd-a214-6b33fa06bb15",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n}",
            "parents": [
                "idea-58"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "a92e7690-11b6-4313-bd30-b0bc25d2c798",
            "type": "program",
            "content": "class Queue {\n  var elements: seq<int>\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(x: int) \n    modifies this\n    ensures elements == old(elements) + [x]\n  {\n    elements := elements + [x];\n  }\n  method Dequeue() returns (x: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements)[1..]\n    ensures x == old(elements)[0]\n  {\n    x := elements[0];\n    elements := elements[1..];\n  }\n  method IsEmpty() returns (b: bool)\n    ensures b == (|elements| == 0)\n  {\n    b := |elements| == 0;\n  }\n}\nmethod SimulateQueueingSystem(events: seq<int>) returns (finalState: seq<int>)\n  requires |events| > 0\n  ensures forall i :: 0 <= i < |events| ==> events[i] >= 0\n  ensures finalState == events\n{\n  var queue := new Queue();\n  var i := 0;\n  while i < |events|\n    invariant 0 <= i <= |events|\n    invariant queue.elements == events[..i]\n  {\n    queue.Enqueue(events[i]);\n    i := i + 1;\n  }\n  finalState := queue.elements;\n}",
            "parents": [
                "idea-198"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "72eb909a-6167-45a1-b200-60174427201a",
            "type": "program",
            "content": "method Transpose(matrix: array2<int>) returns (transposed: array2<int>)\n  requires matrix.Length0 > 0 && matrix.Length1 > 0\n  ensures transposed.Length0 == matrix.Length1 && transposed.Length1 == matrix.Length0\n  ensures forall i: int, j: int :: 0 <= i < matrix.Length0 && 0 <= j < matrix.Length1 ==> transposed[j, i] == matrix[i, j]\n{\n  var rows := matrix.Length0;\n  var cols := matrix.Length1;\n  transposed := new int[cols, rows];\n  var i := 0;\n  while i < rows\n    invariant 0 <= i <= rows\n    invariant forall x: int, y: int :: 0 <= x < i && 0 <= y < cols ==> transposed[y, x] == matrix[x, y]\n  {\n    var j := 0;\n    while j < cols\n      invariant 0 <= j <= cols\n      invariant forall x: int, y: int :: 0 <= x < i && 0 <= y < cols ==> transposed[y, x] == matrix[x, y]\n      invariant forall y: int :: 0 <= y < j ==> transposed[y, i] == matrix[i, y]\n    {\n      transposed[j, i] := matrix[i, j];\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n}",
            "parents": [
                "idea-40"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "SUCCESS"
            }
        },
        {
            "id": "1143df66-397a-4f7b-adf4-e3f270d6fc69",
            "type": "program",
            "content": "class Graph {\n  var adjacencyMatrix: array2<bool>;\n  constructor(n: nat) \n    requires n > 0\n  {\n    adjacencyMatrix := new bool[n, n];\n  }\n  method AddEdge(u: nat, v: nat)\n    requires 0 <= u < adjacencyMatrix.Length0\n    requires 0 <= v < adjacencyMatrix.Length1\n    modifies adjacencyMatrix\n  {\n    adjacencyMatrix[u, v] := true;\n    adjacencyMatrix[v, u] := true;\n  }\n  method IsVertexCover(cover: set<nat>) returns (isCover: bool)\n    requires cover <= set i | 0 <= i < adjacencyMatrix.Length0\n    ensures isCover == (forall u, v :: 0 <= u < adjacencyMatrix.Length0 && 0 <= v < adjacencyMatrix.Length1 && adjacencyMatrix[u, v] ==> u in cover || v in cover)\n  {\n    isCover := true;\n    var n := adjacencyMatrix.Length0;\n    for u := 0 to n - 1 {\n      for v := 0 to n - 1 {\n        if adjacencyMatrix[u, v] && !(u in cover || v in cover) {\n          isCover := false;\n          return;\n        }\n      }\n    }\n  }\n}",
            "parents": [
                "idea-149"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "3291d6ca-287f-4e05-b19c-43387475fb33",
            "type": "program",
            "content": "method CoinChange(coins: seq<int>, amount: int) returns (minCoins: int)\n  requires amount >= 0\n  requires forall c :: c in coins ==> c > 0\n  ensures minCoins >= 0\n  ensures minCoins == -1 <==> (forall c :: c in coins ==> amount % c != 0)\n{\n  var dp := new int[amount + 1];\n  dp[0] := 0;\n  var i := 1;\n  while i <= amount\n    invariant 0 <= i <= amount + 1\n    invariant dp[0] == 0\n    invariant forall j :: 0 <= j < i ==> dp[j] >= 0\n  {\n    dp[i] := amount + 1; // Initialize with a large number\n    var j := 0;\n    while j < |coins|\n      invariant 0 <= j <= |coins|\n      invariant dp[i] >= 0\n    {\n      if i >= coins[j] {\n        dp[i] := if dp[i] < dp[i - coins[j]] + 1 then dp[i] else dp[i - coins[j]] + 1;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  minCoins := if dp[amount] > amount then -1 else dp[amount];\n}",
            "parents": [
                "idea-65"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "709ca822-2f78-4e0c-a3ed-b8f585224a28",
            "type": "program",
            "content": "method DotProduct(a: seq<int>, b: seq<int>) returns (result: int)\n  requires |a| == |b|\n  ensures result == DotProductSpec(a, b)\n{\n  var sum := 0;\n  var i := 0;\n  while i < |a|\n    invariant 0 <= i <= |a|\n    invariant sum == DotProductSpec(a[..i], b[..i])\n    decreases |a| - i\n  {\n    sum := sum + a[i] * b[i];\n    i := i + 1;\n  }\n  result := sum;\n}\n\nfunction DotProductSpec(a: seq<int>, b: seq<int>): int\n  requires |a| == |b|\n{\n  if |a| == 0 then 0 else a[0] * b[0] + DotProductSpec(a[1..], b[1..])\n}",
            "parents": [
                "775329f6-3267-4f17-b9d7-56f5fe0f1959"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "4cdc8acf-bd53-4262-9f62-d262ebc0d72c",
            "type": "program",
            "content": "class Graph {\n  var adjacencyMatrix: array2<bool>;\n\n  constructor(n: nat) \n    requires n > 0\n    ensures adjacencyMatrix.Length0 == n && adjacencyMatrix.Length1 == n\n    ensures forall i, j :: 0 <= i < n && 0 <= j < n ==> !adjacencyMatrix[i, j]\n  {\n    adjacencyMatrix := new bool[n, n];\n  }\n\n  method AddEdge(u: nat, v: nat)\n    requires 0 <= u < adjacencyMatrix.Length0\n    requires 0 <= v < adjacencyMatrix.Length1\n    modifies adjacencyMatrix\n    ensures adjacencyMatrix[u, v] && adjacencyMatrix[v, u]\n  {\n    adjacencyMatrix[u, v] := true;\n    adjacencyMatrix[v, u] := true;\n  }\n\n  method IsVertexCover(cover: set<nat>) returns (isCover: bool)\n    requires cover <= set i | 0 <= i < adjacencyMatrix.Length0\n    ensures isCover == (forall u, v :: 0 <= u < adjacencyMatrix.Length0 && 0 <= v < adjacencyMatrix.Length1 && adjacencyMatrix[u, v] ==> u in cover || v in cover)\n  {\n    isCover := true;\n    var n := adjacencyMatrix.Length0;\n    for u := 0 to n - 1 {\n      for v := 0 to n - 1 {\n        if adjacencyMatrix[u, v] && !(u in cover || v in cover) {\n          isCover := false;\n          return;\n        }\n      }\n    }\n  }\n}",
            "parents": [
                "1143df66-397a-4f7b-adf4-e3f270d6fc69"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "80d73ae5-7f58-4281-a992-fe4c56b9c1e4",
            "type": "program",
            "content": "method SieveOfEratosthenes(limit: nat) returns (primes: seq<bool>)\n  requires limit >= 2\n  ensures |primes| == limit + 1\n  ensures forall i :: 2 <= i <= limit ==> primes[i] <==> (forall j :: 2 <= j * j <= i ==> i % j != 0)\n{\n  var isPrime := new bool[limit + 1];\n  isPrime[0], isPrime[1] := false, false;\n  for i := 2 to limit {\n    isPrime[i] := true;\n  }\n  var p := 2;\n  while p * p <= limit\n    invariant 2 <= p <= limit + 1\n    invariant forall i :: 2 <= i < p ==> isPrime[i] <==> (forall j :: 2 <= j * j <= i ==> i % j != 0)\n    invariant forall i :: 2 <= i <= limit ==> (exists j :: 2 <= j <= i && j * j <= i && i % j == 0) ==> !isPrime[i]\n  {\n    if isPrime[p] {\n      var multiple := p * p;\n      while multiple <= limit\n        invariant p * p <= multiple <= limit + 1\n        invariant forall k :: p * p <= k < multiple ==> !isPrime[k]\n      {\n        isPrime[multiple] := false;\n        multiple := multiple + p;\n      }\n    }\n    p := p + 1;\n  }\n  primes := isPrime[..];\n}",
            "parents": [
                "3c2f899e-79cd-47ea-ae6e-93786ee03d82"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "7c9fc37e-728f-4760-ad6d-a39ce7ace19f",
            "type": "program",
            "content": "method QuickSort(a: array<int>, lo: int, hi: int)\n  requires 0 <= lo <= hi <= a.Length\n  modifies a\n  ensures forall i, j :: lo <= i <= j < hi ==> a[i] <= a[j]\n{\n  if lo < hi {\n    var p := Partition(a, lo, hi);\n    QuickSort(a, lo, p);\n    QuickSort(a, p + 1, hi);\n  }\n}\n\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIndex: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIndex < hi\n  ensures forall i :: lo <= i < pivotIndex ==> a[i] <= a[pivotIndex]\n  ensures forall i :: pivotIndex < i < hi ==> a[pivotIndex] <= a[i]\n{\n  var pivot := a[lo];\n  var i := lo;\n  var j := hi;\n  while i < j\n    invariant lo <= i <= j <= hi\n    invariant forall k :: lo <= k < i ==> a[k] <= pivot\n    invariant forall k :: j <= k < hi ==> a[k] >= pivot\n    invariant exists p :: lo <= p < hi && a[p] == pivot\n  {\n    while i < j && a[i] <= pivot\n      invariant lo <= i < hi\n      invariant forall k :: lo <= k < i ==> a[k] <= pivot\n    {\n      i := i + 1;\n    }\n    while i < j && a[j - 1] >= pivot\n      invariant lo < j <= hi\n      invariant forall k :: j <= k < hi ==> a[k] >= pivot\n    {\n      j := j - 1;\n    }\n    if i < j {\n      a[i], a[j - 1] := a[j - 1], a[i];\n    }\n  }\n  pivotIndex := j - 1;\n  a[lo], a[pivotIndex] := a[pivotIndex], a[lo];\n}",
            "parents": [
                "5d87e78b-9ce9-4aeb-b2c9-d38c121a2aa5"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "529870c8-8186-42dd-98a5-98af9652ac99",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n}",
            "parents": [
                "f02c5b3b-595c-47dd-a214-6b33fa06bb15"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "a70cb0fe-ec4d-4ece-91ef-0b8fa644633c",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n}",
            "parents": [
                "3803a3ca-da34-4a1b-8cf7-61aa3bb9676f"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "c813e2f0-990c-465b-93f8-4762adc8bcef",
            "type": "program",
            "content": "method IsPerfectSquare(n: nat) returns (result: bool)\n  ensures result <==> exists k: nat :: k * k == n\n{\n  var k: nat := 0;\n  result := false;\n  while k * k <= n\n    invariant 0 <= k <= n + 1\n    invariant forall i: nat :: 0 <= i < k ==> i * i != n\n    invariant result <==> exists i: nat :: 0 <= i < k && i * i == n\n  {\n    if k * k == n {\n      result := true;\n      return;\n    }\n    k := k + 1;\n  }\n}",
            "parents": [
                "f390dd04-9155-464e-b156-a9079e20eb98"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "a8ad60b1-b66c-4fb0-af2a-127cfc0876b2",
            "type": "program",
            "content": "method IsValidStackSequence(operations: seq<string>) returns (isValid: bool)\n  ensures isValid == (forall i :: 0 <= i < |operations| ==> operations[i] == \"push\" || operations[i] == \"pop\")\n{\n  var stackSize := 0;\n  isValid := true;\n  // Loop through each operation in the sequence\n  for i := 0 to |operations| \n    invariant 0 <= stackSize\n    invariant 0 <= i <= |operations|\n    invariant isValid == (forall j :: 0 <= j < i ==> operations[j] == \"push\" || operations[j] == \"pop\")\n    invariant isValid ==> (forall j :: 0 <= j < i ==> stackSize >= 0)\n  {\n    if operations[i] == \"push\" {\n      stackSize := stackSize + 1;\n    } else if operations[i] == \"pop\" {\n      if stackSize == 0 {\n        isValid := false;\n        return;\n      }\n      stackSize := stackSize - 1;\n    } else {\n      isValid := false;\n      return;\n    }\n  }\n}",
            "parents": [
                "c38461f0-ed34-4bda-9e59-64250a060952"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "f99cf830-6347-4cab-b3f3-1bdee2b7eefe",
            "type": "program",
            "content": "method IsPerfectSquare(n: nat) returns (result: bool)\n  ensures result == (exists k: nat :: k * k == n)\n{\n  var k: nat := 0;\n  result := false;\n  while k * k <= n\n    invariant 0 <= k <= n + 1\n    invariant forall i: nat :: 0 <= i < k ==> i * i != n\n    invariant result == (exists i: nat :: i < k && i * i == n)\n  {\n    if k * k == n {\n      result := true;\n      return;\n    }\n    k := k + 1;\n  }\n}",
            "parents": [
                "a695d42b-636a-4b6b-8ef8-9cce677f5da1"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "cd565c4a-6196-4c84-aef7-a5c2bd249fd8",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "c48e1814-ca50-4b6e-b86c-3be0ef5feb3b"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "8cf60b9e-c935-4e22-8b29-2539c9e0d327",
            "type": "program",
            "content": "method IsValidStackSequence(operations: seq<string>) returns (isValid: bool)\n  ensures isValid == (forall i :: 0 <= i < |operations| ==> operations[i] == \"push\" || operations[i] == \"pop\")\n{\n  var stackSize := 0;\n  isValid := true;\n  // Loop through each operation in the sequence\n  for i := 0 to |operations| \n    invariant 0 <= stackSize\n    invariant 0 <= i <= |operations|\n    invariant isValid == (forall j :: 0 <= j < i ==> operations[j] == \"push\" || operations[j] == \"pop\")\n    invariant isValid ==> (forall j :: 0 <= j < i ==> stackSize >= 0)\n  {\n    if operations[i] == \"push\" {\n      stackSize := stackSize + 1;\n    } else if operations[i] == \"pop\" {\n      if stackSize == 0 {\n        isValid := false;\n        return;\n      }\n      stackSize := stackSize - 1;\n    } else {\n      isValid := false;\n      return;\n    }\n  }\n  for i := 0 to |operations| \n    invariant 0 <= stackSize\n    invariant 0 <= i <= |operations|\n    invariant forall j :: 0 <= j < i ==> operations[j] == \"push\" || operations[j] == \"pop\"\n    invariant forall j :: 0 <= j < i && operations[j] == \"pop\" ==> (exists k :: 0 <= k < j && operations[k] == \"push\")\n  {\n    if operations[i] == \"push\" {\n      stackSize := stackSize + 1;\n    } else if operations[i] == \"pop\" {\n      if stackSize == 0 {\n        isValid := false;\n        return;\n      }\n      stackSize := stackSize - 1;\n    } else {\n      isValid := false;\n      return;\n    }\n  }\n  isValid := stackSize >= 0;\n}",
            "parents": [
                "a8ad60b1-b66c-4fb0-af2a-127cfc0876b2"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "17a3ca61-b1ce-4aa9-963b-3973756272b9",
            "type": "program",
            "content": "class Graph {\n  var adjacencyMatrix: array2<bool>;\n  constructor(n: nat) \n    requires n > 0\n  {\n    adjacencyMatrix := new bool[n, n];\n  }\n  method AddEdge(u: nat, v: nat)\n    requires 0 <= u < adjacencyMatrix.Length0\n    requires 0 <= v < adjacencyMatrix.Length1\n    modifies adjacencyMatrix\n  {\n    adjacencyMatrix[u, v] := true;\n    adjacencyMatrix[v, u] := true;\n  }\n  method IsVertexCover(cover: set<nat>) returns (isCover: bool)\n    requires cover <= set i | 0 <= i < adjacencyMatrix.Length0\n    ensures isCover == (forall u, v :: 0 <= u < adjacencyMatrix.Length0 && 0 <= v < adjacencyMatrix.Length1 && adjacencyMatrix[u, v] ==> u in cover || v in cover)\n  {\n    isCover := true;\n    var n := adjacencyMatrix.Length0;\n    for u := 0 to n - 1 {\n      for v := 0 to n - 1 {\n        if adjacencyMatrix[u, v] && !(u in cover || v in cover) {\n          isCover := false;\n          return;\n        }\n      }\n    }\n  }\nmethod IsCompleteGraph() returns (isComplete: bool)\n  ensures isComplete == (forall u, v :: 0 <= u < adjacencyMatrix.Length0 && 0 <= v < adjacencyMatrix.Length1 && u != v ==> adjacencyMatrix[u, v])\n{\n  isComplete := true;\n  var n := adjacencyMatrix.Length0;\n  for u := 0 to n - 1\n    invariant 0 <= u <= n\n    invariant isComplete == (forall i, j :: 0 <= i < u && 0 <= j < n && i != j ==> adjacencyMatrix[i, j])\n  {\n    for v := 0 to n - 1\n      invariant 0 <= v <= n\n      invariant isComplete == (forall i, j :: 0 <= i <= u && 0 <= j < v && i != j ==> adjacencyMatrix[i, j])\n    {\n      if u != v && !adjacencyMatrix[u, v] {\n        isComplete := false;\n        return;\n      }\n    }\n  }\n}\n}",
            "parents": [
                "1143df66-397a-4f7b-adf4-e3f270d6fc69"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "SUCCESS"
            }
        },
        {
            "id": "1b5f08f0-4d3d-46bb-8364-a8bf224e24f9",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n}",
            "parents": [
                "3803a3ca-da34-4a1b-8cf7-61aa3bb9676f"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "7e3e9e41-6ccf-4a82-9892-1fb294c88c1a",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n  ensures elements == old(elements)\n{\n  var i := 0;\n  var highestPriority := elements[0].0;\n  value := elements[0].1;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= highestPriority\n    invariant value == elements[0].1\n  {\n    if elements[i].0 < highestPriority {\n      highestPriority := elements[i].0;\n      value := elements[i].1;\n    }\n    i := i + 1;\n  }\n  assert value == elements[0].1;\n}\n}",
            "parents": [
                "a70cb0fe-ec4d-4ece-91ef-0b8fa644633c"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "bbe8dea4-a7fd-41c0-a9a1-84093df79fe4",
            "type": "program",
            "content": "// A simple program to verify that a given configuration of queens on a chessboard is valid\n// i.e., no two queens attack each other.\nmethod IsValidQueenConfiguration(board: seq<seq<bool>>) returns (valid: bool)\n  requires |board| == 8 && forall row :: 0 <= row < |board| ==> |board[row]| == 8\n  ensures valid == true <==> (forall i, j, k, l :: 0 <= i < 8 && 0 <= j < 8 && 0 <= k < 8 && 0 <= l < 8 && board[i][j] && board[k][l] ==> (i == k && j == l) || (i != k && j != l && i - j != k - l && i + j != k + l))\n{\n  valid := true;\n  var n := 8;\n  // Check each pair of queens to ensure they do not attack each other\n  for i := 0 to n - 1 {\n    for j := 0 to n - 1 {\n      if board[i][j] {\n        for k := 0 to n - 1 {\n          for l := 0 to n - 1 {\n            if board[k][l] && (i != k || j != l) {\n              // Check if they are in the same row, column, or diagonal\n              if i == k || j == l || i - j == k - l || i + j == k + l {\n                valid := false;\n                return;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  for i := 0 to n - 1\n    invariant 0 <= i <= n\n    invariant valid == true ==> (forall x, y :: 0 <= x < i && 0 <= y < n && board[x][y] ==> (forall a, b :: 0 <= a < n && 0 <= b < n && board[a][b] && (x != a || y != b) ==> x != a && y != b && x - y != a - b && x + y != a + b))\n  {\n    for j := 0 to n - 1\n      invariant 0 <= j <= n\n      invariant valid == true ==> (forall x, y :: 0 <= x <= i && 0 <= y < j && board[x][y] ==> (forall a, b :: 0 <= a < n && 0 <= b < n && board[a][b] && (x != a || y != b) ==> x != a && y != b && x - y != a - b && x + y != a + b))\n    {\n      if board[i][j] {\n        for k := 0 to n - 1\n          invariant 0 <= k <= n\n          invariant valid == true ==> (forall x, y :: 0 <= x <= i && 0 <= y <= j && board[x][y] ==> (forall a, b :: 0 <= a < k && 0 <= b < n && board[a][b] && (x != a || y != b) ==> x != a && y != b && x - y != a - b && x + y != a + b))\n        {\n          for l := 0 to n - 1\n            invariant 0 <= l <= n\n            invariant valid == true ==> (forall x, y :: 0 <= x <= i && 0 <= y <= j && board[x][y] ==> (forall a, b :: 0 <= a <= k && 0 <= b < l && board[a][b] && (x != a || y != b) ==> x != a && y != b && x - y != a - b && x + y != a + b))\n          {\n            if board[k][l] && (i != k || j != l) {\n              // Check if they are in the same row, column, or diagonal\n              if i == k || j == l || i - j == k - l || i + j == k + l {\n                valid := false;\n                return;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
            "parents": [
                "794e1df6-3d8c-4b78-9124-c9b4a9af8a94"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "672811ec-af0c-4014-a56f-9d8dfb71a0b5",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures elements == old(elements)\n  ensures value == old(elements[0].1)\n{\n  value := elements[0].1;\n}\n}",
            "parents": [
                "3803a3ca-da34-4a1b-8cf7-61aa3bb9676f"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "c8041bff-3eec-4f3b-b067-6bcba8c3d80f",
            "type": "program",
            "content": "class Vector3D {\n  var x: int\n  var y: int\n  var z: int\n  constructor(x: int, y: int, z: int) \n    ensures this.x == x && this.y == y && this.z == z\n  {\n    this.x := x;\n    this.y := y;\n    this.z := z;\n  }\n  method CrossProduct(other: Vector3D) returns (result: Vector3D)\n    ensures result.x == this.y * other.z - this.z * other.y\n    ensures result.y == this.z * other.x - this.x * other.z\n    ensures result.z == this.x * other.y - this.y * other.x\n  {\n    var cx := this.y * other.z - this.z * other.y;\n    var cy := this.z * other.x - this.x * other.z;\n    var cz := this.x * other.y - this.y * other.x;\n    result := new Vector3D(cx, cy, cz);\n  }\nmethod DotProduct(other: Vector3D) returns (result: int)\n  ensures result == this.x * other.x + this.y * other.y + this.z * other.z\n{\n  var sum := 0;\n  var components := [this.x, this.y, this.z];\n  var otherComponents := [other.x, other.y, other.z];\n\n  // Loop over each component to calculate the dot product\n  var i := 0;\n  while i < 3\n    invariant 0 <= i <= 3\n    invariant sum == (if i >= 1 then components[0] * otherComponents[0] else 0)\n                      + (if i >= 2 then components[1] * otherComponents[1] else 0)\n  {\n    sum := sum + components[i] * otherComponents[i];\n    i := i + 1;\n  }\n\n  result := sum;\n}\n}",
            "parents": [
                "0531bc00-ee02-4b47-b00c-5cf1fb944264"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "a917cae4-7a3e-40aa-83f9-7186fb36c08f",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p < right ==> arr[p] > pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "cd565c4a-6196-4c84-aef7-a5c2bd249fd8"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "7201d35b-8e5d-4804-b741-e206c2263be3",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> maxLength >= lis[k]\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n}",
            "parents": [
                "f02c5b3b-595c-47dd-a214-6b33fa06bb15"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "29d030a5-181c-49dd-8935-7c15c647cf18",
            "type": "program",
            "content": "class Graph {\n  var adjacencyMatrix: array2<bool>;\n  constructor(n: nat) \n    requires n > 0\n  {\n    adjacencyMatrix := new bool[n, n];\n  }\n  method AddEdge(u: nat, v: nat)\n    requires 0 <= u < adjacencyMatrix.Length0\n    requires 0 <= v < adjacencyMatrix.Length1\n    modifies adjacencyMatrix\n  {\n    adjacencyMatrix[u, v] := true;\n    adjacencyMatrix[v, u] := true;\n  }\n  method IsVertexCover(cover: set<nat>) returns (isCover: bool)\n    requires cover <= set i | 0 <= i < adjacencyMatrix.Length0\n    ensures isCover == (forall u, v :: 0 <= u < adjacencyMatrix.Length0 && 0 <= v < adjacencyMatrix.Length1 && adjacencyMatrix[u, v] ==> u in cover || v in cover)\n  {\n    isCover := true;\n    var n := adjacencyMatrix.Length0;\n    for u := 0 to n - 1 {\n      for v := 0 to n - 1 {\n        if adjacencyMatrix[u, v] && !(u in cover || v in cover) {\n          isCover := false;\n          return;\n        }\n      }\n    }\n  }\nmethod IsCompleteGraph() returns (isComplete: bool)\n  ensures isComplete == (forall u, v :: 0 <= u < adjacencyMatrix.Length0 && 0 <= v < adjacencyMatrix.Length1 && u != v ==> adjacencyMatrix[u, v])\n{\n  isComplete := true;\n  var n := adjacencyMatrix.Length0;\n  for u := 0 to n - 1\n    invariant 0 <= u <= n\n    invariant isComplete == (forall i, j :: 0 <= i < u && 0 <= j < n && i != j ==> adjacencyMatrix[i, j])\n  {\n    for v := 0 to n - 1\n      invariant 0 <= v <= n\n      invariant isComplete == (forall i, j :: 0 <= i < u && 0 <= j < n && i != j ==> adjacencyMatrix[i, j])\n      invariant isComplete == (forall j :: 0 <= j < v && u != j ==> adjacencyMatrix[u, j])\n    {\n      if u != v && !adjacencyMatrix[u, v] {\n        isComplete := false;\n        return;\n      }\n    }\n  }\n}\n}",
            "parents": [
                "1143df66-397a-4f7b-adf4-e3f270d6fc69"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "SUCCESS"
            }
        },
        {
            "id": "89697437-f527-44fc-8469-12398a118cdb",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n  ensures elements == old(elements)\n{\n  var i := 0;\n  var highestPriority := elements[0].0;\n  value := elements[0].1;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= highestPriority\n    invariant value == elements[0].1\n  {\n    if elements[i].0 < highestPriority {\n      highestPriority := elements[i].0;\n      value := elements[i].1;\n    }\n    i := i + 1;\n  }\n  assert value == elements[0].1;\n}\nmethod UpdatePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i].1 == value && elements[i].0 == newPriority\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n  var element := elements[i];\n  elements := elements[..i] + elements[i+1..]; // Remove the element\n  var newElement := (newPriority, element.1);\n\n  // Reinsert with new priority\n  i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [newElement] + elements[i..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\n}",
            "parents": [
                "7e3e9e41-6ccf-4a82-9892-1fb294c88c1a"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "be6823b5-37e8-4c49-9e27-d36ea3976379",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n{\n  value := elements[0].1;\n}\n}",
            "parents": [
                "a70cb0fe-ec4d-4ece-91ef-0b8fa644633c"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "1a3259b2-7905-4744-befc-ce6414144ded",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n{\n  value := elements[0].1;\n}\n}",
            "parents": [
                "3803a3ca-da34-4a1b-8cf7-61aa3bb9676f"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "8c003d78-55dc-464e-870e-2234e08afcde",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n    invariant forall r: int :: left <= r < i ==> arr[r] <= pivot\n    invariant forall s: int :: i <= s < j ==> arr[s] > pivot\n    invariant forall t: int :: j <= t <= right ==> arr[t] >= pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "cd565c4a-6196-4c84-aef7-a5c2bd249fd8"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "87652645-07de-4f8b-a7ba-4ad1f40c0a88",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures elements == old(elements)\n  ensures value == elements[0].1\n{\n  var highestPriority := elements[0].0;\n  var highestValue := elements[0].1;\n  var i := 1;\n  while i < |elements|\n    invariant 1 <= i <= |elements|\n    invariant highestPriority == elements[0].0\n    invariant highestValue == elements[0].1\n    invariant forall k :: 0 <= k < i ==> elements[k].0 >= highestPriority\n  {\n    if elements[i].0 < highestPriority {\n      highestPriority := elements[i].0;\n      highestValue := elements[i].1;\n    }\n    i := i + 1;\n  }\n  value := highestValue;\n}\n}",
            "parents": [
                "a70cb0fe-ec4d-4ece-91ef-0b8fa644633c"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "805a06a8-b6bf-4a27-9b01-8bf98849d4a2",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\nmethod ChangePriority(oldPriority: int, value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i] == (oldPriority, value)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |elements| && elements[i] != (oldPriority, value)\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k] != (oldPriority, value)\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + elements[i+1..];\n  var newElement := (newPriority, value);\n  i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [newElement] + elements[i..];\n}\n}",
            "parents": [
                "1b5f08f0-4d3d-46bb-8364-a8bf224e24f9"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "9165bc2c-7940-4a39-a2c4-ed54bf23308b",
            "type": "program",
            "content": "method Swap(a: array<int>, i: int, j: int)\n  requires 0 <= i < a.Length && 0 <= j < a.Length\n  modifies a\n  ensures a[i] == old(a[j]) && a[j] == old(a[i]) && (forall k :: k != i && k != j ==> a[k] == old(a[k]))\n{\n  var temp := a[i];\n  a[i] := a[j];\n  a[j] := temp;\n}\nmethod Shuffle(a: array<int>)\n  requires a.Length > 0\n  modifies a\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures (forall i, j :: 0 <= i < j < a.Length ==> a[i] != a[j])\n{\n  var n := a.Length;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    {\n      var j := i + (if n - i == 1 then 0 else (n - i) % (n - i));\n      Swap(a, i, j);\n      i := i + 1;\n    }\n{\n  var n := a.Length;\n  var i := n - 1;\n  while i > 0\n    invariant 0 <= i < n\n    invariant multiset(a[i..]) == multiset(old(a[i..]))\n    {\n      var j := i + (if i == 0 then 0 else i % (i + 1));\n      Swap(a, i, j);\n      i := i - 1;\n    }\n}\n}",
            "parents": [
                "4625c197-546d-449c-ac06-6ed45dcf8f1f"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "70476838-41f7-4ba1-b7e3-0430f4e253d6",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures elements == old(elements)\n  ensures value == old(elements[0].1)\n{\n  value := elements[0].1;\n}\nmethod ChangePriority(oldValue: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == oldValue\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, oldValue)\n{\n  var i := 0;\n  // Find the element with the specified value\n  while i < |elements| && elements[i].1 != oldValue\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != oldValue\n  {\n    i := i + 1;\n  }\n  // Remove the element\n  elements := elements[..i] + elements[i+1..];\n  \n  // Reinsert the element with the new priority\n  var newElement := (newPriority, oldValue);\n  var j := 0;\n  while j < |elements| && elements[j].0 <= newPriority\n    invariant 0 <= j <= |elements|\n    invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n  {\n    j := j + 1;\n  }\n  elements := elements[..j] + [newElement] + elements[j..];\n}\n}",
            "parents": [
                "672811ec-af0c-4014-a56f-9d8dfb71a0b5"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "8950e131-3ee6-4481-9d18-35785b388425",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p < right ==> arr[p] > pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n    invariant forall r: int :: left <= r < i ==> arr[r] <= pivot\n    invariant forall s: int :: i <= s < j ==> arr[s] > pivot\n    invariant forall t: int :: j <= t <= right ==> arr[t] >= pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "a917cae4-7a3e-40aa-83f9-7186fb36c08f"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "d18d8232-1a34-45c7-b8d9-1a1ce12ec6a8",
            "type": "program",
            "content": "class Graph {\n  var adjacencyMatrix: array2<bool>;\n  constructor(n: nat) \n    requires n > 0\n  {\n    adjacencyMatrix := new bool[n, n];\n  }\n  method AddEdge(u: nat, v: nat)\n    requires 0 <= u < adjacencyMatrix.Length0\n    requires 0 <= v < adjacencyMatrix.Length1\n    modifies adjacencyMatrix\n  {\n    adjacencyMatrix[u, v] := true;\n    adjacencyMatrix[v, u] := true;\n  }\n  method IsVertexCover(cover: set<nat>) returns (isCover: bool)\n    requires cover <= set i | 0 <= i < adjacencyMatrix.Length0\n    ensures isCover == (forall u, v :: 0 <= u < adjacencyMatrix.Length0 && 0 <= v < adjacencyMatrix.Length1 && adjacencyMatrix[u, v] ==> u in cover || v in cover)\n  {\n    isCover := true;\n    var n := adjacencyMatrix.Length0;\n    for u := 0 to n - 1 {\n      for v := 0 to n - 1 {\n        if adjacencyMatrix[u, v] && !(u in cover || v in cover) {\n          isCover := false;\n          return;\n        }\n      }\n    }\n  }\nmethod IsCompleteGraph() returns (isComplete: bool)\n  ensures isComplete == (forall u, v :: 0 <= u < adjacencyMatrix.Length0 && 0 <= v < adjacencyMatrix.Length1 && u != v ==> adjacencyMatrix[u, v])\n{\n  isComplete := true;\n  var n := adjacencyMatrix.Length0;\n  for u := 0 to n - 1\n    invariant 0 <= u <= n\n    invariant isComplete == (forall i, j :: 0 <= i < u && 0 <= j < n && i != j ==> adjacencyMatrix[i, j])\n  {\n    for v := 0 to n - 1\n      invariant 0 <= v <= n\n      invariant isComplete == (forall i, j :: 0 <= i < u && 0 <= j < n && i != j ==> adjacencyMatrix[i, j]) &&\n                             (forall j :: 0 <= j < v && u != j ==> adjacencyMatrix[u, j])\n    {\n      if u != v && !adjacencyMatrix[u, v] {\n        isComplete := false;\n        return;\n      }\n    }\n  }\n}\n}",
            "parents": [
                "1143df66-397a-4f7b-adf4-e3f270d6fc69"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "SUCCESS"
            }
        },
        {
            "id": "4251edc1-eb92-408b-a9b9-72456f447f1c",
            "type": "program",
            "content": "method IsValidStackSequence(operations: seq<string>) returns (isValid: bool)\n  ensures isValid == (forall i :: 0 <= i < |operations| ==> operations[i] == \"push\" || operations[i] == \"pop\")\n{\n  var stackSize := 0;\n  isValid := true;\n  // Loop through each operation in the sequence\n  for i := 0 to |operations| \n    invariant 0 <= stackSize\n    invariant 0 <= i <= |operations|\n    invariant isValid == (forall j :: 0 <= j < i ==> operations[j] == \"push\" || operations[j] == \"pop\")\n  {\n    if operations[i] == \"push\" {\n      stackSize := stackSize + 1;\n    } else if operations[i] == \"pop\" {\n      if stackSize == 0 {\n        isValid := false;\n        return;\n      }\n      stackSize := stackSize - 1;\n    } else {\n      isValid := false;\n      return;\n    }\n  }\n  var maxStackSize := 0;\n  for i := 0 to |operations| \n    invariant 0 <= stackSize\n    invariant 0 <= i <= |operations|\n    invariant isValid == (forall j :: 0 <= j < i ==> operations[j] == \"push\" || operations[j] == \"pop\")\n    invariant maxStackSize >= stackSize\n  {\n    if operations[i] == \"push\" {\n      stackSize := stackSize + 1;\n      if stackSize > maxStackSize {\n        maxStackSize := stackSize;\n      }\n    } else if operations[i] == \"pop\" {\n      if stackSize == 0 {\n        isValid := false;\n        return;\n      }\n      stackSize := stackSize - 1;\n    } else {\n      isValid := false;\n      return;\n    }\n  }\n}",
            "parents": [
                "c38461f0-ed34-4bda-9e59-64250a060952"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "aa365734-5d9a-432b-96e3-760ce40ec894",
            "type": "program",
            "content": "method ComputeTriangularNumber(n: nat) returns (t: nat)\n  requires n >= 0\n  ensures t == n * (n + 1) / 2\n{\n  var sum := 0;\n  var i := 0;\n  while i <= n\n    invariant 0 <= i <= n + 1\n    invariant sum == i * (i - 1) / 2\n  {\n    sum := sum + i;\n    i := i + 1;\n  }\n  t := sum;\n  while i <= n\n    invariant 0 <= i <= n + 1\n    invariant sum == i * (i - 1) / 2\n    invariant sum <= n * (n + 1) / 2\n  {\n    sum := sum + i;\n    i := i + 1;\n  }\n  t := sum;\n}",
            "parents": [
                "7dd7dcfd-6654-459a-a74a-17572d0913de"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "SUCCESS"
            }
        },
        {
            "id": "499cfc20-2d66-4bad-a657-6bd0b1653157",
            "type": "program",
            "content": "class Graph {\n  var adjacencyMatrix: array2<bool>;\n\n  constructor(n: nat) \n    requires n > 0\n    ensures adjacencyMatrix.Length0 == n && adjacencyMatrix.Length1 == n\n    ensures forall i, j :: 0 <= i < n && 0 <= j < n ==> !adjacencyMatrix[i, j]\n  {\n    adjacencyMatrix := new bool[n, n];\n  }\n\n  method AddEdge(u: nat, v: nat)\n    requires 0 <= u < adjacencyMatrix.Length0\n    requires 0 <= v < adjacencyMatrix.Length1\n    modifies adjacencyMatrix\n    ensures adjacencyMatrix[u, v] && adjacencyMatrix[v, u]\n  {\n    adjacencyMatrix[u, v] := true;\n    adjacencyMatrix[v, u] := true;\n  }\n\n  method IsVertexCover(cover: set<nat>) returns (isCover: bool)\n    requires cover <= set i | 0 <= i < adjacencyMatrix.Length0\n    ensures isCover == (forall u, v :: 0 <= u < adjacencyMatrix.Length0 && 0 <= v < adjacencyMatrix.Length1 && adjacencyMatrix[u, v] ==> u in cover || v in cover)\n  {\n    isCover := true;\n    var n := adjacencyMatrix.Length0;\n    for u := 0 to n - 1 {\n      for v := 0 to n - 1 {\n        if adjacencyMatrix[u, v] && !(u in cover || v in cover) {\n          isCover := false;\n          return;\n        }\n      }\n    }\n  }\nmethod IsCompleteGraph() returns (isComplete: bool)\n  ensures isComplete == (forall u, v :: 0 <= u < adjacencyMatrix.Length0 && 0 <= v < adjacencyMatrix.Length1 && u != v ==> adjacencyMatrix[u, v])\n{\n  isComplete := true;\n  var n := adjacencyMatrix.Length0;\n  for u := 0 to n - 1\n    invariant 0 <= u <= n\n    invariant isComplete == (forall i, j :: 0 <= i < u && 0 <= j < n && i != j ==> adjacencyMatrix[i, j])\n  {\n    for v := 0 to n - 1\n      invariant 0 <= v <= n\n      invariant isComplete == (forall i, j :: 0 <= i < u && 0 <= j < n && i != j ==> adjacencyMatrix[i, j])\n      invariant isComplete == (forall j :: 0 <= j < v && u != j ==> adjacencyMatrix[u, j])\n    {\n      if u != v && !adjacencyMatrix[u, v] {\n        isComplete := false;\n        return;\n      }\n    }\n  }\n}\n}",
            "parents": [
                "4cdc8acf-bd53-4262-9f62-d262ebc0d72c"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "58498a74-64b0-4bc1-b44c-d75301d9405d",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n  ensures elements == old(elements)\n{\n  var i := 0;\n  var highestPriority := elements[0].0;\n  value := elements[0].1;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= highestPriority\n    invariant value == elements[0].1\n  {\n    if elements[i].0 < highestPriority {\n      highestPriority := elements[i].0;\n      value := elements[i].1;\n    }\n    i := i + 1;\n  }\n  assert value == elements[0].1;\n}\nmethod UpdatePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i].1 == value && elements[i].0 == newPriority\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n  var element := elements[i];\n  elements := elements[..i] + elements[i+1..]; // Remove the element\n  var newElement := (newPriority, element.1);\n\n  // Reinsert with new priority\n  i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [newElement] + elements[i..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\nmethod RemoveByValue(value: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures !exists i :: 0 <= i < |elements| && elements[i].1 == value\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + elements[i+1..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\n}",
            "parents": [
                "89697437-f527-44fc-8469-12398a118cdb"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "SUCCESS"
            }
        },
        {
            "id": "06ba2f07-fbf7-430a-a181-3deb6d20bbe3",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i - 1 ==> lis[k] <= lis[k + 1]\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k :: 0 <= k < i - 1 ==> lis[k] <= lis[k + 1]\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n}",
            "parents": [
                "f02c5b3b-595c-47dd-a214-6b33fa06bb15"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "0e3e1fef-620d-44f1-9109-30887c600d5e",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n{\n  value := elements[0].1;\n}\nmethod ChangePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n  var oldElement := elements[i];\n  elements := elements[..i] + elements[i+1..];\n  var j := 0;\n  while j < |elements| && elements[j].0 <= newPriority\n    invariant 0 <= j <= |elements|\n    invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n    invariant forall k, l :: 0 <= k < l < j ==> elements[k].0 <= elements[l].0\n  {\n    j := j + 1;\n  }\n  elements := elements[..j] + [(newPriority, value)] + elements[j..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\n}",
            "parents": [
                "be6823b5-37e8-4c49-9e27-d36ea3976379"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "06cfd3c5-2390-4a34-8fcd-d7ecddaaea4a",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n  ensures elements == old(elements)\n{\n  var i := 0;\n  var highestPriority := elements[0].0;\n  value := elements[0].1;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= highestPriority\n    invariant value == elements[0].1\n  {\n    if elements[i].0 < highestPriority {\n      highestPriority := elements[i].0;\n      value := elements[i].1;\n    }\n    i := i + 1;\n  }\n  assert value == elements[0].1;\n}\nmethod UpdatePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i].1 == value && elements[i].0 == newPriority\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n  var element := elements[i];\n  elements := elements[..i] + elements[i+1..]; // Remove the element\n  var newElement := (newPriority, element.1);\n\n  // Reinsert with new priority\n  i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [newElement] + elements[i..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\nmethod Remove(value: int) returns (found: bool)\n  modifies this\n  ensures found ==> !exists i :: 0 <= i < |elements| && elements[i].1 == value\n  ensures !found ==> elements == old(elements)\n{\n  var i := 0;\n  found := false;\n  while i < |elements| && !found\n    invariant 0 <= i <= |elements|\n    invariant !found ==> forall k :: 0 <= k < i ==> elements[k].1 != value\n    invariant found ==> !exists k :: 0 <= k < i && elements[k].1 == value\n  {\n    if elements[i].1 == value {\n      found := true;\n      elements := elements[..i] + elements[i+1..];\n    } else {\n      i := i + 1;\n    }\n  }\n  assert found ==> !exists k :: 0 <= k < |elements| && elements[k].1 == value;\n}\n}",
            "parents": [
                "89697437-f527-44fc-8469-12398a118cdb"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "SUCCESS"
            }
        },
        {
            "id": "5ace900e-0e58-4dcb-9451-ef12d1bebe7e",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> maxLength >= lis[k]\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i - 1 ==> lis[k] <= lis[k + 1]\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k :: 0 <= k < i - 1 ==> lis[k] <= lis[k + 1]\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n}",
            "parents": [
                "7201d35b-8e5d-4804-b741-e206c2263be3"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "a3e62053-9c6d-48a9-b8e3-f4e0235d8f8b",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p < right ==> arr[p] > pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n    invariant forall r: int :: left <= r < j ==> arr[r] <= pivot || arr[r] > pivot\n    invariant forall s: int :: j <= s <= right ==> arr[s] >= pivot || arr[s] < pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "a917cae4-7a3e-40aa-83f9-7186fb36c08f"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "1556299d-6d26-4eea-bac5-759d68f30000",
            "type": "program",
            "content": "class Vector3D {\n  var x: int\n  var y: int\n  var z: int\n  constructor(x: int, y: int, z: int) \n    ensures this.x == x && this.y == y && this.z == z\n  {\n    this.x := x;\n    this.y := y;\n    this.z := z;\n  }\n  method CrossProduct(other: Vector3D) returns (result: Vector3D)\n    ensures result.x == this.y * other.z - this.z * other.y\n    ensures result.y == this.z * other.x - this.x * other.z\n    ensures result.z == this.x * other.y - this.y * other.x\n  {\n    var cx := this.y * other.z - this.z * other.y;\n    var cy := this.z * other.x - this.x * other.z;\n    var cz := this.x * other.y - this.y * other.x;\n    result := new Vector3D(cx, cy, cz);\n  }\nmethod DotProduct(other: Vector3D) returns (result: int)\n  ensures result == this.x * other.x + this.y * other.y + this.z * other.z\n{\n  var sum := 0;\n  var components := [this.x, this.y, this.z];\n  var otherComponents := [other.x, other.y, other.z];\n  \n  // Loop invariant to ensure the sum is correctly calculated\n  var i := 0;\n  while i < 3\n    invariant 0 <= i <= 3\n    invariant sum == (if i > 0 then components[0] * otherComponents[0] else 0) +\n                    (if i > 1 then components[1] * otherComponents[1] else 0) +\n                    (if i > 2 then components[2] * otherComponents[2] else 0)\n  {\n    sum := sum + components[i] * otherComponents[i];\n    i := i + 1;\n  }\n  result := sum;\n}\n}",
            "parents": [
                "0531bc00-ee02-4b47-b00c-5cf1fb944264"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "SUCCESS"
            }
        },
        {
            "id": "f96f785a-0a84-4692-a514-f60129d792e5",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n{\n  value := elements[0].1;\n}\n}",
            "parents": [
                "a70cb0fe-ec4d-4ece-91ef-0b8fa644633c"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "439925a9-cdd0-434e-99ac-f9cf562045c7",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n{\n  value := elements[0].1;\n}\nmethod ChangePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var index := -1;\n  var i := 0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant index == -1 ==> forall k :: 0 <= k < i ==> elements[k].1 != value\n    invariant index != -1 ==> elements[index].1 == value\n  {\n    if elements[i].1 == value {\n      index := i;\n      break;\n    }\n    i := i + 1;\n  }\n  assert index != -1; // We should have found the element\n\n  // Remove the element\n  elements := elements[..index] + elements[index + 1..];\n\n  // Reinsert with new priority\n  var newElement := (newPriority, value);\n  i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [newElement] + elements[i..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\n}",
            "parents": [
                "be6823b5-37e8-4c49-9e27-d36ea3976379"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "97060160-b406-4839-8191-a29ff71a9361",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n{\n  value := elements[0].1;\n}\nmethod IsEmpty() returns (empty: bool)\n  ensures empty == (|elements| == 0)\n{\n  var i := 0;\n  empty := true;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant empty == (i == 0)\n  {\n    empty := false;\n    i := i + 1;\n  }\n}\n}",
            "parents": [
                "1a3259b2-7905-4744-befc-ce6414144ded"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "d0c6d61a-a938-45ec-99d0-57a898f70f86",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n    invariant forall r: int :: left <= r < i ==> arr[r] <= pivot\n    invariant forall s: int :: i <= s < j ==> arr[s] > pivot\n    invariant forall t: int :: j <= t <= right ==> arr[t] >= pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n    invariant forall r: int :: left <= r < i ==> arr[r] <= pivot\n    invariant forall s: int :: i <= s < j ==> arr[s] > pivot\n    invariant forall t: int :: j <= t <= right ==> arr[t] >= pivot\n    invariant forall u: int :: left <= u < i ==> arr[u] <= pivot\n    invariant forall v: int :: i <= v <= j ==> arr[v] > pivot\n    invariant forall w: int :: j < w <= right ==> arr[w] >= pivot\n    invariant forall x: int :: left <= x <= right ==> \n              (arr[x] <= pivot || arr[x] > pivot || arr[x] == pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "8c003d78-55dc-464e-870e-2234e08afcde"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "a0ef0509-4322-4e8b-879e-b955746421e8",
            "type": "program",
            "content": "class Graph {\n  var adjacencyMatrix: array2<bool>;\n  constructor(n: nat) \n    requires n > 0\n  {\n    adjacencyMatrix := new bool[n, n];\n  }\n  method AddEdge(u: nat, v: nat)\n    requires 0 <= u < adjacencyMatrix.Length0\n    requires 0 <= v < adjacencyMatrix.Length1\n    modifies adjacencyMatrix\n  {\n    adjacencyMatrix[u, v] := true;\n    adjacencyMatrix[v, u] := true;\n  }\n  method IsVertexCover(cover: set<nat>) returns (isCover: bool)\n    requires cover <= set i | 0 <= i < adjacencyMatrix.Length0\n    ensures isCover == (forall u, v :: 0 <= u < adjacencyMatrix.Length0 && 0 <= v < adjacencyMatrix.Length1 && adjacencyMatrix[u, v] ==> u in cover || v in cover)\n  {\n    isCover := true;\n    var n := adjacencyMatrix.Length0;\n    for u := 0 to n - 1 {\n      for v := 0 to n - 1 {\n        if adjacencyMatrix[u, v] && !(u in cover || v in cover) {\n          isCover := false;\n          return;\n        }\n      }\n    }\n  }\nmethod IsCompleteGraph() returns (isComplete: bool)\n  ensures isComplete == (forall u, v :: 0 <= u < adjacencyMatrix.Length0 && 0 <= v < adjacencyMatrix.Length1 && u != v ==> adjacencyMatrix[u, v])\n{\n  isComplete := true;\n  var n := adjacencyMatrix.Length0;\n  for u := 0 to n - 1\n    invariant 0 <= u <= n\n    invariant isComplete == (forall i, j :: 0 <= i < u && 0 <= j < n && i != j ==> adjacencyMatrix[i, j])\n  {\n    for v := 0 to n - 1\n      invariant 0 <= v <= n\n      invariant isComplete == (forall i, j :: 0 <= i < u && 0 <= j < n && i != j ==> adjacencyMatrix[i, j])\n      invariant isComplete == (forall j :: 0 <= j < v && u != j ==> adjacencyMatrix[u, j])\n    {\n      if u != v && !adjacencyMatrix[u, v] {\n        isComplete := false;\n        return;\n      }\n    }\n  }\n}\n}",
            "parents": [
                "1143df66-397a-4f7b-adf4-e3f270d6fc69"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "SUCCESS"
            }
        },
        {
            "id": "acc10745-d709-4a13-91d2-bd5dc8b4da10",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures elements == old(elements)\n  ensures value == elements[0].1\n{\n  var highestPriority := elements[0].0;\n  var highestValue := elements[0].1;\n  var i := 1;\n  while i < |elements|\n    invariant 1 <= i <= |elements|\n    invariant highestPriority == elements[0].0\n    invariant highestValue == elements[0].1\n    invariant forall k :: 0 <= k < i ==> elements[k].0 >= highestPriority\n  {\n    if elements[i].0 < highestPriority {\n      highestPriority := elements[i].0;\n      highestValue := elements[i].1;\n    }\n    i := i + 1;\n  }\n  value := highestValue;\n}\nmethod ChangePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n  // Remove the element with the specified value\n  elements := elements[..i] + elements[i+1..];\n  \n  // Re-insert the element with the new priority\n  var newElement := (newPriority, value);\n  i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [newElement] + elements[i..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\n}",
            "parents": [
                "87652645-07de-4f8b-a7ba-4ad1f40c0a88"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "e7715655-b950-44f3-8264-7bb353603d0c",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant IsNonDecreasing(lis, i)\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant IsNonDecreasing(lis, i)\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n}\n\npredicate IsNonDecreasing(arr: array<int>, length: int)\n  reads arr\n{\n  forall i, j :: 0 <= i < j < length ==> arr[i] <= arr[j]\n}",
            "parents": [
                "f02c5b3b-595c-47dd-a214-6b33fa06bb15"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "84d83fee-9cca-405a-bcec-912037201669",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n  ensures elements == old(elements)\n{\n  var i := 0;\n  var highestPriority := elements[0].0;\n  value := elements[0].1;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= highestPriority\n    invariant value == elements[0].1\n  {\n    if elements[i].0 < highestPriority {\n      highestPriority := elements[i].0;\n      value := elements[i].1;\n    }\n    i := i + 1;\n  }\n  assert value == elements[0].1;\n}\nmethod IsEmpty() returns (empty: bool)\n  ensures empty <==> |elements| == 0\n{\n  empty := |elements| == 0;\n}\n}",
            "parents": [
                "7e3e9e41-6ccf-4a82-9892-1fb294c88c1a"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "223a0b93-3151-4812-9c68-627387fa2a84",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n{\n  var i := 0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 >= elements[i].0\n  {\n    if elements[i].0 > elements[0].0 {\n      value := elements[i].1;\n      return;\n    }\n    i := i + 1;\n  }\n  value := elements[0].1;\n}\n}",
            "parents": [
                "3803a3ca-da34-4a1b-8cf7-61aa3bb9676f"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "9cb1c3ae-4da1-45fc-809b-4374d83d99c5",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\nmethod UpdatePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures forall i :: 0 <= i < |elements| ==> elements[i].1 != value || elements[i].0 == newPriority\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n\n  // Remove the element with the old priority\n  elements := elements[..i] + elements[i+1..];\n\n  // Reinsert the element with the new priority\n  var newElement := (newPriority, value);\n  i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [newElement] + elements[i..];\n}\n}",
            "parents": [
                "1b5f08f0-4d3d-46bb-8364-a8bf224e24f9"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "cdf2bf93-da54-45d5-808e-0671fc85de78",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\nmethod ChangePriority(oldPriority: int, value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i] == (oldPriority, value)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |elements| && elements[i] != (oldPriority, value)\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k] != (oldPriority, value)\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + elements[i+1..];\n  var newElement := (newPriority, value);\n  i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [newElement] + elements[i..];\n}\nmethod Merge(other: PriorityQueue)\n  modifies this\n  ensures forall e :: e in other.elements ==> e in elements\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |other.elements|\n    invariant 0 <= i <= |other.elements|\n    invariant forall k :: 0 <= k < i ==> other.elements[k] in elements\n    invariant forall m, n :: 0 <= m < n < |elements| ==> elements[m].0 <= elements[n].0\n  {\n    var (priority, value) := other.elements[i];\n    Enqueue(priority, value);\n    i := i + 1;\n  }\n}\n}",
            "parents": [
                "805a06a8-b6bf-4a27-9b01-8bf98849d4a2"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "498b0fa7-33e0-4d30-958c-71042506ae70",
            "type": "program",
            "content": "class Graph {\n  var adjacencyMatrix: array2<bool>;\n\n  constructor(n: nat) \n    requires n > 0\n    ensures adjacencyMatrix.Length0 == n && adjacencyMatrix.Length1 == n\n    ensures forall i, j :: 0 <= i < n && 0 <= j < n ==> !adjacencyMatrix[i, j]\n  {\n    adjacencyMatrix := new bool[n, n];\n  }\n\n  method AddEdge(u: nat, v: nat)\n    requires 0 <= u < adjacencyMatrix.Length0\n    requires 0 <= v < adjacencyMatrix.Length1\n    modifies adjacencyMatrix\n    ensures adjacencyMatrix[u, v] && adjacencyMatrix[v, u]\n  {\n    adjacencyMatrix[u, v] := true;\n    adjacencyMatrix[v, u] := true;\n  }\n\n  method IsVertexCover(cover: set<nat>) returns (isCover: bool)\n    requires cover <= set i | 0 <= i < adjacencyMatrix.Length0\n    ensures isCover == (forall u, v :: 0 <= u < adjacencyMatrix.Length0 && 0 <= v < adjacencyMatrix.Length1 && adjacencyMatrix[u, v] ==> u in cover || v in cover)\n  {\n    isCover := true;\n    var n := adjacencyMatrix.Length0;\n    for u := 0 to n - 1 {\n      for v := 0 to n - 1 {\n        if adjacencyMatrix[u, v] && !(u in cover || v in cover) {\n          isCover := false;\n          return;\n        }\n      }\n    }\n  }\nmethod IsCompleteGraph() returns (isComplete: bool)\n  ensures isComplete == (forall u, v :: 0 <= u < adjacencyMatrix.Length0 && 0 <= v < adjacencyMatrix.Length1 && u != v ==> adjacencyMatrix[u, v])\n{\n  isComplete := true;\n  var n := adjacencyMatrix.Length0;\n  for u := 0 to n - 1\n    invariant 0 <= u <= n\n    invariant isComplete == (forall i, j :: 0 <= i < u && 0 <= j < n && i != j ==> adjacencyMatrix[i, j])\n  {\n    for v := 0 to n - 1\n      invariant 0 <= v <= n\n      invariant isComplete == (forall i, j :: 0 <= i < u && 0 <= j < n && i != j ==> adjacencyMatrix[i, j]) &&\n                             (forall j :: 0 <= j < v && u != j ==> adjacencyMatrix[u, j])\n    {\n      if u != v && !adjacencyMatrix[u, v] {\n        isComplete := false;\n        return;\n      }\n    }\n  }\n}\n}",
            "parents": [
                "4cdc8acf-bd53-4262-9f62-d262ebc0d72c"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "add9b37b-529c-41d8-9a87-1190d778fa35",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures elements == old(elements)\n  ensures value == old(elements[0].1)\n{\n  value := elements[0].1;\n}\nmethod ChangePriority(oldValue: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == oldValue\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, oldValue)\n{\n  var i := 0;\n  // Find the element with the specified value\n  while i < |elements| && elements[i].1 != oldValue\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != oldValue\n  {\n    i := i + 1;\n  }\n  // Remove the element\n  elements := elements[..i] + elements[i+1..];\n  \n  // Reinsert the element with the new priority\n  var newElement := (newPriority, oldValue);\n  var j := 0;\n  while j < |elements| && elements[j].0 <= newPriority\n    invariant 0 <= j <= |elements|\n    invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n  {\n    j := j + 1;\n  }\n  elements := elements[..j] + [newElement] + elements[j..];\n}\nmethod Merge(other: PriorityQueue)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures |elements| == old(|elements|) + |other.elements|\n  ensures forall e :: e in other.elements ==> e in elements\n{\n  var i := 0;\n  while i < |other.elements|\n    invariant 0 <= i <= |other.elements|\n    invariant |elements| == old(|elements|) + i\n    invariant forall j, k :: 0 <= j < k < |elements| ==> elements[j].0 <= elements[k].0\n    invariant forall e :: e in other.elements[..i] ==> e in elements\n  {\n    var (priority, value) := other.elements[i];\n    this.Enqueue(priority, value);\n    i := i + 1;\n  }\n}\n}",
            "parents": [
                "70476838-41f7-4ba1-b7e3-0430f4e253d6"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "748917f8-aa21-4cc5-b49a-7dd1b1d93e06",
            "type": "program",
            "content": "// A simple program to verify that a given configuration of queens on a chessboard is valid\n// i.e., no two queens attack each other.\nmethod IsValidQueenConfiguration(board: seq<seq<bool>>) returns (valid: bool)\n  requires |board| == 8 && forall row :: 0 <= row < |board| ==> |board[row]| == 8\n  ensures valid == true <==> (forall i, j, k, l :: 0 <= i < 8 && 0 <= j < 8 && 0 <= k < 8 && 0 <= l < 8 && board[i][j] && board[k][l] ==> (i == k && j == l) || (i != k && j != l && i - j != k - l && i + j != k + l))\n{\n  valid := true;\n  var n := 8;\n  // Check each pair of queens to ensure they do not attack each other\n  for i := 0 to n - 1 {\n    for j := 0 to n - 1 {\n      if board[i][j] {\n        for k := 0 to n - 1 {\n          for l := 0 to n - 1 {\n            if board[k][l] && (i != k || j != l) {\n              // Check if they are in the same row, column, or diagonal\n              if i == k || j == l || i - j == k - l || i + j == k + l {\n                valid := false;\n                return;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  for i := 0 to n - 1\n    invariant 0 <= i <= n\n    invariant valid == true ==> (forall x, y, u, v :: 0 <= x < i && 0 <= y < n && 0 <= u < n && 0 <= v < n && board[x][y] && board[u][v] ==> (x == u && y == v) || (x != u && y != v && x - y != u - v && x + y != u + v))\n  {\n    for j := 0 to n - 1\n      invariant 0 <= j <= n\n      invariant valid == true ==> (forall x, y, u, v :: 0 <= x < i && 0 <= y < j && 0 <= u < n && 0 <= v < n && board[x][y] && board[u][v] ==> (x == u && y == v) || (x != u && y != v && x - y != u - v && x + y != u + v))\n    {\n      if board[i][j] {\n        for k := 0 to n - 1\n          invariant 0 <= k <= n\n          invariant valid == true ==> (forall x, y, u, v :: 0 <= x < i && 0 <= y < j && 0 <= u < k && 0 <= v < n && board[x][y] && board[u][v] ==> (x == u && y == v) || (x != u && y != v && x - y != u - v && x + y != u + v))\n        {\n          for l := 0 to n - 1\n            invariant 0 <= l <= n\n            invariant valid == true ==> (forall x, y, u, v :: 0 <= x < i && 0 <= y < j && 0 <= u < k && 0 <= v < l && board[x][y] && board[u][v] ==> (x == u && y == v) || (x != u && y != v && x - y != u - v && x + y != u + v))\n          {\n            if board[k][l] && (i != k || j != l) {\n              // Check if they are in the same row, column, or diagonal\n              if i == k || j == l || i - j == k - l || i + j == k + l {\n                valid := false;\n                return;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
            "parents": [
                "794e1df6-3d8c-4b78-9124-c9b4a9af8a94"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "15b2aa02-b940-4eaf-b6af-1c31858e534e",
            "type": "program",
            "content": "class Vector3D {\n  var x: int\n  var y: int\n  var z: int\n  constructor(x: int, y: int, z: int) \n    ensures this.x == x && this.y == y && this.z == z\n  {\n    this.x := x;\n    this.y := y;\n    this.z := z;\n  }\n  method CrossProduct(other: Vector3D) returns (result: Vector3D)\n    ensures result.x == this.y * other.z - this.z * other.y\n    ensures result.y == this.z * other.x - this.x * other.z\n    ensures result.z == this.x * other.y - this.y * other.x\n  {\n    var cx := this.y * other.z - this.z * other.y;\n    var cy := this.z * other.x - this.x * other.z;\n    var cz := this.x * other.y - this.y * other.x;\n    result := new Vector3D(cx, cy, cz);\n  }\nmethod DotProduct(other: Vector3D) returns (result: int)\n  ensures result == this.x * other.x + this.y * other.y + this.z * other.z\n{\n  var sum := 0;\n  var components := [this.x, this.y, this.z];\n  var otherComponents := [other.x, other.y, other.z];\n\n  // Loop over each component to calculate the dot product\n  var i := 0;\n  while i < 3\n    invariant 0 <= i <= 3\n    invariant sum == (if i >= 1 then components[0] * otherComponents[0] else 0)\n                      + (if i >= 2 then components[1] * otherComponents[1] else 0)\n  {\n    sum := sum + components[i] * otherComponents[i];\n    i := i + 1;\n  }\n\n  result := sum;\n}\nmethod SquaredMagnitude() returns (result: int)\n  ensures result == this.x * this.x + this.y * this.y + this.z * this.z\n{\n  var sum := 0;\n  var components := [this.x, this.y, this.z];\n\n  // Loop over each component to calculate the squared magnitude\n  var i := 0;\n  while i < 3\n    invariant 0 <= i <= 3\n    invariant sum == (if i >= 1 then components[0] * components[0] else 0)\n                      + (if i >= 2 then components[1] * components[1] else 0)\n  {\n    sum := sum + components[i] * components[i];\n    i := i + 1;\n  }\n\n  result := sum;\n}\n}",
            "parents": [
                "c8041bff-3eec-4f3b-b067-6bcba8c3d80f"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "d69266e4-437f-4735-82c6-bfecd54e0e88",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n    invariant forall r: int :: left <= r < j ==> arr[r] <= pivot || arr[r] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "cd565c4a-6196-4c84-aef7-a5c2bd249fd8"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "ef5e2ccb-f464-482e-bcda-f79412089a5a",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i - 1 ==> lis[k] <= lis[k + 1]\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k :: 0 <= k < i - 1 ==> lis[k] <= lis[k + 1]\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n  return maxLength;\n  // Compute optimized LIS values in a bottom-up manner with enhanced invariants\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i - 1 ==> lis[k] <= lis[k + 1]  // New invariant: lis is non-decreasing\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k :: 0 <= k < i - 1 ==> lis[k] <= lis[k + 1]  // Maintain non-decreasing order\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n}",
            "parents": [
                "06ba2f07-fbf7-430a-a181-3deb6d20bbe3"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "7143c048-e72b-40ac-9ad8-70c9f2a2c552",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p < right ==> arr[p] > pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n    invariant forall r: int :: left <= r < i ==> arr[r] <= pivot\n    invariant forall s: int :: i <= s < j ==> arr[s] > pivot\n    invariant forall t: int :: j <= t <= right ==> arr[t] >= pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n    invariant forall r: int :: left <= r < i ==> arr[r] <= pivot\n    invariant forall s: int :: i <= s < j ==> arr[s] > pivot\n    invariant forall t: int :: j <= t <= right ==> arr[t] >= pivot\n    invariant (i - left) + (right - j) == (right - left)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "8950e131-3ee6-4481-9d18-35785b388425"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "47ff9bac-d5ea-4f3a-8471-02581f09e109",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures elements == old(elements)\n  ensures value == old(elements[0].1)\n{\n  value := elements[0].1;\n}\nmethod IsEmpty() returns (empty: bool)\n  ensures empty == (|elements| == 0)\n{\n  var i := 0;\n  empty := true;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant empty == (i == 0)\n  {\n    empty := false;\n    i := i + 1;\n  }\n}\n}",
            "parents": [
                "672811ec-af0c-4014-a56f-9d8dfb71a0b5"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "8da96709-43b6-453c-b1a5-03a717b5036b",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method UpdatePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures forall i :: 0 <= i < |elements| ==> elements[i].1 != value || elements[i].0 == newPriority\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n      invariant exists j :: i <= j < |elements| && elements[j].1 == value\n    {\n      i := i + 1;\n    }\n\n    // Remove the element with the old priority\n    elements := elements[..i] + elements[i+1..];\n\n    // Reinsert the element with the new priority\n    var newElement := (newPriority, value);\n    i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n}",
            "parents": [
                "9cb1c3ae-4da1-45fc-809b-4374d83d99c5"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "55d9d0e5-6f19-4a7e-b6e4-bb40226e663d",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method IsEmpty() returns (empty: bool)\n    ensures empty == (|elements| == 0)\n  {\n    var i := 0;\n    empty := true;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant empty == (i == 0)\n    {\n      empty := false;\n      i := i + 1;\n    }\n  }\n}",
            "parents": [
                "97060160-b406-4839-8191-a29ff71a9361"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "4596c890-ed7d-46c8-97d0-2e065b117389",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures elements == old(elements)\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n  }\n}",
            "parents": [
                "672811ec-af0c-4014-a56f-9d8dfb71a0b5"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "9f27c608-f19f-40b1-be5d-e5568f0fa058",
            "type": "program",
            "content": "method IsValidStackSequence(operations: seq<string>) returns (isValid: bool)\n  ensures isValid == (forall i :: 0 <= i < |operations| ==> operations[i] == \"push\" || operations[i] == \"pop\") &&\n                    (forall i :: 0 <= i < |operations| && operations[i] == \"pop\" ==> \n                     (exists j :: 0 <= j < i && operations[j] == \"push\"))\n{\n  var stackSize := 0;\n  isValid := true;\n  // Loop through each operation in the sequence\n  for i := 0 to |operations| \n    invariant 0 <= stackSize\n    invariant 0 <= i <= |operations|\n    invariant isValid == (forall j :: 0 <= j < i ==> operations[j] == \"push\" || operations[j] == \"pop\")\n    invariant isValid ==> (forall j :: 0 <= j < i && operations[j] == \"pop\" ==> (exists k :: 0 <= k < j && operations[k] == \"push\"))\n  {\n    if operations[i] == \"push\" {\n      stackSize := stackSize + 1;\n    } else if operations[i] == \"pop\" {\n      if stackSize == 0 {\n        isValid := false;\n        return;\n      }\n      stackSize := stackSize - 1;\n    } else {\n      isValid := false;\n      return;\n    }\n  }\n  isValid := stackSize >= 0;\n}",
            "parents": [
                "8cf60b9e-c935-4e22-8b29-2539c9e0d327"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "4648c11c-aef5-40df-bf70-a1496a11c09e",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n    {\n      i := i + 1;\n    }\n    var oldElement := elements[i];\n    elements := elements[..i] + elements[i+1..];\n    var j := 0;\n    while j < |elements| && elements[j].0 <= newPriority\n      invariant 0 <= j <= |elements|\n      invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < j ==> elements[k].0 <= elements[l].0\n    {\n      j := j + 1;\n    }\n    elements := elements[..j] + [(newPriority, value)] + elements[j..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n}",
            "parents": [
                "0e3e1fef-620d-44f1-9109-30887c600d5e"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "f4459605-baa8-46a1-9144-2895e6e19d8a",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures elements == old(elements)\n    ensures value == elements[0].1\n  {\n    var highestPriority := elements[0].0;\n    var highestValue := elements[0].1;\n    var i := 1;\n    while i < |elements|\n      invariant 1 <= i <= |elements|\n      invariant highestPriority == elements[0].0\n      invariant highestValue == elements[0].1\n      invariant forall k :: 0 <= k < i ==> elements[k].0 >= highestPriority\n    {\n      if elements[i].0 < highestPriority {\n        highestPriority := elements[i].0;\n        highestValue := elements[i].1;\n      }\n      i := i + 1;\n    }\n    value := highestValue;\n  }\n  method ChangePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n    {\n      i := i + 1;\n    }\n    // Remove the element with the specified value\n    elements := elements[..i] + elements[i+1..];\n    \n    // Re-insert the element with the new priority\n    var newElement := (newPriority, value);\n    i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n}",
            "parents": [
                "acc10745-d709-4a13-91d2-bd5dc8b4da10"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "7f64bdba-ae2c-4e21-9c73-7fd85d17aa05",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n}\n\npredicate IsNonDecreasing(arr: array<int>, length: int)\n  reads arr\n{\n  forall i, j :: 0 <= i < j < length ==> arr[i] <= arr[j]\n}",
            "parents": [
                "e7715655-b950-44f3-8264-7bb353603d0c"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "33ed6d62-9431-44c6-8c34-4cfb35fea409",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n}",
            "parents": [
                "3803a3ca-da34-4a1b-8cf7-61aa3bb9676f"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "7610c355-0496-44ad-b12b-371372dfb939",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant elements[..i] == old(elements[..i])\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n    ensures elements == old(elements)\n  {\n    var i := 0;\n    var highestPriority := elements[0].0;\n    value := elements[0].1;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= highestPriority\n      invariant value == elements[0].1\n      invariant elements == old(elements)\n    {\n      if elements[i].0 < highestPriority {\n        highestPriority := elements[i].0;\n        value := elements[i].1;\n      }\n      i := i + 1;\n    }\n    assert value == elements[0].1;\n  }\n  method UpdatePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures exists i :: 0 <= i < |elements| && elements[i].1 == value && elements[i].0 == newPriority\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n    {\n      i := i + 1;\n    }\n    var element := elements[i];\n    elements := elements[..i] + elements[i+1..]; // Remove the element\n    var newElement := (newPriority, element.1);\n\n    // Reinsert with new priority\n    i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant elements[..i] == old(elements[..i])\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n}",
            "parents": [
                "89697437-f527-44fc-8469-12398a118cdb"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "004df12c-828d-4ec6-bb2e-ef4f8aafebeb",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> maxLength >= lis[k]\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n}",
            "parents": [
                "7201d35b-8e5d-4804-b741-e206c2263be3"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "8b0b7b8a-6bdc-4b26-93f6-e8f47d872f78",
            "type": "program",
            "content": "method IsValidStackSequence(operations: seq<string>) returns (isValid: bool)\n  ensures isValid == (forall i :: 0 <= i < |operations| ==> operations[i] == \"push\" || operations[i] == \"pop\")\n{\n  var stackSize := 0;\n  isValid := true;\n  // Loop through each operation in the sequence\n  for i := 0 to |operations| \n    invariant 0 <= stackSize\n    invariant 0 <= i <= |operations|\n    invariant isValid ==> (forall j :: 0 <= j < i ==> operations[j] == \"push\" || operations[j] == \"pop\")\n  {\n    if operations[i] == \"push\" {\n      stackSize := stackSize + 1;\n    } else if operations[i] == \"pop\" {\n      if stackSize == 0 {\n        isValid := false;\n        return;\n      }\n      stackSize := stackSize - 1;\n    } else {\n      isValid := false;\n      return;\n    }\n  }\n  // Ensure that all operations were valid if we reach this point\n  assert isValid ==> (forall j :: 0 <= j < |operations| ==> operations[j] == \"push\" || operations[j] == \"pop\");\n}",
            "parents": [
                "c38461f0-ed34-4bda-9e59-64250a060952"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "e4a6b192-7a56-48a0-bee3-88e05ad28efb",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant exists i: int :: left <= i <= right && \n              (forall j: int :: left <= j < i ==> arr[j] <= arr[i]) &&\n              (forall j: int :: i < j <= right ==> arr[j] >= arr[i])\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "cd565c4a-6196-4c84-aef7-a5c2bd249fd8"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "6ca783b3-d9e6-4508-bb23-898b47d5267c",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      decreases |elements| - i\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n}",
            "parents": [
                "f96f785a-0a84-4692-a514-f60129d792e5"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "b3bade4c-e82c-4453-b2ca-4289e9c2bf9d",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var index := -1;\n    var i := 0;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant index == -1 ==> forall k :: 0 <= k < i ==> elements[k].1 != value\n      invariant index != -1 ==> elements[index].1 == value\n      invariant index == -1 ==> elements == old(elements)\n    {\n      if elements[i].1 == value {\n        index := i;\n        break;\n      }\n      i := i + 1;\n    }\n    assert index != -1; // We should have found the element\n\n    // Remove the element\n    elements := elements[..index] + elements[index + 1..];\n\n    // Reinsert with new priority\n    var newElement := (newPriority, value);\n    i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant elements[..index] + elements[index..] == old(elements[..index] + elements[index + 1..])\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n}",
            "parents": [
                "439925a9-cdd0-434e-99ac-f9cf562045c7"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "f39c0c06-cab5-4e42-80c4-c63db9871f52",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements[..i] + elements[i..] == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(oldPriority: int, value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i] == (oldPriority, value)\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var i := 0;\n    while i < |elements| && elements[i] != (oldPriority, value)\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k] != (oldPriority, value)\n      invariant elements[..i] + elements[i..] == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + elements[i+1..];\n    var newElement := (newPriority, value);\n    i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n      invariant elements[..i] + elements[i..] == old(elements[..i] + elements[i..])\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Merge(other: PriorityQueue)\n    modifies this\n    ensures forall e :: e in other.elements ==> e in elements\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var i := 0;\n    while i < |other.elements|\n      invariant 0 <= i <= |other.elements|\n      invariant forall k :: 0 <= k < i ==> other.elements[k] in elements\n      invariant forall m, n :: 0 <= m < n < |elements| ==> elements[m].0 <= elements[n].0\n    {\n      var (priority, value) := other.elements[i];\n      Enqueue(priority, value);\n      i := i + 1;\n    }\n  }\n}",
            "parents": [
                "cdf2bf93-da54-45d5-808e-0671fc85de78"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "8cf5861e-6e7c-4a4f-9c3b-79640428b942",
            "type": "program",
            "content": "// A simple program to verify that a given configuration of queens on a chessboard is valid\n// i.e., no two queens attack each other.\nmethod IsValidQueenConfiguration(board: seq<seq<bool>>) returns (valid: bool)\n  requires |board| == 8 && forall row :: 0 <= row < |board| ==> |board[row]| == 8\n  ensures valid == true <==> (forall i, j, k, l :: 0 <= i < 8 && 0 <= j < 8 && 0 <= k < 8 && 0 <= l < 8 && board[i][j] && board[k][l] ==> (i == k && j == l) || (i != k && j != l && i - j != k - l && i + j != k + l))\n{\n  valid := true;\n  var n := 8;\n  // Check each pair of queens to ensure they do not attack each other\n  for i := 0 to n - 1 {\n    for j := 0 to n - 1 {\n      if board[i][j] {\n        for k := 0 to n - 1 {\n          for l := 0 to n - 1 {\n            if board[k][l] && (i != k || j != l) {\n              // Check if they are in the same row, column, or diagonal\n              assert i != k || j != l; // They must be different positions\n              if i == k || j == l || i - j == k - l || i + j == k + l {\n                valid := false;\n                return;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
            "parents": [
                "794e1df6-3d8c-4b78-9124-c9b4a9af8a94"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "ed5524ab-12af-4015-94f6-05b21d0b06b5",
            "type": "program",
            "content": "method DotProduct(a: seq<int>, b: seq<int>) returns (result: int)\n  requires |a| == |b|\n  ensures result == DotProductSpec(a, b)\n{\n  var sum := 0;\n  var i := 0;\n  while i < |a|\n    invariant 0 <= i <= |a|\n    invariant sum == DotProductSpec(a[..i], b[..i])\n    decreases |a| - i\n  {\n    sum := sum + a[i] * b[i];\n    i := i + 1;\n  }\n  result := sum;\n}\n\nfunction DotProductSpec(a: seq<int>, b: seq<int>): int\n  requires |a| == |b|\n{\n  if |a| == 0 then 0 else a[0] * b[0] + DotProductSpec(a[1..], b[1..])\n}",
            "parents": [
                "709ca822-2f78-4e0c-a3ed-b8f585224a28"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "24766049-782a-4a21-b0eb-95e541710466",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n    ensures elements == old(elements)\n  {\n    var i := 0;\n    var highestPriority := elements[0].0;\n    value := elements[0].1;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= highestPriority\n      invariant exists k :: 0 <= k < |elements| && elements[k].0 == highestPriority && value == elements[k].1\n    {\n      if elements[i].0 < highestPriority {\n        highestPriority := elements[i].0;\n        value := elements[i].1;\n      }\n      i := i + 1;\n    }\n    assert exists k :: 0 <= k < |elements| && elements[k].0 == highestPriority && value == elements[k].1;\n  }\n  method IsEmpty() returns (empty: bool)\n    ensures empty <==> |elements| == 0\n  {\n    empty := |elements| == 0;\n  }\n}",
            "parents": [
                "84d83fee-9cca-405a-bcec-912037201669"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "9cfc5a4a-d921-46fe-963b-e9ee7f9a2e53",
            "type": "program",
            "content": "// A simple program to verify that a given configuration of queens on a chessboard is valid\n// i.e., no two queens attack each other.\nmethod IsValidQueenConfiguration(board: seq<seq<bool>>) returns (valid: bool)\n  requires |board| == 8 && forall row :: 0 <= row < |board| ==> |board[row]| == 8\n  ensures valid == true <==> (forall i, j, k, l :: 0 <= i < 8 && 0 <= j < 8 && 0 <= k < 8 && 0 <= l < 8 && board[i][j] && board[k][l] ==> (i == k && j == l) || (i != k && j != l && i - j != k - l && i + j != k + l))\n{\n  valid := true;\n  var n := 8;\n  // Check each pair of queens to ensure they do not attack each other\n  for i := 0 to n - 1\n    invariant 0 <= i <= n\n    invariant valid == true ==> (forall x, y :: 0 <= x < i && 0 <= y < n && board[x][y] ==> (forall a, b :: 0 <= a < n && 0 <= b < n && board[a][b] && (x != a || y != b) ==> x != a && y != b && x - y != a - b && x + y != a + b))\n  {\n    for j := 0 to n - 1\n      invariant 0 <= j <= n\n      invariant valid == true ==> (forall x, y :: 0 <= x <= i && 0 <= y < j && board[x][y] ==> (forall a, b :: 0 <= a < n && 0 <= b < n && board[a][b] && (x != a || y != b) ==> x != a && y != b && x - y != a - b && x + y != a + b))\n    {\n      if board[i][j] {\n        for k := 0 to n - 1\n          invariant 0 <= k <= n\n          invariant valid == true ==> (forall x, y :: 0 <= x <= i && 0 <= y <= j && board[x][y] ==> (forall a, b :: 0 <= a < k && 0 <= b < n && board[a][b] && (x != a || y != b) ==> x != a && y != b && x - y != a - b && x + y != a + b))\n        {\n          for l := 0 to n - 1\n            invariant 0 <= l <= n\n            invariant valid == true ==> (forall x, y :: 0 <= x <= i && 0 <= y <= j && board[x][y] ==> (forall a, b :: 0 <= a <= k && 0 <= b < l && board[a][b] && (x != a || y != b) ==> x != a && y != b && x - y != a - b && x + y != a + b))\n          {\n            if board[k][l] && (i != k || j != l) {\n              // Check if they are in the same row, column, or diagonal\n              if i == k || j == l || i - j == k - l || i + j == k + l {\n                valid := false;\n                return;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
            "parents": [
                "bbe8dea4-a7fd-41c0-a9a1-84093df79fe4"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "bd156f4f-816e-440e-9293-1f374647163a",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures elements == old(elements)\n    ensures value == elements[0].1\n  {\n    var highestPriority := elements[0].0;\n    var highestValue := elements[0].1;\n    var i := 1;\n    while i < |elements|\n      invariant 1 <= i <= |elements|\n      invariant highestPriority == elements[0].0\n      invariant highestValue == elements[0].1\n      invariant forall k :: 0 <= k < i ==> elements[k].0 >= highestPriority\n    {\n      if elements[i].0 < highestPriority {\n        highestPriority := elements[i].0;\n        highestValue := elements[i].1;\n      }\n      i := i + 1;\n    }\n    value := highestValue;\n  }\n}",
            "parents": [
                "87652645-07de-4f8b-a7ba-4ad1f40c0a88"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "9148a44b-6079-45fb-b7ba-172a8e0d446e",
            "type": "program",
            "content": "method QuickSort(a: array<int>, lo: int, hi: int)\n  requires 0 <= lo <= hi <= a.Length\n  modifies a\n  ensures forall i, j :: lo <= i <= j < hi ==> a[i] <= a[j]\n{\n  if lo < hi {\n    var p := Partition(a, lo, hi);\n    QuickSort(a, lo, p);\n    QuickSort(a, p + 1, hi);\n  }\n}\n\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIndex: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIndex < hi\n  ensures forall i :: lo <= i < pivotIndex ==> a[i] <= a[pivotIndex]\n  ensures forall i :: pivotIndex < i < hi ==> a[pivotIndex] <= a[i]\n{\n  var pivot := a[lo];\n  var i := lo;\n  var j := hi;\n  while i < j\n    invariant lo <= i <= j <= hi\n    invariant forall k :: lo <= k < i ==> a[k] <= pivot\n    invariant forall k :: j <= k < hi ==> a[k] >= pivot\n    invariant exists p :: lo <= p < hi && a[p] == pivot\n  {\n    while i < j && a[i] <= pivot\n      invariant lo <= i < hi\n      invariant forall k :: lo <= k < i ==> a[k] <= pivot\n    {\n      i := i + 1;\n    }\n    while i < j && a[j - 1] >= pivot\n      invariant lo < j <= hi\n      invariant forall k :: j <= k < hi ==> a[k] >= pivot\n    {\n      j := j - 1;\n    }\n    if i < j {\n      a[i], a[j - 1] := a[j - 1], a[i];\n    }\n  }\n  pivotIndex := j - 1;\n  a[lo], a[pivotIndex] := a[pivotIndex], a[lo];\n  assert forall i :: lo <= i < pivotIndex ==> a[i] <= a[pivotIndex];\n  assert forall i :: pivotIndex < i < hi ==> a[pivotIndex] <= a[i];\n}",
            "parents": [
                "7c9fc37e-728f-4760-ad6d-a39ce7ace19f"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "e618df95-484f-4b41-a192-c9ede8304119",
            "type": "program",
            "content": "method SieveOfEratosthenes(limit: nat) returns (primes: seq<bool>)\n  requires limit >= 2\n  ensures |primes| == limit + 1\n  ensures forall i :: 2 <= i <= limit ==> primes[i] <==> (forall j :: 2 <= j * j <= i ==> i % j != 0)\n{\n  var isPrime := new bool[limit + 1];\n  isPrime[0], isPrime[1] := false, false;\n  for i := 2 to limit {\n    isPrime[i] := true;\n  }\n  var p := 2;\n  while p * p <= limit\n    invariant 2 <= p <= limit + 1\n    invariant forall i :: 2 <= i < p ==> isPrime[i] <==> (forall j :: 2 <= j * j <= i ==> i % j != 0)\n    invariant forall i :: 2 <= i <= limit ==> (exists j :: 2 <= j <= i && j * j <= i && i % j == 0) ==> !isPrime[i]\n    invariant forall i :: 2 <= i <= limit ==> isPrime[i] ==> (forall j :: 2 <= j < p ==> i % j != 0)\n  {\n    if isPrime[p] {\n      var multiple := p * p;\n      while multiple <= limit\n        invariant p * p <= multiple <= limit + 1\n        invariant forall k :: p * p <= k < multiple ==> !isPrime[k]\n      {\n        isPrime[multiple] := false;\n        multiple := multiple + p;\n      }\n    }\n    p := p + 1;\n  }\n  primes := isPrime[..];\n}",
            "parents": [
                "80d73ae5-7f58-4281-a992-fe4c56b9c1e4"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "2a57eca9-5445-40ee-ad7d-767e70ff15cf",
            "type": "program",
            "content": "method IsPerfectSquare(n: nat) returns (result: bool)\n  ensures result <==> exists k: nat :: k * k == n\n{\n  var k: nat := 0;\n  result := false;\n  while k * k <= n\n    invariant 0 <= k <= n + 1\n    invariant forall i: nat :: 0 <= i < k ==> i * i != n\n    invariant result <==> exists i: nat :: 0 <= i < k && i * i == n\n  {\n    if k * k == n {\n      result := true;\n      return;\n    }\n    k := k + 1;\n  }\n}",
            "parents": [
                "f390dd04-9155-464e-b156-a9079e20eb98"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "47d4bcc1-10b3-44ee-a90d-bf21c2df1cb3",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant exists i: int :: left <= i <= right && \n              (forall j: int :: left <= j < i ==> arr[j] <= arr[i]) &&\n              (forall j: int :: i < j <= right ==> arr[j] >= arr[i])\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "a3e62053-9c6d-48a9-b8e3-f4e0235d8f8b"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "56263928-fe39-4d9f-acfa-69d3e871c62f",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant forall k, l :: 0 <= k < l < |elements| && l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n}",
            "parents": [
                "a70cb0fe-ec4d-4ece-91ef-0b8fa644633c"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "26c0afbb-ac15-46ec-bd57-7a20102170f0",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  length := maxLength;\n  assert forall i, j :: 0 <= i < j < n && arr[i] < arr[j] ==> length >= j - i + 1;\n  return length;\n}",
            "parents": [
                "f02c5b3b-595c-47dd-a214-6b33fa06bb15"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "5639d8a4-aadb-4be9-a2fc-9051d5024df0",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures elements == old(elements)\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(oldValue: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == oldValue\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, oldValue)\n  {\n    var i := 0;\n    // Find the element with the specified value\n    while i < |elements| && elements[i].1 != oldValue\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != oldValue\n      invariant exists j :: i <= j < |elements| && elements[j].1 == oldValue\n    {\n      i := i + 1;\n    }\n    // Remove the element\n    elements := elements[..i] + elements[i+1..];\n    \n    // Reinsert the element with the new priority\n    var newElement := (newPriority, oldValue);\n    var j := 0;\n    while j < |elements| && elements[j].0 <= newPriority\n      invariant 0 <= j <= |elements|\n      invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n    {\n      j := j + 1;\n    }\n    elements := elements[..j] + [newElement] + elements[j..];\n  }\n}",
            "parents": [
                "70476838-41f7-4ba1-b7e3-0430f4e253d6"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "c4e4eff1-9447-45da-b9f9-966336b325af",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n}",
            "parents": [
                "1b5f08f0-4d3d-46bb-8364-a8bf224e24f9"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "37b1c7b5-bca0-426b-a27b-1d024df8ec16",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> lis[k] == 1\n    invariant maxLength == 1\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i\n    invariant forall k, l :: 0 <= k < l < i && arr[k] < arr[l] ==> lis[k] < lis[l]\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k, l :: 0 <= k < l < i && arr[k] < arr[l] ==> lis[k] < lis[l]\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  length := maxLength;\n}",
            "parents": [
                "ef5e2ccb-f464-482e-bcda-f79412089a5a"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "361200ed-2206-410d-9dee-7b14ea7bd244",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k, l :: 0 <= k < l < i && arr[k] < arr[l] ==> lis[k] < lis[l]\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k, l :: 0 <= k < l < i && arr[k] < arr[l] ==> lis[k] < lis[l]\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  assert forall k, l :: 0 <= k < l < n && arr[k] < arr[l] ==> lis[k] < lis[l];\n  length := maxLength;\n}",
            "parents": [
                "06ba2f07-fbf7-430a-a181-3deb6d20bbe3"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "548ee0fb-906c-4b94-954d-7e34b5e0f8d5",
            "type": "program",
            "content": "method IsValidStackSequence(operations: seq<string>) returns (isValid: bool)\n  ensures isValid == (forall i :: 0 <= i < |operations| ==> operations[i] == \"push\" || operations[i] == \"pop\")\n{\n  var stackSize := 0;\n  isValid := true;\n  // Loop through each operation in the sequence\n  for i := 0 to |operations| \n    invariant 0 <= stackSize\n    invariant 0 <= i <= |operations|\n    invariant isValid == (forall j :: 0 <= j < i ==> operations[j] == \"push\" || operations[j] == \"pop\")\n  {\n    if operations[i] == \"push\" {\n      stackSize := stackSize + 1;\n    } else if operations[i] == \"pop\" {\n      if stackSize == 0 {\n        isValid := false;\n        return;\n      }\n      stackSize := stackSize - 1;\n    } else {\n      isValid := false;\n      return;\n    }\n  }\n  var maxStackSize := 0;\n  stackSize := 0; // Reset stackSize for the second loop\n  for i := 0 to |operations| \n    invariant 0 <= stackSize\n    invariant 0 <= i <= |operations|\n    invariant isValid == (forall j :: 0 <= j < i ==> operations[j] == \"push\" || operations[j] == \"pop\")\n    invariant maxStackSize >= stackSize\n  {\n    if operations[i] == \"push\" {\n      stackSize := stackSize + 1;\n      if stackSize > maxStackSize {\n        maxStackSize := stackSize;\n      }\n    } else if operations[i] == \"pop\" {\n      if stackSize == 0 {\n        isValid := false;\n        return;\n      }\n      stackSize := stackSize - 1;\n    } else {\n      isValid := false;\n      return;\n    }\n  }\n}",
            "parents": [
                "4251edc1-eb92-408b-a9b9-72456f447f1c"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "5b849512-9261-47f1-aef0-e80e59c63f0f",
            "type": "program",
            "content": "class Graph {\n  var adjacencyMatrix: array2<bool>;\n\n  constructor(n: nat) \n    requires n > 0\n    ensures adjacencyMatrix.Length0 == n && adjacencyMatrix.Length1 == n\n    ensures forall i, j :: 0 <= i < n && 0 <= j < n ==> !adjacencyMatrix[i, j]\n  {\n    adjacencyMatrix := new bool[n, n];\n  }\n\n  method AddEdge(u: nat, v: nat)\n    requires 0 <= u < adjacencyMatrix.Length0\n    requires 0 <= v < adjacencyMatrix.Length1\n    modifies adjacencyMatrix\n    ensures adjacencyMatrix[u, v] && adjacencyMatrix[v, u]\n  {\n    adjacencyMatrix[u, v] := true;\n    adjacencyMatrix[v, u] := true;\n  }\n\n  method IsVertexCover(cover: set<nat>) returns (isCover: bool)\n    requires cover <= set i | 0 <= i < adjacencyMatrix.Length0\n    ensures isCover == (forall u, v :: 0 <= u < adjacencyMatrix.Length0 && 0 <= v < adjacencyMatrix.Length1 && adjacencyMatrix[u, v] ==> u in cover || v in cover)\n  {\n    isCover := true;\n    var n := adjacencyMatrix.Length0;\n    for u := 0 to n - 1 \n      invariant 0 <= u <= n\n      invariant isCover == (forall i, j :: 0 <= i < u && 0 <= j < n && adjacencyMatrix[i, j] ==> i in cover || j in cover)\n    {\n      for v := 0 to n - 1 \n        invariant 0 <= v <= n\n        invariant isCover == (forall i, j :: 0 <= i < u && 0 <= j < n && adjacencyMatrix[i, j] ==> i in cover || j in cover)\n        invariant isCover == (forall j :: 0 <= j < v && adjacencyMatrix[u, j] ==> u in cover || j in cover)\n      {\n        if adjacencyMatrix[u, v] && !(u in cover || v in cover) {\n          isCover := false;\n          return;\n        }\n      }\n    }\n  }\n\n  method IsCompleteGraph() returns (isComplete: bool)\n    ensures isComplete == (forall u, v :: 0 <= u < adjacencyMatrix.Length0 && 0 <= v < adjacencyMatrix.Length1 && u != v ==> adjacencyMatrix[u, v])\n  {\n    isComplete := true;\n    var n := adjacencyMatrix.Length0;\n    for u := 0 to n - 1\n      invariant 0 <= u <= n\n      invariant isComplete == (forall i, j :: 0 <= i < u && 0 <= j < n && i != j ==> adjacencyMatrix[i, j])\n    {\n      for v := 0 to n - 1\n        invariant 0 <= v <= n\n        invariant isComplete == (forall i, j :: 0 <= i < u && 0 <= j < n && i != j ==> adjacencyMatrix[i, j])\n        invariant isComplete == (forall j :: 0 <= j < v && u != j ==> adjacencyMatrix[u, j])\n      {\n        if u != v && !adjacencyMatrix[u, v] {\n          isComplete := false;\n          return;\n        }\n      }\n    }\n  }\n}",
            "parents": [
                "499cfc20-2d66-4bad-a657-6bd0b1653157"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "be5a346d-4dd0-413f-b663-d4a2805396b5",
            "type": "program",
            "content": "class Graph {\n  var adjacencyMatrix: array2<bool>;\n\n  constructor(n: nat) \n    requires n > 0\n    ensures adjacencyMatrix.Length0 == n && adjacencyMatrix.Length1 == n\n    ensures forall i, j :: 0 <= i < n && 0 <= j < n ==> !adjacencyMatrix[i, j]\n  {\n    adjacencyMatrix := new bool[n, n];\n  }\n\n  method AddEdge(u: nat, v: nat)\n    requires 0 <= u < adjacencyMatrix.Length0\n    requires 0 <= v < adjacencyMatrix.Length1\n    modifies adjacencyMatrix\n    ensures adjacencyMatrix[u, v] && adjacencyMatrix[v, u]\n  {\n    adjacencyMatrix[u, v] := true;\n    adjacencyMatrix[v, u] := true;\n  }\n\n  method IsVertexCover(cover: set<nat>) returns (isCover: bool)\n    requires cover <= set i | 0 <= i < adjacencyMatrix.Length0\n    ensures isCover == (forall u, v :: 0 <= u < adjacencyMatrix.Length0 && 0 <= v < adjacencyMatrix.Length1 && adjacencyMatrix[u, v] ==> u in cover || v in cover)\n  {\n    isCover := true;\n    var n := adjacencyMatrix.Length0;\n    for u := 0 to n - 1 \n      invariant 0 <= u <= n\n      invariant isCover ==> (forall i, j :: 0 <= i < u && 0 <= j < n && adjacencyMatrix[i, j] ==> i in cover || j in cover)\n    {\n      for v := 0 to n - 1 \n        invariant 0 <= v <= n\n        invariant isCover ==> (forall i, j :: 0 <= i < u && 0 <= j < n && adjacencyMatrix[i, j] ==> i in cover || j in cover) &&\n                               (forall j :: 0 <= j < v && adjacencyMatrix[u, j] ==> u in cover || j in cover)\n      {\n        if adjacencyMatrix[u, v] && !(u in cover || v in cover) {\n          isCover := false;\n          return;\n        }\n      }\n    }\n  }\n\n  method IsCompleteGraph() returns (isComplete: bool)\n    ensures isComplete == (forall u, v :: 0 <= u < adjacencyMatrix.Length0 && 0 <= v < adjacencyMatrix.Length1 && u != v ==> adjacencyMatrix[u, v])\n  {\n    isComplete := true;\n    var n := adjacencyMatrix.Length0;\n    for u := 0 to n - 1\n      invariant 0 <= u <= n\n      invariant isComplete == (forall i, j :: 0 <= i < u && 0 <= j < n && i != j ==> adjacencyMatrix[i, j])\n    {\n      for v := 0 to n - 1\n        invariant 0 <= v <= n\n        invariant isComplete == (forall i, j :: 0 <= i < u && 0 <= j < n && i != j ==> adjacencyMatrix[i, j]) &&\n                               (forall j :: 0 <= j < v && u != j ==> adjacencyMatrix[u, j])\n      {\n        if u != v && !adjacencyMatrix[u, v] {\n          isComplete := false;\n          return;\n        }\n      }\n    }\n  }\n}",
            "parents": [
                "498b0fa7-33e0-4d30-958c-71042506ae70"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "32b9e83c-8f5a-49b0-96c0-cb2fcd3e4e10",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant exists i: int :: left <= i <= right && \n              (forall j: int :: left <= j < i ==> arr[j] <= arr[i]) &&\n              (forall j: int :: i < j <= right ==> arr[j] >= arr[i])\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "d0c6d61a-a938-45ec-99d0-57a898f70f86"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "c9d05711-3134-46e2-945d-cc69b31789af",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures elements == old(elements)\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(oldValue: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == oldValue\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, oldValue)\n  {\n    var i := 0;\n    // Find the element with the specified value\n    while i < |elements| && elements[i].1 != oldValue\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != oldValue\n    {\n      i := i + 1;\n    }\n    // Remove the element\n    elements := elements[..i] + elements[i+1..];\n    \n    // Reinsert the element with the new priority\n    var newElement := (newPriority, oldValue);\n    var j := 0;\n    while j < |elements| && elements[j].0 <= newPriority\n      invariant 0 <= j <= |elements|\n      invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n      invariant elements == old(elements[..i] + elements[i+1..])\n    {\n      j := j + 1;\n    }\n    elements := elements[..j] + [newElement] + elements[j..];\n  }\n  method Merge(other: PriorityQueue)\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures |elements| == old(|elements|) + |other.elements|\n    ensures forall e :: e in other.elements ==> e in elements\n  {\n    var i := 0;\n    while i < |other.elements|\n      invariant 0 <= i <= |other.elements|\n      invariant |elements| == old(|elements|) + i\n      invariant forall j, k :: 0 <= j < k < |elements| ==> elements[j].0 <= elements[k].0\n      invariant forall e :: e in other.elements[..i] ==> e in elements\n    {\n      var (priority, value) := other.elements[i];\n      this.Enqueue(priority, value);\n      i := i + 1;\n    }\n  }\n}",
            "parents": [
                "add9b37b-529c-41d8-9a87-1190d778fa35"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "401a50ec-4a14-4833-8d6a-b16c2142dae4",
            "type": "program",
            "content": "method DotProduct(a: seq<int>, b: seq<int>) returns (result: int)\n  requires |a| == |b|\n  ensures result == DotProductSpec(a, b)\n{\n  var sum := 0;\n  var i := 0;\n  while i < |a|\n    invariant 0 <= i <= |a|\n    invariant sum == DotProductSpec(a[..i], b[..i])\n    decreases |a| - i\n  {\n    sum := sum + a[i] * b[i];\n    i := i + 1;\n  }\n  result := sum;\n}\n\nfunction DotProductSpec(a: seq<int>, b: seq<int>): int\n  requires |a| == |b|\n{\n  if |a| == 0 then 0 else a[0] * b[0] + DotProductSpec(a[1..], b[1..])\n}",
            "parents": [
                "775329f6-3267-4f17-b9d7-56f5fe0f1959"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "dcb511aa-6410-4845-b08a-6963d8bf6d82",
            "type": "program",
            "content": "class Graph {\n  var adjacencyMatrix: array2<bool>;\n\n  constructor(n: nat) \n    requires n > 0\n    ensures adjacencyMatrix.Length0 == n && adjacencyMatrix.Length1 == n\n    ensures forall i, j :: 0 <= i < n && 0 <= j < n ==> !adjacencyMatrix[i, j]\n  {\n    adjacencyMatrix := new bool[n, n];\n  }\n\n  method AddEdge(u: nat, v: nat)\n    requires 0 <= u < adjacencyMatrix.Length0\n    requires 0 <= v < adjacencyMatrix.Length1\n    modifies adjacencyMatrix\n    ensures adjacencyMatrix[u, v] && adjacencyMatrix[v, u]\n  {\n    adjacencyMatrix[u, v] := true;\n    adjacencyMatrix[v, u] := true;\n  }\n\n  method IsVertexCover(cover: set<nat>) returns (isCover: bool)\n    requires cover <= set i | 0 <= i < adjacencyMatrix.Length0\n    ensures isCover == (forall u, v :: 0 <= u < adjacencyMatrix.Length0 && 0 <= v < adjacencyMatrix.Length1 && adjacencyMatrix[u, v] ==> u in cover || v in cover)\n  {\n    isCover := true;\n    var n := adjacencyMatrix.Length0;\n    for u := 0 to n - 1 {\n      for v := 0 to n - 1 \n        invariant 0 <= u < n\n        invariant 0 <= v <= n\n        invariant isCover == (forall i, j :: 0 <= i <= u && 0 <= j < n && adjacencyMatrix[i, j] ==> i in cover || j in cover)\n      {\n        if adjacencyMatrix[u, v] && !(u in cover || v in cover) {\n          isCover := false;\n          return;\n        }\n      }\n    }\n  }\n}",
            "parents": [
                "4cdc8acf-bd53-4262-9f62-d262ebc0d72c"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "SUCCESS"
            }
        },
        {
            "id": "9f4eb42c-a3cf-4233-9d1a-54a29fc561eb",
            "type": "program",
            "content": "method IsPerfectSquare(n: nat) returns (result: bool)\n  ensures result == (exists k: nat :: k * k == n)\n{\n  var k: nat := 0;\n  result := false;\n  while k * k <= n\n    invariant 0 <= k <= n + 1\n    invariant forall i: nat :: 0 <= i < k ==> i * i != n\n    invariant result == (exists i: nat :: 0 <= i < k && i * i == n)\n  {\n    if k * k == n {\n      result := true;\n      return;\n    }\n    k := k + 1;\n  }\n  assert forall i: nat :: 0 <= i < k ==> i * i != n;\n}",
            "parents": [
                "a695d42b-636a-4b6b-8ef8-9cce677f5da1"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "SUCCESS"
            }
        },
        {
            "id": "713bbc48-3dd6-4f14-9613-4317c434c06a",
            "type": "program",
            "content": "class Vector3D {\n  var x: int\n  var y: int\n  var z: int\n  constructor(x: int, y: int, z: int) \n    ensures this.x == x && this.y == y && this.z == z\n  {\n    this.x := x;\n    this.y := y;\n    this.z := z;\n  }\n  method CrossProduct(other: Vector3D) returns (result: Vector3D)\n    ensures result.x == this.y * other.z - this.z * other.y\n    ensures result.y == this.z * other.x - this.x * other.z\n    ensures result.z == this.x * other.y - this.y * other.x\n  {\n    var cx := this.y * other.z - this.z * other.y;\n    var cy := this.z * other.x - this.x * other.z;\n    var cz := this.x * other.y - this.y * other.x;\n    result := new Vector3D(cx, cy, cz);\n  }\n  method DotProduct(other: Vector3D) returns (result: int)\n    ensures result == this.x * other.x + this.y * other.y + this.z * other.z\n  {\n    var sum := 0;\n    var components := [this.x, this.y, this.z];\n    var otherComponents := [other.x, other.y, other.z];\n\n    // Loop over each component to calculate the dot product\n    var i := 0;\n    while i < 3\n      invariant 0 <= i <= 3\n      invariant sum == (if i >= 1 then components[0] * otherComponents[0] else 0)\n                        + (if i >= 2 then components[1] * otherComponents[1] else 0)\n                        + (if i >= 3 then components[2] * otherComponents[2] else 0)\n    {\n      sum := sum + components[i] * otherComponents[i];\n      i := i + 1;\n    }\n\n    result := sum;\n  }\n}",
            "parents": [
                "c8041bff-3eec-4f3b-b067-6bcba8c3d80f"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "SUCCESS"
            }
        },
        {
            "id": "0d813b9b-aa36-4d13-b5be-acae41b96ab3",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant exists i: int :: left <= i <= right && arr[i] == arr[k]\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "7143c048-e72b-40ac-9ad8-70c9f2a2c552"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "f15d3c1a-a8bd-4eca-8f65-f9dd4b1bf569",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n}",
            "parents": [
                "be6823b5-37e8-4c49-9e27-d36ea3976379"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "82f1ea8a-8e2b-42a1-8718-bb1728055cfc",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant exists i: int :: left <= i <= right && \n              (forall j: int :: left <= j < i ==> arr[j] <= arr[i]) &&\n              (forall j: int :: i < j <= right ==> arr[j] >= arr[i])\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "c48e1814-ca50-4b6e-b86c-3be0ef5feb3b"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "da8f0149-6af7-4d22-bb10-ceda00bcd35d",
            "type": "program",
            "content": "method IsPerfectSquare(n: nat) returns (result: bool)\n  ensures result == (exists k: nat :: k * k == n)\n{\n  var k: nat := 0;\n  result := false;\n  while k * k <= n\n    invariant 0 <= k <= n + 1\n    invariant forall i: nat :: 0 <= i < k ==> i * i != n\n    invariant result == (exists i: nat :: i < k && i * i == n)\n  {\n    if k * k == n {\n      result := true;\n      return;\n    }\n    k := k + 1;\n  }\n  assert forall i: nat :: i < k ==> i * i != n;\n}",
            "parents": [
                "f99cf830-6347-4cab-b3f3-1bdee2b7eefe"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "0954d8e0-5509-4cfe-8706-0bc8b0ee246d",
            "type": "program",
            "content": "method QuickSort(a: array<int>, lo: int, hi: int)\n  requires 0 <= lo <= hi <= a.Length\n  modifies a\n  ensures forall i, j :: lo <= i <= j < hi ==> a[i] <= a[j]\n{\n  if lo < hi {\n    var p := Partition(a, lo, hi);\n    QuickSort(a, lo, p);\n    QuickSort(a, p + 1, hi);\n  }\n}\n\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIndex: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIndex < hi\n  ensures forall i :: lo <= i < pivotIndex ==> a[i] <= a[pivotIndex]\n  ensures forall i :: pivotIndex < i < hi ==> a[pivotIndex] <= a[i]\n{\n  var pivot := a[lo];\n  var i := lo;\n  var j := hi;\n  while i < j\n    invariant lo <= i <= j <= hi\n    invariant forall k :: lo <= k < i ==> a[k] <= pivot\n    invariant forall k :: j <= k < hi ==> a[k] >= pivot\n    invariant exists p :: lo <= p < hi && a[p] == pivot\n  {\n    while i < j && a[i] <= pivot\n      invariant lo <= i < hi\n      invariant forall k :: lo <= k < i ==> a[k] <= pivot\n    {\n      i := i + 1;\n    }\n    while i < j && a[j - 1] >= pivot\n      invariant lo < j <= hi\n      invariant forall k :: j <= k < hi ==> a[k] >= pivot\n    {\n      j := j - 1;\n    }\n    if i < j {\n      a[i], a[j - 1] := a[j - 1], a[i];\n    }\n  }\n  pivotIndex := j - 1;\n  a[lo], a[pivotIndex] := a[pivotIndex], a[lo];\n}",
            "parents": [
                "5d87e78b-9ce9-4aeb-b2c9-d38c121a2aa5"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "ed01b8bf-3675-436a-a9f0-b28fc6e74823",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n    ensures elements == old(elements)\n  {\n    var i := 0;\n    var highestPriority := elements[0].0;\n    value := elements[0].1;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= highestPriority\n      invariant exists k :: 0 <= k < |elements| && elements[k].0 == highestPriority && value == elements[k].1\n      invariant elements == old(elements)\n    {\n      if elements[i].0 < highestPriority {\n        highestPriority := elements[i].0;\n        value := elements[i].1;\n      }\n      i := i + 1;\n    }\n    assert value == elements[0].1;\n  }\n}",
            "parents": [
                "7e3e9e41-6ccf-4a82-9892-1fb294c88c1a"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "11ce5cd1-4f18-4226-866b-26a89bfdbc08",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  \n  constructor() {\n    elements := [];\n  }\n\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n}",
            "parents": [
                "1a3259b2-7905-4744-befc-ce6414144ded"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "a4d15c75-3986-4d86-a258-d9575b39682b",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  \n  constructor() {\n    elements := [];\n  }\n\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    var i := 0;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 >= elements[i].0\n      invariant forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0\n    {\n      if elements[i].0 > elements[0].0 {\n        value := elements[i].1;\n        return;\n      }\n      i := i + 1;\n    }\n    value := elements[0].1;\n  }\n}",
            "parents": [
                "223a0b93-3151-4812-9c68-627387fa2a84"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "abb8f668-c715-4c64-87d8-9f2f2b65e522",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures elements == old(elements)\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n  }\n  method IsEmpty() returns (empty: bool)\n    ensures empty == (|elements| == 0)\n  {\n    empty := |elements| == 0;\n  }\n}",
            "parents": [
                "47ff9bac-d5ea-4f3a-8471-02581f09e109"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "b4b761b0-1219-4971-93fd-d084cc0e7de3",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n    invariant forall k, l :: 0 <= k < l < i && arr[k] < arr[l] ==> lis[l] >= lis[k] + 1\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n      invariant forall k, l :: 0 <= k < l < i && arr[k] < arr[l] ==> lis[l] >= lis[k] + 1\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n}",
            "parents": [
                "529870c8-8186-42dd-98a5-98af9652ac99"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "22148c59-4305-42a7-a9ca-b2960715f670",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(oldPriority: int, value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i] == (oldPriority, value)\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var i := 0;\n    while i < |elements| && elements[i] != (oldPriority, value)\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k] != (oldPriority, value)\n      invariant exists j :: i <= j < |elements| && elements[j] == (oldPriority, value)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + elements[i+1..];\n    var newElement := (newPriority, value);\n    i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n      invariant elements == old(elements[..i] + elements[i..])\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n}",
            "parents": [
                "805a06a8-b6bf-4a27-9b01-8bf98849d4a2"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "38156512-ab0a-42a6-aeb2-8bd6eeefbca6",
            "type": "program",
            "content": "method IsValidStackSequence(operations: seq<string>) returns (isValid: bool)\n  ensures isValid == (forall i :: 0 <= i < |operations| ==> operations[i] == \"push\" || operations[i] == \"pop\")\n{\n  var stackSize := 0;\n  isValid := true;\n  // Loop through each operation in the sequence\n  for i := 0 to |operations| \n    invariant 0 <= stackSize\n    invariant 0 <= i <= |operations|\n    invariant isValid == (forall j :: 0 <= j < i ==> operations[j] == \"push\" || operations[j] == \"pop\")\n    invariant isValid ==> (forall j :: 0 <= j < i ==> stackSize >= 0)\n  {\n    if operations[i] == \"push\" {\n      stackSize := stackSize + 1;\n    } else if operations[i] == \"pop\" {\n      if stackSize == 0 {\n        isValid := false;\n        return;\n      }\n      stackSize := stackSize - 1;\n    } else {\n      isValid := false;\n      return;\n    }\n  }\n  // Ensure that the loop invariant holds at the end of the loop\n  assert isValid == (forall j :: 0 <= j < |operations| ==> operations[j] == \"push\" || operations[j] == \"pop\");\n}",
            "parents": [
                "a8ad60b1-b66c-4fb0-af2a-127cfc0876b2"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "fffd2a31-d71e-4ce5-9695-b934c425706e",
            "type": "program",
            "content": "// A simple program to verify that a given configuration of queens on a chessboard is valid\n// i.e., no two queens attack each other.\nmethod IsValidQueenConfiguration(board: seq<seq<bool>>) returns (valid: bool)\n  requires |board| == 8 && forall row :: 0 <= row < |board| ==> |board[row]| == 8\n  ensures valid == true <==> (forall i, j, k, l :: 0 <= i < 8 && 0 <= j < 8 && 0 <= k < 8 && 0 <= l < 8 && board[i][j] && board[k][l] ==> (i == k && j == l) || (i != k && j != l && i - j != k - l && i + j != k + l))\n{\n  valid := true;\n  var n := 8;\n  // Check each pair of queens to ensure they do not attack each other\n  for i := 0 to n - 1\n    invariant 0 <= i <= n\n    invariant valid == true ==> (forall x, y, u, v :: 0 <= x < i && 0 <= y < n && 0 <= u < n && 0 <= v < n && board[x][y] && board[u][v] ==> (x == u && y == v) || (x != u && y != v && x - y != u - v && x + y != u + v))\n  {\n    for j := 0 to n - 1\n      invariant 0 <= j <= n\n      invariant valid == true ==> (forall x, y, u, v :: 0 <= x < i && 0 <= y < j && 0 <= u < n && 0 <= v < n && board[x][y] && board[u][v] ==> (x == u && y == v) || (x != u && y != v && x - y != u - v && x + y != u + v))\n    {\n      if board[i][j] {\n        for k := 0 to n - 1\n          invariant 0 <= k <= n\n          invariant valid == true ==> (forall x, y, u, v :: 0 <= x < i && 0 <= y < j && 0 <= u < k && 0 <= v < n && board[x][y] && board[u][v] ==> (x == u && y == v) || (x != u && y != v && x - y != u - v && x + y != u + v))\n        {\n          for l := 0 to n - 1\n            invariant 0 <= l <= n\n            invariant valid == true ==> (forall x, y, u, v :: 0 <= x < i && 0 <= y < j && 0 <= u < k && 0 <= v < l && board[x][y] && board[u][v] ==> (x == u && y == v) || (x != u && y != v && x - y != u - v && x + y != u + v))\n          {\n            if board[k][l] && (i != k || j != l) {\n              // Check if they are in the same row, column, or diagonal\n              if i == k || j == l || i - j == k - l || i + j == k + l {\n                valid := false;\n                return;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
            "parents": [
                "748917f8-aa21-4cc5-b49a-7dd1b1d93e06"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "8d6e13c1-e3da-4473-93c9-94828c1dad40",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> maxLength >= lis[k]\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n}",
            "parents": [
                "5ace900e-0e58-4dcb-9451-ef12d1bebe7e"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "db6e213a-af73-4416-a240-61a616f51b93",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant exists i: int :: left <= i <= right && \n              (forall j: int :: left <= j < i ==> arr[j] <= arr[i]) &&\n              (forall j: int :: i < j <= right ==> arr[j] >= arr[i])\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "8950e131-3ee6-4481-9d18-35785b388425"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "94f22a62-31ca-49bf-a7b6-149512ea9157",
            "type": "program",
            "content": "method MontyHallSimulation(switch: bool) returns (winProbability: real)\n  requires switch == true || switch == false\n  ensures 0.0 <= winProbability <= 1.0\n{\n  var totalGames := 1000;\n  var wins := 0;\n  var i := 0;\n  while i < totalGames\n    invariant 0 <= i <= totalGames\n    invariant 0 <= wins <= i\n  {\n    var carDoor := i % 3; // Simulate the car being behind one of the 3 doors\n    var chosenDoor := (i * 2) % 3; // Simulate the contestant's initial choice\n    if switch {\n      // If the contestant switches, they win if their initial choice was wrong\n      if chosenDoor != carDoor {\n        wins := wins + 1;\n      }\n    } else {\n      // If the contestant doesn't switch, they win if their initial choice was correct\n      if chosenDoor == carDoor {\n        wins := wins + 1;\n      }\n    }\n    i := i + 1;\n  }\n  winProbability := wins as real / totalGames as real;\n}",
            "parents": [
                "idea-60"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "SUCCESS"
            }
        },
        {
            "id": "f8268408-7d7d-4802-af38-468dd674c65a",
            "type": "program",
            "content": "// A simple Dafny program to calculate the area of a triangle given its vertex coordinates\n// using the Shoelace formula.\nmethod TriangleArea(x1: real, y1: real, x2: real, y2: real, x3: real, y3: real) returns (area: real)\n  requires x1 != x2 || y1 != y2 // Ensure vertices are distinct\n  requires x2 != x3 || y2 != y3\n  requires x3 != x1 || y3 != y1\n  ensures area >= 0.0\n{\n  // Shoelace formula for the area of a triangle\n  area := 0.5 * ((x1 * y2 + x2 * y3 + x3 * y1) - (y1 * x2 + y2 * x3 + y3 * x1));\n  if area < 0.0 {\n    area := -area; // Ensure the area is non-negative\n  }\n}",
            "parents": [
                "idea-78"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "SUCCESS"
            }
        },
        {
            "id": "7f165ac2-88ee-4906-b1ae-8a3bdf7fd9ef",
            "type": "program",
            "content": "datatype Expr = \n  | Const(c: int)\n  | Var(x: string)\n  | Add(e1: Expr, e2: Expr)\n  | Mul(e1: Expr, e2: Expr)\nfunction Derivative(e: Expr, v: string): Expr\n  decreases e\n{\n  match e\n  case Const(c) => Const(0)\n  case Var(x) => if x == v then Const(1) else Const(0)\n  case Add(e1, e2) => Add(Derivative(e1, v), Derivative(e2, v))\n  case Mul(e1, e2) => Add(Mul(Derivative(e1, v), e2), Mul(e1, Derivative(e2, v)))\n}\nmethod VerifyDerivative(e: Expr, v: string)\n  ensures Derivative(e, v) == Derivative(e, v)\n{\n  var d := Derivative(e, v);\n  assert d == Derivative(e, v);\n}",
            "parents": [
                "idea-185"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "SUCCESS"
            }
        },
        {
            "id": "3b31f8d6-915d-4c75-a055-6ecea83e97ec",
            "type": "program",
            "content": "method DotProduct(a: seq<int>, b: seq<int>) returns (result: int)\n  requires |a| == |b|\n  ensures result == DotProductSpec(a, b)\n{\n  var sum := 0;\n  var i := 0;\n  while i < |a|\n    invariant 0 <= i <= |a|\n    invariant sum == DotProductSpec(a[..i], b[..i])\n  {\n    sum := sum + a[i] * b[i];\n    i := i + 1;\n  }\n  result := sum;\n}\nfunction DotProductSpec(a: seq<int>, b: seq<int>): int\n  requires |a| == |b|\n{\n  if |a| == 0 then 0 else a[0] * b[0] + DotProductSpec(a[1..], b[1..])\n}",
            "parents": [
                "idea-76"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "b7209d47-b4a9-46e5-be0c-8c62ff5d3767",
            "type": "program",
            "content": "class Queue<T> {\n  var elements: seq<T>\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(x: T)\n    modifies this\n  {\n    elements := elements + [x];\n  }\n  method Dequeue() returns (x: T)\n    requires |elements| > 0\n    modifies this\n    ensures x == old(elements[0])\n    ensures elements == old(elements[1..])\n  {\n    x := elements[0];\n    elements := elements[1..];\n  }\n  method IsEmpty() returns (b: bool)\n    ensures b == (|elements| == 0)\n  {\n    b := |elements| == 0;\n  }\n}",
            "parents": [
                "idea-4"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "SUCCESS"
            }
        },
        {
            "id": "d037d1de-f60f-4fc8-a0af-fe28847bcdcf",
            "type": "program",
            "content": "method TriangularNumber(n: nat) returns (t: nat)\n  requires n >= 0\n  ensures t == n * (n + 1) / 2\n{\n  var sum := 0;\n  var i := 0;\n  while i <= n\n    invariant 0 <= i <= n + 1\n    invariant sum == i * (i - 1) / 2\n  {\n    sum := sum + i;\n    i := i + 1;\n  }\n  t := sum;\n}",
            "parents": [
                "idea-90"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "SUCCESS"
            }
        },
        {
            "id": "22783142-a2bc-4944-ae62-56eb89339981",
            "type": "program",
            "content": "class Node {\n  var value: int\n  var left: Node?\n  var right: Node?\n  constructor(v: int) {\n    value := v;\n    left := null;\n    right := null;\n  }\n}\nclass BinarySearchTree {\n  var root: Node?\n  method Insert(v: int) \n    modifies this\n    ensures IsBST(root)\n  {\n    root := InsertHelper(root, v);\n  }\n  method InsertHelper(n: Node?, v: int) returns (result: Node?)\n    ensures IsBST(result)\n  {\n    if n == null {\n      return new Node(v);\n    }\n    if v < n.value {\n      n.left := InsertHelper(n.left, v);\n    } else if v > n.value {\n      n.right := InsertHelper(n.right, v);\n    }\n    return n;\n  }\n  predicate IsBST(n: Node?) \n    reads n\n  {\n    n == null || \n    (IsBST(n.left) && IsBST(n.right) &&\n     (n.left == null || MaxValue(n.left) < n.value) &&\n     (n.right == null || MinValue(n.right) > n.value))\n  }\n  function MaxValue(n: Node?): int\n    requires n != null\n    reads n\n  {\n    if n.right == null then n.value else MaxValue(n.right)\n  }\n  function MinValue(n: Node?): int\n    requires n != null\n    reads n\n  {\n    if n.left == null then n.value else MinValue(n.left)\n  }\n}",
            "parents": [
                "idea-6"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "b0587eeb-d384-4ed6-88f1-be4e08edc60f",
            "type": "program",
            "content": "method CoinChange(coins: seq<int>, amount: int) returns (minCoins: int)\n  requires amount >= 0\n  requires forall c :: c in coins ==> c > 0\n  ensures minCoins >= -1\n  ensures minCoins == -1 || minCoins * 1 <= amount\n{\n  var dp := new int[amount + 1];\n  dp[0] := 0;\n  var i: int := 1;\n  while i <= amount\n    invariant 0 <= i <= amount + 1\n    invariant dp[0] == 0\n    invariant forall j :: 0 <= j < i ==> dp[j] >= 0 || dp[j] == -1\n  {\n    dp[i] := -1;\n    var j: int := 0;\n    while j < |coins|\n      invariant 0 <= j <= |coins|\n      invariant dp[i] >= -1\n    {\n      if i >= coins[j] && dp[i - coins[j]] != -1 {\n        if dp[i] == -1 || dp[i] > dp[i - coins[j]] + 1 {\n          dp[i] := dp[i - coins[j]] + 1;\n        }\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  minCoins := dp[amount];\n}",
            "parents": [
                "idea-65"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "ff106d62-74d3-45d5-a861-8e362e08884a",
            "type": "program",
            "content": "method TextSegmentation(s: seq<char>, dict: set<seq<char>>) returns (result: seq<seq<char>>)\n  requires |s| > 0\n  ensures forall segment: seq<char> :: segment in result ==> segment in dict\n  ensures |result| > 0\n{\n  var n := |s|;\n  var dp: array<bool> := new bool[n + 1];\n  dp[0] := true;\n  var segments: array<seq<seq<char>>> := new seq<seq<char>>[n + 1];\n  segments[0] := [];\n  for i := 1 to n {\n    dp[i] := false;\n    segments[i] := [];\n    for j := 0 to i - 1 {\n      if dp[j] && s[j..i] in dict {\n        dp[i] := true;\n        segments[i] := segments[j] + [s[j..i]];\n        break;\n      }\n    }\n    assert dp[i] ==> segments[i] != [];\n  }\n  result := segments[n];\n}",
            "parents": [
                "idea-189"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "d42281c9-bb07-4a62-8a1c-f35d0220bd8d",
            "type": "program",
            "content": "method LongestCommonPrefix(strings: seq<seq<char>>) returns (prefix: seq<char>)\n  requires |strings| > 0\n  ensures forall s: seq<char> :: s in strings ==> prefix <= s\n  ensures forall p: seq<char> :: (forall s: seq<char> :: s in strings ==> p <= s) ==> p <= prefix\n{\n  var minLength := if |strings| == 0 then 0 else |strings[0]|;\n  for i := 1 to |strings| {\n    minLength := if |strings[i]| < minLength then |strings[i]| else minLength;\n  }\n  prefix := [];\n  var i := 0;\n  while i < minLength\n    invariant 0 <= i <= minLength\n    invariant forall s: seq<char> :: s in strings ==> prefix <= s[..i]\n    decreases minLength - i\n  {\n    var currentChar := strings[0][i];\n    var allMatch := true;\n    for j := 1 to |strings| {\n      if strings[j][i] != currentChar {\n        allMatch := false;\n        break;\n      }\n    }\n    if allMatch {\n      prefix := prefix + [currentChar];\n      i := i + 1;\n    } else {\n      break;\n    }\n  }\n}",
            "parents": [
                "idea-95"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "8e4ec1fc-6876-4ad8-98dd-24601de53ef7",
            "type": "program",
            "content": "method IsBalancedParentheses(s: seq<char>) returns (balanced: bool)\n  ensures balanced == (CountUnmatched(s) == 0)\n{\n  var unmatched := 0;\n  var i := 0;\n  while i < |s|\n    invariant 0 <= unmatched <= i\n    invariant 0 <= i <= |s|\n    decreases |s| - i\n  {\n    if s[i] == '(' {\n      unmatched := unmatched + 1;\n    } else if s[i] == ')' {\n      if unmatched == 0 {\n        return false;\n      }\n      unmatched := unmatched - 1;\n    }\n    i := i + 1;\n  }\n  return unmatched == 0;\n}\nfunction CountUnmatched(s: seq<char>): int\n  decreases s\n{\n  if |s| == 0 then\n    0\n  else if s[0] == '(' then\n    1 + CountUnmatched(s[1..])\n  else if s[0] == ')' then\n    -1 + CountUnmatched(s[1..])\n  else\n    CountUnmatched(s[1..])\n}",
            "parents": [
                "idea-17"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "ff19a7c3-9cda-489f-b71c-01db8f72a697",
            "type": "program",
            "content": "class Rectangle {\n  var x1: int;\n  var y1: int;\n  var x2: int;\n  var y2: int;\n  constructor(x1: int, y1: int, x2: int, y2: int)\n    requires x1 <= x2 && y1 <= y2\n  {\n    this.x1 := x1;\n    this.y1 := y1;\n    this.x2 := x2;\n    this.y2 := y2;\n  }\n}\nmethod IntersectionArea(r1: Rectangle, r2: Rectangle) returns (area: int)\n  ensures area >= 0\n{\n  var ix1 := if r1.x1 > r2.x1 then r1.x1 else r2.x1;\n  var iy1 := if r1.y1 > r2.y1 then r1.y1 else r2.y1;\n  var ix2 := if r1.x2 < r2.x2 then r1.x2 else r2.x2;\n  var iy2 := if r1.y2 < r2.y2 then r1.y2 else r2.y2;\n  if ix1 < ix2 && iy1 < iy2 {\n    area := (ix2 - ix1) * (iy2 - iy1);\n  } else {\n    area := 0;\n  }\n}",
            "parents": [
                "idea-102"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "SUCCESS"
            }
        },
        {
            "id": "ad026a0a-9fde-4780-ad90-93c8c97b0ce0",
            "type": "program",
            "content": "method IsValidSudokuRow(board: array2<int>, row: int) returns (isValid: bool)\n  requires 0 <= row < board.Length0\n  requires board.Length1 == 9\n  ensures isValid == (forall i, j :: 0 <= i < j < 9 ==> board[row, i] != board[row, j])\n{\n  var seen := new bool[9];\n  isValid := true;\n  for i := 0 to 8\n    invariant 0 <= i <= 9\n    invariant forall k :: 0 <= k < i ==> 0 <= board[row, k] < 9\n    invariant forall k :: 0 <= k < i ==> seen[board[row, k]]\n    invariant isValid == (forall a, b :: 0 <= a < b < i ==> board[row, a] != board[row, b])\n  {\n    if seen[board[row, i]] {\n      isValid := false;\n      return;\n    }\n    seen[board[row, i]] := true;\n  }\n}",
            "parents": [
                "idea-69"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "e35f0bb6-b1e3-4239-8752-4ffc017888f9",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures elements == old(elements)\n    ensures value == elements[0].1\n  {\n    var highestPriority := elements[0].0;\n    var highestValue := elements[0].1;\n    var i := 1;\n    while i < |elements|\n      invariant 1 <= i <= |elements|\n      invariant highestPriority == elements[0].0\n      invariant highestValue == elements[0].1\n      invariant forall k :: 0 <= k < i ==> elements[k].0 >= highestPriority\n    {\n      if elements[i].0 < highestPriority {\n        highestPriority := elements[i].0;\n        highestValue := elements[i].1;\n      }\n      i := i + 1;\n    }\n    value := highestValue;\n  }\n  method ChangePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n    {\n      i := i + 1;\n    }\n    // Remove the element with the specified value\n    elements := elements[..i] + elements[i+1..];\n    \n    // Re-insert the element with the new priority\n    var newElement := (newPriority, value);\n    i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\nmethod FindMaxPriority() returns (maxPriority: int)\n  requires |elements| > 0\n  ensures exists i :: 0 <= i < |elements| && elements[i].0 == maxPriority\n  ensures forall i :: 0 <= i < |elements| ==> elements[i].0 <= maxPriority\n{\n  var maxP := elements[0].0;\n  var i := 1;\n  while i < |elements|\n    invariant 1 <= i <= |elements|\n    invariant exists j :: 0 <= j < i && elements[j].0 == maxP\n    invariant forall j :: 0 <= j < i ==> elements[j].0 <= maxP\n  {\n    if elements[i].0 > maxP {\n      maxP := elements[i].0;\n    }\n    i := i + 1;\n  }\n  maxPriority := maxP;\n}\n}",
            "parents": [
                "f4459605-baa8-46a1-9144-2895e6e19d8a"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "83218e5f-4829-4490-b294-dc54dbaae7ad",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures elements == old(elements)\n  ensures value == elements[0].1\n{\n  var highestPriority := elements[0].0;\n  var highestValue := elements[0].1;\n  var i := 1;\n  while i < |elements|\n    invariant 1 <= i <= |elements|\n    invariant highestPriority == elements[0].0\n    invariant highestValue == elements[0].1\n    invariant forall k :: 0 <= k < i ==> elements[k].0 >= highestPriority\n  {\n    if elements[i].0 < highestPriority {\n      highestPriority := elements[i].0;\n      highestValue := elements[i].1;\n    }\n    i := i + 1;\n  }\n  value := highestValue;\n}\nmethod ChangePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n  // Remove the element with the specified value\n  elements := elements[..i] + elements[i+1..];\n  \n  // Re-insert the element with the new priority\n  var newElement := (newPriority, value);\n  i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [newElement] + elements[i..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\nmethod GetPriorityOfValue(value: int) returns (priority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  ensures exists i :: 0 <= i < |elements| && elements[i].1 == value && priority == elements[i].0\n{\n  var i := 0;\n  priority := -1; // Default value, should never be returned due to precondition\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant priority == -1\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n  priority := elements[i].0;\n  assert exists i :: 0 <= i < |elements| && elements[i].1 == value && priority == elements[i].0;\n}\n}",
            "parents": [
                "acc10745-d709-4a13-91d2-bd5dc8b4da10"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "d5f4b0cb-f254-4b21-a53f-6a4b4b3a00ce",
            "type": "program",
            "content": "method IsPerfectSquare(n: nat) returns (result: bool)\n  ensures result == (exists k: nat :: k * k == n)\n{\n  var k: nat := 0;\n  result := false;\n  while k * k <= n\n    invariant 0 <= k <= n + 1\n    invariant forall i: nat :: 0 <= i < k ==> i * i != n\n    invariant result == (exists i: nat :: i < k && i * i == n)\n  {\n    if k * k == n {\n      result := true;\n      return;\n    }\n    k := k + 1;\n  }\n  while k * k <= n\n    invariant 0 <= k <= n + 1\n    invariant forall i: nat :: 0 <= i < k ==> i * i != n\n    invariant result == (exists i: nat :: i < k && i * i == n)\n    invariant n - k * k <= n // New invariant: the difference is non-negative and decreasing\n  {\n    if k * k == n {\n      result := true;\n      return;\n    }\n    k := k + 1;\n  }\n}",
            "parents": [
                "f99cf830-6347-4cab-b3f3-1bdee2b7eefe"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "bd3d45d4-b97f-4b8c-a49c-effee6725dfa",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures elements == old(elements)\n  ensures value == elements[0].1\n{\n  var highestPriority := elements[0].0;\n  var highestValue := elements[0].1;\n  var i := 1;\n  while i < |elements|\n    invariant 1 <= i <= |elements|\n    invariant highestPriority == elements[0].0\n    invariant highestValue == elements[0].1\n    invariant forall k :: 0 <= k < i ==> elements[k].0 >= highestPriority\n  {\n    if elements[i].0 < highestPriority {\n      highestPriority := elements[i].0;\n      highestValue := elements[i].1;\n    }\n    i := i + 1;\n  }\n  value := highestValue;\n}\nmethod ChangePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n{\n  var i := 0;\n  // Find the element with the specified value\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n  // Remove the element from the sequence\n  elements := elements[..i] + elements[i+1..];\n  \n  // Re-insert with the new priority\n  i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [(newPriority, value)] + elements[i..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\n}",
            "parents": [
                "87652645-07de-4f8b-a7ba-4ad1f40c0a88"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "a2b3481e-c743-4e64-9675-9ebae3fa1746",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> maxLength >= lis[k]\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n  return maxLength;\n}",
            "parents": [
                "7201d35b-8e5d-4804-b741-e206c2263be3"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "46c59235-d34d-48b4-87f2-363c034e5ce7",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p < right ==> arr[p] > pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n    invariant forall r: int :: left <= r < j ==> arr[r] <= pivot || arr[r] > pivot\n    invariant forall s: int :: j <= s <= right ==> arr[s] >= pivot || arr[s] < pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}\n}",
            "parents": [
                "a3e62053-9c6d-48a9-b8e3-f4e0235d8f8b"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "065eed14-ae0c-40ee-91ad-58653b3a822a",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p < right ==> arr[p] > pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n    invariant forall r: int :: left <= r < i ==> arr[r] <= pivot\n    invariant forall s: int :: i <= s < j ==> arr[s] > pivot\n    invariant forall t: int :: j <= t <= right ==> arr[t] >= pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n    invariant (forall u: int :: left <= u <= right && arr[u] == pivot ==> \n              (left <= u < i || i <= u <= j || j < u <= right))\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "8950e131-3ee6-4481-9d18-35785b388425"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "621a9cf9-9717-4fc2-b268-5042db4e270c",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures elements == old(elements)\n    ensures value == elements[0].1\n  {\n    var highestPriority := elements[0].0;\n    var highestValue := elements[0].1;\n    var i := 1;\n    while i < |elements|\n      invariant 1 <= i <= |elements|\n      invariant highestPriority == elements[0].0\n      invariant highestValue == elements[0].1\n      invariant forall k :: 0 <= k < i ==> elements[k].0 >= highestPriority\n    {\n      if elements[i].0 < highestPriority {\n        highestPriority := elements[i].0;\n        highestValue := elements[i].1;\n      }\n      i := i + 1;\n    }\n    value := highestValue;\n  }\nmethod Clear()\n  modifies this\n  ensures |elements| == 0\n{\n  var i := 0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant |elements| == old(|elements|) - i\n  {\n    elements := elements[1..];\n    i := i + 1;\n  }\n}\n}",
            "parents": [
                "bd156f4f-816e-440e-9293-1f374647163a"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "1d6ceaed-053e-49bd-9d0e-2a434d4a5387",
            "type": "program",
            "content": "class Node {\n  var value: int\n  var left: Node?\n  var right: Node?\n  constructor(v: int) {\n    value := v;\n    left := null;\n    right := null;\n  }\n}\nclass BinarySearchTree {\n  var root: Node?\n  method Insert(v: int) \n    modifies this\n    ensures IsBST(root)\n  {\n    root := InsertHelper(root, v);\n  }\n  method InsertHelper(n: Node?, v: int) returns (result: Node?)\n    ensures IsBST(result)\n  {\n    if n == null {\n      return new Node(v);\n    }\n    if v < n.value {\n      n.left := InsertHelper(n.left, v);\n    } else if v > n.value {\n      n.right := InsertHelper(n.right, v);\n    }\n    return n;\n  }\n  predicate IsBST(n: Node?) \n    reads n\n  {\n    n == null || \n    (IsBST(n.left) && IsBST(n.right) &&\n     (n.left == null || MaxValue(n.left) < n.value) &&\n     (n.right == null || MinValue(n.right) > n.value))\n  }\n  function MaxValue(n: Node?): int\n    requires n != null\n    reads n\n  {\n    if n.right == null then n.value else MaxValue(n.right)\n  }\n  function MinValue(n: Node?): int\n    requires n != null\n    reads n\n  {\n    if n.left == null then n.value else MinValue(n.left)\n  }\nmethod Height(n: Node?) returns (h: int)\n  ensures h >= 0\n{\n  if n == null {\n    h := 0;\n  } else {\n    var leftHeight := Height(n.left);\n    var rightHeight := Height(n.right);\n    h := if leftHeight > rightHeight then leftHeight + 1 else rightHeight + 1;\n  }\n}\n}",
            "parents": [
                "22783142-a2bc-4944-ae62-56eb89339981"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "08ab482c-5bfd-4ce8-b920-e65edb1cfabf",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n    invariant forall k, l :: 0 <= k < l < i && arr[k] < arr[l] ==> lis[l] >= lis[k] + 1\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n      invariant forall k, l :: 0 <= k < l < i && arr[k] < arr[l] ==> lis[l] >= lis[k] + 1\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n    invariant forall k, l :: 0 <= k < l < i && arr[k] < arr[l] ==> lis[l] >= lis[k] + 1\n    invariant maxLength >= (if i > 0 then lis[i - 1] else 1) // New invariant\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n      invariant forall k, l :: 0 <= k < l < i && arr[k] < arr[l] ==> lis[l] >= lis[k] + 1\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n}",
            "parents": [
                "b4b761b0-1219-4971-93fd-d084cc0e7de3"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "15b62b82-d6b0-48fb-910c-77902ed912e7",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method IsEmpty() returns (empty: bool)\n    ensures empty == (|elements| == 0)\n  {\n    var i := 0;\n    empty := true;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant empty == (i == 0)\n    {\n      empty := false;\n      i := i + 1;\n    }\n  }\nmethod Merge(other: PriorityQueue)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures |elements| == |old(elements)| + |other.elements|\n  ensures multiset(elements) == multiset(old(elements) + other.elements)\n{\n  var merged: seq<(int, int)> := [];\n  var i := 0;\n  var j := 0;\n\n  while i < |elements| || j < |other.elements|\n    invariant 0 <= i <= |elements|\n    invariant 0 <= j <= |other.elements|\n    invariant |merged| == i + j\n    invariant forall k, l :: 0 <= k < l < |merged| ==> merged[k].0 <= merged[l].0\n    invariant multiset(merged) == multiset(old(elements[..i]) + other.elements[..j])\n  {\n    if i < |elements| && (j >= |other.elements| || elements[i].0 <= other.elements[j].0) {\n      merged := merged + [elements[i]];\n      i := i + 1;\n    } else {\n      merged := merged + [other.elements[j]];\n      j := j + 1;\n    }\n  }\n  elements := merged;\n}\n}",
            "parents": [
                "55d9d0e5-6f19-4a7e-b6e4-bb40226e663d"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "591b5fe3-7521-4743-a960-e11e7013292c",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures elements == old(elements)\n  ensures value == old(elements[0].1)\n{\n  value := elements[0].1;\n}\nmethod UpdatePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var index := -1;\n  var i := 0;\n  // Find the index of the element with the given value\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant index == -1 ==> forall k :: 0 <= k < i ==> elements[k].1 != value\n    invariant index != -1 ==> 0 <= index < |elements| && elements[index].1 == value\n  {\n    if elements[i].1 == value {\n      index := i;\n      break;\n    }\n    i := i + 1;\n  }\n  \n  // Remove the element at the found index\n  var element := elements[index];\n  elements := elements[..index] + elements[index + 1..];\n\n  // Re-insert the element with the new priority\n  var newElement := (newPriority, value);\n  i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [newElement] + elements[i..];\n}\n}",
            "parents": [
                "672811ec-af0c-4014-a56f-9d8dfb71a0b5"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "f2bb060d-2f66-4076-b07a-5aa9784e2ebc",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p < right ==> arr[p] > pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\nfor j := left to right - 1\n  invariant left <= i <= j <= right\n  invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n  invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n  invariant forall q: int :: left <= q <= right ==> \n            (arr[q] <= pivot || arr[q] > pivot)\n  invariant forall r: int :: 0 <= r < left || right < r < arr.Length ==> arr[r] == old(arr[r])\n{\n  if arr[j] <= pivot {\n    arr[i], arr[j] := arr[j], arr[i];\n    i := i + 1;\n  }\n}\narr[i], arr[right] := arr[right], arr[i];\nreturn i;\n}",
            "parents": [
                "a917cae4-7a3e-40aa-83f9-7186fb36c08f"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "373c3e66-b325-42a0-8a99-e4df3d180f5e",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures elements == old(elements)\n  ensures value == old(elements[0].1)\n{\n  value := elements[0].1;\n}\nmethod ChangePriority(oldValue: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == oldValue\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, oldValue)\n{\n  var i := 0;\n  // Find the element with the specified value\n  while i < |elements| && elements[i].1 != oldValue\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != oldValue\n  {\n    i := i + 1;\n  }\n  // Remove the element\n  elements := elements[..i] + elements[i+1..];\n  \n  // Reinsert the element with the new priority\n  var newElement := (newPriority, oldValue);\n  var j := 0;\n  while j < |elements| && elements[j].0 <= newPriority\n    invariant 0 <= j <= |elements|\n    invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n  {\n    j := j + 1;\n  }\n  elements := elements[..j] + [newElement] + elements[j..];\n}\nmethod Merge(other: PriorityQueue)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures |elements| == old(|elements|) + |other.elements|\n  ensures forall e :: e in other.elements ==> e in elements\n{\n  var i := 0;\n  while i < |other.elements|\n    invariant 0 <= i <= |other.elements|\n    invariant |elements| == old(|elements|) + i\n    invariant forall j, k :: 0 <= j < k < |elements| ==> elements[j].0 <= elements[k].0\n    invariant forall e :: e in other.elements[..i] ==> e in elements\n  {\n    var (priority, value) := other.elements[i];\n    this.Enqueue(priority, value);\n    i := i + 1;\n  }\n}\nmethod RemoveValue(value: int)\n  modifies this\n  ensures forall i :: 0 <= i < |elements| ==> elements[i].1 != value\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant forall j :: 0 <= j < i ==> elements[j].1 != value\n    invariant forall j, k :: 0 <= j < k < |elements| ==> elements[j].0 <= elements[k].0\n  {\n    if elements[i].1 == value {\n      elements := elements[..i] + elements[i+1..];\n    } else {\n      i := i + 1;\n    }\n  }\n}\n}",
            "parents": [
                "add9b37b-529c-41d8-9a87-1190d778fa35"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "5afcce6e-6568-4d52-a43c-6a89bc11f728",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n  ensures elements == old(elements)\n{\n  var i := 0;\n  var highestPriority := elements[0].0;\n  value := elements[0].1;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= highestPriority\n    invariant value == elements[0].1\n  {\n    if elements[i].0 < highestPriority {\n      highestPriority := elements[i].0;\n      value := elements[i].1;\n    }\n    i := i + 1;\n  }\n  assert value == elements[0].1;\n}\nmethod Clear()\n  modifies this\n  ensures |elements| == 0\n{\n  var i := 0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant |elements[i..]| == |elements| - i\n  {\n    elements := elements[1..];\n    i := i + 1;\n  }\n  assert |elements| == 0;\n}\n}",
            "parents": [
                "7e3e9e41-6ccf-4a82-9892-1fb294c88c1a"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "5fe70a95-228e-4a7e-8ade-222afa605d25",
            "type": "program",
            "content": "method CoinChange(coins: seq<int>, amount: int) returns (minCoins: int)\n  requires amount >= 0\n  requires forall c :: c in coins ==> c > 0\n  ensures minCoins >= -1\n  ensures minCoins == -1 || minCoins * 1 <= amount\n{\n  var dp := new int[amount + 1];\n  dp[0] := 0;\n  var i: int := 1;\n  while i <= amount\n    invariant 0 <= i <= amount + 1\n    invariant dp[0] == 0\n    invariant forall j :: 0 <= j < i ==> dp[j] >= 0 || dp[j] == -1\n  {\n    dp[i] := -1;\n    var j: int := 0;\n    while j < |coins|\n      invariant forall k :: 0 <= k < i ==> dp[k] <= k\n      invariant 0 <= j <= |coins|\n      invariant dp[i] >= -1\n    {\n}\n}\n}",
            "parents": [
                "b0587eeb-d384-4ed6-88f1-be4e08edc60f"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "87824759-a621-4bf0-b95b-f48af48a0fd1",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures elements == old(elements)\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(oldValue: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == oldValue\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, oldValue)\n  {\n    var i := 0;\n    // Find the element with the specified value\n    while i < |elements| && elements[i].1 != oldValue\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != oldValue\n      invariant exists j :: i <= j < |elements| && elements[j].1 == oldValue\n    {\n      i := i + 1;\n    }\n    // Remove the element\n    elements := elements[..i] + elements[i+1..];\n    \n    // Reinsert the element with the new priority\n    var newElement := (newPriority, oldValue);\n    var j := 0;\n    while j < |elements| && elements[j].0 <= newPriority\n      invariant 0 <= j <= |elements|\n      invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n    {\n      j := j + 1;\n    }\n    elements := elements[..j] + [newElement] + elements[j..];\n  }\nmethod UpdateValue(priority: int, newValue: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].0 == priority\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (priority, newValue)\n{\n  var i := 0;\n  // Find the element with the specified priority\n  while i < |elements| && elements[i].0 != priority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 != priority\n    invariant exists j :: i <= j < |elements| && elements[j].0 == priority\n  {\n    i := i + 1;\n  }\n  // Update the element's value\n  elements := elements[..i] + [(priority, newValue)] + elements[i+1..];\n}\n}",
            "parents": [
                "5639d8a4-aadb-4be9-a2fc-9051d5024df0"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "02c36c95-bc47-411a-ac2a-6417f4b19be3",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n    ensures elements == old(elements)\n  {\n    var i := 0;\n    var highestPriority := elements[0].0;\n    value := elements[0].1;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= highestPriority\n      invariant exists k :: 0 <= k < |elements| && elements[k].0 == highestPriority && value == elements[k].1\n      invariant elements == old(elements)\n    {\n      if elements[i].0 < highestPriority {\n        highestPriority := elements[i].0;\n        value := elements[i].1;\n      }\n      i := i + 1;\n    }\n    assert value == elements[0].1;\n  }\nmethod MaxPriority() returns (maxPriority: int)\n  requires |elements| > 0\n  ensures exists i :: 0 <= i < |elements| && elements[i].0 == maxPriority\n  ensures forall i :: 0 <= i < |elements| ==> elements[i].0 <= maxPriority\n  ensures elements == old(elements)\n{\n  var i := 0;\n  maxPriority := elements[0].0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant exists j :: 0 <= j < i && elements[j].0 == maxPriority\n    invariant forall j :: 0 <= j < i ==> elements[j].0 <= maxPriority\n    invariant elements == old(elements)\n  {\n    if elements[i].0 > maxPriority {\n      maxPriority := elements[i].0;\n    }\n    i := i + 1;\n  }\n  assert exists j :: 0 <= j < |elements| && elements[j].0 == maxPriority;\n  assert forall j :: 0 <= j < |elements| ==> elements[j].0 <= maxPriority;\n}\n}",
            "parents": [
                "ed01b8bf-3675-436a-a9f0-b28fc6e74823"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "a167c201-463a-45b6-b3f1-1db748256467",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant exists i: int :: left <= i <= right && arr[i] == arr[k]\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> arr[q] >= pivot || q < i\n    invariant forall r: int :: left <= r <= right ==> arr[r] <= pivot || r >= i\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "0d813b9b-aa36-4d13-b5be-acae41b96ab3"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "8f60c384-1c74-46e0-b61a-bf2fdb5f519f",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n    ensures elements == old(elements)\n  {\n    var i := 0;\n    var highestPriority := elements[0].0;\n    value := elements[0].1;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= highestPriority\n      invariant exists k :: 0 <= k < |elements| && elements[k].0 == highestPriority && value == elements[k].1\n    {\n      if elements[i].0 < highestPriority {\n        highestPriority := elements[i].0;\n        value := elements[i].1;\n      }\n      i := i + 1;\n    }\n    assert exists k :: 0 <= k < |elements| && elements[k].0 == highestPriority && value == elements[k].1;\n  }\n  method IsEmpty() returns (empty: bool)\n    ensures empty <==> |elements| == 0\n  {\n    empty := |elements| == 0;\n  }\n  method UpdatePriority(value: int, newPriority: int)\n    modifies this\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var i := 0;\n    var found := false;\n    while i < |elements| && !found\n      invariant 0 <= i <= |elements|\n      invariant !found ==> forall k :: 0 <= k < i ==> elements[k].1 != value\n    {\n      if elements[i].1 == value {\n        found := true;\n      } else {\n        i := i + 1;\n      }\n    }\n    if found {\n      var updatedElement := (newPriority, value);\n      elements := elements[..i] + elements[i+1..];\n      var j := 0;\n      while j < |elements| && elements[j].0 <= newPriority\n        invariant 0 <= j <= |elements|\n        invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n        invariant forall k, l :: 0 <= k < l < j ==> elements[k].0 <= elements[l].0\n      {\n        j := j + 1;\n      }\n      elements := elements[..j] + [updatedElement] + elements[j..];\n    }\n    assert forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0;\n  }\n}",
            "parents": [
                "24766049-782a-4a21-b0eb-95e541710466"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "27895798-fdf1-4ae6-b0c4-a594e2a527a7",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  \n  constructor() {\n    elements := [];\n  }\n\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\nmethod IsEmpty() returns (isEmpty: bool)\n  ensures isEmpty == (|elements| == 0)\n{\n  isEmpty := |elements| == 0;\n}\n}",
            "parents": [
                "11ce5cd1-4f18-4226-866b-26a89bfdbc08"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "02e7918a-0747-4f1c-b069-860f48c3f351",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  length := maxLength;\n  assert forall i, j :: 0 <= i < j < n && arr[i] < arr[j] ==> length >= j - i + 1;\n  return length;\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n      invariant forall k :: 0 <= k < j ==> arr[k] < arr[i] ==> lis[i] >= lis[k] + 1\n      invariant lis[i] <= maxLength\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n}",
            "parents": [
                "26c0afbb-ac15-46ec-bd57-7a20102170f0"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "155a201f-9ae9-44b2-bf7e-ed15c1c215f8",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\nmethod ChangePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n  var updatedElement := (newPriority, value);\n  elements := elements[..i] + elements[i+1..];\n  \n  // Re-insert the updated element\n  var j := 0;\n  while j < |elements| && elements[j].0 <= newPriority\n    invariant 0 <= j <= |elements|\n    invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n  {\n    j := j + 1;\n  }\n  elements := elements[..j] + [updatedElement] + elements[j..];\n}\n}",
            "parents": [
                "1b5f08f0-4d3d-46bb-8364-a8bf224e24f9"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "e526fc38-6297-4a55-9b75-bbd8a428c406",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n{\n  value := elements[0].1;\n}\nmethod ChangePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n  var oldElement := elements[i];\n  elements := elements[..i] + elements[i+1..];\n  var j := 0;\n  while j < |elements| && elements[j].0 <= newPriority\n    invariant 0 <= j <= |elements|\n    invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n    invariant forall k, l :: 0 <= k < l < j ==> elements[k].0 <= elements[l].0\n  {\n    j := j + 1;\n  }\n  elements := elements[..j] + [(newPriority, value)] + elements[j..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\nmethod RemoveValue(value: int) \n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures !exists i :: 0 <= i < |elements| && elements[i].1 == value\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + elements[i+1..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\n}",
            "parents": [
                "0e3e1fef-620d-44f1-9109-30887c600d5e"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "7679c90f-2f7f-4d06-855a-7816583305da",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n{\n  value := elements[0].1;\n}\nmethod UpdatePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n{\n  var index := 0;\n  while index < |elements| && elements[index].1 != value\n    invariant 0 <= index <= |elements|\n    invariant forall k :: 0 <= k < index ==> elements[k].1 != value\n  {\n    index := index + 1;\n  }\n\n  // Remove the element with the specified value\n  var priority := elements[index].0;\n  elements := elements[..index] + elements[index + 1..];\n\n  // Reinsert the element with the new priority\n  var newElement := (newPriority, value);\n  var i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [newElement] + elements[i..];\n}\n}",
            "parents": [
                "1a3259b2-7905-4744-befc-ce6414144ded"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "3bd28592-3e7d-46dc-a36e-b4db9f7cd4bd",
            "type": "program",
            "content": "class Graph {\n  var adjacencyMatrix: array2<bool>;\n\n  constructor(n: nat) \n    requires n > 0\n    ensures adjacencyMatrix.Length0 == n && adjacencyMatrix.Length1 == n\n    ensures forall i, j :: 0 <= i < n && 0 <= j < n ==> !adjacencyMatrix[i, j]\n  {\n    adjacencyMatrix := new bool[n, n];\n  }\n\n  method AddEdge(u: nat, v: nat)\n    requires 0 <= u < adjacencyMatrix.Length0\n    requires 0 <= v < adjacencyMatrix.Length1\n    modifies adjacencyMatrix\n    ensures adjacencyMatrix[u, v] && adjacencyMatrix[v, u]\n  {\n    adjacencyMatrix[u, v] := true;\n    adjacencyMatrix[v, u] := true;\n  }\n\n  method IsVertexCover(cover: set<nat>) returns (isCover: bool)\n    requires cover <= set i | 0 <= i < adjacencyMatrix.Length0\n    ensures isCover == (forall u, v :: 0 <= u < adjacencyMatrix.Length0 && 0 <= v < adjacencyMatrix.Length1 && adjacencyMatrix[u, v] ==> u in cover || v in cover)\n  {\n    isCover := true;\n    var n := adjacencyMatrix.Length0;\n    for u := 0 to n - 1 {\n      for v := 0 to n - 1 {\n        if adjacencyMatrix[u, v] && !(u in cover || v in cover) {\n          isCover := false;\n          return;\n        }\n      }\n    }\n  }\nmethod IsCompleteGraph() returns (isComplete: bool)\n  ensures isComplete == (forall u, v :: 0 <= u < adjacencyMatrix.Length0 && 0 <= v < adjacencyMatrix.Length1 && u != v ==> adjacencyMatrix[u, v])\n{\n  isComplete := true;\n  var n := adjacencyMatrix.Length0;\n  for u := 0 to n - 1\n    invariant 0 <= u <= n\n    invariant isComplete == (forall i, j :: 0 <= i < u && 0 <= j < n && i != j ==> adjacencyMatrix[i, j])\n  {\n    for v := 0 to n - 1\n      invariant 0 <= v <= n\n      invariant isComplete == (forall i, j :: 0 <= i < u && 0 <= j < n && i != j ==> adjacencyMatrix[i, j]) &&\n                             (forall i :: 0 <= i < u && i != u ==> adjacencyMatrix[u, i])\n    {\n      if u != v && !adjacencyMatrix[u, v] {\n        isComplete := false;\n        return;\n      }\n    }\n  }\n}\n}",
            "parents": [
                "4cdc8acf-bd53-4262-9f62-d262ebc0d72c"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "bd5e4a80-0b68-44e3-8b6f-c151e0b42635",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\nmethod ChangePriority(oldPriority: int, value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i] == (oldPriority, value)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |elements| && elements[i] != (oldPriority, value)\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k] != (oldPriority, value)\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + elements[i+1..];\n  var newElement := (newPriority, value);\n  i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [newElement] + elements[i..];\n}\nmethod Merge(other: PriorityQueue)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |other.elements|\n    invariant 0 <= i <= |other.elements|\n    invariant forall k :: 0 <= k < i ==> elements[..|elements|] + other.elements[..k] == elements[..|elements| + k]\n    invariant forall m, n :: 0 <= m < n < |elements| ==> elements[m].0 <= elements[n].0\n  {\n    var (priority, value) := other.elements[i];\n    var j := 0;\n    while j < |elements| && elements[j].0 <= priority\n      invariant 0 <= j <= |elements|\n      invariant forall k :: 0 <= k < j ==> elements[k].0 <= priority\n    {\n      j := j + 1;\n    }\n    elements := elements[..j] + [(priority, value)] + elements[j..];\n    i := i + 1;\n  }\n}\n}",
            "parents": [
                "805a06a8-b6bf-4a27-9b01-8bf98849d4a2"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "724c03af-5286-42cb-a89d-df21d91b6452",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n    invariant forall r: int :: left <= r < i ==> arr[r] <= pivot\n    invariant forall s: int :: i <= s < j ==> arr[s] > pivot\n    invariant forall t: int :: j <= t <= right ==> arr[t] >= pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n    invariant forall r: int :: left <= r < i ==> arr[r] <= pivot\n    invariant forall s: int :: i <= s < j ==> arr[s] > pivot\n    invariant forall t: int :: j <= t <= right ==> arr[t] >= pivot\n    invariant forall u: int :: left <= u < i ==> arr[u] <= pivot\n    invariant forall v: int :: i <= v <= j ==> arr[v] > pivot\n    invariant forall w: int :: j < w <= right ==> arr[w] >= pivot\n    invariant forall x: int :: left <= x <= right ==> \n              (arr[x] <= pivot || arr[x] > pivot || arr[x] == pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n    invariant forall r: int :: left <= r <= right ==> \n              (arr[r] <= pivot || arr[r] >= pivot)\n    invariant forall s: int :: left <= s < i ==> arr[s] <= pivot\n    invariant forall t: int :: i <= t <= j ==> arr[t] > pivot\n    invariant forall u: int :: j < u <= right ==> arr[u] >= pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "d0c6d61a-a938-45ec-99d0-57a898f70f86"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "4dbaa72f-0b25-4895-8957-ae1c4cc875f9",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i - 1 ==> lis[k] <= lis[k + 1]\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k :: 0 <= k < i - 1 ==> lis[k] <= lis[k + 1]\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i - 1 ==> lis[k] <= lis[k + 1] // New invariant\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k :: 0 <= k < i - 1 ==> lis[k] <= lis[k + 1] // New invariant\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n}",
            "parents": [
                "06ba2f07-fbf7-430a-a181-3deb6d20bbe3"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "a9f5c9ea-1bd1-4098-89de-f5fa86d9be07",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var index := -1;\n    var i := 0;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant index == -1 ==> forall k :: 0 <= k < i ==> elements[k].1 != value\n      invariant index != -1 ==> elements[index].1 == value\n      invariant index == -1 ==> elements == old(elements)\n    {\n      if elements[i].1 == value {\n        index := i;\n        break;\n      }\n      i := i + 1;\n    }\n    assert index != -1; // We should have found the element\n\n    // Remove the element\n    elements := elements[..index] + elements[index + 1..];\n\n    // Reinsert with new priority\n    var newElement := (newPriority, value);\n    i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant elements[..index] + elements[index..] == old(elements[..index] + elements[index + 1..])\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Merge(other: PriorityQueue)\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures elements == old(elements) + old(other.elements)\n  {\n    var i := 0;\n    var j := 0;\n    var result: seq<(int, int)> := [];\n    while i < |elements| || j < |other.elements|\n      invariant 0 <= i <= |elements|\n      invariant 0 <= j <= |other.elements|\n      invariant forall k, l :: 0 <= k < l < |result| ==> result[k].0 <= result[l].0\n      invariant result + elements[i..] + other.elements[j..] == old(elements) + old(other.elements)\n    {\n      if i < |elements| && (j >= |other.elements| || elements[i].0 <= other.elements[j].0) {\n        result := result + [elements[i]];\n        i := i + 1;\n      } else {\n        result := result + [other.elements[j]];\n        j := j + 1;\n      }\n    }\n    elements := result;\n  }\n}",
            "parents": [
                "b3bade4c-e82c-4453-b2ca-4289e9c2bf9d"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "0443c66f-b4ad-4ba2-b2be-143c39f27448",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n    invariant forall r: int :: left <= r < i ==> arr[r] <= pivot\n    invariant forall s: int :: i <= s < j ==> arr[s] > pivot\n    invariant forall t: int :: j <= t <= right ==> arr[t] >= pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\nfor j := left to right - 1\n  invariant left <= i <= j <= right\n  invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n  invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n  invariant forall q: int :: left <= q <= right ==> \n            (arr[q] <= pivot || arr[q] > pivot)\n  invariant arr[right] == pivot\n{\n  if arr[j] <= pivot {\n    arr[i], arr[j] := arr[j], arr[i];\n    i := i + 1;\n  }\n}\narr[i], arr[right] := arr[right], arr[i];\nreturn i;\n}",
            "parents": [
                "8c003d78-55dc-464e-870e-2234e08afcde"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "8aec9e6d-d4cb-40c6-b508-2c4db9f7cd08",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      decreases |elements| - i\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var index: int := 0;\n    // Find the element with the specified value\n    while index < |elements| && elements[index].1 != value\n      invariant 0 <= index <= |elements|\n      invariant forall k :: 0 <= k < index ==> elements[k].1 != value\n      decreases |elements| - index\n    {\n      index := index + 1;\n    }\n    // Update the priority of the found element\n    elements := elements[..index] + [(newPriority, value)] + elements[index+1..];\n    \n    // Reorder the queue to maintain the priority order\n    var i := 0;\n    var newElement := (newPriority, value);\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      decreases |elements| - i\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i+1..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n}",
            "parents": [
                "6ca783b3-d9e6-4508-bb23-898b47d5267c"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "024c3d7f-0896-40c5-a55d-bd233e917c6f",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n{\n  value := elements[0].1;\n}\n}",
            "parents": [
                "33ed6d62-9431-44c6-8c34-4cfb35fea409"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "4307888b-8d10-4632-b6c7-58bae6812192",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures elements == old(elements)\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(oldValue: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == oldValue\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, oldValue)\n  {\n    var i := 0;\n    // Find the element with the specified value\n    while i < |elements| && elements[i].1 != oldValue\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != oldValue\n    {\n      i := i + 1;\n    }\n    // Remove the element\n    elements := elements[..i] + elements[i+1..];\n    \n    // Reinsert the element with the new priority\n    var newElement := (newPriority, oldValue);\n    var j := 0;\n    while j < |elements| && elements[j].0 <= newPriority\n      invariant 0 <= j <= |elements|\n      invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n      invariant elements == old(elements[..i] + elements[i+1..])\n    {\n      j := j + 1;\n    }\n    elements := elements[..j] + [newElement] + elements[j..];\n  }\n  method Merge(other: PriorityQueue)\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures |elements| == old(|elements|) + |other.elements|\n    ensures forall e :: e in other.elements ==> e in elements\n  {\n    var i := 0;\n    while i < |other.elements|\n      invariant 0 <= i <= |other.elements|\n      invariant |elements| == old(|elements|) + i\n      invariant forall j, k :: 0 <= j < k < |elements| ==> elements[j].0 <= elements[k].0\n      invariant forall e :: e in other.elements[..i] ==> e in elements\n    {\n      var (priority, value) := other.elements[i];\n      this.Enqueue(priority, value);\n      i := i + 1;\n    }\n  }\nmethod DecreasePriority(value: int, decreaseAmount: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  requires decreaseAmount > 0\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (old(elements[i].0) - decreaseAmount, value)\n{\n  var i := 0;\n  // Find the element with the specified value\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n  // Remove the element\n  var oldPriority := elements[i].0;\n  elements := elements[..i] + elements[i+1..];\n  \n  // Reinsert the element with the decreased priority\n  var newPriority := oldPriority - decreaseAmount;\n  var newElement := (newPriority, value);\n  var j := 0;\n  while j < |elements| && elements[j].0 <= newPriority\n    invariant 0 <= j <= |elements|\n    invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n    invariant elements == old(elements[..i] + elements[i+1..])\n  {\n    j := j + 1;\n  }\n  elements := elements[..j] + [newElement] + elements[j..];\n}\n}",
            "parents": [
                "c9d05711-3134-46e2-945d-cc69b31789af"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "88decd5e-1c0c-466b-b71a-baa4beee8c25",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n{\n  value := elements[0].1;\n}\nmethod ChangePriority(oldValue: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == oldValue\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, oldValue)\n  ensures |elements| == old(|elements|)\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != oldValue\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != oldValue\n  {\n    i := i + 1;\n  }\n\n  // Remove the element with oldValue\n  var removedElement := elements[i];\n  elements := elements[..i] + elements[i+1..];\n\n  // Insert the element with the new priority\n  var newElement := (newPriority, oldValue);\n  i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [newElement] + elements[i..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\n}",
            "parents": [
                "be6823b5-37e8-4c49-9e27-d36ea3976379"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "e2b178d9-06f2-49c8-baa4-b31cb54fdd27",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n{\n  value := elements[0].1;\n}\nmethod ChangePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var index := -1;\n  var i := 0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant index == -1 ==> forall k :: 0 <= k < i ==> elements[k].1 != value\n    invariant index != -1 ==> elements[index].1 == value\n  {\n    if elements[i].1 == value {\n      index := i;\n      break;\n    }\n    i := i + 1;\n  }\n  assert index != -1; // We should have found the element\n\n  // Remove the element\n  elements := elements[..index] + elements[index + 1..];\n\n  // Reinsert with new priority\n  var newElement := (newPriority, value);\n  i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [newElement] + elements[i..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\nmethod UpdateAllPriorities(value: int, newPriority: int)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n  {\n    if elements[i].1 == value {\n      // Remove element\n      elements := elements[..i] + elements[i + 1..];\n      \n      // Reinsert with new priority\n      var newElement := (newPriority, value);\n      var j := 0;\n      while j < |elements| && elements[j].0 <= newPriority\n        invariant 0 <= j <= |elements|\n        invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n        invariant forall k, l :: 0 <= k < l < j ==> elements[k].0 <= elements[l].0\n      {\n        j := j + 1;\n      }\n      elements := elements[..j] + [newElement] + elements[j..];\n    } else {\n      i := i + 1;\n    }\n  }\n}\n}",
            "parents": [
                "439925a9-cdd0-434e-99ac-f9cf562045c7"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "e5c5edea-e49e-49bb-b1fa-c3516a4f3881",
            "type": "program",
            "content": "class Graph {\n  var adjacencyMatrix: array2<bool>;\n\n  constructor(n: nat) \n    requires n > 0\n    ensures adjacencyMatrix.Length0 == n && adjacencyMatrix.Length1 == n\n    ensures forall i, j :: 0 <= i < n && 0 <= j < n ==> !adjacencyMatrix[i, j]\n  {\n    adjacencyMatrix := new bool[n, n];\n  }\n\n  method AddEdge(u: nat, v: nat)\n    requires 0 <= u < adjacencyMatrix.Length0\n    requires 0 <= v < adjacencyMatrix.Length1\n    modifies adjacencyMatrix\n    ensures adjacencyMatrix[u, v] && adjacencyMatrix[v, u]\n  {\n    adjacencyMatrix[u, v] := true;\n    adjacencyMatrix[v, u] := true;\n  }\n\n  method IsVertexCover(cover: set<nat>) returns (isCover: bool)\n    requires cover <= set i | 0 <= i < adjacencyMatrix.Length0\n    ensures isCover == (forall u, v :: 0 <= u < adjacencyMatrix.Length0 && 0 <= v < adjacencyMatrix.Length1 && adjacencyMatrix[u, v] ==> u in cover || v in cover)\n  {\n    isCover := true;\n    var n := adjacencyMatrix.Length0;\n    for u := 0 to n - 1 {\n      for v := 0 to n - 1 \n        invariant 0 <= u < n\n        invariant 0 <= v <= n\n        invariant isCover == (forall i, j :: 0 <= i <= u && 0 <= j < n && adjacencyMatrix[i, j] ==> i in cover || j in cover)\n      {\n        if adjacencyMatrix[u, v] && !(u in cover || v in cover) {\n          isCover := false;\n          return;\n        }\n      }\n    }\n  }\nmethod RemoveEdge(u: nat, v: nat)\n  requires 0 <= u < adjacencyMatrix.Length0\n  requires 0 <= v < adjacencyMatrix.Length1\n  modifies adjacencyMatrix\n  ensures !adjacencyMatrix[u, v] && !adjacencyMatrix[v, u]\n{\n  var n := adjacencyMatrix.Length0;\n  for i := 0 to n - 1\n    invariant 0 <= i <= n\n    invariant (forall j :: 0 <= j < i ==> !adjacencyMatrix[u, j] && !adjacencyMatrix[v, j])\n  {\n    adjacencyMatrix[u, i] := false;\n    adjacencyMatrix[v, i] := false;\n  }\n  adjacencyMatrix[u, v] := false;\n  adjacencyMatrix[v, u] := false;\n}\n}",
            "parents": [
                "dcb511aa-6410-4845-b08a-6963d8bf6d82"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "25174c6d-4d7f-48d0-9a43-34883789c1e8",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k, l :: 0 <= k < l < i && arr[k] < arr[l] ==> lis[k] < lis[l]\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k, l :: 0 <= k < l < i && arr[k] < arr[l] ==> lis[k] < lis[l]\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  assert forall k, l :: 0 <= k < l < n && arr[k] < arr[l] ==> lis[k] < lis[l];\n  length := maxLength;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k, l :: 0 <= k < l < i && arr[k] < arr[l] ==> lis[k] < lis[l]\n    invariant forall k :: 1 <= k < i ==> lis[k-1] <= lis[k]  // New invariant\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k, l :: 0 <= k < l < i && arr[k] < arr[l] ==> lis[k] < lis[l]\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  assert forall k, l :: 0 <= k < l < n && arr[k] < arr[l] ==> lis[k] < lis[l];\n  length := maxLength;\n}",
            "parents": [
                "361200ed-2206-410d-9dee-7b14ea7bd244"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "b5dccdbf-3cef-460e-8715-22fbb2918f34",
            "type": "program",
            "content": "method Swap(a: array<int>, i: int, j: int)\n  requires 0 <= i < a.Length && 0 <= j < a.Length\n  modifies a\n  ensures a[i] == old(a[j]) && a[j] == old(a[i]) && (forall k :: k != i && k != j ==> a[k] == old(a[k]))\n{\n  var temp := a[i];\n  a[i] := a[j];\n  a[j] := temp;\n}\nmethod Shuffle(a: array<int>)\n  requires a.Length > 0\n  modifies a\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures (forall i, j :: 0 <= i < j < a.Length ==> a[i] != a[j])\n{\n  var n := a.Length;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    {\n      var j := i + (if n - i == 1 then 0 else (n - i) % (n - i));\n      Swap(a, i, j);\n      i := i + 1;\n    }\n{\n  var n := a.Length;\n  var i := n - 1;\n  while i > 0\n    invariant 0 <= i < n\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant (forall j, k :: 0 <= j < k <= i ==> a[j] != a[k])\n    {\n      var j := if i == 0 then 0 else i % (i + 1);\n      Swap(a, i, j);\n      i := i - 1;\n    }\n}\n}",
            "parents": [
                "4625c197-546d-449c-ac06-6ed45dcf8f1f"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "f3adf2fb-5dc8-4c07-b582-44ff9418e555",
            "type": "program",
            "content": "method TriangularNumber(n: nat) returns (t: nat)\n  requires n >= 0\n  ensures t == n * (n + 1) / 2\n{\n  var sum := 0;\n  var i := 0;\n  while i <= n\n    invariant 0 <= i <= n + 1\n    invariant sum == i * (i - 1) / 2\n  {\n    sum := sum + i;\n    i := i + 1;\n  }\n  t := sum;\n  while i <= n\n    invariant 0 <= i <= n + 1\n    invariant sum == i * (i - 1) / 2\n    invariant sum == (i - 1) * i / 2 // Additional invariant to check consistency with the formula\n  {\n    sum := sum + i;\n    i := i + 1;\n  }\n  t := sum;\n}",
            "parents": [
                "d037d1de-f60f-4fc8-a0af-fe28847bcdcf"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "SUCCESS"
            }
        },
        {
            "id": "b0eee263-eb97-469c-a1ad-952757a08cf1",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n{\n  value := elements[0].1;\n}\nmethod IsEmpty() returns (empty: bool)\n  ensures empty == (|elements| == 0)\n{\n  empty := |elements| == 0;\n}\n}",
            "parents": [
                "f96f785a-0a84-4692-a514-f60129d792e5"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "47a78a94-8b7d-4a32-9894-bacc3e113196",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n  ensures elements == old(elements)\n{\n  value := elements[0].1;\n}\n}",
            "parents": [
                "a70cb0fe-ec4d-4ece-91ef-0b8fa644633c"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "08c785c6-8073-4217-a7f6-3ceb73ff379c",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n    ensures elements == old(elements)\n  {\n    var i := 0;\n    var highestPriority := elements[0].0;\n    value := elements[0].1;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= highestPriority\n      invariant exists k :: 0 <= k < |elements| && elements[k].0 == highestPriority && value == elements[k].1\n      invariant elements == old(elements)\n    {\n      if elements[i].0 < highestPriority {\n        highestPriority := elements[i].0;\n        value := elements[i].1;\n      }\n      i := i + 1;\n    }\n    assert value == elements[0].1;\n  }\nmethod UpdatePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n  ensures forall i :: 0 <= i < |elements| && elements[i].1 != value ==> elements[i] == old(elements[i])\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n  {\n    i := i + 1;\n  }\n  var updatedElement := (newPriority, value);\n  elements := elements[..i] + elements[i+1..];\n  var j := 0;\n  while j < |elements| && elements[j].0 <= newPriority\n    invariant 0 <= j <= |elements|\n    invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n    invariant forall k, l :: 0 <= k < l < j ==> elements[k].0 <= elements[l].0\n  {\n    j := j + 1;\n  }\n  elements := elements[..j] + [updatedElement] + elements[j..];\n}\n}",
            "parents": [
                "ed01b8bf-3675-436a-a9f0-b28fc6e74823"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "e6fd6d5d-f2f0-4e21-bbd8-a6eeea60979f",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures elements == old(elements)\n  ensures value == elements[0].1\n{\n  var highestPriority := elements[0].0;\n  var highestValue := elements[0].1;\n  var i := 1;\n  while i < |elements|\n    invariant 1 <= i <= |elements|\n    invariant highestPriority == elements[0].0\n    invariant highestValue == elements[0].1\n    invariant forall k :: 0 <= k < i ==> elements[k].0 >= highestPriority\n  {\n    if elements[i].0 < highestPriority {\n      highestPriority := elements[i].0;\n      highestValue := elements[i].1;\n    }\n    i := i + 1;\n  }\n  value := highestValue;\n}\nmethod ChangePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n  // Remove the element with the specified value\n  elements := elements[..i] + elements[i+1..];\n  \n  // Re-insert the element with the new priority\n  var newElement := (newPriority, value);\n  i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [newElement] + elements[i..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\nmethod Merge(other: PriorityQueue)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  var j := 0;\n  var newElements: seq<(int, int)> := [];\n  \n  while i < |elements| || j < |other.elements|\n    invariant 0 <= i <= |elements|\n    invariant 0 <= j <= |other.elements|\n    invariant |newElements| == i + j\n    invariant forall k, l :: 0 <= k < l < |newElements| ==> newElements[k].0 <= newElements[l].0\n    invariant forall k :: 0 <= k < i ==> elements[k] in newElements\n    invariant forall k :: 0 <= k < j ==> other.elements[k] in newElements\n  {\n    if i < |elements| && (j >= |other.elements| || elements[i].0 <= other.elements[j].0) {\n      newElements := newElements + [elements[i]];\n      i := i + 1;\n    } else {\n      newElements := newElements + [other.elements[j]];\n      j := j + 1;\n    }\n  }\n  elements := newElements;\n}\n}",
            "parents": [
                "acc10745-d709-4a13-91d2-bd5dc8b4da10"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "fc755cf7-1de6-49cf-aa58-276373aacef5",
            "type": "program",
            "content": "class Graph {\n  var adjacencyMatrix: array2<bool>;\n\n  constructor(n: nat) \n    requires n > 0\n    ensures adjacencyMatrix.Length0 == n && adjacencyMatrix.Length1 == n\n    ensures forall i, j :: 0 <= i < n && 0 <= j < n ==> !adjacencyMatrix[i, j]\n  {\n    adjacencyMatrix := new bool[n, n];\n  }\n\n  method AddEdge(u: nat, v: nat)\n    requires 0 <= u < adjacencyMatrix.Length0\n    requires 0 <= v < adjacencyMatrix.Length1\n    modifies adjacencyMatrix\n    ensures adjacencyMatrix[u, v] && adjacencyMatrix[v, u]\n  {\n    adjacencyMatrix[u, v] := true;\n    adjacencyMatrix[v, u] := true;\n  }\n\n  method IsVertexCover(cover: set<nat>) returns (isCover: bool)\n    requires cover <= set i | 0 <= i < adjacencyMatrix.Length0\n    ensures isCover == (forall u, v :: 0 <= u < adjacencyMatrix.Length0 && 0 <= v < adjacencyMatrix.Length1 && adjacencyMatrix[u, v] ==> u in cover || v in cover)\n  {\n    isCover := true;\n    var n := adjacencyMatrix.Length0;\n    for u := 0 to n - 1 {\n      for v := 0 to n - 1 {\n        if adjacencyMatrix[u, v] && !(u in cover || v in cover) {\n          isCover := false;\n          return;\n        }\n      }\n    }\n  }\nmethod IsCompleteGraph() returns (isComplete: bool)\n  ensures isComplete == (forall u, v :: 0 <= u < adjacencyMatrix.Length0 && 0 <= v < adjacencyMatrix.Length1 && u != v ==> adjacencyMatrix[u, v])\n{\n  isComplete := true;\n  var n := adjacencyMatrix.Length0;\n  for u := 0 to n - 1\n    invariant 0 <= u <= n\n    invariant isComplete == (forall i, j :: 0 <= i < u && 0 <= j < n && i != j ==> adjacencyMatrix[i, j])\n  {\n    for v := 0 to n - 1\n      invariant 0 <= v <= n\n      invariant isComplete == (forall i, j :: 0 <= i < u && 0 <= j < n && i != j ==> adjacencyMatrix[i, j]) &&\n                             (forall j :: 0 <= j < v && u != j ==> adjacencyMatrix[u, j])\n    {\n      if u != v && !adjacencyMatrix[u, v] {\n        isComplete := false;\n        return;\n      }\n    }\n  }\n}\n}",
            "parents": [
                "4cdc8acf-bd53-4262-9f62-d262ebc0d72c"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "6b3597f3-f587-47af-b14c-07c59ed7b366",
            "type": "program",
            "content": "method CoinChange(coins: seq<int>, amount: int) returns (minCoins: int)\n  requires amount >= 0\n  requires forall c :: c in coins ==> c > 0\n  ensures minCoins >= -1\n  ensures minCoins == -1 || minCoins * 1 <= amount\n{\n  var dp := new int[amount + 1];\n  dp[0] := 0;\n  var i: int := 1;\n  while i <= amount\n    invariant 0 <= i <= amount + 1\n    invariant dp[0] == 0\n    invariant forall j :: 0 <= j < i ==> dp[j] >= 0 || dp[j] == -1\n  {\n    dp[i] := -1;\n    var j: int := 0;\n    while j < |coins|\n      invariant forall k :: 0 <= k < i ==> dp[k] <= k\n      invariant 0 <= j <= |coins|\n      invariant dp[i] >= -1\n    {\n        if i - coins[j] >= 0 && dp[i - coins[j]] != -1 {\n          if dp[i] == -1 || dp[i] > dp[i - coins[j]] + 1 {\n            dp[i] := dp[i - coins[j]] + 1;\n          }\n        }\n        j := j + 1;\n      }\n      i := i + 1;\n    }\n    minCoins := dp[amount];\n  }",
            "parents": [
                "5fe70a95-228e-4a7e-8ade-222afa605d25"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "fe8d5f27-d51f-41f1-b2d9-6f3445a66f32",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures elements == old(elements)\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(oldValue: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == oldValue\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, oldValue)\n  {\n    var i := 0;\n    // Find the element with the specified value\n    while i < |elements| && elements[i].1 != oldValue\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != oldValue\n      invariant exists j :: i <= j < |elements| && elements[j].1 == oldValue\n    {\n      i := i + 1;\n    }\n    // Remove the element\n    elements := elements[..i] + elements[i+1..];\n    \n    // Reinsert the element with the new priority\n    var newElement := (newPriority, oldValue);\n    var j := 0;\n    while j < |elements| && elements[j].0 <= newPriority\n      invariant 0 <= j <= |elements|\n      invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n    {\n      j := j + 1;\n    }\n    elements := elements[..j] + [newElement] + elements[j..];\n  }\nmethod UpdateValue(priority: int, newValue: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].0 == priority\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (priority, newValue)\n{\n  var i := 0;\n  // Find the element with the specified priority\n  while i < |elements| && elements[i].0 != priority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 != priority\n    invariant exists j :: i <= j < |elements| && elements[j].0 == priority\n  {\n    i := i + 1;\n  }\n  // Update the element's value\n  elements := elements[..i] + [(priority, newValue)] + elements[i+1..];\n}\nmethod Clear()\n  modifies this\n  ensures |elements| == 0\n{\n  var i := 0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant elements == old(elements[i..])\n  {\n    i := i + 1;\n  }\n  elements := [];\n}\n}",
            "parents": [
                "87824759-a621-4bf0-b95b-f48af48a0fd1"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "4cd78da6-c045-466d-b20e-1e728f74c495",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant exists i: int :: left <= i <= right && arr[i] == arr[k]\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> arr[q] >= pivot || q < i\n    invariant forall r: int :: left <= r <= right ==> arr[r] <= pivot || r >= i\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant (forall q: int :: left <= q <= j ==> arr[q] <= pivot) == (i == j)\n    invariant (forall r: int :: i <= r <= j ==> arr[r] > pivot) == (j == right - 1)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "a167c201-463a-45b6-b3f1-1db748256467"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "99aa3754-f962-4f74-9cea-3aa5df959b36",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n  ensures elements == old(elements)\n{\n  var i := 0;\n  var highestPriority := elements[0].0;\n  value := elements[0].1;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= highestPriority\n    invariant value == elements[0].1\n  {\n    if elements[i].0 < highestPriority {\n      highestPriority := elements[i].0;\n      value := elements[i].1;\n    }\n    i := i + 1;\n  }\n  assert value == elements[0].1;\n}\nmethod UpdatePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i].1 == value && elements[i].0 == newPriority\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n  var element := elements[i];\n  elements := elements[..i] + elements[i+1..]; // Remove the element\n  var newElement := (newPriority, element.1);\n\n  // Reinsert with new priority\n  i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [newElement] + elements[i..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\nmethod Remove(value: int) returns (found: bool)\n  modifies this\n  ensures found ==> !exists i :: 0 <= i < |elements| && elements[i].1 == value\n  ensures !found ==> elements == old(elements)\n{\n  var i := 0;\n  found := false;\n  while i < |elements| && !found\n    invariant 0 <= i <= |elements|\n    invariant !found ==> forall k :: 0 <= k < i ==> elements[k].1 != value\n    invariant found ==> !exists k :: 0 <= k < i && elements[k].1 == value\n  {\n    if elements[i].1 == value {\n      found := true;\n      elements := elements[..i] + elements[i+1..];\n    } else {\n      i := i + 1;\n    }\n  }\n  assert found ==> !exists k :: 0 <= k < |elements| && elements[k].1 == value;\n}\nmethod Merge(other: PriorityQueue)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures |elements| == old(|elements|) + |other.elements|\n  ensures forall e :: e in other.elements ==> e in elements\n{\n  var i := 0;\n  while i < |other.elements|\n    invariant 0 <= i <= |other.elements|\n    invariant |elements| == old(|elements|) + i\n    invariant forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0\n    invariant forall e :: e in other.elements[..i] ==> e in elements\n  {\n    var newElement := other.elements[i];\n    var j := 0;\n    while j < |elements| && elements[j].0 <= newElement.0\n      invariant 0 <= j <= |elements|\n      invariant forall k :: 0 <= k < j ==> elements[k].0 <= newElement.0\n      invariant forall k, l :: 0 <= k < l < j ==> elements[k].0 <= elements[l].0\n    {\n      j := j + 1;\n    }\n    elements := elements[..j] + [newElement] + elements[j..];\n    i := i + 1;\n  }\n}\n}",
            "parents": [
                "06cfd3c5-2390-4a34-8fcd-d7ecddaaea4a"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "32009f05-7c65-4f9c-abd6-5159e582c066",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n{\n  value := elements[0].1;\n}\nmethod UpdatePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n{\n  var i := 0;\n  // Find the index of the element with the given value\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n  assert i < |elements|; // Element with the given value exists\n\n  // Remove the element\n  elements := elements[..i] + elements[i+1..];\n\n  // Reinsert the element with the new priority\n  var newElement := (newPriority, value);\n  var j := 0;\n  while j < |elements| && elements[j].0 <= newPriority\n    invariant 0 <= j <= |elements|\n    invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n    invariant forall k, l :: 0 <= k < l < j ==> elements[k].0 <= elements[l].0\n  {\n    j := j + 1;\n  }\n  elements := elements[..j] + [newElement] + elements[j..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\n}",
            "parents": [
                "be6823b5-37e8-4c49-9e27-d36ea3976379"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "a8cf6e1a-efae-48eb-acb4-1746e705775b",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\nmethod ChangePriority(oldPriority: int, value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i] == (oldPriority, value)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |elements| && elements[i] != (oldPriority, value)\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k] != (oldPriority, value)\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + elements[i+1..];\n  var newElement := (newPriority, value);\n  i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [newElement] + elements[i..];\n}\nmethod Merge(other: PriorityQueue)\n  modifies this\n  ensures forall e :: e in other.elements ==> e in elements\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |other.elements|\n    invariant 0 <= i <= |other.elements|\n    invariant forall k :: 0 <= k < i ==> other.elements[k] in elements\n    invariant forall m, n :: 0 <= m < n < |elements| ==> elements[m].0 <= elements[n].0\n  {\n    var (priority, value) := other.elements[i];\n    Enqueue(priority, value);\n    i := i + 1;\n  }\n}\nmethod RemoveValue(value: int)\n  modifies this\n  ensures forall e :: e in elements ==> e.1 != value\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n    invariant forall m, n :: 0 <= m < n < |elements| ==> elements[m].0 <= elements[n].0\n  {\n    if elements[i].1 == value {\n      elements := elements[..i] + elements[i+1..];\n    } else {\n      i := i + 1;\n    }\n  }\n}\n}",
            "parents": [
                "cdf2bf93-da54-45d5-808e-0671fc85de78"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "30fced3a-b23b-4f08-a948-00e3fc0b6dc1",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> maxLength >= lis[k]\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n  return maxLength;\n}",
            "parents": [
                "7201d35b-8e5d-4804-b741-e206c2263be3"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "39093cb0-3ce3-4c80-b56e-9e6e3d9f4c12",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n{\n  value := elements[0].1;\n}\nmethod ChangePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n  var oldElement := elements[i];\n  elements := elements[..i] + elements[i+1..];\n  var j := 0;\n  while j < |elements| && elements[j].0 <= newPriority\n    invariant 0 <= j <= |elements|\n    invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n    invariant forall k, l :: 0 <= k < l < j ==> elements[k].0 <= elements[l].0\n  {\n    j := j + 1;\n  }\n  elements := elements[..j] + [(newPriority, value)] + elements[j..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\nmethod RemoveValue(value: int) \n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures !exists i :: 0 <= i < |elements| && elements[i].1 == value\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + elements[i+1..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\nmethod Merge(other: PriorityQueue)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures |elements| == |old(elements)| + |other.elements|\n{\n  var newElements: seq<(int, int)> := [];\n  var i := 0;\n  var j := 0;\n  while i < |elements| || j < |other.elements|\n    invariant 0 <= i <= |elements|\n    invariant 0 <= j <= |other.elements|\n    invariant |newElements| == i + j\n    invariant forall k, l :: 0 <= k < l < |newElements| ==> newElements[k].0 <= newElements[l].0\n  {\n    if i < |elements| && (j >= |other.elements| || elements[i].0 <= other.elements[j].0) {\n      newElements := newElements + [elements[i]];\n      i := i + 1;\n    } else {\n      newElements := newElements + [other.elements[j]];\n      j := j + 1;\n    }\n  }\n  elements := newElements;\n}\n}",
            "parents": [
                "e526fc38-6297-4a55-9b75-bbd8a428c406"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "abae7ce8-f7c3-4739-a014-25dd68b6abd9",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n{\n  var i := 0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 >= elements[i].0\n  {\n    if elements[i].0 > elements[0].0 {\n      value := elements[i].1;\n      return;\n    }\n    i := i + 1;\n  }\n  value := elements[0].1;\n}\nmethod UpdatePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i :: 0 <= i < |elements| ==> elements[i].1 != value || elements[i].0 == newPriority\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n  // Remove the element with the specified value\n  elements := elements[..i] + elements[i+1..];\n  // Re-insert the element with the new priority\n  Enqueue(newPriority, value);\n}\n}",
            "parents": [
                "223a0b93-3151-4812-9c68-627387fa2a84"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "4bc9e5ca-6194-460b-8c11-365eb0f37499",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p < right ==> arr[p] > pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n    invariant forall r: int :: left <= r < j ==> arr[r] <= pivot || arr[r] > pivot\n    invariant forall s: int :: j <= s <= right ==> arr[s] >= pivot || arr[s] < pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "a3e62053-9c6d-48a9-b8e3-f4e0235d8f8b"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "a698038d-6b3e-4fc0-b679-6602c71bfbe1",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n  ensures elements == old(elements)\n{\n  value := elements[0].1;\n}\nmethod RemoveByPriority(priority: int) returns (removed: bool)\n  modifies this\n  ensures removed ==> exists i :: 0 <= i < |old(elements)| && old(elements)[i].0 == priority\n  ensures !removed ==> forall i :: 0 <= i < |old(elements)| ==> old(elements)[i].0 != priority\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  removed := false;\n  while i < |elements| && !removed\n    invariant 0 <= i <= |elements|\n    invariant !removed ==> forall k :: 0 <= k < i ==> elements[k].0 != priority\n    invariant removed ==> exists k :: 0 <= k < i && elements[k].0 == priority\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n  {\n    if elements[i].0 == priority {\n      elements := elements[..i] + elements[i+1..];\n      removed := true;\n    } else {\n      i := i + 1;\n    }\n  }\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\n}",
            "parents": [
                "47a78a94-8b7d-4a32-9894-bacc3e113196"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "2ed5452d-1c00-499f-8c92-f6eb81374f61",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p < right ==> arr[p] > pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n    invariant forall r: int :: left <= r < i ==> arr[r] <= pivot\n    invariant forall s: int :: i <= s < j ==> arr[s] > pivot\n    invariant forall t: int :: j <= t <= right ==> arr[t] >= pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n    invariant forall r: int :: left <= r < i ==> arr[r] <= pivot\n    invariant forall s: int :: i <= s < j ==> arr[s] > pivot\n    invariant forall t: int :: j <= t <= right ==> arr[t] >= pivot\n    invariant forall u: int :: left <= u < j ==> arr[u] <= pivot || arr[u] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "8950e131-3ee6-4481-9d18-35785b388425"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "4c9c72f4-3e57-4d6a-8bf2-547a48fc90cb",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var index := -1;\n    var i := 0;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant index == -1 ==> forall k :: 0 <= k < i ==> elements[k].1 != value\n      invariant index != -1 ==> elements[index].1 == value\n      invariant index == -1 ==> elements == old(elements)\n    {\n      if elements[i].1 == value {\n        index := i;\n        break;\n      }\n      i := i + 1;\n    }\n    assert index != -1; // We should have found the element\n\n    // Remove the element\n    elements := elements[..index] + elements[index + 1..];\n\n    // Reinsert with new priority\n    var newElement := (newPriority, value);\n    i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant elements[..index] + elements[index..] == old(elements[..index] + elements[index + 1..])\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Merge(other: PriorityQueue)\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures elements == old(elements) + old(other.elements)\n  {\n    var i := 0;\n    var j := 0;\n    var result: seq<(int, int)> := [];\n    while i < |elements| || j < |other.elements|\n      invariant 0 <= i <= |elements|\n      invariant 0 <= j <= |other.elements|\n      invariant forall k, l :: 0 <= k < l < |result| ==> result[k].0 <= result[l].0\n      invariant result + elements[i..] + other.elements[j..] == old(elements) + old(other.elements)\n    {\n      if i < |elements| && (j >= |other.elements| || elements[i].0 <= other.elements[j].0) {\n        result := result + [elements[i]];\n        i := i + 1;\n      } else {\n        result := result + [other.elements[j]];\n        j := j + 1;\n      }\n    }\n    elements := result;\n  }\nmethod RemoveByPriority(priority: int)\n  modifies this\n  ensures forall i :: 0 <= i < |elements| ==> elements[i].0 != priority\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 != priority\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n  {\n    if elements[i].0 == priority {\n      elements := elements[..i] + elements[i + 1..];\n    } else {\n      i := i + 1;\n    }\n  }\n  assert forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0;\n}\n}",
            "parents": [
                "a9f5c9ea-1bd1-4098-89de-f5fa86d9be07"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "b5482a32-46b3-41bb-88dd-450600e1bcd9",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p < right ==> arr[p] > pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\nfor j := left to right - 1\n  invariant left <= i <= j <= right\n  invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n  invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n  invariant forall q: int :: left <= q <= right ==> \n            (arr[q] <= pivot || arr[q] > pivot)\n  invariant forall r: int :: 0 <= r < left || right < r < arr.Length ==> arr[r] == old(arr[r])\n{\n  if arr[j] <= pivot {\n    arr[i], arr[j] := arr[j], arr[i];\n    i := i + 1;\n  }\n}\narr[i], arr[right] := arr[right], arr[i];\nreturn i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n    invariant forall r: int :: left <= r <= right ==> \n              (arr[r] <= pivot ==> r < i || r > j)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "f2bb060d-2f66-4076-b07a-5aa9784e2ebc"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "f886053e-05d3-4973-b218-f7f646b7c094",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures elements == old(elements)\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n  }\n  method IsEmpty() returns (empty: bool)\n    ensures empty == (|elements| == 0)\n  {\n    empty := |elements| == 0;\n  }\nmethod IncreasePriority(index: int, newPriority: int)\n  requires 0 <= index < |elements|\n  requires elements[index].0 < newPriority\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var value := elements[index].1;\n  elements := elements[..index] + elements[index + 1..];\n  var i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [(newPriority, value)] + elements[i..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\n}",
            "parents": [
                "abb8f668-c715-4c64-87d8-9f2f2b65e522"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "8f458c0a-ace2-40ab-ab63-73072507d648",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures elements == old(elements)\n  ensures value == elements[0].1\n{\n  var highestPriority := elements[0].0;\n  var highestValue := elements[0].1;\n  var i := 1;\n  while i < |elements|\n    invariant 1 <= i <= |elements|\n    invariant highestPriority == elements[0].0\n    invariant highestValue == elements[0].1\n    invariant forall k :: 0 <= k < i ==> elements[k].0 >= highestPriority\n  {\n    if elements[i].0 < highestPriority {\n      highestPriority := elements[i].0;\n      highestValue := elements[i].1;\n    }\n    i := i + 1;\n  }\n  value := highestValue;\n}\nmethod ChangePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n{\n  var i := 0;\n  // Find the element with the specified value\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n  // Remove the element from the sequence\n  elements := elements[..i] + elements[i+1..];\n  \n  // Re-insert with the new priority\n  i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [(newPriority, value)] + elements[i..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\nmethod Merge(other: PriorityQueue)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures |elements| == old(|elements|) + |other.elements|\n  ensures forall e :: e in other.elements ==> e in elements\n{\n  var i := 0;\n  var j := 0;\n  var merged: seq<(int, int)> := [];\n  while i < |elements| || j < |other.elements|\n    invariant 0 <= i <= |elements|\n    invariant 0 <= j <= |other.elements|\n    invariant |merged| == i + j\n    invariant forall k, l :: 0 <= k < l < |merged| ==> merged[k].0 <= merged[l].0\n    invariant forall e :: e in merged ==> e in old(elements) + old(other.elements)\n  {\n    if i < |elements| && (j >= |other.elements| || elements[i].0 <= other.elements[j].0) {\n      merged := merged + [elements[i]];\n      i := i + 1;\n    } else {\n      merged := merged + [other.elements[j]];\n      j := j + 1;\n    }\n  }\n  elements := merged;\n}\n}",
            "parents": [
                "bd3d45d4-b97f-4b8c-a49c-effee6725dfa"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "1f3492b8-3bad-4522-b9f7-12b54de7bad0",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n{\n  value := elements[0].1;\n}\nmethod IsEmpty() returns (empty: bool)\n  ensures empty == (|elements| == 0)\n{\n  empty := |elements| == 0;\n}\nmethod FindMaxPriorityElement() returns (value: int)\n  requires |elements| > 0\n  ensures exists i :: 0 <= i < |elements| && elements[i].1 == value\n  ensures forall i :: 0 <= i < |elements| ==> elements[i].0 <= elements[0].0\n{\n  var maxPriority := elements[0].0;\n  value := elements[0].1;\n  var i := 1;\n  while i < |elements|\n    invariant 1 <= i <= |elements|\n    invariant elements[0].0 == maxPriority\n    invariant exists j :: 0 <= j < i && elements[j].1 == value\n    invariant forall j :: 0 <= j < i ==> elements[j].0 <= maxPriority\n  {\n    if elements[i].0 > maxPriority {\n      maxPriority := elements[i].0;\n      value := elements[i].1;\n    }\n    i := i + 1;\n  }\n}\n}",
            "parents": [
                "b0eee263-eb97-469c-a1ad-952757a08cf1"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "60157cc1-4a4a-4f84-94a4-6f885be35ef0",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\nmethod ChangePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n  var updatedElement := (newPriority, value);\n  elements := elements[..i] + elements[i+1..];\n  \n  // Re-insert the updated element\n  var j := 0;\n  while j < |elements| && elements[j].0 <= newPriority\n    invariant 0 <= j <= |elements|\n    invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n  {\n    j := j + 1;\n  }\n  elements := elements[..j] + [updatedElement] + elements[j..];\n}\nmethod RemoveValue(value: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i :: 0 <= i < |elements| ==> elements[i].1 != value\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + elements[i+1..];\n}\n}",
            "parents": [
                "155a201f-9ae9-44b2-bf7e-ed15c1c215f8"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "06cd1966-f899-48a7-9e36-abbd4c412b53",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n  ensures elements == old(elements)\n{\n  var i := 0;\n  var highestPriority := elements[0].0;\n  value := elements[0].1;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= highestPriority\n    invariant value == elements[0].1\n  {\n    if elements[i].0 < highestPriority {\n      highestPriority := elements[i].0;\n      value := elements[i].1;\n    }\n    i := i + 1;\n  }\n  assert value == elements[0].1;\n}\nmethod IsEmpty() returns (empty: bool)\n  ensures empty <==> |elements| == 0\n{\n  empty := |elements| == 0;\n}\nmethod ChangePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  var found := false;\n  while i < |elements| && !found\n    invariant 0 <= i <= |elements|\n    invariant !found ==> forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    if elements[i].1 == value {\n      found := true;\n    } else {\n      i := i + 1;\n    }\n  }\n  if found {\n    var updatedElement := (newPriority, value);\n    elements := elements[..i] + elements[i+1..];\n    var j := 0;\n    while j < |elements| && elements[j].0 <= newPriority\n      invariant 0 <= j <= |elements|\n      invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < j ==> elements[k].0 <= elements[l].0\n    {\n      j := j + 1;\n    }\n    elements := elements[..j] + [updatedElement] + elements[j..];\n  }\n}\n}",
            "parents": [
                "84d83fee-9cca-405a-bcec-912037201669"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "bcd26e3b-ff15-48a7-87af-f7ced2eb9c56",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\nmethod UpdatePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures forall i :: 0 <= i < |elements| ==> elements[i].1 != value || elements[i].0 == newPriority\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n\n  // Remove the element with the old priority\n  elements := elements[..i] + elements[i+1..];\n\n  // Reinsert the element with the new priority\n  var newElement := (newPriority, value);\n  i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [newElement] + elements[i..];\n}\nmethod Merge(other: PriorityQueue)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures |elements| == old(|elements|) + |other.elements|\n  ensures forall e :: e in other.elements ==> e in elements\n{\n  var i := 0;\n  while i < |other.elements|\n    invariant 0 <= i <= |other.elements|\n    invariant |elements| == old(|elements|) + i\n    invariant forall j, k :: 0 <= j < k < |elements| ==> elements[j].0 <= elements[k].0\n    invariant forall e :: e in other.elements[..i] ==> e in elements\n  {\n    var (priority, value) := other.elements[i];\n    this.Enqueue(priority, value);\n    i := i + 1;\n  }\n}\n}",
            "parents": [
                "9cb1c3ae-4da1-45fc-809b-4374d83d99c5"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "dedada7d-c9ba-4a9c-b5dc-302637dd2454",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n{\n  value := elements[0].1;\n}\nmethod ChangePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var index := -1;\n  var i := 0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant index == -1 ==> forall k :: 0 <= k < i ==> elements[k].1 != value\n    invariant index != -1 ==> elements[index].1 == value\n  {\n    if elements[i].1 == value {\n      index := i;\n      break;\n    }\n    i := i + 1;\n  }\n  assert index != -1; // We should have found the element\n\n  // Remove the element\n  elements := elements[..index] + elements[index + 1..];\n\n  // Reinsert with new priority\n  var newElement := (newPriority, value);\n  i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [newElement] + elements[i..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\nmethod UpdateAllPriorities(value: int, newPriority: int)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n  {\n    if elements[i].1 == value {\n      // Remove element\n      elements := elements[..i] + elements[i + 1..];\n      \n      // Reinsert with new priority\n      var newElement := (newPriority, value);\n      var j := 0;\n      while j < |elements| && elements[j].0 <= newPriority\n        invariant 0 <= j <= |elements|\n        invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n        invariant forall k, l :: 0 <= k < l < j ==> elements[k].0 <= elements[l].0\n      {\n        j := j + 1;\n      }\n      elements := elements[..j] + [newElement] + elements[j..];\n    } else {\n      i := i + 1;\n    }\n  }\n}\nmethod RemoveAllWithPriority(priority: int)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n  {\n    if elements[i].0 == priority {\n      // Remove element\n      elements := elements[..i] + elements[i + 1..];\n    } else {\n      i := i + 1;\n    }\n  }\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\n}",
            "parents": [
                "e2b178d9-06f2-49c8-baa4-b31cb54fdd27"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "14ea84df-3997-4b7b-ae7a-a0cb194df88b",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n    invariant forall r: int :: left <= r < j ==> arr[r] <= pivot || arr[r] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n    invariant forall r: int :: left <= r < j ==> arr[r] <= pivot || arr[r] > pivot\n    invariant forall s: int :: left <= s < i ==> arr[s] <= pivot\n    invariant forall t: int :: i <= t <= j ==> arr[t] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "d69266e4-437f-4735-82c6-bfecd54e0e88"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "0d11e912-fb88-46a8-97e1-3b2391c794ca",
            "type": "program",
            "content": "method IsValidSudokuRow(board: array2<int>, row: int) returns (isValid: bool)\n  requires 0 <= row < board.Length0\n  requires board.Length1 == 9\n  ensures isValid == (forall i, j :: 0 <= i < j < 9 ==> board[row, i] != board[row, j])\n{\n  var seen := new bool[9];\n  isValid := true;\n  for i := 0 to 8\n    invariant 0 <= i <= 9\n    invariant forall k :: 0 <= k < i ==> 0 <= board[row, k] < 9\n    invariant forall k :: 0 <= k < i ==> seen[board[row, k]]\n    invariant isValid == (forall a, b :: 0 <= a < b < i ==> board[row, a] != board[row, b])\n  {\n    if seen[board[row, i]] {\n      isValid := false;\n      return;\n    }\n    seen[board[row, i]] := true;\n  }\n  for i := 0 to 8\n    invariant 0 <= i <= 9\n    invariant forall k :: 0 <= k < i ==> 1 <= board[row, k] <= 9\n    invariant forall k :: 0 <= k < i ==> seen[board[row, k] - 1]\n    invariant isValid == (forall a, b :: 0 <= a < b < i ==> board[row, a] != board[row, b])\n  {\n    if board[row, i] < 1 || board[row, i] > 9 {\n      isValid := false;\n      return;\n    }\n    if seen[board[row, i] - 1] {\n      isValid := false;\n      return;\n    }\n    seen[board[row, i] - 1] := true;\n  }\n}",
            "parents": [
                "ad026a0a-9fde-4780-ad90-93c8c97b0ce0"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "38d69495-71cd-4294-982f-364796a1a544",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n    ensures elements == old(elements)\n  {\n    value := elements[0].1;\n  }\n}",
            "parents": [
                "3803a3ca-da34-4a1b-8cf7-61aa3bb9676f"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "ab45d52e-1f65-46cd-b0b7-dca9f235cb8d",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "cd565c4a-6196-4c84-aef7-a5c2bd249fd8"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "3fd297c4-2005-4dfc-9618-ca2fc486fcbb",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> maxLength >= lis[k]\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i - 1 ==> lis[k] <= lis[k + 1]\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k :: 0 <= k < i - 1 ==> lis[k] <= lis[k + 1]\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n  return maxLength;\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i - 1 ==> lis[k] <= lis[k + 1]\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k :: 0 <= k < i - 1 ==> lis[k] <= lis[k + 1]\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n}",
            "parents": [
                "5ace900e-0e58-4dcb-9451-ef12d1bebe7e"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "85d268a0-2187-4d0f-b121-b5fc1b5c5243",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures elements == old(elements)\n  ensures value == elements[0].1\n{\n  var i := 0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant elements == old(elements)\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= elements[i].0\n  {\n    if elements[i].0 > elements[0].0 {\n      break;\n    }\n    i := i + 1;\n  }\n  value := elements[0].1;\n}\n}",
            "parents": [
                "33ed6d62-9431-44c6-8c34-4cfb35fea409"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "c8fd477c-f3cf-424d-beef-22ef0b9ef966",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  \n  constructor() {\n    elements := [];\n  }\n\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\nmethod IsEmpty() returns (empty: bool)\n  ensures empty == (|elements| == 0)\n{\n  var i := 0;\n  empty := true;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant empty == (i == 0)\n  {\n    empty := false;\n    i := i + 1;\n  }\n}\n}",
            "parents": [
                "11ce5cd1-4f18-4226-866b-26a89bfdbc08"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "69bf4859-15da-486c-891b-d173b3b7feeb",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      decreases |elements| - i\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var index: int := 0;\n    // Find the element with the specified value\n    while index < |elements| && elements[index].1 != value\n      invariant 0 <= index <= |elements|\n      invariant forall k :: 0 <= k < index ==> elements[k].1 != value\n      decreases |elements| - index\n    {\n      index := index + 1;\n    }\n    // Update the priority of the found element\n    elements := elements[..index] + [(newPriority, value)] + elements[index+1..];\n    \n    // Reorder the queue to maintain the priority order\n    var i := 0;\n    var newElement := (newPriority, value);\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      decreases |elements| - i\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i+1..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\nmethod RemoveValue(value: int)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    decreases |elements| - i\n  {\n    if elements[i].1 == value {\n      elements := elements[..i] + elements[i+1..];\n    } else {\n      i := i + 1;\n    }\n  }\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\n}",
            "parents": [
                "8aec9e6d-d4cb-40c6-b508-2c4db9f7cd08"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "dc2486d8-1459-42bc-b96d-599284ab9427",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures elements == old(elements)\n  ensures value == old(elements[0].1)\n{\n  value := elements[0].1;\n}\nmethod UpdatePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n{\n  var index := 0;\n  while index < |elements| && elements[index].1 != value\n    invariant 0 <= index <= |elements|\n    invariant forall k :: 0 <= k < index ==> elements[k].1 != value\n  {\n    index := index + 1;\n  }\n  var oldElement := elements[index];\n  elements := elements[..index] + elements[index + 1..];\n  \n  var i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [(newPriority, value)] + elements[i..];\n}\n}",
            "parents": [
                "672811ec-af0c-4014-a56f-9d8dfb71a0b5"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "d14c7845-3916-426d-bbca-e9c9bcaebc7d",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures elements == old(elements)\n  ensures value == old(elements[0].1)\n{\n  value := elements[0].1;\n}\nmethod IsEmpty() returns (empty: bool)\n  ensures empty == (|elements| == 0)\n{\n  var i := 0;\n  empty := true;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant empty == (i == 0)\n  {\n    empty := false;\n    i := i + 1;\n  }\n}\nmethod FindMaxPriority() returns (maxPriority: int)\n  requires |elements| > 0\n  ensures exists i :: 0 <= i < |elements| && elements[i].0 == maxPriority\n  ensures forall i :: 0 <= i < |elements| ==> elements[i].0 <= maxPriority\n{\n  var i := 0;\n  maxPriority := elements[0].0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant exists j :: 0 <= j < i && elements[j].0 == maxPriority\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= maxPriority\n  {\n    if elements[i].0 > maxPriority {\n      maxPriority := elements[i].0;\n    }\n    i := i + 1;\n  }\n}\n}",
            "parents": [
                "47ff9bac-d5ea-4f3a-8471-02581f09e109"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "513553a6-c831-43ee-90f3-208d94eb8005",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant exists i: int :: left <= i <= right && \n              (forall j: int :: left <= j < i ==> arr[j] <= arr[i]) &&\n              (forall j: int :: i < j <= right ==> arr[j] >= arr[i])\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q < i ==> arr[q] != pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "db6e213a-af73-4416-a240-61a616f51b93"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "ee4f725e-f112-4df2-be94-d1e61119e06f",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures elements == old(elements)\n  ensures value == elements[0].1\n{\n  var maxPriority := elements[0].0;\n  var maxIndex := 0;\n  var i := 1;\n  while i < |elements|\n    invariant 1 <= i <= |elements|\n    invariant 0 <= maxIndex < i\n    invariant elements[maxIndex].0 == maxPriority\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= maxPriority\n  {\n    if elements[i].0 > maxPriority {\n      maxPriority := elements[i].0;\n      maxIndex := i;\n    }\n    i := i + 1;\n  }\n  value := elements[maxIndex].1;\n}\n}",
            "parents": [
                "33ed6d62-9431-44c6-8c34-4cfb35fea409"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "26b87d8c-452b-4b80-b26c-15255669796e",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n{\n  value := elements[0].1;\n}\nmethod UpdatePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i :: 0 <= i < |elements| ==> elements[i].1 != value || elements[i].0 == newPriority\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n  // Remove the element with the specified value\n  elements := elements[..i] + elements[i+1..];\n  \n  // Re-insert the element with the new priority\n  var newElement := (newPriority, value);\n  i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [newElement] + elements[i..];\n}\n}",
            "parents": [
                "1a3259b2-7905-4744-befc-ce6414144ded"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "34cc4e77-1a58-4c34-82af-d526b9d091e4",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i - 1 ==> lis[k] <= lis[k + 1]\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n}",
            "parents": [
                "f02c5b3b-595c-47dd-a214-6b33fa06bb15"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "7e8e04f7-aa2d-4449-b21b-304ba1c4b3c2",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures elements == old(elements)\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n  }\n  method IsEmpty() returns (empty: bool)\n    ensures empty == (|elements| == 0)\n  {\n    empty := |elements| == 0;\n  }\nmethod UpdatePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n{\n  var i := 0;\n  // Find the element with the given value\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n  // Remove the element\n  var updatedElement := (newPriority, value);\n  elements := elements[..i] + elements[i+1..];\n  \n  // Re-insert the element with the new priority\n  var j := 0;\n  while j < |elements| && elements[j].0 <= newPriority\n    invariant 0 <= j <= |elements|\n    invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n    invariant forall k, l :: 0 <= k < l < j ==> elements[k].0 <= elements[l].0\n  {\n    j := j + 1;\n  }\n  elements := elements[..j] + [updatedElement] + elements[j..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\n}",
            "parents": [
                "abb8f668-c715-4c64-87d8-9f2f2b65e522"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "2e23bdc5-9d3d-4952-8147-37d5ff9bf3bd",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n    ensures elements == old(elements)\n  {\n    value := elements[0].1;\n  }\nmethod IsEmpty() returns (empty: bool)\n  ensures empty == (|elements| == 0)\n{\n  empty := |elements| == 0;\n}\n}",
            "parents": [
                "38d69495-71cd-4294-982f-364796a1a544"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "2b547791-24c9-4ea8-91c5-d849dd6892af",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n  ensures elements == old(elements)\n{\n  value := elements[0].1;\n}\nmethod RemoveByPriority(priority: int) returns (removed: bool)\n  modifies this\n  ensures removed ==> exists i :: 0 <= i < |old(elements)| && old(elements)[i].0 == priority\n  ensures !removed ==> forall i :: 0 <= i < |old(elements)| ==> old(elements)[i].0 != priority\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  removed := false;\n  while i < |elements| && !removed\n    invariant 0 <= i <= |elements|\n    invariant !removed ==> forall k :: 0 <= k < i ==> elements[k].0 != priority\n    invariant removed ==> exists k :: 0 <= k < i && elements[k].0 == priority\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n  {\n    if elements[i].0 == priority {\n      elements := elements[..i] + elements[i+1..];\n      removed := true;\n    } else {\n      i := i + 1;\n    }\n  }\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\nmethod UpdatePriority(value: int, newPriority: int) returns (updated: bool)\n  modifies this\n  ensures updated ==> exists i :: 0 <= i < |old(elements)| && old(elements)[i].1 == value\n  ensures !updated ==> forall i :: 0 <= i < |old(elements)| ==> old(elements)[i].1 != value\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  updated := false;\n  while i < |elements| && !updated\n    invariant 0 <= i <= |elements|\n    invariant !updated ==> forall k :: 0 <= k < i ==> elements[k].1 != value\n    invariant updated ==> exists k :: 0 <= k < i && elements[k].1 == value\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n  {\n    if elements[i].1 == value {\n      elements := elements[..i] + elements[i+1..];\n      updated := true;\n    } else {\n      i := i + 1;\n    }\n  }\n  if updated {\n    Enqueue(newPriority, value);\n  }\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\n}",
            "parents": [
                "a698038d-6b3e-4fc0-b679-6602c71bfbe1"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "67dc88b1-752b-4dbc-884f-7fd972b23cc4",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      decreases |elements| - i\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\nmethod UpdatePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n    decreases |elements| - i\n  {\n    i := i + 1;\n  }\n  assert i < |elements| && elements[i].1 == value;\n  elements := elements[..i] + elements[i+1..];\n  \n  // Re-insert with new priority\n  var newElement := (newPriority, value);\n  var j := 0;\n  while j < |elements| && elements[j].0 <= newPriority\n    invariant 0 <= j <= |elements|\n    invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n    invariant forall k, l :: 0 <= k < l < j ==> elements[k].0 <= elements[l].0\n    decreases |elements| - j\n  {\n    j := j + 1;\n  }\n  elements := elements[..j] + [newElement] + elements[j..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\n}",
            "parents": [
                "6ca783b3-d9e6-4508-bb23-898b47d5267c"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "ff0acc56-7506-4644-a976-b8a7bf2e46da",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures elements == old(elements)\n  ensures value == elements[0].1\n{\n  var i := 0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant elements == old(elements)\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= elements[i].0\n  {\n    i := i + 1;\n  }\n  value := elements[0].1;\n}\n}",
            "parents": [
                "a70cb0fe-ec4d-4ece-91ef-0b8fa644633c"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "e08c250b-31c0-4162-a686-8116c7ce7fcf",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      decreases |elements| - i\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var index: int := 0;\n    // Find the element with the specified value\n    while index < |elements| && elements[index].1 != value\n      invariant 0 <= index <= |elements|\n      invariant forall k :: 0 <= k < index ==> elements[k].1 != value\n      decreases |elements| - index\n    {\n      index := index + 1;\n    }\n    // Update the priority of the found element\n    elements := elements[..index] + [(newPriority, value)] + elements[index+1..];\n    \n    // Reorder the queue to maintain the priority order\n    var i := 0;\n    var newElement := (newPriority, value);\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      decreases |elements| - i\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i+1..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\nmethod RemoveValue(value: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var index: int := 0;\n  // Find the element with the specified value\n  while index < |elements| && elements[index].1 != value\n    invariant 0 <= index <= |elements|\n    invariant forall k :: 0 <= k < index ==> elements[k].1 != value\n    decreases |elements| - index\n  {\n    index := index + 1;\n  }\n  // Remove the element\n  elements := elements[..index] + elements[index+1..];\n  // Ensure the sequence is still ordered\n  assert forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0;\n}\n}",
            "parents": [
                "8aec9e6d-d4cb-40c6-b508-2c4db9f7cd08"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "1b923300-88d9-4b5f-be77-b886e1b33d1a",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures elements == old(elements)\n  ensures value == elements[0].1\n{\n  var highestPriority := elements[0].0;\n  var highestValue := elements[0].1;\n  var i := 1;\n  while i < |elements|\n    invariant 1 <= i <= |elements|\n    invariant highestPriority == elements[0].0\n    invariant highestValue == elements[0].1\n    invariant forall k :: 0 <= k < i ==> elements[k].0 >= highestPriority\n  {\n    if elements[i].0 < highestPriority {\n      highestPriority := elements[i].0;\n      highestValue := elements[i].1;\n    }\n    i := i + 1;\n  }\n  value := highestValue;\n}\nmethod ChangePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n  // Remove the element with the specified value\n  elements := elements[..i] + elements[i+1..];\n  \n  // Re-insert the element with the new priority\n  var newElement := (newPriority, value);\n  i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [newElement] + elements[i..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\nmethod GetPriorityOfValue(value: int) returns (priority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  ensures exists i :: 0 <= i < |elements| && elements[i].1 == value && priority == elements[i].0\n{\n  var i := 0;\n  priority := -1; // Default value, should never be returned due to precondition\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant priority == -1\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n  priority := elements[i].0;\n  assert exists i :: 0 <= i < |elements| && elements[i].1 == value && priority == elements[i].0;\n}\nmethod Merge(other: PriorityQueue)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures |elements| == old(|elements|) + |other.elements|\n  ensures forall e :: e in other.elements ==> e in elements\n{\n  var i := 0;\n  while i < |other.elements|\n    invariant 0 <= i <= |other.elements|\n    invariant |elements| == old(|elements|) + i\n    invariant forall j, k :: 0 <= j < k < |elements| ==> elements[j].0 <= elements[k].0\n    invariant forall e :: e in other.elements[..i] ==> e in elements\n  {\n    var (priority, value) := other.elements[i];\n    Enqueue(priority, value);\n    i := i + 1;\n  }\n}\n}",
            "parents": [
                "83218e5f-4829-4490-b294-dc54dbaae7ad"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "cd9f7ee3-1a7f-46be-9d94-1233416c8e9c",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var index := -1;\n    var i := 0;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant index == -1 ==> forall k :: 0 <= k < i ==> elements[k].1 != value\n      invariant index != -1 ==> elements[index].1 == value\n      invariant index == -1 ==> elements == old(elements)\n    {\n      if elements[i].1 == value {\n        index := i;\n        break;\n      }\n      i := i + 1;\n    }\n    assert index != -1; // We should have found the element\n\n    // Remove the element\n    elements := elements[..index] + elements[index + 1..];\n\n    // Reinsert with new priority\n    var newElement := (newPriority, value);\n    i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant elements[..index] + elements[index..] == old(elements[..index] + elements[index + 1..])\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\nmethod RemoveValue(value: int)\n  modifies this\n  ensures forall i :: 0 <= i < |elements| ==> elements[i].1 != value\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n  {\n    if elements[i].1 == value {\n      elements := elements[..i] + elements[i + 1..];\n    } else {\n      i := i + 1;\n    }\n  }\n  assert forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0;\n}\n}",
            "parents": [
                "b3bade4c-e82c-4453-b2ca-4289e9c2bf9d"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "1e3613c2-cb3d-4127-b25c-7577e835e0e9",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n  ensures elements == old(elements)\n{\n  value := elements[0].1;\n}\nmethod ChangePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures forall i :: 0 <= i < |elements| ==> elements[i].1 != value || elements[i].0 == newPriority\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n  assert i < |elements|; // We know the element exists due to the precondition\n  var oldElement := elements[i];\n  elements := elements[..i] + elements[i+1..];\n  \n  // Reinsert the element with the new priority\n  var newElement := (newPriority, value);\n  var j := 0;\n  while j < |elements| && elements[j].0 <= newPriority\n    invariant 0 <= j <= |elements|\n    invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n    invariant forall k, l :: 0 <= k < l < j ==> elements[k].0 <= elements[l].0\n  {\n    j := j + 1;\n  }\n  elements := elements[..j] + [newElement] + elements[j..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\n}",
            "parents": [
                "47a78a94-8b7d-4a32-9894-bacc3e113196"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "3b56c123-58e7-4c51-9d14-d24ab3dd936e",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n{\n  var i := 0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 >= elements[i].0\n  {\n    if elements[i].0 > elements[0].0 {\n      value := elements[i].1;\n      return;\n    }\n    i := i + 1;\n  }\n  value := elements[0].1;\n}\nmethod UpdatePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i :: 0 <= i < |elements| ==> elements[i].1 != value || elements[i].0 == newPriority\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n  // Remove the element with the specified value\n  elements := elements[..i] + elements[i+1..];\n  // Re-insert the element with the new priority\n  Enqueue(newPriority, value);\n}\nmethod Remove(value: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i :: 0 <= i < |elements| ==> elements[i].1 != value\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n  // Remove the element with the specified value\n  elements := elements[..i] + elements[i+1..];\n}\n}",
            "parents": [
                "abae7ce8-f7c3-4739-a014-25dd68b6abd9"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "0646427e-f506-41ec-9740-52212d484c85",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n  ensures elements == old(elements)\n{\n  var i := 0;\n  var highestPriority := elements[0].0;\n  value := elements[0].1;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= highestPriority\n    invariant value == elements[0].1\n  {\n    if elements[i].0 < highestPriority {\n      highestPriority := elements[i].0;\n      value := elements[i].1;\n    }\n    i := i + 1;\n  }\n  assert value == elements[0].1;\n}\nmethod IsEmpty() returns (empty: bool)\n  ensures empty <==> |elements| == 0\n{\n  empty := |elements| == 0;\n}\nmethod ChangePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  var found := false;\n  while i < |elements| && !found\n    invariant 0 <= i <= |elements|\n    invariant !found ==> forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    if elements[i].1 == value {\n      found := true;\n    } else {\n      i := i + 1;\n    }\n  }\n  if found {\n    var updatedElement := (newPriority, value);\n    elements := elements[..i] + elements[i+1..];\n    var j := 0;\n    while j < |elements| && elements[j].0 <= newPriority\n      invariant 0 <= j <= |elements|\n      invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < j ==> elements[k].0 <= elements[l].0\n    {\n      j := j + 1;\n    }\n    elements := elements[..j] + [updatedElement] + elements[j..];\n  }\n}\nmethod Merge(other: PriorityQueue)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures |elements| == |old(elements)| + |other.elements|\n  ensures forall e :: e in old(elements) || e in other.elements ==> e in elements\n{\n  var merged: seq<(int, int)> := [];\n  var i := 0;\n  var j := 0;\n  while i < |elements| || j < |other.elements|\n    invariant 0 <= i <= |elements|\n    invariant 0 <= j <= |other.elements|\n    invariant |merged| == i + j\n    invariant forall k, l :: 0 <= k < l < |merged| ==> merged[k].0 <= merged[l].0\n    invariant forall e :: e in merged ==> e in old(elements) || e in other.elements\n  {\n    if i < |elements| && (j >= |other.elements| || elements[i].0 <= other.elements[j].0) {\n      merged := merged + [elements[i]];\n      i := i + 1;\n    } else {\n      merged := merged + [other.elements[j]];\n      j := j + 1;\n    }\n  }\n  elements := merged;\n}\n}",
            "parents": [
                "06cd1966-f899-48a7-9e36-abbd4c412b53"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "SUCCESS"
            }
        },
        {
            "id": "3b7dd072-dfdb-4237-b0e9-3b1cce27c1ef",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  length := maxLength;\n  assert forall i, j :: 0 <= i < j < n && arr[i] < arr[j] ==> length >= j - i + 1;\n  return length;\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n      invariant forall k :: 0 <= k < j ==> arr[k] < arr[i] ==> lis[i] >= lis[k] + 1\n      invariant lis[i] <= maxLength\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n    invariant forall k :: 0 <= k < i && lis[k] > 1 ==> exists m :: 0 <= m < k && arr[m] < arr[k] && lis[m] + 1 == lis[k]\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n      invariant forall k :: 0 <= k < i && lis[k] > 1 ==> exists m :: 0 <= m < k && arr[m] < arr[k] && lis[m] + 1 == lis[k]\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  length := maxLength;\n  assert forall i, j :: 0 <= i < j < n && arr[i] < arr[j] ==> length >= j - i + 1;\n  return length;\n}",
            "parents": [
                "02e7918a-0747-4f1c-b069-860f48c3f351"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "d5b40493-0f46-4a5c-a888-3282c87ee6e0",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method UpdatePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures forall i :: 0 <= i < |elements| ==> elements[i].1 != value || elements[i].0 == newPriority\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n      invariant exists j :: i <= j < |elements| && elements[j].1 == value\n    {\n      i := i + 1;\n    }\n\n    // Remove the element with the old priority\n    elements := elements[..i] + elements[i+1..];\n\n    // Reinsert the element with the new priority\n    var newElement := (newPriority, value);\n    i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\nmethod Merge(other: PriorityQueue)\n  modifies this\n  ensures |elements| == |old(elements)| + |other.elements|\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures forall e :: e in old(elements) || e in other.elements ==> e in elements\n{\n  var merged: seq<(int, int)> := [];\n  var i := 0;\n  var j := 0;\n  while i < |elements| || j < |other.elements|\n    invariant 0 <= i <= |elements|\n    invariant 0 <= j <= |other.elements|\n    invariant |merged| == i + j\n    invariant forall k, l :: 0 <= k < l < |merged| ==> merged[k].0 <= merged[l].0\n    invariant forall e :: e in merged ==> e in old(elements) || e in other.elements\n  {\n    if i < |elements| && (j >= |other.elements| || elements[i].0 <= other.elements[j].0) {\n      merged := merged + [elements[i]];\n      i := i + 1;\n    } else {\n      merged := merged + [other.elements[j]];\n      j := j + 1;\n    }\n  }\n  elements := merged;\n}\n}",
            "parents": [
                "8da96709-43b6-453c-b1a5-03a717b5036b"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "85e9bfd9-6f00-411a-8f71-8067096bba2a",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      decreases |elements| - i\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var index: int := 0;\n    // Find the element with the specified value\n    while index < |elements| && elements[index].1 != value\n      invariant 0 <= index <= |elements|\n      invariant forall k :: 0 <= k < index ==> elements[k].1 != value\n      decreases |elements| - index\n    {\n      index := index + 1;\n    }\n    // Update the priority of the found element\n    elements := elements[..index] + [(newPriority, value)] + elements[index+1..];\n    \n    // Reorder the queue to maintain the priority order\n    var i := 0;\n    var newElement := (newPriority, value);\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      decreases |elements| - i\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i+1..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\nmethod RemoveValue(value: int)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    decreases |elements| - i\n  {\n    if elements[i].1 == value {\n      elements := elements[..i] + elements[i+1..];\n    } else {\n      i := i + 1;\n    }\n  }\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\nmethod Merge(other: PriorityQueue)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures |elements| == |old(elements)| + |old(other.elements)|\n{\n  var merged: seq<(int, int)> := [];\n  var i := 0;\n  var j := 0;\n  while i < |elements| || j < |other.elements|\n    invariant 0 <= i <= |elements|\n    invariant 0 <= j <= |other.elements|\n    invariant forall k, l :: 0 <= k < l < |merged| ==> merged[k].0 <= merged[l].0\n    invariant |merged| == i + j\n    decreases |elements| + |other.elements| - (i + j)\n  {\n    if i < |elements| && (j >= |other.elements| || elements[i].0 <= other.elements[j].0) {\n      merged := merged + [elements[i]];\n      i := i + 1;\n    } else if j < |other.elements| {\n      merged := merged + [other.elements[j]];\n      j := j + 1;\n    }\n  }\n  elements := merged;\n}\n}",
            "parents": [
                "69bf4859-15da-486c-891b-d173b3b7feeb"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "312f1ffe-a87d-41ef-ad1e-1c1506848b38",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p < right ==> arr[p] > pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n    invariant forall r: int :: left <= r < i ==> arr[r] <= pivot\n    invariant forall s: int :: i <= s < j ==> arr[s] > pivot\n    invariant forall t: int :: j <= t <= right ==> arr[t] >= pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n    invariant forall r: int :: left <= r <= right ==> \n              (arr[r] <= pivot ==> r < i || r > j)\n    invariant forall s: int :: left <= s <= right ==> \n              (arr[s] > pivot ==> s < i || s > j)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "8950e131-3ee6-4481-9d18-35785b388425"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "16c25d59-3b08-47a4-98ed-d8c90194eca8",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures elements == old(elements)\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(oldValue: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == oldValue\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, oldValue)\n  {\n    var i := 0;\n    // Find the element with the specified value\n    while i < |elements| && elements[i].1 != oldValue\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != oldValue\n      invariant exists j :: i <= j < |elements| && elements[j].1 == oldValue\n    {\n      i := i + 1;\n    }\n    // Remove the element\n    elements := elements[..i] + elements[i+1..];\n    \n    // Reinsert the element with the new priority\n    var newElement := (newPriority, oldValue);\n    var j := 0;\n    while j < |elements| && elements[j].0 <= newPriority\n      invariant 0 <= j <= |elements|\n      invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n    {\n      j := j + 1;\n    }\n    elements := elements[..j] + [newElement] + elements[j..];\n  }\nmethod RemoveAllWithPriority(priority: int)\n  modifies this\n  ensures forall i :: 0 <= i < |elements| ==> elements[i].0 != priority\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 != priority\n    invariant forall m, n :: 0 <= m < n < |elements| ==> elements[m].0 <= elements[n].0\n  {\n    if elements[i].0 == priority {\n      elements := elements[..i] + elements[i+1..];\n    } else {\n      i := i + 1;\n    }\n  }\n}\n}",
            "parents": [
                "5639d8a4-aadb-4be9-a2fc-9051d5024df0"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "889d5f59-66f5-43ec-91a8-87078d992c32",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures elements == old(elements)\n  ensures value == elements[0].1\n{\n  var highestPriority := elements[0].0;\n  var highestValue := elements[0].1;\n  var i := 1;\n  while i < |elements|\n    invariant 1 <= i <= |elements|\n    invariant highestPriority == elements[0].0\n    invariant highestValue == elements[0].1\n    invariant forall k :: 0 <= k < i ==> elements[k].0 >= highestPriority\n  {\n    if elements[i].0 < highestPriority {\n      highestPriority := elements[i].0;\n      highestValue := elements[i].1;\n    }\n    i := i + 1;\n  }\n  value := highestValue;\n}\nmethod ChangePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n  // Remove the element with the specified value\n  elements := elements[..i] + elements[i+1..];\n  \n  // Re-insert the element with the new priority\n  var newElement := (newPriority, value);\n  i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [newElement] + elements[i..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\nmethod Merge(other: PriorityQueue)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |other.elements|\n    invariant 0 <= i <= |other.elements|\n    invariant forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0\n  {\n    var (priority, value) := other.elements[i];\n    var j := 0;\n    while j < |elements| && elements[j].0 <= priority\n      invariant 0 <= j <= |elements|\n      invariant forall k :: 0 <= k < j ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < j ==> elements[k].0 <= elements[l].0\n    {\n      j := j + 1;\n    }\n    elements := elements[..j] + [(priority, value)] + elements[j..];\n    i := i + 1;\n  }\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\n}",
            "parents": [
                "acc10745-d709-4a13-91d2-bd5dc8b4da10"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "542a2262-2675-4217-bd08-dc373530b604",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p < right ==> arr[p] > pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n    invariant forall r: int :: left <= r < i ==> arr[r] <= pivot\n    invariant forall s: int :: i <= s <= j ==> arr[s] > pivot\n    invariant forall t: int :: j < t <= right ==> arr[t] >= pivot\n    invariant forall u: int :: left <= u <= right ==> \n              (arr[u] < pivot || arr[u] == pivot || arr[u] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "a917cae4-7a3e-40aa-83f9-7186fb36c08f"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "262481d1-a923-4bb5-9ad2-b7cdb90b79a4",
            "type": "program",
            "content": "class Graph {\n  var adjacencyMatrix: array2<bool>;\n  constructor(n: nat) \n    requires n > 0\n  {\n    adjacencyMatrix := new bool[n, n];\n  }\n  method AddEdge(u: nat, v: nat)\n    requires 0 <= u < adjacencyMatrix.Length0\n    requires 0 <= v < adjacencyMatrix.Length1\n    modifies adjacencyMatrix\n  {\n    adjacencyMatrix[u, v] := true;\n    adjacencyMatrix[v, u] := true;\n  }\n  method IsVertexCover(cover: set<nat>) returns (isCover: bool)\n    requires cover <= set i | 0 <= i < adjacencyMatrix.Length0\n    ensures isCover == (forall u, v :: 0 <= u < adjacencyMatrix.Length0 && 0 <= v < adjacencyMatrix.Length1 && adjacencyMatrix[u, v] ==> u in cover || v in cover)\n  {\n    isCover := true;\n    var n := adjacencyMatrix.Length0;\n    for u := 0 to n - 1 {\n      for v := 0 to n - 1 {\n        if adjacencyMatrix[u, v] && !(u in cover || v in cover) {\n          isCover := false;\n          return;\n        }\n      }\n    }\n  }\nmethod IsCompleteGraph() returns (isComplete: bool)\n  ensures isComplete == (forall u, v :: 0 <= u < adjacencyMatrix.Length0 && 0 <= v < adjacencyMatrix.Length1 && u != v ==> adjacencyMatrix[u, v])\n{\n  isComplete := true;\n  var n := adjacencyMatrix.Length0;\n  for u := 0 to n - 1\n    invariant 0 <= u <= n\n    invariant isComplete == (forall i, j :: 0 <= i < u && 0 <= j < n && i != j ==> adjacencyMatrix[i, j])\n  {\n    for v := 0 to n - 1\n      invariant 0 <= v <= n\n      invariant isComplete == (forall i, j :: 0 <= i < u && 0 <= j < n && i != j ==> adjacencyMatrix[i, j]) &&\n                             (forall j :: 0 <= j < v && u != j ==> adjacencyMatrix[u, j])\n    {\n      if u != v && !adjacencyMatrix[u, v] {\n        isComplete := false;\n        return;\n      }\n    }\n  }\n}\n}",
            "parents": [
                "1143df66-397a-4f7b-adf4-e3f270d6fc69"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "SUCCESS"
            }
        },
        {
            "id": "2ba00b51-9c46-4fbe-a1d7-f928e9e1b8bf",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures elements == old(elements)\n  ensures value == elements[0].1\n{\n  value := elements[0].1;\n}\n}",
            "parents": [
                "3803a3ca-da34-4a1b-8cf7-61aa3bb9676f"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "ca0eda24-d2d0-4761-95f5-013554a48c53",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> maxLength >= lis[k]\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n  return maxLength;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> maxLength >= lis[k]\n    invariant forall k :: 0 <= k < i - 1 ==> lis[k] <= lis[k + 1] // New invariant\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n}",
            "parents": [
                "7201d35b-8e5d-4804-b741-e206c2263be3"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "d6eee4b3-c97c-4481-8fb1-c1f143515422",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures elements == old(elements)\n  ensures value == elements[0].1\n{\n  var highestPriority := elements[0].0;\n  var highestValue := elements[0].1;\n  var i := 1;\n  while i < |elements|\n    invariant 1 <= i <= |elements|\n    invariant highestPriority == elements[0].0\n    invariant highestValue == elements[0].1\n    invariant forall k :: 0 <= k < i ==> elements[k].0 >= highestPriority\n  {\n    if elements[i].0 < highestPriority {\n      highestPriority := elements[i].0;\n      highestValue := elements[i].1;\n    }\n    i := i + 1;\n  }\n  value := highestValue;\n}\nmethod IsEmpty() returns (empty: bool)\n  ensures empty == (|elements| == 0)\n{\n  var i := 0;\n  empty := true;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant empty == (i == 0)\n  {\n    empty := false;\n    i := i + 1;\n  }\n}\n}",
            "parents": [
                "87652645-07de-4f8b-a7ba-4ad1f40c0a88"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "075e0f04-f19f-40e8-b602-b7875691b86c",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures elements == old(elements)\n  ensures value == old(elements[0].1)\n{\n  value := elements[0].1;\n}\nmethod UpdatePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n{\n  var index := 0;\n  while index < |elements| && elements[index].1 != value\n    invariant 0 <= index <= |elements|\n    invariant forall k :: 0 <= k < index ==> elements[k].1 != value\n  {\n    index := index + 1;\n  }\n  var oldElement := elements[index];\n  elements := elements[..index] + elements[index + 1..];\n  \n  var i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [(newPriority, value)] + elements[i..];\n}\nmethod FindMaxPriority() returns (maxValue: int)\n  requires |elements| > 0\n  ensures exists i :: 0 <= i < |elements| && elements[i].1 == maxValue\n  ensures forall i :: 0 <= i < |elements| ==> elements[i].0 <= elements[0].0\n{\n  var maxPriority := elements[0].0;\n  maxValue := elements[0].1;\n  var i := 1;\n  while i < |elements|\n    invariant 1 <= i <= |elements|\n    invariant exists j :: 0 <= j < i && elements[j].1 == maxValue\n    invariant forall j :: 0 <= j < i ==> elements[j].0 <= maxPriority\n  {\n    if elements[i].0 > maxPriority {\n      maxPriority := elements[i].0;\n      maxValue := elements[i].1;\n    }\n    i := i + 1;\n  }\n}\n}",
            "parents": [
                "dc2486d8-1459-42bc-b96d-599284ab9427"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "7de4d0d2-4f45-4f57-9578-9ae4e62f931c",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n    invariant forall a: int, b: int :: left <= a < b <= right ==> \n              (arr[a] <= arr[b] || arr[a] > arr[b])\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "cd565c4a-6196-4c84-aef7-a5c2bd249fd8"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "04960acf-abd3-446c-9f01-9a447345a4d5",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n    invariant forall r: int :: left <= r < i ==> arr[r] <= pivot\n    invariant forall s: int :: i <= s < j ==> arr[s] > pivot\n    invariant forall t: int :: j <= t <= right ==> arr[t] >= pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n    invariant forall r: int :: left <= r < i ==> arr[r] <= pivot\n    invariant forall s: int :: i <= s < j ==> arr[s] > pivot\n    invariant forall t: int :: j <= t <= right ==> arr[t] >= pivot\n    invariant forall u: int :: left <= u < i ==> arr[u] <= pivot\n    invariant forall v: int :: i <= v <= j ==> arr[v] > pivot\n    invariant forall w: int :: j < w <= right ==> arr[w] >= pivot\n    invariant forall x: int :: left <= x <= right ==> \n              (arr[x] <= pivot || arr[x] > pivot || arr[x] == pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "d0c6d61a-a938-45ec-99d0-57a898f70f86"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "73e288f2-30fb-4600-8793-d5bfc53cfe18",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  \n  constructor() {\n    elements := [];\n  }\n\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    var i := 0;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 >= elements[i].0\n      invariant forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0\n    {\n      if elements[i].0 > elements[0].0 {\n        value := elements[i].1;\n        return;\n      }\n      i := i + 1;\n    }\n    value := elements[0].1;\n  }\nmethod IsEmpty() returns (empty: bool)\n  ensures empty == (|elements| == 0)\n{\n  var i := 0;\n  empty := true;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant empty == (i == 0)\n  {\n    empty := false;\n    i := i + 1;\n  }\n}\n}",
            "parents": [
                "a4d15c75-3986-4d86-a258-d9575b39682b"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "ee0b48e9-735d-451d-94aa-936f96717a13",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant exists i: int :: left <= i <= right && arr[i] == arr[k]\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> arr[q] >= pivot || q < i\n    invariant forall r: int :: left <= r <= right ==> arr[r] <= pivot || r >= i\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant (forall q: int :: left <= q <= j ==> arr[q] <= pivot) == (i == j)\n    invariant (forall r: int :: i <= r <= j ==> arr[r] > pivot) == (j == right - 1)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= j ==> arr[q] <= pivot || q < i\n    invariant forall r: int :: i <= r <= j ==> arr[r] > pivot || r >= i\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "4cd78da6-c045-466d-b20e-1e728f74c495"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "2c161f39-3bbf-4762-980d-326beef047ec",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\nmethod ChangePriority(oldPriority: int, value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i] == (oldPriority, value)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |elements| && elements[i] != (oldPriority, value)\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k] != (oldPriority, value)\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + elements[i+1..];\n  var newElement := (newPriority, value);\n  i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [newElement] + elements[i..];\n}\nmethod Merge(other: PriorityQueue)\n  modifies this\n  ensures forall e :: e in other.elements ==> e in elements\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |other.elements|\n    invariant 0 <= i <= |other.elements|\n    invariant forall k :: 0 <= k < i ==> other.elements[k] in elements\n    invariant forall m, n :: 0 <= m < n < |elements| ==> elements[m].0 <= elements[n].0\n  {\n    var (priority, value) := other.elements[i];\n    Enqueue(priority, value);\n    i := i + 1;\n  }\n}\nmethod RemoveValue(value: int)\n  modifies this\n  ensures forall e :: e in elements ==> e.1 != value\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n    invariant forall m, n :: 0 <= m < n < |elements| ==> elements[m].0 <= elements[n].0\n  {\n    if elements[i].1 == value {\n      elements := elements[..i] + elements[i+1..];\n    } else {\n      i := i + 1;\n    }\n  }\n}\nmethod FindMaxPriority() returns (maxPriority: int)\n  requires |elements| > 0\n  ensures forall e :: e in elements ==> e.0 <= maxPriority\n  ensures exists e :: e in elements && e.0 == maxPriority\n{\n  var i := 0;\n  maxPriority := elements[0].0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= maxPriority\n    invariant exists k :: 0 <= k < |elements| && elements[k].0 == maxPriority\n  {\n    if elements[i].0 > maxPriority {\n      maxPriority := elements[i].0;\n    }\n    i := i + 1;\n  }\n}\n}",
            "parents": [
                "a8cf6e1a-efae-48eb-acb4-1746e705775b"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "8a055deb-e29d-43a5-b9f2-6a020ce38fdb",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  \n  constructor() {\n    elements := [];\n  }\n\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\nmethod IsEmpty() returns (isEmpty: bool)\n  ensures isEmpty == (|elements| == 0)\n{\n  isEmpty := |elements| == 0;\n}\nmethod Merge(other: PriorityQueue)\n  modifies this\n  ensures |elements| == |old(elements)| + |other.elements|\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures multiset(elements) == multiset(old(elements) + other.elements)\n{\n  var merged: seq<(int, int)> := [];\n  var i := 0;\n  var j := 0;\n\n  while i < |elements| || j < |other.elements|\n    invariant 0 <= i <= |elements|\n    invariant 0 <= j <= |other.elements|\n    invariant |merged| == i + j\n    invariant forall k, l :: 0 <= k < l < |merged| ==> merged[k].0 <= merged[l].0\n    invariant multiset(merged) == multiset(elements[..i] + other.elements[..j])\n  {\n    if i < |elements| && (j >= |other.elements| || elements[i].0 <= other.elements[j].0) {\n      merged := merged + [elements[i]];\n      i := i + 1;\n    } else {\n      merged := merged + [other.elements[j]];\n      j := j + 1;\n    }\n  }\n\n  elements := merged;\n}\n}",
            "parents": [
                "27895798-fdf1-4ae6-b0c4-a594e2a527a7"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "17f84771-8855-421e-93bf-901975a82fc9",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n  ensures elements == old(elements)\n{\n  var i := 0;\n  var highestPriority := elements[0].0;\n  value := elements[0].1;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= highestPriority\n    invariant value == elements[0].1\n  {\n    if elements[i].0 < highestPriority {\n      highestPriority := elements[i].0;\n      value := elements[i].1;\n    }\n    i := i + 1;\n  }\n  assert value == elements[0].1;\n}\nmethod IsEmpty() returns (empty: bool)\n  ensures empty <==> |elements| == 0\n{\n  empty := |elements| == 0;\n}\n}",
            "parents": [
                "7e3e9e41-6ccf-4a82-9892-1fb294c88c1a"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "670596d7-7da3-4aa5-93e1-0f1fe73178d8",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures elements == old(elements)\n  ensures value == elements[0].1\n{\n  var highestPriority := elements[0].0;\n  var highestValue := elements[0].1;\n  var i := 1;\n  while i < |elements|\n    invariant 1 <= i <= |elements|\n    invariant highestPriority == elements[0].0\n    invariant highestValue == elements[0].1\n    invariant forall k :: 0 <= k < i ==> elements[k].0 >= highestPriority\n  {\n    if elements[i].0 < highestPriority {\n      highestPriority := elements[i].0;\n      highestValue := elements[i].1;\n    }\n    i := i + 1;\n  }\n  value := highestValue;\n}\nmethod ChangePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n{\n  var i := 0;\n  // Find the element with the specified value\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n  // Remove the element from the sequence\n  elements := elements[..i] + elements[i+1..];\n  \n  // Re-insert with the new priority\n  i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [(newPriority, value)] + elements[i..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\nmethod Merge(other: PriorityQueue)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures |elements| == old(|elements|) + |other.elements|\n  ensures forall e :: e in other.elements ==> e in elements\n{\n  var i := 0;\n  var j := 0;\n  var merged: seq<(int, int)> := [];\n  while i < |elements| || j < |other.elements|\n    invariant 0 <= i <= |elements|\n    invariant 0 <= j <= |other.elements|\n    invariant |merged| == i + j\n    invariant forall k, l :: 0 <= k < l < |merged| ==> merged[k].0 <= merged[l].0\n    invariant forall e :: e in merged ==> e in old(elements) + old(other.elements)\n  {\n    if i < |elements| && (j >= |other.elements| || elements[i].0 <= other.elements[j].0) {\n      merged := merged + [elements[i]];\n      i := i + 1;\n    } else {\n      merged := merged + [other.elements[j]];\n      j := j + 1;\n    }\n  }\n  elements := merged;\n}\nmethod RemoveAllWithPriority(priority: int)\n  modifies this\n  ensures forall i :: 0 <= i < |elements| ==> elements[i].0 != priority\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 != priority\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n  {\n    if elements[i].0 == priority {\n      elements := elements[..i] + elements[i+1..];\n    } else {\n      i := i + 1;\n    }\n  }\n}\n}",
            "parents": [
                "8f458c0a-ace2-40ab-ab63-73072507d648"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "6bb09b32-dbe7-4c37-9e1b-698104bfd03e",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures elements == old(elements)\n  ensures value == old(elements[0].1)\n{\n  value := elements[0].1;\n}\nmethod ChangePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n{\n  var index := 0;\n  while index < |elements| && elements[index].1 != value\n    invariant 0 <= index <= |elements|\n    invariant forall k :: 0 <= k < index ==> elements[k].1 != value\n  {\n    index := index + 1;\n  }\n  elements := elements[..index] + elements[index + 1..];\n  \n  var i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [(newPriority, value)] + elements[i..];\n}\n}",
            "parents": [
                "672811ec-af0c-4014-a56f-9d8dfb71a0b5"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "bd3f8d3d-4b00-4771-b0a2-47b134df7d0e",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n    invariant forall k, l :: 0 <= k < l < i && arr[k] < arr[l] ==> lis[l] >= lis[k] + 1\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n      invariant forall k, l :: 0 <= k < l < i && arr[k] < arr[l] ==> lis[l] >= lis[k] + 1\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n    invariant forall k, l :: 0 <= k < l < i && arr[k] < arr[l] ==> lis[l] >= lis[k] + 1\n    invariant forall k :: 0 <= k < i - 1 ==> lis[k] <= lis[k + 1]\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n      invariant forall k, l :: 0 <= k < l < i && arr[k] < arr[l] ==> lis[l] >= lis[k] + 1\n      invariant forall k :: 0 <= k < i - 1 ==> lis[k] <= lis[k + 1]\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n}",
            "parents": [
                "b4b761b0-1219-4971-93fd-d084cc0e7de3"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "5930c594-2f01-493d-af2c-91db85338709",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p < right ==> arr[p] > pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n    invariant forall r: int :: left <= r < j ==> arr[r] <= pivot || arr[r] > pivot\n    invariant forall s: int :: j <= s <= right ==> arr[s] >= pivot || arr[s] < pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n    invariant forall r: int :: left <= r <= right ==> \n              (arr[r] <= pivot ==> r < i || r > j)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "4bc9e5ca-6194-460b-8c11-365eb0f37499"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "53e75e14-e0e1-44c0-b1ef-75b97cf3a2f8",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p < right ==> arr[p] > pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n    invariant forall r: int :: left <= r < j ==> arr[r] <= pivot || arr[r] > pivot\n    invariant forall s: int :: j <= s <= right ==> arr[s] >= pivot || arr[s] < pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}\n}",
            "parents": [
                "a3e62053-9c6d-48a9-b8e3-f4e0235d8f8b"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "40be5413-b048-42ea-bd2b-6c9d3c81040d",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n{\n  value := elements[0].1;\n}\nmethod ChangePriority(oldPriority: int, value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i] == (oldPriority, value)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n{\n  var i := 0;\n  // Find the element with the old priority and value\n  while i < |elements| && elements[i] != (oldPriority, value)\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k] != (oldPriority, value)\n  {\n    i := i + 1;\n  }\n  // Remove the element\n  elements := elements[..i] + elements[i+1..];\n  \n  // Re-insert the element with the new priority\n  var newElement := (newPriority, value);\n  var j := 0;\n  while j < |elements| && elements[j].0 <= newPriority\n    invariant 0 <= j <= |elements|\n    invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n  {\n    j := j + 1;\n  }\n  elements := elements[..j] + [newElement] + elements[j..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\n}",
            "parents": [
                "024c3d7f-0896-40c5-a55d-bd233e917c6f"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "07ce792a-5a60-486a-96b7-fb975b809a35",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant exists i: int :: left <= i <= right && arr[i] == arr[k]\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> arr[q] >= pivot || q < i\n    invariant forall r: int :: left <= r <= right ==> arr[r] <= pivot || r >= i\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> arr[q] >= pivot || q < i\n    invariant forall r: int :: left <= r <= right ==> arr[r] <= pivot || r >= i\n    invariant forall s: int :: left <= s < i ==> arr[s] <= pivot\n    invariant forall t: int :: i <= t <= j ==> arr[t] > pivot\n    invariant forall u: int :: j < u <= right ==> arr[u] >= pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "a167c201-463a-45b6-b3f1-1db748256467"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "0973fe8d-5795-4eda-b1de-c7bac46c28b5",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures elements == old(elements)\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n  }\nmethod IsEmpty() returns (empty: bool)\n  ensures empty <==> |elements| == 0\n  ensures elements == old(elements)\n{\n  empty := |elements| == 0;\n}\n}",
            "parents": [
                "4596c890-ed7d-46c8-97d0-2e065b117389"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "eaf36c65-62c9-42fd-9e27-c66d7fccd808",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  \n  constructor() {\n    elements := [];\n  }\n\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n\n  method IsEmpty() returns (empty: bool)\n    ensures empty == (|elements| == 0)\n  {\n    empty := |elements| == 0;\n  }\n}",
            "parents": [
                "73e288f2-30fb-4600-8793-d5bfc53cfe18"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "61e9d5ca-1914-428d-b234-13bcc1a34c86",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> maxLength >= lis[k]\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> maxLength >= lis[k]\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k :: 0 <= k < i ==> maxLength >= lis[k]\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  length := maxLength;\n  assert forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> maxLength >= j - i + 1;\n  return maxLength;\n}",
            "parents": [
                "004df12c-828d-4ec6-bb2e-ef4f8aafebeb"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "d09e1a64-f1f7-4dcf-91dd-d4e65311d6ba",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements[..i] + elements[i..] == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures elements == old(elements)\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(oldValue: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == oldValue\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, oldValue)\n  {\n    var i := 0;\n    // Find the element with the specified value\n    while i < |elements| && elements[i].1 != oldValue\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != oldValue\n      invariant exists j :: i <= j < |elements| && elements[j].1 == oldValue\n    {\n      i := i + 1;\n    }\n    // Remove the element\n    elements := elements[..i] + elements[i+1..];\n    \n    // Reinsert the element with the new priority\n    var newElement := (newPriority, oldValue);\n    var j := 0;\n    while j < |elements| && elements[j].0 <= newPriority\n      invariant 0 <= j <= |elements|\n      invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n      invariant elements[..j] + elements[j..] == elements[..i] + elements[i+1..]\n    {\n      j := j + 1;\n    }\n    elements := elements[..j] + [newElement] + elements[j..];\n  }\n  method RemoveAllWithPriority(priority: int)\n    modifies this\n    ensures forall i :: 0 <= i < |elements| ==> elements[i].0 != priority\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var i := 0;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 != priority\n      invariant forall m, n :: 0 <= m < n < |elements| ==> elements[m].0 <= elements[n].0\n    {\n      if elements[i].0 == priority {\n        elements := elements[..i] + elements[i+1..];\n      } else {\n        i := i + 1;\n      }\n    }\n  }\n}",
            "parents": [
                "16c25d59-3b08-47a4-98ed-d8c90194eca8"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "19d3f723-d925-4d5c-b904-aee7c5c7d6a1",
            "type": "program",
            "content": "// A simple program to verify that a given configuration of queens on a chessboard is valid\n// i.e., no two queens attack each other.\nmethod IsValidQueenConfiguration(board: seq<seq<bool>>) returns (valid: bool)\n  requires |board| == 8 && forall row :: 0 <= row < |board| ==> |board[row]| == 8\n  ensures valid == true <==> (forall i, j, k, l :: 0 <= i < 8 && 0 <= j < 8 && 0 <= k < 8 && 0 <= l < 8 && board[i][j] && board[k][l] ==> (i == k && j == l) || (i != k && j != l && i - j != k - l && i + j != k + l))\n{\n  valid := true;\n  var n := 8;\n  // Check each pair of queens to ensure they do not attack each other\n  for i := 0 to n - 1\n    invariant 0 <= i <= n\n    invariant valid == true ==> (forall x, y :: 0 <= x < i && 0 <= y < n && board[x][y] ==> (forall a, b :: 0 <= a < n && 0 <= b < n && board[a][b] && (x != a || y != b) ==> x != a && y != b && x - y != a - b && x + y != a + b))\n  {\n    for j := 0 to n - 1\n      invariant 0 <= j <= n\n      invariant valid == true ==> (forall x, y :: 0 <= x <= i && 0 <= y < j && board[x][y] ==> (forall a, b :: 0 <= a < n && 0 <= b < n && board[a][b] && (x != a || y != b) ==> x != a && y != b && x - y != a - b && x + y != a + b))\n    {\n      if board[i][j] {\n        for k := 0 to n - 1\n          invariant 0 <= k <= n\n          invariant valid == true ==> (forall x, y :: 0 <= x <= i && 0 <= y <= j && board[x][y] ==> (forall a, b :: 0 <= a < k && 0 <= b < n && board[a][b] && (x != a || y != b) ==> x != a && y != b && x - y != a - b && x + y != a + b))\n        {\n          for l := 0 to n - 1\n            invariant 0 <= l <= n\n            invariant valid == true ==> (forall x, y :: 0 <= x <= i && 0 <= y <= j && board[x][y] ==> (forall a, b :: 0 <= a <= k && 0 <= b < l && board[a][b] && (x != a || y != b) ==> x != a && y != b && x - y != a - b && x + y != a + b))\n          {\n            if board[k][l] && (i != k || j != l) {\n              // Check if they are in the same row, column, or diagonal\n              if i == k || j == l || i - j == k - l || i + j == k + l {\n                valid := false;\n                return;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
            "parents": [
                "bbe8dea4-a7fd-41c0-a9a1-84093df79fe4"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "2756609e-89bb-46ac-b028-a9741fad836c",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n}",
            "parents": [
                "34cc4e77-1a58-4c34-82af-d526b9d091e4"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "5f488744-a77a-4810-ae41-cee5e0738151",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n    invariant forall k :: 0 <= k < i && lis[k] > 1 ==> exists m :: 0 <= m < k && arr[m] < arr[k] && lis[m] + 1 == lis[k]\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n      invariant forall k :: 0 <= k < i && lis[k] > 1 ==> exists m :: 0 <= m < k && arr[m] < arr[k] && lis[m] + 1 == lis[k]\n      invariant forall k :: 0 <= k < j ==> arr[k] < arr[i] ==> lis[i] >= lis[k] + 1\n      invariant lis[i] <= maxLength\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  length := maxLength;\n  assert forall i, j :: 0 <= i < j < n && arr[i] < arr[j] ==> length >= j - i + 1;\n  return length;\n}",
            "parents": [
                "3b7dd072-dfdb-4237-b0e9-3b1cce27c1ef"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "21316b83-48c7-46e7-870f-7569ddf245df",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    var updatedElement := (newPriority, value);\n    elements := elements[..i] + elements[i+1..];\n    \n    // Re-insert the updated element\n    var j := 0;\n    while j < |elements| && elements[j].0 <= newPriority\n      invariant 0 <= j <= |elements|\n      invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < j ==> elements[k].0 <= elements[l].0\n    {\n      j := j + 1;\n    }\n    elements := elements[..j] + [updatedElement] + elements[j..];\n  }\n  method RemoveValue(value: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i :: 0 <= i < |elements| ==> elements[i].1 != value\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + elements[i+1..];\n  }\n}",
            "parents": [
                "60157cc1-4a4a-4f84-94a4-6f885be35ef0"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "c14d5755-7182-4ee4-b98a-01604f032304",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures elements == old(elements)\n    ensures value == elements[0].1\n  {\n    var highestPriority := elements[0].0;\n    var highestValue := elements[0].1;\n    var i := 1;\n    while i < |elements|\n      invariant 1 <= i <= |elements|\n      invariant highestPriority == elements[0].0\n      invariant highestValue == elements[0].1\n      invariant forall k :: 0 <= k < i ==> elements[k].0 >= highestPriority\n    {\n      if elements[i].0 < highestPriority {\n        highestPriority := elements[i].0;\n        highestValue := elements[i].1;\n      }\n      i := i + 1;\n    }\n    value := highestValue;\n  }\n  method ChangePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n  {\n    var i := 0;\n    // Find the element with the specified value\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n    {\n      i := i + 1;\n    }\n    // Remove the element from the sequence\n    elements := elements[..i] + elements[i+1..];\n    \n    // Re-insert with the new priority\n    i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [(newPriority, value)] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n}",
            "parents": [
                "bd3d45d4-b97f-4b8c-a49c-effee6725dfa"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "bd5753f9-6482-478c-b6fe-2ce7d06c361e",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n}",
            "parents": [
                "3803a3ca-da34-4a1b-8cf7-61aa3bb9676f"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "6bf049f3-820b-4dfc-beca-a265cc6b2f79",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements[..i] == old(elements[..i])\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(oldPriority: int, value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i] == (oldPriority, value)\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n  {\n    var i := 0;\n    // Find the element with the old priority and value\n    while i < |elements| && elements[i] != (oldPriority, value)\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k] != (oldPriority, value)\n    {\n      i := i + 1;\n    }\n    // Remove the element\n    elements := elements[..i] + elements[i+1..];\n    \n    // Re-insert the element with the new priority\n    var newElement := (newPriority, value);\n    var j := 0;\n    while j < |elements| && elements[j].0 <= newPriority\n      invariant 0 <= j <= |elements|\n      invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n    {\n      j := j + 1;\n    }\n    elements := elements[..j] + [newElement] + elements[j..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n}",
            "parents": [
                "40be5413-b048-42ea-bd2b-6c9d3c81040d"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "9746eb90-470d-41a7-b80b-1d13a053b588",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n    invariant forall k, l :: 0 <= k < l < i && arr[k] < arr[l] ==> lis[l] >= lis[k] + 1\n    invariant maxLength >= (if i > 0 then lis[i - 1] else 1) // New invariant\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n      invariant forall k, l :: 0 <= k < l < i && arr[k] < arr[l] ==> lis[l] >= lis[k] + 1\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n}",
            "parents": [
                "08ab482c-5bfd-4ce8-b920-e65edb1cfabf"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "6800a69d-28b5-4733-bdf1-0c0f7a12990a",
            "type": "program",
            "content": "class Graph {\n  var adjacencyMatrix: array2<bool>;\n\n  constructor(n: nat) \n    requires n > 0\n    ensures adjacencyMatrix.Length0 == n && adjacencyMatrix.Length1 == n\n    ensures forall i, j :: 0 <= i < n && 0 <= j < n ==> !adjacencyMatrix[i, j]\n  {\n    adjacencyMatrix := new bool[n, n];\n  }\n\n  method AddEdge(u: nat, v: nat)\n    requires 0 <= u < adjacencyMatrix.Length0\n    requires 0 <= v < adjacencyMatrix.Length1\n    modifies adjacencyMatrix\n    ensures adjacencyMatrix[u, v] && adjacencyMatrix[v, u]\n  {\n    adjacencyMatrix[u, v] := true;\n    adjacencyMatrix[v, u] := true;\n  }\n\n  method IsVertexCover(cover: set<nat>) returns (isCover: bool)\n    requires cover <= set i | 0 <= i < adjacencyMatrix.Length0\n    ensures isCover == (forall u, v :: 0 <= u < adjacencyMatrix.Length0 && 0 <= v < adjacencyMatrix.Length1 && adjacencyMatrix[u, v] ==> u in cover || v in cover)\n  {\n    isCover := true;\n    var n := adjacencyMatrix.Length0;\n    for u := 0 to n - 1 \n      invariant 0 <= u <= n\n      invariant isCover == (forall i, j :: 0 <= i < u && 0 <= j < n && adjacencyMatrix[i, j] ==> i in cover || j in cover)\n    {\n      for v := 0 to n - 1 \n        invariant 0 <= v <= n\n        invariant isCover == (forall i, j :: 0 <= i < u && 0 <= j < n && adjacencyMatrix[i, j] ==> i in cover || j in cover)\n        invariant isCover == (forall j :: 0 <= j < v && adjacencyMatrix[u, j] ==> u in cover || j in cover)\n      {\n        if adjacencyMatrix[u, v] && !(u in cover || v in cover) {\n          isCover := false;\n          return;\n        }\n      }\n    }\n  }\n\n  method IsCompleteGraph() returns (isComplete: bool)\n    ensures isComplete == (forall u, v :: 0 <= u < adjacencyMatrix.Length0 && 0 <= v < adjacencyMatrix.Length1 && u != v ==> adjacencyMatrix[u, v])\n  {\n    isComplete := true;\n    var n := adjacencyMatrix.Length0;\n    for u := 0 to n - 1\n      invariant 0 <= u <= n\n      invariant isComplete == (forall i, j :: 0 <= i < u && 0 <= j < n && i != j ==> adjacencyMatrix[i, j])\n    {\n      for v := 0 to n - 1\n        invariant 0 <= v <= n\n        invariant isComplete == (forall i, j :: 0 <= i < u && 0 <= j < n && i != j ==> adjacencyMatrix[i, j])\n        invariant isComplete == (forall j :: 0 <= j < v && u != j ==> adjacencyMatrix[u, j])\n      {\n        if u != v && !adjacencyMatrix[u, v] {\n          isComplete := false;\n          return;\n        }\n      }\n    }\n  }\n}",
            "parents": [
                "5b849512-9261-47f1-aef0-e80e59c63f0f"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "bb3a3b6d-bbf3-40bb-a822-f6d1a809a386",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> lis[k] == 1\n    invariant 1 <= maxLength <= i + 1\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> maxLength >= lis[k]\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k :: 0 <= k < i ==> maxLength >= lis[k]\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n}",
            "parents": [
                "3fd297c4-2005-4dfc-9618-ca2fc486fcbb"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "83f134af-989e-49f7-aec6-440a4c408440",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n      invariant exists j :: 0 <= j < |elements| ==> elements[j].1 == value\n    {\n      i := i + 1;\n    }\n    var oldElement := elements[i];\n    elements := elements[..i] + elements[i+1..];\n    var j := 0;\n    while j < |elements| && elements[j].0 <= newPriority\n      invariant 0 <= j <= |elements|\n      invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < j ==> elements[k].0 <= elements[l].0\n      invariant elements == old(elements[..i] + elements[i+1..])\n    {\n      j := j + 1;\n    }\n    elements := elements[..j] + [(newPriority, value)] + elements[j..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method RemoveValue(value: int) \n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures !exists i :: 0 <= i < |elements| && elements[i].1 == value\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n      invariant exists j :: 0 <= j < |elements| ==> elements[j].1 == value\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + elements[i+1..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n}",
            "parents": [
                "e526fc38-6297-4a55-9b75-bbd8a428c406"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "5cfc3c4f-9504-4d16-8157-18b40cc3f19f",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  \n  constructor() {\n    elements := [];\n  }\n\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    var i := 0;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 >= elements[i].0\n      invariant i == 0 ==> value == elements[0].1\n    {\n      if elements[i].0 > elements[0].0 {\n        value := elements[i].1;\n        return;\n      }\n      i := i + 1;\n    }\n    value := elements[0].1;\n  }\n}",
            "parents": [
                "223a0b93-3151-4812-9c68-627387fa2a84"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "31829012-41f3-4073-a7fe-5dc8bb07c32c",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> maxLength >= lis[k]\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n}",
            "parents": [
                "ca0eda24-d2d0-4761-95f5-013554a48c53"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "68d61252-d630-4228-bce9-8fee2b4a9ce6",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant exists i: int :: left <= i <= right && arr[i] == arr[k]\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "ee0b48e9-735d-451d-94aa-936f96717a13"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "72fb19e3-8b20-4bf9-abfb-8143ed8452ed",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements[..i]) + old(elements[i..])\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n}",
            "parents": [
                "024c3d7f-0896-40c5-a55d-bd233e917c6f"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "a3aab9e6-15ff-4fa3-9fc4-63090f003219",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(oldValue: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == oldValue\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, oldValue)\n    ensures |elements| == old(|elements|)\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != oldValue\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != oldValue\n    {\n      i := i + 1;\n    }\n\n    // Remove the element with oldValue\n    var removedElement := elements[i];\n    elements := elements[..i] + elements[i+1..];\n\n    // Insert the element with the new priority\n    var newElement := (newPriority, oldValue);\n    i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n}",
            "parents": [
                "88decd5e-1c0c-466b-b71a-baa4beee8c25"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "a4ade04c-1bfd-4bcc-9527-519bc3f9256a",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant exists i: int :: left <= i <= right && \n              (forall j: int :: left <= j < i ==> arr[j] <= arr[i]) &&\n              (forall j: int :: i < j <= right ==> arr[j] >= arr[i])\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "14ea84df-3997-4b7b-ae7a-a0cb194df88b"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "dd4db3fc-f4f8-4a7a-97d6-5bff70d9269a",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures elements == old(elements)\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n}",
            "parents": [
                "ff0acc56-7506-4644-a976-b8a7bf2e46da"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "97bc1739-1236-491b-88a2-e34f1e322792",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method UpdatePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures forall i :: 0 <= i < |elements| ==> elements[i].1 != value || elements[i].0 == newPriority\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n    {\n      i := i + 1;\n    }\n\n    // Remove the element with the old priority\n    elements := elements[..i] + elements[i+1..];\n\n    // Reinsert the element with the new priority\n    var newElement := (newPriority, value);\n    i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Merge(other: PriorityQueue)\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures |elements| == old(|elements|) + |other.elements|\n    ensures forall e :: e in other.elements ==> e in elements\n  {\n    var i := 0;\n    while i < |other.elements|\n      invariant 0 <= i <= |other.elements|\n      invariant |elements| == old(|elements|) + i\n      invariant forall j, k :: 0 <= j < k < |elements| ==> elements[j].0 <= elements[k].0\n      invariant forall e :: e in other.elements[..i] ==> e in elements\n    {\n      var (priority, value) := other.elements[i];\n      this.Enqueue(priority, value);\n      i := i + 1;\n    }\n  }\n}",
            "parents": [
                "bcd26e3b-ff15-48a7-87af-f7ced2eb9c56"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "53e46f05-6c51-46a6-9b91-b65f64b37c2a",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n    ensures elements == old(elements)\n  {\n    var i := 0;\n    var highestPriority := elements[0].0;\n    value := elements[0].1;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= highestPriority\n      invariant exists k :: 0 <= k < |elements| && elements[k].0 == highestPriority && value == elements[k].1\n    {\n      if elements[i].0 < highestPriority {\n        highestPriority := elements[i].0;\n        value := elements[i].1;\n      }\n      i := i + 1;\n    }\n    assert exists k :: 0 <= k < |elements| && elements[k].0 == highestPriority && value == elements[k].1;\n  }\n  method IsEmpty() returns (empty: bool)\n    ensures empty <==> |elements| == 0\n  {\n    empty := |elements| == 0;\n  }\n}",
            "parents": [
                "24766049-782a-4a21-b0eb-95e541710466"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "eef891a4-6118-472f-ba5a-5cb6df83bb4c",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method IsEmpty() returns (empty: bool)\n    ensures empty == (|elements| == 0)\n  {\n    var i := 0;\n    empty := true;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant empty == (i == 0)\n    {\n      empty := false;\n      i := i + 1;\n    }\n  }\n  method Merge(other: PriorityQueue)\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures |elements| == |old(elements)| + |other.elements|\n    ensures multiset(elements) == multiset(old(elements) + other.elements)\n  {\n    var merged: seq<(int, int)> := [];\n    var i := 0;\n    var j := 0;\n\n    while i < |elements| || j < |other.elements|\n      invariant 0 <= i <= |elements|\n      invariant 0 <= j <= |other.elements|\n      invariant |merged| == i + j\n      invariant forall k, l :: 0 <= k < l < |merged| ==> merged[k].0 <= merged[l].0\n      invariant multiset(merged) == multiset(old(elements[..i]) + other.elements[..j])\n    {\n      if i < |elements| && (j >= |other.elements| || elements[i].0 <= other.elements[j].0) {\n        merged := merged + [elements[i]];\n        i := i + 1;\n      } else {\n        merged := merged + [other.elements[j]];\n        j := j + 1;\n      }\n    }\n    elements := merged;\n  }\n}",
            "parents": [
                "15b62b82-d6b0-48fb-910c-77902ed912e7"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "41badb0e-ecf3-4d09-94ba-4779fd364aff",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures elements == old(elements)\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(oldValue: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == oldValue\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, oldValue)\n  {\n    var i := 0;\n    // Find the element with the specified value\n    while i < |elements| && elements[i].1 != oldValue\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != oldValue\n    {\n      i := i + 1;\n    }\n    // Remove the element\n    elements := elements[..i] + elements[i+1..];\n    \n    // Reinsert the element with the new priority\n    var newElement := (newPriority, oldValue);\n    var j := 0;\n    while j < |elements| && elements[j].0 <= newPriority\n      invariant 0 <= j <= |elements|\n      invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n      invariant elements == old(elements[..i] + elements[i+1..])\n    {\n      j := j + 1;\n    }\n    elements := elements[..j] + [newElement] + elements[j..];\n  }\n  method Merge(other: PriorityQueue)\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures |elements| == old(|elements|) + |other.elements|\n    ensures forall e :: e in other.elements ==> e in elements\n  {\n    var i := 0;\n    while i < |other.elements|\n      invariant 0 <= i <= |other.elements|\n      invariant |elements| == old(|elements|) + i\n      invariant forall j, k :: 0 <= j < k < |elements| ==> elements[j].0 <= elements[k].0\n      invariant forall e :: e in other.elements[..i] ==> e in elements\n    {\n      var (priority, value) := other.elements[i];\n      this.Enqueue(priority, value);\n      i := i + 1;\n    }\n  }\n}",
            "parents": [
                "add9b37b-529c-41d8-9a87-1190d778fa35"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "a7f1f348-389f-41d7-94bd-7701d98c6c7b",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n}",
            "parents": [
                "06ba2f07-fbf7-430a-a181-3deb6d20bbe3"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "bf216c66-a16c-4ca5-b6aa-2ba5e5522448",
            "type": "program",
            "content": "method IsValidStackSequence(operations: seq<string>) returns (isValid: bool)\n  ensures isValid == (forall i :: 0 <= i < |operations| ==> operations[i] == \"push\" || operations[i] == \"pop\")\n{\n  var stackSize := 0;\n  isValid := true;\n  // Loop through each operation in the sequence\n  for i := 0 to |operations| \n    invariant 0 <= stackSize\n    invariant 0 <= i <= |operations|\n    invariant isValid == (forall j :: 0 <= j < i ==> operations[j] == \"push\" || operations[j] == \"pop\")\n  {\n    if operations[i] == \"push\" {\n      stackSize := stackSize + 1;\n    } else if operations[i] == \"pop\" {\n      if stackSize == 0 {\n        isValid := false;\n        return;\n      }\n      stackSize := stackSize - 1;\n    } else {\n      isValid := false;\n      return;\n    }\n  }\n  var maxStackSize := 0;\n  stackSize := 0; // Reset stackSize for the second loop\n  for i := 0 to |operations| \n    invariant 0 <= stackSize\n    invariant 0 <= i <= |operations|\n    invariant isValid == (forall j :: 0 <= j < i ==> operations[j] == \"push\" || operations[j] == \"pop\")\n    invariant maxStackSize >= stackSize\n  {\n    if operations[i] == \"push\" {\n      stackSize := stackSize + 1;\n      if stackSize > maxStackSize {\n        maxStackSize := stackSize;\n      }\n    } else if operations[i] == \"pop\" {\n      if stackSize == 0 {\n        isValid := false;\n        return;\n      }\n      stackSize := stackSize - 1;\n    } else {\n      isValid := false;\n      return;\n    }\n  }\n}",
            "parents": [
                "4251edc1-eb92-408b-a9b9-72456f447f1c"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "8fa4d618-abca-4854-9f4b-e936e14d7fa4",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  \n  constructor() {\n    elements := [];\n  }\n  \n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  \n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  \n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures elements == old(elements)\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n  }\n  \n  method UpdatePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n  {\n    var index := 0;\n    while index < |elements| && elements[index].1 != value\n      invariant 0 <= index <= |elements|\n      invariant forall k :: 0 <= k < index ==> elements[k].1 != value\n      invariant exists i :: 0 <= i < |elements| && elements[i].1 == value\n    {\n      index := index + 1;\n    }\n    var oldElement := elements[index];\n    elements := elements[..index] + elements[index + 1..];\n    \n    var i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [(newPriority, value)] + elements[i..];\n  }\n}",
            "parents": [
                "dc2486d8-1459-42bc-b96d-599284ab9427"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "cf80252c-18f1-496e-8005-1cc5ffc665a8",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant exists i: int :: left <= i <= right && \n              (forall j: int :: left <= j < i ==> arr[j] <= arr[i]) &&\n              (forall j: int :: i < j <= right ==> arr[j] >= arr[i])\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "e4a6b192-7a56-48a0-bee3-88e05ad28efb"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "6c3d3ac7-f8f0-4080-82ff-b1e66bf34a0c",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n}",
            "parents": [
                "a70cb0fe-ec4d-4ece-91ef-0b8fa644633c"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "6dc8cff5-a934-4e13-8ced-7614f5cfbda0",
            "type": "program",
            "content": "method IsPerfectSquare(n: nat) returns (result: bool)\n  ensures result == (exists k: nat :: k * k == n)\n{\n  var k: nat := 0;\n  result := false;\n  while k * k <= n\n    invariant 0 <= k <= n + 1\n    invariant forall i: nat :: 0 <= i < k ==> i * i != n\n    invariant result == (exists i: nat :: 0 <= i < k && i * i == n)\n  {\n    if k * k == n {\n      result := true;\n      return;\n    }\n    k := k + 1;\n  }\n}",
            "parents": [
                "a695d42b-636a-4b6b-8ef8-9cce677f5da1"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "b1dc6c2e-c1f2-458c-8166-bcd44c022f31",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n    invariant forall k :: 0 <= k < i ==> forall l :: 0 <= l < k ==> arr[l] < arr[k] ==> lis[l] < lis[k]\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n      invariant forall k :: 0 <= k < i ==> forall l :: 0 <= l < k ==> arr[l] < arr[k] ==> lis[l] < lis[k]\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  length := maxLength;\n  assert forall i, j :: 0 <= i < j < n && arr[i] < arr[j] ==> length >= j - i + 1;\n  return length;\n}",
            "parents": [
                "26c0afbb-ac15-46ec-bd57-7a20102170f0"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "f659e117-b330-4802-b34b-932d92347fff",
            "type": "program",
            "content": "method IsPerfectSquare(n: nat) returns (result: bool)\n  ensures result == (exists k: nat :: k * k == n)\n{\n  var k: nat := 0;\n  result := false;\n  while k * k <= n\n    invariant 0 <= k <= n + 1\n    invariant forall i: nat :: 0 <= i < k ==> i * i != n\n    invariant result == (exists i: nat :: i < k && i * i == n)\n  {\n    if k * k == n {\n      result := true;\n      return;\n    }\n    k := k + 1;\n  }\n  assert forall i: nat :: i < k ==> i * i != n;\n  assert result == (exists i: nat :: i < k && i * i == n);\n}",
            "parents": [
                "da8f0149-6af7-4d22-bb10-ceda00bcd35d"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "43af835e-0c61-497d-aaa7-8e5fab78b557",
            "type": "program",
            "content": "method IsBalancedParentheses(s: seq<char>) returns (balanced: bool)\n  ensures balanced == (CountUnmatched(s) == 0)\n{\n  var unmatched := 0;\n  var i := 0;\n  while i < |s|\n    invariant 0 <= unmatched <= i\n    invariant 0 <= i <= |s|\n    invariant CountUnmatched(s[..i]) == unmatched\n    decreases |s| - i\n  {\n    if s[i] == '(' {\n      unmatched := unmatched + 1;\n    } else if s[i] == ')' {\n      if unmatched == 0 {\n        return false;\n      }\n      unmatched := unmatched - 1;\n    }\n    i := i + 1;\n  }\n  return unmatched == 0;\n}\nfunction CountUnmatched(s: seq<char>): int\n  decreases s\n{\n  if |s| == 0 then\n    0\n  else if s[0] == '(' then\n    1 + CountUnmatched(s[1..])\n  else if s[0] == ')' then\n    -1 + CountUnmatched(s[1..])\n  else\n    CountUnmatched(s[1..])\n}",
            "parents": [
                "8e4ec1fc-6876-4ad8-98dd-24601de53ef7"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "f3733d3d-c7a9-48c2-af1d-e78182ec425d",
            "type": "program",
            "content": "method IsPerfectSquare(n: nat) returns (result: bool)\n  ensures result == (exists k: nat :: k * k == n)\n{\n  var k: nat := 0;\n  result := false;\n  while k * k <= n\n    invariant 0 <= k <= n + 1\n    invariant forall i: nat :: 0 <= i < k ==> i * i != n\n    invariant result == (exists i: nat :: i < k && i * i == n)\n  {\n    if k * k == n {\n      result := true;\n      return;\n    }\n    k := k + 1;\n  }\n  // The second while loop is redundant and should be removed.\n  // The program logic is already complete with the first while loop.\n}",
            "parents": [
                "d5f4b0cb-f254-4b21-a53f-6a4b4b3a00ce"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "28197529-c699-43b8-ad51-ac160faa4544",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var index := -1;\n    var i := 0;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant index == -1 ==> forall k :: 0 <= k < i ==> elements[k].1 != value\n      invariant index != -1 ==> elements[index].1 == value\n      invariant index == -1 ==> elements == old(elements)\n    {\n      if elements[i].1 == value {\n        index := i;\n        break;\n      }\n      i := i + 1;\n    }\n    assert index != -1; // We should have found the element\n\n    // Remove the element\n    elements := elements[..index] + elements[index + 1..];\n\n    // Reinsert with new priority\n    var newElement := (newPriority, value);\n    i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant elements[..index] + elements[index..] == old(elements[..index] + elements[index + 1..])\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Merge(other: PriorityQueue)\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures elements == old(elements) + old(other.elements)\n  {\n    var i := 0;\n    var j := 0;\n    var result: seq<(int, int)> := [];\n    while i < |elements| || j < |other.elements|\n      invariant 0 <= i <= |elements|\n      invariant 0 <= j <= |other.elements|\n      invariant forall k, l :: 0 <= k < l < |result| ==> result[k].0 <= result[l].0\n      invariant result + elements[i..] + other.elements[j..] == old(elements) + old(other.elements)\n    {\n      if i < |elements| && (j >= |other.elements| || elements[i].0 <= other.elements[j].0) {\n        result := result + [elements[i]];\n        i := i + 1;\n      } else {\n        result := result + [other.elements[j]];\n        j := j + 1;\n      }\n    }\n    elements := result;\n  }\n}",
            "parents": [
                "a9f5c9ea-1bd1-4098-89de-f5fa86d9be07"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "66ab765b-ea72-4d7c-822a-01394fcd61ac",
            "type": "program",
            "content": "method DotProduct(a: seq<int>, b: seq<int>) returns (result: int)\n  requires |a| == |b|\n  ensures result == DotProductSpec(a, b)\n{\n  var sum := 0;\n  var i := 0;\n  while i < |a|\n    invariant 0 <= i <= |a|\n    invariant sum == DotProductSpec(a[..i], b[..i])\n    decreases |a| - i\n  {\n    sum := sum + a[i] * b[i];\n    i := i + 1;\n  }\n  result := sum;\n}\n\nfunction DotProductSpec(a: seq<int>, b: seq<int>): int\n  requires |a| == |b|\n{\n  if |a| == 0 then 0 else a[0] * b[0] + DotProductSpec(a[1..], b[1..])\n}",
            "parents": [
                "775329f6-3267-4f17-b9d7-56f5fe0f1959"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "8b90debf-654c-4e55-aa35-2553a5270fe6",
            "type": "program",
            "content": "method QuickSort(a: array<int>, lo: int, hi: int)\n  requires 0 <= lo <= hi <= a.Length\n  modifies a\n  ensures forall i, j :: lo <= i <= j < hi ==> a[i] <= a[j]\n{\n  if lo < hi {\n    var p := Partition(a, lo, hi);\n    QuickSort(a, lo, p);\n    QuickSort(a, p + 1, hi);\n  }\n}\n\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIndex: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIndex < hi\n  ensures forall i :: lo <= i < pivotIndex ==> a[i] <= a[pivotIndex]\n  ensures forall i :: pivotIndex < i < hi ==> a[pivotIndex] <= a[i]\n{\n  var pivot := a[lo];\n  var i := lo;\n  var j := hi;\n  while i < j\n    invariant lo <= i <= j <= hi\n    invariant forall k :: lo <= k < i ==> a[k] <= pivot\n    invariant forall k :: j <= k < hi ==> a[k] >= pivot\n    invariant exists p :: lo <= p < hi && a[p] == pivot\n  {\n    while i < j && a[i] <= pivot\n      invariant lo <= i < hi\n      invariant forall k :: lo <= k < i ==> a[k] <= pivot\n    {\n      i := i + 1;\n    }\n    while i < j && a[j - 1] >= pivot\n      invariant lo < j <= hi\n      invariant forall k :: j <= k < hi ==> a[k] >= pivot\n    {\n      j := j - 1;\n    }\n    if i < j {\n      a[i], a[j - 1] := a[j - 1], a[i];\n    }\n  }\n  pivotIndex := j - 1;\n  a[lo], a[pivotIndex] := a[pivotIndex], a[lo];\n  assert forall i :: lo <= i < pivotIndex ==> a[i] <= a[pivotIndex];\n  assert forall i :: pivotIndex < i < hi ==> a[pivotIndex] <= a[i];\n}",
            "parents": [
                "9148a44b-6079-45fb-b7ba-172a8e0d446e"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "57d32a85-5e5d-45b8-90e4-937bf98d119a",
            "type": "program",
            "content": "class Vector3D {\n  var x: int\n  var y: int\n  var z: int\n  constructor(x: int, y: int, z: int) \n    ensures this.x == x && this.y == y && this.z == z\n  {\n    this.x := x;\n    this.y := y;\n    this.z := z;\n  }\n  method CrossProduct(other: Vector3D) returns (result: Vector3D)\n    ensures result.x == this.y * other.z - this.z * other.y\n    ensures result.y == this.z * other.x - this.x * other.z\n    ensures result.z == this.x * other.y - this.y * other.x\n  {\n    var cx := this.y * other.z - this.z * other.y;\n    var cy := this.z * other.x - this.x * other.z;\n    var cz := this.x * other.y - this.y * other.x;\n    result := new Vector3D(cx, cy, cz);\n  }\n  method DotProduct(other: Vector3D) returns (result: int)\n    ensures result == this.x * other.x + this.y * other.y + this.z * other.z\n  {\n    var sum := 0;\n    var components := [this.x, this.y, this.z];\n    var otherComponents := [other.x, other.y, other.z];\n\n    // Loop over each component to calculate the dot product\n    var i := 0;\n    while i < 3\n      invariant 0 <= i <= 3\n      invariant sum == (if i >= 1 then components[0] * otherComponents[0] else 0)\n                        + (if i >= 2 then components[1] * otherComponents[1] else 0)\n      invariant sum == components[0] * otherComponents[0] + (if i >= 2 then components[1] * otherComponents[1] else 0)\n    {\n      sum := sum + components[i] * otherComponents[i];\n      i := i + 1;\n    }\n\n    result := sum;\n  }\n}",
            "parents": [
                "c8041bff-3eec-4f3b-b067-6bcba8c3d80f"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "484d78c6-113c-42af-b1b4-c7fc5108d3b1",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  \n  constructor() {\n    elements := [];\n  }\n\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n}",
            "parents": [
                "11ce5cd1-4f18-4226-866b-26a89bfdbc08"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "8722fea9-7477-4be9-b5df-bde6c3ec6d1f",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant exists j :: 0 <= j < |elements| ==> elements[j].1 == value\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n    {\n      i := i + 1;\n    }\n    var oldElement := elements[i];\n    elements := elements[..i] + elements[i+1..];\n    var j := 0;\n    while j < |elements| && elements[j].0 <= newPriority\n      invariant 0 <= j <= |elements|\n      invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < j ==> elements[k].0 <= elements[l].0\n    {\n      j := j + 1;\n    }\n    elements := elements[..j] + [(newPriority, value)] + elements[j..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n}",
            "parents": [
                "4648c11c-aef5-40df-bf70-a1496a11c09e"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "cf8b49b7-7138-442c-9f20-7575e9dbad9a",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  \n  constructor() {\n    elements := [];\n  }\n\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n\n  method IsEmpty() returns (isEmpty: bool)\n    ensures isEmpty == (|elements| == 0)\n  {\n    isEmpty := |elements| == 0;\n  }\n}",
            "parents": [
                "27895798-fdf1-4ae6-b0c4-a594e2a527a7"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "080746f7-aa39-43f0-bd33-866d4d8c49d8",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n    ensures elements == old(elements)\n  {\n    var i := 0;\n    var highestPriority := elements[0].0;\n    value := elements[0].1;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= highestPriority\n      invariant exists k :: 0 <= k < i && elements[k].0 == highestPriority && value == elements[k].1\n    {\n      if elements[i].0 < highestPriority {\n        highestPriority := elements[i].0;\n        value := elements[i].1;\n      }\n      i := i + 1;\n    }\n    assert value == elements[0].1;\n  }\n  method IsEmpty() returns (empty: bool)\n    ensures empty <==> |elements| == 0\n  {\n    empty := |elements| == 0;\n  }\n}",
            "parents": [
                "84d83fee-9cca-405a-bcec-912037201669"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "ccb6166f-bc59-489b-82d3-264b2c7d7f30",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(oldPriority: int, value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i] == (oldPriority, value)\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var i := 0;\n    while i < |elements| && elements[i] != (oldPriority, value)\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k] != (oldPriority, value)\n      invariant exists j :: i <= j < |elements| && elements[j] == (oldPriority, value)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + elements[i+1..];\n    var newElement := (newPriority, value);\n    i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n      invariant elements == old(elements[..i]) + old(elements[i..])\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Merge(other: PriorityQueue)\n    modifies this\n    ensures forall e :: e in other.elements ==> e in elements\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var i := 0;\n    while i < |other.elements|\n      invariant 0 <= i <= |other.elements|\n      invariant forall k :: 0 <= k < i ==> other.elements[k] in elements\n      invariant forall m, n :: 0 <= m < n < |elements| ==> elements[m].0 <= elements[n].0\n    {\n      var (priority, value) := other.elements[i];\n      Enqueue(priority, value);\n      i := i + 1;\n    }\n  }\n}",
            "parents": [
                "cdf2bf93-da54-45d5-808e-0671fc85de78"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "1df27871-b52a-4cd7-8e6a-31b3004d1d17",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n}",
            "parents": [
                "c4e4eff1-9447-45da-b9f9-966336b325af"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "8b617161-f2e1-4b1f-a03e-599041b19e1a",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures elements == old(elements)\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n  }\n  method IsEmpty() returns (empty: bool)\n    ensures empty == (|elements| == 0)\n  {\n    var i := 0;\n    empty := true;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant empty == (i == 0)\n    {\n      empty := false;\n      i := i + 1;\n    }\n  }\n  method FindMaxPriority() returns (maxPriority: int)\n    requires |elements| > 0\n    ensures exists i :: 0 <= i < |elements| && elements[i].0 == maxPriority\n    ensures forall i :: 0 <= i < |elements| ==> elements[i].0 <= maxPriority\n  {\n    var i := 0;\n    maxPriority := elements[0].0;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant exists j :: 0 <= j < i && elements[j].0 == maxPriority\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= maxPriority\n    {\n      if elements[i].0 > maxPriority {\n        maxPriority := elements[i].0;\n      }\n      i := i + 1;\n    }\n  }\n}",
            "parents": [
                "d14c7845-3916-426d-bbca-e9c9bcaebc7d"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "6819677d-762f-4841-96c0-8ee8c0023c83",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n    invariant forall k, l :: 0 <= k < l < i && arr[k] < arr[l] ==> lis[l] >= lis[k] + 1\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n      invariant forall k, l :: 0 <= k < l < i && arr[k] < arr[l] ==> lis[l] >= lis[k] + 1\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n}",
            "parents": [
                "b4b761b0-1219-4971-93fd-d084cc0e7de3"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "e7f96eb4-f733-4ffe-a8eb-7f1637baa987",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  \n  constructor() {\n    elements := [];\n  }\n\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n}",
            "parents": [
                "1b5f08f0-4d3d-46bb-8364-a8bf224e24f9"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "4672c406-20ad-413c-87a9-cee77f236560",
            "type": "program",
            "content": "class Node {\n  var value: int\n  var left: Node?\n  var right: Node?\n  constructor(v: int) {\n    value := v;\n    left := null;\n    right := null;\n  }\n}\n\nclass BinarySearchTree {\n  var root: Node?\n\n  method Insert(v: int) \n    modifies this\n    ensures IsBST(root)\n  {\n    root := InsertHelper(root, v);\n  }\n\n  method InsertHelper(n: Node?, v: int) returns (result: Node?)\n    ensures IsBST(result)\n  {\n    if n == null {\n      return new Node(v);\n    }\n    if v < n.value {\n      n.left := InsertHelper(n.left, v);\n      assert IsBST(n.left); // Ensure left subtree is a BST\n    } else if v > n.value {\n      n.right := InsertHelper(n.right, v);\n      assert IsBST(n.right); // Ensure right subtree is a BST\n    }\n    return n;\n  }\n\n  predicate IsBST(n: Node?) \n    reads n\n  {\n    n == null || \n    (IsBST(n.left) && IsBST(n.right) &&\n     (n.left == null || MaxValue(n.left) < n.value) &&\n     (n.right == null || MinValue(n.right) > n.value))\n  }\n\n  function MaxValue(n: Node?): int\n    requires n != null\n    reads n\n  {\n    if n.right == null then n.value else MaxValue(n.right)\n  }\n\n  function MinValue(n: Node?): int\n    requires n != null\n    reads n\n  {\n    if n.left == null then n.value else MinValue(n.left)\n  }\n\n  method Height(n: Node?) returns (h: int)\n    ensures h >= 0\n  {\n    if n == null {\n      h := 0;\n    } else {\n      var leftHeight := Height(n.left);\n      var rightHeight := Height(n.right);\n      h := if leftHeight > rightHeight then leftHeight + 1 else rightHeight + 1;\n    }\n  }\n}",
            "parents": [
                "1d6ceaed-053e-49bd-9d0e-2a434d4a5387"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "39d5e876-d892-43a4-be0c-58889d8e96d7",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n    ensures elements == old(elements)\n  {\n    var i := 0;\n    var highestPriority := elements[0].0;\n    value := elements[0].1;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= highestPriority\n      invariant exists k :: 0 <= k < |elements| && elements[k].0 == highestPriority && value == elements[k].1\n      invariant elements == old(elements)\n    {\n      if elements[i].0 < highestPriority {\n        highestPriority := elements[i].0;\n        value := elements[i].1;\n      }\n      i := i + 1;\n    }\n    assert value == elements[0].1;\n  }\n  method MaxPriority() returns (maxPriority: int)\n    requires |elements| > 0\n    ensures exists i :: 0 <= i < |elements| && elements[i].0 == maxPriority\n    ensures forall i :: 0 <= i < |elements| ==> elements[i].0 <= maxPriority\n    ensures elements == old(elements)\n  {\n    var i := 0;\n    maxPriority := elements[0].0;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant exists j :: 0 <= j < i && elements[j].0 == maxPriority\n      invariant forall j :: 0 <= j < i ==> elements[j].0 <= maxPriority\n      invariant elements == old(elements)\n    {\n      if elements[i].0 > maxPriority {\n        maxPriority := elements[i].0;\n      }\n      i := i + 1;\n    }\n    assert exists j :: 0 <= j < |elements| && elements[j].0 == maxPriority;\n    assert forall j :: 0 <= j < |elements| ==> elements[j].0 <= maxPriority;\n  }\n}",
            "parents": [
                "02c36c95-bc47-411a-ac2a-6417f4b19be3"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "ce0e3a73-9ce7-4a86-87dc-4b41b5fbbc0d",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant exists i: int :: left <= i <= right && arr[i] == arr[k]\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "4bc9e5ca-6194-460b-8c11-365eb0f37499"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "b16fa278-5334-4dfa-8c38-0c34ab5e9daf",
            "type": "program",
            "content": "method IsPerfectSquare(n: nat) returns (result: bool)\n  ensures result <==> exists k: nat :: k * k == n\n{\n  var k: nat := 0;\n  result := false;\n  while k * k <= n\n    invariant 0 <= k <= n + 1\n    invariant forall i: nat :: 0 <= i < k ==> i * i != n\n    invariant result <==> exists i: nat :: 0 <= i < k && i * i == n\n  {\n    if k * k == n {\n      result := true;\n      return;\n    }\n    k := k + 1;\n  }\n  assert forall i: nat :: 0 <= i < k ==> i * i != n;\n}",
            "parents": [
                "f390dd04-9155-464e-b156-a9079e20eb98"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "SUCCESS"
            }
        },
        {
            "id": "8982ad71-0fe7-4130-b2d2-9b5fe25fe089",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method UpdatePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n  {\n    var index := 0;\n    while index < |elements| && elements[index].1 != value\n      invariant 0 <= index <= |elements|\n      invariant forall k :: 0 <= k < index ==> elements[k].1 != value\n      invariant exists i :: 0 <= i < |elements| && elements[i].1 == value\n    {\n      index := index + 1;\n    }\n\n    // Remove the element with the specified value\n    var priority := elements[index].0;\n    elements := elements[..index] + elements[index + 1..];\n\n    // Reinsert the element with the new priority\n    var newElement := (newPriority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n}",
            "parents": [
                "7679c90f-2f7f-4d06-855a-7816583305da"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "b7e2bc2f-eb77-4744-953f-d8435393f055",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method UpdatePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures forall i :: 0 <= i < |elements| ==> elements[i].1 != value || elements[i].0 == newPriority\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n    {\n      i := i + 1;\n    }\n\n    // Remove the element with the old priority\n    elements := elements[..i] + elements[i+1..];\n\n    // Reinsert the element with the new priority\n    var newElement := (newPriority, value);\n    i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n}",
            "parents": [
                "9cb1c3ae-4da1-45fc-809b-4374d83d99c5"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "46b36410-52fd-4966-928e-d987471455f3",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  \n  constructor() {\n    elements := [];\n  }\n\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    var i := 0;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 >= elements[i].0\n      invariant forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0\n    {\n      if elements[i].0 > elements[0].0 {\n        value := elements[i].1;\n        return;\n      }\n      i := i + 1;\n    }\n    value := elements[0].1;\n  }\n}",
            "parents": [
                "a4d15c75-3986-4d86-a258-d9575b39682b"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "00cc1ad0-3b38-460a-922b-f6c79a890a5d",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements[..i] == old(elements[..i])\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method UpdatePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures forall i :: 0 <= i < |elements| ==> elements[i].1 != value || elements[i].0 == newPriority\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n      invariant exists j :: i <= j < |elements| && elements[j].1 == value\n    {\n      i := i + 1;\n    }\n\n    // Remove the element with the old priority\n    elements := elements[..i] + elements[i+1..];\n\n    // Reinsert the element with the new priority\n    var newElement := (newPriority, value);\n    i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n}",
            "parents": [
                "8da96709-43b6-453c-b1a5-03a717b5036b"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "31b41f21-d4dc-4fb5-9af8-cfdc6f0e4819",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> maxLength >= lis[k]\n    invariant forall k, l :: 0 <= k < l < i && arr[k] < arr[l] ==> lis[l] >= l - k + 1\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k, l :: 0 <= k < l < i && arr[k] < arr[l] ==> lis[l] >= l - k + 1\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n}",
            "parents": [
                "8d6e13c1-e3da-4473-93c9-94828c1dad40"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "e44448e8-3ef3-486e-ab38-710d987cec21",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      decreases |elements| - i\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n}",
            "parents": [
                "be6823b5-37e8-4c49-9e27-d36ea3976379"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "655d1fc8-1c41-436e-bf38-cfd9762b8384",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant exists i: int :: left <= i <= right && arr[i] == arr[k]\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "b5482a32-46b3-41bb-88dd-450600e1bcd9"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "fc27f137-5945-41ce-9515-57ebaaf6d72f",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures elements == old(elements)\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n  }\n  method UpdatePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var index := -1;\n    var i := 0;\n    // Find the index of the element with the given value\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant index == -1 ==> forall k :: 0 <= k < i ==> elements[k].1 != value\n      invariant index != -1 ==> 0 <= index < |elements| && elements[index].1 == value\n    {\n      if elements[i].1 == value {\n        index := i;\n        break;\n      }\n      i := i + 1;\n    }\n    \n    // Remove the element at the found index\n    var element := elements[index];\n    elements := elements[..index] + elements[index + 1..];\n\n    // Re-insert the element with the new priority\n    var newElement := (newPriority, value);\n    i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n      invariant elements[..index] + elements[index + 1..] == old(elements[..index] + elements[index + 1..])\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n}",
            "parents": [
                "591b5fe3-7521-4743-a960-e11e7013292c"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "ccdfa0ae-d4db-45dd-bdd4-610a85f69754",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant exists i: int :: left <= i <= right && \n              (forall j: int :: left <= j < i ==> arr[j] <= arr[i]) &&\n              (forall j: int :: i < j <= right ==> arr[j] >= arr[i])\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "32b9e83c-8f5a-49b0-96c0-cb2fcd3e4e10"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "1c897b36-bb89-453e-bfd6-28d1c0fa2995",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      decreases |elements| - i\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var index: int := 0;\n    // Find the element with the specified value\n    while index < |elements| && elements[index].1 != value\n      invariant 0 <= index <= |elements|\n      invariant forall k :: 0 <= k < index ==> elements[k].1 != value\n      decreases |elements| - index\n    {\n      index := index + 1;\n    }\n    // Update the priority of the found element\n    elements := elements[..index] + [(newPriority, value)] + elements[index+1..];\n    \n    // Reorder the queue to maintain the priority order\n    var i := 0;\n    var newElement := (newPriority, value);\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      decreases |elements| - i\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i+1..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n}",
            "parents": [
                "8aec9e6d-d4cb-40c6-b508-2c4db9f7cd08"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "37648709-1dd7-4933-bd94-9fcb0e65a475",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant exists i: int :: left <= i <= right && \n              (forall j: int :: left <= j < i ==> arr[j] <= arr[i]) &&\n              (forall j: int :: i < j <= right ==> arr[j] >= arr[i])\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "a917cae4-7a3e-40aa-83f9-7186fb36c08f"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "61af7580-e820-4d74-a5d1-ba3cb330e463",
            "type": "program",
            "content": "method DotProduct(a: seq<int>, b: seq<int>) returns (result: int)\n  requires |a| == |b|\n  ensures result == DotProductSpec(a, b)\n{\n  var sum := 0;\n  var i := 0;\n  while i < |a|\n    invariant 0 <= i <= |a|\n    invariant sum == DotProductSpec(a[..i], b[..i])\n    decreases |a| - i\n  {\n    sum := sum + a[i] * b[i];\n    i := i + 1;\n  }\n  result := sum;\n}\n\nfunction DotProductSpec(a: seq<int>, b: seq<int>): int\n  requires |a| == |b|\n{\n  if |a| == 0 then 0 else a[0] * b[0] + DotProductSpec(a[1..], b[1..])\n}",
            "parents": [
                "ed5524ab-12af-4015-94f6-05b21d0b06b5"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "c33bdfa5-2a06-4477-8b69-036869b48b76",
            "type": "program",
            "content": "method QuickSort(a: array<int>, lo: int, hi: int)\n  requires 0 <= lo <= hi <= a.Length\n  modifies a\n  ensures forall i, j :: lo <= i <= j < hi ==> a[i] <= a[j]\n{\n  if lo < hi {\n    var p := Partition(a, lo, hi);\n    QuickSort(a, lo, p);\n    QuickSort(a, p + 1, hi);\n  }\n}\n\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIndex: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIndex < hi\n  ensures forall i :: lo <= i < pivotIndex ==> a[i] <= a[pivotIndex]\n  ensures forall i :: pivotIndex < i < hi ==> a[pivotIndex] <= a[i]\n{\n  var pivot := a[lo];\n  var i := lo;\n  var j := hi;\n  while i < j\n    invariant lo <= i <= j <= hi\n    invariant forall k :: lo <= k < i ==> a[k] <= pivot\n    invariant forall k :: j <= k < hi ==> a[k] >= pivot\n    invariant exists p :: lo <= p < hi && a[p] == pivot\n  {\n    while i < j && a[i] <= pivot\n      invariant lo <= i < hi\n      invariant forall k :: lo <= k < i ==> a[k] <= pivot\n    {\n      i := i + 1;\n    }\n    while i < j && a[j - 1] >= pivot\n      invariant lo < j <= hi\n      invariant forall k :: j <= k < hi ==> a[k] >= pivot\n    {\n      j := j - 1;\n    }\n    if i < j {\n      a[i], a[j - 1] := a[j - 1], a[i];\n    }\n  }\n  pivotIndex := j - 1;\n  a[lo], a[pivotIndex] := a[pivotIndex], a[lo];\n  assert forall k :: lo <= k < pivotIndex ==> a[k] <= a[pivotIndex];\n  assert forall k :: pivotIndex < k < hi ==> a[pivotIndex] <= a[k];\n}",
            "parents": [
                "7c9fc37e-728f-4760-ad6d-a39ce7ace19f"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "6eca80d5-1fc1-40e7-833b-7e065d8cebf4",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant exists i: int :: left <= i <= right && arr[i] == arr[k]\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "5930c594-2f01-493d-af2c-91db85338709"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "d90808c5-8a1b-42d1-a729-199a05e03f83",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n\n  constructor() {\n    elements := [];\n  }\n\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n}",
            "parents": [
                "1a3259b2-7905-4744-befc-ce6414144ded"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "53b406ab-d633-4676-afd0-f0ade76e20d0",
            "type": "program",
            "content": "method IsValidStackSequence(operations: seq<string>) returns (isValid: bool)\n  ensures isValid == (forall i :: 0 <= i < |operations| ==> operations[i] == \"push\" || operations[i] == \"pop\")\n{\n  var stackSize := 0;\n  isValid := true;\n  // Loop through each operation in the sequence\n  for i := 0 to |operations| \n    invariant 0 <= stackSize\n    invariant 0 <= i <= |operations|\n    invariant isValid ==> (forall j :: 0 <= j < i ==> operations[j] == \"push\" || operations[j] == \"pop\")\n    invariant isValid ==> (forall j :: 0 <= j < i ==> stackSize >= 0)\n  {\n    if operations[i] == \"push\" {\n      stackSize := stackSize + 1;\n    } else if operations[i] == \"pop\" {\n      if stackSize == 0 {\n        isValid := false;\n        return;\n      }\n      stackSize := stackSize - 1;\n    } else {\n      isValid := false;\n      return;\n    }\n  }\n  // Ensure that all operations were valid if we reach this point\n  assert isValid ==> (forall j :: 0 <= j < |operations| ==> operations[j] == \"push\" || operations[j] == \"pop\");\n}",
            "parents": [
                "8b0b7b8a-6bdc-4b26-93f6-e8f47d872f78"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "2d3726b9-c763-4268-99a4-f89603f6d9c0",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant exists i: int :: left <= i <= right && \n              (forall j: int :: left <= j < i ==> arr[j] <= arr[i]) &&\n              (forall j: int :: i < j <= right ==> arr[j] >= arr[i])\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "d69266e4-437f-4735-82c6-bfecd54e0e88"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "48344a38-3b8b-45a4-a90f-96e301004e0f",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant forall k, l :: 0 <= k < l < |elements| && l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method IsEmpty() returns (empty: bool)\n    ensures empty == (|elements| == 0)\n  {\n    empty := |elements| == 0;\n  }\n}",
            "parents": [
                "b0eee263-eb97-469c-a1ad-952757a08cf1"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "ca648669-4d60-4550-9952-523159edbd62",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method IsEmpty() returns (empty: bool)\n    ensures empty == (|elements| == 0)\n  {\n    var i := 0;\n    empty := true;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant empty == (i == 0)\n    {\n      empty := false;\n      i := i + 1;\n    }\n  }\n}",
            "parents": [
                "97060160-b406-4839-8191-a29ff71a9361"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "fdd3179f-ba99-498f-8d33-38dec9b7d93c",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> lis[k] == 1\n    invariant maxLength == 1\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  length := maxLength;\n}",
            "parents": [
                "4dbaa72f-0b25-4895-8957-ae1c4cc875f9"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "704cb1d3-f86f-4e81-8864-b20ff3be87b2",
            "type": "program",
            "content": "class Graph {\n  var adjacencyMatrix: array2<bool>;\n\n  constructor(n: nat) \n    requires n > 0\n    ensures adjacencyMatrix.Length0 == n && adjacencyMatrix.Length1 == n\n    ensures forall i, j :: 0 <= i < n && 0 <= j < n ==> !adjacencyMatrix[i, j]\n  {\n    adjacencyMatrix := new bool[n, n];\n  }\n\n  method AddEdge(u: nat, v: nat)\n    requires 0 <= u < adjacencyMatrix.Length0\n    requires 0 <= v < adjacencyMatrix.Length1\n    modifies adjacencyMatrix\n    ensures adjacencyMatrix[u, v] && adjacencyMatrix[v, u]\n  {\n    adjacencyMatrix[u, v] := true;\n    adjacencyMatrix[v, u] := true;\n  }\n\n  method IsVertexCover(cover: set<nat>) returns (isCover: bool)\n    requires cover <= set i | 0 <= i < adjacencyMatrix.Length0\n    ensures isCover == (forall u, v :: 0 <= u < adjacencyMatrix.Length0 && 0 <= v < adjacencyMatrix.Length1 && adjacencyMatrix[u, v] ==> u in cover || v in cover)\n  {\n    isCover := true;\n    var n := adjacencyMatrix.Length0;\n    for u := 0 to n - 1 \n      invariant 0 <= u <= n\n      invariant isCover == (forall i, j :: 0 <= i < u && 0 <= j < n && adjacencyMatrix[i, j] ==> i in cover || j in cover)\n    {\n      for v := 0 to n - 1 \n        invariant 0 <= v <= n\n        invariant isCover == (forall i, j :: 0 <= i < u && 0 <= j < n && adjacencyMatrix[i, j] ==> i in cover || j in cover) &&\n                            (forall j :: 0 <= j < v && adjacencyMatrix[u, j] ==> u in cover || j in cover)\n      {\n        if adjacencyMatrix[u, v] && !(u in cover || v in cover) {\n          isCover := false;\n          return;\n        }\n      }\n    }\n  }\n}",
            "parents": [
                "4cdc8acf-bd53-4262-9f62-d262ebc0d72c"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "SUCCESS"
            }
        },
        {
            "id": "4047da5f-7ce2-4b81-aa86-b2381b5e3651",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures elements == old(elements)\n    ensures value == elements[0].1\n  {\n    var highestPriority := elements[0].0;\n    var highestValue := elements[0].1;\n    var i := 1;\n    while i < |elements|\n      invariant 1 <= i <= |elements|\n      invariant highestPriority == elements[0].0\n      invariant highestValue == elements[0].1\n      invariant forall k :: 0 <= k < i ==> elements[k].0 >= highestPriority\n    {\n      if elements[i].0 < highestPriority {\n        highestPriority := elements[i].0;\n        highestValue := elements[i].1;\n      }\n      i := i + 1;\n    }\n    value := highestValue;\n  }\n  method ChangePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n    {\n      i := i + 1;\n    }\n    // Remove the element with the specified value\n    elements := elements[..i] + elements[i+1..];\n    \n    // Re-insert the element with the new priority\n    var newElement := (newPriority, value);\n    i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n}",
            "parents": [
                "acc10745-d709-4a13-91d2-bd5dc8b4da10"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "2f9a83c2-94e0-443e-83b0-24a39d860272",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n      invariant exists j :: i <= j < |elements| && elements[j].1 == value\n    {\n      i := i + 1;\n    }\n    var updatedElement := (newPriority, value);\n    elements := elements[..i] + elements[i+1..];\n    \n    // Re-insert the updated element\n    var j := 0;\n    while j < |elements| && elements[j].0 <= newPriority\n      invariant 0 <= j <= |elements|\n      invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n    {\n      j := j + 1;\n    }\n    elements := elements[..j] + [updatedElement] + elements[j..];\n  }\n}",
            "parents": [
                "155a201f-9ae9-44b2-bf7e-ed15c1c215f8"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "24f134dd-69a7-4584-977c-092a02f176ee",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures elements == old(elements)\n    ensures value == elements[0].1\n  {\n    var highestPriority := elements[0].0;\n    var highestValue := elements[0].1;\n    var i := 1;\n    while i < |elements|\n      invariant 1 <= i <= |elements|\n      invariant highestPriority == elements[0].0\n      invariant highestValue == elements[0].1\n      invariant forall k :: 0 <= k < i ==> elements[k].0 >= highestPriority\n    {\n      if elements[i].0 < highestPriority {\n        highestPriority := elements[i].0;\n        highestValue := elements[i].1;\n      }\n      i := i + 1;\n    }\n    value := highestValue;\n  }\n}",
            "parents": [
                "bd156f4f-816e-440e-9293-1f374647163a"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "594cc228-2844-413e-a0fb-0d4b0381f598",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n    ensures elements == old(elements)\n  {\n    var i := 0;\n    var highestPriority := elements[0].0;\n    value := elements[0].1;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= highestPriority\n      invariant exists k :: 0 <= k < |elements| && elements[k].0 == highestPriority && value == elements[k].1\n      invariant forall k :: 0 <= k < |elements| ==> elements[k].0 >= highestPriority\n    {\n      if elements[i].0 < highestPriority {\n        highestPriority := elements[i].0;\n        value := elements[i].1;\n      }\n      i := i + 1;\n    }\n    assert value == elements[0].1;\n  }\n  method IsEmpty() returns (empty: bool)\n    ensures empty <==> |elements| == 0\n  {\n    empty := |elements| == 0;\n  }\n}",
            "parents": [
                "17f84771-8855-421e-93bf-901975a82fc9"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "278d6f91-8c90-461b-9a81-b0aa78059b22",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n    invariant forall k, j :: 0 <= k < j < i && arr[k] < arr[j] ==> lis[j] >= lis[k] + 1\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n      invariant forall k, l :: 0 <= k < l < i && arr[k] < arr[l] ==> lis[l] >= lis[k] + 1\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n}",
            "parents": [
                "529870c8-8186-42dd-98a5-98af9652ac99"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "0aa5a93a-43a3-483c-8026-214b68ba960d",
            "type": "program",
            "content": "method BinarySearch(a: array<int>, target: int) returns (index: int)\n  requires a != null && a.Length > 0\n  requires forall i: int, j: int :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures 0 <= index < a.Length ==> a[index] == target\n  ensures index == -1 ==> forall i: int :: 0 <= i < a.Length ==> a[i] != target\n{\n  var low := 0;\n  var high := a.Length - 1;\n  index := -1;\n  while low <= high\n    invariant 0 <= low <= a.Length\n    invariant -1 <= high < a.Length\n    invariant forall i: int :: 0 <= i < low ==> a[i] < target\n    invariant forall i: int :: high < i < a.Length ==> a[i] > target\n  {\n    var mid := low + (high - low) / 2;\n    if a[mid] == target {\n      index := mid;\n      return;\n    } else if a[mid] < target {\n      low := mid + 1;\n    } else {\n      high := mid - 1;\n    }\n  }\n}",
            "parents": [
                "idea-0"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "SUCCESS"
            }
        },
        {
            "id": "d6b87501-4b62-4283-af0a-b526a34040e7",
            "type": "program",
            "content": "method CountInversions(arr: array<int>) returns (inversions: int)\n  requires arr != null\n  ensures 0 <= inversions <= arr.Length * (arr.Length - 1) / 2\n  ensures forall i, j :: 0 <= i < j < arr.Length ==> (arr[i] > arr[j] ==> inversions >= 1)\n{\n  inversions := 0;\n  var n := arr.Length;\n  // Loop through each pair of elements in the array\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant 0 <= inversions <= i * (i - 1) / 2\n    {\n      var j := i + 1;\n      while j < n\n        invariant i < j <= n\n        invariant 0 <= inversions <= i * (i - 1) / 2 + (j - i)\n        {\n          if arr[i] > arr[j] {\n            inversions := inversions + 1;\n          }\n          j := j + 1;\n        }\n      i := i + 1;\n    }\n}",
            "parents": [
                "idea-136"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "b8a56f8c-d998-4813-adac-f7a2516c868b",
            "type": "program",
            "content": "method IsBalancedParentheses(s: seq<char>) returns (balanced: bool)\n  ensures balanced == (CountBalanced(s) == 0)\n{\n  var count := 0;\n  balanced := true;\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant 0 <= count\n    invariant balanced == (forall j :: 0 <= j < i ==> CountBalanced(s[..j]) == 0)\n  {\n    if s[i] == '(' {\n      count := count + 1;\n    } else if s[i] == ')' {\n      if count == 0 {\n        balanced := false;\n        return;\n      }\n      count := count - 1;\n    }\n    i := i + 1;\n  }\n  balanced := count == 0;\n}\nfunction CountBalanced(s: seq<char>): int\n  decreases s\n{\n  if |s| == 0 then 0\n  else if s[0] == '(' then 1 + CountBalanced(s[1..])\n  else if s[0] == ')' then -1 + CountBalanced(s[1..])\n  else CountBalanced(s[1..])\n}",
            "parents": [
                "idea-17"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "70072bce-1d3b-4692-89fe-99d402e52853",
            "type": "program",
            "content": "class Polygon {\n  var vertices: seq<(real, real)>\n  constructor (v: seq<(real, real)>) {\n    vertices := v;\n  }\n  method Centroid() returns (cx: real, cy: real)\n    requires |vertices| >= 3\n    ensures 0.0 <= cx <= 1.0 && 0.0 <= cy <= 1.0\n  {\n    var signedArea: real := 0.0;\n    var Cx: real := 0.0;\n    var Cy: real := 0.0;\n    var n := |vertices|;\n    var i: int := 0;\n    while i < n\n      invariant 0 <= i <= n\n      invariant signedArea == 0.5 * (Cx + Cy)\n    {\n      var (x0, y0) := vertices[i];\n      var (x1, y1) := vertices[(i + 1) % n];\n      var a := x0 * y1 - x1 * y0;\n      signedArea := signedArea + a;\n      Cx := Cx + (x0 + x1) * a;\n      Cy := Cy + (y0 + y1) * a;\n      i := i + 1;\n    }\n    signedArea := signedArea / 2.0;\n    cx := Cx / (6.0 * signedArea);\n    cy := Cy / (6.0 * signedArea);\n  }\n}",
            "parents": [
                "idea-158"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "a0041c92-fdce-47bc-9f64-56031d08d305",
            "type": "program",
            "content": "method LongestPalindromeSubstring(s: seq<char>) returns (longest: seq<char>)\n  ensures forall i, j :: 0 <= i <= j < |s| && IsPalindrome(s[i..j+1]) ==> |longest| >= |s[i..j+1]|\n  ensures IsPalindrome(longest)\n{\n  var maxLen := 0;\n  var start := 0;\n  for i := 0 to |s| {\n    var l := i;\n    var r := i;\n    while l >= 0 && r < |s| && s[l] == s[r]\n      invariant 0 <= l <= i\n      invariant i <= r < |s|\n      invariant IsPalindrome(s[l..r+1])\n    {\n      if r - l + 1 > maxLen {\n        maxLen := r - l + 1;\n        start := l;\n      }\n      l := l - 1;\n      r := r + 1;\n    }\n    l := i;\n    r := i + 1;\n    while l >= 0 && r < |s| && s[l] == s[r]\n      invariant 0 <= l <= i\n      invariant i < r < |s|\n      invariant IsPalindrome(s[l..r+1])\n    {\n      if r - l + 1 > maxLen {\n        maxLen := r - l + 1;\n        start := l;\n      }\n      l := l - 1;\n      r := r + 1;\n    }\n  }\n  longest := s[start..start + maxLen];\n}\npredicate IsPalindrome(s: seq<char>) \n  decreases |s|\n{\n  forall i :: 0 <= i < |s| / 2 ==> s[i] == s[|s| - i - 1]\n}",
            "parents": [
                "idea-79"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "cde8465a-daa5-4b65-998e-075f6de24315",
            "type": "program",
            "content": "class Grid {\n  var cells: array<bool>\n  constructor(n: nat) \n    requires n > 0\n  {\n    cells := new bool[n * n];\n  }\n  method SpreadInfection()\n    modifies cells\n    ensures forall i: int :: 0 <= i < cells.Length ==> cells[i] == true\n  {\n    var n := cells.Length;\n    var i: int := 0;\n    while i < n\n      invariant 0 <= i <= n\n      invariant forall j: int :: 0 <= j < i ==> cells[j] == true\n    {\n      cells[i] := true;\n      i := i + 1;\n    }\n  }\n}",
            "parents": [
                "idea-174"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "SUCCESS"
            }
        },
        {
            "id": "7a82a740-8563-4c33-ace4-e7c8e205f153",
            "type": "program",
            "content": "// A simple finite state machine (FSM) for recognizing the pattern \"ab\"\ndatatype State = Start | A | Accept\n// Transition function for the FSM\nfunction transition(s: State, c: char): State\n  decreases s, c\n{\n  match s\n    case Start => if c == 'a' then A else Start\n    case A => if c == 'b' then Accept else Start\n    case Accept => Accept\n}\n// Function to check if a string is accepted by the FSM\nmethod IsPatternRecognized(input: seq<char>) returns (recognized: bool)\n  ensures recognized == (|input| >= 2 && input[|input|-2] == 'a' && input[|input|-1] == 'b')\n{\n  var currentState := Start;\n  var i := 0;\n  while i < |input|\n    invariant 0 <= i <= |input|\n    invariant currentState == Start || currentState == A || currentState == Accept\n  {\n    currentState := transition(currentState, input[i]);\n    i := i + 1;\n  }\n  recognized := currentState == Accept;\n}",
            "parents": [
                "idea-153"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "a2921e1b-f37c-4f0f-b5c2-111dd72ec938",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (result: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == result && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < result ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == result ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  var pivotIndex: int;\n  while left <= right\n    invariant 0 <= left <= arr.Length\n    invariant -1 <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant left <= right + 1\n  {\n    pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return -1; // This line should never be reached due to the loop invariant\n}\nmethod Partition(arr: array<int>, low: int, high: int) returns (pivotIndex: int)\n  requires 0 <= low <= high < arr.Length\n  ensures low <= pivotIndex <= high\n  ensures forall i: int :: low <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= high ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[high];\n  var i := low - 1;\n  for j := low to high - 1\n    invariant low - 1 <= i < high\n    invariant low <= j <= high\n    invariant forall m: int :: low <= m <= i ==> arr[m] <= pivot\n    invariant forall n: int :: i < n < j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      i := i + 1;\n      arr[i], arr[j] := arr[j], arr[i];\n    }\n  }\n  arr[i + 1], arr[high] := arr[high], arr[i + 1];\n  return i + 1;\n}",
            "parents": [
                "idea-142"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "91866c72-72d9-4467-9c1f-896541c0119c",
            "type": "program",
            "content": "class Rectangle {\n  var x1: int;\n  var y1: int;\n  var x2: int;\n  var y2: int;\n  constructor(x1: int, y1: int, x2: int, y2: int)\n    requires x1 <= x2 && y1 <= y2\n  {\n    this.x1 := x1;\n    this.y1 := y1;\n    this.x2 := x2;\n    this.y2 := y2;\n  }\n  method IntersectionArea(other: Rectangle) returns (area: int)\n    ensures area >= 0\n  {\n    var interLeft := if this.x1 > other.x1 then this.x1 else other.x1;\n    var interRight := if this.x2 < other.x2 then this.x2 else other.x2;\n    var interTop := if this.y1 > other.y1 then this.y1 else other.y1;\n    var interBottom := if this.y2 < other.y2 then this.y2 else other.y2;\n    if interLeft < interRight && interTop < interBottom {\n      area := (interRight - interLeft) * (interBottom - interTop);\n    } else {\n      area := 0;\n    }\n  }\n}",
            "parents": [
                "idea-102"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "SUCCESS"
            }
        },
        {
            "id": "2bb7ce42-ec35-4210-a6a6-1c991fa1f87a",
            "type": "program",
            "content": "method Lucas(n: nat) returns (l: nat)\n  requires n >= 0\n  ensures l == LucasNumber(n)\n{\n  if n == 0 {\n    l := 2;\n  } else if n == 1 {\n    l := 1;\n  } else {\n    var a := 2;\n    var b := 1;\n    var i := 2;\n    while i <= n\n      invariant 2 <= i <= n + 1\n      invariant LucasNumber(i - 1) == b\n      invariant LucasNumber(i - 2) == a\n    {\n      var temp := b;\n      b := a + b;\n      a := temp;\n      i := i + 1;\n    }\n    l := b;\n  }\n}\nfunction LucasNumber(n: nat): nat\n  decreases n\n{\n  if n == 0 then 2\n  else if n == 1 then 1\n  else LucasNumber(n - 1) + LucasNumber(n - 2)\n}",
            "parents": [
                "idea-166"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "SUCCESS"
            }
        },
        {
            "id": "7a1d4a9f-771d-49ed-b488-6b0d095b59f1",
            "type": "program",
            "content": "method CoinChange(coins: seq<int>, amount: int) returns (minCoins: int)\n  requires amount >= 0\n  requires forall c :: c in coins ==> c > 0\n  ensures minCoins >= 0\n  ensures minCoins == -1 <==> (forall c :: c in coins ==> c > amount)\n{\n  var dp := new int[amount + 1];\n  dp[0] := 0;\n  var i := 1;\n  while i <= amount\n    invariant 0 <= i <= amount + 1\n    invariant dp[0] == 0\n    invariant forall j :: 1 <= j < i ==> dp[j] >= 0\n  {\n    dp[i] := amount + 1; // Initialize with a large number\n    var j := 0;\n    while j < |coins|\n      invariant 0 <= j <= |coins|\n      invariant dp[i] >= 0\n    {\n      if i >= coins[j] {\n        dp[i] := if dp[i] < dp[i - coins[j]] + 1 then dp[i] else dp[i - coins[j]] + 1;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  minCoins := if dp[amount] > amount then -1 else dp[amount];\n}",
            "parents": [
                "idea-65"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "42cb7371-b1cd-4858-a9e8-c718dc95861a",
            "type": "program",
            "content": "class Stack<T> {\n  var items: seq<T>\n  constructor() {\n    items := [];\n  }\n  method Push(x: T) \n    modifies this\n  {\n    items := items + [x];\n  }\n  method Pop() returns (x: T)\n    requires |items| > 0\n    modifies this\n    ensures x == old(items[|items| - 1])\n    ensures items == old(items[..|items| - 1])\n  {\n    x := items[|items| - 1];\n    items := items[..|items| - 1];\n  }\n  method IsEmpty() returns (b: bool)\n    ensures b == (|items| == 0)\n  {\n    b := |items| == 0;\n  }\n}",
            "parents": [
                "idea-2"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "SUCCESS"
            }
        },
        {
            "id": "1be207f9-5ec4-47ae-afbd-a26a05742a18",
            "type": "program",
            "content": "method QuickSort(a: array<int>, low: int, high: int)\n  requires 0 <= low <= high <= a.Length\n  modifies a\n  ensures forall i, j :: low <= i < j <= high ==> a[i] <= a[j]\n{\n  if low < high {\n    var p := Partition(a, low, high);\n    QuickSort(a, low, p - 1);\n    QuickSort(a, p + 1, high);\n  }\n}\nmethod Partition(a: array<int>, low: int, high: int) returns (pivotIndex: int)\n  requires 0 <= low < high <= a.Length\n  modifies a\n  ensures low <= pivotIndex < high\n  ensures forall i :: low <= i < pivotIndex ==> a[i] <= a[pivotIndex]\n  ensures forall j :: pivotIndex < j <= high ==> a[pivotIndex] <= a[j]\n{\n  var pivot := a[high - 1];\n  var i := low;\n  var j := low;\n  while j < high - 1\n    invariant low <= i <= j < high\n    invariant forall k :: low <= k < i ==> a[k] <= pivot\n    invariant forall l :: i <= l < j ==> a[l] > pivot\n  {\n    if a[j] <= pivot {\n      a[i], a[j] := a[j], a[i];\n      i := i + 1;\n    }\n    j := j + 1;\n  }\n  a[i], a[high - 1] := a[high - 1], a[i];\n  return i;\n}",
            "parents": [
                "idea-28"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "78c51c59-014d-409f-9864-efe831df117f",
            "type": "program",
            "content": "// A simple program to verify that a given configuration of queens on a chessboard is valid\n// i.e., no two queens attack each other.\nmethod IsValidQueenConfiguration(board: seq<seq<bool>>) returns (valid: bool)\n  requires |board| == 8 && forall row :: 0 <= row < |board| ==> |board[row]| == 8\n  ensures valid == true <==> (forall i, j, k, l :: 0 <= i < 8 && 0 <= j < 8 && 0 <= k < 8 && 0 <= l < 8 && board[i][j] && board[k][l] ==> (i == k && j == l) || (i != k && j != l && i - j != k - l && i + j != k + l))\n{\n  valid := true;\n  var n := 8;\n  // Check each pair of queens to ensure they do not attack each other\n  for i := 0 to n - 1 {\n    for j := 0 to n - 1 {\n      if board[i][j] {\n        for k := 0 to n - 1 {\n          for l := 0 to n - 1 {\n            if board[k][l] && (i != k || j != l) {\n              // Check if they are in the same row, column, or diagonal\n              if i == k || j == l || i - j == k - l || i + j == k + l {\n                valid := false;\n                return;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  for i := 0 to n - 1\n    invariant 0 <= i <= n\n    invariant valid == true ==> (forall x, y :: 0 <= x < i && 0 <= y < n && board[x][y] ==> (forall a, b :: 0 <= a < n && 0 <= b < n && board[a][b] && (x != a || y != b) ==> x != a && y != b && x - y != a - b && x + y != a + b))\n  {\n    for j := 0 to n - 1\n      invariant 0 <= j <= n\n      invariant valid == true ==> (forall x, y :: 0 <= x <= i && 0 <= y < j && board[x][y] ==> (forall a, b :: 0 <= a < n && 0 <= b < n && board[a][b] && (x != a || y != b) ==> x != a && y != b && x - y != a - b && x + y != a + b))\n    {\n      if board[i][j] {\n        for k := 0 to n - 1\n          invariant 0 <= k <= n\n          invariant valid == true ==> (forall x, y :: 0 <= x <= i && 0 <= y <= j && board[x][y] ==> (forall a, b :: 0 <= a < k && 0 <= b < n && board[a][b] && (x != a || y != b) ==> x != a && y != b && x - y != a - b && x + y != a + b))\n        {\n          for l := 0 to n - 1\n            invariant 0 <= l <= n\n            invariant valid == true ==> (forall x, y :: 0 <= x <= i && 0 <= y <= j && board[x][y] ==> (forall a, b :: 0 <= a <= k && 0 <= b < l && board[a][b] && (x != a || y != b) ==> x != a && y != b && x - y != a - b && x + y != a + b))\n          {\n            if board[k][l] && (i != k || j != l) {\n              // Check if they are in the same row, column, or diagonal\n              if i == k || j == l || i - j == k - l || i + j == k + l {\n                valid := false;\n                return;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\nfor i := 0 to n - 1\n  invariant 0 <= i <= n\n  invariant valid == true ==> (forall x, y :: 0 <= x < i && 0 <= y < n && board[x][y] ==> (forall a, b :: 0 <= a < n && 0 <= b < n && board[a][b] && (x != a || y != b) ==> x != a && y != b && x - y != a - b && x + y != a + b))\n  invariant forall x, y :: 0 <= x < i && 0 <= y < n ==> (board[x][y] ==> (forall a :: 0 <= a < n ==> !board[a][y]))\n  invariant forall x, y :: 0 <= x < i && 0 <= y < n ==> (board[x][y] ==> (forall b :: 0 <= b < n ==> !board[x][b]))\n{\n  for j := 0 to n - 1\n    invariant 0 <= j <= n\n    invariant valid == true ==> (forall x, y :: 0 <= x <= i && 0 <= y < j && board[x][y] ==> (forall a, b :: 0 <= a < n && 0 <= b < n && board[a][b] && (x != a || y != b) ==> x != a && y != b && x - y != a - b && x + y != a + b))\n    invariant forall x, y :: 0 <= x <= i && 0 <= y < j ==> (board[x][y] ==> (forall a :: 0 <= a < n ==> !board[a][y]))\n    invariant forall x, y :: 0 <= x <= i && 0 <= y < j ==> (board[x][y] ==> (forall b :: 0 <= b < n ==> !board[x][b]))\n  {\n    if board[i][j] {\n      for k := 0 to n - 1\n        invariant 0 <= k <= n\n        invariant valid == true ==> (forall x, y :: 0 <= x <= i && 0 <= y <= j && board[x][y] ==> (forall a, b :: 0 <= a < k && 0 <= b < n && board[a][b] && (x != a || y != b) ==> x != a && y != b && x - y != a - b && x + y != a + b))\n        invariant forall x, y :: 0 <= x <= i && 0 <= y <= j ==> (board[x][y] ==> (forall a :: 0 <= a < k ==> !board[a][y]))\n        invariant forall x, y :: 0 <= x <= i && 0 <= y <= j ==> (board[x][y] ==> (forall b :: 0 <= b < k ==> !board[x][b]))\n      {\n        for l := 0 to n - 1\n          invariant 0 <= l <= n\n          invariant valid == true ==> (forall x, y :: 0 <= x <= i && 0 <= y <= j && board[x][y] ==> (forall a, b :: 0 <= a <= k && 0 <= b < l && board[a][b] && (x != a || y != b) ==> x != a && y != b && x - y != a - b && x + y != a + b))\n          invariant forall x, y :: 0 <= x <= i && 0 <= y <= j ==> (board[x][y] ==> (forall a :: 0 <= a <= k ==> !board[a][y]))\n          invariant forall x, y :: 0 <= x <= i && 0 <= y <= j ==> (board[x][y] ==> (forall b :: 0 <= b < l ==> !board[x][b]))\n        {\n          if board[k][l] && (i != k || j != l) {\n            // Check if they are in the same row, column, or diagonal\n            if i == k || j == l || i - j == k - l || i + j == k + l {\n              valid := false;\n              return;\n            }\n          }\n        }\n      }\n    }\n  }\n}\n}",
            "parents": [
                "bbe8dea4-a7fd-41c0-a9a1-84093df79fe4"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "c959ee71-3228-4c16-a8eb-d49a50c09772",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method UpdatePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures forall i :: 0 <= i < |elements| ==> elements[i].1 != value || elements[i].0 == newPriority\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n      invariant exists j :: i <= j < |elements| && elements[j].1 == value\n    {\n      i := i + 1;\n    }\n\n    // Remove the element with the old priority\n    elements := elements[..i] + elements[i+1..];\n\n    // Reinsert the element with the new priority\n    var newElement := (newPriority, value);\n    i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\nmethod RemoveByValue(value: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures forall i :: 0 <= i < |elements| ==> elements[i].1 != value\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n    invariant exists j :: i <= j < |elements| && elements[j].1 == value\n  {\n    i := i + 1;\n  }\n\n  // Remove the element with the specified value\n  elements := elements[..i] + elements[i+1..];\n}\n}",
            "parents": [
                "8da96709-43b6-453c-b1a5-03a717b5036b"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "f89bb432-d5c9-4e7d-97c0-83c449e84000",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i - 1 ==> lis[k] <= lis[k + 1]\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k :: 0 <= k < i - 1 ==> lis[k] <= lis[k + 1]\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n  return maxLength;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n}",
            "parents": [
                "06ba2f07-fbf7-430a-a181-3deb6d20bbe3"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "75f1c61b-5971-4d07-a561-0934922caf5f",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\nmethod ChangePriority(oldPriority: int, value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i] == (oldPriority, value)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |elements| && elements[i] != (oldPriority, value)\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k] != (oldPriority, value)\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + elements[i+1..];\n  var newElement := (newPriority, value);\n  i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [newElement] + elements[i..];\n}\nmethod Merge(other: PriorityQueue)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |other.elements|\n    invariant 0 <= i <= |other.elements|\n    invariant forall k :: 0 <= k < i ==> elements[..|elements|] + other.elements[..k] == elements[..|elements| + k]\n    invariant forall m, n :: 0 <= m < n < |elements| ==> elements[m].0 <= elements[n].0\n  {\n    var (priority, value) := other.elements[i];\n    var j := 0;\n    while j < |elements| && elements[j].0 <= priority\n      invariant 0 <= j <= |elements|\n      invariant forall k :: 0 <= k < j ==> elements[k].0 <= priority\n    {\n      j := j + 1;\n    }\n    elements := elements[..j] + [(priority, value)] + elements[j..];\n    i := i + 1;\n  }\n}\nmethod Clear()\n  modifies this\n  ensures |elements| == 0\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant |elements| == old(|elements|) - i\n    invariant forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0\n  {\n    elements := elements[1..];\n    i := i + 1;\n  }\n}\n}",
            "parents": [
                "bd5e4a80-0b68-44e3-8b6f-c151e0b42635"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "SUCCESS"
            }
        },
        {
            "id": "5b356f32-3b1a-44eb-9286-1803f0e7030c",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures elements == old(elements)\n  ensures value == old(elements[0].1)\n{\n  value := elements[0].1;\n}\nmethod IsEmpty() returns (empty: bool)\n  ensures empty <==> |elements| == 0\n{\n  empty := true;\n  var i := 0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant empty == (i == 0)\n  {\n    empty := false;\n    i := i + 1;\n  }\n}\n}",
            "parents": [
                "672811ec-af0c-4014-a56f-9d8dfb71a0b5"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "b6f7d94f-5bf4-4157-9064-7d9eb4709b36",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures elements == old(elements)\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n  }\n  method UpdatePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var index := -1;\n    var i := 0;\n    // Find the index of the element with the given value\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant index == -1 ==> forall k :: 0 <= k < i ==> elements[k].1 != value\n      invariant index != -1 ==> 0 <= index < |elements| && elements[index].1 == value\n    {\n      if elements[i].1 == value {\n        index := i;\n        break;\n      }\n      i := i + 1;\n    }\n    \n    // Remove the element at the found index\n    var element := elements[index];\n    elements := elements[..index] + elements[index + 1..];\n\n    // Re-insert the element with the new priority\n    var newElement := (newPriority, value);\n    i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n      invariant elements[..index] + elements[index + 1..] == old(elements[..index] + elements[index + 1..])\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\nmethod Merge(other: PriorityQueue)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |other.elements|\n    invariant 0 <= i <= |other.elements|\n    invariant forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0\n  {\n    var newElement := other.elements[i];\n    var j := 0;\n    while j < |elements| && elements[j].0 <= newElement.0\n      invariant 0 <= j <= |elements|\n      invariant forall k :: 0 <= k < j ==> elements[k].0 <= newElement.0\n    {\n      j := j + 1;\n    }\n    elements := elements[..j] + [newElement] + elements[j..];\n    i := i + 1;\n  }\n}\n}",
            "parents": [
                "fc27f137-5945-41ce-9515-57ebaaf6d72f"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "8c9e371d-9a72-44a0-a710-e17ad30adf60",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant forall k, l :: 0 <= k < l < |elements| && l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method IsEmpty() returns (empty: bool)\n    ensures empty == (|elements| == 0)\n  {\n    empty := |elements| == 0;\n  }\nmethod FindMaxPriority() returns (maxValue: int)\n  requires |elements| > 0\n  ensures exists i :: 0 <= i < |elements| && elements[i].1 == maxValue\n  ensures forall i :: 0 <= i < |elements| ==> elements[i].0 <= elements[0].0\n{\n  var maxIndex := 0;\n  var i := 1;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant 0 <= maxIndex < i\n    invariant forall j :: 0 <= j < i ==> elements[j].0 <= elements[maxIndex].0\n  {\n    if elements[i].0 > elements[maxIndex].0 {\n      maxIndex := i;\n    }\n    i := i + 1;\n  }\n  maxValue := elements[maxIndex].1;\n}\n}",
            "parents": [
                "48344a38-3b8b-45a4-a90f-96e301004e0f"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "f038a5d8-275a-4dd5-90bc-387ecb85ff56",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p < right ==> arr[p] > pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n    invariant forall r: int :: left <= r < j ==> arr[r] <= pivot || arr[r] > pivot\n    invariant forall s: int :: j <= s <= right ==> arr[s] >= pivot || arr[s] < pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\nfor j := left to right - 1\n  invariant left <= i <= j <= right\n  invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n  invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n  invariant forall q: int :: left <= q <= right ==> \n            (arr[q] <= pivot || arr[q] > pivot)\n{\n  if arr[j] <= pivot {\n    arr[i], arr[j] := arr[j], arr[i];\n    i := i + 1;\n  }\n}\narr[i], arr[right] := arr[right], arr[i];\nreturn i;\n}",
            "parents": [
                "a3e62053-9c6d-48a9-b8e3-f4e0235d8f8b"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "143807b2-47ab-4189-a5bd-7261fdea7c1b",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p < right ==> arr[p] > pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n    invariant forall r: int :: left <= r < j ==> arr[r] <= pivot || arr[r] > pivot\n    invariant forall s: int :: j <= s <= right ==> arr[s] >= pivot || arr[s] < pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n    invariant forall r: int :: left <= r <= right ==> \n              (arr[r] <= pivot ==> r < i || r > j)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\nfor j := left to right - 1\n  invariant left <= i <= j <= right\n  invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n  invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n  invariant forall q: int :: left <= q < right ==> (arr[q] <= pivot || arr[q] > pivot)\n  invariant forall r: int :: left <= r < i ==> arr[r] <= pivot\n  invariant forall s: int :: i <= s <= j ==> arr[s] > pivot\n{\n  if arr[j] <= pivot {\n    arr[i], arr[j] := arr[j], arr[i];\n    i := i + 1;\n  }\n}\narr[i], arr[right] := arr[right], arr[i];\nreturn i;\n}",
            "parents": [
                "5930c594-2f01-493d-af2c-91db85338709"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "5e69c257-e155-483a-8b5e-6f065b2ca16b",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  \n  constructor() {\n    elements := [];\n  }\n\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\nmethod IsEmpty() returns (empty: bool)\n  ensures empty <==> |elements| == 0\n{\n  empty := |elements| == 0;\n}\n\nmethod Size() returns (size: int)\n  ensures size == |elements|\n{\n  size := 0;\n  var i := 0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant size == i\n  {\n    size := size + 1;\n    i := i + 1;\n  }\n}\n}",
            "parents": [
                "e7f96eb4-f733-4ffe-a8eb-7f1637baa987"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "ba1aad7c-e85b-4420-81b9-1d2d39442b0d",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n{\n  value := elements[0].1;\n}\n}",
            "parents": [
                "3803a3ca-da34-4a1b-8cf7-61aa3bb9676f"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "aa2fb3da-fd75-41f5-8d59-3623123127b9",
            "type": "program",
            "content": "method CoinChange(coins: seq<int>, amount: int) returns (minCoins: int)\n  requires amount >= 0\n  requires forall c :: c in coins ==> c > 0\n  ensures minCoins >= -1\n  ensures minCoins == -1 || minCoins * 1 <= amount\n{\n  var dp := new int[amount + 1];\n  dp[0] := 0;\n  var i: int := 1;\n  while i <= amount\n    invariant 0 <= i <= amount + 1\n    invariant dp[0] == 0\n    invariant forall j :: 0 <= j < i ==> dp[j] >= 0 || dp[j] == -1\n  {\n    dp[i] := -1;\n    var j: int := 0;\n    while j < |coins|\n      invariant forall k :: 0 <= k < i ==> dp[k] <= k\n      invariant 0 <= j <= |coins|\n      invariant dp[i] >= -1\n    {\n        if i - coins[j] >= 0 && dp[i - coins[j]] != -1 {\n          if dp[i] == -1 || dp[i] > dp[i - coins[j]] + 1 {\n            dp[i] := dp[i - coins[j]] + 1;\n          }\n        }\n        j := j + 1;\n      }\n      i := i + 1;\n    }\n    minCoins := dp[amount];\n  }",
            "parents": [
                "5fe70a95-228e-4a7e-8ade-222afa605d25"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "84818fc7-4eaf-4984-b318-c9c534b3311a",
            "type": "program",
            "content": "method TextSegmentation(s: seq<char>, dict: set<seq<char>>) returns (result: seq<seq<char>>)\n  requires |s| > 0\n  ensures forall segment: seq<char> :: segment in result ==> segment in dict\n  ensures |result| > 0\n{\n  var n := |s|;\n  var dp: array<bool> := new bool[n + 1];\n  dp[0] := true;\n  var segments: array<seq<seq<char>>> := new seq<seq<char>>[n + 1];\n  segments[0] := [];\n  for i := 1 to n {\n    dp[i] := false;\n    segments[i] := [];\n    for j := 0 to i - 1 {\n      if dp[j] && s[j..i] in dict {\n        dp[i] := true;\n        segments[i] := segments[j] + [s[j..i]];\n        break;\n      }\n    }\n    assert dp[i] ==> segments[i] != [];\n  }\n  result := segments[n];\n  for i := 1 to n\n    invariant 0 <= i <= n\n    invariant forall k: int :: 0 <= k < i ==> (dp[k] ==> segments[k] != [] && forall segment: seq<char> :: segment in segments[k] ==> segment in dict)\n  {\n    dp[i] := false;\n    segments[i] := [];\n    for j := 0 to i - 1 {\n      if dp[j] && s[j..i] in dict {\n        dp[i] := true;\n        segments[i] := segments[j] + [s[j..i]];\n        break;\n      }\n    }\n    assert dp[i] ==> segments[i] != [];\n  }\n  result := segments[n];\n}",
            "parents": [
                "ff106d62-74d3-45d5-a861-8e362e08884a"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "62bee572-9ea5-4367-9701-ed67a83bac26",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(oldPriority: int, value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i] == (oldPriority, value)\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var i := 0;\n    while i < |elements| && elements[i] != (oldPriority, value)\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k] != (oldPriority, value)\n      invariant exists j :: i <= j < |elements| && elements[j] == (oldPriority, value)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + elements[i+1..];\n    var newElement := (newPriority, value);\n    i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n      invariant elements == old(elements[..i]) + old(elements[i..])\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Merge(other: PriorityQueue)\n    modifies this\n    ensures forall e :: e in other.elements ==> e in elements\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var i := 0;\n    while i < |other.elements|\n      invariant 0 <= i <= |other.elements|\n      invariant forall k :: 0 <= k < i ==> other.elements[k] in elements\n      invariant forall m, n :: 0 <= m < n < |elements| ==> elements[m].0 <= elements[n].0\n    {\n      var (priority, value) := other.elements[i];\n      Enqueue(priority, value);\n      i := i + 1;\n    }\n  }\nmethod RemoveByValue(value: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n    invariant exists j :: i <= j < |elements| && elements[j].1 == value\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + elements[i+1..];\n}\n}",
            "parents": [
                "ccb6166f-bc59-489b-82d3-264b2c7d7f30"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "9b327adc-f1da-43ce-b281-b43f0e714290",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures elements == old(elements)\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n  }\n  method IsEmpty() returns (empty: bool)\n    ensures empty == (|elements| == 0)\n  {\n    empty := |elements| == 0;\n  }\nmethod Merge(other: PriorityQueue)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures |elements| == |old(elements)| + |other.elements|\n  ensures forall e :: e in other.elements ==> e in elements\n{\n  var i := 0;\n  var j := 0;\n  var merged: seq<(int, int)> := [];\n  \n  while i < |elements| || j < |other.elements|\n    invariant 0 <= i <= |elements|\n    invariant 0 <= j <= |other.elements|\n    invariant |merged| == i + j\n    invariant forall k, l :: 0 <= k < l < |merged| ==> merged[k].0 <= merged[l].0\n    invariant forall e :: e in merged ==> e in elements[..i] + other.elements[..j]\n  {\n    if i < |elements| && (j >= |other.elements| || elements[i].0 <= other.elements[j].0) {\n      merged := merged + [elements[i]];\n      i := i + 1;\n    } else {\n      merged := merged + [other.elements[j]];\n      j := j + 1;\n    }\n  }\n  \n  elements := merged;\n}\n}",
            "parents": [
                "abb8f668-c715-4c64-87d8-9f2f2b65e522"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "54d07980-49cf-42bc-a80b-8a2e914458cb",
            "type": "program",
            "content": "class Graph {\n  var adjacencyMatrix: array2<bool>;\n\n  constructor(n: nat) \n    requires n > 0\n    ensures adjacencyMatrix.Length0 == n && adjacencyMatrix.Length1 == n\n    ensures forall i, j :: 0 <= i < n && 0 <= j < n ==> !adjacencyMatrix[i, j]\n  {\n    adjacencyMatrix := new bool[n, n];\n  }\n\n  method AddEdge(u: nat, v: nat)\n    requires 0 <= u < adjacencyMatrix.Length0\n    requires 0 <= v < adjacencyMatrix.Length1\n    modifies adjacencyMatrix\n    ensures adjacencyMatrix[u, v] && adjacencyMatrix[v, u]\n  {\n    adjacencyMatrix[u, v] := true;\n    adjacencyMatrix[v, u] := true;\n  }\n\n  method IsVertexCover(cover: set<nat>) returns (isCover: bool)\n    requires cover <= set i | 0 <= i < adjacencyMatrix.Length0\n    ensures isCover == (forall u, v :: 0 <= u < adjacencyMatrix.Length0 && 0 <= v < adjacencyMatrix.Length1 && adjacencyMatrix[u, v] ==> u in cover || v in cover)\n  {\n    isCover := true;\n    var n := adjacencyMatrix.Length0;\n    for u := 0 to n - 1 {\n      for v := 0 to n - 1 \n        invariant 0 <= u < n\n        invariant 0 <= v <= n\n        invariant isCover == (forall i, j :: 0 <= i <= u && 0 <= j < n && adjacencyMatrix[i, j] ==> i in cover || j in cover)\n      {\n        if adjacencyMatrix[u, v] && !(u in cover || v in cover) {\n          isCover := false;\n          return;\n        }\n      }\n    }\n  }\nmethod VertexDegree(u: nat) returns (degree: nat)\n  requires 0 <= u < adjacencyMatrix.Length0\n  ensures degree == |set v | 0 <= v < adjacencyMatrix.Length1 && adjacencyMatrix[u, v]|\n{\n  degree := 0;\n  var n := adjacencyMatrix.Length1;\n  for v := 0 to n - 1\n    invariant 0 <= v <= n\n    invariant degree == |set j | 0 <= j < v && adjacencyMatrix[u, j]|\n  {\n    if adjacencyMatrix[u, v] {\n      degree := degree + 1;\n    }\n  }\n}\n}",
            "parents": [
                "dcb511aa-6410-4845-b08a-6963d8bf6d82"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "426a02f5-1be4-4799-a168-4eb69a5d8cff",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures elements == old(elements)\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n      invariant exists j :: 0 <= j < |elements| && elements[j].1 == value\n    {\n      i := i + 1;\n    }\n    var oldElement := elements[i];\n    elements := elements[..i] + elements[i+1..];\n    var j := 0;\n    while j < |elements| && elements[j].0 <= newPriority\n      invariant 0 <= j <= |elements|\n      invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n    {\n      j := j + 1;\n    }\n    elements := elements[..j] + [(newPriority, value)] + elements[j..];\n    assert forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0;\n  }\n}",
            "parents": [
                "4596c890-ed7d-46c8-97d0-2e065b117389"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "b7103310-72b3-4ec3-aa5c-9af55e2f4c79",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n    ensures elements == old(elements)\n  {\n    var i := 0;\n    var highestPriority := elements[0].0;\n    value := elements[0].1;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= highestPriority\n      invariant exists k :: 0 <= k < |elements| && elements[k].0 == highestPriority && value == elements[k].1\n      invariant forall k :: 0 <= k < |elements| ==> elements[k].0 >= highestPriority\n    {\n      if elements[i].0 < highestPriority {\n        highestPriority := elements[i].0;\n        value := elements[i].1;\n      }\n      i := i + 1;\n    }\n    assert value == elements[0].1;\n  }\n  method IsEmpty() returns (empty: bool)\n    ensures empty <==> |elements| == 0\n  {\n    empty := |elements| == 0;\n  }\n  method Merge(other: PriorityQueue)\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures |elements| == |old(elements)| + |other.elements|\n    ensures forall e :: e in old(elements) || e in other.elements ==> e in elements\n  {\n    var merged: seq<(int, int)> := [];\n    var i := 0;\n    var j := 0;\n    while i < |elements| || j < |other.elements|\n      invariant 0 <= i <= |elements|\n      invariant 0 <= j <= |other.elements|\n      invariant |merged| == i + j\n      invariant forall k, l :: 0 <= k < l < |merged| ==> merged[k].0 <= merged[l].0\n      invariant forall e :: e in merged ==> e in old(elements) || e in other.elements\n    {\n      if i < |elements| && (j >= |other.elements| || elements[i].0 <= other.elements[j].0) {\n        merged := merged + [elements[i]];\n        i := i + 1;\n      } else {\n        merged := merged + [other.elements[j]];\n        j := j + 1;\n      }\n    }\n    elements := merged;\n  }\n}",
            "parents": [
                "594cc228-2844-413e-a0fb-0d4b0381f598"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "c3fe129f-4f43-4027-b805-4789ff8866cd",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n{\n  value := elements[0].1;\n}\nmethod UpdatePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var index := 0;\n  while index < |elements| && elements[index].1 != value\n    invariant 0 <= index <= |elements|\n    invariant forall k :: 0 <= k < index ==> elements[k].1 != value\n  {\n    index := index + 1;\n  }\n  var oldElement := elements[index];\n  elements := elements[..index] + elements[index + 1..];\n  \n  var i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [(newPriority, value)] + elements[i..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\n}",
            "parents": [
                "be6823b5-37e8-4c49-9e27-d36ea3976379"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "aa50a49b-c1e5-4a17-8d63-302e4f2f9e6a",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method UpdatePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n  {\n    var index := 0;\n    while index < |elements| && elements[index].1 != value\n      invariant 0 <= index <= |elements|\n      invariant forall k :: 0 <= k < index ==> elements[k].1 != value\n      invariant exists i :: 0 <= i < |elements| && elements[i].1 == value\n    {\n      index := index + 1;\n    }\n\n    // Remove the element with the specified value\n    var priority := elements[index].0;\n    elements := elements[..index] + elements[index + 1..];\n\n    // Reinsert the element with the new priority\n    var newElement := (newPriority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\nmethod UpdateValue(priority: int, newValue: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].0 == priority\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (priority, newValue)\n{\n  var index := 0;\n  while index < |elements| && elements[index].0 != priority\n    invariant 0 <= index <= |elements|\n    invariant forall k :: 0 <= k < index ==> elements[k].0 != priority\n    invariant exists i :: 0 <= i < |elements| && elements[i].0 == priority\n  {\n    index := index + 1;\n  }\n\n  // Update the value of the element with the specified priority\n  elements := elements[..index] + [(priority, newValue)] + elements[index + 1..];\n}\n}",
            "parents": [
                "8982ad71-0fe7-4130-b2d2-9b5fe25fe089"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "d2614e46-12f5-4f3a-8ffb-2a4c0a5dc5ad",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n    invariant forall a: int, b: int :: left <= a < b <= right ==> \n              (arr[a] <= arr[b] || arr[a] > arr[b])\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot // New invariant\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "7de4d0d2-4f45-4f57-9578-9ae4e62f931c"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "6a6fd59c-c1aa-48f4-b642-22542f29469f",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures elements == old(elements)\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(oldValue: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == oldValue\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, oldValue)\n  {\n    var i := 0;\n    // Find the element with the specified value\n    while i < |elements| && elements[i].1 != oldValue\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != oldValue\n      invariant exists j :: i <= j < |elements| && elements[j].1 == oldValue\n    {\n      i := i + 1;\n    }\n    // Remove the element\n    elements := elements[..i] + elements[i+1..];\n    \n    // Reinsert the element with the new priority\n    var newElement := (newPriority, oldValue);\n    var j := 0;\n    while j < |elements| && elements[j].0 <= newPriority\n      invariant 0 <= j <= |elements|\n      invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n    {\n      j := j + 1;\n    }\n    elements := elements[..j] + [newElement] + elements[j..];\n  }\nmethod UpdateValue(priority: int, newValue: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].0 == priority\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (priority, newValue)\n{\n  var i := 0;\n  // Find the element with the specified priority\n  while i < |elements| && elements[i].0 != priority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 != priority\n    invariant exists j :: i <= j < |elements| && elements[j].0 == priority\n  {\n    i := i + 1;\n  }\n  // Update the element's value\n  elements := elements[..i] + [(priority, newValue)] + elements[i+1..];\n}\nmethod Clear()\n  modifies this\n  ensures |elements| == 0\n{\n  var i := 0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant elements == old(elements[i..])\n  {\n    i := i + 1;\n  }\n  elements := [];\n}\nmethod Merge(other: PriorityQueue)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures |elements| == old(|elements|) + |other.elements|\n  ensures forall e :: e in old(elements) + other.elements <==> e in elements\n{\n  var i := 0;\n  while i < |other.elements|\n    invariant 0 <= i <= |other.elements|\n    invariant |elements| == old(|elements|) + i\n    invariant forall e :: e in old(elements) + other.elements[..i] <==> e in elements\n  {\n    var (priority, value) := other.elements[i];\n    this.Enqueue(priority, value);\n    i := i + 1;\n  }\n}\n}",
            "parents": [
                "fe8d5f27-d51f-41f1-b2d9-6f3445a66f32"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "907fa0de-6da7-4f98-b6f7-4799e93e6cf7",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures elements == old(elements)\n  ensures value == old(elements[0].1)\n{\n  value := elements[0].1;\n}\nmethod IsEmpty() returns (empty: bool)\n  ensures empty == (|elements| == 0)\n{\n  var i := 0;\n  empty := true;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant empty == (i == 0)\n  {\n    empty := false;\n    i := i + 1;\n  }\n}\nmethod FindMaxPriority() returns (maxPriority: int)\n  requires |elements| > 0\n  ensures exists i :: 0 <= i < |elements| && elements[i].0 == maxPriority\n  ensures forall i :: 0 <= i < |elements| ==> elements[i].0 <= maxPriority\n{\n  var i := 0;\n  maxPriority := elements[0].0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant exists j :: 0 <= j < i && elements[j].0 == maxPriority\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= maxPriority\n  {\n    if elements[i].0 > maxPriority {\n      maxPriority := elements[i].0;\n    }\n    i := i + 1;\n  }\n}\nmethod UpdatePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n  \n  // Remove the element found at index i\n  elements := elements[..i] + elements[i+1..];\n  \n  // Reinsert the element with the new priority\n  var newElement := (newPriority, value);\n  i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [newElement] + elements[i..];\n}\n}",
            "parents": [
                "d14c7845-3916-426d-bbca-e9c9bcaebc7d"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "acb4fb21-9ea6-4042-8bfb-15fd54fcce7f",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  \n  constructor() {\n    elements := [];\n  }\n\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    var i := 0;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 >= elements[i].0\n      invariant forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0\n    {\n      if elements[i].0 > elements[0].0 {\n        value := elements[i].1;\n        return;\n      }\n      i := i + 1;\n    }\n    value := elements[0].1;\n  }\nmethod UpdatePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  // Find the index of the element to update\n  var index := 0;\n  while index < |elements| && elements[index].1 != value\n    invariant 0 <= index <= |elements|\n    invariant forall k :: 0 <= k < index ==> elements[k].1 != value\n  {\n    index := index + 1;\n  }\n\n  // Update the priority\n  var updatedElement := (newPriority, value);\n  elements := elements[..index] + elements[index+1..];\n\n  // Reinsert the updated element maintaining sorted order\n  var i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [updatedElement] + elements[i..];\n}\n}",
            "parents": [
                "46b36410-52fd-4966-928e-d987471455f3"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "12b2ce10-e684-47cd-90b6-5f651aff1ec1",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod UpdatePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n  \n  var oldElement := elements[i];\n  elements := elements[..i] + elements[i+1..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n\n  // Reinsert the element with the new priority\n  var newElement := (newPriority, value);\n  var j := 0;\n  while j < |elements| && elements[j].0 <= newPriority\n    invariant 0 <= j <= |elements|\n    invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n    invariant forall k, l :: 0 <= k < l < j ==> elements[k].0 <= elements[l].0\n  {\n    j := j + 1;\n  }\n  elements := elements[..j] + [newElement] + elements[j..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\n}",
            "parents": [
                "bd5753f9-6482-478c-b6fe-2ce7d06c361e"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "3a6fc050-18ae-46bc-964a-af0802b572c8",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures elements == old(elements)\n  ensures value == elements[0].1\n{\n  var i := 0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant elements == old(elements)\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= elements[i].0\n  {\n    if elements[i].0 > elements[0].0 {\n      break;\n    }\n    i := i + 1;\n  }\n  value := elements[0].1;\n}\nmethod ChangePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n    invariant exists j :: i <= j < |elements| && elements[j].1 == value\n  {\n    i := i + 1;\n  }\n  // Remove the element with the given value\n  elements := elements[..i] + elements[i+1..];\n  \n  // Insert the element with the new priority\n  var newElement := (newPriority, value);\n  var j := 0;\n  while j < |elements| && elements[j].0 <= newPriority\n    invariant 0 <= j <= |elements|\n    invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n  {\n    j := j + 1;\n  }\n  elements := elements[..j] + [newElement] + elements[j..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\n}",
            "parents": [
                "85d268a0-2187-4d0f-b121-b5fc1b5c5243"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "f51ac2f4-60c1-445f-aaf6-c3281f8a480e",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n    method Peek() returns (value: int)\n      requires |elements| > 0\n      ensures value == elements[0].1\n    {\n      value := elements[0].1;\n    }\n  }",
            "parents": [
                "6c3d3ac7-f8f0-4080-82ff-b1e66bf34a0c"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "c4714f09-29a7-42db-a1d8-683ce31560fb",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n  ensures elements == old(elements)\n{\n  value := elements[0].1;\n}\nmethod RemoveByPriority(priority: int) returns (removed: bool)\n  modifies this\n  ensures removed ==> exists i :: 0 <= i < |old(elements)| && old(elements)[i].0 == priority\n  ensures !removed ==> forall i :: 0 <= i < |old(elements)| ==> old(elements)[i].0 != priority\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  removed := false;\n  while i < |elements| && !removed\n    invariant 0 <= i <= |elements|\n    invariant !removed ==> forall k :: 0 <= k < i ==> elements[k].0 != priority\n    invariant removed ==> exists k :: 0 <= k < i && elements[k].0 == priority\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n  {\n    if elements[i].0 == priority {\n      elements := elements[..i] + elements[i+1..];\n      removed := true;\n    } else {\n      i := i + 1;\n    }\n  }\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\nmethod Merge(other: PriorityQueue)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures |elements| == |old(elements)| + |other.elements|\n{\n  var merged: seq<(int, int)> := [];\n  var i := 0;\n  var j := 0;\n  while i < |elements| || j < |other.elements|\n    invariant 0 <= i <= |elements|\n    invariant 0 <= j <= |other.elements|\n    invariant |merged| == i + j\n    invariant forall k, l :: 0 <= k < l < |merged| ==> merged[k].0 <= merged[l].0\n    invariant forall k :: 0 <= k < i ==> elements[k] in merged\n    invariant forall k :: 0 <= k < j ==> other.elements[k] in merged\n  {\n    if i < |elements| && (j >= |other.elements| || elements[i].0 <= other.elements[j].0) {\n      merged := merged + [elements[i]];\n      i := i + 1;\n    } else {\n      merged := merged + [other.elements[j]];\n      j := j + 1;\n    }\n  }\n  elements := merged;\n}\n}",
            "parents": [
                "a698038d-6b3e-4fc0-b679-6602c71bfbe1"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "326e9206-90e9-46d5-a633-f9c4235d162e",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  \n  constructor() {\n    elements := [];\n  }\n\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    var i := 0;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 >= elements[i].0\n      invariant i == 0 ==> value == elements[0].1\n    {\n      if elements[i].0 > elements[0].0 {\n        value := elements[i].1;\n        return;\n      }\n      i := i + 1;\n    }\n    value := elements[0].1;\n  }\n\nmethod IsEmpty() returns (empty: bool)\n  ensures empty == (|elements| == 0)\n{\n  empty := |elements| == 0;\n}\n\nmethod GetMaxPriority() returns (value: int)\n  requires |elements| > 0\n  ensures exists p :: (p, value) in elements && forall q, v :: (q, v) in elements ==> p >= q\n{\n  var maxPriority := elements[0].0;\n  value := elements[0].1;\n  var i := 1;\n  while i < |elements|\n    invariant 1 <= i <= |elements|\n    invariant exists p :: (p, value) in elements[..i] && forall q, v :: (q, v) in elements[..i] ==> p >= q\n  {\n    if elements[i].0 > maxPriority {\n      maxPriority := elements[i].0;\n      value := elements[i].1;\n    }\n    i := i + 1;\n  }\n}\n}",
            "parents": [
                "5cfc3c4f-9504-4d16-8157-18b40cc3f19f"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "fed6b336-4b0c-4158-b518-2122cd526d52",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\nmethod ChangePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n  var updatedElement := (newPriority, value);\n  elements := elements[..i] + elements[i+1..];\n  \n  // Re-insert the updated element\n  var j := 0;\n  while j < |elements| && elements[j].0 <= newPriority\n    invariant 0 <= j <= |elements|\n    invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n  {\n    j := j + 1;\n  }\n  elements := elements[..j] + [updatedElement] + elements[j..];\n}\nmethod Remove(value: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i :: 0 <= i < |elements| ==> elements[i].1 != value\n  ensures |elements| == old(|elements|) - 1\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + elements[i+1..];\n}\n}",
            "parents": [
                "155a201f-9ae9-44b2-bf7e-ed15c1c215f8"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "a7ab0201-23ae-442c-af0b-6d83e2df1da6",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method IsEmpty() returns (empty: bool)\n    ensures empty == (|elements| == 0)\n  {\n    var i := 0;\n    empty := true;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant empty == (i == 0)\n    {\n      empty := false;\n      i := i + 1;\n    }\n  }\nmethod ChangePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n{\n  var i := 0;\n  var found := false;\n  while i < |elements| && !found\n    invariant 0 <= i <= |elements|\n    invariant !found ==> forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    if elements[i].1 == value {\n      found := true;\n    } else {\n      i := i + 1;\n    }\n  }\n\n  if found {\n    elements := elements[..i] + elements[i+1..];\n    // Reinsert the element with the new priority\n    Enqueue(newPriority, value);\n  }\n}\n}",
            "parents": [
                "55d9d0e5-6f19-4a7e-b6e4-bb40226e663d"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "2ed884d3-1b82-483c-a22e-26f7fa0d16a9",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var index := -1;\n    var i := 0;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant index == -1 ==> forall k :: 0 <= k < i ==> elements[k].1 != value\n      invariant index != -1 ==> elements[index].1 == value\n      invariant index == -1 ==> elements == old(elements)\n    {\n      if elements[i].1 == value {\n        index := i;\n        break;\n      }\n      i := i + 1;\n    }\n    assert index != -1; // We should have found the element\n\n    // Remove the element\n    elements := elements[..index] + elements[index + 1..];\n\n    // Reinsert with new priority\n    var newElement := (newPriority, value);\n    i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant elements[..index] + elements[index..] == old(elements[..index] + elements[index + 1..])\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\nmethod Merge(other: PriorityQueue)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var merged: seq<(int, int)> := [];\n  var i := 0;\n  var j := 0;\n  while i < |elements| || j < |other.elements|\n    invariant 0 <= i <= |elements|\n    invariant 0 <= j <= |other.elements|\n    invariant |merged| == i + j\n    invariant forall k :: 0 <= k < |merged| ==> \n              (k < i ==> merged[k] == elements[k]) || \n              (k >= i ==> merged[k] == other.elements[k - i])\n    invariant forall k, l :: 0 <= k < l < |merged| ==> merged[k].0 <= merged[l].0\n  {\n    if i < |elements| && (j >= |other.elements| || elements[i].0 <= other.elements[j].0) {\n      merged := merged + [elements[i]];\n      i := i + 1;\n    } else {\n      merged := merged + [other.elements[j]];\n      j := j + 1;\n    }\n  }\n  elements := merged;\n}\n}",
            "parents": [
                "b3bade4c-e82c-4453-b2ca-4289e9c2bf9d"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "74a71cf0-0797-4522-bd43-542dd5c6d9ba",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures elements == old(elements)\n    ensures value == elements[0].1\n  {\n    var highestPriority := elements[0].0;\n    var highestValue := elements[0].1;\n    var i := 1;\n    while i < |elements|\n      invariant 1 <= i <= |elements|\n      invariant highestPriority == elements[0].0\n      invariant highestValue == elements[0].1\n      invariant forall k :: 0 <= k < i ==> elements[k].0 >= highestPriority\n    {\n      if elements[i].0 < highestPriority {\n        highestPriority := elements[i].0;\n        highestValue := elements[i].1;\n      }\n      i := i + 1;\n    }\n    value := highestValue;\n  }\n  method ChangePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n    {\n      i := i + 1;\n    }\n    // Remove the element with the specified value\n    elements := elements[..i] + elements[i+1..];\n    \n    // Re-insert the element with the new priority\n    var newElement := (newPriority, value);\n    i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\nmethod RemoveByValue(value: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures !exists i :: 0 <= i < |elements| && elements[i].1 == value\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n  // Remove the element with the specified value\n  elements := elements[..i] + elements[i+1..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\n}",
            "parents": [
                "4047da5f-7ce2-4b81-aa86-b2381b5e3651"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "66fdcb2f-b2cf-47e1-95ba-fa7d78da2ebe",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n{\n  value := elements[0].1;\n}\nmethod ChangePriority(oldValue: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == oldValue\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, oldValue)\n  ensures |elements| == old(|elements|)\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != oldValue\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != oldValue\n  {\n    i := i + 1;\n  }\n\n  // Remove the element with oldValue\n  var removedElement := elements[i];\n  elements := elements[..i] + elements[i+1..];\n\n  // Insert the element with the new priority\n  var newElement := (newPriority, oldValue);\n  i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [newElement] + elements[i..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\nmethod Merge(other: PriorityQueue)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures |elements| == old(|elements|) + |other.elements|\n  ensures forall e :: e in other.elements ==> e in elements\n{\n  var i := 0;\n  var j := 0;\n  var merged: seq<(int, int)> := [];\n\n  while i < |elements| || j < |other.elements|\n    invariant 0 <= i <= |elements|\n    invariant 0 <= j <= |other.elements|\n    invariant |merged| == i + j\n    invariant forall k, l :: 0 <= k < l < |merged| ==> merged[k].0 <= merged[l].0\n    invariant forall e :: e in merged ==> e in old(elements) || e in other.elements\n  {\n    if i < |elements| && (j >= |other.elements| || elements[i].0 <= other.elements[j].0) {\n      merged := merged + [elements[i]];\n      i := i + 1;\n    } else {\n      merged := merged + [other.elements[j]];\n      j := j + 1;\n    }\n  }\n  elements := merged;\n}\n}",
            "parents": [
                "88decd5e-1c0c-466b-b71a-baa4beee8c25"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "19ecc5a0-b45b-4059-9bbd-42ef94e0b00f",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method IsEmpty() returns (empty: bool)\n    ensures empty == (|elements| == 0)\n  {\n    var i := 0;\n    empty := true;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant empty == (i == 0)\n    {\n      empty := false;\n      i := i + 1;\n    }\n  }\nmethod UpdatePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n{\n  var i := 0;\n  var found := false;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant !found ==> forall k :: 0 <= k < i ==> elements[k].1 != value\n    invariant found ==> elements[i - 1] == (newPriority, value)\n  {\n    if elements[i].1 == value {\n      elements := elements[..i] + elements[i+1..];\n      found := true;\n      break;\n    }\n    i := i + 1;\n  }\n  // Insert the updated element back into the queue\n  var j := 0;\n  while j < |elements| && elements[j].0 <= newPriority\n    invariant 0 <= j <= |elements|\n    invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n    invariant forall k, l :: 0 <= k < l < j ==> elements[k].0 <= elements[l].0\n  {\n    j := j + 1;\n  }\n  elements := elements[..j] + [(newPriority, value)] + elements[j..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\n}",
            "parents": [
                "ca648669-4d60-4550-9952-523159edbd62"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "ce799535-df97-4a13-84d8-d84fe5a25b2a",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n{\n  value := elements[0].1;\n}\nmethod UpdatePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n{\n  var index := 0;\n  while index < |elements| && elements[index].1 != value\n    invariant 0 <= index <= |elements|\n    invariant forall k :: 0 <= k < index ==> elements[k].1 != value\n  {\n    index := index + 1;\n  }\n\n  // Remove the element with the specified value\n  var priority := elements[index].0;\n  elements := elements[..index] + elements[index + 1..];\n\n  // Reinsert the element with the new priority\n  var newElement := (newPriority, value);\n  var i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [newElement] + elements[i..];\n}\nmethod ChangePriority(currentPriority: int, value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i] == (currentPriority, value)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n{\n  var index := 0;\n  while index < |elements| && elements[index] != (currentPriority, value)\n    invariant 0 <= index <= |elements|\n    invariant forall k :: 0 <= k < index ==> elements[k] != (currentPriority, value)\n  {\n    index := index + 1;\n  }\n\n  // Remove the element with the specified current priority and value\n  elements := elements[..index] + elements[index + 1..];\n\n  // Reinsert the element with the new priority\n  var newElement := (newPriority, value);\n  var i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [newElement] + elements[i..];\n}\n}",
            "parents": [
                "7679c90f-2f7f-4d06-855a-7816583305da"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "d4b6e572-e584-44e8-b53f-b48b9944e3d4",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures elements == old(elements)\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n  }\nmethod IsEmpty() returns (empty: bool)\n  ensures empty <==> |elements| == 0\n  ensures elements == old(elements)\n{\n  empty := |elements| == 0;\n}\nmethod Merge(other: PriorityQueue)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures elements == old(elements) + other.elements\n{\n  var i := 0;\n  var j := 0;\n  var merged: seq<(int, int)> := [];\n  \n  while i < |elements| || j < |other.elements|\n    invariant 0 <= i <= |elements|\n    invariant 0 <= j <= |other.elements|\n    invariant |merged| == i + j\n    invariant forall k :: 0 <= k < |merged| ==> \n      (k < i ==> merged[k] == elements[k]) || \n      (k < j ==> merged[k] == other.elements[k])\n    invariant forall m, n :: 0 <= m < n < |merged| ==> merged[m].0 <= merged[n].0\n  {\n    if i < |elements| && (j >= |other.elements| || elements[i].0 <= other.elements[j].0) {\n      merged := merged + [elements[i]];\n      i := i + 1;\n    } else {\n      merged := merged + [other.elements[j]];\n      j := j + 1;\n    }\n  }\n  \n  elements := merged;\n}\n}",
            "parents": [
                "0973fe8d-5795-4eda-b1de-c7bac46c28b5"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "0d6da67d-e3d9-4e8f-aaf0-67710d1ba1af",
            "type": "program",
            "content": "class Vector3D {\n  var x: int\n  var y: int\n  var z: int\n  constructor(x: int, y: int, z: int) \n    ensures this.x == x && this.y == y && this.z == z\n  {\n    this.x := x;\n    this.y := y;\n    this.z := z;\n  }\n  method CrossProduct(other: Vector3D) returns (result: Vector3D)\n    ensures result.x == this.y * other.z - this.z * other.y\n    ensures result.y == this.z * other.x - this.x * other.z\n    ensures result.z == this.x * other.y - this.y * other.x\n  {\n    var cx := this.y * other.z - this.z * other.y;\n    var cy := this.z * other.x - this.x * other.z;\n    var cz := this.x * other.y - this.y * other.x;\n    result := new Vector3D(cx, cy, cz);\n  }\nmethod DotProduct(other: Vector3D) returns (result: int)\n  ensures result == this.x * other.x + this.y * other.y + this.z * other.z\n{\n  var sum := 0;\n  var components := [this.x, this.y, this.z];\n  var otherComponents := [other.x, other.y, other.z];\n\n  // Loop over each component to calculate the dot product\n  var i := 0;\n  while i < 3\n    invariant 0 <= i <= 3\n    invariant sum == (if i >= 1 then components[0] * otherComponents[0] else 0)\n                      + (if i >= 2 then components[1] * otherComponents[1] else 0)\n  {\n    sum := sum + components[i] * otherComponents[i];\n    i := i + 1;\n  }\n\n  result := sum;\n}\nmethod SquaredMagnitude() returns (result: int)\n  ensures result == this.x * this.x + this.y * this.y + this.z * this.z\n{\n  var sum := 0;\n  var components := [this.x, this.y, this.z];\n\n  // Loop over each component to calculate the squared magnitude\n  var i := 0;\n  while i < 3\n    invariant 0 <= i <= 3\n    invariant sum == (if i >= 1 then components[0] * components[0] else 0)\n                      + (if i >= 2 then components[1] * components[1] else 0)\n  {\n    sum := sum + components[i] * components[i];\n    i := i + 1;\n  }\n\n  result := sum;\n}\n}",
            "parents": [
                "c8041bff-3eec-4f3b-b067-6bcba8c3d80f"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "ec52d70e-5eea-44c1-b83c-00df356b28e8",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method IsEmpty() returns (empty: bool)\n    ensures empty == (|elements| == 0)\n  {\n    var i := 0;\n    empty := true;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant empty == (i == 0)\n    {\n      empty := false;\n      i := i + 1;\n    }\n  }\nmethod Merge(other: PriorityQueue)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures |elements| == |old(elements)| + |other.elements|\n  ensures multiset(elements) == multiset(old(elements) + other.elements)\n{\n  var merged: seq<(int, int)> := [];\n  var i := 0;\n  var j := 0;\n\n  while i < |elements| || j < |other.elements|\n    invariant 0 <= i <= |elements|\n    invariant 0 <= j <= |other.elements|\n    invariant |merged| == i + j\n    invariant forall k, l :: 0 <= k < l < |merged| ==> merged[k].0 <= merged[l].0\n    invariant multiset(merged) == multiset(old(elements[..i]) + other.elements[..j])\n  {\n    if i < |elements| && (j >= |other.elements| || elements[i].0 <= other.elements[j].0) {\n      merged := merged + [elements[i]];\n      i := i + 1;\n    } else {\n      merged := merged + [other.elements[j]];\n      j := j + 1;\n    }\n  }\n  elements := merged;\n}\nmethod IncreasePriority(value: int, newPriority: int)\n  requires |elements| > 0\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i].1 == value ==> elements[i].0 == newPriority\n{\n  var found := false;\n  var i := 0;\n  \n  // Find the element with the given value\n  while i < |elements| && !found\n    invariant 0 <= i <= |elements|\n    invariant !found ==> forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    if elements[i].1 == value {\n      found := true;\n    } else {\n      i := i + 1;\n    }\n  }\n  \n  if found {\n    // Remove the element and reinsert it with the new priority\n    var element := elements[i];\n    elements := elements[..i] + elements[i+1..];\n    \n    var j := 0;\n    while j < |elements| && elements[j].0 <= newPriority\n      invariant 0 <= j <= |elements|\n      invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < j ==> elements[k].0 <= elements[l].0\n    {\n      j := j + 1;\n    }\n    elements := elements[..j] + [(newPriority, element.1)] + elements[j..];\n  }\n}\n}",
            "parents": [
                "15b62b82-d6b0-48fb-910c-77902ed912e7"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "a620efaf-7aed-4994-9970-ebbbf8f3fd6a",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n      invariant exists j :: i <= j < |elements| && elements[j].1 == value\n    {\n      i := i + 1;\n    }\n    var updatedElement := (newPriority, value);\n    elements := elements[..i] + elements[i+1..];\n    \n    // Re-insert the updated element\n    var j := 0;\n    while j < |elements| && elements[j].0 <= newPriority\n      invariant 0 <= j <= |elements|\n      invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n    {\n      j := j + 1;\n    }\n    elements := elements[..j] + [updatedElement] + elements[j..];\n  }\nmethod RemoveValue(value: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n    invariant exists j :: i <= j < |elements| && elements[j].1 == value\n  {\n    i := i + 1;\n  }\n  // Remove the element with the specified value\n  elements := elements[..i] + elements[i+1..];\n}\n}",
            "parents": [
                "2f9a83c2-94e0-443e-83b0-24a39d860272"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "bd1a55e3-c249-4ce0-81a2-e950bb815eb4",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n    invariant forall r: int :: left <= r < j ==> arr[r] <= pivot || arr[r] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n    invariant forall r: int :: i <= r <= j ==> arr[r] >= pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "d69266e4-437f-4735-82c6-bfecd54e0e88"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "b96f6bb0-ca74-4357-88d5-ca5ed0f56084",
            "type": "program",
            "content": "method ComputeTriangularNumber(n: nat) returns (t: nat)\n  requires n >= 0\n  ensures t == n * (n + 1) / 2\n{\n  var sum := 0;\n  var i := 0;\n  while i <= n\n    invariant 0 <= i <= n + 1\n    invariant sum == i * (i - 1) / 2\n  {\n    sum := sum + i;\n    i := i + 1;\n  }\n  t := sum;\n{\n  var sum := 0;\n  var i := 0;\n  while i <= n\n    invariant 0 <= i <= n + 1\n    invariant sum == i * (i - 1) * (2 * i - 1) / 6\n  {\n    sum := sum + i * i;\n    i := i + 1;\n  }\n  t := sum;\n}\n}",
            "parents": [
                "7dd7dcfd-6654-459a-a74a-17572d0913de"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "cf5035c0-ce4c-44a3-8399-bb39deb73799",
            "type": "program",
            "content": "class Graph {\n  var adjacencyMatrix: array2<bool>;\n\n  constructor(n: nat) \n    requires n > 0\n    ensures adjacencyMatrix.Length0 == n && adjacencyMatrix.Length1 == n\n    ensures forall i, j :: 0 <= i < n && 0 <= j < n ==> !adjacencyMatrix[i, j]\n  {\n    adjacencyMatrix := new bool[n, n];\n  }\n\n  method AddEdge(u: nat, v: nat)\n    requires 0 <= u < adjacencyMatrix.Length0\n    requires 0 <= v < adjacencyMatrix.Length1\n    modifies adjacencyMatrix\n    ensures adjacencyMatrix[u, v] && adjacencyMatrix[v, u]\n  {\n    adjacencyMatrix[u, v] := true;\n    adjacencyMatrix[v, u] := true;\n  }\n\n  method IsVertexCover(cover: set<nat>) returns (isCover: bool)\n    requires cover <= set i | 0 <= i < adjacencyMatrix.Length0\n    ensures isCover == (forall u, v :: 0 <= u < adjacencyMatrix.Length0 && 0 <= v < adjacencyMatrix.Length1 && adjacencyMatrix[u, v] ==> u in cover || v in cover)\n  {\n    isCover := true;\n    var n := adjacencyMatrix.Length0;\n    for u := 0 to n - 1 \n      invariant 0 <= u <= n\n      invariant isCover == (forall i, j :: 0 <= i < u && 0 <= j < n && adjacencyMatrix[i, j] ==> i in cover || j in cover)\n    {\n      for v := 0 to n - 1 \n        invariant 0 <= v <= n\n        invariant isCover == (forall i, j :: 0 <= i < u && 0 <= j < n && adjacencyMatrix[i, j] ==> i in cover || j in cover) &&\n                            (forall j :: 0 <= j < v && adjacencyMatrix[u, j] ==> u in cover || j in cover)\n      {\n        if adjacencyMatrix[u, v] && !(u in cover || v in cover) {\n          isCover := false;\n          return;\n        }\n      }\n    }\n  }\nmethod IsCompleteGraph() returns (isComplete: bool)\n  ensures isComplete == (forall u, v :: 0 <= u < adjacencyMatrix.Length0 && 0 <= v < adjacencyMatrix.Length1 && u != v ==> adjacencyMatrix[u, v])\n{\n  isComplete := true;\n  var n := adjacencyMatrix.Length0;\n  for u := 0 to n - 1\n    invariant 0 <= u <= n\n    invariant isComplete == (forall i, j :: 0 <= i < u && 0 <= j < n && i != j ==> adjacencyMatrix[i, j])\n  {\n    for v := 0 to n - 1\n      invariant 0 <= v <= n\n      invariant isComplete == (forall i, j :: 0 <= i < u && 0 <= j < n && i != j ==> adjacencyMatrix[i, j]) &&\n                              (forall j :: 0 <= j < v && u != j ==> adjacencyMatrix[u, j])\n    {\n      if u != v && !adjacencyMatrix[u, v] {\n        isComplete := false;\n        return;\n      }\n    }\n  }\n}\n}",
            "parents": [
                "704cb1d3-f86f-4e81-8864-b20ff3be87b2"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "f1d947f0-8d04-450b-859d-d7789eddde73",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n  ensures elements == old(elements)\n{\n  value := elements[0].1;\n}\nmethod RemoveByPriority(priority: int) returns (removed: bool)\n  modifies this\n  ensures removed ==> exists i :: 0 <= i < |old(elements)| && old(elements)[i].0 == priority\n  ensures !removed ==> forall i :: 0 <= i < |old(elements)| ==> old(elements)[i].0 != priority\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  removed := false;\n  while i < |elements| && !removed\n    invariant 0 <= i <= |elements|\n    invariant !removed ==> forall k :: 0 <= k < i ==> elements[k].0 != priority\n    invariant removed ==> exists k :: 0 <= k < i && elements[k].0 == priority\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n  {\n    if elements[i].0 == priority {\n      elements := elements[..i] + elements[i+1..];\n      removed := true;\n    } else {\n      i := i + 1;\n    }\n  }\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\nmethod UpdatePriority(value: int, newPriority: int) returns (updated: bool)\n  modifies this\n  ensures updated ==> exists i :: 0 <= i < |old(elements)| && old(elements)[i].1 == value\n  ensures !updated ==> forall i :: 0 <= i < |old(elements)| ==> old(elements)[i].1 != value\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  updated := false;\n  while i < |elements| && !updated\n    invariant 0 <= i <= |elements|\n    invariant !updated ==> forall k :: 0 <= k < i ==> elements[k].1 != value\n    invariant updated ==> exists k :: 0 <= k < i && elements[k].1 == value\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n  {\n    if elements[i].1 == value {\n      elements := elements[..i] + elements[i+1..];\n      updated := true;\n    } else {\n      i := i + 1;\n    }\n  }\n  if updated {\n    Enqueue(newPriority, value);\n  }\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\nmethod FindMaxPriority() returns (maxPriority: int, value: int)\n  requires |elements| > 0\n  ensures exists i :: 0 <= i < |elements| && elements[i].0 == maxPriority && elements[i].1 == value\n  ensures forall i :: 0 <= i < |elements| ==> elements[i].0 <= maxPriority\n{\n  var i := 0;\n  maxPriority := elements[0].0;\n  value := elements[0].1;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant exists j :: 0 <= j < i && elements[j].0 == maxPriority && elements[j].1 == value\n    invariant forall j :: 0 <= j < i ==> elements[j].0 <= maxPriority\n  {\n    if elements[i].0 > maxPriority {\n      maxPriority := elements[i].0;\n      value := elements[i].1;\n    }\n    i := i + 1;\n  }\n}\n}",
            "parents": [
                "2b547791-24c9-4ea8-91c5-d849dd6892af"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "45567ac7-3d94-4b66-8777-4fd0db8bfca5",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\nmethod UpdatePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures forall i :: 0 <= i < |elements| ==> elements[i].1 != value || elements[i].0 == newPriority\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n\n  // Remove the element with the old priority\n  elements := elements[..i] + elements[i+1..];\n\n  // Reinsert the element with the new priority\n  var newElement := (newPriority, value);\n  i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [newElement] + elements[i..];\n}\nmethod Merge(other: PriorityQueue)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures |elements| == old(|elements|) + |other.elements|\n  ensures forall e :: e in other.elements ==> e in elements\n{\n  var i := 0;\n  while i < |other.elements|\n    invariant 0 <= i <= |other.elements|\n    invariant |elements| == old(|elements|) + i\n    invariant forall j, k :: 0 <= j < k < |elements| ==> elements[j].0 <= elements[k].0\n    invariant forall e :: e in other.elements[..i] ==> e in elements\n  {\n    var (priority, value) := other.elements[i];\n    this.Enqueue(priority, value);\n    i := i + 1;\n  }\n}\nmethod RemoveAllWithPriority(priority: int)\n  modifies this\n  ensures forall i :: 0 <= i < |elements| ==> elements[i].0 != priority\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 != priority\n    invariant forall j, k :: 0 <= j < k < |elements| ==> elements[j].0 <= elements[k].0\n  {\n    if elements[i].0 == priority {\n      elements := elements[..i] + elements[i+1..];\n    } else {\n      i := i + 1;\n    }\n  }\n}\n}",
            "parents": [
                "bcd26e3b-ff15-48a7-87af-f7ced2eb9c56"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "ab71fddc-8dde-482e-8579-5ec5bd7cd4b3",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p < right ==> arr[p] > pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n    invariant forall r: int :: left <= r < i ==> arr[r] <= pivot\n    invariant forall s: int :: i <= s < j ==> arr[s] > pivot\n    invariant forall t: int :: j <= t <= right ==> arr[t] >= pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n    invariant forall r: int :: left <= r < i ==> arr[r] <= pivot\n    invariant forall s: int :: i <= s < j ==> arr[s] > pivot\n    invariant forall t: int :: j <= t <= right ==> arr[t] >= pivot\n    invariant forall u: int :: left <= u < j ==> arr[u] <= pivot || arr[u] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\nfor j := left to right - 1\n  invariant left <= i <= j <= right\n  invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n  invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n  invariant forall q: int :: left <= q <= right ==> \n            (arr[q] <= pivot || arr[q] > pivot)\n  invariant forall r: int :: left <= r < i ==> arr[r] <= pivot\n  invariant forall s: int :: i <= s < j ==> arr[s] > pivot\n  invariant forall t: int :: j <= t <= right ==> arr[t] >= pivot\n  invariant forall u: int :: left <= u < j ==> arr[u] <= pivot || arr[u] > pivot\n  invariant forall v: int :: left <= v < i ==> arr[v] <= pivot\n  invariant forall w: int :: i <= w <= j ==> arr[w] > pivot\n  invariant forall x: int :: j < x <= right ==> arr[x] >= pivot\n{\n  if arr[j] <= pivot {\n    arr[i], arr[j] := arr[j], arr[i];\n    i := i + 1;\n  }\n}\narr[i], arr[right] := arr[right], arr[i];\nreturn i;\n}",
            "parents": [
                "2ed5452d-1c00-499f-8c92-f6eb81374f61"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "1ae24b06-f583-4ecf-976e-8e69df746946",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures elements == old(elements)\n  ensures value == old(elements[0].1)\n{\n  value := elements[0].1;\n}\nmethod ChangePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n{\n  var index := 0;\n  while index < |elements| && elements[index].1 != value\n    invariant 0 <= index <= |elements|\n    invariant forall k :: 0 <= k < index ==> elements[k].1 != value\n  {\n    index := index + 1;\n  }\n  elements := elements[..index] + elements[index + 1..];\n  \n  var i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [(newPriority, value)] + elements[i..];\n}\nmethod RemoveValue(value: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures forall i :: 0 <= i < |elements| ==> elements[i].1 != value\n{\n  var index := 0;\n  while index < |elements| && elements[index].1 != value\n    invariant 0 <= index <= |elements|\n    invariant forall k :: 0 <= k < index ==> elements[k].1 != value\n  {\n    index := index + 1;\n  }\n  elements := elements[..index] + elements[index + 1..];\n}\n}",
            "parents": [
                "6bb09b32-dbe7-4c37-9e1b-698104bfd03e"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "c3f6fe5d-326c-4a3f-bf11-2b91d2c7e1ca",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method IsEmpty() returns (empty: bool)\n    ensures empty == (|elements| == 0)\n  {\n    var i := 0;\n    empty := true;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant empty == (i == 0)\n    {\n      empty := false;\n      i := i + 1;\n    }\n  }\n  method Merge(other: PriorityQueue)\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures |elements| == |old(elements)| + |other.elements|\n    ensures multiset(elements) == multiset(old(elements) + other.elements)\n  {\n    var merged: seq<(int, int)> := [];\n    var i := 0;\n    var j := 0;\n\n    while i < |elements| || j < |other.elements|\n      invariant 0 <= i <= |elements|\n      invariant 0 <= j <= |other.elements|\n      invariant |merged| == i + j\n      invariant forall k, l :: 0 <= k < l < |merged| ==> merged[k].0 <= merged[l].0\n      invariant multiset(merged) == multiset(old(elements[..i]) + other.elements[..j])\n    {\n      if i < |elements| && (j >= |other.elements| || elements[i].0 <= other.elements[j].0) {\n        merged := merged + [elements[i]];\n        i := i + 1;\n      } else {\n        merged := merged + [other.elements[j]];\n        j := j + 1;\n      }\n    }\n    elements := merged;\n  }\nmethod FindMaxPriority() returns (maxValue: int)\n  requires |elements| > 0\n  ensures exists i :: 0 <= i < |elements| && elements[i].1 == maxValue\n  ensures forall j :: 0 <= j < |elements| ==> elements[j].0 <= elements[0].0\n{\n  var maxPriority := elements[0].0;\n  maxValue := elements[0].1;\n  var i := 1;\n  while i < |elements|\n    invariant 1 <= i <= |elements|\n    invariant exists j :: 0 <= j < i && elements[j].1 == maxValue\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= maxPriority\n  {\n    if elements[i].0 > maxPriority {\n      maxPriority := elements[i].0;\n      maxValue := elements[i].1;\n    }\n    i := i + 1;\n  }\n}\n}",
            "parents": [
                "eef891a4-6118-472f-ba5a-5cb6df83bb4c"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "bea629b9-e69a-42bc-8ab1-6e7e32173b87",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n{\n  value := elements[0].1;\n}\nmethod UpdatePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n{\n  var i := 0;\n  // Find the index of the element with the given value\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n  assert i < |elements|; // Element with the given value exists\n\n  // Remove the element\n  elements := elements[..i] + elements[i+1..];\n\n  // Reinsert the element with the new priority\n  var newElement := (newPriority, value);\n  var j := 0;\n  while j < |elements| && elements[j].0 <= newPriority\n    invariant 0 <= j <= |elements|\n    invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n    invariant forall k, l :: 0 <= k < l < j ==> elements[k].0 <= elements[l].0\n  {\n    j := j + 1;\n  }\n  elements := elements[..j] + [newElement] + elements[j..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\nmethod FindMaxPriority() returns (maxPriority: int)\n  requires |elements| > 0\n  ensures forall i :: 0 <= i < |elements| ==> elements[i].0 <= maxPriority\n  ensures exists i :: 0 <= i < |elements| && elements[i].0 == maxPriority\n{\n  var i := 0;\n  maxPriority := elements[0].0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= maxPriority\n    invariant exists k :: 0 <= k < i ==> elements[k].0 == maxPriority\n  {\n    if elements[i].0 > maxPriority {\n      maxPriority := elements[i].0;\n    }\n    i := i + 1;\n  }\n}\n}",
            "parents": [
                "32009f05-7c65-4f9c-abd6-5159e582c066"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "92b3c973-beda-49d5-b669-a63ce6e10563",
            "type": "program",
            "content": "class Graph {\n  var adjacencyMatrix: array2<bool>;\n\n  constructor(n: nat) \n    requires n > 0\n    ensures adjacencyMatrix.Length0 == n && adjacencyMatrix.Length1 == n\n    ensures forall i, j :: 0 <= i < n && 0 <= j < n ==> !adjacencyMatrix[i, j]\n  {\n    adjacencyMatrix := new bool[n, n];\n  }\n\n  method AddEdge(u: nat, v: nat)\n    requires 0 <= u < adjacencyMatrix.Length0\n    requires 0 <= v < adjacencyMatrix.Length1\n    modifies adjacencyMatrix\n    ensures adjacencyMatrix[u, v] && adjacencyMatrix[v, u]\n  {\n    adjacencyMatrix[u, v] := true;\n    adjacencyMatrix[v, u] := true;\n  }\n\n  method IsVertexCover(cover: set<nat>) returns (isCover: bool)\n    requires cover <= set i | 0 <= i < adjacencyMatrix.Length0\n    ensures isCover == (forall u, v :: 0 <= u < adjacencyMatrix.Length0 && 0 <= v < adjacencyMatrix.Length1 && adjacencyMatrix[u, v] ==> u in cover || v in cover)\n  {\n    isCover := true;\n    var n := adjacencyMatrix.Length0;\n    for u := 0 to n - 1 {\n      for v := 0 to n - 1 {\n        if adjacencyMatrix[u, v] && !(u in cover || v in cover) {\n          isCover := false;\n          return;\n        }\n      }\n    }\n  }\nmethod IsCompleteGraph() returns (isComplete: bool)\n  ensures isComplete == (forall u, v :: 0 <= u < adjacencyMatrix.Length0 && 0 <= v < adjacencyMatrix.Length1 && u != v ==> adjacencyMatrix[u, v])\n{\n  isComplete := true;\n  var n := adjacencyMatrix.Length0;\n  for u := 0 to n - 1\n    invariant 0 <= u <= n\n    invariant isComplete == (forall i, j :: 0 <= i < u && 0 <= j < n && i != j ==> adjacencyMatrix[i, j])\n  {\n    for v := 0 to n - 1\n      invariant 0 <= v <= n\n      invariant isComplete == (forall i, j :: 0 <= i < u && 0 <= j < n && i != j ==> adjacencyMatrix[i, j])\n      invariant isComplete == (forall j :: 0 <= j < v && u != j ==> adjacencyMatrix[u, j])\n    {\n      if u != v && !adjacencyMatrix[u, v] {\n        isComplete := false;\n        return;\n      }\n    }\n  }\n}\n}",
            "parents": [
                "4cdc8acf-bd53-4262-9f62-d262ebc0d72c"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "d97ca7cb-1a62-496d-96f5-fdb68b685040",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p < right ==> arr[p] > pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n    invariant forall r: int :: left <= r < j ==> arr[r] <= pivot || arr[r] > pivot\n    invariant forall s: int :: j <= s <= right ==> arr[s] >= pivot || arr[s] < pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\nfor j := left to right - 1\n  invariant left <= i <= j <= right\n  invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n  invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n  invariant forall q: int :: left <= q <= right ==> \n            (arr[q] <= pivot || arr[q] > pivot)\n  invariant forall r: int :: left <= r < i ==> arr[r] <= pivot\n  invariant forall s: int :: i <= s <= j ==> arr[s] > pivot\n  invariant forall t: int :: j < t <= right ==> arr[t] >= pivot\n  invariant forall u: int :: left <= u <= right ==> \n            (arr[u] < pivot || arr[u] == pivot || arr[u] > pivot)\n{\n  if arr[j] <= pivot {\n    arr[i], arr[j] := arr[j], arr[i];\n    i := i + 1;\n  }\n}\narr[i], arr[right] := arr[right], arr[i];\nreturn i;\n}",
            "parents": [
                "4bc9e5ca-6194-460b-8c11-365eb0f37499"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "ebc1864f-9d02-42f5-a4f2-e11f37586b67",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i - 1 ==> lis[k] <= lis[k + 1]\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k :: 0 <= k < i - 1 ==> lis[k] <= lis[k + 1]\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n  return maxLength;\n  // Compute optimized LIS values in a bottom-up manner with enhanced invariants\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i - 1 ==> lis[k] <= lis[k + 1]  // New invariant: lis is non-decreasing\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k :: 0 <= k < i - 1 ==> lis[k] <= lis[k + 1]  // Maintain non-decreasing order\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n  return maxLength;\n  // Compute optimized LIS values in a bottom-up manner with enhanced invariants\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i - 1 ==> lis[k] <= lis[k + 1]  // New invariant: lis is non-decreasing\n    invariant var sumLis := 0; forall k :: 0 <= k < i ==> sumLis == sumLis + lis[k]  // New invariant: sum of lis values\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k :: 0 <= k < i - 1 ==> lis[k] <= lis[k + 1]  // Maintain non-decreasing order\n      invariant var sumLisInner := 0; forall k :: 0 <= k < i ==> sumLisInner == sumLisInner + lis[k]  // Maintain sum of lis values\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n}",
            "parents": [
                "ef5e2ccb-f464-482e-bcda-f79412089a5a"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "fa5be51d-627c-416b-a66e-63acfeb27a87",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n    invariant forall r: int :: left <= r < i ==> arr[r] <= pivot\n    invariant forall s: int :: i <= s < j ==> arr[s] > pivot\n    invariant forall t: int :: j <= t <= right ==> arr[t] >= pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\nfor j := left to right - 1\n  invariant left <= i <= j <= right\n  invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n  invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n  invariant forall q: int :: left <= q <= right ==> \n            (arr[q] <= pivot || arr[q] > pivot)\n  invariant arr[right] == pivot\n{\n  if arr[j] <= pivot {\n    arr[i], arr[j] := arr[j], arr[i];\n    i := i + 1;\n  }\n}\narr[i], arr[right] := arr[right], arr[i];\nreturn i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n    invariant forall r: int :: i <= r <= j ==> arr[r] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "0443c66f-b4ad-4ba2-b2be-143c39f27448"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "c53abcc4-ff1f-4795-95d2-32a0896dac3d",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method IsEmpty() returns (empty: bool)\n    ensures empty == (|elements| == 0)\n  {\n    var i := 0;\n    empty := true;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant empty == (i == 0)\n    {\n      empty := false;\n      i := i + 1;\n    }\n  }\nmethod Merge(other: PriorityQueue)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures |elements| == |old(elements)| + |other.elements|\n  ensures multiset(elements) == multiset(old(elements) + other.elements)\n{\n  var merged: seq<(int, int)> := [];\n  var i := 0;\n  var j := 0;\n\n  while i < |elements| || j < |other.elements|\n    invariant 0 <= i <= |elements|\n    invariant 0 <= j <= |other.elements|\n    invariant |merged| == i + j\n    invariant forall k, l :: 0 <= k < l < |merged| ==> merged[k].0 <= merged[l].0\n    invariant multiset(merged) == multiset(old(elements[..i]) + other.elements[..j])\n  {\n    if i < |elements| && (j >= |other.elements| || elements[i].0 <= other.elements[j].0) {\n      merged := merged + [elements[i]];\n      i := i + 1;\n    } else {\n      merged := merged + [other.elements[j]];\n      j := j + 1;\n    }\n  }\n  elements := merged;\n}\nmethod IncreasePriority(value: int, newPriority: int)\n  requires |elements| > 0\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i].1 == value ==> elements[i].0 == newPriority\n{\n  var found := false;\n  var i := 0;\n  \n  // Find the element with the given value\n  while i < |elements| && !found\n    invariant 0 <= i <= |elements|\n    invariant !found ==> forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    if elements[i].1 == value {\n      found := true;\n    } else {\n      i := i + 1;\n    }\n  }\n  \n  if found {\n    // Remove the element and reinsert it with the new priority\n    var element := elements[i];\n    elements := elements[..i] + elements[i+1..];\n    \n    var j := 0;\n    while j < |elements| && elements[j].0 <= newPriority\n      invariant 0 <= j <= |elements|\n      invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < j ==> elements[k].0 <= elements[l].0\n    {\n      j := j + 1;\n    }\n    elements := elements[..j] + [(newPriority, element.1)] + elements[j..];\n  }\n}\nmethod FindMaxPriority() returns (maxPriority: int)\n  requires |elements| > 0\n  ensures maxPriority == elements[0].0 || exists i :: 0 <= i < |elements| && elements[i].0 == maxPriority\n  ensures forall i :: 0 <= i < |elements| ==> elements[i].0 <= maxPriority\n{\n  maxPriority := elements[0].0;\n  var i := 1;\n  while i < |elements|\n    invariant 1 <= i <= |elements|\n    invariant maxPriority == elements[0].0 || exists j :: 0 <= j < i && elements[j].0 == maxPriority\n    invariant forall j :: 0 <= j < i ==> elements[j].0 <= maxPriority\n  {\n    if elements[i].0 > maxPriority {\n      maxPriority := elements[i].0;\n    }\n    i := i + 1;\n  }\n}\n}",
            "parents": [
                "ec52d70e-5eea-44c1-b83c-00df356b28e8"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "36102cb8-ab48-4753-9384-c054cadcf540",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n{\n  value := elements[0].1;\n}\n}",
            "parents": [
                "a70cb0fe-ec4d-4ece-91ef-0b8fa644633c"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "05ef22d1-f2d3-48b9-b56e-95171697bf62",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant exists i: int :: left <= i <= right && \n              (forall j: int :: left <= j < i ==> arr[j] <= arr[i]) &&\n              (forall j: int :: i < j <= right ==> arr[j] >= arr[i])\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot ==> (exists r: int :: left <= r < i && arr[r] == arr[q])) ||\n              (arr[q] > pivot ==> (exists s: int :: i <= s <= j && arr[s] == arr[q]))\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "cf80252c-18f1-496e-8005-1cc5ffc665a8"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "de04ceef-9989-4299-add2-42d169de9b83",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n    ensures elements == old(elements)\n  {\n    var i := 0;\n    var highestPriority := elements[0].0;\n    value := elements[0].1;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= highestPriority\n      invariant exists k :: 0 <= k < |elements| && elements[k].0 == highestPriority && value == elements[k].1\n      invariant elements == old(elements)\n    {\n      if elements[i].0 < highestPriority {\n        highestPriority := elements[i].0;\n        value := elements[i].1;\n      }\n      i := i + 1;\n    }\n    assert value == elements[0].1;\n  }\nmethod UpdatePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n  ensures forall i :: 0 <= i < |elements| && elements[i].1 != value ==> elements[i] == old(elements[i])\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n  {\n    i := i + 1;\n  }\n  var updatedElement := (newPriority, value);\n  elements := elements[..i] + elements[i+1..];\n  var j := 0;\n  while j < |elements| && elements[j].0 <= newPriority\n    invariant 0 <= j <= |elements|\n    invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n    invariant forall k, l :: 0 <= k < l < j ==> elements[k].0 <= elements[l].0\n  {\n    j := j + 1;\n  }\n  elements := elements[..j] + [updatedElement] + elements[j..];\n}\nmethod Merge(other: PriorityQueue)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures |elements| == |old(elements)| + |other.elements|\n  ensures forall e :: e in old(elements) || e in other.elements ==> e in elements\n{\n  var i := 0;\n  var j := 0;\n  var merged: seq<(int, int)> := [];\n  while i < |elements| || j < |other.elements|\n    invariant 0 <= i <= |elements|\n    invariant 0 <= j <= |other.elements|\n    invariant |merged| == i + j\n    invariant forall k, l :: 0 <= k < l < |merged| ==> merged[k].0 <= merged[l].0\n    invariant forall e :: e in merged ==> e in old(elements) || e in other.elements\n  {\n    if i < |elements| && (j >= |other.elements| || elements[i].0 <= other.elements[j].0) {\n      merged := merged + [elements[i]];\n      i := i + 1;\n    } else {\n      merged := merged + [other.elements[j]];\n      j := j + 1;\n    }\n  }\n  elements := merged;\n}\n}",
            "parents": [
                "08c785c6-8073-4217-a7f6-3ceb73ff379c"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "1b123c63-860d-4b31-aa1c-82c3693447f5",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method IsEmpty() returns (empty: bool)\n    ensures empty == (|elements| == 0)\n  {\n    var i := 0;\n    empty := true;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant empty == (i == 0)\n    {\n      empty := false;\n      i := i + 1;\n    }\n  }\nmethod ChangePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var index := 0;\n  while index < |elements| && elements[index].1 != value\n    invariant 0 <= index <= |elements|\n    invariant forall k :: 0 <= k < index ==> elements[k].1 != value\n  {\n    index := index + 1;\n  }\n  var element := elements[index];\n  elements := elements[..index] + elements[index+1..];\n  \n  var i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [(newPriority, value)] + elements[i..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\n}",
            "parents": [
                "55d9d0e5-6f19-4a7e-b6e4-bb40226e663d"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "86ad5489-9c2b-4996-b63c-366c0143face",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n{\n  var i := 0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 >= elements[i].0\n  {\n    if elements[i].0 > elements[0].0 {\n      value := elements[i].1;\n      return;\n    }\n    i := i + 1;\n  }\n  value := elements[0].1;\n}\nmethod Merge(other: PriorityQueue)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures |elements| == |old(elements)| + |other.elements|\n{\n  var i := 0;\n  while i < |other.elements|\n    invariant 0 <= i <= |other.elements|\n    invariant forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0\n    invariant |elements| == |old(elements)| + i\n  {\n    var (priority, value) := other.elements[i];\n    Enqueue(priority, value);\n    i := i + 1;\n  }\n}\n}",
            "parents": [
                "223a0b93-3151-4812-9c68-627387fa2a84"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "2dd34ac8-894f-4ee0-acf9-535568a618f3",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n{\n  value := elements[0].1;\n}\nmethod IsEmpty() returns (empty: bool)\n  ensures empty == (|elements| == 0)\n{\n  var i := 0;\n  empty := true;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant empty == (i == 0)\n  {\n    empty := false;\n    i := i + 1;\n  }\n}\nmethod Size() returns (size: int)\n  ensures size == |elements|\n{\n  var count := 0;\n  var i := 0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant count == i\n  {\n    count := count + 1;\n    i := i + 1;\n  }\n  size := count;\n}\n}",
            "parents": [
                "97060160-b406-4839-8191-a29ff71a9361"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "d1d0eb78-2360-4eb6-af9e-fe4fda548ce5",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method UpdatePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n  {\n    var index := 0;\n    while index < |elements| && elements[index].1 != value\n      invariant 0 <= index <= |elements|\n      invariant forall k :: 0 <= k < index ==> elements[k].1 != value\n      invariant exists i :: 0 <= i < |elements| && elements[i].1 == value\n    {\n      index := index + 1;\n    }\n\n    // Remove the element with the specified value\n    var priority := elements[index].0;\n    elements := elements[..index] + elements[index + 1..];\n\n    // Reinsert the element with the new priority\n    var newElement := (newPriority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\nmethod FindMaxPriorityElement() returns (maxElement: (int, int))\n  requires |elements| > 0\n  ensures forall e :: e in elements ==> maxElement.0 >= e.0\n  ensures maxElement in elements\n{\n  var maxIndex := 0;\n  var i := 1;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant 0 <= maxIndex < |elements|\n    invariant forall j :: 0 <= j < i ==> elements[maxIndex].0 >= elements[j].0\n  {\n    if elements[i].0 > elements[maxIndex].0 {\n      maxIndex := i;\n    }\n    i := i + 1;\n  }\n  maxElement := elements[maxIndex];\n}\n}",
            "parents": [
                "8982ad71-0fe7-4130-b2d2-9b5fe25fe089"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "015e80aa-7ba3-483c-9e68-b09e93ba1cf1",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures elements == old(elements)\n    ensures value == elements[0].1\n  {\n    var highestPriority := elements[0].0;\n    var highestValue := elements[0].1;\n    var i := 1;\n    while i < |elements|\n      invariant 1 <= i <= |elements|\n      invariant highestPriority == elements[0].0\n      invariant highestValue == elements[0].1\n      invariant forall k :: 0 <= k < i ==> elements[k].0 >= highestPriority\n    {\n      if elements[i].0 < highestPriority {\n        highestPriority := elements[i].0;\n        highestValue := elements[i].1;\n      }\n      i := i + 1;\n    }\n    value := highestValue;\n  }\nmethod UpdatePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n  assert i < |elements|; // The element must exist due to the precondition\n  var updatedElement := (newPriority, value);\n  elements := elements[..i] + elements[i+1..];\n  \n  // Re-insert the updated element with new priority\n  var j := 0;\n  while j < |elements| && elements[j].0 <= newPriority\n    invariant 0 <= j <= |elements|\n    invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n    invariant forall k, l :: 0 <= k < l < j ==> elements[k].0 <= elements[l].0\n  {\n    j := j + 1;\n  }\n  elements := elements[..j] + [updatedElement] + elements[j..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\n}",
            "parents": [
                "bd156f4f-816e-440e-9293-1f374647163a"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "0f1548de-c7de-4300-9e7f-6095af0a9221",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      decreases |elements| - i\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\nmethod UpdatePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n    decreases |elements| - i\n  {\n    i := i + 1;\n  }\n  // Update the priority of the found element\n  elements := elements[..i] + [(newPriority, value)] + elements[i+1..];\n\n  // Reorder the queue to maintain the priority order\n  var j := i;\n  while j > 0 && elements[j-1].0 > newPriority\n    invariant 0 <= j <= |elements|\n    invariant forall k, l :: 0 <= k < l < j ==> elements[k].0 <= elements[l].0\n    decreases j\n  {\n    elements := elements[..j-1] + [elements[j]] + [elements[j-1]] + elements[j+1..];\n    j := j - 1;\n  }\n\n  while j < |elements|-1 && elements[j+1].0 < newPriority\n    invariant 0 <= j < |elements|\n    invariant forall k, l :: 0 <= k < l <= j ==> elements[k].0 <= elements[l].0\n    decreases |elements| - j\n  {\n    elements := elements[..j] + [elements[j+1]] + [elements[j]] + elements[j+2..];\n    j := j + 1;\n  }\n}\n}",
            "parents": [
                "6ca783b3-d9e6-4508-bb23-898b47d5267c"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "4da200e1-8a59-4c5b-9640-3ed7e2fe9bf9",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var index := -1;\n    var i := 0;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant index == -1 ==> forall k :: 0 <= k < i ==> elements[k].1 != value\n      invariant index != -1 ==> elements[index].1 == value\n      invariant index == -1 ==> elements == old(elements)\n    {\n      if elements[i].1 == value {\n        index := i;\n        break;\n      }\n      i := i + 1;\n    }\n    assert index != -1; // We should have found the element\n\n    // Remove the element\n    elements := elements[..index] + elements[index + 1..];\n\n    // Reinsert with new priority\n    var newElement := (newPriority, value);\n    i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant elements[..index] + elements[index..] == old(elements[..index] + elements[index + 1..])\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\nmethod RemoveByValue(value: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures forall i :: 0 <= i < |elements| ==> elements[i].1 != value\n{\n  var index := -1;\n  var i := 0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant index == -1 ==> forall k :: 0 <= k < i ==> elements[k].1 != value\n    invariant index != -1 ==> elements[index].1 == value\n    invariant index == -1 ==> elements == old(elements)\n  {\n    if elements[i].1 == value {\n      index := i;\n      break;\n    }\n    i := i + 1;\n  }\n  assert index != -1; // We should have found the element\n\n  // Remove the element\n  elements := elements[..index] + elements[index + 1..];\n  assert forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0;\n  assert forall i :: 0 <= i < |elements| ==> elements[i].1 != value;\n}\n}",
            "parents": [
                "b3bade4c-e82c-4453-b2ca-4289e9c2bf9d"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "c9b559f1-b3dc-4a6d-86a7-0c1eb95180c2",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures elements == old(elements)\n  ensures value == elements[0].1\n{\n  value := elements[0].1;\n}\nmethod UpdatePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n  // Remove the element with the old priority\n  elements := elements[..i] + elements[i+1..];\n  \n  // Reinsert the element with the new priority\n  var j := 0;\n  while j < |elements| && elements[j].0 <= newPriority\n    invariant 0 <= j <= |elements|\n    invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n  {\n    j := j + 1;\n  }\n  elements := elements[..j] + [(newPriority, value)] + elements[j..];\n}\n}",
            "parents": [
                "2ba00b51-9c46-4fbe-a1d7-f928e9e1b8bf"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "158c3d8c-b55f-48ad-a9cc-a48a1f68d704",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\nmethod IsEmpty() returns (empty: bool)\n  ensures empty <==> |elements| == 0\n{\n  var i := 0;\n  empty := true;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant empty <==> i == 0\n  {\n    empty := false;\n    i := i + 1;\n  }\n}\n}",
            "parents": [
                "1df27871-b52a-4cd7-8e6a-31b3004d1d17"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "8e90eded-26ff-4a53-8bbf-f1b14881c44a",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements[..i] + elements[i..] == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures elements == old(elements)\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(oldValue: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == oldValue\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, oldValue)\n  {\n    var i := 0;\n    // Find the element with the specified value\n    while i < |elements| && elements[i].1 != oldValue\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != oldValue\n      invariant exists j :: i <= j < |elements| && elements[j].1 == oldValue\n    {\n      i := i + 1;\n    }\n    // Remove the element\n    elements := elements[..i] + elements[i+1..];\n    \n    // Reinsert the element with the new priority\n    var newElement := (newPriority, oldValue);\n    var j := 0;\n    while j < |elements| && elements[j].0 <= newPriority\n      invariant 0 <= j <= |elements|\n      invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n      invariant elements[..j] + elements[j..] == elements[..i] + elements[i+1..]\n    {\n      j := j + 1;\n    }\n    elements := elements[..j] + [newElement] + elements[j..];\n  }\n  method RemoveAllWithPriority(priority: int)\n    modifies this\n    ensures forall i :: 0 <= i < |elements| ==> elements[i].0 != priority\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var i := 0;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 != priority\n      invariant forall m, n :: 0 <= m < n < |elements| ==> elements[m].0 <= elements[n].0\n    {\n      if elements[i].0 == priority {\n        elements := elements[..i] + elements[i+1..];\n      } else {\n        i := i + 1;\n      }\n    }\n  }\nmethod Merge(other: PriorityQueue)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures |elements| == |old(elements)| + |other.elements|\n  ensures forall e :: e in other.elements ==> e in elements\n{\n  var i := 0;\n  while i < |other.elements|\n    invariant 0 <= i <= |other.elements|\n    invariant forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0\n    invariant |elements| == |old(elements)| + i\n    invariant forall e :: e in other.elements[..i] ==> e in elements\n  {\n    var (priority, value) := other.elements[i];\n    this.Enqueue(priority, value);\n    i := i + 1;\n  }\n}\n}",
            "parents": [
                "d09e1a64-f1f7-4dcf-91dd-d4e65311d6ba"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "92187984-0b8a-4ac1-bf23-2b9ed3120806",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod UpdatePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n  \n  var oldElement := elements[i];\n  elements := elements[..i] + elements[i+1..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n\n  // Reinsert the element with the new priority\n  var newElement := (newPriority, value);\n  var j := 0;\n  while j < |elements| && elements[j].0 <= newPriority\n    invariant 0 <= j <= |elements|\n    invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n    invariant forall k, l :: 0 <= k < l < j ==> elements[k].0 <= elements[l].0\n  {\n    j := j + 1;\n  }\n  elements := elements[..j] + [newElement] + elements[j..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n{\n  value := elements[0].1;\n}\n}",
            "parents": [
                "12b2ce10-e684-47cd-90b6-5f651aff1ec1"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "b8389da0-5fd2-4517-9373-f6fee3fca60a",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  \n  constructor() {\n    elements := [];\n  }\n\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    var i := 0;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 >= elements[i].0\n      invariant forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0\n    {\n      if elements[i].0 > elements[0].0 {\n        value := elements[i].1;\n        return;\n      }\n      i := i + 1;\n    }\n    value := elements[0].1;\n  }\nmethod IsEmpty() returns (empty: bool)\n  ensures empty == (|elements| == 0)\n{\n  var i := 0;\n  empty := true;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant empty == (i == 0)\n  {\n    empty := false;\n    i := i + 1;\n  }\n}\n}",
            "parents": [
                "46b36410-52fd-4966-928e-d987471455f3"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "49f896c7-3354-4b06-9b47-5ec9ce3b6a1f",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures elements == old(elements)\n  ensures value == old(elements[0].1)\n{\n  value := elements[0].1;\n}\nmethod ChangePriority(oldValue: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == oldValue\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, oldValue)\n{\n  var i := 0;\n  // Find the element with the specified value\n  while i < |elements| && elements[i].1 != oldValue\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != oldValue\n  {\n    i := i + 1;\n  }\n  // Remove the element\n  elements := elements[..i] + elements[i+1..];\n  \n  // Reinsert the element with the new priority\n  var newElement := (newPriority, oldValue);\n  var j := 0;\n  while j < |elements| && elements[j].0 <= newPriority\n    invariant 0 <= j <= |elements|\n    invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n  {\n    j := j + 1;\n  }\n  elements := elements[..j] + [newElement] + elements[j..];\n}\nmethod Merge(other: PriorityQueue)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures |elements| == old(|elements|) + |other.elements|\n  ensures forall e :: e in other.elements ==> e in elements\n{\n  var i := 0;\n  while i < |other.elements|\n    invariant 0 <= i <= |other.elements|\n    invariant |elements| == old(|elements|) + i\n    invariant forall j, k :: 0 <= j < k < |elements| ==> elements[j].0 <= elements[k].0\n    invariant forall e :: e in other.elements[..i] ==> e in elements\n  {\n    var (priority, value) := other.elements[i];\n    this.Enqueue(priority, value);\n    i := i + 1;\n  }\n}\nmethod RemoveAllWithPriority(priority: int)\n  modifies this\n  ensures forall i :: 0 <= i < |elements| ==> elements[i].0 != priority\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant forall j :: 0 <= j < i ==> elements[j].0 != priority\n    invariant forall j, k :: 0 <= j < k < |elements| ==> elements[j].0 <= elements[k].0\n  {\n    if elements[i].0 == priority {\n      elements := elements[..i] + elements[i+1..];\n    } else {\n      i := i + 1;\n    }\n  }\n}\n}",
            "parents": [
                "add9b37b-529c-41d8-9a87-1190d778fa35"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "eecb38c6-a1e8-4dac-848c-704c1eb30cf7",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n  ensures elements == old(elements)\n{\n  var i := 0;\n  var highestPriority := elements[0].0;\n  value := elements[0].1;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= highestPriority\n    invariant value == elements[0].1\n  {\n    if elements[i].0 < highestPriority {\n      highestPriority := elements[i].0;\n      value := elements[i].1;\n    }\n    i := i + 1;\n  }\n  assert value == elements[0].1;\n}\nmethod IsEmpty() returns (empty: bool)\n  ensures empty <==> |elements| == 0\n{\n  empty := |elements| == 0;\n}\nmethod ChangePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  var found := false;\n  while i < |elements| && !found\n    invariant 0 <= i <= |elements|\n    invariant !found ==> forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    if elements[i].1 == value {\n      found := true;\n    } else {\n      i := i + 1;\n    }\n  }\n  if found {\n    var updatedElement := (newPriority, value);\n    elements := elements[..i] + elements[i+1..];\n    var j := 0;\n    while j < |elements| && elements[j].0 <= newPriority\n      invariant 0 <= j <= |elements|\n      invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < j ==> elements[k].0 <= elements[l].0\n    {\n      j := j + 1;\n    }\n    elements := elements[..j] + [updatedElement] + elements[j..];\n  }\n}\nmethod Merge(other: PriorityQueue)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures |elements| == |old(elements)| + |other.elements|\n  ensures forall e :: e in old(elements) || e in other.elements ==> e in elements\n{\n  var merged: seq<(int, int)> := [];\n  var i := 0;\n  var j := 0;\n  while i < |elements| || j < |other.elements|\n    invariant 0 <= i <= |elements|\n    invariant 0 <= j <= |other.elements|\n    invariant |merged| == i + j\n    invariant forall k, l :: 0 <= k < l < |merged| ==> merged[k].0 <= merged[l].0\n    invariant forall e :: e in merged ==> e in old(elements) || e in other.elements\n  {\n    if i < |elements| && (j >= |other.elements| || elements[i].0 <= other.elements[j].0) {\n      merged := merged + [elements[i]];\n      i := i + 1;\n    } else {\n      merged := merged + [other.elements[j]];\n      j := j + 1;\n    }\n  }\n  elements := merged;\n}\nmethod Remove(value: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures forall e :: e in old(elements) && e.1 != value ==> e in elements\n  ensures forall e :: e in elements ==> e in old(elements)\n{\n  var i := 0;\n  var found := false;\n  while i < |elements| && !found\n    invariant 0 <= i <= |elements|\n    invariant !found ==> forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    if elements[i].1 == value {\n      found := true;\n    } else {\n      i := i + 1;\n    }\n  }\n  if found {\n    elements := elements[..i] + elements[i+1..];\n  }\n}\n}",
            "parents": [
                "0646427e-f506-41ec-9740-52212d484c85"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "4f73f064-c3dd-43a9-8a23-011cc9924efe",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      decreases |elements| - i\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\nmethod IsEmpty() returns (empty: bool)\n  ensures empty <==> |elements| == 0\n{\n  var i := 0;\n  empty := true;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant empty <==> i == |elements|\n    decreases |elements| - i\n  {\n    empty := false;\n    i := i + 1;\n  }\n}\n}",
            "parents": [
                "e44448e8-3ef3-486e-ab38-710d987cec21"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "2a93c70b-5d1a-44f8-8e69-8a8fc19af630",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant exists i: int :: left <= i <= right && arr[i] == arr[k]\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> arr[q] >= pivot || q < i\n    invariant forall r: int :: left <= r <= right ==> arr[r] <= pivot || r >= i\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q < i ==> arr[q] <= pivot\n    invariant forall r: int :: i <= r <= j ==> arr[r] > pivot || arr[r] == pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "a167c201-463a-45b6-b3f1-1db748256467"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "80b53b40-449a-4e10-9a5b-63260bc04166",
            "type": "program",
            "content": "class Node {\n  var value: int\n  var left: Node?\n  var right: Node?\n  constructor(v: int) {\n    value := v;\n    left := null;\n    right := null;\n  }\n}\nclass BinarySearchTree {\n  var root: Node?\n  method Insert(v: int) \n    modifies this\n    ensures IsBST(root)\n  {\n    root := InsertHelper(root, v);\n  }\n  method InsertHelper(n: Node?, v: int) returns (result: Node?)\n    ensures IsBST(result)\n  {\n    if n == null {\n      return new Node(v);\n    }\n    if v < n.value {\n      n.left := InsertHelper(n.left, v);\n    } else if v > n.value {\n      n.right := InsertHelper(n.right, v);\n    }\n    return n;\n  }\n  predicate IsBST(n: Node?) \n    reads n\n  {\n    n == null || \n    (IsBST(n.left) && IsBST(n.right) &&\n     (n.left == null || MaxValue(n.left) < n.value) &&\n     (n.right == null || MinValue(n.right) > n.value))\n  }\n  function MaxValue(n: Node?): int\n    requires n != null\n    reads n\n  {\n    if n.right == null then n.value else MaxValue(n.right)\n  }\n  function MinValue(n: Node?): int\n    requires n != null\n    reads n\n  {\n    if n.left == null then n.value else MinValue(n.left)\n  }\nmethod Height(n: Node?) returns (h: int)\n  ensures h >= 0\n{\n  if n == null {\n    h := 0;\n  } else {\n    var leftHeight := Height(n.left);\n    var rightHeight := Height(n.right);\n    h := if leftHeight > rightHeight then leftHeight + 1 else rightHeight + 1;\n  }\n}\nmethod CountNodes(n: Node?) returns (count: int)\n  ensures count >= 0\n{\n  if n == null {\n    count := 0;\n  } else {\n    var leftCount: int;\n    var rightCount: int;\n    leftCount := CountNodes(n.left);\n    rightCount := CountNodes(n.right);\n    count := leftCount + rightCount + 1;\n  }\n}\n}",
            "parents": [
                "1d6ceaed-053e-49bd-9d0e-2a434d4a5387"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "SUCCESS"
            }
        },
        {
            "id": "6ca6a783-0034-4eb2-a963-79966c92f6cb",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n{\n  value := elements[0].1;\n}\nmethod ChangePriority(oldPriority: int, value: int, newPriority: int)\n  requires |elements| > 0\n  requires exists i :: 0 <= i < |elements| && elements[i] == (oldPriority, value)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n{\n  var i := 0;\n  while i < |elements| && elements[i] != (oldPriority, value)\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k] != (oldPriority, value)\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + elements[i+1..];\n  \n  var newElement := (newPriority, value);\n  i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [newElement] + elements[i..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\n}",
            "parents": [
                "be6823b5-37e8-4c49-9e27-d36ea3976379"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "d40b64c5-9eb5-49f4-8871-ea79ff06007a",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n    ensures elements == old(elements)\n  {\n    var i := 0;\n    var highestPriority := elements[0].0;\n    value := elements[0].1;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= highestPriority\n      invariant exists k :: 0 <= k < |elements| && elements[k].0 == highestPriority && value == elements[k].1\n      invariant elements == old(elements)\n    {\n      if elements[i].0 < highestPriority {\n        highestPriority := elements[i].0;\n        value := elements[i].1;\n      }\n      i := i + 1;\n    }\n    assert value == elements[0].1;\n  }\nmethod MaxPriority() returns (maxPriority: int)\n  requires |elements| > 0\n  ensures exists i :: 0 <= i < |elements| && elements[i].0 == maxPriority\n  ensures forall i :: 0 <= i < |elements| ==> elements[i].0 <= maxPriority\n  ensures elements == old(elements)\n{\n  var i := 0;\n  maxPriority := elements[0].0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant exists j :: 0 <= j < i && elements[j].0 == maxPriority\n    invariant forall j :: 0 <= j < i ==> elements[j].0 <= maxPriority\n    invariant elements == old(elements)\n  {\n    if elements[i].0 > maxPriority {\n      maxPriority := elements[i].0;\n    }\n    i := i + 1;\n  }\n  assert exists j :: 0 <= j < |elements| && elements[j].0 == maxPriority;\n  assert forall j :: 0 <= j < |elements| ==> elements[j].0 <= maxPriority;\n}\nmethod MinPriority() returns (minPriority: int)\n  requires |elements| > 0\n  ensures exists i :: 0 <= i < |elements| && elements[i].0 == minPriority\n  ensures forall i :: 0 <= i < |elements| ==> minPriority <= elements[i].0\n  ensures elements == old(elements)\n{\n  var i := 0;\n  minPriority := elements[0].0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant exists j :: 0 <= j < i && elements[j].0 == minPriority\n    invariant forall j :: 0 <= j < i ==> minPriority <= elements[j].0\n    invariant elements == old(elements)\n  {\n    if elements[i].0 < minPriority {\n      minPriority := elements[i].0;\n    }\n    i := i + 1;\n  }\n  assert exists j :: 0 <= j < |elements| && elements[j].0 == minPriority;\n  assert forall j :: 0 <= j < |elements| ==> minPriority <= elements[j].0;\n}\n}",
            "parents": [
                "02c36c95-bc47-411a-ac2a-6417f4b19be3"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "79fbe4b9-c48f-4ca4-b2f4-01576c9eed0c",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n    method Peek() returns (value: int)\n      requires |elements| > 0\n      ensures value == elements[0].1\n    {\n      value := elements[0].1;\n    }\nmethod UpdatePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  // Find the element with the given value\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n  // Remove the element\n  elements := elements[..i] + elements[i+1..];\n  \n  // Reinsert the element with the new priority\n  var newElement := (newPriority, value);\n  var j := 0;\n  while j < |elements| && elements[j].0 <= newPriority\n    invariant 0 <= j <= |elements|\n    invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n    invariant forall k, l :: 0 <= k < l < j ==> elements[k].0 <= elements[l].0\n    invariant forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0\n  {\n    j := j + 1;\n  }\n  elements := elements[..j] + [newElement] + elements[j..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\n}",
            "parents": [
                "f51ac2f4-60c1-445f-aaf6-c3281f8a480e"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "9f735dc8-712c-4299-8d8f-5824c9149ad8",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures elements == old(elements)\n  ensures value == elements[0].1\n{\n  var highestPriority := elements[0].0;\n  var highestValue := elements[0].1;\n  var i := 1;\n  while i < |elements|\n    invariant 1 <= i <= |elements|\n    invariant highestPriority == elements[0].0\n    invariant highestValue == elements[0].1\n    invariant forall k :: 0 <= k < i ==> elements[k].0 >= highestPriority\n  {\n    if elements[i].0 < highestPriority {\n      highestPriority := elements[i].0;\n      highestValue := elements[i].1;\n    }\n    i := i + 1;\n  }\n  value := highestValue;\n}\nmethod ChangePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n  // Remove the element with the specified value\n  elements := elements[..i] + elements[i+1..];\n  \n  // Re-insert the element with the new priority\n  var newElement := (newPriority, value);\n  i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [newElement] + elements[i..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\nmethod Merge(other: PriorityQueue)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  var j := 0;\n  var newElements: seq<(int, int)> := [];\n  \n  while i < |elements| || j < |other.elements|\n    invariant 0 <= i <= |elements|\n    invariant 0 <= j <= |other.elements|\n    invariant |newElements| == i + j\n    invariant forall k, l :: 0 <= k < l < |newElements| ==> newElements[k].0 <= newElements[l].0\n    invariant forall k :: 0 <= k < i ==> elements[k] in newElements\n    invariant forall k :: 0 <= k < j ==> other.elements[k] in newElements\n  {\n    if i < |elements| && (j >= |other.elements| || elements[i].0 <= other.elements[j].0) {\n      newElements := newElements + [elements[i]];\n      i := i + 1;\n    } else {\n      newElements := newElements + [other.elements[j]];\n      j := j + 1;\n    }\n  }\n  elements := newElements;\n}\nmethod RemoveAllWithPriority(priority: int)\n  modifies this\n  ensures forall i :: 0 <= i < |elements| ==> elements[i].0 != priority\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var newElements: seq<(int, int)> := [];\n  var i := 0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant |newElements| <= i\n    invariant forall k :: 0 <= k < |newElements| ==> newElements[k].0 != priority\n    invariant forall k, l :: 0 <= k < l < |newElements| ==> newElements[k].0 <= newElements[l].0\n  {\n    if elements[i].0 != priority {\n      newElements := newElements + [elements[i]];\n    }\n    i := i + 1;\n  }\n  elements := newElements;\n}\n}",
            "parents": [
                "e6fd6d5d-f2f0-4e21-bbd8-a6eeea60979f"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "2bebbaf6-de03-45f6-a7d3-28d9d21e12ec",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n    ensures elements == old(elements)\n  {\n    var i := 0;\n    var highestPriority := elements[0].0;\n    value := elements[0].1;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= highestPriority\n      invariant exists k :: 0 <= k < |elements| && elements[k].0 == highestPriority && value == elements[k].1\n      invariant elements == old(elements)\n    {\n      if elements[i].0 < highestPriority {\n        highestPriority := elements[i].0;\n        value := elements[i].1;\n      }\n      i := i + 1;\n    }\n    assert value == elements[0].1;\n  }\nmethod IsEmpty() returns (empty: bool)\n  ensures empty == (|elements| == 0)\n{\n  empty := true;\n  var i := 0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant empty == (i == 0)\n    invariant forall k :: 0 <= k < i ==> elements[k] == old(elements[k])\n  {\n    empty := false;\n    i := i + 1;\n  }\n}\n}",
            "parents": [
                "ed01b8bf-3675-436a-a9f0-b28fc6e74823"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "0c679037-6cb9-4b49-83ef-020884750fe1",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\nmethod ChangePriority(oldPriority: int, value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i] == (oldPriority, value)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |elements| && elements[i] != (oldPriority, value)\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k] != (oldPriority, value)\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + elements[i+1..];\n  var newElement := (newPriority, value);\n  i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [newElement] + elements[i..];\n}\nmethod Merge(other: PriorityQueue)\n  modifies this\n  ensures forall e :: e in other.elements ==> e in elements\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |other.elements|\n    invariant 0 <= i <= |other.elements|\n    invariant forall k :: 0 <= k < i ==> other.elements[k] in elements\n    invariant forall m, n :: 0 <= m < n < |elements| ==> elements[m].0 <= elements[n].0\n  {\n    var (priority, value) := other.elements[i];\n    Enqueue(priority, value);\n    i := i + 1;\n  }\n}\nmethod RemoveValue(value: int)\n  modifies this\n  ensures forall e :: e in elements ==> e.1 != value\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n    invariant forall m, n :: 0 <= m < n < |elements| ==> elements[m].0 <= elements[n].0\n  {\n    if elements[i].1 == value {\n      elements := elements[..i] + elements[i+1..];\n    } else {\n      i := i + 1;\n    }\n  }\n}\nmethod FindMaxPriority() returns (maxPriority: int)\n  requires |elements| > 0\n  ensures forall e :: e in elements ==> e.0 <= maxPriority\n  ensures exists e :: e in elements && e.0 == maxPriority\n{\n  var i := 0;\n  maxPriority := elements[0].0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= maxPriority\n    invariant exists k :: 0 <= k < |elements| && elements[k].0 == maxPriority\n  {\n    if elements[i].0 > maxPriority {\n      maxPriority := elements[i].0;\n    }\n    i := i + 1;\n  }\n}\nmethod UpdateValue(priority: int, newValue: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].0 == priority\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (priority, newValue)\n{\n  var i := 0;\n  while i < |elements| && elements[i].0 != priority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 != priority\n  {\n    i := i + 1;\n  }\n  if i < |elements| {\n    elements := elements[..i] + [(priority, newValue)] + elements[i+1..];\n  }\n}\n}",
            "parents": [
                "2c161f39-3bbf-4762-980d-326beef047ec"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "9635d81c-4d8c-4907-bde0-9f49ccf1b884",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n  // Reconstruct the longest increasing subsequence\n  var lisSequence := new int[maxLength];\n  var index := 0;\n  var currentIndex := 0;\n  // Find the index of the maximum length in lis array\n  for k := 0 to n - 1 {\n    if lis[k] == maxLength {\n      currentIndex := k;\n      break;\n    }\n  }\n  // Backtrack to find the sequence\n  while maxLength > 0\n    invariant 0 <= index < maxLength\n    invariant 0 <= currentIndex < n\n    invariant maxLength - index <= lis[currentIndex]\n  {\n    lisSequence[maxLength - 1] := arr[currentIndex];\n    maxLength := maxLength - 1;\n    for k := 0 to currentIndex - 1 {\n      if lis[k] == maxLength && arr[k] < arr[currentIndex] {\n        currentIndex := k;\n        break;\n      }\n    }\n  }\n  return lisSequence.Length;\n}",
            "parents": [
                "a7f1f348-389f-41d7-94bd-7701d98c6c7b"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "e25da69b-a348-4730-83a2-44f2483ff655",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures elements == old(elements)\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n  }\n  method IsEmpty() returns (empty: bool)\n    ensures empty == (|elements| == 0)\n  {\n    empty := |elements| == 0;\n  }\nmethod ChangePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n  var element := elements[i];\n  elements := elements[..i] + elements[i+1..];\n  \n  // Re-insert the element with the new priority\n  var newElement := (newPriority, value);\n  i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [newElement] + elements[i..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\n}",
            "parents": [
                "abb8f668-c715-4c64-87d8-9f2f2b65e522"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "af828686-cf8c-4b37-997b-20735f54b2ae",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n{\n  value := elements[0].1;\n}\nmethod ChangePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n  var oldElement := elements[i];\n  elements := elements[..i] + elements[i+1..];\n  var j := 0;\n  while j < |elements| && elements[j].0 <= newPriority\n    invariant 0 <= j <= |elements|\n    invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n    invariant forall k, l :: 0 <= k < l < j ==> elements[k].0 <= elements[l].0\n  {\n    j := j + 1;\n  }\n  elements := elements[..j] + [(newPriority, value)] + elements[j..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\nmethod RemoveValue(value: int) \n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures !exists i :: 0 <= i < |elements| && elements[i].1 == value\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + elements[i+1..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\nmethod MaxPriority() returns (maxPriority: int)\n  requires |elements| > 0\n  ensures exists i :: 0 <= i < |elements| && elements[i].0 == maxPriority\n  ensures forall i :: 0 <= i < |elements| ==> elements[i].0 <= maxPriority\n{\n  var i := 0;\n  maxPriority := elements[0].0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant exists j :: 0 <= j < i && elements[j].0 == maxPriority\n    invariant forall j :: 0 <= j < i ==> elements[j].0 <= maxPriority\n  {\n    if elements[i].0 > maxPriority {\n      maxPriority := elements[i].0;\n    }\n    i := i + 1;\n  }\n}\n}",
            "parents": [
                "e526fc38-6297-4a55-9b75-bbd8a428c406"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "25366ad1-1e72-4a53-84d8-4d6d22ffd205",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures elements == old(elements)\n  ensures value == elements[0].1\n{\n  var highestPriority := elements[0].0;\n  var highestValue := elements[0].1;\n  var i := 1;\n  while i < |elements|\n    invariant 1 <= i <= |elements|\n    invariant highestPriority == elements[0].0\n    invariant highestValue == elements[0].1\n    invariant forall k :: 0 <= k < i ==> elements[k].0 >= highestPriority\n  {\n    if elements[i].0 < highestPriority {\n      highestPriority := elements[i].0;\n      highestValue := elements[i].1;\n    }\n    i := i + 1;\n  }\n  value := highestValue;\n}\nmethod ChangePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n  // Remove the element with the specified value\n  elements := elements[..i] + elements[i+1..];\n  \n  // Re-insert the element with the new priority\n  var newElement := (newPriority, value);\n  i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [newElement] + elements[i..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\nmethod Merge(other: PriorityQueue)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |other.elements|\n    invariant 0 <= i <= |other.elements|\n    invariant forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0\n  {\n    var (priority, value) := other.elements[i];\n    var j := 0;\n    while j < |elements| && elements[j].0 <= priority\n      invariant 0 <= j <= |elements|\n      invariant forall k :: 0 <= k < j ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < j ==> elements[k].0 <= elements[l].0\n    {\n      j := j + 1;\n    }\n    elements := elements[..j] + [(priority, value)] + elements[j..];\n    i := i + 1;\n  }\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\nmethod RemoveByValue(value: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures forall i :: 0 <= i < |elements| ==> elements[i].1 != value\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + elements[i+1..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\n}",
            "parents": [
                "889d5f59-66f5-43ec-91a8-87078d992c32"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "5073494e-9c74-4da0-958c-187ddde2bd9a",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n{\n  value := elements[0].1;\n}\nmethod UpdatePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n{\n  var index := 0;\n  while index < |elements| && elements[index].1 != value\n    invariant 0 <= index <= |elements|\n    invariant forall k :: 0 <= k < index ==> elements[k].1 != value\n  {\n    index := index + 1;\n  }\n\n  // Remove the element with the specified value\n  var priority := elements[index].0;\n  elements := elements[..index] + elements[index + 1..];\n\n  // Reinsert the element with the new priority\n  var newElement := (newPriority, value);\n  var i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [newElement] + elements[i..];\n}\nmethod ChangePriority(currentPriority: int, value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i] == (currentPriority, value)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n{\n  var index := 0;\n  while index < |elements| && elements[index] != (currentPriority, value)\n    invariant 0 <= index <= |elements|\n    invariant forall k :: 0 <= k < index ==> elements[k] != (currentPriority, value)\n  {\n    index := index + 1;\n  }\n\n  // Remove the element with the specified current priority and value\n  elements := elements[..index] + elements[index + 1..];\n\n  // Reinsert the element with the new priority\n  var newElement := (newPriority, value);\n  var i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [newElement] + elements[i..];\n}\nmethod RemoveByValue(value: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures !exists i :: 0 <= i < |elements| && elements[i].1 == value\n{\n  var index := 0;\n  while index < |elements| && elements[index].1 != value\n    invariant 0 <= index <= |elements|\n    invariant forall k :: 0 <= k < index ==> elements[k].1 != value\n  {\n    index := index + 1;\n  }\n\n  // Remove the element with the specified value\n  elements := elements[..index] + elements[index + 1..];\n\n  // Ensure the sequence remains sorted by priority\n  assert forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0;\n}\n}",
            "parents": [
                "ce799535-df97-4a13-84d8-d84fe5a25b2a"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "91ef6e90-9199-42a0-be78-0f0da4f7dc5e",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n  ensures elements == old(elements)\n{\n  var i := 0;\n  var highestPriority := elements[0].0;\n  value := elements[0].1;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= highestPriority\n    invariant value == elements[0].1\n  {\n    if elements[i].0 < highestPriority {\n      highestPriority := elements[i].0;\n      value := elements[i].1;\n    }\n    i := i + 1;\n  }\n  assert value == elements[0].1;\n}\nmethod UpdatePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i].1 == value && elements[i].0 == newPriority\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n  var element := elements[i];\n  elements := elements[..i] + elements[i+1..]; // Remove the element\n  var newElement := (newPriority, element.1);\n\n  // Reinsert with new priority\n  i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [newElement] + elements[i..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\nmethod Remove(value: int) returns (found: bool)\n  modifies this\n  ensures found ==> !exists i :: 0 <= i < |elements| && elements[i].1 == value\n  ensures !found ==> elements == old(elements)\n{\n  var i := 0;\n  found := false;\n  while i < |elements| && !found\n    invariant 0 <= i <= |elements|\n    invariant !found ==> forall k :: 0 <= k < i ==> elements[k].1 != value\n    invariant found ==> !exists k :: 0 <= k < i && elements[k].1 == value\n  {\n    if elements[i].1 == value {\n      found := true;\n      elements := elements[..i] + elements[i+1..];\n    } else {\n      i := i + 1;\n    }\n  }\n  assert found ==> !exists k :: 0 <= k < |elements| && elements[k].1 == value;\n}\nmethod Merge(other: PriorityQueue)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures forall e :: e in other.elements ==> e in elements\n{\n  var i := 0;\n  while i < |other.elements|\n    invariant 0 <= i <= |other.elements|\n    invariant forall e :: e in other.elements[..i] ==> e in elements\n    invariant forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0\n  {\n    var (priority, value) := other.elements[i];\n    Enqueue(priority, value);\n    i := i + 1;\n  }\n  assert forall e :: e in other.elements ==> e in elements;\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\n}",
            "parents": [
                "06cfd3c5-2390-4a34-8fcd-d7ecddaaea4a"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "4e89ab7a-77aa-45b4-8e1d-a2f39f8a6a59",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures elements == old(elements)\n  ensures value == elements[0].1\n{\n  var highestPriority := elements[0].0;\n  var highestValue := elements[0].1;\n  var i := 1;\n  while i < |elements|\n    invariant 1 <= i <= |elements|\n    invariant highestPriority == elements[0].0\n    invariant highestValue == elements[0].1\n    invariant forall k :: 0 <= k < i ==> elements[k].0 >= highestPriority\n  {\n    if elements[i].0 < highestPriority {\n      highestPriority := elements[i].0;\n      highestValue := elements[i].1;\n    }\n    i := i + 1;\n  }\n  value := highestValue;\n}\nmethod IsEmpty() returns (empty: bool)\n  ensures empty == (|elements| == 0)\n{\n  var i := 0;\n  empty := true;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant empty == (i == 0)\n  {\n    empty := false;\n    i := i + 1;\n  }\n}\nmethod UpdatePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var index := 0;\n  var found := false;\n  while index < |elements| && !found\n    invariant 0 <= index <= |elements|\n    invariant !found ==> forall k :: 0 <= k < index ==> elements[k].1 != value\n  {\n    if elements[index].1 == value {\n      found := true;\n    } else {\n      index := index + 1;\n    }\n  }\n\n  if found {\n    var updatedElement := (newPriority, value);\n    elements := elements[..index] + elements[index + 1..];\n    var i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [updatedElement] + elements[i..];\n  }\n}\n}",
            "parents": [
                "d6eee4b3-c97c-4481-8fb1-c1f143515422"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "c5e1e621-0367-4423-b5b5-af6721643bd9",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  \n  constructor() {\n    elements := [];\n  }\n\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    var i := 0;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 >= elements[i].0\n      invariant forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0\n    {\n      if elements[i].0 > elements[0].0 {\n        value := elements[i].1;\n        return;\n      }\n      i := i + 1;\n    }\n    value := elements[0].1;\n  }\nmethod IsEmpty() returns (empty: bool)\n  ensures empty == (|elements| == 0)\n{\n  var i := 0;\n  empty := true;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant empty == (i == 0)\n  {\n    empty := false;\n    i := i + 1;\n  }\n}\n}",
            "parents": [
                "a4d15c75-3986-4d86-a258-d9575b39682b"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "41f1c706-2bbd-45ad-8109-a500869f1768",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures elements == old(elements)\n  ensures value == old(elements[0].1)\n{\n  value := elements[0].1;\n}\nmethod UpdatePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n{\n  var index := 0;\n  while index < |elements| && elements[index].1 != value\n    invariant 0 <= index <= |elements|\n    invariant forall k :: 0 <= k < index ==> elements[k].1 != value\n  {\n    index := index + 1;\n  }\n  var oldElement := elements[index];\n  elements := elements[..index] + elements[index + 1..];\n  \n  var i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [(newPriority, value)] + elements[i..];\n}\nmethod FindMaxPriority() returns (maxValue: int)\n  requires |elements| > 0\n  ensures exists i :: 0 <= i < |elements| && elements[i].1 == maxValue\n  ensures forall i :: 0 <= i < |elements| ==> elements[i].0 <= elements[0].0\n{\n  var maxPriority := elements[0].0;\n  maxValue := elements[0].1;\n  var i := 1;\n  while i < |elements|\n    invariant 1 <= i <= |elements|\n    invariant exists j :: 0 <= j < i && elements[j].1 == maxValue\n    invariant forall j :: 0 <= j < i ==> elements[j].0 <= maxPriority\n  {\n    if elements[i].0 > maxPriority {\n      maxPriority := elements[i].0;\n      maxValue := elements[i].1;\n    }\n    i := i + 1;\n  }\n}\nmethod Remove(value: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i :: 0 <= i < |elements| ==> elements[i].1 != value\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var index := 0;\n  while index < |elements| && elements[index].1 != value\n    invariant 0 <= index <= |elements|\n    invariant forall k :: 0 <= k < index ==> elements[k].1 != value\n  {\n    index := index + 1;\n  }\n  elements := elements[..index] + elements[index + 1..];\n}\n}",
            "parents": [
                "075e0f04-f19f-40e8-b602-b7875691b86c"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "cdf44e18-6c28-4d6d-b3c6-119940e12d94",
            "type": "program",
            "content": "// A simple program to verify that a given configuration of queens on a chessboard is valid\n// i.e., no two queens attack each other.\nmethod IsValidQueenConfiguration(board: seq<seq<bool>>) returns (valid: bool)\n  requires |board| == 8 && forall row :: 0 <= row < |board| ==> |board[row]| == 8\n  ensures valid == true <==> (forall i, j, k, l :: 0 <= i < 8 && 0 <= j < 8 && 0 <= k < 8 && 0 <= l < 8 && board[i][j] && board[k][l] ==> (i == k && j == l) || (i != k && j != l && i - j != k - l && i + j != k + l))\n{\n  valid := true;\n  var n := 8;\n  // Check each pair of queens to ensure they do not attack each other\n  for i := 0 to n - 1\n    invariant 0 <= i <= n\n    invariant valid == true ==> (forall x, y :: 0 <= x < i && 0 <= y < n && board[x][y] ==> (forall a, b :: 0 <= a < n && 0 <= b < n && board[a][b] && (x != a || y != b) ==> x != a && y != b && x - y != a - b && x + y != a + b))\n  {\n    for j := 0 to n - 1\n      invariant 0 <= j <= n\n      invariant valid == true ==> (forall x, y :: 0 <= x <= i && 0 <= y < j && board[x][y] ==> (forall a, b :: 0 <= a < n && 0 <= b < n && board[a][b] && (x != a || y != b) ==> x != a && y != b && x - y != a - b && x + y != a + b))\n    {\n      if board[i][j] {\n        for k := 0 to n - 1\n          invariant 0 <= k <= n\n          invariant valid == true ==> (forall x, y :: 0 <= x <= i && 0 <= y <= j && board[x][y] ==> (forall a, b :: 0 <= a < k && 0 <= b < n && board[a][b] && (x != a || y != b) ==> x != a && y != b && x - y != a - b && x + y != a + b))\n        {\n          for l := 0 to n - 1\n            invariant 0 <= l <= n\n            invariant valid == true ==> (forall x, y :: 0 <= x <= i && 0 <= y <= j && board[x][y] ==> (forall a, b :: 0 <= a <= k && 0 <= b < l && board[a][b] && (x != a || y != b) ==> x != a && y != b && x - y != a - b && x + y != a + b))\n          {\n            if board[k][l] && (i != k || j != l) {\n              // Check if they are in the same row, column, or diagonal\n              if i == k || j == l || i - j == k - l || i + j == k + l {\n                valid := false;\n                return;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n{\n  valid := true;\n  var n := 8;\n  var queenCount := 0;\n\n  // Count the number of queens on the board\n  for i := 0 to n - 1\n    invariant 0 <= i <= n\n    invariant 0 <= queenCount <= n * i\n  {\n    for j := 0 to n - 1\n      invariant 0 <= j <= n\n      invariant 0 <= queenCount <= n * i + j\n    {\n      if board[i][j] {\n        queenCount := queenCount + 1;\n      }\n    }\n  }\n\n  // Check if the number of queens is exactly 8\n  if queenCount != 8 {\n    valid := false;\n    return;\n  }\n\n  // Check each pair of queens to ensure they do not attack each other\n  for i := 0 to n - 1\n    invariant 0 <= i <= n\n    invariant valid == true ==> (forall x, y :: 0 <= x < i && 0 <= y < n && board[x][y] ==> (forall a, b :: 0 <= a < n && 0 <= b < n && board[a][b] && (x != a || y != b) ==> x != a && y != b && x - y != a - b && x + y != a + b))\n  {\n    for j := 0 to n - 1\n      invariant 0 <= j <= n\n      invariant valid == true ==> (forall x, y :: 0 <= x <= i && 0 <= y < j && board[x][y] ==> (forall a, b :: 0 <= a < n && 0 <= b < n && board[a][b] && (x != a || y != b) ==> x != a && y != b && x - y != a - b && x + y != a + b))\n    {\n      if board[i][j] {\n        for k := 0 to n - 1\n          invariant 0 <= k <= n\n          invariant valid == true ==> (forall x, y :: 0 <= x <= i && 0 <= y <= j && board[x][y] ==> (forall a, b :: 0 <= a < k && 0 <= b < n && board[a][b] && (x != a || y != b) ==> x != a && y != b && x - y != a - b && x + y != a + b))\n        {\n          for l := 0 to n - 1\n            invariant 0 <= l <= n\n            invariant valid == true ==> (forall x, y :: 0 <= x <= i && 0 <= y <= j && board[x][y] ==> (forall a, b :: 0 <= a <= k && 0 <= b < l && board[a][b] && (x != a || y != b) ==> x != a && y != b && x - y != a - b && x + y != a + b))\n          {\n            if board[k][l] && (i != k || j != l) {\n              // Check if they are in the same row, column, or diagonal\n              if i == k || j == l || i - j == k - l || i + j == k + l {\n                valid := false;\n                return;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n}",
            "parents": [
                "9cfc5a4a-d921-46fe-963b-e9ee7f9a2e53"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "09b77c5a-6f2d-4658-93af-18870ef38532",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n{\n  value := elements[0].1;\n}\nmethod ChangePriority(oldValue: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == oldValue\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, oldValue)\n  ensures |elements| == old(|elements|)\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != oldValue\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != oldValue\n  {\n    i := i + 1;\n  }\n\n  // Remove the element with oldValue\n  var removedElement := elements[i];\n  elements := elements[..i] + elements[i+1..];\n\n  // Insert the element with the new priority\n  var newElement := (newPriority, oldValue);\n  i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [newElement] + elements[i..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\nmethod Merge(other: PriorityQueue)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures |elements| == old(|elements|) + |other.elements|\n  ensures forall e :: e in other.elements ==> e in elements\n{\n  var i := 0;\n  var j := 0;\n  var merged: seq<(int, int)> := [];\n\n  while i < |elements| || j < |other.elements|\n    invariant 0 <= i <= |elements|\n    invariant 0 <= j <= |other.elements|\n    invariant |merged| == i + j\n    invariant forall k, l :: 0 <= k < l < |merged| ==> merged[k].0 <= merged[l].0\n    invariant forall e :: e in merged ==> e in old(elements) || e in other.elements\n  {\n    if i < |elements| && (j >= |other.elements| || elements[i].0 <= other.elements[j].0) {\n      merged := merged + [elements[i]];\n      i := i + 1;\n    } else {\n      merged := merged + [other.elements[j]];\n      j := j + 1;\n    }\n  }\n  elements := merged;\n}\nmethod RemoveValue(value: int) \n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures |elements| == old(|elements|) - 1\n  ensures forall e :: e in elements ==> e.1 != value\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n  {\n    i := i + 1;\n  }\n\n  // Remove the element with the specified value\n  elements := elements[..i] + elements[i+1..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\n}",
            "parents": [
                "66fdcb2f-b2cf-47e1-95ba-fa7d78da2ebe"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "SUCCESS"
            }
        },
        {
            "id": "4f56a2ae-252f-446c-b5a5-04953416e58d",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p < right ==> arr[p] > pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n    invariant forall r: int :: left <= r < i ==> arr[r] <= pivot\n    invariant forall s: int :: i <= s <= j ==> arr[s] > pivot\n    invariant forall t: int :: j < t <= right ==> arr[t] >= pivot\n    invariant forall u: int :: left <= u <= right ==> \n              (arr[u] < pivot || arr[u] == pivot || arr[u] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n    invariant forall r: int :: left <= r < i ==> arr[r] <= pivot\n    invariant forall s: int :: i <= s <= j ==> arr[s] > pivot\n    invariant forall t: int :: j < t <= right ==> arr[t] >= pivot\n    invariant forall u: int :: left <= u <= right ==> \n              (arr[u] < pivot || arr[u] == pivot || arr[u] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "542a2262-2675-4217-bd08-dc373530b604"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "c1f4be9d-80a5-44f8-bc67-babfa460ac9f",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    var updatedElement := (newPriority, value);\n    elements := elements[..i] + elements[i+1..];\n    \n    // Re-insert the updated element\n    var j := 0;\n    while j < |elements| && elements[j].0 <= newPriority\n      invariant 0 <= j <= |elements|\n      invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < j ==> elements[k].0 <= elements[l].0\n    {\n      j := j + 1;\n    }\n    elements := elements[..j] + [updatedElement] + elements[j..];\n  }\n  method RemoveValue(value: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i :: 0 <= i < |elements| ==> elements[i].1 != value\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + elements[i+1..];\n  }\nmethod IncreasePriority(value: int, increment: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n  {\n    i := i + 1;\n  }\n  var updatedElement := (elements[i].0 + increment, value);\n  elements := elements[..i] + elements[i+1..];\n  \n  // Re-insert the updated element with increased priority\n  var j := 0;\n  while j < |elements| && elements[j].0 <= updatedElement.0\n    invariant 0 <= j <= |elements|\n    invariant forall k :: 0 <= k < j ==> elements[k].0 <= updatedElement.0\n    invariant forall k, l :: 0 <= k < l < j ==> elements[k].0 <= elements[l].0\n  {\n    j := j + 1;\n  }\n  elements := elements[..j] + [updatedElement] + elements[j..];\n}\n}",
            "parents": [
                "21316b83-48c7-46e7-870f-7569ddf245df"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "6151a276-3c21-4f3c-9d7a-54ca82be88ea",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures elements == old(elements)\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(oldValue: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == oldValue\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, oldValue)\n  {\n    var i := 0;\n    // Find the element with the specified value\n    while i < |elements| && elements[i].1 != oldValue\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != oldValue\n    {\n      i := i + 1;\n    }\n    // Remove the element\n    elements := elements[..i] + elements[i+1..];\n    \n    // Reinsert the element with the new priority\n    var newElement := (newPriority, oldValue);\n    var j := 0;\n    while j < |elements| && elements[j].0 <= newPriority\n      invariant 0 <= j <= |elements|\n      invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n      invariant elements == old(elements[..i] + elements[i+1..])\n    {\n      j := j + 1;\n    }\n    elements := elements[..j] + [newElement] + elements[j..];\n  }\n  method Merge(other: PriorityQueue)\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures |elements| == old(|elements|) + |other.elements|\n    ensures forall e :: e in other.elements ==> e in elements\n  {\n    var i := 0;\n    while i < |other.elements|\n      invariant 0 <= i <= |other.elements|\n      invariant |elements| == old(|elements|) + i\n      invariant forall j, k :: 0 <= j < k < |elements| ==> elements[j].0 <= elements[k].0\n      invariant forall e :: e in other.elements[..i] ==> e in elements\n    {\n      var (priority, value) := other.elements[i];\n      this.Enqueue(priority, value);\n      i := i + 1;\n    }\n  }\nmethod DecreasePriority(value: int, decreaseAmount: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  requires decreaseAmount > 0\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (old(elements[i].0) - decreaseAmount, value)\n{\n  var i := 0;\n  // Find the element with the specified value\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n  // Remove the element\n  var oldPriority := elements[i].0;\n  elements := elements[..i] + elements[i+1..];\n  \n  // Reinsert the element with the decreased priority\n  var newPriority := oldPriority - decreaseAmount;\n  var newElement := (newPriority, value);\n  var j := 0;\n  while j < |elements| && elements[j].0 <= newPriority\n    invariant 0 <= j <= |elements|\n    invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n    invariant elements == old(elements[..i] + elements[i+1..])\n  {\n    j := j + 1;\n  }\n  elements := elements[..j] + [newElement] + elements[j..];\n}\nmethod RemoveValue(value: int)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures forall e :: e in old(elements) && e.1 != value ==> e in elements\n  ensures forall e :: e in elements ==> e.1 != value\n{\n  var i := 0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant forall j, k :: 0 <= j < k < |elements| ==> elements[j].0 <= elements[k].0\n    invariant forall e :: e in old(elements[..i]) && e.1 != value ==> e in elements\n  {\n    if elements[i].1 == value {\n      elements := elements[..i] + elements[i+1..];\n    } else {\n      i := i + 1;\n    }\n  }\n}\n}",
            "parents": [
                "4307888b-8d10-4632-b6c7-58bae6812192"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "f490fcf1-41e8-47bd-9b2a-2454fd1f5b4b",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures elements == old(elements)\n  ensures value == old(elements[0].1)\n{\n  value := elements[0].1;\n}\nmethod IsEmpty() returns (empty: bool)\n  ensures empty == (|elements| == 0)\n{\n  var i := 0;\n  empty := true;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant empty == (i == 0)\n  {\n    empty := false;\n    i := i + 1;\n  }\n}\nmethod UpdatePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n{\n  var index := 0;\n  while index < |elements| && elements[index].1 != value\n    invariant 0 <= index <= |elements|\n    invariant forall k :: 0 <= k < index ==> elements[k].1 != value\n  {\n    index := index + 1;\n  }\n\n  var element := elements[index];\n  elements := elements[..index] + elements[index + 1..];\n\n  var i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [(newPriority, value)] + elements[i..];\n}\n}",
            "parents": [
                "47ff9bac-d5ea-4f3a-8471-02581f09e109"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "0de4ba2b-d15c-467c-8f3f-03cf417ef75e",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var index := -1;\n    var i := 0;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant index == -1 ==> forall k :: 0 <= k < i ==> elements[k].1 != value\n      invariant index != -1 ==> elements[index].1 == value\n      invariant index == -1 ==> elements == old(elements)\n    {\n      if elements[i].1 == value {\n        index := i;\n        break;\n      }\n      i := i + 1;\n    }\n    assert index != -1; // We should have found the element\n\n    // Remove the element\n    elements := elements[..index] + elements[index + 1..];\n\n    // Reinsert with new priority\n    var newElement := (newPriority, value);\n    i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant elements[..index] + elements[index..] == old(elements[..index] + elements[index + 1..])\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Merge(other: PriorityQueue)\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures elements == old(elements) + old(other.elements)\n  {\n    var i := 0;\n    var j := 0;\n    var result: seq<(int, int)> := [];\n    while i < |elements| || j < |other.elements|\n      invariant 0 <= i <= |elements|\n      invariant 0 <= j <= |other.elements|\n      invariant forall k, l :: 0 <= k < l < |result| ==> result[k].0 <= result[l].0\n      invariant result + elements[i..] + other.elements[j..] == old(elements) + old(other.elements)\n    {\n      if i < |elements| && (j >= |other.elements| || elements[i].0 <= other.elements[j].0) {\n        result := result + [elements[i]];\n        i := i + 1;\n      } else {\n        result := result + [other.elements[j]];\n        j := j + 1;\n      }\n    }\n    elements := result;\n  }\nmethod RemoveByPriority(priority: int)\n  modifies this\n  ensures forall i :: 0 <= i < |elements| ==> elements[i].0 != priority\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 != priority\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n  {\n    if elements[i].0 == priority {\n      elements := elements[..i] + elements[i + 1..];\n    } else {\n      i := i + 1;\n    }\n  }\n  assert forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0;\n}\nmethod FindMaxPriority() returns (maxPriority: int)\n  requires |elements| > 0\n  ensures exists i :: 0 <= i < |elements| && elements[i].0 == maxPriority\n  ensures forall i :: 0 <= i < |elements| ==> elements[i].0 <= maxPriority\n{\n  var i := 0;\n  maxPriority := elements[0].0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant exists j :: 0 <= j < i && elements[j].0 == maxPriority\n    invariant forall j :: 0 <= j < i ==> elements[j].0 <= maxPriority\n  {\n    if elements[i].0 > maxPriority {\n      maxPriority := elements[i].0;\n    }\n    i := i + 1;\n  }\n}\n}",
            "parents": [
                "4c9c72f4-3e57-4d6a-8bf2-547a48fc90cb"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "bbd54b05-652b-4075-b10a-e7b0f9e25609",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures elements == old(elements)\n    ensures value == elements[0].1\n  {\n    var highestPriority := elements[0].0;\n    var highestValue := elements[0].1;\n    var i := 1;\n    while i < |elements|\n      invariant 1 <= i <= |elements|\n      invariant highestPriority == elements[0].0\n      invariant highestValue == elements[0].1\n      invariant forall k :: 0 <= k < i ==> elements[k].0 >= highestPriority\n    {\n      if elements[i].0 < highestPriority {\n        highestPriority := elements[i].0;\n        highestValue := elements[i].1;\n      }\n      i := i + 1;\n    }\n    value := highestValue;\n  }\n  method ChangePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n    {\n      i := i + 1;\n    }\n    // Remove the element with the specified value\n    elements := elements[..i] + elements[i+1..];\n    \n    // Re-insert the element with the new priority\n    var newElement := (newPriority, value);\n    i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\nmethod RemoveValue(value: int)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures forall i :: 0 <= i < |elements| ==> elements[i].1 != value\n{\n  var i := 0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n    invariant forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0\n  {\n    if elements[i].1 == value {\n      elements := elements[..i] + elements[i+1..];\n    } else {\n      i := i + 1;\n    }\n  }\n  assert forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0;\n  assert forall i :: 0 <= i < |elements| ==> elements[i].1 != value;\n}\n}",
            "parents": [
                "f4459605-baa8-46a1-9144-2895e6e19d8a"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "7e705b5f-0147-4942-a66c-db7b90f2028b",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var index := -1;\n    var i := 0;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant index == -1 ==> forall k :: 0 <= k < i ==> elements[k].1 != value\n      invariant index != -1 ==> elements[index].1 == value\n      invariant index == -1 ==> elements == old(elements)\n    {\n      if elements[i].1 == value {\n        index := i;\n        break;\n      }\n      i := i + 1;\n    }\n    assert index != -1; // We should have found the element\n\n    // Remove the element\n    elements := elements[..index] + elements[index + 1..];\n\n    // Reinsert with new priority\n    var newElement := (newPriority, value);\n    i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant elements[..index] + elements[index..] == old(elements[..index] + elements[index + 1..])\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Merge(other: PriorityQueue)\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures elements == old(elements) + old(other.elements)\n  {\n    var i := 0;\n    var j := 0;\n    var result: seq<(int, int)> := [];\n    while i < |elements| || j < |other.elements|\n      invariant 0 <= i <= |elements|\n      invariant 0 <= j <= |other.elements|\n      invariant forall k, l :: 0 <= k < l < |result| ==> result[k].0 <= result[l].0\n      invariant result + elements[i..] + other.elements[j..] == old(elements) + old(other.elements)\n    {\n      if i < |elements| && (j >= |other.elements| || elements[i].0 <= other.elements[j].0) {\n        result := result + [elements[i]];\n        i := i + 1;\n      } else {\n        result := result + [other.elements[j]];\n        j := j + 1;\n      }\n    }\n    elements := result;\n  }\nmethod RemoveByPriority(priority: int)\n  modifies this\n  ensures forall i :: 0 <= i < |elements| ==> elements[i].0 != priority\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 != priority\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n  {\n    if elements[i].0 == priority {\n      elements := elements[..i] + elements[i + 1..];\n    } else {\n      i := i + 1;\n    }\n  }\n  assert forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0;\n}\nmethod FindMaxPriority() returns (maxPriority: int)\n  requires |elements| > 0\n  ensures exists i :: 0 <= i < |elements| && elements[i].0 == maxPriority\n  ensures forall i :: 0 <= i < |elements| ==> elements[i].0 <= maxPriority\n{\n  var i := 0;\n  maxPriority := elements[0].0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant exists j :: 0 <= j < i && elements[j].0 == maxPriority\n    invariant forall j :: 0 <= j < i ==> elements[j].0 <= maxPriority\n  {\n    if elements[i].0 > maxPriority {\n      maxPriority := elements[i].0;\n    }\n    i := i + 1;\n  }\n}\nmethod FindMinPriority() returns (minPriority: int)\n  requires |elements| > 0\n  ensures exists i :: 0 <= i < |elements| && elements[i].0 == minPriority\n  ensures forall i :: 0 <= i < |elements| ==> elements[i].0 >= minPriority\n{\n  var i := 0;\n  minPriority := elements[0].0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant exists j :: 0 <= j < i && elements[j].0 == minPriority\n    invariant forall j :: 0 <= j < i ==> elements[j].0 >= minPriority\n  {\n    if elements[i].0 < minPriority {\n      minPriority := elements[i].0;\n    }\n    i := i + 1;\n  }\n}\n}",
            "parents": [
                "0de4ba2b-d15c-467c-8f3f-03cf417ef75e"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "af0632b8-3d12-44e5-81ac-d4c671c27824",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      decreases |elements| - i\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\nmethod UpdatePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n    decreases |elements| - i\n  {\n    i := i + 1;\n  }\n  assert i < |elements| && elements[i].1 == value;\n  elements := elements[..i] + elements[i+1..];\n  \n  // Re-insert with new priority\n  var newElement := (newPriority, value);\n  var j := 0;\n  while j < |elements| && elements[j].0 <= newPriority\n    invariant 0 <= j <= |elements|\n    invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n    invariant forall k, l :: 0 <= k < l < j ==> elements[k].0 <= elements[l].0\n    decreases |elements| - j\n  {\n    j := j + 1;\n  }\n  elements := elements[..j] + [newElement] + elements[j..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\nmethod RemoveValue(value: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures !exists i :: 0 <= i < |elements| && elements[i].1 == value\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n    decreases |elements| - i\n  {\n    i := i + 1;\n  }\n  assert i < |elements| && elements[i].1 == value;\n  elements := elements[..i] + elements[i+1..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\n}",
            "parents": [
                "67dc88b1-752b-4dbc-884f-7fd972b23cc4"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "fcd79252-c8a7-44f5-a5eb-75d9da8e1c42",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  \n  constructor() {\n    elements := [];\n  }\n\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\nmethod IsEmpty() returns (isEmpty: bool)\n  ensures isEmpty == (|elements| == 0)\n{\n  isEmpty := |elements| == 0;\n}\n}",
            "parents": [
                "484d78c6-113c-42af-b1b4-c7fc5108d3b1"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "684d56ca-9263-42c7-963a-43612a95bd55",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method UpdatePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures forall i :: 0 <= i < |elements| ==> elements[i].1 != value || elements[i].0 == newPriority\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n      invariant exists j :: i <= j < |elements| && elements[j].1 == value\n    {\n      i := i + 1;\n    }\n\n    // Remove the element with the old priority\n    elements := elements[..i] + elements[i+1..];\n\n    // Reinsert the element with the new priority\n    var newElement := (newPriority, value);\n    i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\nmethod Merge(other: PriorityQueue)\n  modifies this\n  ensures |elements| == |old(elements)| + |other.elements|\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures forall e :: e in old(elements) || e in other.elements ==> e in elements\n{\n  var merged: seq<(int, int)> := [];\n  var i := 0;\n  var j := 0;\n  while i < |elements| || j < |other.elements|\n    invariant 0 <= i <= |elements|\n    invariant 0 <= j <= |other.elements|\n    invariant |merged| == i + j\n    invariant forall k, l :: 0 <= k < l < |merged| ==> merged[k].0 <= merged[l].0\n    invariant forall e :: e in merged ==> e in old(elements) || e in other.elements\n  {\n    if i < |elements| && (j >= |other.elements| || elements[i].0 <= other.elements[j].0) {\n      merged := merged + [elements[i]];\n      i := i + 1;\n    } else {\n      merged := merged + [other.elements[j]];\n      j := j + 1;\n    }\n  }\n  elements := merged;\n}\nmethod RemoveAllWithPriority(priority: int)\n  modifies this\n  ensures forall i :: 0 <= i < |elements| ==> elements[i].0 != priority\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var newElements: seq<(int, int)> := [];\n  var i := 0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant |newElements| <= |elements|\n    invariant forall k :: 0 <= k < |newElements| ==> newElements[k].0 != priority\n    invariant forall k, l :: 0 <= k < l < |newElements| ==> newElements[k].0 <= newElements[l].0\n  {\n    if elements[i].0 != priority {\n      newElements := newElements + [elements[i]];\n    }\n    i := i + 1;\n  }\n  elements := newElements;\n}\n}",
            "parents": [
                "d5b40493-0f46-4a5c-a888-3282c87ee6e0"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "bfd7c8c8-65d8-49f9-adf3-14d7e2055fb0",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n    ensures elements == old(elements)\n  {\n    var i := 0;\n    var highestPriority := elements[0].0;\n    value := elements[0].1;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= highestPriority\n      invariant exists k :: 0 <= k < |elements| && elements[k].0 == highestPriority && value == elements[k].1\n      invariant elements == old(elements)\n    {\n      if elements[i].0 < highestPriority {\n        highestPriority := elements[i].0;\n        value := elements[i].1;\n      }\n      i := i + 1;\n    }\n    assert value == elements[0].1;\n  }\nmethod IsEmpty() returns (empty: bool)\n  ensures empty == (|elements| == 0)\n{\n  empty := true;\n  var i := 0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant empty == (i == 0)\n    invariant forall k :: 0 <= k < i ==> elements[k] == old(elements[k])\n  {\n    empty := false;\n    i := i + 1;\n  }\n}\nmethod ChangePriority(oldPriority: int, value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i] == (oldPriority, value)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n{\n  var i := 0;\n  while i < |elements| && elements[i] != (oldPriority, value)\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k] != (oldPriority, value)\n    invariant elements == old(elements)\n  {\n    i := i + 1;\n  }\n\n  // Remove the element with the old priority\n  elements := elements[..i] + elements[i+1..];\n\n  // Insert the element with the new priority\n  var j := 0;\n  while j < |elements| && elements[j].0 <= newPriority\n    invariant 0 <= j <= |elements|\n    invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n    invariant forall k, l :: 0 <= k < l < j ==> elements[k].0 <= elements[l].0\n    invariant elements == old(elements[..i] + elements[i+1..])\n  {\n    j := j + 1;\n  }\n  elements := elements[..j] + [(newPriority, value)] + elements[j..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\n}",
            "parents": [
                "2bebbaf6-de03-45f6-a7d3-28d9d21e12ec"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "ee99ec2e-60ab-4cfb-9d08-4baebc9fea6e",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  \n  constructor() {\n    elements := [];\n  }\n\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    var i := 0;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 >= elements[i].0\n      invariant forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0\n    {\n      if elements[i].0 > elements[0].0 {\n        value := elements[i].1;\n        return;\n      }\n      i := i + 1;\n    }\n    value := elements[0].1;\n  }\nmethod IsEmpty() returns (empty: bool)\n  ensures empty == (|elements| == 0)\n{\n  var i := 0;\n  empty := true;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant empty == (i == 0)\n  {\n    empty := false;\n    i := i + 1;\n  }\n}\nmethod Merge(other: PriorityQueue)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures |elements| == |old(elements)| + |other.elements|\n{\n  var i := 0;\n  var j := 0;\n  var merged: seq<(int, int)> := [];\n\n  while i < |elements| || j < |other.elements|\n    invariant 0 <= i <= |elements|\n    invariant 0 <= j <= |other.elements|\n    invariant |merged| == i + j\n    invariant forall k, l :: 0 <= k < l < |merged| ==> merged[k].0 <= merged[l].0\n  {\n    if i < |elements| && (j >= |other.elements| || elements[i].0 <= other.elements[j].0) {\n      merged := merged + [elements[i]];\n      i := i + 1;\n    } else {\n      merged := merged + [other.elements[j]];\n      j := j + 1;\n    }\n  }\n  elements := merged;\n}\n}",
            "parents": [
                "73e288f2-30fb-4600-8793-d5bfc53cfe18"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "9933700f-cb1b-41ec-ba89-a7011bc4da60",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(oldPriority: int, value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i] == (oldPriority, value)\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var i := 0;\n    while i < |elements| && elements[i] != (oldPriority, value)\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k] != (oldPriority, value)\n      invariant exists j :: i <= j < |elements| && elements[j] == (oldPriority, value)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + elements[i+1..];\n    var newElement := (newPriority, value);\n    i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n      invariant elements == old(elements[..i]) + old(elements[i..])\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Merge(other: PriorityQueue)\n    modifies this\n    ensures forall e :: e in other.elements ==> e in elements\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var i := 0;\n    while i < |other.elements|\n      invariant 0 <= i <= |other.elements|\n      invariant forall k :: 0 <= k < i ==> other.elements[k] in elements\n      invariant forall m, n :: 0 <= m < n < |elements| ==> elements[m].0 <= elements[n].0\n    {\n      var (priority, value) := other.elements[i];\n      Enqueue(priority, value);\n      i := i + 1;\n    }\n  }\nmethod RemoveByValue(value: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n    invariant exists j :: i <= j < |elements| && elements[j].1 == value\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + elements[i+1..];\n}\nmethod FindMaxPriority() returns (maxValue: int)\n  requires |elements| > 0\n  ensures exists i :: 0 <= i < |elements| && elements[i].1 == maxValue\n  ensures forall i :: 0 <= i < |elements| ==> elements[i].0 <= elements[0].0\n{\n  var maxPriority := elements[0].0;\n  maxValue := elements[0].1;\n  var i := 1;\n  while i < |elements|\n    invariant 1 <= i <= |elements|\n    invariant exists j :: 0 <= j < i && elements[j].1 == maxValue\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= maxPriority\n  {\n    if elements[i].0 > maxPriority {\n      maxPriority := elements[i].0;\n      maxValue := elements[i].1;\n    }\n    i := i + 1;\n  }\n}\n}",
            "parents": [
                "62bee572-9ea5-4367-9701-ed67a83bac26"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "811f4228-3324-4fc6-975e-cf4984679871",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i - 1 ==> lis[k] <= lis[k + 1]\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k :: 0 <= k < i - 1 ==> lis[k] <= lis[k + 1]\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n  return maxLength;\n  // Enhanced loop with additional invariants\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i - 1 ==> lis[k] <= lis[k + 1]\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k :: 0 <= k < i - 1 ==> lis[k] <= lis[k + 1]\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n}",
            "parents": [
                "06ba2f07-fbf7-430a-a181-3deb6d20bbe3"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "00d3bb26-c873-4dd7-894b-6e3acdba6d1b",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n{\n  value := elements[0].1;\n}\nmethod ChangePriority(oldPriority: int, value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i] == (oldPriority, value)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n{\n  var i := 0;\n  // Find the element with the old priority and value\n  while i < |elements| && elements[i] != (oldPriority, value)\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k] != (oldPriority, value)\n  {\n    i := i + 1;\n  }\n  // Remove the element\n  elements := elements[..i] + elements[i+1..];\n  \n  // Re-insert the element with the new priority\n  var newElement := (newPriority, value);\n  var j := 0;\n  while j < |elements| && elements[j].0 <= newPriority\n    invariant 0 <= j <= |elements|\n    invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n  {\n    j := j + 1;\n  }\n  elements := elements[..j] + [newElement] + elements[j..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\nmethod Merge(other: PriorityQueue)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |other.elements|\n    invariant 0 <= i <= |other.elements|\n    invariant forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0\n    invariant forall k :: 0 <= k < i ==> exists j :: 0 <= j < |elements| && elements[j] == other.elements[k]\n  {\n    var (priority, value) := other.elements[i];\n    var j := 0;\n    while j < |elements| && elements[j].0 <= priority\n      invariant 0 <= j <= |elements|\n      invariant forall k :: 0 <= k < j ==> elements[k].0 <= priority\n    {\n      j := j + 1;\n    }\n    elements := elements[..j] + [(priority, value)] + elements[j..];\n    i := i + 1;\n  }\n  assert forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0;\n}\n}",
            "parents": [
                "40be5413-b048-42ea-bd2b-6c9d3c81040d"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "c61b907e-c688-4c85-96b4-9c5f11136a13",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method UpdatePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures forall i :: 0 <= i < |elements| ==> elements[i].1 != value || elements[i].0 == newPriority\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n      invariant exists j :: i <= j < |elements| && elements[j].1 == value\n    {\n      i := i + 1;\n    }\n\n    // Remove the element with the old priority\n    elements := elements[..i] + elements[i+1..];\n\n    // Reinsert the element with the new priority\n    var newElement := (newPriority, value);\n    i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\nmethod RemoveByValue(value: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures forall i :: 0 <= i < |elements| ==> elements[i].1 != value\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n    invariant exists j :: i <= j < |elements| && elements[j].1 == value\n  {\n    i := i + 1;\n  }\n\n  // Remove the element with the specified value\n  elements := elements[..i] + elements[i+1..];\n}\nmethod Merge(other: PriorityQueue)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures |elements| == |old(elements)| + |other.elements|\n  ensures forall e :: e in other.elements ==> e in elements\n{\n  var i := 0;\n  var j := 0;\n  var merged: seq<(int, int)> := [];\n\n  while i < |elements| || j < |other.elements|\n    invariant 0 <= i <= |elements|\n    invariant 0 <= j <= |other.elements|\n    invariant |merged| == i + j\n    invariant forall k :: 0 <= k < |merged| ==> \n      (k < i ==> merged[k] == elements[k]) || \n      (k >= i ==> merged[k] == other.elements[k - i])\n    invariant forall k, l :: 0 <= k < l < |merged| ==> merged[k].0 <= merged[l].0\n  {\n    if i < |elements| && (j >= |other.elements| || elements[i].0 <= other.elements[j].0) {\n      merged := merged + [elements[i]];\n      i := i + 1;\n    } else {\n      merged := merged + [other.elements[j]];\n      j := j + 1;\n    }\n  }\n\n  elements := merged;\n}\n}",
            "parents": [
                "c959ee71-3228-4c16-a8eb-d49a50c09772"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "eedbac9d-ec9a-44d5-bba0-eecccf7a1787",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures elements == old(elements)\n  ensures value == elements[0].1\n{\n  value := elements[0].1;\n  assert elements == old(elements);\n}\n}",
            "parents": [
                "bd5753f9-6482-478c-b6fe-2ce7d06c361e"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "cb78bc26-6e77-4577-9cc9-c89d51b4fb27",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures elements == old(elements)\n    ensures value == elements[0].1\n  {\n    var highestPriority := elements[0].0;\n    var highestValue := elements[0].1;\n    var i := 1;\n    while i < |elements|\n      invariant 1 <= i <= |elements|\n      invariant highestPriority == elements[0].0\n      invariant highestValue == elements[0].1\n      invariant forall k :: 0 <= k < i ==> elements[k].0 >= highestPriority\n    {\n      if elements[i].0 < highestPriority {\n        highestPriority := elements[i].0;\n        highestValue := elements[i].1;\n      }\n      i := i + 1;\n    }\n    value := highestValue;\n  }\n  method ChangePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n    {\n      i := i + 1;\n    }\n    // Remove the element with the specified value\n    elements := elements[..i] + elements[i+1..];\n    \n    // Re-insert the element with the new priority\n    var newElement := (newPriority, value);\n    i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\nmethod RemoveByValue(value: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures forall i :: 0 <= i < |elements| ==> elements[i].1 != value\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n  // Remove the element with the specified value\n  elements := elements[..i] + elements[i+1..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\n}",
            "parents": [
                "f4459605-baa8-46a1-9144-2895e6e19d8a"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "8a7a04ec-4fb0-451e-a293-cae995a453df",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n{\n  value := elements[0].1;\n}\nmethod ChangePriority(oldValue: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == oldValue\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, oldValue)\n  ensures |elements| == old(|elements|)\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != oldValue\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != oldValue\n  {\n    i := i + 1;\n  }\n\n  // Remove the element with oldValue\n  var removedElement := elements[i];\n  elements := elements[..i] + elements[i+1..];\n\n  // Insert the element with the new priority\n  var newElement := (newPriority, oldValue);\n  i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [newElement] + elements[i..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\nmethod Merge(other: PriorityQueue)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures |elements| == old(|elements|) + |other.elements|\n  ensures forall e :: e in other.elements ==> e in elements\n{\n  var i := 0;\n  var j := 0;\n  var merged: seq<(int, int)> := [];\n\n  while i < |elements| || j < |other.elements|\n    invariant 0 <= i <= |elements|\n    invariant 0 <= j <= |other.elements|\n    invariant |merged| == i + j\n    invariant forall k, l :: 0 <= k < l < |merged| ==> merged[k].0 <= merged[l].0\n    invariant forall e :: e in merged ==> e in old(elements) || e in other.elements\n  {\n    if i < |elements| && (j >= |other.elements| || elements[i].0 <= other.elements[j].0) {\n      merged := merged + [elements[i]];\n      i := i + 1;\n    } else {\n      merged := merged + [other.elements[j]];\n      j := j + 1;\n    }\n  }\n  elements := merged;\n}\nmethod RemoveValue(value: int)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures forall e :: e in old(elements) && e.1 != value ==> e in elements\n  ensures forall e :: e in elements ==> e in old(elements) && e.1 != value\n{\n  var i := 0;\n  var newElements: seq<(int, int)> := [];\n  \n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant |newElements| <= i\n    invariant forall k, l :: 0 <= k < l < |newElements| ==> newElements[k].0 <= newElements[l].0\n    invariant forall e :: e in newElements ==> e in old(elements) && e.1 != value\n  {\n    if elements[i].1 != value {\n      newElements := newElements + [elements[i]];\n    }\n    i := i + 1;\n  }\n  \n  elements := newElements;\n}\n}",
            "parents": [
                "66fdcb2f-b2cf-47e1-95ba-fa7d78da2ebe"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "b94b6a9f-4005-436c-9ef3-4c6f274c8ebc",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures elements == old(elements)\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n  }\nmethod UpdatePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n{\n  var index := 0;\n  while index < |elements| && elements[index].1 != value\n    invariant 0 <= index <= |elements|\n    invariant forall k :: 0 <= k < index ==> elements[k].1 != value\n  {\n    index := index + 1;\n  }\n  var updatedElement := (newPriority, value);\n  elements := elements[..index] + elements[index + 1..];\n  var i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [updatedElement] + elements[i..];\n  assert forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0;\n}\n}",
            "parents": [
                "4596c890-ed7d-46c8-97d0-2e065b117389"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "dfa76a91-fe16-42fe-9b43-6825f3ffcc02",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p < right ==> arr[p] > pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n    invariant forall r: int :: left <= r < j ==> arr[r] <= pivot || arr[r] > pivot\n    invariant forall s: int :: j <= s <= right ==> arr[s] >= pivot || arr[s] < pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\nfor j := left to right - 1\n  invariant left <= i <= j <= right\n  invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n  invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n  invariant forall q: int :: left <= q <= right ==> \n            (arr[q] <= pivot || arr[q] > pivot)\n{\n  if arr[j] <= pivot {\n    arr[i], arr[j] := arr[j], arr[i];\n    i := i + 1;\n  }\n}\narr[i], arr[right] := arr[right], arr[i];\nreturn i;\nfor j := left to right - 1\n  invariant left <= i <= j <= right\n  invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n  invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n  invariant forall q: int :: left <= q <= right ==> \n            (arr[q] <= pivot || arr[q] > pivot)\n  invariant (forall x: int :: left <= x < j ==> arr[x] <= pivot) ==> i == j\n{\n  if arr[j] <= pivot {\n    arr[i], arr[j] := arr[j], arr[i];\n    i := i + 1;\n  }\n}\narr[i], arr[right] := arr[right], arr[i];\nreturn i;\n}",
            "parents": [
                "f038a5d8-275a-4dd5-90bc-387ecb85ff56"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "020e5af2-423b-47a4-8e22-96f2ef0aad99",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n    ensures elements == old(elements)\n  {\n    var i := 0;\n    var highestPriority := elements[0].0;\n    value := elements[0].1;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= highestPriority\n      invariant exists k :: 0 <= k < |elements| && elements[k].0 == highestPriority && value == elements[k].1\n      invariant forall k :: 0 <= k < |elements| ==> elements[k].0 >= highestPriority\n    {\n      if elements[i].0 < highestPriority {\n        highestPriority := elements[i].0;\n        value := elements[i].1;\n      }\n      i := i + 1;\n    }\n    assert value == elements[0].1;\n  }\n  method IsEmpty() returns (empty: bool)\n    ensures empty <==> |elements| == 0\n  {\n    empty := |elements| == 0;\n  }\n  method Merge(other: PriorityQueue)\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures |elements| == |old(elements)| + |other.elements|\n    ensures forall e :: e in old(elements) || e in other.elements ==> e in elements\n  {\n    var merged: seq<(int, int)> := [];\n    var i := 0;\n    var j := 0;\n    while i < |elements| || j < |other.elements|\n      invariant 0 <= i <= |elements|\n      invariant 0 <= j <= |other.elements|\n      invariant |merged| == i + j\n      invariant forall k, l :: 0 <= k < l < |merged| ==> merged[k].0 <= merged[l].0\n      invariant forall e :: e in merged ==> e in old(elements) || e in other.elements\n    {\n      if i < |elements| && (j >= |other.elements| || elements[i].0 <= other.elements[j].0) {\n        merged := merged + [elements[i]];\n        i := i + 1;\n      } else {\n        merged := merged + [other.elements[j]];\n        j := j + 1;\n      }\n    }\n    elements := merged;\n  }\nmethod RemoveByPriority(priority: int)\n  modifies this\n  ensures forall e :: e in old(elements) && e.0 != priority ==> e in elements\n  ensures forall e :: e in elements ==> e in old(elements) && e.0 != priority\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var newElements: seq<(int, int)> := [];\n  var i := 0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant |newElements| <= |elements|\n    invariant forall e :: e in newElements ==> e in old(elements) && e.0 != priority\n    invariant forall k, l :: 0 <= k < l < |newElements| ==> newElements[k].0 <= newElements[l].0\n  {\n    if elements[i].0 != priority {\n      newElements := newElements + [elements[i]];\n    }\n    i := i + 1;\n  }\n  elements := newElements;\n}\n}",
            "parents": [
                "b7103310-72b3-4ec3-aa5c-9af55e2f4c79"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "64acfb0d-3833-4c93-93ad-fffe7d9e2ffa",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n  ensures elements == old(elements)\n{\n  var i := 0;\n  var highestPriority := elements[0].0;\n  value := elements[0].1;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= highestPriority\n    invariant value == elements[0].1\n  {\n    if elements[i].0 < highestPriority {\n      highestPriority := elements[i].0;\n      value := elements[i].1;\n    }\n    i := i + 1;\n  }\n  assert value == elements[0].1;\n}\nmethod UpdatePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i].1 == value && elements[i].0 == newPriority\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n  var element := elements[i];\n  elements := elements[..i] + elements[i+1..]; // Remove the element\n  var newElement := (newPriority, element.1);\n\n  // Reinsert with new priority\n  i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [newElement] + elements[i..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\nmethod FindHighestPriority() returns (priority: int, value: int)\n  requires |elements| > 0\n  ensures exists i :: 0 <= i < |elements| && elements[i].0 == priority && elements[i].1 == value\n  ensures forall i :: 0 <= i < |elements| ==> elements[i].0 >= priority\n{\n  var i := 0;\n  priority := elements[0].0;\n  value := elements[0].1;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant exists j :: 0 <= j < i && elements[j].0 == priority && elements[j].1 == value\n    invariant forall k :: 0 <= k < i ==> elements[k].0 >= priority\n  {\n    if elements[i].0 < priority {\n      priority := elements[i].0;\n      value := elements[i].1;\n    }\n    i := i + 1;\n  }\n  assert exists j :: 0 <= j < |elements| && elements[j].0 == priority && elements[j].1 == value;\n  assert forall k :: 0 <= k < |elements| ==> elements[k].0 >= priority;\n}\n}",
            "parents": [
                "89697437-f527-44fc-8469-12398a118cdb"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "c58266e5-0da1-4cb8-82d9-d61e7bdaf061",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures elements == old(elements)\n    ensures value == elements[0].1\n  {\n    var highestPriority := elements[0].0;\n    var highestValue := elements[0].1;\n    var i := 1;\n    while i < |elements|\n      invariant 1 <= i <= |elements|\n      invariant highestPriority == elements[0].0\n      invariant highestValue == elements[0].1\n      invariant forall k :: 0 <= k < i ==> elements[k].0 >= highestPriority\n    {\n      if elements[i].0 < highestPriority {\n        highestPriority := elements[i].0;\n        highestValue := elements[i].1;\n      }\n      i := i + 1;\n    }\n    value := highestValue;\n  }\n  method ChangePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n    {\n      i := i + 1;\n    }\n    // Remove the element with the specified value\n    elements := elements[..i] + elements[i+1..];\n    \n    // Re-insert the element with the new priority\n    var newElement := (newPriority, value);\n    i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\nmethod RemoveByValue(value: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures !exists i :: 0 <= i < |elements| && elements[i].1 == value\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n  // Remove the element with the specified value\n  elements := elements[..i] + elements[i+1..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\nmethod FindHighestPriorityElement() returns (element: (int, int))\n  requires |elements| > 0\n  ensures element in elements\n  ensures forall e :: e in elements ==> e.0 >= element.0\n{\n  var highestPriorityElement := elements[0];\n  var i := 1;\n  while i < |elements|\n    invariant 1 <= i <= |elements|\n    invariant highestPriorityElement in elements[..i]\n    invariant forall k :: 0 <= k < i ==> elements[k].0 >= highestPriorityElement.0\n  {\n    if elements[i].0 < highestPriorityElement.0 {\n      highestPriorityElement := elements[i];\n    }\n    i := i + 1;\n  }\n  element := highestPriorityElement;\n}\n}",
            "parents": [
                "74a71cf0-0797-4522-bd43-542dd5c6d9ba"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "02f7efd3-0c97-4338-99dc-3adb14006d3c",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n    {\n      i := i + 1;\n    }\n    var oldElement := elements[i];\n    elements := elements[..i] + elements[i+1..];\n    var j := 0;\n    while j < |elements| && elements[j].0 <= newPriority\n      invariant 0 <= j <= |elements|\n      invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < j ==> elements[k].0 <= elements[l].0\n    {\n      j := j + 1;\n    }\n    elements := elements[..j] + [(newPriority, value)] + elements[j..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\nmethod RemoveByValue(value: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures !exists i :: 0 <= i < |elements| && elements[i].1 == value\n{\n  var i := 0;\n  // Find the element with the specified value\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n  // Remove the element\n  elements := elements[..i] + elements[i+1..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  assert !exists k :: 0 <= k < |elements| && elements[k].1 == value;\n}\n}",
            "parents": [
                "4648c11c-aef5-40df-bf70-a1496a11c09e"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "dee8aeb8-099b-48ad-aa17-57b2219b56d1",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures elements == old(elements)\n  ensures value == old(elements[0].1)\n{\n  value := elements[0].1;\n}\nmethod UpdatePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n{\n  var index := 0;\n  while index < |elements| && elements[index].1 != value\n    invariant 0 <= index <= |elements|\n    invariant forall k :: 0 <= k < index ==> elements[k].1 != value\n  {\n    index := index + 1;\n  }\n  var oldElement := elements[index];\n  elements := elements[..index] + elements[index + 1..];\n  \n  var i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [(newPriority, value)] + elements[i..];\n}\nmethod ChangeValue(priority: int, newValue: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].0 == priority\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (priority, newValue)\n{\n  var index := 0;\n  while index < |elements| && elements[index].0 != priority\n    invariant 0 <= index <= |elements|\n    invariant forall k :: 0 <= k < index ==> elements[k].0 != priority\n  {\n    index := index + 1;\n  }\n  elements := elements[..index] + [(priority, newValue)] + elements[index + 1..];\n}\n}",
            "parents": [
                "dc2486d8-1459-42bc-b96d-599284ab9427"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "594440b3-98cc-438b-98ef-d52f1a7fb0f3",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n    ensures elements == old(elements)\n  {\n    value := elements[0].1;\n  }\nmethod IsEmpty() returns (empty: bool)\n  ensures empty <==> |elements| == 0\n{\n  var i := 0;\n  empty := true;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant empty <==> i == 0\n  {\n    empty := false;\n    i := i + 1;\n  }\n}\n}",
            "parents": [
                "38d69495-71cd-4294-982f-364796a1a544"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "7f82a0d1-51d3-4627-bbd2-093727894d6e",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n\n  constructor() {\n    elements := [];\n  }\n\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\nmethod ChangePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n  {\n    i := i + 1;\n  }\n  var oldElement := elements[i];\n  elements := elements[..i] + elements[i+1..];\n  \n  // Re-insert the element with the new priority\n  var newElement := (newPriority, value);\n  var j := 0;\n  while j < |elements| && elements[j].0 <= newPriority\n    invariant 0 <= j <= |elements|\n    invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n    invariant forall k, l :: 0 <= k < l < j ==> elements[k].0 <= elements[l].0\n  {\n    j := j + 1;\n  }\n  elements := elements[..j] + [newElement] + elements[j..];\n}\n}",
            "parents": [
                "d90808c5-8a1b-42d1-a729-199a05e03f83"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "c4653a52-ca35-4840-959b-af753f71f198",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method UpdatePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures forall i :: 0 <= i < |elements| ==> elements[i].1 != value || elements[i].0 == newPriority\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n    {\n      i := i + 1;\n    }\n\n    // Remove the element with the old priority\n    elements := elements[..i] + elements[i+1..];\n\n    // Reinsert the element with the new priority\n    var newElement := (newPriority, value);\n    i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Merge(other: PriorityQueue)\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures |elements| == old(|elements|) + |other.elements|\n    ensures forall e :: e in other.elements ==> e in elements\n  {\n    var i := 0;\n    while i < |other.elements|\n      invariant 0 <= i <= |other.elements|\n      invariant |elements| == old(|elements|) + i\n      invariant forall j, k :: 0 <= j < k < |elements| ==> elements[j].0 <= elements[k].0\n      invariant forall e :: e in other.elements[..i] ==> e in elements\n    {\n      var (priority, value) := other.elements[i];\n      this.Enqueue(priority, value);\n      i := i + 1;\n    }\n  }\nmethod RemoveValue(value: int)\n  modifies this\n  ensures forall i :: 0 <= i < |elements| ==> elements[i].1 != value\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n    invariant forall j, k :: 0 <= j < k < |elements| ==> elements[j].0 <= elements[k].0\n  {\n    if elements[i].1 == value {\n      elements := elements[..i] + elements[i+1..];\n    } else {\n      i := i + 1;\n    }\n  }\n}\n}",
            "parents": [
                "97bc1739-1236-491b-88a2-e34f1e322792"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "1036f89e-6a07-4816-a9b7-5cd435101f25",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n{\n  value := elements[0].1;\n}\nmethod IsEmpty() returns (empty: bool)\n  ensures empty == (|elements| == 0)\n{\n  empty := |elements| == 0;\n}\nmethod FindMaxPriorityElement() returns (value: int)\n  requires |elements| > 0\n  ensures exists i :: 0 <= i < |elements| && elements[i].1 == value\n  ensures forall i :: 0 <= i < |elements| ==> elements[i].0 <= elements[0].0\n{\n  var maxPriority := elements[0].0;\n  value := elements[0].1;\n  var i := 1;\n  while i < |elements|\n    invariant 1 <= i <= |elements|\n    invariant elements[0].0 == maxPriority\n    invariant exists j :: 0 <= j < i && elements[j].1 == value\n    invariant forall j :: 0 <= j < i ==> elements[j].0 <= maxPriority\n  {\n    if elements[i].0 > maxPriority {\n      maxPriority := elements[i].0;\n      value := elements[i].1;\n    }\n    i := i + 1;\n  }\n}\nmethod Merge(other: PriorityQueue)\n  modifies this\n  ensures |elements| == old(|elements|) + |other.elements|\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |other.elements|\n    invariant 0 <= i <= |other.elements|\n    invariant |elements| == old(|elements|) + i\n    invariant forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0\n  {\n    this.Enqueue(other.elements[i].0, other.elements[i].1);\n    i := i + 1;\n  }\n}\n}",
            "parents": [
                "1f3492b8-3bad-4522-b9f7-12b54de7bad0"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "e50db80b-cae2-48bb-9034-9320d67e12ca",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures elements == old(elements)\n  ensures value == elements[0].1\n{\n  var i := 0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant elements == old(elements)\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= elements[i].0\n  {\n    if elements[i].0 > elements[0].0 {\n      break;\n    }\n    i := i + 1;\n  }\n  value := elements[0].1;\n}\nmethod ChangePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n    invariant exists j :: i <= j < |elements| && elements[j].1 == value\n  {\n    i := i + 1;\n  }\n  // Remove the element with the given value\n  elements := elements[..i] + elements[i+1..];\n  \n  // Insert the element with the new priority\n  var newElement := (newPriority, value);\n  var j := 0;\n  while j < |elements| && elements[j].0 <= newPriority\n    invariant 0 <= j <= |elements|\n    invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n  {\n    j := j + 1;\n  }\n  elements := elements[..j] + [newElement] + elements[j..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\nmethod PeekWithPriority() returns (priority: int, value: int)\n  requires |elements| > 0\n  ensures elements == old(elements)\n  ensures priority == elements[0].0 && value == elements[0].1\n{\n  var i := 0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant elements == old(elements)\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= elements[i].0\n  {\n    if elements[i].0 > elements[0].0 {\n      break;\n    }\n    i := i + 1;\n  }\n  priority := elements[0].0;\n  value := elements[0].1;\n}\n}",
            "parents": [
                "3a6fc050-18ae-46bc-964a-af0802b572c8"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "08b3c0aa-05c0-4d42-82a3-e0ca3b27442d",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n  ensures elements == old(elements)\n{\n  value := elements[0].1;\n}\nmethod RemoveByPriority(priority: int) returns (removed: bool)\n  modifies this\n  ensures removed ==> exists i :: 0 <= i < |old(elements)| && old(elements)[i].0 == priority\n  ensures !removed ==> forall i :: 0 <= i < |old(elements)| ==> old(elements)[i].0 != priority\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  removed := false;\n  while i < |elements| && !removed\n    invariant 0 <= i <= |elements|\n    invariant !removed ==> forall k :: 0 <= k < i ==> elements[k].0 != priority\n    invariant removed ==> exists k :: 0 <= k < i && elements[k].0 == priority\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n  {\n    if elements[i].0 == priority {\n      elements := elements[..i] + elements[i+1..];\n      removed := true;\n    } else {\n      i := i + 1;\n    }\n  }\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\nmethod UpdatePriority(value: int, newPriority: int) returns (updated: bool)\n  modifies this\n  ensures updated ==> exists i :: 0 <= i < |old(elements)| && old(elements)[i].1 == value\n  ensures !updated ==> forall i :: 0 <= i < |old(elements)| ==> old(elements)[i].1 != value\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  updated := false;\n  while i < |elements| && !updated\n    invariant 0 <= i <= |elements|\n    invariant !updated ==> forall k :: 0 <= k < i ==> elements[k].1 != value\n    invariant updated ==> exists k :: 0 <= k < i && elements[k].1 == value\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n  {\n    if elements[i].1 == value {\n      elements := elements[..i] + elements[i+1..];\n      updated := true;\n    } else {\n      i := i + 1;\n    }\n  }\n  if updated {\n    // Reinsert with new priority\n    var newElement := (newPriority, value);\n    var j := 0;\n    while j < |elements| && elements[j].0 <= newPriority\n      invariant 0 <= j <= |elements|\n      invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < j ==> elements[k].0 <= elements[l].0\n    {\n      j := j + 1;\n    }\n    elements := elements[..j] + [newElement] + elements[j..];\n  }\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\n}",
            "parents": [
                "a698038d-6b3e-4fc0-b679-6602c71bfbe1"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "87c7c59d-d9cf-458f-8b3f-e416133112f4",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures elements == old(elements)\n  ensures value == elements[0].1\n{\n  var i := 0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant elements == old(elements)\n    invariant elements[0].0 == old(elements[0].0)\n  {\n    if i == 0 {\n      value := elements[i].1;\n    }\n    i := i + 1;\n  }\n}\n}",
            "parents": [
                "33ed6d62-9431-44c6-8c34-4cfb35fea409"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "743de7d7-e0a6-48a2-8677-dea42e0ee79c",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n  ensures elements == old(elements)\n{\n  var i := 0;\n  var highestPriority := elements[0].0;\n  value := elements[0].1;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= highestPriority\n    invariant value == elements[0].1\n  {\n    if elements[i].0 < highestPriority {\n      highestPriority := elements[i].0;\n      value := elements[i].1;\n    }\n    i := i + 1;\n  }\n  assert value == elements[0].1;\n}\nmethod IsEmpty() returns (empty: bool)\n  ensures empty <==> |elements| == 0\n{\n  empty := |elements| == 0;\n}\nmethod ChangePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  var found := false;\n  while i < |elements| && !found\n    invariant 0 <= i <= |elements|\n    invariant !found ==> forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    if elements[i].1 == value {\n      found := true;\n    } else {\n      i := i + 1;\n    }\n  }\n  if found {\n    var updatedElement := (newPriority, value);\n    elements := elements[..i] + elements[i+1..];\n    var j := 0;\n    while j < |elements| && elements[j].0 <= newPriority\n      invariant 0 <= j <= |elements|\n      invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < j ==> elements[k].0 <= elements[l].0\n    {\n      j := j + 1;\n    }\n    elements := elements[..j] + [updatedElement] + elements[j..];\n  }\n}\nmethod Merge(other: PriorityQueue)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures |elements| == |old(elements)| + |other.elements|\n  ensures forall e :: e in old(elements) || e in other.elements ==> e in elements\n{\n  var merged: seq<(int, int)> := [];\n  var i := 0;\n  var j := 0;\n  while i < |elements| || j < |other.elements|\n    invariant 0 <= i <= |elements|\n    invariant 0 <= j <= |other.elements|\n    invariant |merged| == i + j\n    invariant forall k, l :: 0 <= k < l < |merged| ==> merged[k].0 <= merged[l].0\n    invariant forall e :: e in merged ==> e in old(elements) || e in other.elements\n  {\n    if i < |elements| && (j >= |other.elements| || elements[i].0 <= other.elements[j].0) {\n      merged := merged + [elements[i]];\n      i := i + 1;\n    } else {\n      merged := merged + [other.elements[j]];\n      j := j + 1;\n    }\n  }\n  elements := merged;\n}\nmethod RemoveValue(value: int)\n  modifies this\n  ensures forall e :: e in elements ==> e.1 != value\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var newElements: seq<(int, int)> := [];\n  var i := 0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant |newElements| <= |elements|\n    invariant forall e :: e in newElements ==> e.1 != value\n    invariant forall k, l :: 0 <= k < l < |newElements| ==> newElements[k].0 <= newElements[l].0\n  {\n    if elements[i].1 != value {\n      newElements := newElements + [elements[i]];\n    }\n    i := i + 1;\n  }\n  elements := newElements;\n}\n}",
            "parents": [
                "0646427e-f506-41ec-9740-52212d484c85"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "bba80eb3-4331-4d85-b809-b85f46ebd600",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures elements == old(elements)\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(oldValue: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == oldValue\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, oldValue)\n  {\n    var i := 0;\n    // Find the element with the specified value\n    while i < |elements| && elements[i].1 != oldValue\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != oldValue\n    {\n      i := i + 1;\n    }\n    // Remove the element\n    elements := elements[..i] + elements[i+1..];\n    \n    // Reinsert the element with the new priority\n    var newElement := (newPriority, oldValue);\n    var j := 0;\n    while j < |elements| && elements[j].0 <= newPriority\n      invariant 0 <= j <= |elements|\n      invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n      invariant elements == old(elements[..i] + elements[i+1..])\n    {\n      j := j + 1;\n    }\n    elements := elements[..j] + [newElement] + elements[j..];\n  }\n  method Merge(other: PriorityQueue)\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures |elements| == old(|elements|) + |other.elements|\n    ensures forall e :: e in other.elements ==> e in elements\n  {\n    var i := 0;\n    while i < |other.elements|\n      invariant 0 <= i <= |other.elements|\n      invariant |elements| == old(|elements|) + i\n      invariant forall j, k :: 0 <= j < k < |elements| ==> elements[j].0 <= elements[k].0\n      invariant forall e :: e in other.elements[..i] ==> e in elements\n    {\n      var (priority, value) := other.elements[i];\n      this.Enqueue(priority, value);\n      i := i + 1;\n    }\n  }\nmethod FindHighestPriority() returns (value: int)\n  requires |elements| > 0\n  ensures exists i :: 0 <= i < |elements| && elements[i].1 == value && \n          forall j :: 0 <= j < |elements| ==> elements[j].0 <= elements[i].0\n{\n  var highestPriority := elements[0].0;\n  var highestValue := elements[0].1;\n  var i := 1;\n  while i < |elements|\n    invariant 1 <= i <= |elements|\n    invariant exists j :: 0 <= j < i && elements[j].0 == highestPriority && elements[j].1 == highestValue\n    invariant forall j :: 0 <= j < i ==> elements[j].0 <= highestPriority\n  {\n    if elements[i].0 > highestPriority {\n      highestPriority := elements[i].0;\n      highestValue := elements[i].1;\n    }\n    i := i + 1;\n  }\n  value := highestValue;\n}\n}",
            "parents": [
                "c9d05711-3134-46e2-945d-cc69b31789af"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "1c50ce64-ab08-44ac-91eb-bee0425b7450",
            "type": "program",
            "content": "class Node {\n  var value: int\n  var left: Node?\n  var right: Node?\n  constructor(v: int) {\n    value := v;\n    left := null;\n    right := null;\n  }\n}\nclass BinarySearchTree {\n  var root: Node?\n  method Insert(v: int) \n    modifies this\n    ensures IsBST(root)\n  {\n    root := InsertHelper(root, v);\n  }\n  method InsertHelper(n: Node?, v: int) returns (result: Node?)\n    ensures IsBST(result)\n  {\n    if n == null {\n      return new Node(v);\n    }\n    if v < n.value {\n      n.left := InsertHelper(n.left, v);\n    } else if v > n.value {\n      n.right := InsertHelper(n.right, v);\n    }\n    return n;\n  }\n  predicate IsBST(n: Node?) \n    reads n\n  {\n    n == null || \n    (IsBST(n.left) && IsBST(n.right) &&\n     (n.left == null || MaxValue(n.left) < n.value) &&\n     (n.right == null || MinValue(n.right) > n.value))\n  }\n  function MaxValue(n: Node?): int\n    requires n != null\n    reads n\n  {\n    if n.right == null then n.value else MaxValue(n.right)\n  }\n  function MinValue(n: Node?): int\n    requires n != null\n    reads n\n  {\n    if n.left == null then n.value else MinValue(n.left)\n  }\nmethod Height(n: Node?) returns (h: int)\n  ensures h >= 0\n  ensures n == null ==> h == 0\n  ensures n != null ==> h > 0\n{\n  if n == null {\n    return 0;\n  }\n  var leftHeight := Height(n.left);\n  var rightHeight := Height(n.right);\n  h := if leftHeight > rightHeight then leftHeight + 1 else rightHeight + 1;\n}\n}",
            "parents": [
                "22783142-a2bc-4944-ae62-56eb89339981"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "19b3aacf-ce42-4b30-ad88-5514611c0513",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures elements == old(elements)\n  ensures value == old(elements[0].1)\n{\n  value := elements[0].1;\n}\nmethod IsEmpty() returns (empty: bool)\n  ensures empty <==> |elements| == 0\n{\n  empty := true;\n  var i := 0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant empty == (i == 0)\n  {\n    empty := false;\n    i := i + 1;\n  }\n}\nmethod UpdatePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var index := 0;\n  while index < |elements| && elements[index].1 != value\n    invariant 0 <= index <= |elements|\n    invariant forall k :: 0 <= k < index ==> elements[k].1 != value\n  {\n    index := index + 1;\n  }\n  var oldElement := elements[index];\n  elements := elements[..index] + elements[index + 1..];\n  \n  var i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [(newPriority, value)] + elements[i..];\n}\n}",
            "parents": [
                "5b356f32-3b1a-44eb-9286-1803f0e7030c"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "012297ef-bae7-48da-af45-f60403411e66",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures value == elements[0].1\n{\n  value := elements[0].1;\n}\nmethod IsEmpty() returns (empty: bool)\n  ensures empty <==> |elements| == 0\n{\n  var i := 0;\n  empty := true;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant empty <==> i == |elements|\n  {\n    empty := false;\n    i := i + 1;\n  }\n}\n\nmethod Clear()\n  modifies this\n  ensures |elements| == 0\n{\n  elements := [];\n}\n}",
            "parents": [
                "ba1aad7c-e85b-4420-81b9-1d2d39442b0d"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "d3fabbb6-fec7-466c-982b-f1568454f637",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures elements == old(elements)\n  ensures value == elements[0].1\n{\n  var highestPriority := elements[0].0;\n  var highestValue := elements[0].1;\n  var i := 1;\n  while i < |elements|\n    invariant 1 <= i <= |elements|\n    invariant highestPriority == elements[0].0\n    invariant highestValue == elements[0].1\n    invariant forall k :: 0 <= k < i ==> elements[k].0 >= highestPriority\n  {\n    if elements[i].0 < highestPriority {\n      highestPriority := elements[i].0;\n      highestValue := elements[i].1;\n    }\n    i := i + 1;\n  }\n  value := highestValue;\n}\nmethod ChangePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n  // Remove the element with the specified value\n  elements := elements[..i] + elements[i+1..];\n  \n  // Re-insert the element with the new priority\n  var newElement := (newPriority, value);\n  i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [newElement] + elements[i..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\nmethod Merge(other: PriorityQueue)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |other.elements|\n    invariant 0 <= i <= |other.elements|\n    invariant forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0\n  {\n    var (priority, value) := other.elements[i];\n    var j := 0;\n    while j < |elements| && elements[j].0 <= priority\n      invariant 0 <= j <= |elements|\n      invariant forall k :: 0 <= k < j ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < j ==> elements[k].0 <= elements[l].0\n    {\n      j := j + 1;\n    }\n    elements := elements[..j] + [(priority, value)] + elements[j..];\n    i := i + 1;\n  }\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\nmethod FindHighestPriorityElement() returns (element: (int, int))\n  requires |elements| > 0\n  ensures element in elements\n  ensures forall e :: e in elements ==> element.0 <= e.0\n{\n  var highestPriorityElement := elements[0];\n  var i := 1;\n  while i < |elements|\n    invariant 1 <= i <= |elements|\n    invariant highestPriorityElement in elements[..i]\n    invariant forall e :: e in elements[..i] ==> highestPriorityElement.0 <= e.0\n  {\n    if elements[i].0 < highestPriorityElement.0 {\n      highestPriorityElement := elements[i];\n    }\n    i := i + 1;\n  }\n  element := highestPriorityElement;\n}\n}",
            "parents": [
                "889d5f59-66f5-43ec-91a8-87078d992c32"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "bb88517a-4b61-4968-a97c-94f0c151c3ca",
            "type": "program",
            "content": "class Node {\n  var value: int\n  var left: Node?\n  var right: Node?\n  constructor(v: int) {\n    value := v;\n    left := null;\n    right := null;\n  }\n}\nclass BinarySearchTree {\n  var root: Node?\n  method Insert(v: int) \n    modifies this\n    ensures IsBST(root)\n  {\n    root := InsertHelper(root, v);\n  }\n  method InsertHelper(n: Node?, v: int) returns (result: Node?)\n    ensures IsBST(result)\n  {\n    if n == null {\n      return new Node(v);\n    }\n    if v < n.value {\n      n.left := InsertHelper(n.left, v);\n    } else if v > n.value {\n      n.right := InsertHelper(n.right, v);\n    }\n    return n;\n  }\n  predicate IsBST(n: Node?) \n    reads n\n  {\n    n == null || \n    (IsBST(n.left) && IsBST(n.right) &&\n     (n.left == null || MaxValue(n.left) < n.value) &&\n     (n.right == null || MinValue(n.right) > n.value))\n  }\n  function MaxValue(n: Node?): int\n    requires n != null\n    reads n\n  {\n    if n.right == null then n.value else MaxValue(n.right)\n  }\n  function MinValue(n: Node?): int\n    requires n != null\n    reads n\n  {\n    if n.left == null then n.value else MinValue(n.left)\n  }\nmethod Height(n: Node?) returns (h: int)\n  ensures h >= 0\n{\n  if n == null {\n    h := 0;\n  } else {\n    var leftHeight := Height(n.left);\n    var rightHeight := Height(n.right);\n    h := if leftHeight > rightHeight then leftHeight + 1 else rightHeight + 1;\n  }\n}\nmethod CountNodes(n: Node?) returns (count: int)\n  ensures count >= 0\n{\n  if n == null {\n    count := 0;\n  } else {\n    var leftCount: int;\n    var rightCount: int;\n    leftCount := CountNodes(n.left);\n    rightCount := CountNodes(n.right);\n    count := leftCount + rightCount + 1;\n  }\n}\nmethod SumValues(n: Node?) returns (sum: int)\n  ensures sum >= 0\n{\n  if n == null {\n    sum := 0;\n  } else {\n    var leftSum: int;\n    var rightSum: int;\n    leftSum := SumValues(n.left);\n    rightSum := SumValues(n.right);\n    sum := leftSum + rightSum + n.value;\n  }\n}\n}",
            "parents": [
                "80b53b40-449a-4e10-9a5b-63260bc04166"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "65084839-7d61-416d-9620-4b86c7da6536",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var index := -1;\n    var i := 0;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant index == -1 ==> forall k :: 0 <= k < i ==> elements[k].1 != value\n      invariant index != -1 ==> elements[index].1 == value\n      invariant index == -1 ==> elements == old(elements)\n    {\n      if elements[i].1 == value {\n        index := i;\n        break;\n      }\n      i := i + 1;\n    }\n    assert index != -1; // We should have found the element\n\n    // Remove the element\n    elements := elements[..index] + elements[index + 1..];\n\n    // Reinsert with new priority\n    var newElement := (newPriority, value);\n    i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant elements[..index] + elements[index..] == old(elements[..index] + elements[index + 1..])\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Merge(other: PriorityQueue)\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures elements == old(elements) + old(other.elements)\n  {\n    var i := 0;\n    var j := 0;\n    var result: seq<(int, int)> := [];\n    while i < |elements| || j < |other.elements|\n      invariant 0 <= i <= |elements|\n      invariant 0 <= j <= |other.elements|\n      invariant forall k, l :: 0 <= k < l < |result| ==> result[k].0 <= result[l].0\n      invariant result + elements[i..] + other.elements[j..] == old(elements) + old(other.elements)\n    {\n      if i < |elements| && (j >= |other.elements| || elements[i].0 <= other.elements[j].0) {\n        result := result + [elements[i]];\n        i := i + 1;\n      } else {\n        result := result + [other.elements[j]];\n        j := j + 1;\n      }\n    }\n    elements := result;\n  }\nmethod RemoveByPriority(priority: int)\n  modifies this\n  ensures forall i :: 0 <= i < |elements| ==> elements[i].0 != priority\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 != priority\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n  {\n    if elements[i].0 == priority {\n      elements := elements[..i] + elements[i + 1..];\n    } else {\n      i := i + 1;\n    }\n  }\n  assert forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0;\n}\nmethod FindMaxPriority() returns (maxPriority: int)\n  requires |elements| > 0\n  ensures exists i :: 0 <= i < |elements| && elements[i].0 == maxPriority\n  ensures forall i :: 0 <= i < |elements| ==> elements[i].0 <= maxPriority\n{\n  var i := 0;\n  maxPriority := elements[0].0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant exists j :: 0 <= j < i && elements[j].0 == maxPriority\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= maxPriority\n  {\n    if elements[i].0 > maxPriority {\n      maxPriority := elements[i].0;\n    }\n    i := i + 1;\n  }\n  assert exists j :: 0 <= j < |elements| && elements[j].0 == maxPriority;\n  assert forall k :: 0 <= k < |elements| ==> elements[k].0 <= maxPriority;\n}\n}",
            "parents": [
                "4c9c72f4-3e57-4d6a-8bf2-547a48fc90cb"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "5291a9ef-fa02-4df7-9372-043b2ebd1dc1",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (result: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == result && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < result ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == result ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  var pivotIndex: int;\n  while left <= right\n    invariant 0 <= left <= arr.Length\n    invariant -1 <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant left <= right + 1\n  {\n    pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return -1; // This line should never be reached due to the loop invariant\n}\nmethod Partition(arr: array<int>, low: int, high: int) returns (pivotIndex: int)\n  requires 0 <= low <= high < arr.Length\n  ensures low <= pivotIndex <= high\n  ensures forall i: int :: low <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= high ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[high];\n  var i := low - 1;\n  for j := low to high - 1\n    invariant low - 1 <= i < high\n    invariant low <= j <= high\n    invariant forall m: int :: low <= m <= i ==> arr[m] <= pivot\n    invariant forall n: int :: i < n < j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      i := i + 1;\n      arr[i], arr[j] := arr[j], arr[i];\n    }\n  }\n  arr[i + 1], arr[high] := arr[high], arr[i + 1];\n  return i + 1;\n  for j := low to high - 1\n    invariant low - 1 <= i < high\n    invariant low <= j <= high\n    invariant forall m: int :: low <= m <= i ==> arr[m] <= pivot\n    invariant forall n: int :: i < n < j ==> arr[n] > pivot\n    invariant forall p: int :: j <= p < high ==> arr[p] >= pivot\n  {\n    if arr[j] <= pivot {\n      i := i + 1;\n      arr[i], arr[j] := arr[j], arr[i];\n    }\n  }\n  arr[i + 1], arr[high] := arr[high], arr[i + 1];\n  return i + 1;\n}",
            "parents": [
                "a2921e1b-f37c-4f0f-b5c2-111dd72ec938"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "d9f3ec73-7451-4dc1-97a1-f0670c080936",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n    invariant forall r: int :: left <= r < j ==> arr[r] <= pivot || arr[r] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "d69266e4-437f-4735-82c6-bfecd54e0e88"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "c76144ec-4a07-457f-bcce-2d5bddbfdefb",
            "type": "program",
            "content": "class Graph {\n  var adjacencyMatrix: array2<bool>;\n\n  constructor(n: nat) \n    requires n > 0\n    ensures adjacencyMatrix.Length0 == n && adjacencyMatrix.Length1 == n\n    ensures forall i, j :: 0 <= i < n && 0 <= j < n ==> !adjacencyMatrix[i, j]\n  {\n    adjacencyMatrix := new bool[n, n];\n  }\n\n  method AddEdge(u: nat, v: nat)\n    requires 0 <= u < adjacencyMatrix.Length0\n    requires 0 <= v < adjacencyMatrix.Length1\n    modifies adjacencyMatrix\n    ensures adjacencyMatrix[u, v] && adjacencyMatrix[v, u]\n  {\n    adjacencyMatrix[u, v] := true;\n    adjacencyMatrix[v, u] := true;\n  }\n\n  method IsVertexCover(cover: set<nat>) returns (isCover: bool)\n    requires cover <= set i | 0 <= i < adjacencyMatrix.Length0\n    ensures isCover == (forall u, v :: 0 <= u < adjacencyMatrix.Length0 && 0 <= v < adjacencyMatrix.Length1 && adjacencyMatrix[u, v] ==> u in cover || v in cover)\n  {\n    isCover := true;\n    var n := adjacencyMatrix.Length0;\n    for u := 0 to n - 1 {\n      for v := 0 to n - 1 {\n        if adjacencyMatrix[u, v] && !(u in cover || v in cover) {\n          isCover := false;\n          return;\n        }\n      }\n    }\n  }\nmethod IsCompleteGraph() returns (isComplete: bool)\n  ensures isComplete == (forall u, v :: 0 <= u < adjacencyMatrix.Length0 && 0 <= v < adjacencyMatrix.Length1 && u != v ==> adjacencyMatrix[u, v])\n{\n  isComplete := true;\n  var n := adjacencyMatrix.Length0;\n  for u := 0 to n - 1\n    invariant 0 <= u <= n\n    invariant isComplete == (forall i, j :: 0 <= i < u && 0 <= j < n && i != j ==> adjacencyMatrix[i, j])\n  {\n    for v := 0 to n - 1\n      invariant 0 <= v <= n\n      invariant isComplete == (forall i, j :: 0 <= i < u && 0 <= j < n && i != j ==> adjacencyMatrix[i, j])\n      invariant isComplete == (forall j :: 0 <= j < v && u != j ==> adjacencyMatrix[u, j])\n    {\n      if u != v && !adjacencyMatrix[u, v] {\n        isComplete := false;\n        return;\n      }\n    }\n  }\n}\n}",
            "parents": [
                "4cdc8acf-bd53-4262-9f62-d262ebc0d72c"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "61bba81c-b2bf-4eb9-8aad-dd4d4857542d",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n    invariant forall r: int :: left <= r < j ==> arr[r] <= pivot || arr[r] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n    invariant forall r: int :: left <= r < j ==> arr[r] <= pivot || arr[r] > pivot\n    invariant forall s: int :: left <= s < i ==> arr[s] <= pivot\n    invariant forall t: int :: i <= t <= j ==> arr[t] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n    invariant forall r: int :: left <= r <= right ==> \n              (arr[r] <= pivot || arr[r] > pivot)\n    invariant forall s: int :: left <= s < i ==> arr[s] <= pivot\n    invariant forall t: int :: i <= t <= j ==> arr[t] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "14ea84df-3997-4b7b-ae7a-a0cb194df88b"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "2a5bf287-3d74-4b80-925e-38f564b8e6e4",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures elements == old(elements)\n  ensures value == elements[0].1\n{\n  var highestPriority := elements[0].0;\n  var highestValue := elements[0].1;\n  var i := 1;\n  while i < |elements|\n    invariant 1 <= i <= |elements|\n    invariant highestPriority == elements[0].0\n    invariant highestValue == elements[0].1\n    invariant forall k :: 0 <= k < i ==> elements[k].0 >= highestPriority\n  {\n    if elements[i].0 < highestPriority {\n      highestPriority := elements[i].0;\n      highestValue := elements[i].1;\n    }\n    i := i + 1;\n  }\n  value := highestValue;\n}\nmethod ChangePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n  // Remove the element with the specified value\n  elements := elements[..i] + elements[i+1..];\n  \n  // Re-insert the element with the new priority\n  var newElement := (newPriority, value);\n  i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [newElement] + elements[i..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\nmethod GetPriorityOfValue(value: int) returns (priority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  ensures exists i :: 0 <= i < |elements| && elements[i].1 == value && priority == elements[i].0\n{\n  var i := 0;\n  priority := -1; // Default value, should never be returned due to precondition\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant priority == -1\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n  priority := elements[i].0;\n  assert exists i :: 0 <= i < |elements| && elements[i].1 == value && priority == elements[i].0;\n}\nmethod Merge(other: PriorityQueue)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures |elements| == old(|elements|) + |other.elements|\n  ensures forall e :: e in other.elements ==> e in elements\n{\n  var i := 0;\n  while i < |other.elements|\n    invariant 0 <= i <= |other.elements|\n    invariant |elements| == old(|elements|) + i\n    invariant forall j, k :: 0 <= j < k < |elements| ==> elements[j].0 <= elements[k].0\n    invariant forall e :: e in other.elements[..i] ==> e in elements\n  {\n    var (priority, value) := other.elements[i];\n    Enqueue(priority, value);\n    i := i + 1;\n  }\n}\nmethod RemoveAllWithPriority(priority: int)\n  modifies this\n  ensures forall i :: 0 <= i < |elements| ==> elements[i].0 != priority\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 != priority\n    invariant forall j, k :: 0 <= j < k < i ==> elements[j].0 <= elements[k].0\n  {\n    if elements[i].0 == priority {\n      elements := elements[..i] + elements[i+1..];\n    } else {\n      i := i + 1;\n    }\n  }\n  assert forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0;\n}\n}",
            "parents": [
                "1b923300-88d9-4b5f-be77-b886e1b33d1a"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "SUCCESS"
            }
        },
        {
            "id": "9df6818e-69a2-468b-b41c-3d06abc5ebd4",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures elements == old(elements)\n    ensures value == elements[0].1\n  {\n    var highestPriority := elements[0].0;\n    var highestValue := elements[0].1;\n    var i := 1;\n    while i < |elements|\n      invariant 1 <= i <= |elements|\n      invariant highestPriority == elements[0].0\n      invariant highestValue == elements[0].1\n      invariant forall k :: 0 <= k < i ==> elements[k].0 >= highestPriority\n    {\n      if elements[i].0 < highestPriority {\n        highestPriority := elements[i].0;\n        highestValue := elements[i].1;\n      }\n      i := i + 1;\n    }\n    value := highestValue;\n  }\n  method ChangePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n    {\n      i := i + 1;\n    }\n    // Remove the element with the specified value\n    elements := elements[..i] + elements[i+1..];\n    \n    // Re-insert the element with the new priority\n    var newElement := (newPriority, value);\n    i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\nmethod RemoveValue(value: int)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures forall i :: 0 <= i < |elements| ==> elements[i].1 != value\n{\n  var i := 0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n    invariant forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0\n  {\n    if elements[i].1 == value {\n      elements := elements[..i] + elements[i+1..];\n    } else {\n      i := i + 1;\n    }\n  }\n  assert forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0;\n  assert forall i :: 0 <= i < |elements| ==> elements[i].1 != value;\n}\nmethod FindHighestPriorityElement() returns (element: (int, int))\n  requires |elements| > 0\n  ensures element in elements\n  ensures forall e :: e in elements ==> e.0 >= element.0\n{\n  var highestPriorityElement := elements[0];\n  var i := 1;\n  while i < |elements|\n    invariant 1 <= i <= |elements|\n    invariant highestPriorityElement in elements[..i]\n    invariant forall e :: e in elements[..i] ==> e.0 >= highestPriorityElement.0\n  {\n    if elements[i].0 < highestPriorityElement.0 {\n      highestPriorityElement := elements[i];\n    }\n    i := i + 1;\n  }\n  element := highestPriorityElement;\n}\n}",
            "parents": [
                "bbd54b05-652b-4075-b10a-e7b0f9e25609"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "b71ad747-45be-4068-bd72-8948d9308043",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var index := -1;\n    var i := 0;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant index == -1 ==> forall k :: 0 <= k < i ==> elements[k].1 != value\n      invariant index != -1 ==> elements[index].1 == value\n      invariant index == -1 ==> elements == old(elements)\n    {\n      if elements[i].1 == value {\n        index := i;\n        break;\n      }\n      i := i + 1;\n    }\n    assert index != -1; // We should have found the element\n\n    // Remove the element\n    elements := elements[..index] + elements[index + 1..];\n\n    // Reinsert with new priority\n    var newElement := (newPriority, value);\n    i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant elements[..index] + elements[index..] == old(elements[..index] + elements[index + 1..])\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Merge(other: PriorityQueue)\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures elements == old(elements) + old(other.elements)\n  {\n    var i := 0;\n    var j := 0;\n    var result: seq<(int, int)> := [];\n    while i < |elements| || j < |other.elements|\n      invariant 0 <= i <= |elements|\n      invariant 0 <= j <= |other.elements|\n      invariant forall k, l :: 0 <= k < l < |result| ==> result[k].0 <= result[l].0\n      invariant result + elements[i..] + other.elements[j..] == old(elements) + old(other.elements)\n    {\n      if i < |elements| && (j >= |other.elements| || elements[i].0 <= other.elements[j].0) {\n        result := result + [elements[i]];\n        i := i + 1;\n      } else {\n        result := result + [other.elements[j]];\n        j := j + 1;\n      }\n    }\n    elements := result;\n  }\nmethod RemoveByValue(value: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures forall i :: 0 <= i < |elements| ==> elements[i].1 != value\n{\n  var index := -1;\n  var i := 0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant index == -1 ==> forall k :: 0 <= k < i ==> elements[k].1 != value\n    invariant index != -1 ==> elements[index].1 == value\n    invariant index == -1 ==> elements == old(elements)\n  {\n    if elements[i].1 == value {\n      index := i;\n      break;\n    }\n    i := i + 1;\n  }\n  assert index != -1; // We should have found the element\n\n  // Remove the element\n  elements := elements[..index] + elements[index + 1..];\n  assert forall i :: 0 <= i < |elements| ==> elements[i].1 != value;\n  assert forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0;\n}\n}",
            "parents": [
                "28197529-c699-43b8-ad51-ac160faa4544"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "e9643a5f-48ad-4f0e-982a-b6b5e00efa10",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method IsEmpty() returns (empty: bool)\n    ensures empty == (|elements| == 0)\n  {\n    var i := 0;\n    empty := true;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant empty == (i == 0)\n    {\n      empty := false;\n      i := i + 1;\n    }\n  }\nmethod Merge(other: PriorityQueue)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures |elements| == |old(elements)| + |other.elements|\n  ensures multiset(elements) == multiset(old(elements) + other.elements)\n{\n  var merged: seq<(int, int)> := [];\n  var i := 0;\n  var j := 0;\n\n  while i < |elements| || j < |other.elements|\n    invariant 0 <= i <= |elements|\n    invariant 0 <= j <= |other.elements|\n    invariant |merged| == i + j\n    invariant forall k, l :: 0 <= k < l < |merged| ==> merged[k].0 <= merged[l].0\n    invariant multiset(merged) == multiset(old(elements[..i]) + other.elements[..j])\n  {\n    if i < |elements| && (j >= |other.elements| || elements[i].0 <= other.elements[j].0) {\n      merged := merged + [elements[i]];\n      i := i + 1;\n    } else {\n      merged := merged + [other.elements[j]];\n      j := j + 1;\n    }\n  }\n  elements := merged;\n}\nmethod IncreasePriority(value: int, newPriority: int)\n  requires |elements| > 0\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i].1 == value ==> elements[i].0 == newPriority\n{\n  var found := false;\n  var i := 0;\n  \n  // Find the element with the given value\n  while i < |elements| && !found\n    invariant 0 <= i <= |elements|\n    invariant !found ==> forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    if elements[i].1 == value {\n      found := true;\n    } else {\n      i := i + 1;\n    }\n  }\n  \n  if found {\n    // Remove the element and reinsert it with the new priority\n    var element := elements[i];\n    elements := elements[..i] + elements[i+1..];\n    \n    var j := 0;\n    while j < |elements| && elements[j].0 <= newPriority\n      invariant 0 <= j <= |elements|\n      invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < j ==> elements[k].0 <= elements[l].0\n    {\n      j := j + 1;\n    }\n    elements := elements[..j] + [(newPriority, element.1)] + elements[j..];\n  }\n}\nmethod DecreasePriority(value: int, newPriority: int)\n  requires |elements| > 0\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i].1 == value ==> elements[i].0 == newPriority\n{\n  var found := false;\n  var i := 0;\n  \n  // Find the element with the given value\n  while i < |elements| && !found\n    invariant 0 <= i <= |elements|\n    invariant !found ==> forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    if elements[i].1 == value {\n      found := true;\n    } else {\n      i := i + 1;\n    }\n  }\n  \n  if found {\n    // Remove the element and reinsert it with the new priority\n    var element := elements[i];\n    elements := elements[..i] + elements[i+1..];\n    \n    var j := 0;\n    while j < |elements| && elements[j].0 < newPriority\n      invariant 0 <= j <= |elements|\n      invariant forall k :: 0 <= k < j ==> elements[k].0 < newPriority\n      invariant forall k, l :: 0 <= k < l < j ==> elements[k].0 <= elements[l].0\n    {\n      j := j + 1;\n    }\n    elements := elements[..j] + [(newPriority, element.1)] + elements[j..];\n  }\n}\n}",
            "parents": [
                "ec52d70e-5eea-44c1-b83c-00df356b28e8"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "10e94b86-05ce-4596-a109-63655f8e7f96",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k, l :: 0 <= k < l < i && arr[k] < arr[l] ==> lis[k] < lis[l]\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k, l :: 0 <= k < l < i && arr[k] < arr[l] ==> lis[k] < lis[l]\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  assert forall k, l :: 0 <= k < l < n && arr[k] < arr[l] ==> lis[k] < lis[l];\n  length := maxLength;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k, l :: 0 <= k < l < i && arr[k] < arr[l] ==> lis[k] < lis[l]\n    invariant forall k :: 1 <= k < i ==> lis[k-1] <= lis[k]  // New invariant\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k, l :: 0 <= k < l < i && arr[k] < arr[l] ==> lis[k] < lis[l]\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  assert forall k, l :: 0 <= k < l < n && arr[k] < arr[l] ==> lis[k] < lis[l];\n  length := maxLength;\nwhile i < n\n  invariant 1 <= i <= n\n  invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n  invariant 1 <= maxLength <= i + 1\n  invariant forall k, l :: 0 <= k < l < i && arr[k] < arr[l] ==> lis[k] < lis[l]\n  invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength // New invariant: lis[k] is bounded by maxLength\n{\n  var j := 0;\n  while j < i\n    invariant 0 <= j <= i\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant forall k, l :: 0 <= k < l < i && arr[k] < arr[l] ==> lis[k] < lis[l]\n  {\n    if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n      lis[i] := lis[j] + 1;\n    }\n    j := j + 1;\n  }\n  if maxLength < lis[i] {\n    maxLength := lis[i];\n  }\n  i := i + 1;\n}\nassert forall k, l :: 0 <= k < l < n && arr[k] < arr[l] ==> lis[k] < lis[l];\nlength := maxLength;\n}",
            "parents": [
                "25174c6d-4d7f-48d0-9a43-34883789c1e8"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "65faee9c-919b-428d-965e-5c7fddb00c00",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method UpdatePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n  {\n    var index := 0;\n    while index < |elements| && elements[index].1 != value\n      invariant 0 <= index <= |elements|\n      invariant forall k :: 0 <= k < index ==> elements[k].1 != value\n      invariant exists i :: 0 <= i < |elements| && elements[i].1 == value\n    {\n      index := index + 1;\n    }\n\n    // Remove the element with the specified value\n    var priority := elements[index].0;\n    elements := elements[..index] + elements[index + 1..];\n\n    // Reinsert the element with the new priority\n    var newElement := (newPriority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\nmethod UpdateValue(priority: int, newValue: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].0 == priority\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (priority, newValue)\n{\n  var index := 0;\n  while index < |elements| && elements[index].0 != priority\n    invariant 0 <= index <= |elements|\n    invariant forall k :: 0 <= k < index ==> elements[k].0 != priority\n    invariant exists i :: 0 <= i < |elements| && elements[i].0 == priority\n  {\n    index := index + 1;\n  }\n\n  // Update the value of the element with the specified priority\n  elements := elements[..index] + [(priority, newValue)] + elements[index + 1..];\n}\nmethod Merge(other: PriorityQueue)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures |elements| == old(|elements|) + |other.elements|\n  ensures forall e :: e in other.elements ==> e in elements\n{\n  var i := 0;\n  while i < |other.elements|\n    invariant 0 <= i <= |other.elements|\n    invariant |elements| == old(|elements|) + i\n    invariant forall e :: e in other.elements[..i] ==> e in elements\n    invariant forall j, k :: 0 <= j < k < |elements| ==> elements[j].0 <= elements[k].0\n  {\n    var (priority, value) := other.elements[i];\n    this.Enqueue(priority, value);\n    i := i + 1;\n  }\n}\n}",
            "parents": [
                "aa50a49b-c1e5-4a17-8d63-302e4f2f9e6a"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "c9eb8a9b-f58c-4764-a99f-6080babf3b47",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p < right ==> arr[p] > pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n    invariant forall r: int :: left <= r < j ==> arr[r] <= pivot || arr[r] > pivot\n    invariant forall s: int :: j <= s <= right ==> arr[s] >= pivot || arr[s] < pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant forall q: int :: left <= q <= right ==> \n              (arr[q] <= pivot || arr[q] > pivot)\n    invariant forall r: int :: left <= r < j ==> arr[r] <= pivot || arr[r] > pivot\n    invariant forall s: int :: j <= s <= right ==> arr[s] >= pivot || arr[s] < pivot\n    invariant forall t: int :: left <= t < i ==> arr[t] <= pivot // New invariant\n    invariant forall u: int :: i <= u <= right ==> arr[u] >= pivot // New invariant\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "4bc9e5ca-6194-460b-8c11-365eb0f37499"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "a23720ee-4585-47e9-b0e5-64713d260fb3",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\nmethod Peek() returns (value: int)\n  requires |elements| > 0\n  ensures elements == old(elements)\n  ensures value == elements[0].1\n{\n  var highestPriority := elements[0].0;\n  var highestValue := elements[0].1;\n  var i := 1;\n  while i < |elements|\n    invariant 1 <= i <= |elements|\n    invariant highestPriority == elements[0].0\n    invariant highestValue == elements[0].1\n    invariant forall k :: 0 <= k < i ==> elements[k].0 >= highestPriority\n  {\n    if elements[i].0 < highestPriority {\n      highestPriority := elements[i].0;\n      highestValue := elements[i].1;\n    }\n    i := i + 1;\n  }\n  value := highestValue;\n}\nmethod ChangePriority(value: int, newPriority: int)\n  requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n{\n  var i := 0;\n  while i < |elements| && elements[i].1 != value\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n  {\n    i := i + 1;\n  }\n  // Remove the element with the specified value\n  elements := elements[..i] + elements[i+1..];\n  \n  // Re-insert the element with the new priority\n  var newElement := (newPriority, value);\n  i := 0;\n  while i < |elements| && elements[i].0 <= newPriority\n    invariant 0 <= i <= |elements|\n    invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n    invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n  {\n    i := i + 1;\n  }\n  elements := elements[..i] + [newElement] + elements[i..];\n  assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n}\nmethod Merge(other: PriorityQueue)\n  modifies this\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var i := 0;\n  var j := 0;\n  var newElements: seq<(int, int)> := [];\n  \n  while i < |elements| || j < |other.elements|\n    invariant 0 <= i <= |elements|\n    invariant 0 <= j <= |other.elements|\n    invariant |newElements| == i + j\n    invariant forall k, l :: 0 <= k < l < |newElements| ==> newElements[k].0 <= newElements[l].0\n    invariant forall k :: 0 <= k < i ==> elements[k] in newElements\n    invariant forall k :: 0 <= k < j ==> other.elements[k] in newElements\n  {\n    if i < |elements| && (j >= |other.elements| || elements[i].0 <= other.elements[j].0) {\n      newElements := newElements + [elements[i]];\n      i := i + 1;\n    } else {\n      newElements := newElements + [other.elements[j]];\n      j := j + 1;\n    }\n  }\n  elements := newElements;\n}\nmethod RemoveAllWithPriority(priority: int)\n  modifies this\n  ensures forall i :: 0 <= i < |elements| ==> elements[i].0 != priority\n  ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n{\n  var newElements: seq<(int, int)> := [];\n  var i := 0;\n  while i < |elements|\n    invariant 0 <= i <= |elements|\n    invariant |newElements| <= i\n    invariant forall k :: 0 <= k < |newElements| ==> newElements[k].0 != priority\n    invariant forall k, l :: 0 <= k < l < |newElements| ==> newElements[k].0 <= newElements[l].0\n  {\n    if elements[i].0 != priority {\n      newElements := newElements + [elements[i]];\n    }\n    i := i + 1;\n  }\n  elements := newElements;\n}\nmethod FindHighestPriority() returns (priority: int, value: int)\n  requires |elements| > 0\n  ensures elements == old(elements)\n  ensures exists i :: 0 <= i < |elements| && elements[i] == (priority, value)\n  ensures forall i :: 0 <= i < |elements| ==> elements[i].0 >= priority\n{\n  priority := elements[0].0;\n  value := elements[0].1;\n  var i := 1;\n  while i < |elements|\n    invariant 1 <= i <= |elements|\n    invariant exists j :: 0 <= j < i && elements[j] == (priority, value)\n    invariant forall k :: 0 <= k < i ==> elements[k].0 >= priority\n  {\n    if elements[i].0 < priority {\n      priority := elements[i].0;\n      value := elements[i].1;\n    }\n    i := i + 1;\n  }\n}\n}",
            "parents": [
                "9f735dc8-712c-4299-8d8f-5824c9149ad8"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "7c980d64-be10-46da-adbf-9e2ff3b59035",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      decreases |elements| - i\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n      decreases |elements| - i\n    {\n      i := i + 1;\n    }\n    var oldElement := elements[i];\n    elements := elements[..i] + elements[i+1..];\n    var j := 0;\n    while j < |elements| && elements[j].0 <= newPriority\n      invariant 0 <= j <= |elements|\n      invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < j ==> elements[k].0 <= elements[l].0\n      decreases |elements| - j\n    {\n      j := j + 1;\n    }\n    elements := elements[..j] + [(newPriority, value)] + elements[j..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method RemoveByValue(value: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures !exists i :: 0 <= i < |elements| && elements[i].1 == value\n  {\n    var i := 0;\n    // Find the element with the specified value\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n      decreases |elements| - i\n    {\n      i := i + 1;\n    }\n    // Remove the element\n    elements := elements[..i] + elements[i+1..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n    assert !exists k :: 0 <= k < |elements| && elements[k].1 == value;\n  }\n}",
            "parents": [
                "02f7efd3-0c97-4338-99dc-3adb14006d3c"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "3bcd75a6-b63c-4db0-9c01-b1ce73de8b25",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method UpdatePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n  {\n    var i := 0;\n    // Find the index of the element with the given value\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n    {\n      i := i + 1;\n    }\n    assert i < |elements|; // Element with the given value exists\n\n    // Remove the element\n    elements := elements[..i] + elements[i+1..];\n\n    // Reinsert the element with the new priority\n    var newElement := (newPriority, value);\n    var j := 0;\n    while j < |elements| && elements[j].0 <= newPriority\n      invariant 0 <= j <= |elements|\n      invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < j ==> elements[k].0 <= elements[l].0\n    {\n      j := j + 1;\n    }\n    elements := elements[..j] + [newElement] + elements[j..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method FindMaxPriority() returns (maxPriority: int)\n    requires |elements| > 0\n    ensures forall i :: 0 <= i < |elements| ==> elements[i].0 <= maxPriority\n    ensures exists i :: 0 <= i < |elements| && elements[i].0 == maxPriority\n  {\n    var i := 0;\n    maxPriority := elements[0].0;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= maxPriority\n      invariant exists k :: 0 <= k < i ==> elements[k].0 == maxPriority\n    {\n      if elements[i].0 > maxPriority {\n        maxPriority := elements[i].0;\n      }\n      i := i + 1;\n    }\n    assert exists k :: 0 <= k < |elements| && elements[k].0 == maxPriority;\n  }\n}",
            "parents": [
                "bea629b9-e69a-42bc-8ab1-6e7e32173b87"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "1ddadfc5-c237-4ddf-91da-9cc17a5f2cd6",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  \n  constructor() {\n    elements := [];\n  }\n  \n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  \n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  \n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  \n  method ChangePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n    {\n      i := i + 1;\n    }\n    var oldElement := elements[i];\n    elements := elements[..i] + elements[i+1..];\n    var j := 0;\n    while j < |elements| && elements[j].0 <= newPriority\n      invariant 0 <= j <= |elements|\n      invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < j ==> elements[k].0 <= elements[l].0\n    {\n      j := j + 1;\n    }\n    elements := elements[..j] + [(newPriority, value)] + elements[j..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n}",
            "parents": [
                "0e3e1fef-620d-44f1-9109-30887c600d5e"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "f7fd4977-d1f2-4379-985b-533be8f40181",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures elements == old(elements)\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n      invariant exists j :: i <= j < |elements| && elements[j].1 == value\n    {\n      i := i + 1;\n    }\n    // Remove the element with the given value\n    elements := elements[..i] + elements[i+1..];\n    \n    // Insert the element with the new priority\n    var newElement := (newPriority, value);\n    var j := 0;\n    while j < |elements| && elements[j].0 <= newPriority\n      invariant 0 <= j <= |elements|\n      invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n    {\n      j := j + 1;\n    }\n    elements := elements[..j] + [newElement] + elements[j..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method PeekWithPriority() returns (priority: int, value: int)\n    requires |elements| > 0\n    ensures elements == old(elements)\n    ensures priority == elements[0].0 && value == elements[0].1\n  {\n    priority := elements[0].0;\n    value := elements[0].1;\n  }\n}",
            "parents": [
                "e50db80b-cae2-48bb-9034-9320d67e12ca"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "8117b8cd-31a9-4f59-95cb-a8c22c9d0c1c",
            "type": "program",
            "content": "method QuickSort(a: array<int>, lo: int, hi: int)\n  requires 0 <= lo <= hi <= a.Length\n  modifies a\n  ensures forall i, j :: lo <= i <= j < hi ==> a[i] <= a[j]\n{\n  if lo < hi {\n    var p := Partition(a, lo, hi);\n    QuickSort(a, lo, p);\n    QuickSort(a, p + 1, hi);\n  }\n}\n\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIndex: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIndex < hi\n  ensures forall i :: lo <= i < pivotIndex ==> a[i] <= a[pivotIndex]\n  ensures forall i :: pivotIndex < i < hi ==> a[pivotIndex] <= a[i]\n{\n  var pivot := a[lo];\n  var i := lo;\n  var j := hi;\n  while i < j\n    invariant lo <= i <= j <= hi\n    invariant forall k :: lo <= k < i ==> a[k] <= pivot\n    invariant forall k :: j <= k < hi ==> a[k] >= pivot\n    invariant exists p :: lo <= p < hi && a[p] == pivot\n  {\n    while i < j && a[i] <= pivot\n      invariant lo <= i < hi\n      invariant forall k :: lo <= k < i ==> a[k] <= pivot\n    {\n      i := i + 1;\n    }\n    while i < j && a[j - 1] >= pivot\n      invariant lo < j <= hi\n      invariant forall k :: j <= k < hi ==> a[k] >= pivot\n    {\n      j := j - 1;\n    }\n    if i < j {\n      a[i], a[j - 1] := a[j - 1], a[i];\n    }\n  }\n  pivotIndex := j - 1;\n  a[lo], a[pivotIndex] := a[pivotIndex], a[lo];\n  assert forall k :: lo <= k < pivotIndex ==> a[k] <= a[pivotIndex];\n  assert forall k :: pivotIndex < k < hi ==> a[pivotIndex] <= a[k];\n}",
            "parents": [
                "c33bdfa5-2a06-4477-8b69-036869b48b76"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "acb9782b-cf5e-4019-ad7c-c3d03e0550a1",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n}",
            "parents": [
                "36102cb8-ab48-4753-9384-c054cadcf540"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "bc90af31-af16-4744-9fbf-d8c31566943f",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant exists i: int :: left <= i <= right && arr[i] == arr[k] &&\n              (forall j: int :: left <= j < right && arr[j] < arr[k] ==> j < i) &&\n              (forall j: int :: left <= j < right && arr[j] == arr[k] ==> j <= i)\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "5930c594-2f01-493d-af2c-91db85338709"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "79930dd9-7352-4a40-81d0-21f333c03e00",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, j :: 0 <= k < j < i ==> elements[k].0 <= elements[j].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, j :: 0 <= k < j < |elements| ==> elements[k].0 <= elements[j].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    var i := 0;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 >= elements[i].0\n    {\n      if elements[i].0 > elements[0].0 {\n        value := elements[i].1;\n        return;\n      }\n      i := i + 1;\n    }\n    value := elements[0].1;\n  }\n  method Merge(other: PriorityQueue)\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures |elements| == |old(elements)| + |other.elements|\n  {\n    var i := 0;\n    while i < |other.elements|\n      invariant 0 <= i <= |other.elements|\n      invariant forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0\n      invariant |elements| == |old(elements)| + i\n    {\n      var (priority, value) := other.elements[i];\n      Enqueue(priority, value);\n      i := i + 1;\n    }\n    assert |elements| == |old(elements)| + |other.elements|;\n    assert forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0;\n  }\n}",
            "parents": [
                "86ad5489-9c2b-4996-b63c-366c0143face"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "6b324142-7a39-4202-bfe1-4ad8c4218ca7",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  \n  constructor() {\n    elements := [];\n  }\n  \n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  \n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  \n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n    ensures elements == old(elements)\n  {\n    value := elements[0].1;\n  }\n  \n  method ChangePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures forall i :: 0 <= i < |elements| ==> elements[i].1 != value || elements[i].0 == newPriority\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n      invariant exists j :: i <= j < |elements| && elements[j].1 == value\n    {\n      i := i + 1;\n    }\n    assert i < |elements|; // We know the element exists due to the precondition\n    var oldElement := elements[i];\n    elements := elements[..i] + elements[i+1..];\n    \n    // Reinsert the element with the new priority\n    var newElement := (newPriority, value);\n    var j := 0;\n    while j < |elements| && elements[j].0 <= newPriority\n      invariant 0 <= j <= |elements|\n      invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < j ==> elements[k].0 <= elements[l].0\n      invariant elements == old(elements[..i] + elements[i+1..])\n    {\n      j := j + 1;\n    }\n    elements := elements[..j] + [newElement] + elements[j..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n}",
            "parents": [
                "1e3613c2-cb3d-4127-b25c-7577e835e0e9"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "de541f28-641a-4049-b739-18afc5350135",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n      invariant exists j :: i <= j < |elements| && elements[j].1 == value\n    {\n      i := i + 1;\n    }\n    var updatedElement := (newPriority, value);\n    elements := elements[..i] + elements[i+1..];\n    \n    // Re-insert the updated element\n    var j := 0;\n    while j < |elements| && elements[j].0 <= newPriority\n      invariant 0 <= j <= |elements|\n      invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n    {\n      j := j + 1;\n    }\n    elements := elements[..j] + [updatedElement] + elements[j..];\n  }\n  method RemoveValue(value: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n      invariant exists j :: i <= j < |elements| && elements[j].1 == value\n    {\n      i := i + 1;\n    }\n    // Remove the element with the specified value\n    elements := elements[..i] + elements[i+1..];\n  }\n}",
            "parents": [
                "a620efaf-7aed-4994-9970-ebbbf8f3fd6a"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "1424a1d3-8170-4355-acd6-ce01a2eb8953",
            "type": "program",
            "content": "method QuickSort(a: array<int>, lo: int, hi: int)\n  requires 0 <= lo <= hi <= a.Length\n  modifies a\n  ensures forall i, j :: lo <= i <= j < hi ==> a[i] <= a[j]\n{\n  if lo < hi {\n    var p := Partition(a, lo, hi);\n    QuickSort(a, lo, p);\n    QuickSort(a, p + 1, hi);\n  }\n}\n\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIndex: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIndex < hi\n  ensures forall i :: lo <= i < pivotIndex ==> a[i] <= a[pivotIndex]\n  ensures forall i :: pivotIndex < i < hi ==> a[pivotIndex] <= a[i]\n{\n  var pivot := a[lo];\n  var i := lo;\n  var j := hi;\n  while i < j\n    invariant lo <= i <= j <= hi\n    invariant forall k :: lo <= k < i ==> a[k] <= pivot\n    invariant forall k :: j <= k < hi ==> a[k] >= pivot\n    invariant exists p :: lo <= p < hi && a[p] == pivot\n  {\n    while i < j && a[i] <= pivot\n      invariant lo <= i < hi\n      invariant forall k :: lo <= k < i ==> a[k] <= pivot\n    {\n      i := i + 1;\n    }\n    while i < j && a[j - 1] >= pivot\n      invariant lo < j <= hi\n      invariant forall k :: j <= k < hi ==> a[k] >= pivot\n    {\n      j := j - 1;\n    }\n    if i < j {\n      a[i], a[j - 1] := a[j - 1], a[i];\n    }\n  }\n  pivotIndex := i - 1;\n  a[lo], a[pivotIndex] := a[pivotIndex], a[lo];\n}",
            "parents": [
                "7c9fc37e-728f-4760-ad6d-a39ce7ace19f"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "44e7eccd-3623-4cfd-9465-5aa9360e29da",
            "type": "program",
            "content": "class Graph {\n  var adjacencyMatrix: array2<bool>;\n\n  constructor(n: nat) \n    requires n > 0\n    ensures adjacencyMatrix.Length0 == n && adjacencyMatrix.Length1 == n\n    ensures forall i, j :: 0 <= i < n && 0 <= j < n ==> !adjacencyMatrix[i, j]\n  {\n    adjacencyMatrix := new bool[n, n];\n  }\n\n  method AddEdge(u: nat, v: nat)\n    requires 0 <= u < adjacencyMatrix.Length0\n    requires 0 <= v < adjacencyMatrix.Length1\n    modifies adjacencyMatrix\n    ensures adjacencyMatrix[u, v] && adjacencyMatrix[v, u]\n  {\n    adjacencyMatrix[u, v] := true;\n    adjacencyMatrix[v, u] := true;\n  }\n\n  method IsVertexCover(cover: set<nat>) returns (isCover: bool)\n    requires cover <= set i | 0 <= i < adjacencyMatrix.Length0\n    ensures isCover == (forall u, v :: 0 <= u < adjacencyMatrix.Length0 && 0 <= v < adjacencyMatrix.Length1 && adjacencyMatrix[u, v] ==> u in cover || v in cover)\n  {\n    isCover := true;\n    var n := adjacencyMatrix.Length0;\n    for u := 0 to n - 1 {\n      for v := 0 to n - 1 {\n        if adjacencyMatrix[u, v] && !(u in cover || v in cover) {\n          isCover := false;\n          return;\n        }\n      }\n    }\n  }\n\n  method IsCompleteGraph() returns (isComplete: bool)\n    ensures isComplete == (forall u, v :: 0 <= u < adjacencyMatrix.Length0 && 0 <= v < adjacencyMatrix.Length1 && u != v ==> adjacencyMatrix[u, v])\n  {\n    isComplete := true;\n    var n := adjacencyMatrix.Length0;\n    for u := 0 to n - 1\n      invariant 0 <= u <= n\n      invariant isComplete == (forall i, j :: 0 <= i < u && 0 <= j < n && i != j ==> adjacencyMatrix[i, j])\n    {\n      for v := 0 to n - 1\n        invariant 0 <= v <= n\n        invariant isComplete == (forall i, j :: 0 <= i < u && 0 <= j < n && i != j ==> adjacencyMatrix[i, j]) &&\n                               (forall i :: 0 <= i < u && i != u ==> adjacencyMatrix[u, i])\n      {\n        if u != v && !adjacencyMatrix[u, v] {\n          isComplete := false;\n          return;\n        }\n      }\n    }\n  }\n}",
            "parents": [
                "3bd28592-3e7d-46dc-a36e-b4db9f7cd4bd"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "71fbd2a2-e7dc-47c3-8e32-b89f523aebdf",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements[..i] == old(elements[..i])\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method UpdatePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures forall i :: 0 <= i < |elements| ==> elements[i].1 != value || elements[i].0 == newPriority\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n      invariant exists j :: i <= j < |elements| && elements[j].1 == value\n    {\n      i := i + 1;\n    }\n\n    // Remove the element with the old priority\n    elements := elements[..i] + elements[i+1..];\n\n    // Reinsert the element with the new priority\n    var newElement := (newPriority, value);\n    i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n}",
            "parents": [
                "00cc1ad0-3b38-460a-922b-f6c79a890a5d"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "8fa14a9a-b4b6-4cd9-b6f7-66ca2cddd900",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n\n  constructor() {\n    elements := [];\n  }\n\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant forall k, l :: 0 <= k < l < |elements| && l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n}",
            "parents": [
                "f96f785a-0a84-4692-a514-f60129d792e5"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "4bdbda8f-a7c2-429d-86f8-d62dd90476df",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n}",
            "parents": [
                "ba1aad7c-e85b-4420-81b9-1d2d39442b0d"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "63f82f96-933b-4c3a-8d7d-7257e3c34172",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant exists i: int :: left <= i <= right && \n              (forall j: int :: left <= j < i ==> arr[j] <= arr[i]) &&\n              (forall j: int :: i < j <= right ==> arr[j] >= arr[i])\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "c48e1814-ca50-4b6e-b86c-3be0ef5feb3b"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "825aea69-f339-47c5-b0d5-d03b437bc5bf",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures elements == old(elements)\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n      invariant exists j :: 0 <= j < |elements| && elements[j].1 == value\n    {\n      i := i + 1;\n    }\n    var oldElement := elements[i];\n    elements := elements[..i] + elements[i+1..];\n    var j := 0;\n    while j < |elements| && elements[j].0 <= newPriority\n      invariant 0 <= j <= |elements|\n      invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n      invariant elements == old(elements[..i] + elements[i+1..])\n    {\n      j := j + 1;\n    }\n    elements := elements[..j] + [(newPriority, value)] + elements[j..];\n    assert forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0;\n  }\n}",
            "parents": [
                "426a02f5-1be4-4799-a168-4eb69a5d8cff"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "2bcf4ebe-ccf7-477e-a86f-85ce94584fa8",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var index := -1;\n    var i := 0;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant index == -1 ==> forall k :: 0 <= k < i ==> elements[k].1 != value\n      invariant index != -1 ==> elements[index].1 == value\n      invariant index == -1 ==> elements == old(elements)\n    {\n      if elements[i].1 == value {\n        index := i;\n        break;\n      }\n      i := i + 1;\n    }\n    assert index != -1; // We should have found the element\n\n    // Remove the element\n    elements := elements[..index] + elements[index + 1..];\n\n    // Reinsert with new priority\n    var newElement := (newPriority, value);\n    i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant elements[..index] + elements[index..] == old(elements[..index] + elements[index + 1..])\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Merge(other: PriorityQueue)\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var merged: seq<(int, int)> := [];\n    var i := 0;\n    var j := 0;\n    while i < |elements| || j < |other.elements|\n      invariant 0 <= i <= |elements|\n      invariant 0 <= j <= |other.elements|\n      invariant |merged| == i + j\n      invariant forall k :: 0 <= k < i ==> merged[k] == elements[k]\n      invariant forall k :: 0 <= k < j ==> merged[i + k] == other.elements[k]\n      invariant forall k, l :: 0 <= k < l < |merged| ==> merged[k].0 <= merged[l].0\n    {\n      if i < |elements| && (j >= |other.elements| || elements[i].0 <= other.elements[j].0) {\n        merged := merged + [elements[i]];\n        i := i + 1;\n      } else {\n        merged := merged + [other.elements[j]];\n        j := j + 1;\n      }\n    }\n    elements := merged;\n  }\n}",
            "parents": [
                "2ed884d3-1b82-483c-a22e-26f7fa0d16a9"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "8185e24b-2204-4f0e-a4fa-7715a69c6e0c",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant exists i: int :: left <= i <= right && arr[i] == arr[k]\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "ee0b48e9-735d-451d-94aa-936f96717a13"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "7ac5f9f8-f3a7-4406-a8f6-9320bd5275db",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures elements == old(elements)\n    ensures value == elements[0].1\n  {\n    var highestPriority := elements[0].0;\n    var highestValue := elements[0].1;\n    var i := 1;\n    while i < |elements|\n      invariant 1 <= i <= |elements|\n      invariant highestPriority == elements[0].0\n      invariant highestValue == elements[0].1\n      invariant forall k :: 0 <= k < i ==> elements[k].0 >= highestPriority\n    {\n      if elements[i].0 < highestPriority {\n        highestPriority := elements[i].0;\n        highestValue := elements[i].1;\n      }\n      i := i + 1;\n    }\n    value := highestValue;\n  }\n  method UpdatePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n    {\n      i := i + 1;\n    }\n    assert i < |elements|; // The element must exist due to the precondition\n    var updatedElement := (newPriority, value);\n    elements := elements[..i] + elements[i+1..];\n    \n    // Re-insert the updated element with new priority\n    var j := 0;\n    while j < |elements| && elements[j].0 <= newPriority\n      invariant 0 <= j <= |elements|\n      invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < j ==> elements[k].0 <= elements[l].0\n    {\n      j := j + 1;\n    }\n    elements := elements[..j] + [updatedElement] + elements[j..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n}",
            "parents": [
                "015e80aa-7ba3-483c-9e68-b09e93ba1cf1"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "152bfb7c-c953-4eff-aab2-b0fadae22c36",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method IsEmpty() returns (empty: bool)\n    ensures empty == (|elements| == 0)\n  {\n    empty := |elements| == 0;\n  }\n  method FindMaxPriority() returns (maxValue: int)\n    requires |elements| > 0\n    ensures exists i :: 0 <= i < |elements| && elements[i].1 == maxValue\n    ensures forall i :: 0 <= i < |elements| ==> elements[i].0 <= elements[0].0\n  {\n    var maxIndex := 0;\n    var i := 1;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant 0 <= maxIndex < i\n      invariant forall j :: 0 <= j < i ==> elements[j].0 <= elements[maxIndex].0\n    {\n      if elements[i].0 > elements[maxIndex].0 {\n        maxIndex := i;\n      }\n      i := i + 1;\n    }\n    maxValue := elements[maxIndex].1;\n  }\n}",
            "parents": [
                "8c9e371d-9a72-44a0-a710-e17ad30adf60"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "b1480f9a-935c-41eb-b723-fb581dc80a92",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n    invariant forall k, l :: 0 <= k < l < i && arr[k] < arr[l] ==> lis[l] >= lis[k] + 1\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n      invariant forall k, l :: 0 <= k < l < i && arr[k] < arr[l] ==> lis[l] >= lis[k] + 1\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  length := maxLength;\n  assert forall i, j :: 0 <= i < j < n && arr[i] < arr[j] ==> length >= j - i + 1;\n  return length;\n}",
            "parents": [
                "6819677d-762f-4841-96c0-8ee8c0023c83"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "8116ecc7-b1af-4f86-8d39-1a8fd190749e",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  \n  constructor() {\n    elements := [];\n  }\n  \n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  \n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  \n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures elements == old(elements)\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n  }\n  \n  method ChangePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n  {\n    var index := 0;\n    while index < |elements| && elements[index].1 != value\n      invariant 0 <= index <= |elements|\n      invariant forall k :: 0 <= k < index ==> elements[k].1 != value\n    {\n      index := index + 1;\n    }\n    elements := elements[..index] + elements[index + 1..];\n    \n    var i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n      invariant elements[..index] + elements[index + 1..] == old(elements[..index] + elements[index + 1..])\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [(newPriority, value)] + elements[i..];\n  }\n  \n  method RemoveValue(value: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures forall i :: 0 <= i < |elements| ==> elements[i].1 != value\n  {\n    var index := 0;\n    while index < |elements| && elements[index].1 != value\n      invariant 0 <= index <= |elements|\n      invariant forall k :: 0 <= k < index ==> elements[k].1 != value\n    {\n      index := index + 1;\n    }\n    elements := elements[..index] + elements[index + 1..];\n  }\n}",
            "parents": [
                "1ae24b06-f583-4ecf-976e-8e69df746946"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "4e886c45-2524-40ff-97c9-07e56e5b3248",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  \n  constructor() {\n    elements := [];\n  }\n  \n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  \n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  \n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  \n  method IsEmpty() returns (empty: bool)\n    ensures empty == (|elements| == 0)\n  {\n    var i := 0;\n    empty := true;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant empty == (i == 0)\n    {\n      empty := false;\n      i := i + 1;\n    }\n  }\n  \n  method ChangePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n  {\n    var i := 0;\n    var found := false;\n    while i < |elements| && !found\n      invariant 0 <= i <= |elements|\n      invariant !found ==> forall k :: 0 <= k < i ==> elements[k].1 != value\n    {\n      if elements[i].1 == value {\n        found := true;\n      } else {\n        i := i + 1;\n      }\n    }\n\n    if found {\n      elements := elements[..i] + elements[i+1..];\n      // Reinsert the element with the new priority\n      Enqueue(newPriority, value);\n    }\n  }\n}",
            "parents": [
                "a7ab0201-23ae-442c-af0b-6d83e2df1da6"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "4f70717c-fa8a-4c3e-a176-b57d478552f2",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n    ensures elements == old(elements)\n  {\n    var i := 0;\n    var highestPriority := elements[0].0;\n    value := elements[0].1;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= highestPriority\n      invariant exists k :: 0 <= k < |elements| && elements[k].0 == highestPriority && value == elements[k].1\n      invariant elements == old(elements)\n    {\n      if elements[i].0 < highestPriority {\n        highestPriority := elements[i].0;\n        value := elements[i].1;\n      }\n      i := i + 1;\n    }\n    assert value == elements[0].1;\n  }\n  method MaxPriority() returns (maxPriority: int)\n    requires |elements| > 0\n    ensures exists i :: 0 <= i < |elements| && elements[i].0 == maxPriority\n    ensures forall i :: 0 <= i < |elements| ==> elements[i].0 <= maxPriority\n    ensures elements == old(elements)\n  {\n    var i := 0;\n    maxPriority := elements[0].0;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant exists j :: 0 <= j < i && elements[j].0 == maxPriority\n      invariant forall j :: 0 <= j < i ==> elements[j].0 <= maxPriority\n      invariant elements == old(elements)\n    {\n      if elements[i].0 > maxPriority {\n        maxPriority := elements[i].0;\n      }\n      i := i + 1;\n    }\n    assert exists j :: 0 <= j < |elements| && elements[j].0 == maxPriority;\n    assert forall j :: 0 <= j < |elements| ==> elements[j].0 <= maxPriority;\n  }\n  method MinPriority() returns (minPriority: int)\n    requires |elements| > 0\n    ensures exists i :: 0 <= i < |elements| && elements[i].0 == minPriority\n    ensures forall i :: 0 <= i < |elements| ==> minPriority <= elements[i].0\n    ensures elements == old(elements)\n  {\n    var i := 0;\n    minPriority := elements[0].0;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant exists j :: 0 <= j < i && elements[j].0 == minPriority\n      invariant forall j :: 0 <= j < i ==> minPriority <= elements[j].0\n      invariant elements == old(elements)\n    {\n      if elements[i].0 < minPriority {\n        minPriority := elements[i].0;\n      }\n      i := i + 1;\n    }\n    assert exists j :: 0 <= j < |elements| && elements[j].0 == minPriority;\n    assert forall j :: 0 <= j < |elements| ==> minPriority <= elements[j].0;\n  }\n}",
            "parents": [
                "d40b64c5-9eb5-49f4-8871-ea79ff06007a"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "e11bc6e8-ee57-4100-a05d-fb1e32e1099f",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      decreases |elements| - i\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var index: int := 0;\n    // Find the element with the specified value\n    while index < |elements| && elements[index].1 != value\n      invariant 0 <= index <= |elements|\n      invariant forall k :: 0 <= k < index ==> elements[k].1 != value\n      decreases |elements| - index\n    {\n      index := index + 1;\n    }\n    // Update the priority of the found element\n    elements := elements[..index] + [(newPriority, value)] + elements[index+1..];\n    \n    // Reorder the queue to maintain the priority order\n    var i := 0;\n    var newElement := (newPriority, value);\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      decreases |elements| - i\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i+1..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method RemoveValue(value: int)\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var i := 0;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n      decreases |elements| - i\n    {\n      if elements[i].1 == value {\n        elements := elements[..i] + elements[i+1..];\n      } else {\n        i := i + 1;\n      }\n    }\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n}",
            "parents": [
                "69bf4859-15da-486c-891b-d173b3b7feeb"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "888044c4-28cb-4456-a199-4b0e214b5604",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> maxLength >= lis[k]\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> maxLength >= lis[k]\n    invariant forall k, l :: 0 <= k < l < i && arr[k] < arr[l] ==> lis[l] >= l - k + 1\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k :: 0 <= k < i ==> maxLength >= lis[k]\n      invariant forall k, l :: 0 <= k < l < i && arr[k] < arr[l] ==> lis[l] >= l - k + 1\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  length := maxLength;\n  assert forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> maxLength >= j - i + 1;\n  return maxLength;\n}",
            "parents": [
                "61e9d5ca-1914-428d-b234-13bcc1a34c86"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "0b890d47-6022-40cf-9951-ca851049a14b",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n\n  constructor() {\n    elements := [];\n  }\n\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n    assert elements == old(elements[1..]);\n  }\n\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n}",
            "parents": [
                "d90808c5-8a1b-42d1-a729-199a05e03f83"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "56e69a59-eae3-407a-b985-1c2f7b0dffdc",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures elements == old(elements)\n    ensures value == elements[0].1\n  {\n    var highestPriority := elements[0].0;\n    var highestValue := elements[0].1;\n    var i := 1;\n    while i < |elements|\n      invariant 1 <= i <= |elements|\n      invariant highestPriority == elements[0].0\n      invariant highestValue == elements[0].1\n      invariant forall k :: 0 <= k < i ==> elements[k].0 >= highestPriority\n    {\n      if elements[i].0 < highestPriority {\n        highestPriority := elements[i].0;\n        highestValue := elements[i].1;\n      }\n      i := i + 1;\n    }\n    value := highestValue;\n  }\n}",
            "parents": [
                "bd156f4f-816e-440e-9293-1f374647163a"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "1333ca17-3cc4-44ee-9f55-da5f5e7b192c",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      decreases |elements| - i\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method UpdatePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n      decreases |elements| - i\n    {\n      i := i + 1;\n    }\n    // Update the priority of the found element\n    elements := elements[..i] + [(newPriority, value)] + elements[i+1..];\n\n    // Reorder the queue to maintain the priority order\n    var j := i;\n    while j > 0 && elements[j-1].0 > newPriority\n      invariant 0 <= j <= |elements|\n      invariant forall k, l :: 0 <= k < l < j ==> elements[k].0 <= elements[l].0\n      invariant elements[j] == (newPriority, value)\n      decreases j\n    {\n      elements := elements[..j-1] + [elements[j]] + [elements[j-1]] + elements[j+1..];\n      j := j - 1;\n    }\n\n    while j < |elements|-1 && elements[j+1].0 < newPriority\n      invariant 0 <= j < |elements|\n      invariant forall k, l :: 0 <= k < l <= j ==> elements[k].0 <= elements[l].0\n      invariant elements[j] == (newPriority, value)\n      decreases |elements| - j\n    {\n      elements := elements[..j] + [elements[j+1]] + [elements[j]] + elements[j+2..];\n      j := j + 1;\n    }\n  }\n}",
            "parents": [
                "0f1548de-c7de-4300-9e7f-6095af0a9221"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "e063aeb7-5fa9-4584-85ea-ee07fc52563d",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      decreases |elements| - i\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n    ensures elements == old(elements)\n  {\n    var i := 0;\n    var highestPriority := elements[0].0;\n    value := elements[0].1;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= highestPriority\n      invariant exists k :: 0 <= k < |elements| && elements[k].0 == highestPriority && value == elements[k].1\n      decreases |elements| - i\n    {\n      if elements[i].0 < highestPriority {\n        highestPriority := elements[i].0;\n        value := elements[i].1;\n      }\n      i := i + 1;\n    }\n    assert value == elements[0].1;\n  }\n  method IsEmpty() returns (empty: bool)\n    ensures empty <==> |elements| == 0\n  {\n    empty := |elements| == 0;\n  }\n  method ChangePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var i := 0;\n    var found := false;\n    while i < |elements| && !found\n      invariant 0 <= i <= |elements|\n      invariant !found ==> forall k :: 0 <= k < i ==> elements[k].1 != value\n      decreases |elements| - i\n    {\n      if elements[i].1 == value {\n        found := true;\n      } else {\n        i := i + 1;\n      }\n    }\n    if found {\n      var updatedElement := (newPriority, value);\n      elements := elements[..i] + elements[i+1..];\n      var j := 0;\n      while j < |elements| && elements[j].0 <= newPriority\n        invariant 0 <= j <= |elements|\n        invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n        invariant forall k, l :: 0 <= k < l < j ==> elements[k].0 <= elements[l].0\n        decreases |elements| - j\n      {\n        j := j + 1;\n      }\n      elements := elements[..j] + [updatedElement] + elements[j..];\n    }\n  }\n}",
            "parents": [
                "06cd1966-f899-48a7-9e36-abbd4c412b53"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "e5a18123-9dd6-4cf9-bd1c-eeceb27a9bb2",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n}",
            "parents": [
                "3803a3ca-da34-4a1b-8cf7-61aa3bb9676f"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "8cfcb0e7-d64e-4592-9d60-3ae6b1d10e8e",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n      invariant exists j :: i <= j < |elements| ==> elements[j].1 == value\n    {\n      i := i + 1;\n    }\n    var updatedElement := (newPriority, value);\n    elements := elements[..i] + elements[i+1..];\n    \n    // Re-insert the updated element\n    var j := 0;\n    while j < |elements| && elements[j].0 <= newPriority\n      invariant 0 <= j <= |elements|\n      invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < j ==> elements[k].0 <= elements[l].0\n    {\n      j := j + 1;\n    }\n    elements := elements[..j] + [updatedElement] + elements[j..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n}",
            "parents": [
                "155a201f-9ae9-44b2-bf7e-ed15c1c215f8"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "0f53fe46-09d8-4eed-8940-0543d8e5698d",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  \n  constructor() {\n    elements := [];\n  }\n\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n}",
            "parents": [
                "484d78c6-113c-42af-b1b4-c7fc5108d3b1"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "0afd3d56-6df2-4689-b6b9-55836841c075",
            "type": "program",
            "content": "method IsValidStackSequence(operations: seq<string>) returns (isValid: bool)\n  ensures isValid == (forall i :: 0 <= i < |operations| ==> operations[i] == \"push\" || operations[i] == \"pop\")\n{\n  var stackSize := 0;\n  isValid := true;\n  // Loop through each operation in the sequence\n  for i := 0 to |operations| \n    invariant 0 <= stackSize\n    invariant 0 <= i <= |operations|\n    invariant isValid == (forall j :: 0 <= j < i ==> operations[j] == \"push\" || operations[j] == \"pop\")\n    invariant isValid ==> (forall j :: 0 <= j < i ==> stackSize >= 0)\n  {\n    if operations[i] == \"push\" {\n      stackSize := stackSize + 1;\n    } else if operations[i] == \"pop\" {\n      if stackSize == 0 {\n        isValid := false;\n        return;\n      }\n      stackSize := stackSize - 1;\n    } else {\n      isValid := false;\n      return;\n    }\n  }\n}",
            "parents": [
                "c38461f0-ed34-4bda-9e59-64250a060952"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "06e8253e-7af0-4cfc-82d9-ee4904775129",
            "type": "program",
            "content": "method QuickSort(a: array<int>, lo: int, hi: int)\n  requires 0 <= lo <= hi <= a.Length\n  modifies a\n  ensures forall i, j :: lo <= i <= j < hi ==> a[i] <= a[j]\n{\n  if lo < hi {\n    var p := Partition(a, lo, hi);\n    QuickSort(a, lo, p);\n    QuickSort(a, p + 1, hi);\n  }\n}\n\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIndex: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIndex < hi\n  ensures forall i :: lo <= i < pivotIndex ==> a[i] <= a[pivotIndex]\n  ensures forall i :: pivotIndex < i < hi ==> a[pivotIndex] <= a[i]\n{\n  var pivot := a[lo];\n  var i := lo;\n  var j := hi;\n  while i < j\n    invariant lo <= i <= j <= hi\n    invariant forall k :: lo <= k < i ==> a[k] <= pivot\n    invariant forall k :: j <= k < hi ==> a[k] >= pivot\n    invariant exists p :: lo <= p < hi && a[p] == pivot\n  {\n    while i < j && a[i] <= pivot\n      invariant lo <= i < hi\n      invariant forall k :: lo <= k < i ==> a[k] <= pivot\n    {\n      i := i + 1;\n    }\n    while i < j && a[j - 1] >= pivot\n      invariant lo < j <= hi\n      invariant forall k :: j <= k < hi ==> a[k] >= pivot\n    {\n      j := j - 1;\n    }\n    if i < j {\n      a[i], a[j - 1] := a[j - 1], a[i];\n    }\n  }\n  pivotIndex := j - 1;\n  a[lo], a[pivotIndex] := a[pivotIndex], a[lo];\n  assert forall i :: lo <= i < pivotIndex ==> a[i] <= a[pivotIndex];\n  assert forall i :: pivotIndex < i < hi ==> a[pivotIndex] <= a[i];\n}",
            "parents": [
                "9148a44b-6079-45fb-b7ba-172a8e0d446e"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "201fa1f8-5faf-4bc3-9405-f339c3d394d2",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method UpdatePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures forall i :: 0 <= i < |elements| ==> elements[i].1 != value || elements[i].0 == newPriority\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n\n    // Remove the element with the old priority\n    elements := elements[..i] + elements[i+1..];\n\n    // Reinsert the element with the new priority\n    var newElement := (newPriority, value);\n    i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n}",
            "parents": [
                "9cb1c3ae-4da1-45fc-809b-4374d83d99c5"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "363211b0-914a-4995-a831-498d246397d5",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures elements == old(elements)\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n  }\n  method IsEmpty() returns (empty: bool)\n    ensures empty == (|elements| == 0)\n  {\n    empty := |elements| == 0;\n  }\n  method ChangePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    var element := elements[i];\n    elements := elements[..i] + elements[i+1..];\n    \n    // Re-insert the element with the new priority\n    var newElement := (newPriority, value);\n    i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant elements == old(elements[..i]) + old(elements[i..])\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n}",
            "parents": [
                "e25da69b-a348-4730-83a2-44f2483ff655"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "b9836467-5c92-494e-be04-ab3271791b8c",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method UpdatePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n    {\n      i := i + 1;\n    }\n    \n    var oldElement := elements[i];\n    elements := elements[..i] + elements[i+1..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n\n    // Reinsert the element with the new priority\n    var newElement := (newPriority, value);\n    var j := 0;\n    while j < |elements| && elements[j].0 <= newPriority\n      invariant 0 <= j <= |elements|\n      invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < j ==> elements[k].0 <= elements[l].0\n    {\n      j := j + 1;\n    }\n    elements := elements[..j] + [newElement] + elements[j..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n}",
            "parents": [
                "92187984-0b8a-4ac1-bf23-2b9ed3120806"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "ad11703a-a485-458e-ab6c-272343643815",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  \n  constructor() {\n    elements := [];\n  }\n\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    var i := 0;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 >= elements[i].0\n      invariant forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0\n    {\n      if elements[i].0 > elements[0].0 {\n        value := elements[i].1;\n        return;\n      }\n      i := i + 1;\n    }\n    value := elements[0].1;\n  }\n}",
            "parents": [
                "a4d15c75-3986-4d86-a258-d9575b39682b"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "51ffb355-c89e-4deb-9c06-acf704b53757",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures elements == old(elements)\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n  }\n  method UpdatePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var index := -1;\n    var i := 0;\n    // Find the index of the element with the given value\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant index == -1 ==> forall k :: 0 <= k < i ==> elements[k].1 != value\n      invariant index != -1 ==> 0 <= index < |elements| && elements[index].1 == value\n    {\n      if elements[i].1 == value {\n        index := i;\n        break;\n      }\n      i := i + 1;\n    }\n    \n    // Remove the element at the found index\n    var element := elements[index];\n    elements := elements[..index] + elements[index + 1..];\n\n    // Re-insert the element with the new priority\n    var newElement := (newPriority, value);\n    i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n      invariant elements[..index] + elements[index + 1..] == old(elements[..index] + elements[index + 1..])\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n}",
            "parents": [
                "591b5fe3-7521-4743-a960-e11e7013292c"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "7d3e9451-05c2-4835-8763-6cfd0d436673",
            "type": "program",
            "content": "method DotProduct(a: seq<int>, b: seq<int>) returns (result: int)\n  requires |a| == |b|\n  ensures result == DotProductSpec(a, b)\n{\n  var sum := 0;\n  var i := 0;\n  while i < |a|\n    invariant 0 <= i <= |a|\n    invariant sum == DotProductSpec(a[..i], b[..i])\n    decreases |a| - i\n  {\n    sum := sum + a[i] * b[i];\n    i := i + 1;\n  }\n  result := sum;\n}\n\nfunction DotProductSpec(a: seq<int>, b: seq<int>): int\n  requires |a| == |b|\n{\n  if |a| == 0 then 0 else a[0] * b[0] + DotProductSpec(a[1..], b[1..])\n}",
            "parents": [
                "775329f6-3267-4f17-b9d7-56f5fe0f1959"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "5028175a-a45c-4323-8f82-d31dd3775300",
            "type": "program",
            "content": "class Graph {\n  var adjacencyMatrix: array2<bool>;\n\n  constructor(n: nat) \n    requires n > 0\n    ensures adjacencyMatrix.Length0 == n && adjacencyMatrix.Length1 == n\n    ensures forall i, j :: 0 <= i < n && 0 <= j < n ==> !adjacencyMatrix[i, j]\n  {\n    adjacencyMatrix := new bool[n, n];\n  }\n\n  method AddEdge(u: nat, v: nat)\n    requires 0 <= u < adjacencyMatrix.Length0\n    requires 0 <= v < adjacencyMatrix.Length1\n    modifies adjacencyMatrix\n    ensures adjacencyMatrix[u, v] && adjacencyMatrix[v, u]\n  {\n    adjacencyMatrix[u, v] := true;\n    adjacencyMatrix[v, u] := true;\n  }\n\n  method IsVertexCover(cover: set<nat>) returns (isCover: bool)\n    requires cover <= set i | 0 <= i < adjacencyMatrix.Length0\n    ensures isCover == (forall u, v :: 0 <= u < adjacencyMatrix.Length0 && 0 <= v < adjacencyMatrix.Length1 && adjacencyMatrix[u, v] ==> u in cover || v in cover)\n  {\n    isCover := true;\n    var n := adjacencyMatrix.Length0;\n    for u := 0 to n - 1 {\n      for v := 0 to n - 1 {\n        if adjacencyMatrix[u, v] && !(u in cover || v in cover) {\n          isCover := false;\n          return;\n        }\n      }\n    }\n  }\n\n  method IsCompleteGraph() returns (isComplete: bool)\n    ensures isComplete == (forall u, v :: 0 <= u < adjacencyMatrix.Length0 && 0 <= v < adjacencyMatrix.Length1 && u != v ==> adjacencyMatrix[u, v])\n  {\n    isComplete := true;\n    var n := adjacencyMatrix.Length0;\n    for u := 0 to n - 1\n      invariant 0 <= u <= n\n      invariant isComplete == (forall i, j :: 0 <= i < u && 0 <= j < n && i != j ==> adjacencyMatrix[i, j])\n    {\n      for v := 0 to n - 1\n        invariant 0 <= v <= n\n        invariant isComplete == (forall i, j :: 0 <= i < u && 0 <= j < n && i != j ==> adjacencyMatrix[i, j]) &&\n                               (forall j :: 0 <= j < v && u != j ==> adjacencyMatrix[u, j])\n      {\n        if u != v && !adjacencyMatrix[u, v] {\n          isComplete := false;\n          return;\n        }\n      }\n    }\n  }\n}",
            "parents": [
                "498b0fa7-33e0-4d30-958c-71042506ae70"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "e8b7ef81-6f96-4c24-8137-f3e00f76dd78",
            "type": "program",
            "content": "class Vector3D {\n  var x: int\n  var y: int\n  var z: int\n\n  constructor(x: int, y: int, z: int) \n    ensures this.x == x && this.y == y && this.z == z\n  {\n    this.x := x;\n    this.y := y;\n    this.z := z;\n  }\n\n  method CrossProduct(other: Vector3D) returns (result: Vector3D)\n    ensures result.x == this.y * other.z - this.z * other.y\n    ensures result.y == this.z * other.x - this.x * other.z\n    ensures result.z == this.x * other.y - this.y * other.x\n  {\n    var cx := this.y * other.z - this.z * other.y;\n    var cy := this.z * other.x - this.x * other.z;\n    var cz := this.x * other.y - this.y * other.x;\n    result := new Vector3D(cx, cy, cz);\n  }\n\n  method DotProduct(other: Vector3D) returns (result: int)\n    ensures result == this.x * other.x + this.y * other.y + this.z * other.z\n  {\n    var sum := 0;\n    var components := [this.x, this.y, this.z];\n    var otherComponents := [other.x, other.y, other.z];\n\n    // Loop over each component to calculate the dot product\n    var i := 0;\n    while i < 3\n      invariant 0 <= i <= 3\n      invariant sum == (if i >= 1 then components[0] * otherComponents[0] else 0)\n                        + (if i >= 2 then components[1] * otherComponents[1] else 0)\n                        + (if i >= 3 then components[2] * otherComponents[2] else 0)\n    {\n      sum := sum + components[i] * otherComponents[i];\n      i := i + 1;\n    }\n\n    result := sum;\n  }\n}",
            "parents": [
                "57d32a85-5e5d-45b8-90e4-937bf98d119a"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "SUCCESS"
            }
        },
        {
            "id": "79317c81-04fe-4411-b0bc-b8df1abcfff2",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures elements == old(elements)\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n  }\n  method IsEmpty() returns (empty: bool)\n    ensures empty <==> |elements| == 0\n    ensures elements == old(elements)\n  {\n    empty := |elements| == 0;\n  }\n  method Merge(other: PriorityQueue)\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures elements == old(elements) + other.elements\n  {\n    var i := 0;\n    var j := 0;\n    var merged: seq<(int, int)> := [];\n    \n    while i < |elements| || j < |other.elements|\n      invariant 0 <= i <= |elements|\n      invariant 0 <= j <= |other.elements|\n      invariant |merged| == i + j\n      invariant forall k :: 0 <= k < |merged| ==> \n        (k < i ==> merged[k] == elements[k]) || \n        (k < j ==> merged[k] == other.elements[k])\n      invariant forall m, n :: 0 <= m < n < |merged| ==> merged[m].0 <= merged[n].0\n    {\n      if i < |elements| && (j >= |other.elements| || elements[i].0 <= other.elements[j].0) {\n        merged := merged + [elements[i]];\n        i := i + 1;\n      } else {\n        merged := merged + [other.elements[j]];\n        j := j + 1;\n      }\n    }\n    \n    elements := merged;\n  }\n}",
            "parents": [
                "d4b6e572-e584-44e8-b53f-b48b9944e3d4"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "fd2b4a74-da6d-4ea1-a5d7-de13c1744c4a",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant exists i: int :: left <= i <= right && arr[i] == arr[k]\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "2a93c70b-5d1a-44f8-8e69-8a8fc19af630"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "779c2727-eb17-4833-ad2b-d93ce47ec838",
            "type": "program",
            "content": "class Graph {\n  var adjacencyMatrix: array2<bool>;\n\n  constructor(n: nat) \n    requires n > 0\n    ensures adjacencyMatrix.Length0 == n && adjacencyMatrix.Length1 == n\n    ensures forall i, j :: 0 <= i < n && 0 <= j < n ==> !adjacencyMatrix[i, j]\n  {\n    adjacencyMatrix := new bool[n, n];\n  }\n\n  method AddEdge(u: nat, v: nat)\n    requires 0 <= u < adjacencyMatrix.Length0\n    requires 0 <= v < adjacencyMatrix.Length1\n    modifies adjacencyMatrix\n    ensures adjacencyMatrix[u, v] && adjacencyMatrix[v, u]\n  {\n    adjacencyMatrix[u, v] := true;\n    adjacencyMatrix[v, u] := true;\n  }\n\n  method IsVertexCover(cover: set<nat>) returns (isCover: bool)\n    requires cover <= set i | 0 <= i < adjacencyMatrix.Length0\n    ensures isCover == (forall u, v :: 0 <= u < adjacencyMatrix.Length0 && 0 <= v < adjacencyMatrix.Length1 && adjacencyMatrix[u, v] ==> u in cover || v in cover)\n  {\n    isCover := true;\n    var n := adjacencyMatrix.Length0;\n    for u := 0 to n - 1 \n      invariant 0 <= u <= n\n      invariant isCover ==> (forall i, j :: 0 <= i < u && 0 <= j < n && adjacencyMatrix[i, j] ==> i in cover || j in cover)\n    {\n      for v := 0 to n - 1 \n        invariant 0 <= v <= n\n        invariant isCover ==> (forall i, j :: 0 <= i < u && 0 <= j < n && adjacencyMatrix[i, j] ==> i in cover || j in cover) &&\n                               (forall j :: 0 <= j < v && adjacencyMatrix[u, j] ==> u in cover || j in cover)\n      {\n        if adjacencyMatrix[u, v] && !(u in cover || v in cover) {\n          isCover := false;\n          return;\n        }\n      }\n    }\n  }\n\n  method IsCompleteGraph() returns (isComplete: bool)\n    ensures isComplete == (forall u, v :: 0 <= u < adjacencyMatrix.Length0 && 0 <= v < adjacencyMatrix.Length1 && u != v ==> adjacencyMatrix[u, v])\n  {\n    isComplete := true;\n    var n := adjacencyMatrix.Length0;\n    for u := 0 to n - 1\n      invariant 0 <= u <= n\n      invariant isComplete ==> (forall i, j :: 0 <= i < u && 0 <= j < n && i != j ==> adjacencyMatrix[i, j])\n    {\n      for v := 0 to n - 1\n        invariant 0 <= v <= n\n        invariant isComplete ==> (forall i, j :: 0 <= i < u && 0 <= j < n && i != j ==> adjacencyMatrix[i, j]) &&\n                               (forall j :: 0 <= j < v && u != j ==> adjacencyMatrix[u, j])\n      {\n        if u != v && !adjacencyMatrix[u, v] {\n          isComplete := false;\n          return;\n        }\n      }\n    }\n  }\n}",
            "parents": [
                "be5a346d-4dd0-413f-b663-d4a2805396b5"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "5b6d7825-1255-4e49-984d-5026650d1dcd",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method UpdatePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i :: 0 <= i < |elements| ==> elements[i].1 != value || elements[i].0 == newPriority\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n    {\n      i := i + 1;\n    }\n    // Remove the element with the specified value\n    elements := elements[..i] + elements[i+1..];\n    \n    // Re-insert the element with the new priority\n    var newElement := (newPriority, value);\n    i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n}",
            "parents": [
                "26b87d8c-452b-4b80-b26c-15255669796e"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "ba7c54d6-ecc0-49e9-a24a-908197f4ce1d",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements[..i]) + elements[i..]\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures elements == old(elements)\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(oldValue: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == oldValue\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, oldValue)\n  {\n    var i := 0;\n    // Find the element with the specified value\n    while i < |elements| && elements[i].1 != oldValue\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != oldValue\n    {\n      i := i + 1;\n    }\n    // Remove the element\n    elements := elements[..i] + elements[i+1..];\n    \n    // Reinsert the element with the new priority\n    var newElement := (newPriority, oldValue);\n    var j := 0;\n    while j < |elements| && elements[j].0 <= newPriority\n      invariant 0 <= j <= |elements|\n      invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n      invariant elements == old(elements[..j]) + elements[j..]\n    {\n      j := j + 1;\n    }\n    elements := elements[..j] + [newElement] + elements[j..];\n  }\n  method Merge(other: PriorityQueue)\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures |elements| == old(|elements|) + |other.elements|\n    ensures forall e :: e in other.elements ==> e in elements\n  {\n    var i := 0;\n    while i < |other.elements|\n      invariant 0 <= i <= |other.elements|\n      invariant |elements| == old(|elements|) + i\n      invariant forall j, k :: 0 <= j < k < |elements| ==> elements[j].0 <= elements[k].0\n      invariant forall e :: e in other.elements[..i] ==> e in elements\n    {\n      var (priority, value) := other.elements[i];\n      this.Enqueue(priority, value);\n      i := i + 1;\n    }\n  }\n}",
            "parents": [
                "add9b37b-529c-41d8-9a87-1190d778fa35"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "6d0b1b27-1adb-46b3-be08-2eb0461bcd67",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  \n  constructor() {\n    elements := [];\n  }\n\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant forall k, l :: 0 <= k < l < |elements| && l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n}",
            "parents": [
                "e7f96eb4-f733-4ffe-a8eb-7f1637baa987"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "2491a196-592a-414e-91f5-e25ce316d94a",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant exists i: int :: left <= i <= right && arr[i] == arr[k]\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "065eed14-ae0c-40ee-91ad-58653b3a822a"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "8660b894-119a-4cdd-a72f-a1355d37e38f",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  \n  constructor() {\n    elements := [];\n  }\n\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n\n  method IsEmpty() returns (isEmpty: bool)\n    ensures isEmpty == (|elements| == 0)\n  {\n    isEmpty := |elements| == 0;\n  }\n}",
            "parents": [
                "fcd79252-c8a7-44f5-a5eb-75d9da8e1c42"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "1d06e5ef-4a3b-4132-911a-c76744fac0c6",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> maxLength >= lis[k]\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> maxLength >= lis[k]\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k :: 0 <= k < i ==> maxLength >= lis[k]\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n}",
            "parents": [
                "31829012-41f3-4073-a7fe-5dc8bb07c32c"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "fea41cd3-0c98-4184-86db-d3482c20f352",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> maxLength >= lis[k]\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> maxLength >= lis[k]\n    invariant forall k, l :: 0 <= k < l < i && arr[k] < arr[l] ==> lis[l] >= l - k + 1\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k, l :: 0 <= k < l < i && arr[k] < arr[l] ==> lis[l] >= l - k + 1\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n}",
            "parents": [
                "31b41f21-d4dc-4fb5-9af8-cfdc6f0e4819"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "2de54079-e9f3-489d-8e85-e16a1594e3f9",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(oldValue: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == oldValue\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, oldValue)\n    ensures |elements| == old(|elements|)\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != oldValue\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != oldValue\n    {\n      i := i + 1;\n    }\n\n    // Remove the element with oldValue\n    var removedElement := elements[i];\n    elements := elements[..i] + elements[i+1..];\n\n    // Insert the element with the new priority\n    var newElement := (newPriority, oldValue);\n    i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Merge(other: PriorityQueue)\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures |elements| == old(|elements|) + |other.elements|\n    ensures forall e :: e in other.elements ==> e in elements\n  {\n    var i := 0;\n    var j := 0;\n    var merged: seq<(int, int)> := [];\n\n    while i < |elements| || j < |other.elements|\n      invariant 0 <= i <= |elements|\n      invariant 0 <= j <= |other.elements|\n      invariant |merged| == i + j\n      invariant forall k, l :: 0 <= k < l < |merged| ==> merged[k].0 <= merged[l].0\n      invariant forall e :: e in merged ==> e in old(elements) || e in other.elements\n    {\n      if i < |elements| && (j >= |other.elements| || elements[i].0 <= other.elements[j].0) {\n        merged := merged + [elements[i]];\n        i := i + 1;\n      } else {\n        merged := merged + [other.elements[j]];\n        j := j + 1;\n      }\n    }\n    elements := merged;\n  }\n}",
            "parents": [
                "66fdcb2f-b2cf-47e1-95ba-fa7d78da2ebe"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "06fb5e5e-4b6f-440b-871a-14fa6b27da4e",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures elements == old(elements)\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n  }\n  method IsEmpty() returns (empty: bool)\n    ensures empty == (|elements| == 0)\n  {\n    empty := |elements| == 0;\n  }\n  method IncreasePriority(index: int, newPriority: int)\n    requires 0 <= index < |elements|\n    requires elements[index].0 < newPriority\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var value := elements[index].1;\n    elements := elements[..index] + elements[index + 1..];\n    var i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [(newPriority, value)] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n}",
            "parents": [
                "f886053e-05d3-4973-b218-f7f646b7c094"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "a5c95943-2ac4-41d8-95c3-957e17e6059b",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  \n  constructor() {\n    elements := [];\n  }\n\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n\n  method IsEmpty() returns (isEmpty: bool)\n    ensures isEmpty == (|elements| == 0)\n  {\n    isEmpty := |elements| == 0;\n  }\n\n  method Merge(other: PriorityQueue)\n    modifies this\n    ensures |elements| == |old(elements)| + |other.elements|\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures multiset(elements) == multiset(old(elements) + other.elements)\n  {\n    var merged: seq<(int, int)> := [];\n    var i := 0;\n    var j := 0;\n\n    while i < |elements| || j < |other.elements|\n      invariant 0 <= i <= |elements|\n      invariant 0 <= j <= |other.elements|\n      invariant |merged| == i + j\n      invariant forall k, l :: 0 <= k < l < |merged| ==> merged[k].0 <= merged[l].0\n      invariant multiset(merged) == multiset(elements[..i] + other.elements[..j])\n    {\n      if i < |elements| && (j >= |other.elements| || elements[i].0 <= other.elements[j].0) {\n        merged := merged + [elements[i]];\n        i := i + 1;\n      } else {\n        merged := merged + [other.elements[j]];\n        j := j + 1;\n      }\n    }\n\n    elements := merged;\n  }\n}",
            "parents": [
                "8a055deb-e29d-43a5-b9f2-6a020ce38fdb"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "edf3769d-4637-4380-8b3a-7ba278f79f2d",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k, l :: 0 <= k < l < i && arr[k] < arr[l] ==> lis[k] < lis[l]\n    invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k, l :: 0 <= k < l < i && arr[k] < arr[l] ==> lis[k] < lis[l]\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  assert forall k, l :: 0 <= k < l < n && arr[k] < arr[l] ==> lis[k] < lis[l];\n  length := maxLength;\n}",
            "parents": [
                "10e94b86-05ce-4596-a109-63655f8e7f96"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "855b80b3-1878-4a09-8a0c-744c244d8285",
            "type": "program",
            "content": "class Graph {\n  var adjacencyMatrix: array2<bool>;\n\n  constructor(n: nat) \n    requires n > 0\n    ensures adjacencyMatrix.Length0 == n && adjacencyMatrix.Length1 == n\n    ensures forall i, j :: 0 <= i < n && 0 <= j < n ==> !adjacencyMatrix[i, j]\n  {\n    adjacencyMatrix := new bool[n, n];\n  }\n\n  method AddEdge(u: nat, v: nat)\n    requires 0 <= u < adjacencyMatrix.Length0\n    requires 0 <= v < adjacencyMatrix.Length1\n    modifies adjacencyMatrix\n    ensures adjacencyMatrix[u, v] && adjacencyMatrix[v, u]\n  {\n    adjacencyMatrix[u, v] := true;\n    adjacencyMatrix[v, u] := true;\n  }\n\n  method IsVertexCover(cover: set<nat>) returns (isCover: bool)\n    requires cover <= set i | 0 <= i < adjacencyMatrix.Length0\n    ensures isCover == (forall u, v :: 0 <= u < adjacencyMatrix.Length0 && 0 <= v < adjacencyMatrix.Length1 && adjacencyMatrix[u, v] ==> u in cover || v in cover)\n  {\n    isCover := true;\n    var n := adjacencyMatrix.Length0;\n    for u := 0 to n - 1 \n      invariant 0 <= u <= n\n      invariant isCover == (forall i, j :: 0 <= i < u && 0 <= j < n && adjacencyMatrix[i, j] ==> i in cover || j in cover)\n    {\n      for v := 0 to n - 1 \n        invariant 0 <= v <= n\n        invariant isCover == (forall i, j :: 0 <= i < u && 0 <= j < n && adjacencyMatrix[i, j] ==> i in cover || j in cover)\n        invariant isCover == (forall j :: 0 <= j < v && adjacencyMatrix[u, j] ==> u in cover || j in cover)\n      {\n        if adjacencyMatrix[u, v] && !(u in cover || v in cover) {\n          isCover := false;\n          return;\n        }\n      }\n    }\n  }\n\n  method VertexDegree(u: nat) returns (degree: nat)\n    requires 0 <= u < adjacencyMatrix.Length0\n    ensures degree == |set v | 0 <= v < adjacencyMatrix.Length1 && adjacencyMatrix[u, v]|\n  {\n    degree := 0;\n    var n := adjacencyMatrix.Length1;\n    for v := 0 to n - 1\n      invariant 0 <= v <= n\n      invariant degree == |set j | 0 <= j < v && adjacencyMatrix[u, j]|\n    {\n      if adjacencyMatrix[u, v] {\n        degree := degree + 1;\n      }\n    }\n  }\n}",
            "parents": [
                "54d07980-49cf-42bc-a80b-8a2e914458cb"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "c7bbdab0-96fd-44a2-9bdb-a64b89c38d9b",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(oldPriority: int, value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i] == (oldPriority, value)\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var i := 0;\n    while i < |elements| && elements[i] != (oldPriority, value)\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k] != (oldPriority, value)\n      invariant exists j :: i <= j < |elements| && elements[j] == (oldPriority, value)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + elements[i+1..];\n    var newElement := (newPriority, value);\n    i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n      invariant elements == old(elements[..i]) + old(elements[i..])\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Merge(other: PriorityQueue)\n    modifies this\n    ensures forall e :: e in other.elements ==> e in elements\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var i := 0;\n    while i < |other.elements|\n      invariant 0 <= i <= |other.elements|\n      invariant forall k :: 0 <= k < i ==> other.elements[k] in elements\n      invariant forall m, n :: 0 <= m < n < |elements| ==> elements[m].0 <= elements[n].0\n    {\n      var (priority, value) := other.elements[i];\n      Enqueue(priority, value);\n      i := i + 1;\n    }\n  }\n}",
            "parents": [
                "ccb6166f-bc59-489b-82d3-264b2c7d7f30"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "bf5bd331-33a9-4d63-8a4b-9e96bbb7e4a4",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n    invariant forall k, l :: 0 <= k < l < i && arr[k] < arr[l] ==> lis[l] >= lis[k] + 1\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n      invariant forall k, l :: 0 <= k < l < i && arr[k] < arr[l] ==> lis[l] >= lis[k] + 1\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n}",
            "parents": [
                "529870c8-8186-42dd-98a5-98af9652ac99"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "faf89847-f9e5-4687-a7ec-1836751a3bcd",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant exists i: int :: left <= i <= right && \n              (forall j: int :: left <= j < i ==> arr[j] <= arr[i]) &&\n              (forall j: int :: i < j <= right ==> arr[j] >= arr[i])\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n    invariant arr[right] == pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "fa5be51d-627c-416b-a66e-63acfeb27a87"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "9b6a4e52-1172-4a58-a4d7-61afc1c94ca6",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method UpdatePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n  {\n    var index := 0;\n    while index < |elements| && elements[index].1 != value\n      invariant 0 <= index <= |elements|\n      invariant forall k :: 0 <= k < index ==> elements[k].1 != value\n      invariant exists i :: 0 <= i < |elements| ==> elements[i].1 == value\n    {\n      index := index + 1;\n    }\n\n    // Remove the element with the specified value\n    var priority := elements[index].0;\n    elements := elements[..index] + elements[index + 1..];\n\n    // Reinsert the element with the new priority\n    var newElement := (newPriority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method ChangePriority(currentPriority: int, value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i] == (currentPriority, value)\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n  {\n    var index := 0;\n    while index < |elements| && elements[index] != (currentPriority, value)\n      invariant 0 <= index <= |elements|\n      invariant forall k :: 0 <= k < index ==> elements[k] != (currentPriority, value)\n      invariant exists i :: 0 <= i < |elements| ==> elements[i] == (currentPriority, value)\n    {\n      index := index + 1;\n    }\n\n    // Remove the element with the specified current priority and value\n    elements := elements[..index] + elements[index + 1..];\n\n    // Reinsert the element with the new priority\n    var newElement := (newPriority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n}",
            "parents": [
                "ce799535-df97-4a13-84d8-d84fe5a25b2a"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "008bcdc9-239c-422e-a77a-96e6321d0b7d",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures elements == old(elements)\n    ensures value == elements[0].1\n  {\n    var highestPriority := elements[0].0;\n    var highestValue := elements[0].1;\n    var i := 1;\n    while i < |elements|\n      invariant 1 <= i <= |elements|\n      invariant highestPriority == elements[0].0\n      invariant highestValue == elements[0].1\n      invariant forall k :: 0 <= k < i ==> elements[k].0 >= highestPriority\n    {\n      if elements[i].0 < highestPriority {\n        highestPriority := elements[i].0;\n        highestValue := elements[i].1;\n      }\n      i := i + 1;\n    }\n    value := highestValue;\n  }\n  method ChangePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n    {\n      i := i + 1;\n    }\n    // Remove the element with the specified value\n    elements := elements[..i] + elements[i+1..];\n    \n    // Re-insert the element with the new priority\n    var newElement := (newPriority, value);\n    i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n}",
            "parents": [
                "f4459605-baa8-46a1-9144-2895e6e19d8a"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "8effe3db-7909-493a-a378-f681a23f3b44",
            "type": "program",
            "content": "method IsValidSudokuRow(board: array2<int>, row: int) returns (isValid: bool)\n  requires 0 <= row < board.Length0\n  requires board.Length1 == 9\n  ensures isValid == (forall i, j :: 0 <= i < j < 9 ==> board[row, i] != board[row, j])\n{\n  var seen := new bool[9];\n  isValid := true;\n  for i := 0 to 8\n    invariant 0 <= i <= 9\n    invariant forall k :: 0 <= k < i ==> 0 <= board[row, k] < 9\n    invariant forall k :: 0 <= k < i ==> seen[board[row, k]]\n    invariant isValid == (forall a, b :: 0 <= a < b < i ==> board[row, a] != board[row, b])\n  {\n    assert 0 <= board[row, i] < 9; // Ensure the board value is within the valid range\n    if seen[board[row, i]] {\n      isValid := false;\n      return;\n    }\n    seen[board[row, i]] := true;\n  }\n  assert isValid == (forall a, b :: 0 <= a < b < 9 ==> board[row, a] != board[row, b]);\n}",
            "parents": [
                "ad026a0a-9fde-4780-ad90-93c8c97b0ce0"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "44e25b3e-abee-48d4-9c9c-472f375293c8",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant exists i: int :: left <= i <= right && arr[i] == arr[k]\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "f038a5d8-275a-4dd5-90bc-387ecb85ff56"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "c907e7f3-c0a4-40cb-88a0-7a0f17020d38",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(oldPriority: int, value: int, newPriority: int)\n    requires |elements| > 0\n    requires exists i :: 0 <= i < |elements| && elements[i] == (oldPriority, value)\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n  {\n    var i := 0;\n    while i < |elements| && elements[i] != (oldPriority, value)\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k] != (oldPriority, value)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + elements[i+1..];\n    \n    var newElement := (newPriority, value);\n    i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n}",
            "parents": [
                "6ca6a783-0034-4eb2-a963-79966c92f6cb"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "f86d050a-66f5-4efb-81f3-9aa0b265937b",
            "type": "program",
            "content": "method DotProduct(a: seq<int>, b: seq<int>) returns (result: int)\n  requires |a| == |b|\n  ensures result == DotProductSpec(a, b)\n{\n  var sum := 0;\n  var i := 0;\n  while i < |a|\n    invariant 0 <= i <= |a|\n    invariant sum == DotProductSpec(a[..i], b[..i])\n    decreases |a| - i\n  {\n    sum := sum + a[i] * b[i];\n    i := i + 1;\n  }\n  result := sum;\n}\n\nfunction DotProductSpec(a: seq<int>, b: seq<int>): int\n  requires |a| == |b|\n{\n  if |a| == 0 then 0 else a[0] * b[0] + DotProductSpec(a[1..], b[1..])\n}",
            "parents": [
                "3b31f8d6-915d-4c75-a055-6ecea83e97ec"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "c617ee03-ca62-459d-8a2d-b68a3d0e1ee4",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant exists i: int :: left <= i <= right && \n              (forall j: int :: left <= j < i ==> arr[j] <= arr[i]) &&\n              (forall j: int :: i < j <= right ==> arr[j] >= arr[i])\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "4f56a2ae-252f-446c-b5a5-04953416e58d"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "037750f1-bcb5-4f4b-be4c-bd80fe14ad3f",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n    invariant forall k :: 0 <= k < i && lis[k] > 1 ==> exists m :: 0 <= m < k && arr[m] < arr[k] && lis[m] + 1 == lis[k]\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n      invariant forall k :: 0 <= k < i && lis[k] > 1 ==> exists m :: 0 <= m < k && arr[m] < arr[k] && lis[m] + 1 == lis[k]\n      invariant forall k :: 0 <= k < j ==> arr[k] < arr[i] ==> lis[i] >= lis[k] + 1\n      invariant lis[i] <= maxLength\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  length := maxLength;\n  assert forall i, j :: 0 <= i < j < n && arr[i] < arr[j] ==> length >= j - i + 1;\n  return length;\n}",
            "parents": [
                "3b7dd072-dfdb-4237-b0e9-3b1cce27c1ef"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "2dcd4d0e-45e1-4939-8182-5c74d089ed70",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures elements == old(elements)\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n  }\n  method UpdatePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n  {\n    var index := 0;\n    while index < |elements| && elements[index].1 != value\n      invariant 0 <= index <= |elements|\n      invariant forall k :: 0 <= k < index ==> elements[k].1 != value\n      invariant exists i :: 0 <= i < |elements| && elements[i].1 == value\n    {\n      index := index + 1;\n    }\n    var oldElement := elements[index];\n    elements := elements[..index] + elements[index + 1..];\n    \n    var i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [(newPriority, value)] + elements[i..];\n  }\n  method FindMaxPriority() returns (maxValue: int)\n    requires |elements| > 0\n    ensures exists i :: 0 <= i < |elements| && elements[i].1 == maxValue\n    ensures forall i :: 0 <= i < |elements| ==> elements[i].0 <= elements[0].0\n  {\n    var maxPriority := elements[0].0;\n    maxValue := elements[0].1;\n    var i := 1;\n    while i < |elements|\n      invariant 1 <= i <= |elements|\n      invariant exists j :: 0 <= j < i && elements[j].1 == maxValue\n      invariant forall j :: 0 <= j < i ==> elements[j].0 <= maxPriority\n    {\n      if elements[i].0 > maxPriority {\n        maxPriority := elements[i].0;\n        maxValue := elements[i].1;\n      }\n      i := i + 1;\n    }\n  }\n}",
            "parents": [
                "075e0f04-f19f-40e8-b602-b7875691b86c"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "76634e24-352f-449c-82c0-2e22484c3af2",
            "type": "program",
            "content": "method DotProduct(a: seq<int>, b: seq<int>) returns (result: int)\n  requires |a| == |b|\n  ensures result == DotProductSpec(a, b)\n{\n  var sum := 0;\n  var i := 0;\n  while i < |a|\n    invariant 0 <= i <= |a|\n    invariant sum == DotProductSpec(a[..i], b[..i])\n    decreases |a| - i\n  {\n    assert sum + a[i] * b[i] == DotProductSpec(a[..i+1], b[..i+1]);\n    sum := sum + a[i] * b[i];\n    i := i + 1;\n  }\n  result := sum;\n}\n\nfunction DotProductSpec(a: seq<int>, b: seq<int>): int\n  requires |a| == |b|\n{\n  if |a| == 0 then 0 else a[0] * b[0] + DotProductSpec(a[1..], b[1..])\n}",
            "parents": [
                "61af7580-e820-4d74-a5d1-ba3cb330e463"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "26baf2f9-4653-411a-813a-582bf30a7865",
            "type": "program",
            "content": "class Graph {\n  var adjacencyMatrix: array2<bool>;\n\n  constructor(n: nat) \n    requires n > 0\n    ensures adjacencyMatrix.Length0 == n && adjacencyMatrix.Length1 == n\n  {\n    adjacencyMatrix := new bool[n, n];\n  }\n\n  method AddEdge(u: nat, v: nat)\n    requires 0 <= u < adjacencyMatrix.Length0\n    requires 0 <= v < adjacencyMatrix.Length1\n    modifies adjacencyMatrix\n    ensures adjacencyMatrix[u, v] == true && adjacencyMatrix[v, u] == true\n  {\n    adjacencyMatrix[u, v] := true;\n    adjacencyMatrix[v, u] := true;\n  }\n\n  method IsVertexCover(cover: set<nat>) returns (isCover: bool)\n    requires cover <= set i | 0 <= i < adjacencyMatrix.Length0\n    ensures isCover == (forall u, v :: 0 <= u < adjacencyMatrix.Length0 && 0 <= v < adjacencyMatrix.Length1 && adjacencyMatrix[u, v] ==> u in cover || v in cover)\n  {\n    isCover := true;\n    var n := adjacencyMatrix.Length0;\n    for u := 0 to n - 1 {\n      for v := 0 to n - 1 \n        invariant 0 <= u < n && 0 <= v <= n\n        invariant isCover == (forall i, j :: 0 <= i <= u && 0 <= j < n && adjacencyMatrix[i, j] ==> i in cover || j in cover)\n      {\n        if adjacencyMatrix[u, v] && !(u in cover || v in cover) {\n          isCover := false;\n          return;\n        }\n      }\n    }\n  }\n}",
            "parents": [
                "1143df66-397a-4f7b-adf4-e3f270d6fc69"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "a763a137-f390-47e2-a6e1-5e43e5c48bd7",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  \n  constructor() {\n    elements := [];\n  }\n\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n\n  method IsEmpty() returns (empty: bool)\n    ensures empty == (|elements| == 0)\n  {\n    empty := |elements| == 0;\n  }\n}",
            "parents": [
                "73e288f2-30fb-4600-8793-d5bfc53cfe18"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "16559d74-d222-4d5d-a25c-c048b79ca8dd",
            "type": "program",
            "content": "// A simple program to verify that a given configuration of queens on a chessboard is valid\n// i.e., no two queens attack each other.\nmethod IsValidQueenConfiguration(board: seq<seq<bool>>) returns (valid: bool)\n  requires |board| == 8 && forall row :: 0 <= row < |board| ==> |board[row]| == 8\n  ensures valid == true <==> (forall i, j, k, l :: 0 <= i < 8 && 0 <= j < 8 && 0 <= k < 8 && 0 <= l < 8 && board[i][j] && board[k][l] ==> (i == k && j == l) || (i != k && j != l && i - j != k - l && i + j != k + l))\n{\n  valid := true;\n  var n := 8;\n  // Check each pair of queens to ensure they do not attack each other\n  for i := 0 to n - 1\n    invariant 0 <= i <= n\n    invariant valid == true ==> (forall x, y :: 0 <= x < i && 0 <= y < n && board[x][y] ==> (forall a, b :: 0 <= a < n && 0 <= b < n && board[a][b] && (x != a || y != b) ==> x != a && y != b && x - y != a - b && x + y != a + b))\n  {\n    for j := 0 to n - 1\n      invariant 0 <= j <= n\n      invariant valid == true ==> (forall x, y :: 0 <= x <= i && 0 <= y < j && board[x][y] ==> (forall a, b :: 0 <= a < n && 0 <= b < n && board[a][b] && (x != a || y != b) ==> x != a && y != b && x - y != a - b && x + y != a + b))\n    {\n      if board[i][j] {\n        for k := 0 to n - 1\n          invariant 0 <= k <= n\n          invariant valid == true ==> (forall a, b :: 0 <= a < k && 0 <= b < n && board[a][b] && (i != a || j != b) ==> i != a && j != b && i - j != a - b && i + j != a + b)\n        {\n          for l := 0 to n - 1\n            invariant 0 <= l <= n\n            invariant valid == true ==> (forall a, b :: 0 <= a <= k && 0 <= b < l && board[a][b] && (i != a || j != b) ==> i != a && j != b && i - j != a - b && i + j != a + b)\n          {\n            if board[k][l] && (i != k || j != l) {\n              // Check if they are in the same row, column, or diagonal\n              if i == k || j == l || i - j == k - l || i + j == k + l {\n                valid := false;\n                return;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
            "parents": [
                "19d3f723-d925-4d5c-b904-aee7c5c7d6a1"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "b5ece713-0a46-47af-bf09-aca9b9916ab1",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  \n  constructor() {\n    elements := [];\n  }\n  \n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements[..i] + elements[i..] == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  \n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  \n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures elements == old(elements)\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n  }\n  \n  method UpdatePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n  {\n    var index := 0;\n    while index < |elements| && elements[index].1 != value\n      invariant 0 <= index <= |elements|\n      invariant forall k :: 0 <= k < index ==> elements[k].1 != value\n      invariant exists i :: 0 <= i < |elements| && elements[i].1 == value\n    {\n      index := index + 1;\n    }\n    var oldElement := elements[index];\n    elements := elements[..index] + elements[index + 1..];\n    \n    var i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n      invariant elements[..i] + elements[i..] == old(elements[..index] + elements[index + 1..])\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [(newPriority, value)] + elements[i..];\n  }\n}",
            "parents": [
                "8fa4d618-abca-4854-9f4b-e936e14d7fa4"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "9462b231-a5ce-4ab6-9e20-d287ef18c1d6",
            "type": "program",
            "content": "method QuickSort(a: array<int>, lo: int, hi: int)\n  requires 0 <= lo <= hi <= a.Length\n  modifies a\n  ensures forall i, j :: lo <= i <= j < hi ==> a[i] <= a[j]\n{\n  if lo < hi {\n    var p := Partition(a, lo, hi);\n    QuickSort(a, lo, p);\n    QuickSort(a, p + 1, hi);\n  }\n}\n\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIndex: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIndex < hi\n  ensures forall i :: lo <= i < pivotIndex ==> a[i] <= a[pivotIndex]\n  ensures forall i :: pivotIndex < i < hi ==> a[pivotIndex] <= a[i]\n{\n  var pivot := a[lo];\n  var i := lo;\n  var j := hi;\n  while i < j\n    invariant lo <= i <= j <= hi\n    invariant forall k :: lo <= k < i ==> a[k] <= pivot\n    invariant forall k :: j <= k < hi ==> a[k] >= pivot\n    invariant exists p :: lo <= p < hi && a[p] == pivot\n  {\n    while i < j && a[i] <= pivot\n      invariant lo <= i < hi\n      invariant forall k :: lo <= k < i ==> a[k] <= pivot\n    {\n      i := i + 1;\n    }\n    while i < j && a[j - 1] >= pivot\n      invariant lo < j <= hi\n      invariant forall k :: j <= k < hi ==> a[k] >= pivot\n    {\n      j := j - 1;\n    }\n    if i < j {\n      a[i], a[j - 1] := a[j - 1], a[i];\n    }\n  }\n  pivotIndex := j - 1;\n  a[lo], a[pivotIndex] := a[pivotIndex], a[lo];\n  assert forall i :: lo <= i < pivotIndex ==> a[i] <= a[pivotIndex];\n  assert forall i :: pivotIndex < i < hi ==> a[pivotIndex] <= a[i];\n}",
            "parents": [
                "8b90debf-654c-4e55-aa35-2553a5270fe6"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "bb0ff6cf-a71f-4df2-9821-45c8f7c9e416",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant exists i: int :: left <= i <= right && \n              (forall j: int :: left <= j < i ==> arr[j] <= arr[i]) &&\n              (forall j: int :: i < j <= right ==> arr[j] >= arr[i])\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  // The following line is unreachable, but needed for compilation\n  assert false; // This assertion will never be reached if the loop terminates correctly\n  return arr[k]; \n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "82f1ea8a-8e2b-42a1-8718-bb1728055cfc"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "0c832e7f-8665-4f21-b944-ff3a0d22c938",
            "type": "program",
            "content": "method QuickSort(a: array<int>, lo: int, hi: int)\n  requires 0 <= lo <= hi <= a.Length\n  modifies a\n  ensures forall i, j :: lo <= i <= j < hi ==> a[i] <= a[j]\n{\n  if lo < hi {\n    var p := Partition(a, lo, hi);\n    QuickSort(a, lo, p);\n    QuickSort(a, p + 1, hi);\n  }\n}\n\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIndex: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIndex < hi\n  ensures forall i :: lo <= i < pivotIndex ==> a[i] <= a[pivotIndex]\n  ensures forall i :: pivotIndex < i < hi ==> a[pivotIndex] <= a[i]\n{\n  var pivot := a[lo];\n  var i := lo;\n  var j := hi;\n  while i < j\n    invariant lo <= i <= j <= hi\n    invariant forall k :: lo <= k < i ==> a[k] <= pivot\n    invariant forall k :: j <= k < hi ==> a[k] >= pivot\n    invariant exists p :: lo <= p < hi && a[p] == pivot\n  {\n    while i < j && a[i] <= pivot\n      invariant lo <= i < hi\n      invariant forall k :: lo <= k < i ==> a[k] <= pivot\n    {\n      i := i + 1;\n    }\n    while i < j && a[j - 1] >= pivot\n      invariant lo < j <= hi\n      invariant forall k :: j <= k < hi ==> a[k] >= pivot\n    {\n      j := j - 1;\n    }\n    if i < j {\n      a[i], a[j - 1] := a[j - 1], a[i];\n    }\n  }\n  pivotIndex := j - 1;\n  a[lo], a[pivotIndex] := a[pivotIndex], a[lo];\n  assert forall k :: lo <= k < pivotIndex ==> a[k] <= a[pivotIndex];\n  assert forall k :: pivotIndex < k < hi ==> a[pivotIndex] <= a[k];\n}",
            "parents": [
                "c33bdfa5-2a06-4477-8b69-036869b48b76"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "8db079bf-120a-4496-b801-88d09d329089",
            "type": "program",
            "content": "class Vector3D {\n  var x: int\n  var y: int\n  var z: int\n  constructor(x: int, y: int, z: int) \n    ensures this.x == x && this.y == y && this.z == z\n  {\n    this.x := x;\n    this.y := y;\n    this.z := z;\n  }\n  method CrossProduct(other: Vector3D) returns (result: Vector3D)\n    ensures result.x == this.y * other.z - this.z * other.y\n    ensures result.y == this.z * other.x - this.x * other.z\n    ensures result.z == this.x * other.y - this.y * other.x\n  {\n    var cx := this.y * other.z - this.z * other.y;\n    var cy := this.z * other.x - this.x * other.z;\n    var cz := this.x * other.y - this.y * other.x;\n    result := new Vector3D(cx, cy, cz);\n  }\n  method DotProduct(other: Vector3D) returns (result: int)\n    ensures result == this.x * other.x + this.y * other.y + this.z * other.z\n  {\n    var sum := 0;\n    var components := [this.x, this.y, this.z];\n    var otherComponents := [other.x, other.y, other.z];\n\n    // Loop over each component to calculate the dot product\n    var i := 0;\n    while i < 3\n      invariant 0 <= i <= 3\n      invariant sum == (if i >= 1 then components[0] * otherComponents[0] else 0)\n                        + (if i >= 2 then components[1] * otherComponents[1] else 0)\n      invariant sum == components[0] * otherComponents[0] + components[1] * otherComponents[1] * (if i >= 2 then 1 else 0)\n    {\n      sum := sum + components[i] * otherComponents[i];\n      i := i + 1;\n    }\n\n    result := sum;\n  }\n}",
            "parents": [
                "57d32a85-5e5d-45b8-90e4-937bf98d119a"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "56be9591-c7c8-48f9-859d-f5d26067a893",
            "type": "program",
            "content": "method IsPerfectSquare(n: nat) returns (result: bool)\n  ensures result <==> exists k: nat :: k * k == n\n{\n  var k: nat := 0;\n  result := false;\n  while k * k <= n\n    invariant 0 <= k <= n + 1\n    invariant forall i: nat :: 0 <= i < k ==> i * i != n\n    invariant result <==> exists i: nat :: 0 <= i <= k && i * i == n\n  {\n    if k * k == n {\n      result := true;\n      return;\n    }\n    k := k + 1;\n  }\n}",
            "parents": [
                "f390dd04-9155-464e-b156-a9079e20eb98"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "f9582613-93d4-4222-949b-e821edd52010",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  \n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  \n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i - 1 ==> lis[k] <= lis[k + 1] // Ensure lis is non-decreasing\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k :: 0 <= k < i - 1 ==> lis[k] <= lis[k + 1] // Maintain non-decreasing order\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  \n  return maxLength;\n}",
            "parents": [
                "ef5e2ccb-f464-482e-bcda-f79412089a5a"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "9adc37cf-8edc-48f9-ab79-921b7cac1eb0",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant forall j: int :: left <= j <= right ==> (arr[j] <= arr[right] && arr[j] >= arr[left])\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  // This line is unreachable, but needed for compilation\n  return arr[k]; \n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "a3e62053-9c6d-48a9-b8e3-f4e0235d8f8b"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "03b0ee34-f379-490e-a8d7-63f63ec9e9f9",
            "type": "program",
            "content": "class Queue {\n  var elements: seq<int>\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(x: int) \n    modifies this\n    ensures elements == old(elements) + [x]\n  {\n    elements := elements + [x];\n  }\n  method Dequeue() returns (x: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements)[1..]\n    ensures x == old(elements)[0]\n  {\n    x := elements[0];\n    elements := elements[1..];\n  }\n  method IsEmpty() returns (b: bool)\n    ensures b == (|elements| == 0)\n  {\n    b := |elements| == 0;\n  }\n}\nmethod SimulateQueueingSystem(events: seq<int>) returns (finalState: seq<int>)\n  requires |events| > 0\n  ensures forall i :: 0 <= i < |events| ==> events[i] >= 0\n  ensures finalState == events\n{\n  var queue := new Queue();\n  var i := 0;\n  while i < |events|\n    invariant 0 <= i <= |events|\n    invariant queue.elements == events[..i]\n  {\n    queue.Enqueue(events[i]);\n    i := i + 1;\n  }\n  finalState := queue.elements;\n}",
            "parents": [
                "a92e7690-11b6-4313-bd30-b0bc25d2c798"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "c482e42a-9661-463f-b3cd-4e84ba67d0d6",
            "type": "program",
            "content": "class Graph {\n  var adjacencyMatrix: array2<bool>;\n\n  constructor(n: nat) \n    requires n > 0\n    ensures adjacencyMatrix.Length0 == n && adjacencyMatrix.Length1 == n\n    ensures forall i, j :: 0 <= i < n && 0 <= j < n ==> !adjacencyMatrix[i, j]\n  {\n    adjacencyMatrix := new bool[n, n];\n  }\n\n  method AddEdge(u: nat, v: nat)\n    requires 0 <= u < adjacencyMatrix.Length0\n    requires 0 <= v < adjacencyMatrix.Length1\n    modifies adjacencyMatrix\n    ensures adjacencyMatrix[u, v] && adjacencyMatrix[v, u]\n  {\n    adjacencyMatrix[u, v] := true;\n    adjacencyMatrix[v, u] := true;\n  }\n\n  method IsVertexCover(cover: set<nat>) returns (isCover: bool)\n    requires cover <= set i | 0 <= i < adjacencyMatrix.Length0\n    ensures isCover == (forall u, v :: 0 <= u < adjacencyMatrix.Length0 && 0 <= v < adjacencyMatrix.Length1 && adjacencyMatrix[u, v] ==> u in cover || v in cover)\n  {\n    isCover := true;\n    var n := adjacencyMatrix.Length0;\n\n    // Loop invariant for the outer loop\n    var i := 0;\n    while i < n\n      invariant 0 <= i <= n\n      invariant isCover == (forall x, y :: 0 <= x < i && 0 <= y < n && adjacencyMatrix[x, y] ==> x in cover || y in cover)\n    {\n      var j := 0;\n      while j < n\n        invariant 0 <= j <= n\n        invariant isCover == (forall x, y :: 0 <= x < i && 0 <= y < j && adjacencyMatrix[x, y] ==> x in cover || y in cover)\n      {\n        if adjacencyMatrix[i, j] && !(i in cover || j in cover) {\n          isCover := false;\n          return;\n        }\n        j := j + 1;\n      }\n      i := i + 1;\n    }\n  }\n}",
            "parents": [
                "4cdc8acf-bd53-4262-9f62-d262ebc0d72c"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "SUCCESS"
            }
        },
        {
            "id": "06e966ff-354e-43ea-a5c4-17c19ba317ec",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant forall j: int :: left <= j <= right ==> arr[j] >= arr[k] // Ensure elements are in the correct order\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  // The following line is unreachable, but needed for compilation\n  return arr[k]; \n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "8c003d78-55dc-464e-870e-2234e08afcde"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "3335d6d0-7b27-462c-a1c0-023f2120aae5",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant forall j: int :: left <= j <= right ==> (arr[j] < arr[k] || arr[j] >= arr[k])\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  // The following line is unreachable but needed for compilation\n  return arr[k]; \n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "2ed5452d-1c00-499f-8c92-f6eb81374f61"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "c221da65-4495-45ad-9550-e3272e1941bf",
            "type": "program",
            "content": "method IsBalancedParentheses(s: seq<char>) returns (balanced: bool)\n  ensures balanced == (CountUnmatched(s) == 0)\n{\n  var unmatched := 0;\n  var i := 0;\n  while i < |s|\n    invariant 0 <= unmatched <= i\n    invariant 0 <= i <= |s|\n    invariant CountUnmatched(s[..i]) == unmatched\n    decreases |s| - i\n  {\n    if s[i] == '(' {\n      unmatched := unmatched + 1;\n    } else if s[i] == ')' {\n      if unmatched == 0 {\n        return false;\n      }\n      unmatched := unmatched - 1;\n    }\n    i := i + 1;\n  }\n  return unmatched == 0;\n}\n\nfunction CountUnmatched(s: seq<char>): int\n  decreases |s|\n{\n  if |s| == 0 then\n    0\n  else if s[0] == '(' then\n    1 + CountUnmatched(s[1..])\n  else if s[0] == ')' then\n    -1 + CountUnmatched(s[1..])\n  else\n    CountUnmatched(s[1..])\n}",
            "parents": [
                "43af835e-0c61-497d-aaa7-8e5fab78b557"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "ef79d8b3-4409-4c7b-996b-20a2279de491",
            "type": "program",
            "content": "method IsValidStackSequence(operations: seq<string>) returns (isValid: bool)\n  ensures isValid == (forall i :: 0 <= i < |operations| ==> operations[i] == \"push\" || operations[i] == \"pop\")\n{\n  var stackSize := 0;\n  isValid := true;\n  // Loop through each operation in the sequence\n  for i := 0 to |operations| \n    invariant 0 <= stackSize\n    invariant 0 <= i <= |operations|\n    invariant isValid == (forall j :: 0 <= j < i ==> operations[j] == \"push\" || operations[j] == \"pop\")\n    invariant isValid ==> (forall j :: 0 <= j < i ==> stackSize >= 0)\n    invariant stackSize <= i // Added invariant to ensure stackSize does not exceed the number of operations processed\n  {\n    if i < |operations| { // Check if i is within bounds before accessing operations[i]\n      if operations[i] == \"push\" {\n        stackSize := stackSize + 1;\n      } else if operations[i] == \"pop\" {\n        if stackSize == 0 {\n          isValid := false;\n          return;\n        }\n        stackSize := stackSize - 1;\n      } else {\n        isValid := false;\n        return;\n      }\n    }\n  }\n}",
            "parents": [
                "0afd3d56-6df2-4689-b6b9-55836841c075"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "6209f0a0-0f8c-4acc-97e0-9e0fd444848e",
            "type": "program",
            "content": "method DotProduct(a: seq<int>, b: seq<int>) returns (result: int)\n  requires |a| == |b|\n  ensures result == DotProductSpec(a, b)\n{\n  var sum := 0;\n  var i := 0;\n  while i < |a|\n    invariant 0 <= i <= |a|\n    invariant sum == DotProductSpec(a[..i], b[..i])\n    decreases |a| - i\n  {\n    sum := sum + a[i] * b[i];\n    i := i + 1;\n  }\n  result := sum;\n}\n\nfunction DotProductSpec(a: seq<int>, b: seq<int>): int\n  requires |a| == |b|\n{\n  if |a| == 0 then 0 else a[0] * b[0] + DotProductSpec(a[1..], b[1..])\n}",
            "parents": [
                "66ab765b-ea72-4d7c-822a-01394fcd61ac"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "ce814bbc-35f0-413f-8d98-b65c2d9f9162",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  \n  constructor() {\n    elements := [];\n  }\n  \n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  \n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  \n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures elements == old(elements)\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n  }\n  \n  method UpdatePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n  {\n    var index := 0;\n    while index < |elements| && elements[index].1 != value\n      invariant 0 <= index <= |elements|\n      invariant forall k :: 0 <= k < index ==> elements[k].1 != value\n      invariant exists i :: 0 <= i < |elements| && elements[i].1 == value\n    {\n      index := index + 1;\n    }\n    \n    // Remove the old element\n    var oldElement := elements[index];\n    elements := elements[..index] + elements[index + 1..];\n    \n    // Insert the new element in the correct position\n    var i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n      invariant elements == old(elements[..index]) + [oldElement] + elements[index..]\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [(newPriority, value)] + elements[i..];\n  }\n}",
            "parents": [
                "8fa4d618-abca-4854-9f4b-e936e14d7fa4"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "451f486f-dd8b-42a0-a11f-649490858504",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant forall j: int :: left <= j <= right ==> arr[j] <= arr[right]\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  // This line is unreachable, but needed for compilation\n  return arr[k]; \n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "724c03af-5286-42cb-a89d-df21d91b6452"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "d9aa4765-2440-447e-b90d-8b23abd19c0d",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant forall j: int :: left <= j <= right ==> arr[j] <= arr[right] // All elements in the range are less than or equal to the pivot\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  // This line is unreachable, but needed for compilation\n  return arr[k]; \n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "143807b2-47ab-4189-a5bd-7261fdea7c1b"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "e23a1fb4-6ec6-4ecd-8b29-b3a74e7964ad",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n    ensures elements == old(elements)\n  {\n    var i := 0;\n    var highestPriority := elements[0].0;\n    value := elements[0].1;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= highestPriority\n      invariant exists k :: 0 <= k < |elements| && elements[k].0 == highestPriority && value == elements[k].1\n    {\n      if elements[i].0 < highestPriority {\n        highestPriority := elements[i].0;\n        value := elements[i].1;\n      }\n      i := i + 1;\n    }\n    assert exists k :: 0 <= k < |elements| && elements[k].0 == highestPriority && value == elements[k].1;\n  }\n  method IsEmpty() returns (empty: bool)\n    ensures empty <==> |elements| == 0\n  {\n    empty := |elements| == 0;\n  }\n}",
            "parents": [
                "24766049-782a-4a21-b0eb-95e541710466"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "ad7c25fa-216b-4c4e-bcfb-acdfd9b05c78",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method UpdatePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n    {\n      i := i + 1;\n    }\n    \n    var oldElement := elements[i];\n    elements := elements[..i] + elements[i+1..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n\n    // Reinsert the element with the new priority\n    var newElement := (newPriority, value);\n    var j := 0;\n    while j < |elements| && elements[j].0 <= newPriority\n      invariant 0 <= j <= |elements|\n      invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < j ==> elements[k].0 <= elements[l].0\n    {\n      j := j + 1;\n    }\n    elements := elements[..j] + [newElement] + elements[j..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n}",
            "parents": [
                "12b2ce10-e684-47cd-90b6-5f651aff1ec1"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "1e11ae22-f89d-49e3-abce-232f95839707",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  \n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  \n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  \n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n}",
            "parents": [
                "f51ac2f4-60c1-445f-aaf6-c3281f8a480e"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "3952c36b-e2bb-4afb-aab5-75ec6d4d26d7",
            "type": "program",
            "content": "method IsValidQueenConfiguration(board: seq<seq<bool>>) returns (valid: bool)\n  requires |board| == 8 && forall row :: 0 <= row < |board| ==> |board[row]| == 8\n  ensures valid == true <==> (forall i, j, k, l :: 0 <= i < 8 && 0 <= j < 8 && 0 <= k < 8 && 0 <= l < 8 && board[i][j] && board[k][l] ==> (i == k && j == l) || (i != k && j != l && i - j != k - l && i + j != k + l))\n{\n  valid := true;\n  var n := 8;\n  \n  // Check each pair of queens to ensure they do not attack each other\n  for i := 0 to n - 1 {\n    for j := 0 to n - 1 {\n      if board[i][j] {\n        for k := 0 to n - 1 {\n          for l := 0 to n - 1 {\n            if board[k][l] && (i != k || j != l) {\n              // Check if they are in the same row, column, or diagonal\n              if i == k || j == l || i - j == k - l || i + j == k + l {\n                valid := false;\n                return;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // Additional nested loops with invariants\n  for i := 0 to n - 1\n    invariant 0 <= i <= n\n    invariant valid == true ==> (forall x, y, u, v :: 0 <= x < i && 0 <= y < n && 0 <= u < n && 0 <= v < n && board[x][y] && board[u][v] ==> (x == u && y == v) || (x != u && y != v && x - y != u - v && x + y != u + v))\n  {\n    for j := 0 to n - 1\n      invariant 0 <= j <= n\n      invariant valid == true ==> (forall x, y, u, v :: 0 <= x < i && 0 <= y < j && 0 <= u < n && 0 <= v < n && board[x][y] && board[u][v] ==> (x == u && y == v) || (x != u && y != v && x - y != u - v && x + y != u + v))\n    {\n      if board[i][j] {\n        for k := 0 to n - 1\n          invariant 0 <= k <= n\n          invariant valid == true ==> (forall x, y, u, v :: 0 <= x < i && 0 <= y < j && 0 <= u < k && 0 <= v < n && board[x][y] && board[u][v] ==> (x == u && y == v) || (x != u && y != v && x - y != u - v && x + y != u + v))\n        {\n          for l := 0 to n - 1\n            invariant 0 <= l <= n\n            invariant valid == true ==> (forall x, y, u, v :: 0 <= x < i && 0 <= y < j && 0 <= u < k && 0 <= v < l && board[x][y] && board[u][v] ==> (x == u && y == v) || (x != u && y != v && x - y != u - v && x + y != u + v))\n          {\n            if board[k][l] && (i != k || j != l) {\n              // Check if they are in the same row, column, or diagonal\n              if i == k || j == l || i - j == k - l || i + j == k + l {\n                valid := false;\n                return;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
            "parents": [
                "748917f8-aa21-4cc5-b49a-7dd1b1d93e06"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "8b18fa01-f79e-4dd8-875c-9621af8133b3",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant exists i: int :: left <= i <= right && \n              (forall j: int :: left <= j < i ==> arr[j] <= arr[i]) &&\n              (forall j: int :: i < j <= right ==> arr[j] >= arr[i])\n    invariant forall j: int :: left <= j <= right ==> arr[j] >= arr[left] // Added invariant\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  // The following line is unreachable, but needed for compilation\n  return arr[k]; \n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "e4a6b192-7a56-48a0-bee3-88e05ad28efb"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "SUCCESS"
            }
        },
        {
            "id": "8ccb866a-629b-4a2c-832d-834593cf111e",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant forall j: int :: left <= j <= right ==> (arr[j] <= arr[right] && arr[j] >= arr[left])\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  return arr[k]; // This line is unreachable, but needed for compilation\n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "d2614e46-12f5-4f3a-8ffb-2a4c0a5dc5ad"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "d71dadb8-61ce-42a0-8936-00c5046b696d",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      decreases |elements| - i\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var index: int := 0;\n    // Find the element with the specified value\n    while index < |elements| && elements[index].1 != value\n      invariant 0 <= index <= |elements|\n      invariant forall k :: 0 <= k < index ==> elements[k].1 != value\n      decreases |elements| - index\n    {\n      index := index + 1;\n    }\n    // Update the priority of the found element\n    elements := elements[..index] + [(newPriority, value)] + elements[index+1..];\n    \n    // Reorder the queue to maintain the priority order\n    var i := 0;\n    var newElement := (newPriority, value);\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      decreases |elements| - i\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i+1..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method RemoveValue(value: int)\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var i := 0;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      decreases |elements| - i\n    {\n      if elements[i].1 == value {\n        elements := elements[..i] + elements[i+1..];\n        // After removing an element, we need to ensure the order is maintained\n        assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n      } else {\n        i := i + 1;\n      }\n    }\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n}",
            "parents": [
                "69bf4859-15da-486c-891b-d173b3b7feeb"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "285d9baf-3aff-42d8-b4f1-da3ebbb4be29",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method UpdatePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures forall i :: 0 <= i < |elements| ==> elements[i].1 != value || elements[i].0 == newPriority\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n      invariant exists j :: i <= j < |elements| && elements[j].1 == value\n    {\n      i := i + 1;\n    }\n\n    // Remove the element with the old priority\n    elements := elements[..i] + elements[i+1..];\n\n    // Reinsert the element with the new priority\n    var newElement := (newPriority, value);\n    i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Merge(other: PriorityQueue)\n    modifies this\n    ensures |elements| == |old(elements)| + |other.elements|\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures forall e :: e in old(elements) || e in other.elements ==> e in elements\n  {\n    var merged: seq<(int, int)> := [];\n    var i := 0;\n    var j := 0;\n    while i < |elements| || j < |other.elements|\n      invariant 0 <= i <= |elements|\n      invariant 0 <= j <= |other.elements|\n      invariant |merged| == i + j\n      invariant forall k, l :: 0 <= k < l < |merged| ==> merged[k].0 <= merged[l].0\n      invariant forall e :: e in merged ==> e in old(elements) || e in other.elements\n    {\n      if i < |elements| && (j >= |other.elements| || elements[i].0 <= other.elements[j].0) {\n        merged := merged + [elements[i]];\n        i := i + 1;\n      } else {\n        merged := merged + [other.elements[j]];\n        j := j + 1;\n      }\n    }\n    elements := merged;\n  }\n}",
            "parents": [
                "d5b40493-0f46-4a5c-a888-3282c87ee6e0"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "97bb510f-e2f4-4b26-a47b-bd3678103715",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  \n  constructor() {\n    elements := [];\n  }\n\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n\n  method IsEmpty() returns (empty: bool)\n    ensures empty <==> |elements| == 0\n  {\n    empty := |elements| == 0;\n  }\n\n  method Size() returns (size: int)\n    ensures size == |elements|\n  {\n    size := 0;\n    var i := 0;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant size == i\n    {\n      size := size + 1;\n      i := i + 1;\n    }\n  }\n}",
            "parents": [
                "5e69c257-e155-483a-8b5e-6f065b2ca16b"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "21ef4008-bda1-48ba-ba27-d6d7e6ccdc40",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant exists i: int :: left <= i <= right && \n              (forall j: int :: left <= j < i ==> arr[j] <= arr[i]) &&\n              (forall j: int :: i < j <= right ==> arr[j] >= arr[i])\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  // The following line is unreachable, but needed for compilation\n  assert false; // This will help the verifier understand that the loop must terminate correctly\n  return arr[k]; \n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "ccdfa0ae-d4db-45dd-bdd4-610a85f69754"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "3307bdd0-0735-4e1c-99f9-6b1699e09744",
            "type": "program",
            "content": "method IsValidQueenConfiguration(board: seq<seq<bool>>) returns (valid: bool)\n  requires |board| == 8 && forall row :: 0 <= row < |board| ==> |board[row]| == 8\n  ensures valid == true <==> (forall i, j, k, l :: 0 <= i < 8 && 0 <= j < 8 && 0 <= k < 8 && 0 <= l < 8 && board[i][j] && board[k][l] ==> (i == k && j == l) || (i != k && j != l && i - j != k - l && i + j != k + l))\n{\n  valid := true;\n  var n := 8;\n\n  // Check each pair of queens to ensure they do not attack each other\n  for i := 0 to n - 1 {\n    for j := 0 to n - 1 {\n      if board[i][j] {\n        for k := 0 to n - 1 {\n          for l := 0 to n - 1 {\n            if board[k][l] && (i != k || j != l) {\n              // Check if they are in the same row, column, or diagonal\n              if i == k || j == l || i - j == k - l || i + j == k + l {\n                valid := false;\n                return;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // Additional verification using nested loops\n  for i := 0 to n - 1\n    invariant 0 <= i <= n\n    invariant valid == true ==> (forall x, y :: 0 <= x < i && 0 <= y < n && board[x][y] ==> (forall a, b :: 0 <= a < n && 0 <= b < n && board[a][b] && (x != a || y != b) ==> x != a && y != b && x - y != a - b && x + y != a + b))\n  {\n    for j := 0 to n - 1\n      invariant 0 <= j <= n\n      invariant valid == true ==> (forall x, y :: 0 <= x <= i && 0 <= y < j && board[x][y] ==> (forall a, b :: 0 <= a < n && 0 <= b < n && board[a][b] && (x != a || y != b) ==> x != a && y != b && x - y != a - b && x + y != a + b))\n    {\n      if board[i][j] {\n        for k := 0 to n - 1\n          invariant 0 <= k <= n\n          invariant valid == true ==> (forall x, y :: 0 <= x <= i && 0 <= y <= j && board[x][y] ==> (forall a, b :: 0 <= a < k && 0 <= b < n && board[a][b] && (x != a || y != b) ==> x != a && y != b && x - y != a - b && x + y != a + b))\n        {\n          for l := 0 to n - 1\n            invariant 0 <= l <= n\n            invariant valid == true ==> (forall x, y :: 0 <= x <= i && 0 <= y <= j && board[x][y] ==> (forall a, b :: 0 <= a <= k && 0 <= b < l && board[a][b] && (x != a || y != b) ==> x != a && y != b && x - y != a - b && x + y != a + b))\n          {\n            if board[k][l] && (i != k || j != l) {\n              // Check if they are in the same row, column, or diagonal\n              if i == k || j == l || i - j == k - l || i + j == k + l {\n                valid := false;\n                return;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
            "parents": [
                "bbe8dea4-a7fd-41c0-a9a1-84093df79fe4"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "30de3448-c261-478d-a436-4c3594f7a3d1",
            "type": "program",
            "content": "method DotProduct(a: seq<int>, b: seq<int>) returns (result: int)\n  requires |a| == |b|\n  ensures result == DotProductSpec(a, b)\n{\n  var sum := 0;\n  var i := 0;\n  while i < |a|\n    invariant 0 <= i <= |a|\n    invariant sum == DotProductSpec(a[..i], b[..i])\n    decreases |a| - i\n  {\n    sum := sum + a[i] * b[i];\n    i := i + 1;\n  }\n  result := sum;\n}\n\nfunction DotProductSpec(a: seq<int>, b: seq<int>): int\n  requires |a| == |b|\n{\n  if |a| == 0 then 0 else a[0] * b[0] + DotProductSpec(a[1..], b[1..])\n}",
            "parents": [
                "61af7580-e820-4d74-a5d1-ba3cb330e463"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "55317867-020e-4164-b58d-c9ed72fbf559",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  \n  constructor() {\n    elements := [];\n  }\n\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1; // Directly assign the value\n  }\n\n  method IsEmpty() returns (empty: bool)\n    ensures empty == (|elements| == 0)\n  {\n    var i := 0;\n    empty := true;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant empty == (i == 0)\n    {\n      empty := false;\n      i := i + 1;\n    }\n  }\n}",
            "parents": [
                "c5e1e621-0367-4423-b5b5-af6721643bd9"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "aed2a94e-b8e8-4e86-8885-4b717b415c8a",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  \n  constructor() {\n    elements := [];\n  }\n  \n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  \n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  \n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures elements == old(elements)\n    ensures value == elements[0].1\n  {\n    var i := 0;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant elements == old(elements)\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= elements[0].0\n    {\n      i := i + 1;\n    }\n    value := elements[0].1;\n  }\n}",
            "parents": [
                "ff0acc56-7506-4644-a976-b8a7bf2e46da"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "a410aed6-3ad6-4a06-b2bc-77f1b2a46220",
            "type": "program",
            "content": "method DotProduct(a: seq<int>, b: seq<int>) returns (result: int)\n  requires |a| == |b|\n  ensures result == DotProductSpec(a, b)\n{\n  var sum := 0;\n  var i := 0;\n  while i < |a|\n    invariant 0 <= i <= |a|\n    invariant sum == DotProductSpec(a[..i], b[..i])\n  {\n    sum := sum + a[i] * b[i];\n    i := i + 1;\n  }\n  result := sum;\n}\n\nfunction DotProductSpec(a: seq<int>, b: seq<int>): int\n  requires |a| == |b|\n{\n  if |a| == 0 then 0 else a[0] * b[0] + DotProductSpec(a[1..], b[1..])\n}",
            "parents": [
                "775329f6-3267-4f17-b9d7-56f5fe0f1959"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "18a02f10-abca-4bbb-ab66-5ed858b5056e",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n    ensures elements == old(elements)\n  {\n    var i := 0;\n    var highestPriority := elements[0].0;\n    value := elements[0].1;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= highestPriority\n      invariant exists k :: 0 <= k < |elements| && elements[k].0 == highestPriority && value == elements[k].1\n      invariant elements == old(elements)\n    {\n      if elements[i].0 < highestPriority {\n        highestPriority := elements[i].0;\n        value := elements[i].1;\n      }\n      i := i + 1;\n    }\n    assert value == elements[0].1;\n  }\n  method MaxPriority() returns (maxPriority: int)\n    requires |elements| > 0\n    ensures exists i :: 0 <= i < |elements| && elements[i].0 == maxPriority\n    ensures forall i :: 0 <= i < |elements| ==> elements[i].0 <= maxPriority\n    ensures elements == old(elements)\n  {\n    var i := 0;\n    maxPriority := elements[0].0;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant exists j :: 0 <= j < i && elements[j].0 == maxPriority\n      invariant forall j :: 0 <= j < i ==> elements[j].0 <= maxPriority\n      invariant elements == old(elements)\n    {\n      if elements[i].0 > maxPriority {\n        maxPriority := elements[i].0;\n      }\n      i := i + 1;\n    }\n    assert exists j :: 0 <= j < |elements| && elements[j].0 == maxPriority;\n    assert forall j :: 0 <= j < |elements| ==> elements[j].0 <= maxPriority;\n  }\n}",
            "parents": [
                "02c36c95-bc47-411a-ac2a-6417f4b19be3"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "8d5f429e-29f8-4b32-bc40-4a2c3548888d",
            "type": "program",
            "content": "method DotProduct(a: seq<int>, b: seq<int>) returns (result: int)\n  requires |a| == |b|\n  ensures result == DotProductSpec(a, b)\n{\n  var sum := 0;\n  var i := 0;\n  while i < |a|\n    invariant 0 <= i <= |a|\n    invariant sum == DotProductSpec(a[..i], b[..i])\n    decreases |a| - i\n  {\n    sum := sum + a[i] * b[i];\n    i := i + 1;\n  }\n  result := sum;\n}\n\nfunction DotProductSpec(a: seq<int>, b: seq<int>): int\n  requires |a| == |b|\n{\n  if |a| == 0 then 0 else a[0] * b[0] + DotProductSpec(a[1..], b[1..])\n}",
            "parents": [
                "7d3e9451-05c2-4835-8763-6cfd0d436673"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "7a043495-ec3b-42b9-8b92-45cf8522fff5",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1; // Directly assign the value of the first element\n  }\n  method UpdatePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i :: 0 <= i < |elements| ==> elements[i].1 != value || elements[i].0 == newPriority\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n    {\n      i := i + 1;\n    }\n    // Remove the element with the specified value\n    elements := elements[..i] + elements[i+1..];\n    // Re-insert the element with the new priority\n    Enqueue(newPriority, value);\n  }\n  method Remove(value: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i :: 0 <= i < |elements| ==> elements[i].1 != value\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n    {\n      i := i + 1;\n    }\n    // Remove the element with the specified value\n    elements := elements[..i] + elements[i+1..];\n  }\n}",
            "parents": [
                "3b56c123-58e7-4c51-9d14-d24ab3dd936e"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "0793c51d-23c9-4896-b40d-8b451a0849f6",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n    assert |elements| >= 0; // Ensure that elements is not empty after dequeue\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements)\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n}",
            "parents": [
                "dd4db3fc-f4f8-4a7a-97d6-5bff70d9269a"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "fe1c8521-caf2-4550-9d07-b03a6aa5d7e9",
            "type": "program",
            "content": "method IsValidSudokuRow(board: array2<int>, row: int) returns (isValid: bool)\n  requires 0 <= row < board.Length0\n  requires board.Length1 == 9\n  ensures isValid == (forall i, j :: 0 <= i < j < 9 ==> board[row, i] != board[row, j])\n{\n  var seen := new bool[9];\n  isValid := true;\n  for i := 0 to 8\n    invariant 0 <= i <= 9\n    invariant forall k :: 0 <= k < i ==> 0 <= board[row, k] < 9\n    invariant forall k :: 0 <= k < i ==> seen[board[row, k]]\n    invariant isValid == (forall a, b :: 0 <= a < b < i ==> board[row, a] != board[row, b])\n  {\n    if board[row, i] < 0 || board[row, i] >= 9 {\n      isValid := false;\n      return;\n    }\n    if seen[board[row, i]] {\n      isValid := false;\n      return;\n    }\n    seen[board[row, i]] := true;\n  }\n  for i := 0 to 8\n    invariant 0 <= i <= 9\n    invariant forall k :: 0 <= k < i ==> 1 <= board[row, k] <= 9\n    invariant forall k :: 0 <= k < i ==> seen[board[row, k] - 1]\n    invariant isValid == (forall a, b :: 0 <= a < b < i ==> board[row, a] != board[row, b])\n  {\n    if board[row, i] < 1 || board[row, i] > 9 {\n      isValid := false;\n      return;\n    }\n    if seen[board[row, i] - 1] {\n      isValid := false;\n      return;\n    }\n    seen[board[row, i] - 1] := true;\n  }\n}",
            "parents": [
                "0d11e912-fb88-46a8-97e1-3b2391c794ca"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "ec07c552-ba22-429e-af97-f1b1bc87b461",
            "type": "program",
            "content": "method IsValidQueenConfiguration(board: seq<seq<bool>>) returns (valid: bool)\n  requires |board| == 8 && forall row :: 0 <= row < |board| ==> |board[row]| == 8\n  ensures valid == true <==> (forall i, j, k, l :: 0 <= i < 8 && 0 <= j < 8 && 0 <= k < 8 && 0 <= l < 8 && board[i][j] && board[k][l] ==> (i == k && j == l) || (i != k && j != l && i - j != k - l && i + j != k + l))\n{\n  valid := true;\n  var n := 8;\n  \n  // Check each pair of queens to ensure they do not attack each other\n  for i := 0 to n - 1\n    invariant 0 <= i <= n\n    invariant valid == true ==> (forall x, y :: 0 <= x < i && 0 <= y < n && board[x][y] ==> (forall a, b :: 0 <= a < n && 0 <= b < n && board[a][b] && (x != a || y != b) ==> x != a && y != b && x - y != a - b && x + y != a + b))\n  {\n    for j := 0 to n - 1\n      invariant 0 <= j <= n\n      invariant valid == true ==> (forall x, y :: 0 <= x <= i && 0 <= y < j && board[x][y] ==> (forall a, b :: 0 <= a < n && 0 <= b < n && board[a][b] && (x != a || y != b) ==> x != a && y != b && x - y != a - b && x + y != a + b))\n    {\n      if board[i][j] {\n        for k := 0 to n - 1\n          invariant 0 <= k <= n\n          invariant valid == true ==> (forall x, y :: 0 <= x <= i && 0 <= y <= j && board[x][y] ==> (forall a, b :: 0 <= a < k && 0 <= b < n && board[a][b] && (x != a || y != b) ==> x != a && y != b && x - y != a - b && x + y != a + b))\n        {\n          for l := 0 to n - 1\n            invariant 0 <= l <= n\n            invariant valid == true ==> (forall x, y :: 0 <= x <= i && 0 <= y <= j && board[x][y] ==> (forall a, b :: 0 <= a <= k && 0 <= b < l && board[a][b] && (x != a || y != b) ==> x != a && y != b && x - y != a - b && x + y != a + b))\n          {\n            if board[k][l] && (i != k || j != l) {\n              // Check if they are in the same row, column, or diagonal\n              if i == k || j == l || i - j == k - l || i + j == k + l {\n                valid := false;\n                return;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
            "parents": [
                "bbe8dea4-a7fd-41c0-a9a1-84093df79fe4"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "8768f166-72ef-41a9-a616-6d1a24218344",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method UpdatePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n    {\n      i := i + 1;\n    }\n    \n    var oldElement := elements[i];\n    elements := elements[..i] + elements[i+1..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n\n    // Reinsert the element with the new priority\n    var newElement := (newPriority, value);\n    var j := 0;\n    while j < |elements| && elements[j].0 <= newPriority\n      invariant 0 <= j <= |elements|\n      invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < j ==> elements[k].0 <= elements[l].0\n    {\n      j := j + 1;\n    }\n    elements := elements[..j] + [newElement] + elements[j..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n}",
            "parents": [
                "12b2ce10-e684-47cd-90b6-5f651aff1ec1"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "b0cced39-b008-41ee-8fe9-e7e0dce94c6e",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  \n  constructor() {\n    elements := [];\n  }\n\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1; // Directly assign the value of the first element\n  }\n\n  method IsEmpty() returns (empty: bool)\n    ensures empty == (|elements| == 0)\n  {\n    var i := 0;\n    empty := true;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant empty == (i == 0)\n    {\n      empty := false;\n      i := i + 1;\n    }\n  }\n}",
            "parents": [
                "b8389da0-5fd2-4517-9373-f6fee3fca60a"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "c00ca60b-64db-47f2-8608-f8524ebe4fa4",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant forall j: int :: left <= j <= right ==> (arr[j] <= arr[right] && arr[j] >= arr[left]) // Elements are within bounds\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  // This line is unreachable, but needed for compilation\n  return arr[k]; \n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "f038a5d8-275a-4dd5-90bc-387ecb85ff56"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "b60f9126-cdab-4429-ab6e-8d2fb3925654",
            "type": "program",
            "content": "method DotProduct(a: seq<int>, b: seq<int>) returns (result: int)\n  requires |a| == |b|\n  ensures result == DotProductSpec(a, b)\n{\n  var sum := 0;\n  var i := 0;\n  while i < |a|\n    invariant 0 <= i <= |a|\n    invariant sum == DotProductSpec(a[..i], b[..i])\n    decreases |a| - i\n  {\n    sum := sum + a[i] * b[i];\n    i := i + 1;\n  }\n  result := sum;\n}\n\nfunction DotProductSpec(a: seq<int>, b: seq<int>): int\n  requires |a| == |b|\n{\n  if |a| == 0 then 0 else a[0] * b[0] + DotProductSpec(a[1..], b[1..])\n}",
            "parents": [
                "61af7580-e820-4d74-a5d1-ba3cb330e463"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "79f32bfa-221a-463f-8c2d-3e9dd63bacaa",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant forall j: int :: left <= j <= right ==> (arr[j] <= arr[right] && arr[j] >= arr[left])\n    invariant exists i: int :: left <= i <= right && arr[i] == arr[k] // Ensure that the k-th smallest is within the bounds\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  // This line is unreachable, but needed for compilation\n  return arr[k]; \n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "9adc37cf-8edc-48f9-ab79-921b7cac1eb0"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "4b80b1c7-df6c-4471-9720-c8238a8bee20",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> maxLength >= lis[k]\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n}",
            "parents": [
                "7201d35b-8e5d-4804-b741-e206c2263be3"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "9ef09dc7-cc93-4c1e-ad07-e52847f673c5",
            "type": "program",
            "content": "method DotProduct(a: seq<int>, b: seq<int>) returns (result: int)\n  requires |a| == |b|\n  ensures result == DotProductSpec(a, b)\n{\n  var sum := 0;\n  var i := 0;\n  while i < |a|\n    invariant 0 <= i <= |a|\n    invariant sum == DotProductSpec(a[..i], b[..i])\n    decreases |a| - i\n  {\n    sum := sum + a[i] * b[i];\n    i := i + 1;\n  }\n  result := sum;\n}\n\nfunction DotProductSpec(a: seq<int>, b: seq<int>): int\n  requires |a| == |b|\n{\n  if |a| == 0 then 0 else a[0] * b[0] + DotProductSpec(a[1..], b[1..])\n}",
            "parents": [
                "6209f0a0-0f8c-4acc-97e0-9e0fd444848e"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "45d1fbb4-82f0-45cb-bd81-e054b33d97de",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant exists i: int :: left <= i <= right && \n              (forall j: int :: left <= j < i ==> arr[j] <= arr[i]) &&\n              (forall j: int :: i < j <= right ==> arr[j] >= arr[i])\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  // This line is unreachable, but needed for compilation\n  return arr[k]; \n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "513553a6-c831-43ee-90f3-208d94eb8005"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "224aed27-ef1b-4fe1-bf7c-3bde0e249a75",
            "type": "program",
            "content": "method QuickSort(a: array<int>, lo: int, hi: int)\n  requires 0 <= lo <= hi <= a.Length\n  modifies a\n  ensures forall i, j :: lo <= i <= j < hi ==> a[i] <= a[j]\n{\n  if lo < hi {\n    var p := Partition(a, lo, hi);\n    QuickSort(a, lo, p);\n    QuickSort(a, p + 1, hi);\n  }\n}\n\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIndex: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIndex < hi\n  ensures forall i :: lo <= i < pivotIndex ==> a[i] <= a[pivotIndex]\n  ensures forall i :: pivotIndex < i < hi ==> a[pivotIndex] <= a[i]\n{\n  var pivot := a[lo];\n  var i := lo;\n  var j := hi;\n  while i < j\n    invariant lo <= i <= j <= hi\n    invariant forall k :: lo <= k < i ==> a[k] <= pivot\n    invariant forall k :: j <= k < hi ==> a[k] >= pivot\n    invariant exists p :: lo <= p < hi && a[p] == pivot\n  {\n    while i < j && a[i] <= pivot\n      invariant lo <= i < hi\n      invariant forall k :: lo <= k < i ==> a[k] <= pivot\n    {\n      i := i + 1;\n    }\n    while i < j && a[j - 1] >= pivot\n      invariant lo < j <= hi\n      invariant forall k :: j <= k < hi ==> a[k] >= pivot\n    {\n      j := j - 1;\n    }\n    if i < j {\n      a[i], a[j - 1] := a[j - 1], a[i];\n    }\n  }\n  pivotIndex := j - 1;\n  a[lo], a[pivotIndex] := a[pivotIndex], a[lo];\n  \n  // Ensure the pivot is in the correct position\n  assert forall i :: lo <= i < pivotIndex ==> a[i] <= a[pivotIndex];\n  assert forall i :: pivotIndex < i < hi ==> a[pivotIndex] <= a[i];\n  \n  // Additional assertion to ensure the pivot is correctly placed\n  assert a[pivotIndex] == pivot;\n}",
            "parents": [
                "06e8253e-7af0-4cfc-82d9-ee4904775129"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "855139eb-160d-4d6b-926b-668dce2d6c5c",
            "type": "program",
            "content": "class Vector3D {\n  var x: int\n  var y: int\n  var z: int\n  constructor(x: int, y: int, z: int) \n    ensures this.x == x && this.y == y && this.z == z\n  {\n    this.x := x;\n    this.y := y;\n    this.z := z;\n  }\n  \n  method CrossProduct(other: Vector3D) returns (result: Vector3D)\n    ensures result.x == this.y * other.z - this.z * other.y\n    ensures result.y == this.z * other.x - this.x * other.z\n    ensures result.z == this.x * other.y - this.y * other.x\n  {\n    var cx := this.y * other.z - this.z * other.y;\n    var cy := this.z * other.x - this.x * other.z;\n    var cz := this.x * other.y - this.y * other.x;\n    result := new Vector3D(cx, cy, cz);\n  }\n\n  method DotProduct(other: Vector3D) returns (result: int)\n    ensures result == this.x * other.x + this.y * other.y + this.z * other.z\n  {\n    var sum := 0;\n    var components := [this.x, this.y, this.z];\n    var otherComponents := [other.x, other.y, other.z];\n\n    // Loop over each component to calculate the dot product\n    var i := 0;\n    while i < 3\n      invariant 0 <= i <= 3\n      invariant sum == (if i >= 1 then components[0] * otherComponents[0] else 0)\n                      + (if i >= 2 then components[1] * otherComponents[1] else 0)\n                      + (if i >= 3 then components[2] * otherComponents[2] else 0)\n    {\n      sum := sum + components[i] * otherComponents[i];\n      i := i + 1;\n    }\n\n    result := sum;\n  }\n\n  method SquaredMagnitude() returns (result: int)\n    ensures result == this.x * this.x + this.y * this.y + this.z * this.z\n  {\n    var sum := 0;\n    var components := [this.x, this.y, this.z];\n\n    // Loop over each component to calculate the squared magnitude\n    var i := 0;\n    while i < 3\n      invariant 0 <= i <= 3\n      invariant sum == (if i >= 1 then components[0] * components[0] else 0)\n                      + (if i >= 2 then components[1] * components[1] else 0)\n                      + (if i >= 3 then components[2] * components[2] else 0)\n    {\n      sum := sum + components[i] * components[i];\n      i := i + 1;\n    }\n\n    result := sum;\n  }\n}",
            "parents": [
                "15b2aa02-b940-4eaf-b6af-1c31858e534e"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "SUCCESS"
            }
        },
        {
            "id": "a4277588-5bcf-417f-8fd2-25cd262a1e6f",
            "type": "program",
            "content": "method IsPerfectSquare(n: nat) returns (result: bool)\n  ensures result == (exists k: nat :: k * k == n)\n{\n  var k: nat := 0;\n  result := false;\n  while k * k <= n\n    invariant 0 <= k <= n + 1\n    invariant forall i: nat :: 0 <= i < k ==> i * i != n\n    invariant result == (exists i: nat :: 0 <= i < k && i * i == n)\n  {\n    if k * k == n {\n      result := true;\n      return;\n    }\n    k := k + 1;\n  }\n  // After the loop, we need to ensure that result is correctly set\n  assert result == (exists i: nat :: 0 <= i < k && i * i == n);\n}",
            "parents": [
                "6dc8cff5-a934-4e13-8ced-7614f5cfbda0"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "22937d0e-d02f-441c-8ad1-93c5f015674d",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method IsEmpty() returns (empty: bool)\n    ensures empty == (|elements| == 0)\n  {\n    var i := 0;\n    empty := true;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant empty == (i == 0)\n    {\n      empty := false;\n      i := i + 1;\n    }\n  }\n  method Size() returns (size: int)\n    ensures size == |elements|\n  {\n    var count := 0;\n    var i := 0;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant count == i\n    {\n      count := count + 1;\n      i := i + 1;\n    }\n    size := count;\n  }\n}",
            "parents": [
                "2dd34ac8-894f-4ee0-acf9-535568a618f3"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "c1289bdb-9f39-4c77-a9d8-ec5e9219745c",
            "type": "program",
            "content": "method QuickSort(a: array<int>, lo: int, hi: int)\n  requires 0 <= lo <= hi <= a.Length\n  modifies a\n  ensures forall i, j :: lo <= i <= j < hi ==> a[i] <= a[j]\n{\n  if lo < hi {\n    var p := Partition(a, lo, hi);\n    QuickSort(a, lo, p);\n    QuickSort(a, p + 1, hi);\n  }\n}\n\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIndex: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIndex < hi\n  ensures forall i :: lo <= i < pivotIndex ==> a[i] <= a[pivotIndex]\n  ensures forall i :: pivotIndex < i < hi ==> a[pivotIndex] <= a[i]\n{\n  var pivot := a[lo];\n  var i := lo;\n  var j := hi;\n  while i < j\n    invariant lo <= i <= j <= hi\n    invariant forall k :: lo <= k < i ==> a[k] <= pivot\n    invariant forall k :: j <= k < hi ==> a[k] >= pivot\n  {\n    while i < j && a[i] <= pivot\n      invariant lo <= i < hi\n      invariant forall k :: lo <= k < i ==> a[k] <= pivot\n    {\n      i := i + 1;\n    }\n    while i < j && a[j - 1] >= pivot\n      invariant lo < j <= hi\n      invariant forall k :: j <= k < hi ==> a[k] >= pivot\n    {\n      j := j - 1;\n    }\n    if i < j {\n      a[i], a[j - 1] := a[j - 1], a[i];\n    }\n  }\n  pivotIndex := j - 1;\n  a[lo], a[pivotIndex] := a[pivotIndex], a[lo];\n}",
            "parents": [
                "5d87e78b-9ce9-4aeb-b2c9-d38c121a2aa5"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "65fe5038-bc37-4c4a-b92e-1b5ae0ff253e",
            "type": "program",
            "content": "method DotProduct(a: seq<int>, b: seq<int>) returns (result: int)\n  requires |a| == |b|\n  ensures result == DotProductSpec(a, b)\n{\n  var sum := 0;\n  var i := 0;\n  while i < |a|\n    invariant 0 <= i <= |a|\n    invariant sum == DotProductSpec(a[..i], b[..i])\n    decreases |a| - i\n  {\n    sum := sum + a[i] * b[i];\n    i := i + 1;\n  }\n  result := sum;\n}\n\nfunction DotProductSpec(a: seq<int>, b: seq<int>): int\n  requires |a| == |b|\n{\n  if |a| == 0 then 0 else a[0] * b[0] + DotProductSpec(a[1..], b[1..])\n}",
            "parents": [
                "f86d050a-66f5-4efb-81f3-9aa0b265937b"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "07aca84a-008d-4501-b43d-96ed3180e5ab",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n    invariant forall k, j :: 0 <= k < j < i && arr[k] < arr[j] ==> lis[j] >= lis[k] + 1\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n      invariant forall k, l :: 0 <= k < l < i && arr[k] < arr[l] ==> lis[l] >= lis[k] + 1\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n}",
            "parents": [
                "278d6f91-8c90-461b-9a81-b0aa78059b22"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "33a8f993-3417-4bfc-9d6f-8c48dc991f5c",
            "type": "program",
            "content": "method QuickSort(a: array<int>, lo: int, hi: int)\n  requires 0 <= lo <= hi <= a.Length\n  modifies a\n  ensures forall i, j :: lo <= i <= j < hi ==> a[i] <= a[j]\n{\n  if lo < hi {\n    var p := Partition(a, lo, hi);\n    QuickSort(a, lo, p);\n    QuickSort(a, p + 1, hi);\n  }\n}\n\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIndex: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIndex < hi\n  ensures forall i :: lo <= i < pivotIndex ==> a[i] <= a[pivotIndex]\n  ensures forall i :: pivotIndex < i < hi ==> a[pivotIndex] <= a[i]\n{\n  var pivot := a[lo];\n  var i := lo;\n  var j := hi;\n  while i < j\n    invariant lo <= i <= j <= hi\n    invariant forall k :: lo <= k < i ==> a[k] <= pivot\n    invariant forall k :: j <= k < hi ==> a[k] >= pivot\n    invariant exists p :: lo <= p < hi && a[p] == pivot\n  {\n    while i < j && a[i] <= pivot\n      invariant lo <= i < hi\n      invariant forall k :: lo <= k < i ==> a[k] <= pivot\n    {\n      i := i + 1;\n    }\n    while i < j && a[j - 1] >= pivot\n      invariant lo < j <= hi\n      invariant forall k :: j <= k < hi ==> a[k] >= pivot\n    {\n      j := j - 1;\n    }\n    if i < j {\n      a[i], a[j - 1] := a[j - 1], a[i];\n    }\n  }\n  pivotIndex := j - 1;\n  a[lo], a[pivotIndex] := a[pivotIndex], a[lo];\n  // Additional assertion to maintain the properties after partitioning\n  assert forall k :: lo <= k < pivotIndex ==> a[k] <= a[pivotIndex];\n  assert forall k :: pivotIndex < k < hi ==> a[pivotIndex] <= a[k];\n}",
            "parents": [
                "0954d8e0-5509-4cfe-8706-0bc8b0ee246d"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "becbee47-bff8-4eb0-b3b9-1232d84a43bb",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant exists i: int :: left <= i <= right && \n              (forall j: int :: left <= j < i ==> arr[j] <= arr[i]) &&\n              (forall j: int :: i < j <= right ==> arr[j] >= arr[i])\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  // The following line is unreachable, but needed for compilation\n  return arr[k]; \n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "c617ee03-ca62-459d-8a2d-b68a3d0e1ee4"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "7d7af3a4-890a-446d-917e-477b6aa58e2f",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n    ensures elements == old(elements)\n  {\n    value := elements[0].1;\n  }\n}",
            "parents": [
                "47a78a94-8b7d-4a32-9894-bacc3e113196"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "a564dd75-1b42-4fca-8ba5-e49415bbbda5",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n    invariant forall k, l :: 0 <= k < l < i && arr[k] < arr[l] ==> lis[l] >= lis[k] + 1\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n      invariant forall k, l :: 0 <= k < l < i && arr[k] < arr[l] ==> lis[l] >= lis[k] + 1\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  length := maxLength; // Assign the result to the output parameter\n  return length; // Return the length\n}",
            "parents": [
                "6819677d-762f-4841-96c0-8ee8c0023c83"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "d1008c1d-04df-4f51-9961-45f5a26fcbbd",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant forall j: int :: left <= j <= right ==> (arr[j] < arr[k] ==> j < k)\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  // The following line is unreachable but needed for compilation\n  return arr[k]; \n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "542a2262-2675-4217-bd08-dc373530b604"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "f299289e-0d8d-437f-a41c-3c54d0c8bbdf",
            "type": "program",
            "content": "class Node {\n  var value: int\n  var left: Node?\n  var right: Node?\n  constructor(v: int) {\n    value := v;\n    left := null;\n    right := null;\n  }\n}\nclass BinarySearchTree {\n  var root: Node?\n  \n  method Insert(v: int) \n    modifies this\n    ensures IsBST(root)\n  {\n    root := InsertHelper(root, v);\n  }\n  \n  method InsertHelper(n: Node?, v: int) returns (result: Node?)\n    ensures IsBST(result)\n  {\n    if n == null {\n      return new Node(v);\n    }\n    if v < n.value {\n      n.left := InsertHelper(n.left, v);\n    } else if v > n.value {\n      n.right := InsertHelper(n.right, v);\n    }\n    return n;\n  }\n  \n  predicate IsBST(n: Node?) \n    reads n\n  {\n    n == null || \n    (IsBST(n.left) && IsBST(n.right) &&\n     (n.left == null || MaxValue(n.left) < n.value) &&\n     (n.right == null || MinValue(n.right) > n.value))\n  }\n  \n  function MaxValue(n: Node?): int\n    requires n != null\n    reads n\n  {\n    if n.right == null then n.value else MaxValue(n.right)\n  }\n  \n  function MinValue(n: Node?): int\n    requires n != null\n    reads n\n  {\n    if n.left == null then n.value else MinValue(n.left)\n  }\n  \n  method Height(n: Node?) returns (h: int)\n    ensures h >= 0\n  {\n    if n == null {\n      h := 0;\n    } else {\n      var leftHeight := Height(n.left);\n      var rightHeight := Height(n.right);\n      h := if leftHeight > rightHeight then leftHeight + 1 else rightHeight + 1;\n    }\n  }\n  \n  method CountNodes(n: Node?) returns (count: int)\n    ensures count >= 0\n  {\n    if n == null {\n      count := 0;\n    } else {\n      var leftCount: int;\n      var rightCount: int;\n      leftCount := CountNodes(n.left);\n      rightCount := CountNodes(n.right);\n      count := leftCount + rightCount + 1;\n    }\n  }\n  \n  method SumValues(n: Node?) returns (sum: int)\n    ensures sum >= 0\n  {\n    if n == null {\n      sum := 0;\n    } else {\n      var leftSum: int;\n      var rightSum: int;\n      leftSum := SumValues(n.left);\n      rightSum := SumValues(n.right);\n      sum := leftSum + rightSum + n.value;\n    }\n  }\n}",
            "parents": [
                "bb88517a-4b61-4968-a97c-94f0c151c3ca"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "d747d3a8-4470-493c-8743-2b0774448e78",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (result: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == result && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < result ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == result ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  var pivotIndex: int;\n  while left <= right\n    invariant 0 <= left <= arr.Length\n    invariant -1 <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant left <= right + 1\n    invariant forall j: int :: 0 <= j < arr.Length ==> (arr[j] < arr[pivotIndex] ==> j < k) // Ensure elements less than pivot are before k\n  {\n    pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  // The loop should always terminate with a valid result\n  assert false; // This line should never be reached due to the loop invariant\n  return -1; // This line should never be reached due to the loop invariant\n}\n\nmethod Partition(arr: array<int>, low: int, high: int) returns (pivotIndex: int)\n  requires 0 <= low <= high < arr.Length\n  ensures low <= pivotIndex <= high\n  ensures forall i: int :: low <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= high ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[high];\n  var i := low - 1;\n  for j := low to high - 1\n    invariant low - 1 <= i < high\n    invariant low <= j <= high\n    invariant forall m: int :: low <= m <= i ==> arr[m] <= pivot\n    invariant forall n: int :: i < n < j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      i := i + 1;\n      arr[i], arr[j] := arr[j], arr[i];\n    }\n  }\n  arr[i + 1], arr[high] := arr[high], arr[i + 1];\n  return i + 1;\n}",
            "parents": [
                "a2921e1b-f37c-4f0f-b5c2-111dd72ec938"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "8859e078-1879-409a-a5db-68f09109ed2d",
            "type": "program",
            "content": "method IsValidQueenConfiguration(board: seq<seq<bool>>) returns (valid: bool)\n  requires |board| == 8 && forall row :: 0 <= row < |board| ==> |board[row]| == 8\n  ensures valid == true <==> (forall i, j, k, l :: 0 <= i < 8 && 0 <= j < 8 && 0 <= k < 8 && 0 <= l < 8 && board[i][j] && board[k][l] ==> (i == k && j == l) || (i != k && j != l && i - j != k - l && i + j != k + l))\n{\n  valid := true;\n  var n := 8;\n  // Check each pair of queens to ensure they do not attack each other\n  for i := 0 to n - 1\n    invariant 0 <= i <= n\n    invariant valid == true ==> (forall x, y :: 0 <= x < i && 0 <= y < n && board[x][y] ==> (forall a, b :: 0 <= a < n && 0 <= b < n && board[a][b] && (x != a || y != b) ==> x != a && y != b && x - y != a - b && x + y != a + b))\n  {\n    for j := 0 to n - 1\n      invariant 0 <= j <= n\n      invariant valid == true ==> (forall x, y :: 0 <= x <= i && 0 <= y < j && board[x][y] ==> (forall a, b :: 0 <= a < n && 0 <= b < n && board[a][b] && (x != a || y != b) ==> x != a && y != b && x - y != a - b && x + y != a + b))\n    {\n      if board[i][j] {\n        for k := 0 to n - 1\n          invariant 0 <= k <= n\n          invariant valid == true ==> (forall a, b :: 0 <= a < k && 0 <= b < n && board[a][b] && (i != a || j != b) ==> i != a && j != b && i - j != a - b && i + j != a + b)\n        {\n          for l := 0 to n - 1\n            invariant 0 <= l <= n\n            invariant valid == true ==> (forall a, b :: 0 <= a <= k && 0 <= b < l && board[a][b] && (i != a || j != b) ==> i != a && j != b && i - j != a - b && i + j != a + b)\n          {\n            if board[k][l] && (i != k || j != l) {\n              // Check if they are in the same row, column, or diagonal\n              if i == k || j == l || i - j == k - l || i + j == k + l {\n                valid := false;\n                return;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}",
            "parents": [
                "16559d74-d222-4d5d-a25c-c048b79ca8dd"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "453e444a-6cd0-46c6-ab45-e84b278014df",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n    invariant forall k :: 0 <= k < i ==> (arr[k] < arr[i] ==> lis[i] >= lis[k] + 1)\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n      invariant forall k :: 0 <= k < j ==> arr[k] < arr[i] ==> lis[i] >= lis[k] + 1\n      invariant lis[i] <= maxLength\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  length := maxLength;\n  assert forall i, j :: 0 <= i < j < n && arr[i] < arr[j] ==> length >= j - i + 1;\n  return length;\n}",
            "parents": [
                "02e7918a-0747-4f1c-b069-860f48c3f351"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "bf0bf0e5-f674-41a8-8680-c3b5d5b3dc87",
            "type": "program",
            "content": "method DotProduct(a: seq<int>, b: seq<int>) returns (result: int)\n  requires |a| == |b|\n  ensures result == DotProductSpec(a, b)\n{\n  var sum := 0;\n  var i := 0;\n  while i < |a|\n    invariant 0 <= i <= |a|\n    invariant sum == DotProductSpec(a[..i], b[..i])\n  {\n    sum := sum + a[i] * b[i];\n    i := i + 1;\n  }\n  result := sum;\n}\n\nfunction DotProductSpec(a: seq<int>, b: seq<int>): int\n  requires |a| == |b|\n{\n  if |a| == 0 then 0 else a[0] * b[0] + DotProductSpec(a[1..], b[1..])\n}",
            "parents": [
                "3b31f8d6-915d-4c75-a055-6ecea83e97ec"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "6047c764-28b5-4ad7-8a63-9853f925b0d8",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant exists i: int :: left <= i <= right && \n              (forall j: int :: left <= j < i ==> arr[j] <= arr[i]) &&\n              (forall j: int :: i < j <= right ==> arr[j] >= arr[i])\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  // The following line is unreachable, but needed for compilation\n  assert false; // This assertion will never be reached if the loop terminates correctly\n  return arr[k]; \n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "bb0ff6cf-a71f-4df2-9821-45c8f7c9e416"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "72bc78ce-a4ec-446e-be3b-8c07068d9a1d",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  \n  constructor() {\n    elements := [];\n  }\n\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n    assert |elements| == old(|elements|) - 1; // Ensure the size is decremented\n  }\n\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n\n  method IsEmpty() returns (isEmpty: bool)\n    ensures isEmpty == (|elements| == 0)\n  {\n    isEmpty := |elements| == 0;\n  }\n}",
            "parents": [
                "8660b894-119a-4cdd-a72f-a1355d37e38f"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "a7bd67bf-642f-4ca4-8ec7-d02162e96b94",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  \n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  \n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  \n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  \n  method UpdatePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures forall i :: 0 <= i < |elements| ==> elements[i].1 != value || elements[i].0 == newPriority\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n      invariant exists j :: i <= j < |elements| && elements[j].1 == value\n    {\n      i := i + 1;\n    }\n\n    // Remove the element with the old priority\n    elements := elements[..i] + elements[i+1..];\n\n    // Reinsert the element with the new priority\n    var newElement := (newPriority, value);\n    i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  \n  method Merge(other: PriorityQueue)\n    modifies this\n    ensures |elements| == |old(elements)| + |other.elements|\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures forall e :: e in old(elements) || e in other.elements ==> e in elements\n  {\n    var merged: seq<(int, int)> := [];\n    var i := 0;\n    var j := 0;\n    while i < |elements| || j < |other.elements|\n      invariant 0 <= i <= |elements|\n      invariant 0 <= j <= |other.elements|\n      invariant |merged| == i + j\n      invariant forall k, l :: 0 <= k < l < |merged| ==> merged[k].0 <= merged[l].0\n      invariant forall e :: e in merged ==> e in old(elements) || e in other.elements\n    {\n      if i < |elements| && (j >= |other.elements| || elements[i].0 <= other.elements[j].0) {\n        merged := merged + [elements[i]];\n        i := i + 1;\n      } else {\n        merged := merged + [other.elements[j]];\n        j := j + 1;\n      }\n    }\n    elements := merged;\n  }\n}",
            "parents": [
                "d5b40493-0f46-4a5c-a888-3282c87ee6e0"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "88c5227d-0e5f-4a27-93db-09fd50a98322",
            "type": "program",
            "content": "method LongestCommonPrefix(strings: seq<seq<char>>) returns (prefix: seq<char>)\n  requires |strings| > 0\n  ensures forall s: seq<char> :: s in strings ==> prefix <= s\n  ensures forall p: seq<char> :: (forall s: seq<char> :: s in strings ==> p <= s) ==> p <= prefix\n{\n  var minLength := |strings[0]|;\n  for i := 1 to |strings| - 1 {\n    minLength := if |strings[i]| < minLength then |strings[i]| else minLength;\n  }\n  prefix := [];\n  var i := 0;\n  while i < minLength\n    invariant 0 <= i <= minLength\n    invariant forall s: seq<char> :: s in strings ==> prefix <= s[..i]\n    invariant |prefix| == i\n    decreases minLength - i\n  {\n    var currentChar := strings[0][i];\n    var allMatch := true;\n    for j := 1 to |strings| - 1 {\n      if strings[j][i] != currentChar {\n        allMatch := false;\n        break;\n      }\n    }\n    if allMatch {\n      prefix := prefix + [currentChar];\n      i := i + 1;\n    } else {\n      break;\n    }\n  }\n}",
            "parents": [
                "d42281c9-bb07-4a62-8a1c-f35d0220bd8d"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "d3de0fa1-8d00-4630-b470-fd430383311b",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  // Final assertion to ensure the correct length is returned\n  length := maxLength;\n  assert 0 <= length <= arr.Length;\n  return length;\n}",
            "parents": [
                "2756609e-89bb-46ac-b028-a9741fad836c"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "9dedf287-e459-41a7-bf3c-2c593e1004f8",
            "type": "program",
            "content": "method IsBalancedParentheses(s: seq<char>) returns (balanced: bool)\n  ensures balanced == (CountBalanced(s) == 0)\n{\n  var count := 0;\n  balanced := true;\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant 0 <= count\n    invariant balanced == (forall j :: 0 <= j < i ==> CountBalanced(s[..j]) == 0)\n    invariant CountBalanced(s[..i]) == count\n  {\n    if s[i] == '(' {\n      count := count + 1;\n    } else if s[i] == ')' {\n      if count == 0 {\n        balanced := false;\n        return;\n      }\n      count := count - 1;\n    }\n    i := i + 1;\n  }\n  balanced := count == 0;\n}\nfunction CountBalanced(s: seq<char>): int\n  decreases s\n{\n  if |s| == 0 then 0\n  else if s[0] == '(' then 1 + CountBalanced(s[1..])\n  else if s[0] == ')' then -1 + CountBalanced(s[1..])\n  else CountBalanced(s[1..])\n}",
            "parents": [
                "b8a56f8c-d998-4813-adac-f7a2516c868b"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "5a732a12-8607-4fe8-a172-aad95ec263dd",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  \n  constructor() {\n    elements := [];\n  }\n\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements| // i is within bounds\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority // All elements before i have lower or equal priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0 // Elements before i are sorted\n      invariant forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0 // Elements in the original sequence are sorted\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n\n  method IsEmpty() returns (empty: bool)\n    ensures empty == (|elements| == 0)\n  {\n    empty := |elements| == 0;\n  }\n}",
            "parents": [
                "eaf36c65-62c9-42fd-9e27-c66d7fccd808"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "7128aac2-db1e-446c-811a-92212f861c02",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n    assert |elements| == old(|elements|) - 1; // Ensure the size decreases by 1\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n    ensures elements == old(elements)\n  {\n    value := elements[0].1;\n  }\n}",
            "parents": [
                "7d7af3a4-890a-446d-917e-477b6aa58e2f"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "9fad23d1-c014-4a55-8754-4cc54a392c1c",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  \n  constructor() {\n    elements := [];\n  }\n\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n    assert |elements| == old(|elements|) - 1; // Ensure the size is decremented\n  }\n\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n\n  method IsEmpty() returns (isEmpty: bool)\n    ensures isEmpty == (|elements| == 0)\n  {\n    isEmpty := |elements| == 0;\n  }\n}",
            "parents": [
                "72bc78ce-a4ec-446e-be3b-8c07068d9a1d"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "4efef0d0-c56c-4bce-8d8f-353d0084727d",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant forall j: int :: left <= j <= right ==> arr[j] <= arr[right]\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  // The following line is unreachable, but needed for compilation\n  return arr[k]; \n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "dfa76a91-fe16-42fe-9b43-6825f3ffcc02"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "e317f646-32ba-47cc-b1d6-6721cc172a44",
            "type": "program",
            "content": "method QuickSort(a: array<int>, lo: int, hi: int)\n  requires 0 <= lo <= hi <= a.Length\n  modifies a\n  ensures forall i, j :: lo <= i <= j < hi ==> a[i] <= a[j]\n{\n  if lo < hi {\n    var p := Partition(a, lo, hi);\n    QuickSort(a, lo, p);\n    QuickSort(a, p + 1, hi);\n  }\n}\n\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIndex: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIndex < hi\n  ensures forall i :: lo <= i < pivotIndex ==> a[i] <= a[pivotIndex]\n  ensures forall i :: pivotIndex < i < hi ==> a[pivotIndex] <= a[i]\n{\n  var pivot := a[lo];\n  var i := lo;\n  var j := hi;\n  while i < j\n    invariant lo <= i <= j <= hi\n    invariant forall k :: lo <= k < i ==> a[k] <= pivot\n    invariant forall k :: j <= k < hi ==> a[k] >= pivot\n  {\n    while i < j && a[i] <= pivot\n      invariant lo <= i < hi\n      invariant forall k :: lo <= k < i ==> a[k] <= pivot\n    {\n      i := i + 1;\n    }\n    while i < j && a[j - 1] >= pivot\n      invariant lo < j <= hi\n      invariant forall k :: j <= k < hi ==> a[k] >= pivot\n    {\n      j := j - 1;\n    }\n    if i < j {\n      a[i], a[j - 1] := a[j - 1], a[i];\n    }\n  }\n  pivotIndex := j - 1;\n  a[lo], a[pivotIndex] := a[pivotIndex], a[lo];\n}",
            "parents": [
                "c1289bdb-9f39-4c77-a9d8-ec5e9219745c"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "30fded93-c78f-40d3-a4dd-33961d960d47",
            "type": "program",
            "content": "method IsValidStackSequence(operations: seq<string>) returns (isValid: bool)\n  ensures isValid == (forall i :: 0 <= i < |operations| ==> operations[i] == \"push\" || operations[i] == \"pop\")\n{\n  var stackSize := 0;\n  isValid := true;\n  // Loop through each operation in the sequence\n  for i := 0 to |operations| \n    invariant 0 <= stackSize\n    invariant 0 <= i <= |operations|\n    invariant isValid == (forall j :: 0 <= j < i ==> operations[j] == \"push\" || operations[j] == \"pop\")\n  {\n    if i < |operations| {\n      if operations[i] == \"push\" {\n        stackSize := stackSize + 1;\n      } else if operations[i] == \"pop\" {\n        if stackSize == 0 {\n          isValid := false;\n          return;\n        }\n        stackSize := stackSize - 1;\n      } else {\n        isValid := false;\n        return;\n      }\n    }\n  }\n  \n  var maxStackSize := 0;\n  stackSize := 0; // Reset stackSize for the second loop\n  for i := 0 to |operations| \n    invariant 0 <= stackSize\n    invariant 0 <= i <= |operations|\n    invariant isValid == (forall j :: 0 <= j < i ==> operations[j] == \"push\" || operations[j] == \"pop\")\n    invariant maxStackSize >= stackSize\n  {\n    if i < |operations| {\n      if operations[i] == \"push\" {\n        stackSize := stackSize + 1;\n        if stackSize > maxStackSize {\n          maxStackSize := stackSize;\n        }\n      } else if operations[i] == \"pop\" {\n        if stackSize == 0 {\n          isValid := false;\n          return;\n        }\n        stackSize := stackSize - 1;\n      } else {\n        isValid := false;\n        return;\n      }\n    }\n  }\n}",
            "parents": [
                "4251edc1-eb92-408b-a9b9-72456f447f1c"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "b56ca82c-f750-4212-8a64-46308ee5b5d0",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method IsEmpty() returns (empty: bool)\n    ensures empty == (|elements| == 0)\n  {\n    var i := 0;\n    empty := true;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant empty == (i == 0)\n    {\n      empty := false;\n      i := i + 1;\n    }\n    assert empty == (i == 0); // Added assertion to clarify the loop's effect\n  }\n}",
            "parents": [
                "ca648669-4d60-4550-9952-523159edbd62"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "952d6a7e-672e-4cdb-8fd9-52d47394f03e",
            "type": "program",
            "content": "class Node {\n  var value: int\n  var left: Node?\n  var right: Node?\n  constructor(v: int) {\n    value := v;\n    left := null;\n    right := null;\n  }\n}\nclass BinarySearchTree {\n  var root: Node?\n  \n  method Insert(v: int) \n    modifies this\n    ensures IsBST(root)\n  {\n    root := InsertHelper(root, v);\n  }\n  \n  method InsertHelper(n: Node?, v: int) returns (result: Node?)\n    ensures IsBST(result)\n  {\n    if n == null {\n      return new Node(v);\n    }\n    if v < n.value {\n      n.left := InsertHelper(n.left, v);\n    } else if v > n.value {\n      n.right := InsertHelper(n.right, v);\n    }\n    return n;\n  }\n  \n  predicate IsBST(n: Node?) \n    reads n\n  {\n    n == null || \n    (IsBST(n.left) && IsBST(n.right) &&\n     (n.left == null || MaxValue(n.left) < n.value) &&\n     (n.right == null || MinValue(n.right) > n.value))\n  }\n  \n  function MaxValue(n: Node?): int\n    requires n != null\n    reads n\n  {\n    if n.right == null then n.value else MaxValue(n.right)\n  }\n  \n  function MinValue(n: Node?): int\n    requires n != null\n    reads n\n  {\n    if n.left == null then n.value else MinValue(n.left)\n  }\n  \n  method Height(n: Node?) returns (h: int)\n    ensures h >= 0\n  {\n    if n == null {\n      h := 0;\n    } else {\n      var leftHeight := Height(n.left);\n      var rightHeight := Height(n.right);\n      h := if leftHeight > rightHeight then leftHeight + 1 else rightHeight + 1;\n    }\n  }\n  \n  method CountNodes(n: Node?) returns (count: int)\n    ensures count >= 0\n  {\n    if n == null {\n      count := 0;\n    } else {\n      var leftCount: int;\n      var rightCount: int;\n      leftCount := CountNodes(n.left);\n      rightCount := CountNodes(n.right);\n      count := leftCount + rightCount + 1;\n    }\n  }\n  \n  method SumValues(n: Node?) returns (sum: int)\n    ensures sum >= 0\n  {\n    if n == null {\n      sum := 0;\n    } else {\n      var leftSum: int;\n      var rightSum: int;\n      leftSum := SumValues(n.left);\n      rightSum := SumValues(n.right);\n      sum := leftSum + rightSum + n.value;\n    }\n  }\n}",
            "parents": [
                "bb88517a-4b61-4968-a97c-94f0c151c3ca"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "f3707a4b-2d70-42aa-b95c-18edaeb90763",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant forall j: int :: left <= j <= right ==> arr[j] <= arr[right]\n    invariant exists i: int :: left <= i <= right && arr[i] == arr[k] // Added invariant\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  // This line is unreachable, but needed for compilation\n  return arr[k]; \n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "451f486f-dd8b-42a0-a11f-649490858504"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "66d33384-a312-4f2f-91a7-5b62e1cf9b83",
            "type": "program",
            "content": "method DotProduct(a: seq<int>, b: seq<int>) returns (result: int)\n  requires |a| == |b|\n  ensures result == DotProductSpec(a, b)\n{\n  var sum := 0;\n  var i := 0;\n  while i < |a|\n    invariant 0 <= i <= |a|\n    invariant sum == DotProductSpec(a[..i], b[..i])\n  {\n    sum := sum + a[i] * b[i];\n    i := i + 1;\n  }\n  result := sum;\n}\n\nfunction DotProductSpec(a: seq<int>, b: seq<int>): int\n  requires |a| == |b|\n{\n  if |a| == 0 then 0 else a[0] * b[0] + DotProductSpec(a[1..], b[1..])\n}",
            "parents": [
                "bf0bf0e5-f674-41a8-8680-c3b5d5b3dc87"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "4dbb8a6d-7f21-4beb-bdc7-d86ee2a47651",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n    assert |elements| == old(|elements|) - 1; // Ensure the size decreases by 1\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n    ensures elements == old(elements)\n  {\n    var i := 0;\n    var highestPriority := elements[0].0;\n    value := elements[0].1;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= highestPriority\n      invariant exists k :: 0 <= k < |elements| && elements[k].0 == highestPriority && value == elements[k].1\n    {\n      if elements[i].0 < highestPriority {\n        highestPriority := elements[i].0;\n        value := elements[i].1;\n      }\n      i := i + 1;\n    }\n    assert exists k :: 0 <= k < |elements| && elements[k].0 == highestPriority && value == elements[k].1;\n  }\n  method IsEmpty() returns (empty: bool)\n    ensures empty <==> |elements| == 0\n  {\n    empty := |elements| == 0;\n  }\n}",
            "parents": [
                "e23a1fb4-6ec6-4ecd-8b29-b3a74e7964ad"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "77845c6f-c852-40cc-88ef-6df8a07b1b56",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  \n  constructor() {\n    elements := [];\n  }\n\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n\n  method IsEmpty() returns (empty: bool)\n    ensures empty <==> |elements| == 0\n  {\n    empty := |elements| == 0;\n  }\n\n  method Size() returns (size: int)\n    ensures size == |elements|\n  {\n    size := 0;\n    var i := 0;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant size == i\n    {\n      size := size + 1;\n      i := i + 1;\n    }\n  }\n}",
            "parents": [
                "97bb510f-e2f4-4b26-a47b-bd3678103715"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "3affcb9e-6935-4e84-bb22-a57e6d14fa7a",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  \n  constructor() {\n    elements := [];\n  }\n\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n\n  method IsEmpty() returns (isEmpty: bool)\n    ensures isEmpty == (|elements| == 0)\n  {\n    isEmpty := |elements| == 0;\n  }\n}",
            "parents": [
                "fcd79252-c8a7-44f5-a5eb-75d9da8e1c42"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "b7d7f4a1-140f-4b92-af71-b4c953573cb2",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n    {\n      i := i + 1;\n    }\n    var updatedElement := (newPriority, value);\n    elements := elements[..i] + elements[i+1..];\n    \n    // Re-insert the updated element\n    var j := 0;\n    while j < |elements| && elements[j].0 <= newPriority\n      invariant 0 <= j <= |elements|\n      invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n    {\n      j := j + 1;\n    }\n    elements := elements[..j] + [updatedElement] + elements[j..];\n  }\n  method Remove(value: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i :: 0 <= i < |elements| ==> elements[i].1 != value\n    ensures |elements| == old(|elements|) - 1\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n    {\n      i := i + 1;\n    }\n    // Ensure that we are removing the correct element\n    assert i < |elements| && elements[i].1 == value;\n    elements := elements[..i] + elements[i+1..];\n  }\n}",
            "parents": [
                "fed6b336-4b0c-4158-b518-2122cd526d52"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "5972193f-0e0b-4078-aa5a-361a1d39b1fa",
            "type": "program",
            "content": "method IsBalancedParentheses(s: seq<char>) returns (balanced: bool)\n  ensures balanced == (CountUnmatched(s) == 0)\n{\n  var unmatched := 0;\n  var i := 0;\n  while i < |s|\n    invariant 0 <= unmatched <= i\n    invariant 0 <= i <= |s|\n    invariant unmatched >= 0 // Added invariant to ensure unmatched is non-negative\n    decreases |s| - i\n  {\n    if s[i] == '(' {\n      unmatched := unmatched + 1;\n    } else if s[i] == ')' {\n      if unmatched == 0 {\n        return false;\n      }\n      unmatched := unmatched - 1;\n    }\n    i := i + 1;\n  }\n  return unmatched == 0;\n}\n\nfunction CountUnmatched(s: seq<char>): int\n  decreases s\n{\n  if |s| == 0 then\n    0\n  else if s[0] == '(' then\n    1 + CountUnmatched(s[1..])\n  else if s[0] == ')' then\n    -1 + CountUnmatched(s[1..])\n  else\n    CountUnmatched(s[1..])\n}",
            "parents": [
                "8e4ec1fc-6876-4ad8-98dd-24601de53ef7"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "24eb4ea7-4318-4277-bf47-d49db8d4e292",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant forall j: int :: left <= j <= right ==> (arr[j] <= arr[right] && arr[j] >= arr[left])\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  // This line is unreachable, but needed for compilation\n  return arr[k]; \n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "d9f3ec73-7451-4dc1-97a1-f0670c080936"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "9c7032fb-706f-4922-815f-ef4ce5b19464",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant exists i: int :: left <= i <= right && arr[i] == arr[k]\n    invariant forall j: int :: left <= j <= right ==> arr[j] >= arr[left] && arr[j] <= arr[right]\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  // The following return statement is unreachable but needed for compilation\n  return arr[k]; \n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "4cd78da6-c045-466d-b20e-1e728f74c495"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "SUCCESS"
            }
        },
        {
            "id": "32fcd9c0-e689-4f69-a0ce-8cf0d8796459",
            "type": "program",
            "content": "method QuickSort(a: array<int>, lo: int, hi: int)\n  requires 0 <= lo <= hi <= a.Length\n  modifies a\n  ensures forall i, j :: lo <= i <= j < hi ==> a[i] <= a[j]\n{\n  if lo < hi {\n    var p := Partition(a, lo, hi);\n    QuickSort(a, lo, p);\n    QuickSort(a, p + 1, hi);\n  }\n}\n\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIndex: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIndex < hi\n  ensures forall i :: lo <= i < pivotIndex ==> a[i] <= a[pivotIndex]\n  ensures forall i :: pivotIndex < i < hi ==> a[pivotIndex] <= a[i]\n{\n  var pivot := a[lo];\n  var i := lo;\n  var j := hi;\n  while i < j\n    invariant lo <= i <= j <= hi\n    invariant forall k :: lo <= k < i ==> a[k] <= pivot\n    invariant forall k :: j <= k < hi ==> a[k] >= pivot\n    invariant exists p :: lo <= p < hi && a[p] == pivot\n  {\n    while i < j && a[i] <= pivot\n      invariant lo <= i < hi\n      invariant forall k :: lo <= k < i ==> a[k] <= pivot\n    {\n      i := i + 1;\n    }\n    while i < j && a[j - 1] >= pivot\n      invariant lo < j <= hi\n      invariant forall k :: j <= k < hi ==> a[k] >= pivot\n    {\n      j := j - 1;\n    }\n    if i < j {\n      a[i], a[j - 1] := a[j - 1], a[i];\n    }\n  }\n  pivotIndex := j - 1;\n  a[lo], a[pivotIndex] := a[pivotIndex], a[lo];\n  // Additional assertion to ensure the pivot is in the correct position\n  assert lo <= pivotIndex < hi;\n}",
            "parents": [
                "0954d8e0-5509-4cfe-8706-0bc8b0ee246d"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "2125d010-8071-4919-b7f8-927097a40232",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant forall j: int :: left <= j <= right ==> (arr[j] <= arr[right] && arr[j] >= arr[left]) // Elements are within bounds\n    invariant forall j: int :: left <= j <= right ==> arr[j] < arr[right + 1] // Ensure elements are less than the next element\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  // This line is unreachable, but needed for compilation\n  return arr[k]; \n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "c00ca60b-64db-47f2-8608-f8524ebe4fa4"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "7d835d2c-6803-4902-b8d0-a8821f17db37",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n    ensures elements == old(elements)\n  {\n    var i := 0;\n    var highestPriority := elements[0].0;\n    value := elements[0].1;\n    while i < |elements|\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= highestPriority\n      invariant exists k :: 0 <= k < i && elements[k].0 == highestPriority && value == elements[k].1\n    {\n      if elements[i].0 < highestPriority {\n        highestPriority := elements[i].0;\n        value := elements[i].1;\n      }\n      i := i + 1;\n    }\n    assert value == elements[0].1;\n  }\n  method IsEmpty() returns (empty: bool)\n    ensures empty <==> |elements| == 0\n  {\n    empty := |elements| == 0;\n  }\n}",
            "parents": [
                "080746f7-aa39-43f0-bd33-866d4d8c49d8"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "259195f2-0486-4928-b9cf-53298a97a4dd",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant exists i: int :: left <= i <= right && \n              (forall j: int :: left <= j < i ==> arr[j] <= arr[i]) &&\n              (forall j: int :: i < j <= right ==> arr[j] >= arr[i])\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  // The following line is unreachable but needed for compilation\n  return arr[k]; \n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right + 1 // Adjusted to include j == right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "ccdfa0ae-d4db-45dd-bdd4-610a85f69754"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "b88ceb31-b528-4357-b32b-daa61ab6c725",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  \n  constructor() {\n    elements := [];\n  }\n\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n      invariant forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n    assert |elements| == old(|elements|) - 1; // Ensure the size decreases by 1\n  }\n\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n\n  method IsEmpty() returns (isEmpty: bool)\n    ensures isEmpty == (|elements| == 0)\n  {\n    isEmpty := |elements| == 0;\n  }\n}",
            "parents": [
                "cf8b49b7-7138-442c-9f20-7575e9dbad9a"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "e4baee2d-183b-4b70-ada9-2e075a83e7d3",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant forall j: int :: left <= j <= right ==> (arr[j] <= arr[k] || arr[j] >= arr[k])\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  // This line is unreachable, but needed for compilation\n  return arr[k]; \n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "fa5be51d-627c-416b-a66e-63acfeb27a87"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "0744d0d1-78d0-4bd7-9a7e-ac199af74188",
            "type": "program",
            "content": "method DotProduct(a: seq<int>, b: seq<int>) returns (result: int)\n  requires |a| == |b|\n  ensures result == DotProductSpec(a, b)\n{\n  var sum := 0;\n  var i := 0;\n  while i < |a|\n    invariant 0 <= i <= |a|\n    invariant sum == DotProductSpec(a[..i], b[..i])\n    decreases |a| - i\n  {\n    sum := sum + a[i] * b[i];\n    i := i + 1;\n  }\n  result := sum;\n}\n\nfunction DotProductSpec(a: seq<int>, b: seq<int>): int\n  requires |a| == |b|\n{\n  if |a| == 0 then 0 else a[0] * b[0] + DotProductSpec(a[1..], b[1..])\n}",
            "parents": [
                "ed5524ab-12af-4015-94f6-05b21d0b06b5"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "c2d7504a-6d1b-40f5-83fb-01cc12958f04",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(oldPriority: int, value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i] == (oldPriority, value)\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var i := 0;\n    while i < |elements| && elements[i] != (oldPriority, value)\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k] != (oldPriority, value)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + elements[i+1..];\n    \n    var newElement := (newPriority, value);\n    i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Merge(other: PriorityQueue)\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var i := 0;\n    while i < |other.elements|\n      invariant 0 <= i <= |other.elements|\n      invariant forall k :: 0 <= k < i ==> elements[..|elements|] + other.elements[..k] == elements[..|elements| + k]\n      invariant forall m, n :: 0 <= m < n < |elements| ==> elements[m].0 <= elements[n].0\n    {\n      var (priority, value) := other.elements[i];\n      var j := 0;\n      while j < |elements| && elements[j].0 <= priority\n        invariant 0 <= j <= |elements|\n        invariant forall k :: 0 <= k < j ==> elements[k].0 <= priority\n      {\n        j := j + 1;\n      }\n      elements := elements[..j] + [(priority, value)] + elements[j..];\n      i := i + 1;\n    }\n  }\n}",
            "parents": [
                "bd5e4a80-0b68-44e3-8b6f-c151e0b42635"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "cc6f4397-cdb3-4ecc-a571-54cebb5af7bc",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant forall j: int :: left <= j <= right ==> \n              (arr[j] <= arr[k] || arr[j] > arr[k]) // Ensure partitioning respects the kth element\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  // This line is unreachable, but needed for compilation\n  return arr[k]; \n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "7de4d0d2-4f45-4f57-9578-9ae4e62f931c"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "1233a416-8c05-419c-98b7-c3bf2adcf1e5",
            "type": "program",
            "content": "method QuickSort(a: array<int>, lo: int, hi: int)\n  requires 0 <= lo <= hi <= a.Length\n  modifies a\n  ensures forall i, j :: lo <= i <= j < hi ==> a[i] <= a[j]\n{\n  if lo < hi {\n    var p := Partition(a, lo, hi);\n    QuickSort(a, lo, p);\n    QuickSort(a, p + 1, hi);\n  }\n}\n\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIndex: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIndex < hi\n  ensures forall i :: lo <= i < pivotIndex ==> a[i] <= a[pivotIndex]\n  ensures forall i :: pivotIndex < i < hi ==> a[pivotIndex] <= a[i]\n{\n  var pivot := a[lo];\n  var i := lo;\n  var j := hi;\n  while i < j\n    invariant lo <= i <= j <= hi\n    invariant forall k :: lo <= k < i ==> a[k] <= pivot\n    invariant forall k :: j <= k < hi ==> a[k] >= pivot\n    invariant exists p :: lo <= p < hi && a[p] == pivot\n  {\n    while i < j && a[i] <= pivot\n      invariant lo <= i < hi\n      invariant forall k :: lo <= k < i ==> a[k] <= pivot\n    {\n      i := i + 1;\n    }\n    while i < j && a[j - 1] >= pivot\n      invariant lo < j <= hi\n      invariant forall k :: j <= k < hi ==> a[k] >= pivot\n    {\n      j := j - 1;\n    }\n    if i < j {\n      a[i], a[j - 1] := a[j - 1], a[i];\n    }\n  }\n  pivotIndex := j - 1;\n  a[lo], a[pivotIndex] := a[pivotIndex], a[lo];\n  \n  // Additional assertion to maintain the properties after partitioning\n  assert forall k :: lo <= k < pivotIndex ==> a[k] <= a[pivotIndex];\n  assert forall k :: pivotIndex < k < hi ==> a[pivotIndex] <= a[k];\n  \n  // Ensure that the pivot is correctly positioned\n  assert a[pivotIndex] == pivot;\n}",
            "parents": [
                "33a8f993-3417-4bfc-9d6f-8c48dc991f5c"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "a178c1f9-bcf4-4762-87c3-f799d7e53e1c",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant forall j: int :: left <= j <= right ==> arr[j] <= arr[right] // Elements to the left of the pivot are less than or equal to pivot\n    invariant forall j: int :: left <= j <= right ==> arr[j] >= arr[left] // Elements to the right of the pivot are greater than or equal to pivot\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  // This line is unreachable, but needed for compilation\n  return arr[k]; \n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "ab71fddc-8dde-482e-8579-5ec5bd7cd4b3"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "152870cb-9b1b-4cd6-a396-8533464423eb",
            "type": "program",
            "content": "method IsPerfectSquare(n: nat) returns (result: bool)\n  ensures result <==> exists k: nat :: k * k == n\n{\n  var k: nat := 0;\n  result := false;\n  while k * k <= n\n    invariant 0 <= k <= n + 1\n    invariant forall i: nat :: 0 <= i < k ==> i * i != n\n    invariant result <==> exists i: nat :: i * i == n && i < k\n  {\n    if k * k == n {\n      result := true;\n      return;\n    }\n    k := k + 1;\n  }\n}",
            "parents": [
                "f390dd04-9155-464e-b156-a9079e20eb98"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "933a0305-9f91-4916-a99e-df84b921c0ea",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant elements == old(elements)\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method UpdatePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures forall i :: 0 <= i < |elements| ==> elements[i].1 != value || elements[i].0 == newPriority\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n      invariant exists j :: i <= j < |elements| && elements[j].1 == value\n    {\n      i := i + 1;\n    }\n\n    // Remove the element with the old priority\n    elements := elements[..i] + elements[i+1..];\n\n    // Reinsert the element with the new priority\n    var newElement := (newPriority, value);\n    i := 0;\n    while i < |elements| && elements[i].0 <= newPriority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= newPriority\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n  }\n  \n  method Merge(other: PriorityQueue)\n    modifies this\n    ensures |elements| == |old(elements)| + |other.elements|\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures forall e :: e in old(elements) || e in other.elements ==> e in elements\n  {\n    var merged: seq<(int, int)> := [];\n    var i := 0;\n    var j := 0;\n    while i < |elements| || j < |other.elements|\n      invariant 0 <= i <= |elements|\n      invariant 0 <= j <= |other.elements|\n      invariant |merged| == i + j\n      invariant forall k, l :: 0 <= k < l < |merged| ==> merged[k].0 <= merged[l].0\n      invariant forall e :: e in merged ==> e in old(elements) || e in other.elements\n    {\n      if i < |elements| && (j >= |other.elements| || elements[i].0 <= other.elements[j].0) {\n        merged := merged + [elements[i]];\n        i := i + 1;\n      } else {\n        merged := merged + [other.elements[j]];\n        j := j + 1;\n      }\n    }\n    elements := merged;\n  }\n}",
            "parents": [
                "d5b40493-0f46-4a5c-a888-3282c87ee6e0"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "91c02ec3-a2b8-41d8-a6ac-a352431e76ef",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method ChangePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n    ensures exists i :: 0 <= i < |elements| && elements[i] == (newPriority, value)\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant exists j :: 0 <= j < |elements| ==> elements[j].1 == value\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n    {\n      i := i + 1;\n    }\n    var oldElement := elements[i];\n    elements := elements[..i] + elements[i+1..];\n    \n    // Ensure the priority queue remains sorted after removing the element\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n\n    var j := 0;\n    while j < |elements| && elements[j].0 <= newPriority\n      invariant 0 <= j <= |elements|\n      invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < j ==> elements[k].0 <= elements[l].0\n    {\n      j := j + 1;\n    }\n    elements := elements[..j] + [(newPriority, value)] + elements[j..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n}",
            "parents": [
                "8722fea9-7477-4be9-b5df-bde6c3ec6d1f"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "0afd96dc-0a89-4f5f-93fb-4a26d5219bb7",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i - 1 ==> lis[k] <= lis[k + 1]  // Ensure lis is non-decreasing\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k :: 0 <= k < i - 1 ==> lis[k] <= lis[k + 1]  // Maintain non-decreasing order\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n}",
            "parents": [
                "ef5e2ccb-f464-482e-bcda-f79412089a5a"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "49a8fcaf-d691-4d70-9fcf-8650eac30002",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant forall j: int :: 0 <= j < arr.Length ==> (arr[j] < arr[k] ==> j < k) // Ensure the ordering of elements\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  // The following line is unreachable, but needed for compilation\n  return arr[k]; \n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "c48e1814-ca50-4b6e-b86c-3be0ef5feb3b"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "ed22f5cb-7663-47fe-8728-7a67ddcde3e0",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant exists i: int :: left <= i <= right && arr[i] == arr[k]\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  // The following return is unreachable but needed for compilation\n  return arr[k]; \n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "ee0b48e9-735d-451d-94aa-936f96717a13"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "0c0d6e54-d926-4f7b-8828-8e8fd3123483",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> lis[k] == 1\n    invariant maxLength == 1\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i\n    invariant forall k, l :: 0 <= k < l < i && arr[k] < arr[l] ==> lis[k] < lis[l]\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k, l :: 0 <= k < l < i && arr[k] < arr[l] ==> lis[k] < lis[l]\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  length := maxLength;\n}",
            "parents": [
                "37b1c7b5-bca0-426b-a27b-1d024df8ec16"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "de14a46a-9349-466d-9760-4b2540c5749c",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant forall j: int :: left <= j <= right ==> (arr[j] <= arr[right] && arr[j] >= arr[left])\n    invariant exists i: int :: left <= i <= right && arr[i] == arr[k] // Added invariant\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  // This line is unreachable, but needed for compilation\n  return arr[k]; \n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "9adc37cf-8edc-48f9-ab79-921b7cac1eb0"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "202e4448-a047-4eb6-a9ed-2a30f2f713ca",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant exists i: int :: left <= i <= right && \n              (forall j: int :: left <= j < i ==> arr[j] <= arr[i]) &&\n              (forall j: int :: i < j <= right ==> arr[j] >= arr[i])\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  // The following line is unreachable, but needed for compilation\n  assert false; // This will help the verifier understand that the loop must terminate correctly\n  return arr[k]; \n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n    invariant forall p: int :: j < p <= right ==> arr[p] >= pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "21ef4008-bda1-48ba-ba27-d6d7e6ccdc40"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "56d4454b-1dbb-443d-8252-759ae39b0baa",
            "type": "program",
            "content": "method DotProduct(a: seq<int>, b: seq<int>) returns (result: int)\n  requires |a| == |b|\n  ensures result == DotProductSpec(a, b)\n{\n  var sum := 0;\n  var i := 0;\n  while i < |a|\n    invariant 0 <= i <= |a|\n    invariant sum == DotProductSpec(a[..i], b[..i])\n    decreases |a| - i\n  {\n    sum := sum + a[i] * b[i];\n    i := i + 1;\n  }\n  result := sum;\n}\n\nfunction DotProductSpec(a: seq<int>, b: seq<int>): int\n  requires |a| == |b|\n{\n  if |a| == 0 then 0 else a[0] * b[0] + DotProductSpec(a[1..], b[1..])\n}",
            "parents": [
                "401a50ec-4a14-4833-8d6a-b16c2142dae4"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "ccf8b0fe-0828-46f2-b259-9192ef20a5a6",
            "type": "program",
            "content": "method QuickSort(a: array<int>, lo: int, hi: int)\n  requires 0 <= lo <= hi <= a.Length\n  modifies a\n  ensures forall i, j :: lo <= i <= j < hi ==> a[i] <= a[j]\n{\n  if lo < hi {\n    var p := Partition(a, lo, hi);\n    QuickSort(a, lo, p);\n    QuickSort(a, p + 1, hi);\n  }\n}\n\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIndex: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIndex < hi\n  ensures forall i :: lo <= i < pivotIndex ==> a[i] <= a[pivotIndex]\n  ensures forall i :: pivotIndex < i < hi ==> a[pivotIndex] <= a[i]\n{\n  var pivot := a[lo];\n  var i := lo;\n  var j := hi;\n  while i < j\n    invariant lo <= i <= j <= hi\n    invariant forall k :: lo <= k < i ==> a[k] <= pivot\n    invariant forall k :: j <= k < hi ==> a[k] >= pivot\n    invariant exists p :: lo <= p < hi && a[p] == pivot\n  {\n    while i < j && a[i] <= pivot\n      invariant lo <= i < hi\n      invariant forall k :: lo <= k < i ==> a[k] <= pivot\n    {\n      i := i + 1;\n    }\n    while i < j && a[j - 1] >= pivot\n      invariant lo < j <= hi\n      invariant forall k :: j <= k < hi ==> a[k] >= pivot\n    {\n      j := j - 1;\n    }\n    if i < j {\n      a[i], a[j - 1] := a[j - 1], a[i];\n    }\n  }\n  pivotIndex := j - 1;\n  a[lo], a[pivotIndex] := a[pivotIndex], a[lo];\n  assert forall k :: lo <= k < pivotIndex ==> a[k] <= a[pivotIndex];\n  assert forall k :: pivotIndex < k < hi ==> a[pivotIndex] <= a[k];\n  // Additional assertions to ensure the correctness of the partitioning\n  assert a[pivotIndex] == pivot; // Ensure the pivot is at the correct index\n}",
            "parents": [
                "c33bdfa5-2a06-4477-8b69-036869b48b76"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "59d028d5-aec3-4995-babf-1ece56688099",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n  method IsEmpty() returns (empty: bool)\n    ensures empty == (|elements| == 0)\n  {\n    empty := |elements| == 0;\n  }\n}",
            "parents": [
                "b0eee263-eb97-469c-a1ad-952757a08cf1"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "7ed2b137-8e4f-4275-ad20-c66d2ddef63f",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant forall j: int :: left <= j <= right ==> arr[j] <= arr[right] // Added invariant\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  // The following line is unreachable but needed for compilation\n  return arr[k]; \n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "d2614e46-12f5-4f3a-8ffb-2a4c0a5dc5ad"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "3e85d84c-de2e-4dc6-9b7e-0b163d460bd1",
            "type": "program",
            "content": "method IsPerfectSquare(n: nat) returns (result: bool)\n  ensures result == (exists k: nat :: k * k == n)\n{\n  var k: nat := 0;\n  result := false;\n  while k * k <= n\n    invariant 0 <= k <= n + 1\n    invariant forall i: nat :: 0 <= i < k ==> i * i != n\n    invariant result == (exists i: nat :: i < k && i * i == n)\n  {\n    if k * k == n {\n      result := true;\n      return;\n    }\n    k := k + 1;\n  }\n  // After the loop, we have k * k > n\n  assert forall i: nat :: i < k ==> i * i != n; // This holds because we never found a perfect square\n  assert result == (exists i: nat :: i < k && i * i == n); // This holds because result is false\n}",
            "parents": [
                "f659e117-b330-4802-b34b-932d92347fff"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "4710fd85-3975-4210-8a00-8385d43ff4c3",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant exists i: int :: left <= i <= right && \n              (forall j: int :: left <= j < i ==> arr[j] <= arr[i]) &&\n              (forall j: int :: i < j <= right ==> arr[j] >= arr[i])\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  // The following line is unreachable, but needed for compilation\n  assert false; // This assertion will never be reached if the loop terminates correctly\n  return arr[k]; \n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "6047c764-28b5-4ad7-8a63-9853f925b0d8"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "afbbfc88-6504-4a9a-ba5a-9d70ac60c21b",
            "type": "program",
            "content": "method DotProduct(a: seq<int>, b: seq<int>) returns (result: int)\n  requires |a| == |b|\n  ensures result == DotProductSpec(a, b)\n{\n  var sum := 0;\n  var i := 0;\n  while i < |a|\n    invariant 0 <= i <= |a|\n    invariant sum == DotProductSpec(a[..i], b[..i])\n    decreases |a| - i\n  {\n    sum := sum + a[i] * b[i];\n    i := i + 1;\n  }\n  result := sum;\n}\n\nfunction DotProductSpec(a: seq<int>, b: seq<int>): int\n  requires |a| == |b|\n{\n  if |a| == 0 then 0 else a[0] * b[0] + DotProductSpec(a[1..], b[1..])\n}",
            "parents": [
                "b60f9126-cdab-4429-ab6e-8d2fb3925654"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "66db89a0-0c3d-49eb-862c-1656beb2b225",
            "type": "program",
            "content": "method LongestIncreasingSubsequence(arr: array<int>) returns (length: int)\n  requires arr != null\n  ensures 0 <= length <= arr.Length\n  ensures forall i, j :: 0 <= i < j < arr.Length && arr[i] < arr[j] ==> length >= j - i + 1\n{\n  var n := arr.Length;\n  if n == 0 {\n    return 0;\n  }\n  var lis := new int[n];\n  var maxLength := 1;\n  // Initialize LIS values for all indexes\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n  {\n    lis[i] := 1;\n    i := i + 1;\n  }\n  // Compute optimized LIS values in a bottom-up manner\n  i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n    invariant 1 <= maxLength <= i + 1\n    invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n  {\n    var j := 0;\n    while j < i\n      invariant 0 <= j <= i\n      invariant forall k :: 0 <= k < i ==> 1 <= lis[k] <= k + 1\n      invariant forall k :: 0 <= k < i ==> lis[k] <= maxLength\n    {\n      if arr[j] < arr[i] && lis[i] < lis[j] + 1 {\n        lis[i] := lis[j] + 1;\n      }\n      j := j + 1;\n    }\n    if maxLength < lis[i] {\n      maxLength := lis[i];\n    }\n    i := i + 1;\n  }\n  return maxLength;\n}",
            "parents": [
                "811f4228-3324-4fc6-975e-cf4984679871"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "21ed52c5-10f6-4508-8cdc-ddf3d2d9999a",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant forall j: int :: left <= j <= right ==> (arr[j] < arr[k] || arr[j] >= arr[k])\n    invariant forall j: int :: left <= j <= right ==> (arr[j] < arr[left] || arr[j] >= arr[left])\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  // The following line is unreachable but needed for compilation\n  return arr[k]; \n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "3335d6d0-7b27-462c-a1c0-023f2120aae5"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "eb5d0d9a-80ba-4b1e-b9b3-feb861eea7f7",
            "type": "program",
            "content": "class PriorityQueue {\n  var elements: seq<(int, int)> // (priority, value)\n  constructor() {\n    elements := [];\n  }\n  method Enqueue(priority: int, value: int)\n    modifies this\n    ensures elements == old(elements) + [(priority, value)]\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var newElement := (priority, value);\n    var i := 0;\n    while i < |elements| && elements[i].0 <= priority\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].0 <= priority\n      invariant forall k, l :: 0 <= k < l < i ==> elements[k].0 <= elements[l].0\n    {\n      i := i + 1;\n    }\n    elements := elements[..i] + [newElement] + elements[i..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Dequeue() returns (value: int)\n    requires |elements| > 0\n    modifies this\n    ensures elements == old(elements[1..])\n    ensures value == old(elements[0].1)\n  {\n    value := elements[0].1;\n    elements := elements[1..];\n  }\n  method UpdatePriority(value: int, newPriority: int)\n    requires exists i :: 0 <= i < |elements| && elements[i].1 == value\n    modifies this\n    ensures forall i, j :: 0 <= i < j < |elements| ==> elements[i].0 <= elements[j].0\n  {\n    var i := 0;\n    while i < |elements| && elements[i].1 != value\n      invariant 0 <= i <= |elements|\n      invariant forall k :: 0 <= k < i ==> elements[k].1 != value\n    {\n      i := i + 1;\n    }\n    \n    var oldElement := elements[i];\n    elements := elements[..i] + elements[i+1..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n\n    // Reinsert the element with the new priority\n    var newElement := (newPriority, value);\n    var j := 0;\n    while j < |elements| && elements[j].0 <= newPriority\n      invariant 0 <= j <= |elements|\n      invariant forall k :: 0 <= k < j ==> elements[k].0 <= newPriority\n      invariant forall k, l :: 0 <= k < l < j ==> elements[k].0 <= elements[l].0\n    {\n      j := j + 1;\n    }\n    elements := elements[..j] + [newElement] + elements[j..];\n    assert forall k, l :: 0 <= k < l < |elements| ==> elements[k].0 <= elements[l].0;\n  }\n  method Peek() returns (value: int)\n    requires |elements| > 0\n    ensures value == elements[0].1\n  {\n    value := elements[0].1;\n  }\n}",
            "parents": [
                "92187984-0b8a-4ac1-bf23-2b9ed3120806"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "69b3232c-5828-4b67-85be-ea62ef04cdfa",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant exists i: int :: left <= i <= right && \n              (forall j: int :: left <= j < i ==> arr[j] <= arr[i]) &&\n              (forall j: int :: i < j <= right ==> arr[j] >= arr[i])\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  // This line is unreachable, but needed for compilation\n  return arr[k]; \n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "63f82f96-933b-4c3a-8d7d-7257e3c34172"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        },
        {
            "id": "df407665-0dbe-4631-adb7-6f04c4c16110",
            "type": "program",
            "content": "class Vector3D {\n  var x: int\n  var y: int\n  var z: int\n  constructor(x: int, y: int, z: int) \n    ensures this.x == x && this.y == y && this.z == z\n  {\n    this.x := x;\n    this.y := y;\n    this.z := z;\n  }\n  \n  method CrossProduct(other: Vector3D) returns (result: Vector3D)\n    ensures result.x == this.y * other.z - this.z * other.y\n    ensures result.y == this.z * other.x - this.x * other.z\n    ensures result.z == this.x * other.y - this.y * other.x\n  {\n    var cx := this.y * other.z - this.z * other.y;\n    var cy := this.z * other.x - this.x * other.z;\n    var cz := this.x * other.y - this.y * other.x;\n    result := new Vector3D(cx, cy, cz);\n  }\n\n  method DotProduct(other: Vector3D) returns (result: int)\n    ensures result == this.x * other.x + this.y * other.y + this.z * other.z\n  {\n    var sum := 0;\n    var components := [this.x, this.y, this.z];\n    var otherComponents := [other.x, other.y, other.z];\n\n    // Loop over each component to calculate the dot product\n    var i := 0;\n    while i < 3\n      invariant 0 <= i <= 3\n      invariant sum == (if i >= 1 then components[0] * otherComponents[0] else 0)\n                      + (if i >= 2 then components[1] * otherComponents[1] else 0)\n                      + (if i >= 3 then components[2] * otherComponents[2] else 0)\n    {\n      sum := sum + components[i] * otherComponents[i];\n      i := i + 1;\n    }\n\n    result := sum;\n  }\n}",
            "parents": [
                "c8041bff-3eec-4f3b-b067-6bcba8c3d80f"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "SUCCESS"
            }
        },
        {
            "id": "329972b9-ca85-4d28-8cca-c0face304d28",
            "type": "program",
            "content": "method FindKthSmallest(arr: array<int>, k: int) returns (kthSmallest: int)\n  requires 0 <= k < arr.Length\n  ensures exists i: int :: 0 <= i < arr.Length && arr[i] == kthSmallest && \n          (forall j: int :: 0 <= j < arr.Length && arr[j] < kthSmallest ==> j < i) &&\n          (forall j: int :: 0 <= j < arr.Length && arr[j] == kthSmallest ==> j <= i)\n{\n  var left := 0;\n  var right := arr.Length - 1;\n  while left <= right\n    invariant 0 <= left <= right < arr.Length\n    invariant 0 <= k < arr.Length\n    invariant forall j: int :: left <= j <= right ==> (arr[j] <= arr[right] && arr[j] >= arr[left])\n    decreases right - left\n  {\n    var pivotIndex := Partition(arr, left, right);\n    if pivotIndex == k {\n      return arr[pivotIndex];\n    } else if pivotIndex < k {\n      left := pivotIndex + 1;\n    } else {\n      right := pivotIndex - 1;\n    }\n  }\n  // The following return statement is unreachable but needed for compilation\n  return arr[k]; \n}\n\nmethod Partition(arr: array<int>, left: int, right: int) returns (pivotIndex: int)\n  requires 0 <= left <= right < arr.Length\n  ensures left <= pivotIndex <= right\n  ensures forall i: int :: left <= i < pivotIndex ==> arr[i] <= arr[pivotIndex]\n  ensures forall i: int :: pivotIndex < i <= right ==> arr[i] >= arr[pivotIndex]\n{\n  var pivot := arr[right];\n  var i := left;\n  for j := left to right - 1\n    invariant left <= i <= j <= right\n    invariant forall m: int :: left <= m < i ==> arr[m] <= pivot\n    invariant forall n: int :: i <= n <= j ==> arr[n] > pivot\n  {\n    if arr[j] <= pivot {\n      arr[i], arr[j] := arr[j], arr[i];\n      i := i + 1;\n    }\n  }\n  arr[i], arr[right] := arr[right], arr[i];\n  return i;\n}",
            "parents": [
                "04960acf-abd3-446c-9f01-9a447345a4d5"
            ],
            "statistics": {},
            "properties": {
                "verification_outcome": "GOAL_UNPROVEN"
            }
        }
    ]
}