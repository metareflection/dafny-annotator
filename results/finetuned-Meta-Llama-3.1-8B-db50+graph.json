[
    {
        "Prog-Fun-Solutions_tmp_tmp7_gmnz5f_mockExam2_p6.dfy": {
            "state": "// problem 6:\n// name:      Gabriele Berardi\n// s-number: s4878728\n// table:     XXXXX\nghost function f(n: int): int {\n  if n <= 0 then 1 else n + f(n-1)*f(n-2)\n}\nghost function fSum(n: nat): int {\n // give the body of this function\n  // it should return Sum(i: 0<=i < n: f(i))\n  if n <= 0 then 0 else f(n-1) + fSum(n-1)\n}\nmethod problem6(n:nat) returns (a: int)\nensures a == fSum(n)\n{\n  a := 0;\n  var k := 0;\n  var x := 1;\n  var y := 2;\n  while k < n\ninvariant x == f(k-1)\n  {\n    k := k + 1;\n    a := a + x;\n    x, y := y, k+1 + x*y;    \n  }\n}",
            "success": false
        },
        "dafny-exercise_tmp_tmpouftptir_appendArray.dfy": {
            "state": "method appendArray(a: array<int>, b: array<int>) returns (c: array<int>)\nensures c.Length == a.Length + b.Length\nensures forall i :: 0 <= i < a.Length ==> a[i] == c[i]\nensures forall i :: 0 <= i < b.Length ==> b[i] == c[a.Length + i]\n{\n\tc := new int[a.Length + b.Length];\n\tvar i := 0;\n\twhile i < a.Length\ninvariant a[..i] == c[..a.Length + i]\n\t{\n\t\tc[i] := a[i];\n\t\ti := i + 1;\n\t}\n\twhile i < b.Length + a.Length\n\t{\n\t\tc[i] := b[i - a.Length];\n\t\ti := i + 1;\n\t}\n}",
            "success": false
        },
        "task_id_573.dfy": {
            "state": "method UniqueProduct (arr: array<int>) returns (product: int)\n   ensures product == SetProduct((set i | 0 <= i < arr.Length :: arr[i]))\n{\n    var p := 1;\n    var seen: set<int> := {};\n    for i := 0 to arr.Length\n        invariant 0 <= i <= arr.Length\n        invariant seen == (set k | 0 <= k < i :: arr[k])\n        invariant p == SetProduct((set k | 0 <= k < i :: arr[k]))\n    {\n        if ! (arr[i] in seen) {\n            seen := seen + { arr[i] };\n            p := p * arr[i];\n            SetProductLemma(seen, arr[i]);\n        }\n    }\n    product := p;\n}\nghost function SetProduct(s : set<int>) : int\n{\n    if s == {} then 1\n    else var x :| x in s; \n         x * SetProduct(s - {x})\n}\n/* \n * This is necessary because, when we add one element, we need to make sure\n * that the product of the new set, as a whole, is the same as the product\n * of the old set times the new element.\n */\nlemma SetProductLemma(s: set <int>, x: int) \n requires x in s\n ensures SetProduct(s - {x}) * x == SetProduct(s)\n{\n   if s != {}\n   {\nassert s == s - {x} + {x};\n      var y :| y in s && y * SetProduct(s - {y}) == SetProduct(s);\n      if y == x {}\n      else {\n         calc {\n            SetProduct(s);\n            y * SetProduct(s - {y});\n            { SetProductLemma(s - {y}, x); }\n            y * x * SetProduct(s - {y} - {x});\n            { assert s - {x} - {y} == s - {y} - {x};}\n            y * x * SetProduct(s - {x} - {y});\n            x * y * SetProduct(s - {x} - {y});\n            { SetProductLemma(s - {x}, y); }\n            x * SetProduct(s - {x});\n         }\n      }\n   }\n}",
            "success": true
        },
        "task_id_769.dfy": {
            "state": "method Difference(a: seq<int>, b: seq<int>) returns (diff: seq<int>)\n    ensures forall x :: x in diff <==> (x in a && x !in b)\n    ensures forall i, j :: 0 <= i < j < |diff| ==> diff[i] != diff[j]\n{\n    diff := [];\n    for i := 0 to |a|\ninvariant forall k :: 0 <= k < i ==> a[k] !in b ==> a[k] !in diff\n    {\n        if a[i] !in b && a[i] !in diff\n        {\n            diff := diff + [a[i]];\n        }\n    }\n}",
            "success": false
        },
        "Dafny_Programs_tmp_tmp99966ew4_lemma.dfy": {
            "state": "lemma SkippingLemma(a : array<int>, j : int)\n   requires a != null\n   requires forall i :: 0 <= i < a.Length ==> 0 <= a[i]\n   requires forall i :: 0 < i < a.Length ==> a[i-1]-1 <= a[i]\n   requires 0 <= j < a.Length\n   ensures forall k :: j <= k < j + a[j] && k < a.Length ==> a[k] != 0\n{\n   var i := j;\n   while i < j + a[j] && i < a.Length\n   decreases j + a[j] - i\n      invariant i < a.Length ==> a[j] - (i-j) <= a[i]\n      invariant forall k :: j <= k < i && k < a.Length ==> a[k] != 0\n   {\n      i := i + 1;\n   }\n}\nmethod FindZero(a: array<int>) returns (index: int)\n   requires a != null\n   requires forall i :: 0 <= i < a.Length ==> 0 <= a[i]\n   requires forall i :: 0 < i < a.Length ==> a[i-1]-1 <= a[i]\n   ensures index < 0  ==> forall i :: 0 <= i < a.Length ==> a[i] != 0\n   ensures 0 <= index ==> index < a.Length && a[index] == 0\n{\n   index := 0;\n   while index < a.Length\ninvariant index < a.Length ==> forall k :: 0 <= k < index && k < a.Length ==> a[k] != 0\n   {\n      if a[index] == 0 { return; }\n      SkippingLemma(a, index);\n      index := index + a[index];\n   }\n   index := -1;\n}",
            "success": false
        },
        "Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 3_InsertionSortMultiset.dfy": {
            "state": "// H\u00f6fundur spurningar:  Snorri Agnarsson, snorri@hi.is\n// Permalink spurningar: https://rise4fun.com/Dafny/G4sc3\n// H\u00f6fundur lausnar:     Alexander Gu\u00f0mundsson\n// Permalink lausnar:    https://rise4fun.com/Dafny/nujsu\n// Insertion sort me\u00f0 hj\u00e1lp helmingunarleitar.\nmethod Search( s: seq<int>, x: int ) returns ( k: int )\n    // Ekki m\u00e1 breyta forskilyr\u00f0um e\u00f0a eftirskilyr\u00f0um fallsins\n    requires forall p,q | 0 <= p < q < |s| :: s[p] <= s[q];\n    ensures 0 <= k <= |s|;\n    ensures forall i | 0 <= i < k :: s[i] <= x;\n    ensures forall i | k <= i < |s| :: s[i] >= x;\n    ensures forall z | z in s[..k] :: z <= x;\n    ensures forall z | z in s[k..] :: z >= x;\n    ensures s == s[..k]+s[k..];\n{\n    // Setji\u00f0 vi\u00f0eigandi stofn fallsins h\u00e9r.\n    var p := 0;\n    var q := |s|;\n    if p == q\n    {\n        return p;\n    }\n    while p != q \n        decreases q-p;\n        invariant 0 <= p <= q <= |s|;\n        invariant forall r | 0 <= r < p :: s[r] <= x;\n        invariant forall r | q <= r < |s| :: s[r] >= x;\n    {\n        var m := p + (q-p)/2;\n        if s[m] == x\n        {\n            return m;\n        }\n        if s[m] < x\n        {\n            p := m+1;\n        }\n        else\n        {\n            q := m;\n        }\n    }\n    return p;\n}\nmethod Sort( m: multiset<int> ) returns ( r: seq<int> )\n    ensures multiset(r) == m;\n    ensures forall p,q | 0 <= p < q < |r| :: r[p] <= r[q];\n{\n    // Setji\u00f0 vi\u00f0eigandi frumstillingu \u00e1 r og rest h\u00e9r.\n    // r er skilabreyta en rest er n\u00fd breyta sem \u00fei\u00f0 b\u00fai\u00f0 til.\n    r := [];\n    var rest := m;\n    while rest != multiset{}\n        // Ekki breyta fastayr\u00f0ingu lykkju\n    {\n        // Setji\u00f0 vi\u00f0eigandi stofn lykkjunnar h\u00e9r.\n        // Fjarl\u00e6gi\u00f0 eitt gildi \u00far rest me\u00f0\n        //    var x :| x in rest;\n        //    rest := rest-multiset{x};\n        // og noti\u00f0 Search til a\u00f0 finna r\u00e9ttan sta\u00f0\n        // \u00ed r til a\u00f0 stinga [x] inn \u00ed r.\n        var x :| x in rest;\n        rest := rest - multiset{x};\n        var k := Search(r, x);\n        r := r[..k] + [x] + r[k..];\n    }\n    return r;\n}",
            "success": false
        },
        "Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseFirstNegative.dfy": {
            "state": "predicate positive(s:seq<int>)\n{forall u::0<=u<|s| ==> s[u]>=0}\nmethod mfirstNegative(v:array<int>) returns (b:bool, i:int)\nensures b <==> exists k::0<=k<v.Length && v[k]<0\nensures b ==> 0<=i<v.Length && v[i]<0 && positive(v[0..i])\n{ \n i:=0;\n b:=false;\n while (i<v.Length && !b)\n    invariant 0<=i<=v.Length\n    invariant b <==> exists k::0<=k<i && v[k]<0\n    invariant b ==> v[i-1]<0 && positive(v[0..i-1])\n    decreases v.Length - i\n  { \n    b:=(v[i]<0);\n    i:=i+1;\n   }\n  if (b){i:=i-1;}\n}\nmethod mfirstNegative2(v:array<int>) returns (b:bool, i:int)\nensures b <==> exists k::0<=k<v.Length && v[k]<0\nensures b ==> 0<=i<v.Length && v[i]<0 && positive(v[0..i])\n{ \n i:=0;b:=false;\n while (i<v.Length && !b)\ninvariant b ==> v[i-1]<0 && positive(v[0..i-1])\n  { \n    b:=(v[i]<0);\n    if (!b) {i:=i+1;}\n   }\n}",
            "success": false
        },
        "Metodos_Formais_tmp_tmpbez22nnn_Aula_2_ex1.dfy": {
            "state": "method Mult(x:nat, y:nat) returns (r: nat)\nensures r == x * y\n{\n    var m := x;\nassert m == x; // x has the right value\n    var n := y;\n    r:=0;\n    while m > 0\n    {\n        r := r + n;\n        m := m - 1;\n    }\n    return r;\n}",
            "success": false
        },
        "insert_strong.dfy": {
            "state": "method insert(line:array<char>, l:int, nl:array<char>, p:int, at:int)\n  requires 0 <= l+p <= line.Length\n  requires 0 <= p <= nl.Length\n  requires 0 <= at <= l\n  modifies line\n  ensures forall i :: (0<=i<p) ==> line[at+i] == nl[i]\n  ensures forall i :: (0<=i<at) ==> line[i] == old(line[i])\n  ensures forall i :: (at+p<=i<l+p) ==> line[i] == old(line[i-p])\n{\n  ghost var initialLine := line[..];\n  var i:int := l;\n  while(i>at)\ndecreases i\n  {\n    i := i - 1;\n    line[i+p] := line[i];\n  }\n  i := 0;\n  while(i<p)\n  {\n    line[at + i] := nl[i];\n    i := i + 1;\n  }\n}",
            "success": false
        },
        "task_id_743.dfy": {
            "state": "method RotateRight(l: seq<int>, n: int) returns (r: seq<int>)\n    requires n >= 0\n    ensures |r| == |l|\n    ensures forall i :: 0 <= i < |l| ==> r[i] == l[(i - n + |l|) % |l|]\n{\n    var rotated: seq<int> := [];\n    for i := 0 to |l|\ninvariant forall j :: 0 <= j < i ==> rotated[j] == l[(j - n + |l|) % |l|]\n    {\n        rotated := rotated + [l[(i - n + |l|) % |l|]];\n    }\n    return rotated;\n}",
            "success": false
        },
        "Dafny_Verify_tmp_tmphq7j0row_Test_Cases_solved_1_select.dfy": {
            "state": "method SelectionSort(a: array<int>)\n  modifies a\n  ensures forall i,j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures multiset(a[..]) == old(multiset(a[..]))\n{\n  var n := 0;\n  while n != a.Length\n  {\n    var mindex, m := n, n;\n    while m != a.Length\ninvariant forall i :: n <= i < m ==> a[mindex] <= a[i]\n    {\n      if a[m] < a[mindex] {\n        mindex := m;\n      }\n      m := m + 1;\n    }\n    if a[mindex] < a[n] {\n      a[mindex], a[n] := a[n], a[mindex];\n    }\n    n := n + 1;\n  }  \n}",
            "success": false
        },
        "task_id_414.dfy": {
            "state": "method AnyValueExists(seq1: seq<int>, seq2: seq<int>) returns (result: bool)\n    ensures result <==> (exists i :: 0 <= i < |seq1| && seq1[i] in seq2)\n{\n    result := false;\n    for i := 0 to |seq1|\ninvariant result <==> (exists k :: 0 <= k < i && seq1[k] in seq2)\n    {\n        if seq1[i] in seq2 {\n            result := true;\n            break;\n        }\n    }\n}",
            "success": true
        },
        "Correctness_tmp_tmpwqvg5q_4_MethodCalls_q1.dfy": {
            "state": "/**\n  (a) Verify whether or not the following program\n      satisfies total correctness.\n      You should use weakest precondition reasoning\n      and may extend the loop invariant if required.\n      You will need to add a decreases clause to prove termination\n  (a) Weakest precondition proof (without termination) (6 marks)\n      Termination proof (2marks)\n*/\nfunction fusc(n: int): nat\nlemma rule1()\n  ensures fusc(0) == 0\nlemma rule2()\n  ensures fusc(1) == 1\nlemma rule3(n:nat)\n  ensures fusc(2*n) == fusc(n)\nlemma rule4(n:nat)\n  ensures fusc(2*n+1) == fusc(n) + fusc(n+1)\nmethod ComputeFusc(N: int) returns (b: int)\n  requires N >= 0 \n  ensures b == fusc(N)\n{\n  b := 0;\n  var n, a := N, 1;\n  while (n != 0)\n  {\n    ghost var d := n; // termination metric\n    if (n % 2 == 0)\n    {\n      rule4(n/2);\n      rule3(n/2);\n      a := a + b;\n      n := n / 2;\n    } else {\n      rule4((n-1)/2);\n      rule3((n-1)/2);\n      rule3((n+1)/2);\n              b * fusc(n) - b  * fusc(n) + b  * fusc(((n-1)/2)+1) + a * fusc(n);\n              b * fusc(n) - b  * (fusc(n) - fusc(((n-1)/2)+1)) + a * fusc(n);\n              a * fusc(n - 1) + b  * fusc(n) - b  * fusc(n-1) + a * fusc(n) - a * fusc(n-1);\n      b := b + a;\n      n := (n - 1) / 2;\n    }\n  }\n  rule1();\n  rule2();\n}",
            "success": false
        },
        "Workshop_tmp_tmp0cu11bdq_Workshop_Answers_Question6.dfy": {
            "state": "method arrayUpToN(n: int) returns (a: array<int>)\n    requires n >= 0\n    ensures a.Length == n\n    ensures forall j :: 0 < j < n ==> a[j] >= 0\n    ensures forall j, k : int :: 0 <= j <= k < n ==> a[j] <= a[k]\n{\n    var i := 0;\n    a := new int[n];\n    while i < n\ninvariant forall j, k :: 0 <= j <= k < i ==> a[j] <= a[k]\n    {\n        a[i] := i;\n        i := i + 1;\n    }\n}",
            "success": false
        },
        "Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_50_examples_SumArray.dfy": {
            "state": "function Sum(arr: array<int>, len: int): int\n    reads arr\n    requires arr.Length > 0 && 0 <= len <= arr.Length\n{\n    if len == 0 then 0 else arr[len-1] + Sum(arr, len-1)\n}\nmethod SumArray(arr: array<int>) returns (sum: int)\n    requires arr.Length > 0\n    ensures sum == Sum(arr, arr.Length)\n{\n    sum := 0;\n    var i := 0;\n    while i < arr.Length\ninvariant sum == Sum(arr, i)\n    {\n        sum := sum + arr[i];\n        i := i + 1;\n    }\n}",
            "success": false
        },
        "task_id_424.dfy": {
            "state": "method ExtractRearChars(l: seq<string>) returns (r: seq<char>)\n    requires forall i :: 0 <= i < |l| ==> |l[i]| > 0\n    ensures |r| == |l|\n    ensures forall i :: 0 <= i < |l| ==> r[i] == l[i][|l[i]| - 1]\n{\n    var rearChars: seq<char> := [];\n    for i := 0 to |l|\ninvariant |rearChars| == i\n    {\n        rearChars := rearChars + [l[i][|l[i]| - 1]];\n    }\n    return rearChars;\n}",
            "success": false
        },
        "task_id_3.dfy": {
            "state": "method IsNonPrime(n: int) returns (result: bool)\n    requires n >= 2\n    ensures result <==> (exists k :: 2 <= k < n && n % k == 0)\n{\n    result := false;\n    var i := 2;\n    while i <= n/2\ninvariant result <==> (exists j :: 2 <= j < i && n % j == 0)\n    {\n        if n % i == 0\n        {\n            result := true;\n            break;\n        }\n        i := i + 1;\n    }\n}",
            "success": true
        },
        "task_id_8.dfy": {
            "state": "method SquareElements(a: array<int>) returns (squared: array<int>)\n    ensures squared.Length == a.Length\n    ensures forall i :: 0 <= i < a.Length ==> squared[i] == a[i] * a[i]\n{\n    squared := new int[a.Length];\n    for i := 0 to a.Length\ninvariant forall j :: 0 <= j < i ==> squared[j] == a[j] * a[j]\n    {\n        squared[i] := a[i] * a[i];\n    }\n}",
            "success": true
        },
        "task_id_170.dfy": {
            "state": "function sumTo( a:array<int>, start:int, end:int ) : int\n    requires a != null;\n    requires 0 <= start && start <= end && end <= a.Length;\n    decreases end;\n    reads a;\n    {\n        if (start == end) then 0 else sumTo(a, start, end-1) + a[end-1]\n    }\n    method SumInRange(a: array<int>, start: int, end: int) returns (sum: int)\n    requires a != null\n    requires 0 <= start && start <= end && end <= a.Length\n    ensures sum == sumTo(a, start, end)\n    {\n        sum := 0;\n        for i := start to end\ninvariant sum == sumTo(a, start, i)\n        {\n            sum := sum + a[i];\n        }\n    }",
            "success": true
        },
        "ProjectosCVS_tmp_tmp_02_gmcw_Handout 1_CVS_handout1_55754_55780.dfy": {
            "state": "/**\nCVS 2021-22 Handout 1\nAuthors\nGon\u00e7alo Martins Louren\u00e7o n\u00ba55780\nJoana Soares Faria  n\u00ba55754\n */\n// First Exercise\nlemma peasantMultLemma(a:int, b:int)\n    requires b >= 0\n    ensures b % 2 == 0 ==> (a * b == 2 * a * b / 2)\n    ensures b % 2 == 1 ==> (a * b == a + 2 * a * (b - 1) / 2)\n    {\n        if (b % 2 == 0 && b > 0) { \n            peasantMultLemma(a, b - 2);\n        }\n        if (b % 2 == 1 && b > 1) {\n            peasantMultLemma(a, b - 2);\n        }\n    }\nmethod peasantMult(a: int, b: int) returns (r: int)\n    requires b > 0\n    ensures r == a * b\n    {\n        r := 0;\n        var aa := a;\n        var bb := b;\n        while(bb > 0)\n            decreases bb \n            invariant 0 <= bb <= b\n            invariant r + aa * bb == a * b\n        { \n            // Use of lemma was not necessary for a successful verification\n            // peasantMultLemma(aa, bb);\n            if (bb % 2 == 0)\n            {\n                aa := 2 * aa;\n                bb := bb / 2;\n            } else if (bb % 2 == 1)\n            {\n                r := r + aa;\n                aa := 2 * aa;\n                bb := (bb-1) / 2;\n            }\n        } \n    }\n//Second Exercise\nmethod euclidianDiv(a: int,b : int) returns (q: int,r: int)\n    requires a >= 0\n    requires b > 0\n    ensures a == b * q + r\n    {\n        r := a;\n        q := 0;\n        while(r - b >= 0)\ninvariant r >= 0\n            // invariant a == b * q + r\n        {\n            r := r - b;\n            q := q + 1;\n        }\n    }",
            "success": false
        },
        "Software-Verification_tmp_tmpv4ueky2d_Best Time to Buy and Sell Stock_best_time_to_buy_and_sell_stock.dfy": {
            "state": "method best_time_to_buy_and_sell_stock(prices: array<int>) returns (max_profit: int)\n    requires 1 <= prices.Length <= 100000\n    requires forall i :: 0 <= i < prices.Length ==> 0 <= prices[i] <= 10000\n    ensures forall i, j :: 0 <= i < j < prices.Length ==> max_profit >= prices[j] - prices[i]\n{\n    var min_price := 10001;\n    max_profit := 0;\n    var i := 0;\n    while (i < prices.Length)\ninvariant forall j :: 0 <= j < i ==> min_price <= prices[j]\n    {\n        var price := prices[i];\n        if (price < min_price)\n        {\n            min_price := price;\n        }\n        if (price - min_price > max_profit) {\n            max_profit := price - min_price;\n        }\n        i := i + 1;\n    }\n}",
            "success": false
        },
        "dafny_examples_tmp_tmp8qotd4ez_leetcode_0001-two-sum.dfy": {
            "state": "// If this invariant is added explicitly to the loop then the verfication never finishes.\n// It could be {:opaque} for a more controlled verification:\n// assert InMap([], m, target) by {\n//   reveal InMap();\n// }\npredicate InMap(nums: seq<int>, m: map<int, int>, t: int) {\n  forall j :: 0 <= j < |nums| ==> t - nums[j] in m\n}\nmethod TwoSum(nums: array<int>, target: int) returns (r: (int, int))\n  ensures 0 <= r.0 ==> 0 <= r.0 < r.1 < nums.Length && \n                       nums[r.0] + nums[r.1] == target &&\n                       forall i, j :: 0 <= i < j < r.1 ==> nums[i] + nums[j] != target\n  ensures r.0 == -1 <==> forall i, j :: 0 <= i < j < nums.Length ==> nums[i] + nums[j] != target\n{\n  var m: map<int, int> := map[];\n  var i := 0;\n  while i < nums.Length\ninvariant InMap(nums[..i], m, target) // Once this assertion is removed, the verification finishes quickly, and when this assertion is added, the verification never finishes.\n  {\n    if nums[i] in m {\n      return (m[nums[i]], i);\n    }\n    m := m[target - nums[i] := i];\n    i := i + 1;\n  }\n  return (-1, -1);\n}",
            "success": false
        },
        "CVS-Projto1_tmp_tmpb1o0bu8z_Hoare.dfy": {
            "state": "method Max (x: nat, y:nat) returns (r:nat)\n    ensures (r >= x && r >=y)\n    ensures (r == x || r == y)\n{\n    if (x >= y) { r := x;}\n    else { r := y;}\n}\nmethod Test ()\n{\n    var result := Max(42, 73);\n    assert result == 73;\n}\nmethod m1 (x: int, y: int) returns (z: int)\nrequires 0 < x < y\nensures z >= 0 && z <= y && z != x\n{\n    //assume 0 < x < y\n    z := 0;\n}\nfunction fib (n: nat) : nat\n{\n    if n == 0 then 1 else\n    if n == 1 then 1 else\n    fib(n -1) + fib (n-2)\n}\nmethod Fib (n: nat) returns (r:nat)\n    ensures r == fib(n)\n{\n    if (n == 0) {\n        return 1;\n    }\n    r := 1;\n    var next:=2;\n    var i := 1;\n    while i < n\n        invariant 1 <= i <= n\n        invariant r == fib(i)\n        invariant next == fib(i+1)\n    {\n        var tmp:=next;\n        next:= next + r;\n        r:= tmp;\n        i:= i + 1;\n    }\n    assert r == fib(n);\n    return r;\n}\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\nfunction add(l:List<int>) : int\n{\n    match l\n    case Nil => 0\n    case Cons(x, xs) => x + add(xs)\n}\nmethod addImp (l: List<int>) returns (s: int)\n    ensures s == add(l)\n{\n    var ll := l;\n    s := 0;\n    while ll != Nil\n        decreases ll\n        invariant add(l) == s + add(ll)\n        {\n            s := s + ll.head;\n            ll:= ll.tail;\n        }\n    assert s == add(l);\n}\nmethod MaxA (a: array<int>) returns (m: int)\n    requires a.Length > 0\n    ensures forall i :: 0 <= i < a.Length ==> a[i] <= m\n    ensures exists i :: 0 <= i < a.Length && a[i] == m\n{\n    m := a[0];\n    var i := 1;\n    while i< a.Length\ninvariant exists j :: 0 <= j < i && a[j] == m\n    {\n        if a[i] > m {\n            m:= a[i];\n        }\n        i := i +1;\n    }\n}",
            "success": false
        },
        "task_id_807.dfy": {
            "state": "predicate IsOdd(x: int)\n{\n    x % 2 != 0\n}\nmethod FindFirstOdd(a: array<int>) returns (found: bool, index: int)\n    requires a != null\n    ensures !found ==> forall i :: 0 <= i < a.Length ==> !IsOdd(a[i])\n    ensures found ==> 0 <= index < a.Length && IsOdd(a[index]) && forall i :: 0 <= i < index ==> !IsOdd(a[i])\n{\n    found := false;\n    index := 0;\n    while (index < a.Length)\ninvariant found ==> forall i :: 0 <= i < index ==> !IsOdd(a[i])\n    {\n        if IsOdd(a[index])\n        {\n            found := true;\n            return;\n        }\n        index := index + 1;\n    }\n}",
            "success": false
        },
        "min_array_strong.dfy": {
            "state": "method minArray(a: array<int>) returns (r:int)\n  requires a.Length > 0\n  ensures forall i :: 0 <= i < a.Length ==> r <= a[i]\n  ensures exists i :: 0 <= i < a.Length && r == a[i]\n{\n  r:=a[0];\n  var i:=1;\n  while i<a.Length\ninvariant exists j::0<=j<i&&r==a[j]\n  {\n    if r>a[i]{\n      r:=a[i];\n    }\n    i:=i+1;\n  }\n}",
            "success": false
        },
        "task_id_594.dfy": {
            "state": "predicate IsEven(n: int)\n{\n    n % 2 == 0\n}\npredicate IsOdd(n: int)\n{\n    n % 2 != 0\n}\nmethod FirstEvenOddDifference(a: array<int>) returns (diff: int)\n    requires a.Length >= 2\n    requires exists i :: 0 <= i < a.Length && IsEven(a[i])\n    requires exists i :: 0 <= i < a.Length && IsOdd(a[i])\n    ensures exists i, j :: 0 <= i < a.Length && 0 <= j < a.Length && IsEven(a[i]) && IsOdd(a[j]) && diff == a[i] - a[j] && \n        (forall k :: 0 <= k < i ==> IsOdd(a[k])) && (forall k :: 0 <= k < j ==> IsEven(a[k]))\n{\n    var firstEven: int := -1;\n    var firstOdd: int := -1;\n    for i := 0 to a.Length\n    {\n        if firstEven == -1 && IsEven(a[i])\n        {\n            firstEven := i;\n        }\n        if firstOdd == -1 && IsOdd(a[i])\n        {\n            firstOdd := i;\n        }\n        if firstEven != -1 && firstOdd != -1\n        {\n            break;\n        }\n    }\n    diff := a[firstEven] - a[firstOdd];\n}",
            "success": false
        },
        "dafny-duck_tmp_tmplawbgxjo_p1.dfy": {
            "state": "// Given an array of integers, it returns the sum. [1,3,3,2]->9\nfunction Sum(xs: seq<int>): int {\n    if |xs| == 0 then 0 else Sum(xs[..|xs|-1]) + xs[|xs|-1]\n}\nmethod SumArray(xs: array<int>) returns (s: int)\n    ensures s == Sum(xs[..])\n{\n    s := 0;\n    var i := 0;\n    while i < xs.Length\ninvariant s == Sum(xs[..i])\n    {\n        s := s + xs[i];\n        i := i + 1;\n    }\n}",
            "success": false
        },
        "laboratory_tmp_tmps8ws6mu2_dafny-tutorial_exercise11.dfy": {
            "state": "method m()\n{\n    var i, n := 0, 20;\n    while i != n\n    {\n        i := i + 1;\n    }\n}",
            "success": false
        },
        "task_id_554.dfy": {
            "state": "/**\n * Find odd numbers from an array of numbers\n **/\npredicate IsOdd(n: int)\n{\n    n % 2 == 1\n}\nmethod FindOddNumbers(arr: array<int>) returns (oddList: seq<int>)\n    // All numbers in the output are odd and exist in the input \n    ensures forall i :: 0 <= i < |oddList| ==> IsOdd(oddList[i]) && oddList[i] in arr[..]\n    // All odd numbers in the input are in the output\n    ensures forall i :: 0 <= i < arr.Length && IsOdd(arr[i]) ==> arr[i] in oddList\n{\n    oddList := [];\n    for i := 0 to arr.Length\ninvariant forall k :: 0 <= k < i && IsOdd(arr[k]) ==> arr[k] in oddList\n    {\n        if IsOdd(arr[i])\n        {\n            oddList := oddList + [arr[i]];\n        }\n    }\n}",
            "success": false
        },
        "Dafny-experiences_tmp_tmp150sm9qy_dafny_started_tutorial_dafny_tutorial_array.dfy": {
            "state": "method FindMax(a: array<int>) returns (i: int)\n  // Annotate this method with pre- and postconditions\n  // that ensure it behaves as described.\n  requires a.Length > 0\n  ensures 0<= i < a.Length\n  ensures forall k :: 0 <= k < a.Length ==> a[k] <= a[i]\n{\n  // Fill in the body that calculates the INDEX of the maximum.\n  i := 0;\n  var index := 1;\n  while index < a.Length\ninvariant forall k :: 0 <= k < index ==> a[k] <= a[i]\n  {\n    if a[index] > a[i] {i:= index;}\n    index := index + 1;\n  }\n}",
            "success": false
        },
        "Workshop_tmp_tmp0cu11bdq_Workshop_Answers_Question5.dfy": {
            "state": "method rev(a : array<int>)\n    requires a != null;\n    modifies a;\n    ensures forall k :: 0 <= k < a.Length ==> a[k] == old(a[(a.Length - 1) - k]);\n{\n    var i := 0;\n    while (i < a.Length - 1 - i)\ninvariant forall k :: a.Length / 2 - i <= k < a.Length / 2 + i ==> a[k] == old(a[a.Length - 1 - k]);\n    {\n        a[i], a[a.Length - 1 - i] := a[a.Length - 1 - i], a[i];\n        i := i + 1;\n    }\n}",
            "success": false
        },
        "Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_50_examples_28.dfy": {
            "state": "method main(x: int, y: int) returns (x_out: int, y_out: int, n: int)\nrequires x >= 0\nrequires y >= 0\nrequires x == y\nensures y_out == n\n{\n    x_out := x;\n    y_out := y;\n    n := 0;\n    while (x_out != n)\n    {\n        x_out := x_out - 1;\n        y_out := y_out - 1;\n    }\n}",
            "success": false
        },
        "dafny_tmp_tmp2ewu6s7x_ListReverse.dfy": {
            "state": "function reverse(xs: seq<nat>): seq<nat>\n{\n    if xs == [] then [] else reverse(xs[1..]) + [xs[0]]\n}\nlemma ReverseAppendDistr(xs: seq<nat>, ys: seq<nat>)\nensures reverse(xs + ys) == reverse(ys) + reverse(xs)\n{\n    if {\n        case xs == [] =>\n        calc {\nreverse(xs) + reverse(xs[1..]);\n            reverse([] + ys);\n            calc {\n                [] + ys;\n                ys;\n            }\n            reverse(ys);\n            reverse(ys) + reverse([]);\n        }\n        case xs != [] => {\n            var zs := xs + ys;\n        }\n    }\n}\nlemma ReverseInvolution(xxs: seq<nat>)\nensures reverse(reverse(xxs)) == xxs\n{\n    if {\n        case xxs == [] => {}\n        case xxs != [] => calc {\n            reverse(reverse(xxs));\n            ==\n            reverse(reverse(xxs[1..]) + [xxs[0]]);\n            ==\n            { ReverseAppendDistr(reverse(xxs[1..]), [xxs[0]]); }\n            reverse([xxs[0]]) + reverse(reverse(xxs[1..]));\n            ==\n            { ReverseInvolution(xxs[1..]); }\n            calc {\n                reverse([xxs[0]]);\n                ==\n                [] + [xxs[0]];\n                ==\n                [xxs[0]];\n            }\n            [xxs[0]] + xxs[1..];\n            ==\n            xxs;\n        }\n    }\n}",
            "success": false
        },
        "task_id_732.dfy": {
            "state": "predicate IsSpaceCommaDot(c: char)\n{\n    c == ' ' || c == ',' || c == '.'\n}\nmethod ReplaceWithColon(s: string) returns (v: string)\n    ensures |v| == |s|\n    ensures forall i :: 0 <= i < |s| ==> (IsSpaceCommaDot(s[i]) ==> v[i] == ':') && (!IsSpaceCommaDot(s[i]) ==> v[i] == s[i])\n{\n    var s' : string := [];\n    for i := 0 to |s|\ninvariant |s'| == i\n    {\n        if IsSpaceCommaDot(s[i])\n        {\n            s' := s' + [':'];\n        }\n        else \n        {\n            s' := s' + [s[i]];\n        }\n    }\n    return s';\n}",
            "success": false
        },
        "task_id_445.dfy": {
            "state": "method MultiplyElements(a: seq<int>, b: seq<int>) returns (result: seq<int>)\n    requires |a| == |b|\n    ensures |result| == |a|\n    ensures forall i :: 0 <= i < |result| ==> result[i] == a[i] * b[i]\n{\n    result := [];\n    var i := 0;\n    while i < |a|\ninvariant forall k :: 0 <= k < i ==> result[k] == a[k] * b[k]\n    {\n        result := result + [a[i] * b[i]];\n        i := i + 1;\n    }\n}",
            "success": false
        },
        "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_pregel algorithms_skeleton_nondet-permutation.dfy": {
            "state": "\ufeffmodule Permutation\n{\n\t/**\n\t * Given n >= 0, generate a permuation of {0,...,n-1} nondeterministically.\n\t */\n\tmethod Generate(n: int) returns (perm: array<int>)\n\t\trequires n >= 0\n\t\tensures perm != null\n\t\tensures perm.Length == n\n\t\tensures fresh(perm)\n\t\tensures isValid(perm, n)\n\t{\nassert isValid(perm, n);\n\t\tvar all := set x | 0 <= x < n;\n\t\tvar used := {};\n\t\tperm := new int[n];\n\t\tCardinalityLemma(n, all);\n\t\twhile used < all\n\t\t{\n\t\t\tCardinalityOrderingLemma(used, all);\n\t\t\tvar dst :| dst in all && dst !in used;\n\t\t\tperm[|used|] := dst;\n\t\t\tused := used + {dst};\n\t\t}\n\t\tprint perm;\n\t}\n\tpredicate isValid(a: array<int>, n: nat)\n\t\trequires a != null && a.Length == n\n\t\treads a\n\t{\n\t\tassume forall i | 0 <= i < n :: i in a[..];\n\t\tdistinct(a)\n\t\t&& (forall i | 0 <= i < a.Length :: 0 <= a[i] < n)\n\t\t&& (forall i | 0 <= i < n :: i in a[..])\n\t}\n\tpredicate distinct(a: array<int>)\n\t\trequires a != null\n\t\treads a\n\t{\n\t\tdistinct'(a, a.Length)\n\t}\n\tpredicate distinct'(a: array<int>, n: int)\n\t\trequires a != null\n\t\trequires a.Length >= n\n\t\treads a\n\t{\n\t\tforall i,j | 0 <= i < n && 0 <= j < n && i != j :: a[i] != a[j]\n\t}\n\tlemma CardinalityLemma (size: int, s: set<int>)\n\t\trequires size >= 0\n\t\trequires s == set x | 0 <= x < size\n\t\tensures\tsize == |s|\n\t{\n\t\tif(size == 0) {\n\t\t} else {\n\t\t\tCardinalityLemma(size - 1, s - {size - 1});\n\t\t}\n\t}\n\tlemma CardinalityOrderingLemma<T> (s1: set<T>, s2: set<T>)\n\t\trequires s1 < s2\n\t\tensures |s1| < |s2|\n\t{\n\t\tvar e :| e in s2 - s1;\n\t\tif s1 != s2 - {e} {\n\t\t\tCardinalityOrderingLemma(s1, s2 - {e});\n\t\t}\n\t}\n\tlemma SetDiffLemma<T> (s1: set<T>, s2: set<T>)\n\t\trequires s1 < s2\n\t\tensures s2 - s1 != {}\n\t{\n\t\tvar e :| e in s2 - s1;\n\t\tif s2 - s1 != {e} {} // What does Dafny prove here???\n\t}\n}",
            "success": false
        },
        "cs245-verification_tmp_tmp0h_nxhqp_quicksort-partition.dfy": {
            "state": "// Quicksort Partition -- Stephanie McIntyre\n// Based on examples in class \n// Parts have been modified cause you know, arrays are different...\nmethod QuicksortPartition(X: array<int>, n: int, p: int) returns (a: int, b: int)\nmodifies X;\n/*Pre-Condition*/   requires X.Length>=1 && n == X.Length;\n/*Post-Condition*/  ensures b>=n;\n                    ensures forall x:: 0<=x<a<n ==> X[x] <= p;\n                    ensures forall x:: a==n || (0<=a<=x<n ==> X[x] > p);\n                    ensures multiset(X[..])==multiset(old(X[..]))           //This says the new X is a permutation of our old version of X.\n{\n  a := 0;\n  while ( a < n && X[a] <= p ) \ninvariant forall x::a<=x<b<n ==> X[x]>p;\n  { \n    a := a+1;\n  }\n  b := a+1;\n  while ( b<n )\n  { \n    if ( X[b] <= p ) {\n      var t := X[b]; \n      X[b] := X[a]; \n      X[a] := t; \n      a := a+1;\n    }\n    b := b+1;\n  }\n}\n/* The annotations and implied proofs are left for you.\n   I might do them later on next week. */",
            "success": false
        },
        "ironsync-osdi2023_tmp_tmpx80antoe_linear-dafny_docs_DafnyRef_examples_Example-Old2.dfy": {
            "state": "class A {\n  var value: int\n  constructor ()\n     ensures value == 10\n  {\n     value := 10;\n  }\n}\nclass B {\n   var a: A\n   constructor () { a := new A(); }\n   method m()\n     requires a.value == 11\n     modifies this, this.a\n   {\n     label L:\n     a.value := 12;\n     label M:\n     a := new A(); // Line X\n     label N:\n     a.value := 20;\n     label P:\nassert a.value == 20; // Line Q\n                                // but .value in current state\n                                  // reference at Line X\n  }\n}",
            "success": true
        },
        "set_to_seq_strong.dfy": {
            "state": "method SetToSeq<T>(s: set<T>) returns (xs: seq<T>)\n  ensures multiset(s) == multiset(xs)\n{\n  xs := [];\n  var left: set<T> := s;\n  while left != {}\ninvariant multiset(left) + multiset(xs) == multiset(s)\n  {\n    var x :| x in left;\n    left := left - {x};\n    xs := xs + [x];\n  }\n}",
            "success": true
        },
        "task_id_106.dfy": {
            "state": "method AppendArrayToSeq(s: seq<int>, a: array<int>) returns (r: seq<int>)\n    requires a != null\n    ensures |r| == |s| + a.Length\n    ensures forall i :: 0 <= i < |s| ==> r[i] == s[i]\n    ensures forall i :: 0 <= i < a.Length ==> r[|s| + i] == a[i]\n{\n    r := s;\n    for i := 0 to a.Length\ninvariant forall j :: 0 <= j < i ==> r[|s| + j] == a[j]\n    {\n        r := r + [a[i]];\n    }\n}",
            "success": false
        },
        "task_id_474.dfy": {
            "state": "method ReplaceChars(s: string, oldChar: char, newChar: char) returns (v: string)\n    ensures |v| == |s|\n    ensures forall i :: 0 <= i < |s| ==> (s[i] == oldChar ==> v[i] == newChar) && (s[i] != oldChar ==> v[i] == s[i])\n{\n    var s' : string := [];\n    for i := 0 to |s|\ninvariant forall j :: 0 <= j < i ==> (s[j] == oldChar ==> s'[j] == newChar) && (s[j] != oldChar ==> s'[j] == s[j])\n    {\n        if s[i] == oldChar\n        {\n            s' := s' + [newChar];\n        }\n        else \n        {\n            s' := s' + [s[i]];\n        }\n    }\n    return s';\n}",
            "success": false
        },
        "dafny_examples_tmp_tmp8qotd4ez_lib_math_DivMod.dfy": {
            "state": "module DivMod {\n  function {:opaque} DivSub(a: int, b: int): int\n    requires 0 <= a && 0 < b\n  {\n    if a < b then 0 else 1 + DivSub(a - b, b)\n  }\n  function {:opaque} ModSub(a: int, b: int): int\n    requires 0 <= a && 0 < b\n  {\n    if a < b then a else ModSub(a - b, b)\n  }\n  lemma DivModAdd1(a: int, b: int)\n    requires b != 0\n    ensures (a + b) % b == a % b\n    ensures (a + b) / b == a / b + 1\n  {\n    var c := (a + b) / b - (a / b) - 1;\n  }\n  lemma DivModSub1(a: int, b: int)\n    requires b != 0\n    ensures (a - b) % b == a % b\n    ensures (a - b) / b == a / b - 1\n  {\n    var c := (a - b) / b - (a / b) + 1;\n  }\n  lemma ModEq(a: int, b: int)\n    requires 0 <= a && 0 < b\n    ensures a % b == ModSub(a, b)\n  {\n    reveal ModSub();\n    if a >= b {\n      DivModSub1(a, b);\n    }\n  }\n  lemma DivEq(a: int, b: int)\n    requires 0 <= a && 0 < b\n    ensures a / b == DivSub(a, b)\n  {\n    reveal DivSub();\n    if a >= b {\n      DivModSub1(a, b);\n    }\n  }\n  lemma DivModSpec'(a: int, b: int, q: int, r: int)\n    requires 0 <= a && 0 < b\n    requires 0 <= q && 0 <= r < b\n    requires a == q * b + r\n    ensures ModSub(a, b) == r\n    ensures DivSub(a, b) == q\n  {\n    reveal ModSub();\n    reveal DivSub();\n    if q > 0 {\n      DivModSpec'(a - b, b, q - 1, r);\n    }\n  }\n  lemma DivModSpec(a: int, b: int, q: int, r: int)\n    requires 0 <= a && 0 < b\n    requires 0 <= q && 0 <= r < b\n    requires a == q * b + r\n    ensures a % b == r\n    ensures a / b == q\n  {\n    ModEq(a, b);\n    DivEq(a, b);\n    DivModSpec'(a, b, q, r);\n  }\n  lemma DivMul(a: int, b: int)\n    requires 0 <= a && 0 < b\n    ensures a * b / b == a\n  {\n    DivModSpec(a * b, b, a, 0);\n  }\n  lemma DivModMulAdd(a: int, b: int, c: int)\n    requires 0 <= a && 0 <= c < b && 0 < b\n    ensures (a * b + c) / b == a\n    ensures (a * b + c) % b == c\n  {\n    DivModSpec(a * b + c, b, a, c);\n  }\n}",
            "success": false
        },
        "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic examples_sumto_sol.dfy": {
            "state": "function sum_up_to (n: nat): nat\n{\n  if (n == 0) then 0\n  else sum_up_to (n-1) + 1\n}\nmethod SumUpTo (n: nat) returns (r: nat)\n  ensures r == sum_up_to (n);\n{\n  var i := 0;\n  r := 0;\n  while (i < n)\n    invariant 0 <= i <= n;\n    invariant r == sum_up_to (i);\n  {\n    r := r + 1;\n    i := i + 1;\n  }\n}\nfunction total (a: seq<nat>) : nat\n{\n  if |a| == 0 then 0\n  else total (a[0..|a|-1]) + a[|a|-1]\n}\nlemma total_lemma (a: seq<nat>, i:nat) \n  requires |a| > 0;\n  requires 0 <= i < |a|;\n  ensures total (a[0..i]) + a[i] == total (a[0..i+1]);\n{\n  ghost var b := a[0..i+1];\n  calc\n  {\n    total (a[0..i+1]);\n    total (b);\n    total (b[0..|b|-1]) + b[|b|-1];\n    total (b[0..|b|-1]) + a[i];\n    {assert (b[0..|b|-1] == a[0..i]);}\n    total (a[0..i]) + a[i];\n  }\n}\nmethod Total (a: seq<nat>) returns (r:nat)\n  ensures r == total (a[0..|a|]); \n{\n  var i := 0;\n  r := 0;\n  while i < |a|\ninvariant r == total (a[0..i]);\n  { \n    total_lemma (a, i);\n    r := r + a[i];\n    i := i + 1;\n  }\n}",
            "success": false
        },
        "array_sum_strong.dfy": {
            "state": "method arraySum(a: array<int>, b: array<int>) returns (c: array<int> )\n  requires a.Length==b.Length\n  ensures c.Length==a.Length\n  ensures forall i:: 0 <= i< a.Length==> a[i] + b[i]==c[i]\n{\n  c:= new int[a.Length];\n  var i:=0;\n  while i<a.Length\n  {\n    c[i]:=a[i]+b[i];\n    i:=i+1;\n  }\n}",
            "success": false
        },
        "task_id_282.dfy": {
            "state": "method ElementWiseSubtraction(a: array<int>, b: array<int>) returns (result: array<int>)\n    requires a != null && b != null\n    requires a.Length == b.Length\n    ensures result != null\n    ensures result.Length == a.Length\n    ensures forall i :: 0 <= i < result.Length ==> result[i] == a[i] - b[i]\n{\n    result := new int[a.Length];\n    var i := 0;\n    while i < a.Length\n    {\n        result[i] := a[i] - b[i];\n        i := i + 1;\n    }\n}",
            "success": false
        },
        "task_id_2.dfy": {
            "state": "predicate InArray(a: array<int>, x: int)\n    reads a\n{\n    exists i :: 0 <= i < a.Length && a[i] == x\n}\nmethod SharedElements(a: array<int>, b: array<int>) returns (result: seq<int>)\n    // All elements in the output are in both a and b\n    ensures forall x :: x in result ==> (InArray(a, x) && InArray(b, x))\n    // The elements in the output are all different\n    ensures forall i, j :: 0 <= i < j < |result| ==> result[i] != result[j]\n{\n    var res: seq<int> := [];\n    for i := 0 to a.Length\ninvariant forall j, k :: 0 <= j < k < |res| ==> res[j] != res[k]\n    {\n        if InArray(b, a[i]) && a[i] !in res\n        {\n            res := res + [a[i]];\n        }\n    }\n    result := res;\n}",
            "success": false
        },
        "task_id_145.dfy": {
            "state": "method MaxDifference(a: array<int>) returns (diff: int)\n    requires a.Length > 1\n    ensures forall i, j :: 0 <= i < a.Length && 0 <= j < a.Length ==> a[i] - a[j] <= diff\n{\n    var minVal := a[0];\n    var maxVal := a[0];\n    for i := 1 to a.Length\ninvariant forall j :: 0 <= j < i ==> minVal <= a[j] && a[j] <= maxVal\n    {\n        if a[i] < minVal {\n            minVal := a[i];\n        } else if a[i] > maxVal {\n            maxVal := a[i];\n        }\n    }\n    diff := maxVal - minVal;\n}",
            "success": true
        },
        "Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseContained.dfy": {
            "state": "predicate strictSorted(s : seq<int>) {\n\tforall u, w :: 0 <= u < w < |s| ==> s[u] < s[w]\n}\nmethod mcontained(v:array<int>,w:array<int>,n:int,m:int) returns (b:bool)\n//Specify and implement an O(m+n) algorithm that returns b\n//v and w are strictly increasing ordered arrays\n//b is true iff the first n elements of v are contained in the first m elements of w\nrequires n<=m && n>=0\nrequires strictSorted(v[..])\nrequires strictSorted(w[..])\nrequires v.Length >= n && w.Length >= m\nensures b==forall k:: 0<= k< n ==> v[k] in w[..m]//exists j :: 0 <= j < m && v[k] == w[j]\n{\n\tvar i:=0;\n\tvar j:=0;\n\twhile(i<n && j<m && (v[i] >= w[j])) //&& b)\ninvariant i<=j\n\t{\t\n\t\tif(v[i] == w[j]){\n\t\t\ti:=i+1;\n\t\t}\n\t\tj:=j+1;\n\t}\n\tb := i==n;\n}",
            "success": false
        },
        "ironsync-osdi2023_tmp_tmpx80antoe_linear-dafny_docs_DafnyRef_examples_Example-Old.dfy": {
            "state": "class A {\n  var value: int\n  method m(i: int)\n    requires i == 6\n    requires value == 42\n    modifies this\n  {\n    var j: int := 17;\n    value := 43;\n    label L:\n    j := 18;\n    value := 44;\n    label M:\nassert(j + 1 == 19);\n    // value is this.value; 'this' is the same\n    // same reference in current and pre state but the\n    // values stored in the heap as its fields are different;\n    // '.value' evaluates to 42 in the pre-state, 43 at L,\n    // and 44 in the current state\n  }\n}",
            "success": true
        },
        "Dafny_Programs_tmp_tmp99966ew4_binary_search.dfy": {
            "state": "predicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n}\nmethod BinarySearch(a: array<int>, value: int) returns (index: int)\n   requires a != null && 0 <= a.Length && sorted(a)\n   ensures 0 <= index ==> index < a.Length && a[index] == value\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != value\n{\n   var low, high := 0, a.Length;\n   while low < high\n         0 <= i < a.Length && !(low <= i < high) ==> a[i] != value\n   {\n      var mid := (low + high) / 2;\n      if a[mid] < value\n      {\n         low := mid + 1;\n      }\n      else if value < a[mid]\n      {\n         high := mid;\n      }\n      else\n      {\n         return mid;\n      }\n   }\n   return -1;\n}",
            "success": false
        },
        "llm-verified-eval_tmp_tmpd2deqn_i_dafny_161.dfy": {
            "state": "function IsLetter(c: char): bool \n{\n  (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') \n}\nfunction NoLetters(s: string, n: nat): bool \n  requires n <= |s|\n{\n  forall c :: 0 <= c < n ==> !IsLetter(s[c])\n}\nfunction ToggleCase(c: char): char\n{\n  if c >= 'a' && c <= 'z' \n  then \n    (c - 'a' + 'A')\n  else if c >= 'A' && c <= 'Z' \n    then \n      (c - 'A' + 'a')\n    else \n      c\n}\nfunction isReverse(s: string, s_prime: string): bool{\n  (|s| == |s_prime|) &&\n  (forall si :: 0 <= si < |s|/2 ==> s_prime[|s| - si - 1] == s[si])\n}\nmethod Reverse(original: seq<char>) returns (reversed: seq<char>)\n  ensures |reversed| == |original| \n  ensures forall i :: 0 <= i < |original| ==> reversed[i] == original[|original| - 1 - i] \n{\n  reversed := []; \n  var i := |original|;\n  while i > 0\n    decreases i\n    invariant 0 <= i <= |original|\n    invariant  |reversed| == |original| - i\n    invariant forall j :: 0 <= j < |original|-i ==>\n    reversed[j] == original[|original| - 1 - j]\n  {\n    i := i - 1;\n    reversed := reversed + [original[i]]; \n  }\n}\nmethod solve(s: string) returns (result: string)\n  ensures |result| == |s| \n  ensures !NoLetters(s, |s|) ==> forall i :: 0 <= i < |s| && IsLetter(s[i]) ==> result[i] == ToggleCase(s[i])\n  ensures !NoLetters(s, |s|) ==> forall i :: 0 <= i < |s| && !IsLetter(s[i]) ==> result[i] == s[i] \n  ensures NoLetters(s, |s|) ==> isReverse(result, s) \n{\n    var flg : bool := false;\n    result := \"\";\n    for i := 0 to |s|\n    {\n      if IsLetter(s[i])\n      {\n        result := result + [ToggleCase(s[i])];\n        flg := true;\n      } else {\n        result := result + [s[i]];\n      }\n    }\n    if !flg\n    {\n      result := Reverse(s);\n    }\n}",
            "success": false
        },
        "Dafny_Verify_tmp_tmphq7j0row_dataset_C_convert_examples_15.dfy": {
            "state": "method main(n: int, k: int) returns (k_out: int)\n    requires n > 0;\n\trequires k > n;\n\tensures k_out >= 0;\n{\n\tk_out := k;\n    var j: int := 0;\n    while(j < n)\ninvariant 0 <= j <= n\n    {\n        j := j + 1;\n        k_out := k_out - 1;\n    }\n}\n// C code:\n// MODULE main\n// \tint i;\n// \tint n;\n// \tint j;\n// \tint k;\n// \tassume(n > 0);\n// \tassume(k > n);\n// \tassume(j == 0);\n// \twhile(j < n){\n// \t\tj = j + 1;\n// \t\tk = k - 1;\n// \t}\n// \tassert(k >= 0);\t\n// END MODULE\n// Invariant\n// (\n    // not (or (<= 1 (+ n (+ (* (- 1) j) (* (- 1) k)))) (\n    //     and (<= k (- 1)) (<= (+ n (* (- 1) j)) (- 1)))))",
            "success": false
        },
        "Dafny_Verify_tmp_tmphq7j0row_Generated_Code_Mult.dfy_1.dfy": {
            "state": "method mult(a:int, b:int) returns (x:int)\n  \trequires a >= 0 && b >= 0\n  \tensures x == a * b\n{\n  \tx := 0;\n\tvar y := a;\n  \twhile y > 0\ndecreases y\n\t{\n\t\tx := x + b;\n\t\ty := y - 1;\n\t}\n}",
            "success": false
        },
        "Dafny_Verify_tmp_tmphq7j0row_Generated_Code_ComputePower.dfy_3.dfy": {
            "state": "function Power(n: nat): nat {\n    if n == 0 then 1 else 2 * Power(n - 1)\n}\nmethod ComputePower(n: nat) returns (p: nat)\n    ensures p == Power(n)\n{\n    p := 1;\n    var i := 0;\nassert p == Power(i);\n    while i != n\n    {\n        i := i + 1;\n        p := p * 2;\n    }\n}",
            "success": false
        },
        "Dafny_tmp_tmpv_d3qi10_3_cumsum.dfy": {
            "state": "function sum(a: array<int>, i: int): int\n    requires 0 <= i < a.Length\n    reads a\n{\n    a[i] + if i == 0 then 0 else sum(a, i - 1)\n}\nmethod cumsum(a: array<int>, b: array<int>)\n    requires  a.Length == b.Length && a.Length > 0 && a != b\n    // when you change a  , that's not the same object than b . \n    //requires b.Length > 0 \n    ensures forall i | 0 <= i < a.Length :: b[i] == sum(a, i)\n    modifies b\n{\n    b[0] := a[0]; // Initialise le premier \u00e9l\u00e9ment de b\n    var i := 1;\n    while i < a.Length\n    {\n        b[i] := b[i - 1] + a[i]; // Calcule la somme cumul\u00e9e pour chaque \u00e9l\u00e9ment\n        i := i + 1;\n    }\n}",
            "success": false
        },
        "task_id_412.dfy": {
            "state": "/**\n * Remove odd numbers from an array of numbers\n **/\npredicate IsEven(n: int)\n{\n    n % 2 == 0\n}\nmethod RemoveOddNumbers(arr: array<int>) returns (evenList: seq<int>)\n    // All numbers in the output are even and exist in the input \n    ensures forall i :: 0 <= i < |evenList| ==> IsEven(evenList[i]) && evenList[i] in arr[..]\n    // All even numbers in the input are in the output\n    ensures forall i :: 0 <= i < arr.Length && IsEven(arr[i]) ==> arr[i] in evenList\n{\n    evenList := [];\n    for i := 0 to arr.Length\ninvariant forall k :: 0 <= k < i && IsEven(arr[k]) ==> arr[k] in evenList\n    {\n        if IsEven(arr[i])\n        {\n            evenList := evenList + [arr[i]];\n        }\n    }\n}",
            "success": false
        },
        "task_id_603.dfy": {
            "state": "method LucidNumbers(n: int) returns (lucid: seq<int>)\n    requires n >= 0\n    ensures forall i :: 0 <= i < |lucid| ==> lucid[i] % 3 == 0\n    ensures forall i :: 0 <= i < |lucid| ==> lucid[i] <= n\n    ensures forall i, j :: 0 <= i < j < |lucid| ==> lucid[i] < lucid[j]\n{\n    lucid := [];\n    var i := 0;\n    while i <= n\ninvariant forall i, j :: 0 <= i < j < |lucid| ==> lucid[i] < lucid[j]\n    {\n        if i % 3 == 0 {\n            lucid := lucid + [i];\n        }\n        i := i + 1;\n    }\n}",
            "success": false
        },
        "sat_dfy_tmp_tmpfcyj8am9_dfy_Seq.dfy": {
            "state": "module Seq {\n    function seq_sum(s: seq<int>) : (sum: int)\n    {\n        if s == [] then\n            0\n        else\n            var x := s[0];\n            var remaining := s[1..];\n            x + seq_sum(remaining)\n    }\n    lemma SeqPartsSameSum(s: seq<int>, s1: seq<int>, s2: seq<int>)\n        requires s == s1 + s2\n        ensures seq_sum(s) == seq_sum(s1) + seq_sum(s2)\n    {\n        if s == [] {\n        } else if s1 == [] {\n        } else {\n            var x := s1[0];\n            var s1' := s1[1..];\n            SeqPartsSameSum(s[1..], s1[1..], s2);\n        }\n    }\n    lemma DifferentPermutationSameSum(s1: seq<int>, s2: seq<int>)\n        requires multiset(s1) == multiset(s2)\n        ensures seq_sum(s1) == seq_sum(s2)\n    {\n        if s1 == [] {\n        } else {\n            var x :| x in s1;\n            var i1, i2 :| 0 <= i1 < |s1| && 0 <= i2 < |s2| && s1[i1] == s2[i2] && s1[i1] == x;\nassert s1[..i1] == s1[..i1+1][1..];\n            var remaining1 := s1[..i1] + s1[i1+1..];\n            SeqPartsSameSum(s1[..i1+1], s1[..i1], [x]);\n            SeqPartsSameSum(s1, s1[..i1+1], s1[i1+1..]);\n            SeqPartsSameSum(remaining1, s1[..i1], s1[i1+1..]);\n            var remaining2 := s2[..i2] + s2[i2+1..];\n            SeqPartsSameSum(s2[..i2+1], s2[..i2], [x]);\n            SeqPartsSameSum(s2, s2[..i2+1], s2[i2+1..]);\n            SeqPartsSameSum(remaining2, s2[..i2], s2[i2+1..]);\n            DifferentPermutationSameSum(remaining1, remaining2);\n        }\n    }\n}",
            "success": false
        },
        "online_max_strong.dfy": {
            "state": "method onlineMax(a: array<int>, x: int) returns (ghost m:int, p:int)\n  requires 1<=x<a.Length\n  requires a.Length!=0\n  ensures x<=p<a.Length\n  ensures forall i::0<=i<x==> a[i]<=m\n  ensures exists i::0<=i<x && a[i]==m\n  ensures x<=p<a.Length-1 ==> (forall i::0<=i<p ==> a[i]<a[p])\n  ensures (forall i::x<=i<a.Length && a[i]<=m) ==> p==a.Length-1\n{\n  p:= 0;\n  var best := a[0];\n  var i:=1;\n  while i<x\ninvariant (forall j::x<=j<p ==> a[j]<best)\n  {\n    if a[i]>best{\n      best:=a[i];\n    }\n    i:=i+1;\n  }\n  m:=best;\n  i:=x;\n  while i<a.Length\n  {\n    if a[i]>best{\n      p:=i;\n      return;\n    }\n    i:=i+1;\n  }\n  p:=a.Length-1;\n}",
            "success": false
        },
        "cs245-verification_tmp_tmp0h_nxhqp_SortingIssues_FirstAttempt.dfy": {
            "state": "// Sorting: \n//        Pre/Post Condition Issues - An investigation \n//                                      -- Stephanie McIntyre\n// Based on examples in class \n// First Attempt at specifying requirements for sorting array A in incrementing order\n// We want our Hoare triple of (|Pre-Condition|) Code (|Post-Condition|) to hold iff A is properly sorted.\nmethod sort(A: array<int>, n: int)\nmodifies A; requires n==A.Length;\n/* Pre-Condition */   requires n>=0;            \n/* Post-Condition */  ensures forall i,j:: 0<=i<=j<n ==> A[i]<=A[j];  //This states that A is sorted.\n//Can we write code that does not sort A that still satisfies the requirements? \n//Consider the following program:\n{\nassert forall i,j::0<=i<=j<n ==> A[i]<=A[j];\n  var k := 0;\n  while(k<n)\n  {\n    A[k] := k;\n    k := k+1;\n  }\n}",
            "success": false
        },
        "Dafny_Verify_tmp_tmphq7j0row_AI_agent_verify_examples_ComputePower.dfy": {
            "state": "function Power(n: nat): nat {\n    if n == 0 then 1 else 2 * Power(n - 1)\n}\nmethod ComputePower(N: int) returns (y: nat) requires N >= 0\n    ensures y == Power(N)\n{\n    y := 1;\n    var x := 0; \n    while x != N\ndecreases N - x\n    {\n        x, y := x + 1, y + y;\n    } \n}",
            "success": false
        },
        "dafny-language-server_tmp_tmpkir0kenl_Test_hofs_Requires.dfy": {
            "state": "// RUN: %dafny /compile:3 /print:\"%t.print\" /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\nmethod Main()\n{\n  test0(10);\n\ttest5(11);\n\ttest6(12);\n\ttest1();\n\ttest2();\n}\npredicate valid(x:int)\n{\n  x > 0\n}\nfunction ref1(y:int) : int\n  requires valid(y);\n{\n  y - 1\n}\nlemma assumption1()\n  ensures forall a, b :: valid(a) && valid(b) && ref1(a) == ref1(b) ==> a == b;\n{\n}\nmethod test0(a: int)\n{\n  if ref1.requires(a) {\n    // the precondition should suffice to let us call the method\n    ghost var b := ref1(a);\n  }\n}\nmethod test5(a: int)\n{\n  if valid(a) {\n    // valid(a) is the precondition of ref1\n    assert ref1.requires(a);\n  }\n}\nmethod test6(a: int)\n{\n  if ref1.requires(a) {\n    // the precondition of ref1 is valid(a)\n    assert valid(a);\n  }\n}\nmethod test1()\n{\n  if * {\n    assert forall a, b :: valid(a) && valid(b) && ref1(a) == ref1(b) ==> a == b;\n  } else {\n    assert forall a, b :: ref1.requires(a) && ref1.requires(b) && ref1(a) == ref1(b)\n                          ==> a == b;\n  }\n}\nfunction {:opaque} ref2(y:int) : int        // Now with an opaque attribute\n  requires valid(y);\n{\n  y - 1\n}\nlemma assumption2()\n  ensures forall a, b :: valid(a) && valid(b) && ref2(a) == ref2(b) ==> a == b;\n{\n  reveal ref2();\n}\nmethod test2()\n{\n  assumption2();\n  if * {\n  } else {\n                          ==> a == b;\n  }\n}",
            "success": false
        },
        "Dafny-Exercises_tmp_tmpjm75muf__Session6Exercises_ExerciseCountMin.dfy": {
            "state": "function min(v:array<int>,i:int):int\ndecreases i\n reads v\n requires 1<=i<=v.Length\n ensures forall k::0<=k<i==> v[k]>=min(v,i)\n {if (i==1) then v[0]\n  else if (v[i-1]<=min(v,i-1)) then v[i-1]\n  else min(v,i-1)\n  }\nfunction countMin(v:array<int>,x:int, i:int):int\ndecreases i\n reads v\n  requires 0<=i<=v.Length\n  ensures !(x in v[0..i]) ==> countMin(v,x,i)==0\n  {\n   if (i==0) then 0\n   else if (v[i-1]==x) then 1+countMin(v,x,i-1)\n   else countMin(v,x,i-1)\n  }\n method mCountMin(v:array<int>) returns (c:int)\nrequires v.Length>0\nensures c==countMin(v,min(v,v.Length),v.Length)\n//Implement and verify an O(v.Length) algorithm \n{\n  var i:=1;\n  c:=1;\n  var mini:=v[0];\n  while(i<v.Length)\ninvariant mini==min(v,i) && c == countMin(v,mini,i)\n  {\n    if(v[i]==mini){\n      c:=c + 1;\n    }\n    else if(v[i]<mini){\n      c:=1;\n      mini:=v[i];\n    }\n    i:=i+1;\n  }\n}",
            "success": false
        },
        "Prog-Fun-Solutions_tmp_tmp7_gmnz5f_mockExam2_p5.dfy": {
            "state": "// problem 5:\n// name:      Gabriele Berardi\n// s-number: s4878728\n// table:     XXXX\nghost function f(n: int): int {\n  if n < 0 then 0 else 3*f(n-5) + n\n}\nmethod problem5(n:nat) returns (x: int)\nensures x == f(n)\n{\n    var a := 1;\n    var b := 0;\n    var k := n;\n    while k >= 0\n    {\n        b := a*k + b;\n        a := 3*a;\n        k := k - 5;\n    }\n    x := b;\n}",
            "success": false
        },
        "task_id_18.dfy": {
            "state": "method RemoveChars(s1: string, s2: string) returns (v: string)\n    ensures |v| <= |s1|\n    ensures forall i :: 0 <= i < |v| ==> (v[i] in s1) && !(v[i] in s2)\n    ensures forall i :: 0 <= i < |s1| ==> (s1[i] in s2) || (s1[i] in v)\n{\n    var v' : string := [];\n    for i := 0 to |s1|\ninvariant forall i :: 0 <= i <= i - 1 + |v'| ==> (s1[i] in s2) || (s1[i] in v')\n    {\n        if !(s1[i] in s2)\n        {\n            v' := v' + [s1[i]];\n        }\n    }\n    return v';\n}",
            "success": false
        },
        "specTesting_tmp_tmpueam35lx_examples_sort_sort.dfy": {
            "state": "method quickSort(intSeq:array<int>)\n    modifies intSeq\n    ensures forall i:nat, j:nat | 0 <= i <= j < intSeq.Length :: intSeq[i] <= intSeq[j]\n    // ensures multiset(intSeq[..]) == multiset(old(intSeq[..]))\nlemma sort(prevSeq:seq<int>) returns (curSeq:seq<int>)\n    ensures (forall i:nat, j:nat | 0 <= i <= j < |curSeq| :: curSeq[i] <= curSeq[j])\n    ensures multiset(prevSeq) == multiset(curSeq)\npredicate post_sort(prevSeq:seq<int>, curSeq:seq<int>)\n{\n    && (forall i:nat, j:nat | 0 <= i <= j < |curSeq| :: curSeq[i] <= curSeq[j])\n    && multiset(prevSeq) == multiset(curSeq)\n}\nlemma multisetAdditivity(m1:multiset<int>, m2:multiset<int>, m3:multiset<int>, m4:multiset<int>)\n    requires m1 == m2 + m3\n    requires m1 == m2 + m4\n    ensures m3 == m4\n    {\n    }\nlemma twoSortedSequencesWithSameElementsAreEqual(s1:seq<int>, s2:seq<int>)\n    requires (forall i:nat, j:nat | 0 <= i <= j < |s1| :: s1[i] <= s1[j])\n    requires (forall i:nat, j:nat | 0 <= i <= j < |s2| :: s2[i] <= s2[j])\n    requires multiset(s1) == multiset(s2)\n    requires |s1| == |s2|\n    ensures s1 == s2\n{\n    if (|s1| != 0) {\n        if s1[|s1|-1] == s2[|s2|-1] {\n            multisetAdditivity(multiset(s1), multiset([s1[|s1|-1]]), multiset(s1[..|s1|-1]), multiset(s2[..|s1|-1]));\n        }\n        twoSortedSequencesWithSameElementsAreEqual(s1[..|s1|-1], s2[..|s2|-1]);\n        } else if s1[|s1|-1] < s2[|s2|-1] {\n        } else {\n        }\n    }\n}\nlemma sort_determinisitc(prevSeq:seq<int>, curSeq:seq<int>, curSeq':seq<int>)\n    requires post_sort(prevSeq, curSeq)\n    requires post_sort(prevSeq, curSeq')\n    ensures curSeq == curSeq'\n{\n    if (|curSeq| != |curSeq'|) {\n    } else {\n        twoSortedSequencesWithSameElementsAreEqual(curSeq, curSeq');\n    }\n}\nlemma sort_determinisitc1(prevSeq:seq<int>, curSeq:seq<int>, curSeq':seq<int>)\n    requires prevSeq == [5,4,3,2,1]\n    requires post_sort(prevSeq, curSeq)\n    requires post_sort(prevSeq, curSeq')\n    ensures curSeq == curSeq'\n{\n}",
            "success": false
        },
        "reverse_strong.dfy": {
            "state": "method reverse(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[a.Length - 1 - i])\n{\n  var i := 0;\n  while i <a.Length / 2\ndecreases a.Length - i\n  {\n    a[i], a[a.Length-1-i] := a[a.Length-1-i], a[i];\n    i := i + 1;\n  }\n}",
            "success": false
        },
        "task_id_94.dfy": {
            "state": "method MinSecondValueFirst(s: array<seq<int>>) returns (firstOfMinSecond: int)\n    requires s.Length > 0\n    requires forall i :: 0 <= i < s.Length ==> |s[i]| >= 2\n    ensures exists i :: 0 <= i < s.Length && firstOfMinSecond == s[i][0] && \n        (forall j :: 0 <= j < s.Length ==> s[i][1] <= s[j][1])\n{\n    var minSecondIndex := 0;\n    for i := 1 to s.Length\n    {\n        if s[i][1] < s[minSecondIndex][1]\n        {\n            minSecondIndex := i;\n        }\n    }\n    firstOfMinSecond := s[minSecondIndex][0];\n}",
            "success": false
        },
        "task_id_113.dfy": {
            "state": "predicate IsDigit(c: char)\n{\n    48 <= c as int <= 57\n}\nmethod IsInteger(s: string) returns (result: bool)\n    ensures result <==> (|s| > 0) && (forall i :: 0 <= i < |s| ==> IsDigit(s[i]))\n{\n    result := true;\n    if |s| == 0 {\n        result := false;\n    } else {\n        for i := 0 to |s|\ninvariant (forall j :: 0 <= j < i ==> IsDigit(s[j]))\n        {\n            if !IsDigit(s[i]) {\n                result := false;\n                break;\n            }\n        }\n    }\n}",
            "success": true
        },
        "Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Exercise4_Find_Max.dfy": {
            "state": "method findMax(a:array<int>) returns (pos:int, maxVal: int)\n  requires a.Length > 0;\n  requires forall i :: 0 <= i < a.Length ==> a[i] >= 0;\n  ensures forall i :: 0 <= i < a.Length ==> a[i] <= maxVal;\n  ensures exists i :: 0 <= i < a.Length &&  a[i] == maxVal;\n  ensures 0 <= pos < a.Length\n  ensures a[pos] == maxVal;\n{\n  pos := 0;\n  maxVal := a[0];\n  var j := 1;\n  while(j < a.Length)\ninvariant 0 <= j <= a.Length\n  {\n    if (a[j] > maxVal) \n    {\n      maxVal := a[j];\n      pos := j;\n    }\n    j := j+1;\n  }\n  return;\n}",
            "success": false
        },
        "task_id_759.dfy": {
            "state": "method IsDecimalWithTwoPrecision(s: string) returns (result: bool)\n    ensures result ==> (exists i :: 0 <= i < |s| && s[i] == '.' && |s| - i - 1 == 2)\n    ensures !result ==> !(exists i :: 0 <= i < |s| && s[i] == '.' && |s| - i - 1 == 2)\n{\n    result := false;\n    for i := 0 to |s|\n    {\n        if s[i] == '.' && |s| - i - 1 == 2 {\n            result := true;\n            break;\n        }\n    }\n}",
            "success": false
        },
        "Dafny_tmp_tmpmvs2dmry_pancakesort_flip.dfy": {
            "state": "// flips (i.e., reverses) array elements in the range [0..num]\nmethod flip (a: array<int>, num: int)\nrequires a.Length > 0;\nrequires 0 <= num < a.Length;\nmodifies a;\nensures forall k :: 0 <= k <= num ==> a[k] == old(a[num-k])\nensures forall k :: num < k < a.Length ==> a[k] == old(a[k])\n// ensures multiset(a[..]) == old(multiset(a[..]))\n{\n  var tmp:int;\n  var i := 0;\n  var j := num;\n  while (i < j)\ninvariant forall k :: i <= k < j ==> a[k] == old(a[k])\n  // invariant 0 <= i < j <= num\n  {\n    tmp := a[i];\n    a[i] := a[j];\n    a[j] := tmp;\n    i := i + 1;\n    j := j - 1;\n  }\n}",
            "success": false
        },
        "is_palindrome_strong.dfy": {
            "state": "method IsPalindrome(x: seq<char>) returns (result: bool)\n  ensures result <==> (forall i :: 0 <= i < |x| ==> x[i] == x[|x| - i - 1])\n{\n  if |x|==0 {\n    return true;\n  }\n  var i := 0;\n  var j := |x| - 1;\n  result := true;\n  while (i < j)\ninvariant result <==> (forall s :: 0 <= s < i ==> x[s] == x[|x| - s - 1])\n  {\n    if x[i] != x[j] {\n      result := false;\n      return;\n    }\n    i := i + 1;\n    j := j - 1;\n  }\n}",
            "success": false
        },
        "Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExercisePositive.dfy": {
            "state": "predicate positive(s:seq<int>)\n{forall u::0<=u<|s| ==> s[u]>=0}\nmethod mpositive(v:array<int>) returns (b:bool)\nensures b==positive(v[0..v.Length])\n{\n    var i:=0;\n    //1. assert positive(v[..0])\n    while i<v.Length && v[i]>=0\n        decreases v.Length - i \n        invariant 0<=i<=v.Length\n        invariant positive(v[..i])\n    {\n        //2. assert 0<=i<v.Length && positive(v[..i]);\n        i:=i+1;\n        //2. assert 0<=i<v.Length && positive(v[..i]);\n    }\n    //3. assert i==v.Length ==> positive(v[..]);\n    //3. assert i<v.Length => v[i]<0;\n    b := i==v.Length;\n}\nmethod mpositive3(v:array<int>) returns (b:bool)\nensures b==positive(v[0..v.Length])\n{\n    var i:=0; b:=true;\n    while(i<v.Length && b)\n        decreases v.Length - i \n        invariant 0 <= i <= v.Length\n        invariant b==positive(v[0..i])\n        invariant !b ==> !positive(v[0..v.Length])\n    {\n        b:=v[i]>=0;\n        i:=i+1;\n    }\n}\nmethod mpositive4(v:array<int>) returns (b:bool)\nensures b==positive(v[0..v.Length])\n{\n    var i:=0; b:=true;\n    while(i<v.Length && b)\n        decreases v.Length - i \n        invariant 0 <= i <= v.Length\n        invariant b==positive(v[0..i])\n        invariant !b ==> !positive(v[0..v.Length])\n    {\n        b:=v[i]>=0;\n        i:=i+1;\n    }\n}\nmethod mpositivertl(v:array<int>) returns (b:bool)\nensures b==positive(v[0..v.Length])\n{\n    var i:=v.Length-1;\n    while(i>=0 && v[i]>=0)\ndecreases i\n    {\n        i:=i-1;\n    }\n    b:= i==-1;\n}",
            "success": false
        },
        "task_id_579.dfy": {
            "state": "predicate InArray(a: array<int>, x: int)\n    reads a\n{\n    exists i :: 0 <= i < a.Length && a[i] == x\n}\nmethod DissimilarElements(a: array<int>, b: array<int>) returns (result: seq<int>)\n    // All elements in the output are either in a or b, but not in both or neither\n    ensures forall x :: x in result ==> (InArray(a, x) != InArray(b, x))\n    // The elements in the output are all different\n    ensures forall i, j :: 0 <= i < j < |result| ==> result[i] != result[j]\n{\n    var res: seq<int> := [];\n    for i := 0 to a.Length\n    {\n        if !InArray(b, a[i]) && a[i] !in res\n        {\n            res := res + [a[i]];\n        }\n    }\n    ghost var partialSize := |res|;\nassert partialSize == |res|;\n    for i := 0 to b.Length\n    {\n        if !InArray(a, b[i]) && b[i] !in res\n        {\n            res := res + [b[i]];\n        }\n    }\n    result := res;\n}",
            "success": false
        },
        "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_vampire project_original_Searching.dfy": {
            "state": "// Assuming Array is Object Blood\n// Blood Array<int>\n// index\nmethod Find(blood: array<int>, key: int) returns (index: int)\nrequires blood != null\nensures 0 <= index ==> index < blood.Length && blood[index] == key\nensures index < 0 ==> forall k :: 0 <= k < blood.Length ==> blood[k] != key\n{\n   index := 0;\n   while index < blood.Length\ndecreases blood.Length - index\n   {\n      if blood[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n}",
            "success": false
        },
        "Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_normal_data_completion_MaxPerdV2.dfy": {
            "state": "function contains(v: int, a: array<int>, n: int): bool\nreads a\n  requires n <= a.Length\n{\n  exists j :: 0 <= j < n && a[j] == v\n}\nfunction upper_bound(v: int, a: array<int>, n: int): bool\nreads a\n  requires n <= a.Length\n{\n  forall j :: 0 <= j < n ==> a[j] <= v\n}\nfunction is_max(m: int, a: array<int>, n: int): bool\nreads a\n  requires n <= a.Length\n{\n  contains(m, a, n) && upper_bound(m, a, n)\n}\nmethod max(a: array<int>, n: int) returns (max: int)\n  requires 0 < n <= a.Length;\n  ensures is_max(max, a, n);\n{\n  var i: int := 1;\n  max := a[0];\n  while i < n\ninvariant is_max(max, a, i)\n  {\n    if a[i] > max {\n      max := a[i];\n    }\n    i := i + 1;\n  }\n}",
            "success": false
        },
        "count_lessthan_strong.dfy": {
            "state": "method CountLessThan(numbers: set<int>, threshold: int) returns (count: int)\n  ensures count == |set i | i in numbers && i < threshold|\n{\n  count := 0;\n  var shrink := numbers;\n  var grow := {};\n  while |shrink | > 0\n  {\n    var i: int :| i in shrink;\n    shrink := shrink - {i};\n    var grow' := grow+{i};\n           (set i | i in grow && i < threshold )+ if i < threshold then {i} else {};\n    grow := grow + {i};\n    if i < threshold {\n      count := count + 1;\n    }\n  }\n}",
            "success": false
        },
        "Metodos_Formais_tmp_tmpql2hwcsh_Invariantes_multiplicador.dfy": {
            "state": "// Exemplo de invariantes\n// Invariante significa que o valor n\u00e3o muda desde a pr\u00e9-condi\u00e7\u00e3o at\u00e9 a p\u00f3s-condi\u00e7\u00e3o\nmethod Mult(x:nat, y:nat) returns (r:nat)\nensures r == x * y\n{\n    // par\u00e2metros de entrada s\u00e3o imut\u00e1veis, por isso\n    // \u00e9 preciso a atribuir a vari\u00e1veis locais para usar em blocos de c\u00f3digos para mudar\n    var m := x;\n    var n := y;\nassert  n == 3;\n    r := 0;\n    while m > 0 \n    {\n        r := r + n;\n        m := m -1;\n    }\n    return r;\n}\n// Teste do m\u00e9todo para encontrar a invariante\n// x | y | m | n | r\n// 5 | 3 | 5 | 3 | 0\n// 5 | 3 | 4 | 3 | 3\n// 5 | 3 | 3 | 3 | 6\n// 5 | 3 | 2 | 3 | 9\n// 5 | 3 | 1 | 3 | 12\n// 5 | 3 | 0 | 3 | 15\n// vimos o seguinte:\n// m * n + r = x * y\n// 5 * 3 + 0 (15) = 5 * 3 (15)\n// portanto a f\u00f3rmula m*n+r == x*y \u00e9 uma invariante\n// mas s\u00f3 isso n\u00e3o serve, o m ele \u00e9 maior ou igual a zero quando acaba o while\n// por isso, tamb\u00e9m \u00e9 a invariante que necessita\n// com isso dizemos para o programa as altera\u00e7\u00f5es do m de maior ou igual a zero\n// e mostramos a fun\u00e7\u00e3o encontrada que alterava o valor de m e n das variaveis criadas\n// SE OS ALGORITMOS TIVEREM REPETI\u00c7\u00c3O OU RECURS\u00c3O, DEVEM SER MOSTRADOS QUAIS S\u00c3O AS INVARIANTES\n// OU SEJA, OS VALORES QUE N\u00c3O EST\u00c3O SENDO MUDADOS E COLOCAR A F\u00d3RMULA DELE COMO ACIMA",
            "success": false
        },
        "t1_MF_tmp_tmpi_sqie4j_exemplos_introducao_ex4.dfy": {
            "state": "function Fat(n: nat): nat\n{\n   if n == 0 then 1 else n * Fat(n-1)\n}\nmethod Fatorial(n:nat)  returns (r:nat)\n  ensures r == Fat(n)\n{\n    r := 1;\n    var i := 0;\nassert 0 <= i <= n && 1 <= r <= Fat(n);\n    while i < n\n    {\n        i := i + 1;\n        r := r * i;\n    }\n}",
            "success": false
        },
        "HATRA-2022-Paper_tmp_tmp5texxy8l_copilot_verification_Two Sum_two_sum.dfy": {
            "state": "method twoSum(nums: array<int>, target: int) returns (index1: int, index2: int)\n    requires 2 <= nums.Length\n    requires exists i, j :: (0 <= i < j < nums.Length && nums[i] + nums[j] == target)\n    ensures index1 != index2\n    ensures 0 <= index1 < nums.Length\n    ensures 0 <= index2 < nums.Length\n    ensures nums[index1] + nums[index2] == target\n{\n    var i := 0;\n    while i < nums.Length\n    {\n        var j := i + 1;\n        while j < nums.Length\ninvariant exists k :: i <= k < nums.Length && nums[i] + nums[k] == target\n        {\n            if nums[i] + nums[j] == target\n            {\n                return i, j;\n            } \n            j := j + 1;\n        }\n        i := i + 1;\n    }\n}",
            "success": false
        },
        "task_id_793.dfy": {
            "state": "method LastPosition(arr: array<int>, elem: int) returns (pos: int)\n    requires arr.Length > 0\n    requires forall i, j :: 0 <= i < j < arr.Length ==> arr[i] <= arr[j]\n    ensures pos == -1 || (0 <= pos < arr.Length && arr[pos] == elem && (pos <= arr.Length - 1 || arr[pos + 1] > elem))\n    ensures forall i :: 0 <= i < arr.Length ==> arr[i] == old(arr[i])\n{\n    pos := -1;\n    for i := 0 to arr.Length - 1\ninvariant pos == -1 || (0 <= pos < arr.Length && arr[pos] == elem && (pos <= i || arr[i] > elem))\n    {\n        if arr[i] == elem\n        {\n            pos := i;\n        }\n    }\n}",
            "success": true
        },
        "dafny-language-server_tmp_tmpkir0kenl_Test_vstte2012_Two-Way-Sort.dfy": {
            "state": "// RUN: %dafny /compile:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n// This method is a slight generalization of the\n// code provided in the problem statement since it\n// is generic in the type of the array elements.\nmethod swap<T>(a: array<T>, i: int, j: int)\n  requires 0 <= i < j < a.Length\n  modifies a\n  ensures a[i] == old(a[j])\n  ensures a[j] == old(a[i])\n  ensures forall m :: 0 <= m < a.Length && m != i && m != j ==> a[m] == old(a[m])\n  ensures multiset(a[..]) == old(multiset(a[..]))\n{\n  var t := a[i];\n  a[i] := a[j];\n  a[j] := t;\n}\n// This method is a direct translation of the pseudo\n// code given in the problem statement.\n// The first postcondition expresses that the resulting\n// array is sorted, that is, all occurrences of \"false\"\n// come before all occurrences of \"true\".\n// The second postcondition expresses that the post-state\n// array is a permutation of the pre-state array. To express\n// this, we use Dafny's built-in multisets. The built-in\n// function \"multiset\" takes an array and yields the\n// multiset of the array elements.\n// Note that Dafny guesses a suitable ranking function\n// for the termination proof of the while loop.\n// We use the loop guard from the given pseudo-code.  However,\n// the program also verifies with the stronger guard \"i < j\"\n// (without changing any of the other specifications or\n// annotations).\nmethod two_way_sort(a: array<bool>)\n  modifies a\n  ensures forall m,n :: 0 <= m < n < a.Length ==> (!a[m] || a[n])\n  ensures multiset(a[..]) == old(multiset(a[..]))\n{\n  var i := 0;\n  var j := a.Length - 1;\n  while (i <= j)\ninvariant multiset(a[..]) == old(multiset(a[..]))\n  {\n    if (!a[i]) {\n      i := i+1;\n    } else if (a[j]) {\n      j := j-1;\n    } else {\n      swap(a, i, j);\n      i := i+1;\n      j := j-1;\n    }\n  }\n}",
            "success": false
        }
    },
    {
        "Prog-Fun-Solutions_tmp_tmp7_gmnz5f_mockExam2_p6.dfy": {
            "state": "// problem 6:\n// name:      Gabriele Berardi\n// s-number: s4878728\n// table:     XXXXX\nghost function f(n: int): int {\n  if n <= 0 then 1 else n + f(n-1)*f(n-2)\n}\nghost function fSum(n: nat): int {\n // give the body of this function\n  // it should return Sum(i: 0<=i < n: f(i))\n  if n <= 0 then 0 else f(n-1) + fSum(n-1)\n}\nmethod problem6(n:nat) returns (a: int)\nensures a == fSum(n)\n{\n  a := 0;\n  var k := 0;\n  var x := 1;\n  var y := 2;\n  while k < n\ninvariant x == f(k-1)\n  {\n    k := k + 1;\n    a := a + x;\n    x, y := y, k+1 + x*y;    \n  }\n}",
            "success": false
        },
        "dafny-exercise_tmp_tmpouftptir_appendArray.dfy": {
            "state": "method appendArray(a: array<int>, b: array<int>) returns (c: array<int>)\nensures c.Length == a.Length + b.Length\nensures forall i :: 0 <= i < a.Length ==> a[i] == c[i]\nensures forall i :: 0 <= i < b.Length ==> b[i] == c[a.Length + i]\n{\n\tc := new int[a.Length + b.Length];\n\tvar i := 0;\n\twhile i < a.Length\ninvariant a[..i] == c[..a.Length + i]\n\t{\n\t\tc[i] := a[i];\n\t\ti := i + 1;\n\t}\n\twhile i < b.Length + a.Length\n\t{\n\t\tc[i] := b[i - a.Length];\n\t\ti := i + 1;\n\t}\n}",
            "success": false
        },
        "task_id_573.dfy": {
            "state": "method UniqueProduct (arr: array<int>) returns (product: int)\n   ensures product == SetProduct((set i | 0 <= i < arr.Length :: arr[i]))\n{\n    var p := 1;\n    var seen: set<int> := {};\n    for i := 0 to arr.Length\n        invariant 0 <= i <= arr.Length\n        invariant seen == (set k | 0 <= k < i :: arr[k])\n        invariant p == SetProduct((set k | 0 <= k < i :: arr[k]))\n    {\n        if ! (arr[i] in seen) {\n            seen := seen + { arr[i] };\n            p := p * arr[i];\n            SetProductLemma(seen, arr[i]);\n        }\n    }\n    product := p;\n}\nghost function SetProduct(s : set<int>) : int\n{\n    if s == {} then 1\n    else var x :| x in s; \n         x * SetProduct(s - {x})\n}\n/* \n * This is necessary because, when we add one element, we need to make sure\n * that the product of the new set, as a whole, is the same as the product\n * of the old set times the new element.\n */\nlemma SetProductLemma(s: set <int>, x: int) \n requires x in s\n ensures SetProduct(s - {x}) * x == SetProduct(s)\n{\n   if s != {}\n   {\nassert s == s - {x} + {x};\n      var y :| y in s && y * SetProduct(s - {y}) == SetProduct(s);\n      if y == x {}\n      else {\n         calc {\n            SetProduct(s);\n            y * SetProduct(s - {y});\n            { SetProductLemma(s - {y}, x); }\n            y * x * SetProduct(s - {y} - {x});\n            { assert s - {x} - {y} == s - {y} - {x};}\n            y * x * SetProduct(s - {x} - {y});\n            x * y * SetProduct(s - {x} - {y});\n            { SetProductLemma(s - {x}, y); }\n            x * SetProduct(s - {x});\n         }\n      }\n   }\n}",
            "success": true
        },
        "task_id_769.dfy": {
            "state": "method Difference(a: seq<int>, b: seq<int>) returns (diff: seq<int>)\n    ensures forall x :: x in diff <==> (x in a && x !in b)\n    ensures forall i, j :: 0 <= i < j < |diff| ==> diff[i] != diff[j]\n{\n    diff := [];\n    for i := 0 to |a|\ninvariant forall k, l :: 0 <= k < l < |diff| ==> diff[k] != diff[l]\ninvariant forall k :: 0 <= k < i ==> a[k] !in b ==> a[k] !in diff\n    {\n        if a[i] !in b && a[i] !in diff\n        {\n            diff := diff + [a[i]];\n        }\n    }\n}",
            "success": false
        },
        "Dafny_Programs_tmp_tmp99966ew4_lemma.dfy": {
            "state": "lemma SkippingLemma(a : array<int>, j : int)\n   requires a != null\n   requires forall i :: 0 <= i < a.Length ==> 0 <= a[i]\n   requires forall i :: 0 < i < a.Length ==> a[i-1]-1 <= a[i]\n   requires 0 <= j < a.Length\n   ensures forall k :: j <= k < j + a[j] && k < a.Length ==> a[k] != 0\n{\n   var i := j;\n   while i < j + a[j] && i < a.Length\n   decreases j + a[j] - i\n      invariant i < a.Length ==> a[j] - (i-j) <= a[i]\n      invariant forall k :: j <= k < i && k < a.Length ==> a[k] != 0\n   {\n      i := i + 1;\n   }\n}\nmethod FindZero(a: array<int>) returns (index: int)\n   requires a != null\n   requires forall i :: 0 <= i < a.Length ==> 0 <= a[i]\n   requires forall i :: 0 < i < a.Length ==> a[i-1]-1 <= a[i]\n   ensures index < 0  ==> forall i :: 0 <= i < a.Length ==> a[i] != 0\n   ensures 0 <= index ==> index < a.Length && a[index] == 0\n{\n   index := 0;\n   while index < a.Length\ninvariant forall i :: 0 <= i < index && i < a.Length ==> a[i] != 0\ninvariant index < a.Length ==> forall k :: 0 <= k < index && k < a.Length ==> a[k] != 0\n   {\n      if a[index] == 0 { return; }\n      SkippingLemma(a, index);\n      index := index + a[index];\n   }\n   index := -1;\n}",
            "success": true
        },
        "Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 3_InsertionSortMultiset.dfy": {
            "state": "// H\u00f6fundur spurningar:  Snorri Agnarsson, snorri@hi.is\n// Permalink spurningar: https://rise4fun.com/Dafny/G4sc3\n// H\u00f6fundur lausnar:     Alexander Gu\u00f0mundsson\n// Permalink lausnar:    https://rise4fun.com/Dafny/nujsu\n// Insertion sort me\u00f0 hj\u00e1lp helmingunarleitar.\nmethod Search( s: seq<int>, x: int ) returns ( k: int )\n    // Ekki m\u00e1 breyta forskilyr\u00f0um e\u00f0a eftirskilyr\u00f0um fallsins\n    requires forall p,q | 0 <= p < q < |s| :: s[p] <= s[q];\n    ensures 0 <= k <= |s|;\n    ensures forall i | 0 <= i < k :: s[i] <= x;\n    ensures forall i | k <= i < |s| :: s[i] >= x;\n    ensures forall z | z in s[..k] :: z <= x;\n    ensures forall z | z in s[k..] :: z >= x;\n    ensures s == s[..k]+s[k..];\n{\n    // Setji\u00f0 vi\u00f0eigandi stofn fallsins h\u00e9r.\n    var p := 0;\n    var q := |s|;\n    if p == q\n    {\n        return p;\n    }\n    while p != q \n        decreases q-p;\n        invariant 0 <= p <= q <= |s|;\n        invariant forall r | 0 <= r < p :: s[r] <= x;\n        invariant forall r | q <= r < |s| :: s[r] >= x;\n    {\n        var m := p + (q-p)/2;\n        if s[m] == x\n        {\n            return m;\n        }\n        if s[m] < x\n        {\n            p := m+1;\n        }\n        else\n        {\n            q := m;\n        }\n    }\n    return p;\n}\nmethod Sort( m: multiset<int> ) returns ( r: seq<int> )\n    ensures multiset(r) == m;\n    ensures forall p,q | 0 <= p < q < |r| :: r[p] <= r[q];\n{\n    // Setji\u00f0 vi\u00f0eigandi frumstillingu \u00e1 r og rest h\u00e9r.\n    // r er skilabreyta en rest er n\u00fd breyta sem \u00fei\u00f0 b\u00fai\u00f0 til.\n    r := [];\n    var rest := m;\n    while rest != multiset{}\ndecreases rest;\n        // Ekki breyta fastayr\u00f0ingu lykkju\n    {\n        // Setji\u00f0 vi\u00f0eigandi stofn lykkjunnar h\u00e9r.\n        // Fjarl\u00e6gi\u00f0 eitt gildi \u00far rest me\u00f0\n        //    var x :| x in rest;\n        //    rest := rest-multiset{x};\n        // og noti\u00f0 Search til a\u00f0 finna r\u00e9ttan sta\u00f0\n        // \u00ed r til a\u00f0 stinga [x] inn \u00ed r.\n        var x :| x in rest;\n        rest := rest - multiset{x};\n        var k := Search(r, x);\n        r := r[..k] + [x] + r[k..];\n    }\n    return r;\n}",
            "success": false
        },
        "Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseFirstNegative.dfy": {
            "state": "predicate positive(s:seq<int>)\n{forall u::0<=u<|s| ==> s[u]>=0}\nmethod mfirstNegative(v:array<int>) returns (b:bool, i:int)\nensures b <==> exists k::0<=k<v.Length && v[k]<0\nensures b ==> 0<=i<v.Length && v[i]<0 && positive(v[0..i])\n{ \n i:=0;\n b:=false;\n while (i<v.Length && !b)\n    invariant 0<=i<=v.Length\n    invariant b <==> exists k::0<=k<i && v[k]<0\n    invariant b ==> v[i-1]<0 && positive(v[0..i-1])\n    decreases v.Length - i\n  { \n    b:=(v[i]<0);\n    i:=i+1;\n   }\n  if (b){i:=i-1;}\n}\nmethod mfirstNegative2(v:array<int>) returns (b:bool, i:int)\nensures b <==> exists k::0<=k<v.Length && v[k]<0\nensures b ==> 0<=i<v.Length && v[i]<0 && positive(v[0..i])\n{ \n i:=0;b:=false;\n while (i<v.Length && !b)\ninvariant 0<=i<=v.Length\ninvariant b ==> v[i-1]<0 && positive(v[0..i-1])\n  { \n    b:=(v[i]<0);\n    if (!b) {i:=i+1;}\n   }\n}",
            "success": false
        },
        "Metodos_Formais_tmp_tmpbez22nnn_Aula_2_ex1.dfy": {
            "state": "method Mult(x:nat, y:nat) returns (r: nat)\nensures r == x * y\n{\n    var m := x;\nassert m == x; // x has the right value\n    var n := y;\nassert r == x*y-n; // r still has the right value\n    r:=0;\n    while m > 0\n    {\n        r := r + n;\n        m := m - 1;\n    }\n    return r;\n}",
            "success": false
        },
        "insert_strong.dfy": {
            "state": "method insert(line:array<char>, l:int, nl:array<char>, p:int, at:int)\n  requires 0 <= l+p <= line.Length\n  requires 0 <= p <= nl.Length\n  requires 0 <= at <= l\n  modifies line\n  ensures forall i :: (0<=i<p) ==> line[at+i] == nl[i]\n  ensures forall i :: (0<=i<at) ==> line[i] == old(line[i])\n  ensures forall i :: (at+p<=i<l+p) ==> line[i] == old(line[i-p])\n{\n  ghost var initialLine := line[..];\n  var i:int := l;\n  while(i>at)\ninvariant forall i :: (i < p || at+i < l) ==> line[at+i] == (if i<p then nl[i] else line[i])\ndecreases i\n  {\n    i := i - 1;\n    line[i+p] := line[i];\n  }\n  i := 0;\n  while(i<p)\n  {\n    line[at + i] := nl[i];\n    i := i + 1;\n  }\n}",
            "success": false
        },
        "task_id_743.dfy": {
            "state": "method RotateRight(l: seq<int>, n: int) returns (r: seq<int>)\n    requires n >= 0\n    ensures |r| == |l|\n    ensures forall i :: 0 <= i < |l| ==> r[i] == l[(i - n + |l|) % |l|]\n{\n    var rotated: seq<int> := [];\n    for i := 0 to |l|\ninvariant |rotated| == i\ninvariant forall j :: 0 <= j < i ==> rotated[j] == l[(j - n + |l|) % |l|]\n    {\n        rotated := rotated + [l[(i - n + |l|) % |l|]];\n    }\n    return rotated;\n}",
            "success": true
        },
        "Dafny_Verify_tmp_tmphq7j0row_Test_Cases_solved_1_select.dfy": {
            "state": "method SelectionSort(a: array<int>)\n  modifies a\n  ensures forall i,j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures multiset(a[..]) == old(multiset(a[..]))\n{\n  var n := 0;\n  while n != a.Length\n  {\n    var mindex, m := n, n;\n    while m != a.Length\ninvariant forall i :: n <= i < m ==> a[mindex] <= a[i]\n    {\n      if a[m] < a[mindex] {\n        mindex := m;\n      }\n      m := m + 1;\n    }\n    if a[mindex] < a[n] {\n      a[mindex], a[n] := a[n], a[mindex];\n    }\n    n := n + 1;\n  }  \n}",
            "success": false
        },
        "task_id_414.dfy": {
            "state": "method AnyValueExists(seq1: seq<int>, seq2: seq<int>) returns (result: bool)\n    ensures result <==> (exists i :: 0 <= i < |seq1| && seq1[i] in seq2)\n{\n    result := false;\n    for i := 0 to |seq1|\ninvariant result <==> (exists k :: 0 <= k < i && seq1[k] in seq2)\n    {\n        if seq1[i] in seq2 {\n            result := true;\n            break;\n        }\n    }\n}",
            "success": true
        },
        "Correctness_tmp_tmpwqvg5q_4_MethodCalls_q1.dfy": {
            "state": "/**\n  (a) Verify whether or not the following program\n      satisfies total correctness.\n      You should use weakest precondition reasoning\n      and may extend the loop invariant if required.\n      You will need to add a decreases clause to prove termination\n  (a) Weakest precondition proof (without termination) (6 marks)\n      Termination proof (2marks)\n*/\nfunction fusc(n: int): nat\nlemma rule1()\n  ensures fusc(0) == 0\nlemma rule2()\n  ensures fusc(1) == 1\nlemma rule3(n:nat)\n  ensures fusc(2*n) == fusc(n)\nlemma rule4(n:nat)\n  ensures fusc(2*n+1) == fusc(n) + fusc(n+1)\nmethod ComputeFusc(N: int) returns (b: int)\n  requires N >= 0 \n  ensures b == fusc(N)\n{\n  b := 0;\n  var n, a := N, 1;\n  while (n != 0)\n  {\n    ghost var d := n; // termination metric\n    if (n % 2 == 0)\n    {\n      rule4(n/2);\n      rule3(n/2);\n      a := a + b;\n      n := n / 2;\n    } else {\n      rule4((n-1)/2);\n      rule3((n-1)/2);\n      rule3((n+1)/2);\n              b * fusc(n) - b  * fusc(n) + b  * fusc(((n-1)/2)+1) + a * fusc(n);\n              b * fusc(n) - b  * (fusc(n) - fusc(((n-1)/2)+1)) + a * fusc(n);\n              a * fusc(n - 1) + b  * fusc(n) - b  * fusc(n-1) + a * fusc(n) - a * fusc(n-1);\n      b := b + a;\n      n := (n - 1) / 2;\n    }\n  }\n  rule1();\n  rule2();\n}",
            "success": false
        },
        "Workshop_tmp_tmp0cu11bdq_Workshop_Answers_Question6.dfy": {
            "state": "method arrayUpToN(n: int) returns (a: array<int>)\n    requires n >= 0\n    ensures a.Length == n\n    ensures forall j :: 0 < j < n ==> a[j] >= 0\n    ensures forall j, k : int :: 0 <= j <= k < n ==> a[j] <= a[k]\n{\n    var i := 0;\n    a := new int[n];\n    while i < n\ndecreases n - i\ninvariant forall j, k :: 0 <= j <= k < i ==> a[j] <= a[k]\n    {\n        a[i] := i;\n        i := i + 1;\n    }\n}",
            "success": false
        },
        "Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_50_examples_SumArray.dfy": {
            "state": "function Sum(arr: array<int>, len: int): int\n    reads arr\n    requires arr.Length > 0 && 0 <= len <= arr.Length\n{\n    if len == 0 then 0 else arr[len-1] + Sum(arr, len-1)\n}\nmethod SumArray(arr: array<int>) returns (sum: int)\n    requires arr.Length > 0\n    ensures sum == Sum(arr, arr.Length)\n{\n    sum := 0;\n    var i := 0;\n    while i < arr.Length\ndecreases arr.Length - i\ninvariant sum == Sum(arr, i)\n    {\n        sum := sum + arr[i];\n        i := i + 1;\n    }\n}",
            "success": false
        },
        "task_id_424.dfy": {
            "state": "method ExtractRearChars(l: seq<string>) returns (r: seq<char>)\n    requires forall i :: 0 <= i < |l| ==> |l[i]| > 0\n    ensures |r| == |l|\n    ensures forall i :: 0 <= i < |l| ==> r[i] == l[i][|l[i]| - 1]\n{\n    var rearChars: seq<char> := [];\n    for i := 0 to |l|\ninvariant |rearChars| == i\ninvariant forall j :: 0 <= j < i ==> rearChars[j] == l[j][|l[j]| - 1]\n    {\n        rearChars := rearChars + [l[i][|l[i]| - 1]];\n    }\n    return rearChars;\n}",
            "success": true
        },
        "task_id_3.dfy": {
            "state": "method IsNonPrime(n: int) returns (result: bool)\n    requires n >= 2\n    ensures result <==> (exists k :: 2 <= k < n && n % k == 0)\n{\n    result := false;\n    var i := 2;\n    while i <= n/2\ninvariant result <==> (exists j :: 2 <= j < i && n % j == 0)\n    {\n        if n % i == 0\n        {\n            result := true;\n            break;\n        }\n        i := i + 1;\n    }\n}",
            "success": true
        },
        "task_id_8.dfy": {
            "state": "method SquareElements(a: array<int>) returns (squared: array<int>)\n    ensures squared.Length == a.Length\n    ensures forall i :: 0 <= i < a.Length ==> squared[i] == a[i] * a[i]\n{\n    squared := new int[a.Length];\n    for i := 0 to a.Length\ninvariant forall j :: 0 <= j < i ==> squared[j] == a[j] * a[j]\n    {\n        squared[i] := a[i] * a[i];\n    }\n}",
            "success": true
        },
        "task_id_170.dfy": {
            "state": "function sumTo( a:array<int>, start:int, end:int ) : int\n    requires a != null;\n    requires 0 <= start && start <= end && end <= a.Length;\n    decreases end;\n    reads a;\n    {\n        if (start == end) then 0 else sumTo(a, start, end-1) + a[end-1]\n    }\n    method SumInRange(a: array<int>, start: int, end: int) returns (sum: int)\n    requires a != null\n    requires 0 <= start && start <= end && end <= a.Length\n    ensures sum == sumTo(a, start, end)\n    {\n        sum := 0;\n        for i := start to end\ninvariant sum == sumTo(a, start, i)\n        {\n            sum := sum + a[i];\n        }\n    }",
            "success": true
        },
        "ProjectosCVS_tmp_tmp_02_gmcw_Handout 1_CVS_handout1_55754_55780.dfy": {
            "state": "/**\nCVS 2021-22 Handout 1\nAuthors\nGon\u00e7alo Martins Louren\u00e7o n\u00ba55780\nJoana Soares Faria  n\u00ba55754\n */\n// First Exercise\nlemma peasantMultLemma(a:int, b:int)\n    requires b >= 0\n    ensures b % 2 == 0 ==> (a * b == 2 * a * b / 2)\n    ensures b % 2 == 1 ==> (a * b == a + 2 * a * (b - 1) / 2)\n    {\n        if (b % 2 == 0 && b > 0) { \n            peasantMultLemma(a, b - 2);\n        }\n        if (b % 2 == 1 && b > 1) {\n            peasantMultLemma(a, b - 2);\n        }\n    }\nmethod peasantMult(a: int, b: int) returns (r: int)\n    requires b > 0\n    ensures r == a * b\n    {\n        r := 0;\n        var aa := a;\n        var bb := b;\n        while(bb > 0)\n            decreases bb \n            invariant 0 <= bb <= b\n            invariant r + aa * bb == a * b\n        { \n            // Use of lemma was not necessary for a successful verification\n            // peasantMultLemma(aa, bb);\n            if (bb % 2 == 0)\n            {\n                aa := 2 * aa;\n                bb := bb / 2;\n            } else if (bb % 2 == 1)\n            {\n                r := r + aa;\n                aa := 2 * aa;\n                bb := (bb-1) / 2;\n            }\n        } \n    }\n//Second Exercise\nmethod euclidianDiv(a: int,b : int) returns (q: int,r: int)\n    requires a >= 0\n    requires b > 0\n    ensures a == b * q + r\n    {\n        r := a;\n        q := 0;\n        while(r - b >= 0)\ndecreases r\ninvariant r >= 0\n            // invariant a == b * q + r\n        {\n            r := r - b;\n            q := q + 1;\n        }\n    }",
            "success": false
        },
        "Software-Verification_tmp_tmpv4ueky2d_Best Time to Buy and Sell Stock_best_time_to_buy_and_sell_stock.dfy": {
            "state": "method best_time_to_buy_and_sell_stock(prices: array<int>) returns (max_profit: int)\n    requires 1 <= prices.Length <= 100000\n    requires forall i :: 0 <= i < prices.Length ==> 0 <= prices[i] <= 10000\n    ensures forall i, j :: 0 <= i < j < prices.Length ==> max_profit >= prices[j] - prices[i]\n{\n    var min_price := 10001;\n    max_profit := 0;\n    var i := 0;\n    while (i < prices.Length)\ninvariant min_price <= 10001\ninvariant forall j :: 0 <= j < i ==> min_price <= prices[j]\n    {\n        var price := prices[i];\n        if (price < min_price)\n        {\n            min_price := price;\n        }\n        if (price - min_price > max_profit) {\n            max_profit := price - min_price;\n        }\n        i := i + 1;\n    }\n}",
            "success": false
        },
        "dafny_examples_tmp_tmp8qotd4ez_leetcode_0001-two-sum.dfy": {
            "state": "// If this invariant is added explicitly to the loop then the verfication never finishes.\n// It could be {:opaque} for a more controlled verification:\n// assert InMap([], m, target) by {\n//   reveal InMap();\n// }\npredicate InMap(nums: seq<int>, m: map<int, int>, t: int) {\n  forall j :: 0 <= j < |nums| ==> t - nums[j] in m\n}\nmethod TwoSum(nums: array<int>, target: int) returns (r: (int, int))\n  ensures 0 <= r.0 ==> 0 <= r.0 < r.1 < nums.Length && \n                       nums[r.0] + nums[r.1] == target &&\n                       forall i, j :: 0 <= i < j < r.1 ==> nums[i] + nums[j] != target\n  ensures r.0 == -1 <==> forall i, j :: 0 <= i < j < nums.Length ==> nums[i] + nums[j] != target\n{\n  var m: map<int, int> := map[];\n  var i := 0;\n  while i < nums.Length\ninvariant 0 <= i <= nums.Length\ninvariant InMap(nums[..i], m, target) // Once this assertion is removed, the verification finishes quickly, and when this assertion is added, the verification never finishes.\n  {\n    if nums[i] in m {\n      return (m[nums[i]], i);\n    }\n    m := m[target - nums[i] := i];\n    i := i + 1;\n  }\n  return (-1, -1);\n}",
            "success": false
        },
        "CVS-Projto1_tmp_tmpb1o0bu8z_Hoare.dfy": {
            "state": "method Max (x: nat, y:nat) returns (r:nat)\n    ensures (r >= x && r >=y)\n    ensures (r == x || r == y)\n{\n    if (x >= y) { r := x;}\n    else { r := y;}\n}\nmethod Test ()\n{\n    var result := Max(42, 73);\n    assert result == 73;\n}\nmethod m1 (x: int, y: int) returns (z: int)\nrequires 0 < x < y\nensures z >= 0 && z <= y && z != x\n{\n    //assume 0 < x < y\n    z := 0;\n}\nfunction fib (n: nat) : nat\n{\n    if n == 0 then 1 else\n    if n == 1 then 1 else\n    fib(n -1) + fib (n-2)\n}\nmethod Fib (n: nat) returns (r:nat)\n    ensures r == fib(n)\n{\n    if (n == 0) {\n        return 1;\n    }\n    r := 1;\n    var next:=2;\n    var i := 1;\n    while i < n\n        invariant 1 <= i <= n\n        invariant r == fib(i)\n        invariant next == fib(i+1)\n    {\n        var tmp:=next;\n        next:= next + r;\n        r:= tmp;\n        i:= i + 1;\n    }\n    assert r == fib(n);\n    return r;\n}\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\nfunction add(l:List<int>) : int\n{\n    match l\n    case Nil => 0\n    case Cons(x, xs) => x + add(xs)\n}\nmethod addImp (l: List<int>) returns (s: int)\n    ensures s == add(l)\n{\n    var ll := l;\n    s := 0;\n    while ll != Nil\n        decreases ll\n        invariant add(l) == s + add(ll)\n        {\n            s := s + ll.head;\n            ll:= ll.tail;\n        }\n    assert s == add(l);\n}\nmethod MaxA (a: array<int>) returns (m: int)\n    requires a.Length > 0\n    ensures forall i :: 0 <= i < a.Length ==> a[i] <= m\n    ensures exists i :: 0 <= i < a.Length && a[i] == m\n{\n    m := a[0];\n    var i := 1;\n    while i< a.Length\ninvariant forall j :: 0 <= j < i ==> a[j] <= m\ninvariant exists j :: 0 <= j < i && a[j] == m\n    {\n        if a[i] > m {\n            m:= a[i];\n        }\n        i := i +1;\n    }\n}",
            "success": false
        },
        "task_id_807.dfy": {
            "state": "predicate IsOdd(x: int)\n{\n    x % 2 != 0\n}\nmethod FindFirstOdd(a: array<int>) returns (found: bool, index: int)\n    requires a != null\n    ensures !found ==> forall i :: 0 <= i < a.Length ==> !IsOdd(a[i])\n    ensures found ==> 0 <= index < a.Length && IsOdd(a[index]) && forall i :: 0 <= i < index ==> !IsOdd(a[i])\n{\n    found := false;\n    index := 0;\n    while (index < a.Length)\ninvariant 0 <= index <= a.Length\ninvariant found ==> forall i :: 0 <= i < index ==> !IsOdd(a[i])\n    {\n        if IsOdd(a[index])\n        {\n            found := true;\n            return;\n        }\n        index := index + 1;\n    }\n}",
            "success": false
        },
        "min_array_strong.dfy": {
            "state": "method minArray(a: array<int>) returns (r:int)\n  requires a.Length > 0\n  ensures forall i :: 0 <= i < a.Length ==> r <= a[i]\n  ensures exists i :: 0 <= i < a.Length && r == a[i]\n{\n  r:=a[0];\n  var i:=1;\n  while i<a.Length\ninvariant r==a[0]\ninvariant exists j::0<=j<i&&r==a[j]\n  {\n    if r>a[i]{\n      r:=a[i];\n    }\n    i:=i+1;\n  }\n}",
            "success": false
        },
        "task_id_594.dfy": {
            "state": "predicate IsEven(n: int)\n{\n    n % 2 == 0\n}\npredicate IsOdd(n: int)\n{\n    n % 2 != 0\n}\nmethod FirstEvenOddDifference(a: array<int>) returns (diff: int)\n    requires a.Length >= 2\n    requires exists i :: 0 <= i < a.Length && IsEven(a[i])\n    requires exists i :: 0 <= i < a.Length && IsOdd(a[i])\n    ensures exists i, j :: 0 <= i < a.Length && 0 <= j < a.Length && IsEven(a[i]) && IsOdd(a[j]) && diff == a[i] - a[j] && \n        (forall k :: 0 <= k < i ==> IsOdd(a[k])) && (forall k :: 0 <= k < j ==> IsEven(a[k]))\n{\n    var firstEven: int := -1;\n    var firstOdd: int := -1;\n    for i := 0 to a.Length\n    {\n        if firstEven == -1 && IsEven(a[i])\n        {\n            firstEven := i;\n        }\n        if firstOdd == -1 && IsOdd(a[i])\n        {\n            firstOdd := i;\n        }\n        if firstEven != -1 && firstOdd != -1\n        {\n            break;\n        }\n    }\n    diff := a[firstEven] - a[firstOdd];\n}",
            "success": false
        },
        "dafny-duck_tmp_tmplawbgxjo_p1.dfy": {
            "state": "// Given an array of integers, it returns the sum. [1,3,3,2]->9\nfunction Sum(xs: seq<int>): int {\n    if |xs| == 0 then 0 else Sum(xs[..|xs|-1]) + xs[|xs|-1]\n}\nmethod SumArray(xs: array<int>) returns (s: int)\n    ensures s == Sum(xs[..])\n{\n    s := 0;\n    var i := 0;\n    while i < xs.Length\ninvariant 0 <= i <= xs.Length\ninvariant s == Sum(xs[..i])\n    {\n        s := s + xs[i];\n        i := i + 1;\n    }\n}",
            "success": false
        },
        "laboratory_tmp_tmps8ws6mu2_dafny-tutorial_exercise11.dfy": {
            "state": "method m()\n{\n    var i, n := 0, 20;\n    while i != n\n    {\n        i := i + 1;\n    }\n}",
            "success": false
        },
        "task_id_554.dfy": {
            "state": "/**\n * Find odd numbers from an array of numbers\n **/\npredicate IsOdd(n: int)\n{\n    n % 2 == 1\n}\nmethod FindOddNumbers(arr: array<int>) returns (oddList: seq<int>)\n    // All numbers in the output are odd and exist in the input \n    ensures forall i :: 0 <= i < |oddList| ==> IsOdd(oddList[i]) && oddList[i] in arr[..]\n    // All odd numbers in the input are in the output\n    ensures forall i :: 0 <= i < arr.Length && IsOdd(arr[i]) ==> arr[i] in oddList\n{\n    oddList := [];\n    for i := 0 to arr.Length\ninvariant forall k :: 0 <= k < |oddList| ==> IsOdd(oddList[k]) && oddList[k] in arr[..]\ninvariant forall k :: 0 <= k < i && IsOdd(arr[k]) ==> arr[k] in oddList\n    {\n        if IsOdd(arr[i])\n        {\n            oddList := oddList + [arr[i]];\n        }\n    }\n}",
            "success": true
        },
        "Dafny-experiences_tmp_tmp150sm9qy_dafny_started_tutorial_dafny_tutorial_array.dfy": {
            "state": "method FindMax(a: array<int>) returns (i: int)\n  // Annotate this method with pre- and postconditions\n  // that ensure it behaves as described.\n  requires a.Length > 0\n  ensures 0<= i < a.Length\n  ensures forall k :: 0 <= k < a.Length ==> a[k] <= a[i]\n{\n  // Fill in the body that calculates the INDEX of the maximum.\n  i := 0;\n  var index := 1;\n  while index < a.Length\ninvariant 0 <= i < index\ninvariant forall k :: 0 <= k < index ==> a[k] <= a[i]\n  {\n    if a[index] > a[i] {i:= index;}\n    index := index + 1;\n  }\n}",
            "success": false
        },
        "Workshop_tmp_tmp0cu11bdq_Workshop_Answers_Question5.dfy": {
            "state": "method rev(a : array<int>)\n    requires a != null;\n    modifies a;\n    ensures forall k :: 0 <= k < a.Length ==> a[k] == old(a[(a.Length - 1) - k]);\n{\n    var i := 0;\n    while (i < a.Length - 1 - i)\ninvariant 0 <= i <= a.Length / 2;\ninvariant forall k :: a.Length / 2 - i <= k < a.Length / 2 + i ==> a[k] == old(a[a.Length - 1 - k]);\n    {\n        a[i], a[a.Length - 1 - i] := a[a.Length - 1 - i], a[i];\n        i := i + 1;\n    }\n}",
            "success": false
        },
        "Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_50_examples_28.dfy": {
            "state": "method main(x: int, y: int) returns (x_out: int, y_out: int, n: int)\nrequires x >= 0\nrequires y >= 0\nrequires x == y\nensures y_out == n\n{\nassert x_out == n;\n    x_out := x;\n    y_out := y;\n    n := 0;\n    while (x_out != n)\n    {\n        x_out := x_out - 1;\n        y_out := y_out - 1;\n    }\n}",
            "success": false
        },
        "dafny_tmp_tmp2ewu6s7x_ListReverse.dfy": {
            "state": "function reverse(xs: seq<nat>): seq<nat>\n{\n    if xs == [] then [] else reverse(xs[1..]) + [xs[0]]\n}\nlemma ReverseAppendDistr(xs: seq<nat>, ys: seq<nat>)\nensures reverse(xs + ys) == reverse(ys) + reverse(xs)\n{\n    if {\n        case xs == [] =>\n        calc {\nreverse(xs) + reverse(xs[1..]);\n==\n            reverse([] + ys);\n            calc {\n                [] + ys;\n                ys;\n            }\n            reverse(ys);\n            reverse(ys) + reverse([]);\n        }\n        case xs != [] => {\n            var zs := xs + ys;\n        }\n    }\n}\nlemma ReverseInvolution(xxs: seq<nat>)\nensures reverse(reverse(xxs)) == xxs\n{\n    if {\n        case xxs == [] => {}\n        case xxs != [] => calc {\n            reverse(reverse(xxs));\n            ==\n            reverse(reverse(xxs[1..]) + [xxs[0]]);\n            ==\n            { ReverseAppendDistr(reverse(xxs[1..]), [xxs[0]]); }\n            reverse([xxs[0]]) + reverse(reverse(xxs[1..]));\n            ==\n            { ReverseInvolution(xxs[1..]); }\n            calc {\n                reverse([xxs[0]]);\n                ==\n                [] + [xxs[0]];\n                ==\n                [xxs[0]];\n            }\n            [xxs[0]] + xxs[1..];\n            ==\n            xxs;\n        }\n    }\n}",
            "success": false
        },
        "task_id_732.dfy": {
            "state": "predicate IsSpaceCommaDot(c: char)\n{\n    c == ' ' || c == ',' || c == '.'\n}\nmethod ReplaceWithColon(s: string) returns (v: string)\n    ensures |v| == |s|\n    ensures forall i :: 0 <= i < |s| ==> (IsSpaceCommaDot(s[i]) ==> v[i] == ':') && (!IsSpaceCommaDot(s[i]) ==> v[i] == s[i])\n{\n    var s' : string := [];\n    for i := 0 to |s|\ninvariant |s'| == i\ninvariant forall k :: 0 <= k < i ==> (IsSpaceCommaDot(s[k]) ==> s'[k] == ':') && (!IsSpaceCommaDot(s[k]) ==> s'[k] == s[k])\n    {\n        if IsSpaceCommaDot(s[i])\n        {\n            s' := s' + [':'];\n        }\n        else \n        {\n            s' := s' + [s[i]];\n        }\n    }\n    return s';\n}",
            "success": true
        },
        "task_id_445.dfy": {
            "state": "method MultiplyElements(a: seq<int>, b: seq<int>) returns (result: seq<int>)\n    requires |a| == |b|\n    ensures |result| == |a|\n    ensures forall i :: 0 <= i < |result| ==> result[i] == a[i] * b[i]\n{\n    result := [];\n    var i := 0;\n    while i < |a|\ninvariant |result| == i\ninvariant forall k :: 0 <= k < i ==> result[k] == a[k] * b[k]\n    {\n        result := result + [a[i] * b[i]];\n        i := i + 1;\n    }\n}",
            "success": false
        },
        "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_pregel algorithms_skeleton_nondet-permutation.dfy": {
            "state": "\ufeffmodule Permutation\n{\n\t/**\n\t * Given n >= 0, generate a permuation of {0,...,n-1} nondeterministically.\n\t */\n\tmethod Generate(n: int) returns (perm: array<int>)\n\t\trequires n >= 0\n\t\tensures perm != null\n\t\tensures perm.Length == n\n\t\tensures fresh(perm)\n\t\tensures isValid(perm, n)\n\t{\nassert isValid(perm, n);\n\t\tvar all := set x | 0 <= x < n;\n\t\tvar used := {};\n\t\tperm := new int[n];\n\t\tCardinalityLemma(n, all);\n\t\twhile used < all\n\t\t{\n\t\t\tCardinalityOrderingLemma(used, all);\n\t\t\tvar dst :| dst in all && dst !in used;\n\t\t\tperm[|used|] := dst;\n\t\t\tused := used + {dst};\n\t\t}\n\t\tprint perm;\n\t}\n\tpredicate isValid(a: array<int>, n: nat)\n\t\trequires a != null && a.Length == n\n\t\treads a\n\t{\n\t\tassume forall i | 0 <= i < n :: i in a[..];\n\t\tdistinct(a)\n\t\t&& (forall i | 0 <= i < a.Length :: 0 <= a[i] < n)\n\t\t&& (forall i | 0 <= i < n :: i in a[..])\n\t}\n\tpredicate distinct(a: array<int>)\n\t\trequires a != null\n\t\treads a\n\t{\n\t\tdistinct'(a, a.Length)\n\t}\n\tpredicate distinct'(a: array<int>, n: int)\n\t\trequires a != null\n\t\trequires a.Length >= n\n\t\treads a\n\t{\n\t\tforall i,j | 0 <= i < n && 0 <= j < n && i != j :: a[i] != a[j]\n\t}\n\tlemma CardinalityLemma (size: int, s: set<int>)\n\t\trequires size >= 0\n\t\trequires s == set x | 0 <= x < size\n\t\tensures\tsize == |s|\n\t{\n\t\tif(size == 0) {\n\t\t} else {\n\t\t\tCardinalityLemma(size - 1, s - {size - 1});\n\t\t}\n\t}\n\tlemma CardinalityOrderingLemma<T> (s1: set<T>, s2: set<T>)\n\t\trequires s1 < s2\n\t\tensures |s1| < |s2|\n\t{\n\t\tvar e :| e in s2 - s1;\n\t\tif s1 != s2 - {e} {\n\t\t\tCardinalityOrderingLemma(s1, s2 - {e});\n\t\t}\n\t}\n\tlemma SetDiffLemma<T> (s1: set<T>, s2: set<T>)\n\t\trequires s1 < s2\n\t\tensures s2 - s1 != {}\n\t{\n\t\tvar e :| e in s2 - s1;\n\t\tif s2 - s1 != {e} {} // What does Dafny prove here???\n\t}\n}",
            "success": false
        },
        "cs245-verification_tmp_tmp0h_nxhqp_quicksort-partition.dfy": {
            "state": "// Quicksort Partition -- Stephanie McIntyre\n// Based on examples in class \n// Parts have been modified cause you know, arrays are different...\nmethod QuicksortPartition(X: array<int>, n: int, p: int) returns (a: int, b: int)\nmodifies X;\n/*Pre-Condition*/   requires X.Length>=1 && n == X.Length;\n/*Post-Condition*/  ensures b>=n;\n                    ensures forall x:: 0<=x<a<n ==> X[x] <= p;\n                    ensures forall x:: a==n || (0<=a<=x<n ==> X[x] > p);\n                    ensures multiset(X[..])==multiset(old(X[..]))           //This says the new X is a permutation of our old version of X.\n{\n  a := 0;\n  while ( a < n && X[a] <= p ) \ninvariant multiset(X[..])==multiset(old(X[..]))           //This says the new X is a permutation of our old version of X.\ninvariant forall x::a<=x<b<n ==> X[x]>p;\n  { \n    a := a+1;\n  }\n  b := a+1;\n  while ( b<n )\n  { \n    if ( X[b] <= p ) {\n      var t := X[b]; \n      X[b] := X[a]; \n      X[a] := t; \n      a := a+1;\n    }\n    b := b+1;\n  }\n}\n/* The annotations and implied proofs are left for you.\n   I might do them later on next week. */",
            "success": false
        },
        "ironsync-osdi2023_tmp_tmpx80antoe_linear-dafny_docs_DafnyRef_examples_Example-Old2.dfy": {
            "state": "class A {\n  var value: int\n  constructor ()\n     ensures value == 10\n  {\n     value := 10;\n  }\n}\nclass B {\n   var a: A\n   constructor () { a := new A(); }\n   method m()\n     requires a.value == 11\n     modifies this, this.a\n   {\n     label L:\n     a.value := 12;\n     label M:\n     a := new A(); // Line X\n     label N:\n     a.value := 20;\n     label P:\nassert a.value == 20; // Line Q\n                                // but .value in current state\n                                  // reference at Line X\n  }\n}",
            "success": true
        },
        "set_to_seq_strong.dfy": {
            "state": "method SetToSeq<T>(s: set<T>) returns (xs: seq<T>)\n  ensures multiset(s) == multiset(xs)\n{\n  xs := [];\n  var left: set<T> := s;\n  while left != {}\ninvariant multiset(left) + multiset(xs) == multiset(s)\n  {\n    var x :| x in left;\n    left := left - {x};\n    xs := xs + [x];\n  }\n}",
            "success": true
        },
        "task_id_106.dfy": {
            "state": "method AppendArrayToSeq(s: seq<int>, a: array<int>) returns (r: seq<int>)\n    requires a != null\n    ensures |r| == |s| + a.Length\n    ensures forall i :: 0 <= i < |s| ==> r[i] == s[i]\n    ensures forall i :: 0 <= i < a.Length ==> r[|s| + i] == a[i]\n{\n    r := s;\n    for i := 0 to a.Length\ninvariant |r| == |s| + i\ninvariant forall j :: 0 <= j < i ==> r[|s| + j] == a[j]\n    {\n        r := r + [a[i]];\n    }\n}",
            "success": false
        },
        "task_id_474.dfy": {
            "state": "method ReplaceChars(s: string, oldChar: char, newChar: char) returns (v: string)\n    ensures |v| == |s|\n    ensures forall i :: 0 <= i < |s| ==> (s[i] == oldChar ==> v[i] == newChar) && (s[i] != oldChar ==> v[i] == s[i])\n{\n    var s' : string := [];\n    for i := 0 to |s|\ninvariant |s'| == i\ninvariant forall j :: 0 <= j < i ==> (s[j] == oldChar ==> s'[j] == newChar) && (s[j] != oldChar ==> s'[j] == s[j])\n    {\n        if s[i] == oldChar\n        {\n            s' := s' + [newChar];\n        }\n        else \n        {\n            s' := s' + [s[i]];\n        }\n    }\n    return s';\n}",
            "success": true
        },
        "dafny_examples_tmp_tmp8qotd4ez_lib_math_DivMod.dfy": {
            "state": "module DivMod {\n  function {:opaque} DivSub(a: int, b: int): int\n    requires 0 <= a && 0 < b\n  {\n    if a < b then 0 else 1 + DivSub(a - b, b)\n  }\n  function {:opaque} ModSub(a: int, b: int): int\n    requires 0 <= a && 0 < b\n  {\n    if a < b then a else ModSub(a - b, b)\n  }\n  lemma DivModAdd1(a: int, b: int)\n    requires b != 0\n    ensures (a + b) % b == a % b\n    ensures (a + b) / b == a / b + 1\nlemma DivModAdd(a: int, b: int, c: int)\n  {\n    var c := (a + b) / b - (a / b) - 1;\n  }\n  lemma DivModSub1(a: int, b: int)\n    requires b != 0\n    ensures (a - b) % b == a % b\n    ensures (a - b) / b == a / b - 1\n  {\n    var c := (a - b) / b - (a / b) + 1;\n  }\n  lemma ModEq(a: int, b: int)\n    requires 0 <= a && 0 < b\n    ensures a % b == ModSub(a, b)\n  {\n    reveal ModSub();\n    if a >= b {\n      DivModSub1(a, b);\n    }\n  }\n  lemma DivEq(a: int, b: int)\n    requires 0 <= a && 0 < b\n    ensures a / b == DivSub(a, b)\n  {\n    reveal DivSub();\n    if a >= b {\n      DivModSub1(a, b);\n    }\n  }\n  lemma DivModSpec'(a: int, b: int, q: int, r: int)\n    requires 0 <= a && 0 < b\n    requires 0 <= q && 0 <= r < b\n    requires a == q * b + r\n    ensures ModSub(a, b) == r\n    ensures DivSub(a, b) == q\n  {\n    reveal ModSub();\n    reveal DivSub();\n    if q > 0 {\n      DivModSpec'(a - b, b, q - 1, r);\n    }\n  }\n  lemma DivModSpec(a: int, b: int, q: int, r: int)\n    requires 0 <= a && 0 < b\n    requires 0 <= q && 0 <= r < b\n    requires a == q * b + r\n    ensures a % b == r\n    ensures a / b == q\n  {\n    ModEq(a, b);\n    DivEq(a, b);\n    DivModSpec'(a, b, q, r);\n  }\n  lemma DivMul(a: int, b: int)\n    requires 0 <= a && 0 < b\n    ensures a * b / b == a\n  {\n    DivModSpec(a * b, b, a, 0);\n  }\n  lemma DivModMulAdd(a: int, b: int, c: int)\n    requires 0 <= a && 0 <= c < b && 0 < b\n    ensures (a * b + c) / b == a\n    ensures (a * b + c) % b == c\n  {\n    DivModSpec(a * b + c, b, a, c);\n  }\n}",
            "success": false
        },
        "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic examples_sumto_sol.dfy": {
            "state": "function sum_up_to (n: nat): nat\n{\n  if (n == 0) then 0\n  else sum_up_to (n-1) + 1\n}\nmethod SumUpTo (n: nat) returns (r: nat)\n  ensures r == sum_up_to (n);\n{\n  var i := 0;\n  r := 0;\n  while (i < n)\n    invariant 0 <= i <= n;\n    invariant r == sum_up_to (i);\n  {\n    r := r + 1;\n    i := i + 1;\n  }\n}\nfunction total (a: seq<nat>) : nat\n{\n  if |a| == 0 then 0\n  else total (a[0..|a|-1]) + a[|a|-1]\n}\nlemma total_lemma (a: seq<nat>, i:nat) \n  requires |a| > 0;\n  requires 0 <= i < |a|;\n  ensures total (a[0..i]) + a[i] == total (a[0..i+1]);\n{\n  ghost var b := a[0..i+1];\n  calc\n  {\n    total (a[0..i+1]);\n    total (b);\n    total (b[0..|b|-1]) + b[|b|-1];\n    total (b[0..|b|-1]) + a[i];\n    {assert (b[0..|b|-1] == a[0..i]);}\n    total (a[0..i]) + a[i];\n  }\n}\nmethod Total (a: seq<nat>) returns (r:nat)\n  ensures r == total (a[0..|a|]); \n{\n  var i := 0;\n  r := 0;\n  while i < |a|\ninvariant 0 <= i <= |a|;\ninvariant r == total (a[0..i]);\n  { \n    total_lemma (a, i);\n    r := r + a[i];\n    i := i + 1;\n  }\n}",
            "success": true
        },
        "array_sum_strong.dfy": {
            "state": "method arraySum(a: array<int>, b: array<int>) returns (c: array<int> )\n  requires a.Length==b.Length\n  ensures c.Length==a.Length\n  ensures forall i:: 0 <= i< a.Length==> a[i] + b[i]==c[i]\n{\n  c:= new int[a.Length];\n  var i:=0;\n  while i<a.Length\ndecreases c.Length-i\n  {\n    c[i]:=a[i]+b[i];\n    i:=i+1;\n  }\n}",
            "success": false
        },
        "task_id_282.dfy": {
            "state": "method ElementWiseSubtraction(a: array<int>, b: array<int>) returns (result: array<int>)\n    requires a != null && b != null\n    requires a.Length == b.Length\n    ensures result != null\n    ensures result.Length == a.Length\n    ensures forall i :: 0 <= i < result.Length ==> result[i] == a[i] - b[i]\n{\n    result := new int[a.Length];\n    var i := 0;\n    while i < a.Length\n    {\n        result[i] := a[i] - b[i];\n        i := i + 1;\n    }\n}",
            "success": false
        },
        "task_id_2.dfy": {
            "state": "predicate InArray(a: array<int>, x: int)\n    reads a\n{\n    exists i :: 0 <= i < a.Length && a[i] == x\n}\nmethod SharedElements(a: array<int>, b: array<int>) returns (result: seq<int>)\n    // All elements in the output are in both a and b\n    ensures forall x :: x in result ==> (InArray(a, x) && InArray(b, x))\n    // The elements in the output are all different\n    ensures forall i, j :: 0 <= i < j < |result| ==> result[i] != result[j]\n{\n    var res: seq<int> := [];\n    for i := 0 to a.Length\ninvariant forall x :: x in res ==> (InArray(a, x) && InArray(b, x))\ninvariant forall j, k :: 0 <= j < k < |res| ==> res[j] != res[k]\n    {\n        if InArray(b, a[i]) && a[i] !in res\n        {\n            res := res + [a[i]];\n        }\n    }\n    result := res;\n}",
            "success": true
        },
        "task_id_145.dfy": {
            "state": "method MaxDifference(a: array<int>) returns (diff: int)\n    requires a.Length > 1\n    ensures forall i, j :: 0 <= i < a.Length && 0 <= j < a.Length ==> a[i] - a[j] <= diff\n{\n    var minVal := a[0];\n    var maxVal := a[0];\n    for i := 1 to a.Length\ninvariant forall j :: 0 <= j < i ==> minVal <= a[j] && a[j] <= maxVal\n    {\n        if a[i] < minVal {\n            minVal := a[i];\n        } else if a[i] > maxVal {\n            maxVal := a[i];\n        }\n    }\n    diff := maxVal - minVal;\n}",
            "success": true
        },
        "Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseContained.dfy": {
            "state": "predicate strictSorted(s : seq<int>) {\n\tforall u, w :: 0 <= u < w < |s| ==> s[u] < s[w]\n}\nmethod mcontained(v:array<int>,w:array<int>,n:int,m:int) returns (b:bool)\n//Specify and implement an O(m+n) algorithm that returns b\n//v and w are strictly increasing ordered arrays\n//b is true iff the first n elements of v are contained in the first m elements of w\nrequires n<=m && n>=0\nrequires strictSorted(v[..])\nrequires strictSorted(w[..])\nrequires v.Length >= n && w.Length >= m\nensures b==forall k:: 0<= k< n ==> v[k] in w[..m]//exists j :: 0 <= j < m && v[k] == w[j]\n{\n\tvar i:=0;\n\tvar j:=0;\n\twhile(i<n && j<m && (v[i] >= w[j])) //&& b)\ndecreases w.Length-j\ninvariant i<=j\n\t{\t\n\t\tif(v[i] == w[j]){\n\t\t\ti:=i+1;\n\t\t}\n\t\tj:=j+1;\n\t}\n\tb := i==n;\n}",
            "success": false
        },
        "ironsync-osdi2023_tmp_tmpx80antoe_linear-dafny_docs_DafnyRef_examples_Example-Old.dfy": {
            "state": "class A {\n  var value: int\n  method m(i: int)\n    requires i == 6\n    requires value == 42\n    modifies this\n  {\n    var j: int := 17;\n    value := 43;\n    label L:\n    j := 18;\n    value := 44;\n    label M:\nassert(j + 1 == 19);\n    // value is this.value; 'this' is the same\n    // same reference in current and pre state but the\n    // values stored in the heap as its fields are different;\n    // '.value' evaluates to 42 in the pre-state, 43 at L,\n    // and 44 in the current state\n  }\n}",
            "success": true
        },
        "Dafny_Programs_tmp_tmp99966ew4_binary_search.dfy": {
            "state": "predicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n}\nmethod BinarySearch(a: array<int>, value: int) returns (index: int)\n   requires a != null && 0 <= a.Length && sorted(a)\n   ensures 0 <= index ==> index < a.Length && a[index] == value\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != value\n{\n   var low, high := 0, a.Length;\n   while low < high\n         0 <= i < a.Length && !(low <= i < high) ==> a[i] != value\n   {\n      var mid := (low + high) / 2;\n      if a[mid] < value\n      {\n         low := mid + 1;\n      }\n      else if value < a[mid]\n      {\n         high := mid;\n      }\n      else\n      {\n         return mid;\n      }\n   }\n   return -1;\n}",
            "success": false
        },
        "llm-verified-eval_tmp_tmpd2deqn_i_dafny_161.dfy": {
            "state": "function IsLetter(c: char): bool \n{\n  (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') \n}\nfunction NoLetters(s: string, n: nat): bool \n  requires n <= |s|\n{\n  forall c :: 0 <= c < n ==> !IsLetter(s[c])\n}\nfunction ToggleCase(c: char): char\n{\n  if c >= 'a' && c <= 'z' \n  then \n    (c - 'a' + 'A')\n  else if c >= 'A' && c <= 'Z' \n    then \n      (c - 'A' + 'a')\n    else \n      c\n}\nfunction isReverse(s: string, s_prime: string): bool{\n  (|s| == |s_prime|) &&\n  (forall si :: 0 <= si < |s|/2 ==> s_prime[|s| - si - 1] == s[si])\n}\nmethod Reverse(original: seq<char>) returns (reversed: seq<char>)\n  ensures |reversed| == |original| \n  ensures forall i :: 0 <= i < |original| ==> reversed[i] == original[|original| - 1 - i] \n{\n  reversed := []; \n  var i := |original|;\n  while i > 0\n    decreases i\n    invariant 0 <= i <= |original|\n    invariant  |reversed| == |original| - i\n    invariant forall j :: 0 <= j < |original|-i ==>\n    reversed[j] == original[|original| - 1 - j]\n  {\n    i := i - 1;\n    reversed := reversed + [original[i]]; \n  }\n}\nmethod solve(s: string) returns (result: string)\n  ensures |result| == |s| \n  ensures !NoLetters(s, |s|) ==> forall i :: 0 <= i < |s| && IsLetter(s[i]) ==> result[i] == ToggleCase(s[i])\n  ensures !NoLetters(s, |s|) ==> forall i :: 0 <= i < |s| && !IsLetter(s[i]) ==> result[i] == s[i] \n  ensures NoLetters(s, |s|) ==> isReverse(result, s) \n{\n    var flg : bool := false;\n    result := \"\";\n    for i := 0 to |s|\ninvariant !NoLetters(s, i+1) ==> forall j :: 0 <= j < i+1 && !IsLetter(s[j]) ==> result[j] == s[j]\n    {\n      if IsLetter(s[i])\n      {\n        result := result + [ToggleCase(s[i])];\n        flg := true;\n      } else {\n        result := result + [s[i]];\n      }\n    }\n    if !flg\n    {\n      result := Reverse(s);\n    }\n}",
            "success": false
        },
        "Dafny_Verify_tmp_tmphq7j0row_dataset_C_convert_examples_15.dfy": {
            "state": "method main(n: int, k: int) returns (k_out: int)\n    requires n > 0;\n\trequires k > n;\n\tensures k_out >= 0;\n{\n\tk_out := k;\n    var j: int := 0;\n    while(j < n)\ninvariant j <= n || k >= 1\ninvariant 0 <= j <= n\n    {\n        j := j + 1;\n        k_out := k_out - 1;\n    }\n}\n// C code:\n// MODULE main\n// \tint i;\n// \tint n;\n// \tint j;\n// \tint k;\n// \tassume(n > 0);\n// \tassume(k > n);\n// \tassume(j == 0);\n// \twhile(j < n){\n// \t\tj = j + 1;\n// \t\tk = k - 1;\n// \t}\n// \tassert(k >= 0);\t\n// END MODULE\n// Invariant\n// (\n    // not (or (<= 1 (+ n (+ (* (- 1) j) (* (- 1) k)))) (\n    //     and (<= k (- 1)) (<= (+ n (* (- 1) j)) (- 1)))))",
            "success": false
        },
        "Dafny_Verify_tmp_tmphq7j0row_Generated_Code_Mult.dfy_1.dfy": {
            "state": "method mult(a:int, b:int) returns (x:int)\n  \trequires a >= 0 && b >= 0\n  \tensures x == a * b\n{\n  \tx := 0;\n\tvar y := a;\n  \twhile y > 0\ninvariant x == (a - y) * b\ndecreases y\n\t{\n\t\tx := x + b;\n\t\ty := y - 1;\n\t}\n}",
            "success": true
        },
        "Dafny_Verify_tmp_tmphq7j0row_Generated_Code_ComputePower.dfy_3.dfy": {
            "state": "function Power(n: nat): nat {\n    if n == 0 then 1 else 2 * Power(n - 1)\n}\nmethod ComputePower(n: nat) returns (p: nat)\n    ensures p == Power(n)\n{\n    p := 1;\n    var i := 0;\nassert p == Power(i);\n    while i != n\ninvariant i <= n && p == Power(i)\n    {\n        i := i + 1;\n        p := p * 2;\n    }\n}",
            "success": true
        },
        "Dafny_tmp_tmpv_d3qi10_3_cumsum.dfy": {
            "state": "function sum(a: array<int>, i: int): int\n    requires 0 <= i < a.Length\n    reads a\n{\n    a[i] + if i == 0 then 0 else sum(a, i - 1)\n}\nmethod cumsum(a: array<int>, b: array<int>)\n    requires  a.Length == b.Length && a.Length > 0 && a != b\n    // when you change a  , that's not the same object than b . \n    //requires b.Length > 0 \n    ensures forall i | 0 <= i < a.Length :: b[i] == sum(a, i)\n    modifies b\n{\n    b[0] := a[0]; // Initialise le premier \u00e9l\u00e9ment de b\n    var i := 1;\n    while i < a.Length\n    {\n        b[i] := b[i - 1] + a[i]; // Calcule la somme cumul\u00e9e pour chaque \u00e9l\u00e9ment\n        i := i + 1;\n    }\n}",
            "success": false
        },
        "task_id_412.dfy": {
            "state": "/**\n * Remove odd numbers from an array of numbers\n **/\npredicate IsEven(n: int)\n{\n    n % 2 == 0\n}\nmethod RemoveOddNumbers(arr: array<int>) returns (evenList: seq<int>)\n    // All numbers in the output are even and exist in the input \n    ensures forall i :: 0 <= i < |evenList| ==> IsEven(evenList[i]) && evenList[i] in arr[..]\n    // All even numbers in the input are in the output\n    ensures forall i :: 0 <= i < arr.Length && IsEven(arr[i]) ==> arr[i] in evenList\n{\n    evenList := [];\n    for i := 0 to arr.Length\ninvariant forall k :: 0 <= k < |evenList| ==> IsEven(evenList[k]) && evenList[k] in arr[..]\ninvariant forall k :: 0 <= k < i && IsEven(arr[k]) ==> arr[k] in evenList\n    {\n        if IsEven(arr[i])\n        {\n            evenList := evenList + [arr[i]];\n        }\n    }\n}",
            "success": true
        },
        "task_id_603.dfy": {
            "state": "method LucidNumbers(n: int) returns (lucid: seq<int>)\n    requires n >= 0\n    ensures forall i :: 0 <= i < |lucid| ==> lucid[i] % 3 == 0\n    ensures forall i :: 0 <= i < |lucid| ==> lucid[i] <= n\n    ensures forall i, j :: 0 <= i < j < |lucid| ==> lucid[i] < lucid[j]\n{\n    lucid := [];\n    var i := 0;\n    while i <= n\ninvariant forall k :: 0 <= k < |lucid| ==> lucid[k] % 3 == 0\ninvariant forall i, j :: 0 <= i < j < |lucid| ==> lucid[i] < lucid[j]\n    {\n        if i % 3 == 0 {\n            lucid := lucid + [i];\n        }\n        i := i + 1;\n    }\n}",
            "success": false
        },
        "sat_dfy_tmp_tmpfcyj8am9_dfy_Seq.dfy": {
            "state": "module Seq {\n    function seq_sum(s: seq<int>) : (sum: int)\n    {\n        if s == [] then\n            0\n        else\n            var x := s[0];\n            var remaining := s[1..];\n            x + seq_sum(remaining)\n    }\n    lemma SeqPartsSameSum(s: seq<int>, s1: seq<int>, s2: seq<int>)\n        requires s == s1 + s2\n        ensures seq_sum(s) == seq_sum(s1) + seq_sum(s2)\n    {\n        if s == [] {\n        } else if s1 == [] {\n        } else {\n            var x := s1[0];\n            var s1' := s1[1..];\n            SeqPartsSameSum(s[1..], s1[1..], s2);\n        }\n    }\n    lemma DifferentPermutationSameSum(s1: seq<int>, s2: seq<int>)\n        requires multiset(s1) == multiset(s2)\n        ensures seq_sum(s1) == seq_sum(s2)\n    {\n        if s1 == [] {\n        } else {\n            var x :| x in s1;\n            var i1, i2 :| 0 <= i1 < |s1| && 0 <= i2 < |s2| && s1[i1] == s2[i2] && s1[i1] == x;\nassert s1[..i1+1] == s1[..i1] + s1[i1..i1+1];\nassert s1[..i1] == s1[..i1+1][1..];\n            var remaining1 := s1[..i1] + s1[i1+1..];\n            SeqPartsSameSum(s1[..i1+1], s1[..i1], [x]);\n            SeqPartsSameSum(s1, s1[..i1+1], s1[i1+1..]);\n            SeqPartsSameSum(remaining1, s1[..i1], s1[i1+1..]);\n            var remaining2 := s2[..i2] + s2[i2+1..];\n            SeqPartsSameSum(s2[..i2+1], s2[..i2], [x]);\n            SeqPartsSameSum(s2, s2[..i2+1], s2[i2+1..]);\n            SeqPartsSameSum(remaining2, s2[..i2], s2[i2+1..]);\n            DifferentPermutationSameSum(remaining1, remaining2);\n        }\n    }\n}",
            "success": false
        },
        "online_max_strong.dfy": {
            "state": "method onlineMax(a: array<int>, x: int) returns (ghost m:int, p:int)\n  requires 1<=x<a.Length\n  requires a.Length!=0\n  ensures x<=p<a.Length\n  ensures forall i::0<=i<x==> a[i]<=m\n  ensures exists i::0<=i<x && a[i]==m\n  ensures x<=p<a.Length-1 ==> (forall i::0<=i<p ==> a[i]<a[p])\n  ensures (forall i::x<=i<a.Length && a[i]<=m) ==> p==a.Length-1\n{\n  p:= 0;\n  var best := a[0];\n  var i:=1;\n  while i<x\ninvariant forall j::0<=j<i ==> a[j]<=best\ninvariant (forall j::x<=j<p ==> a[j]<best)\n  {\n    if a[i]>best{\n      best:=a[i];\n    }\n    i:=i+1;\n  }\n  m:=best;\n  i:=x;\n  while i<a.Length\n  {\n    if a[i]>best{\n      p:=i;\n      return;\n    }\n    i:=i+1;\n  }\n  p:=a.Length-1;\n}",
            "success": false
        },
        "cs245-verification_tmp_tmp0h_nxhqp_SortingIssues_FirstAttempt.dfy": {
            "state": "// Sorting: \n//        Pre/Post Condition Issues - An investigation \n//                                      -- Stephanie McIntyre\n// Based on examples in class \n// First Attempt at specifying requirements for sorting array A in incrementing order\n// We want our Hoare triple of (|Pre-Condition|) Code (|Post-Condition|) to hold iff A is properly sorted.\nmethod sort(A: array<int>, n: int)\nmodifies A; requires n==A.Length;\n/* Pre-Condition */   requires n>=0;            \n/* Post-Condition */  ensures forall i,j:: 0<=i<=j<n ==> A[i]<=A[j];  //This states that A is sorted.\n//Can we write code that does not sort A that still satisfies the requirements? \n//Consider the following program:\n{\nassert forall i,j::0<=i<=j<n ==> A[i]<=A[j];\n  var k := 0;\n  while(k<n)\ndecreases n-k;\n  {\n    A[k] := k;\n    k := k+1;\n  }\n}",
            "success": false
        },
        "Dafny_Verify_tmp_tmphq7j0row_AI_agent_verify_examples_ComputePower.dfy": {
            "state": "function Power(n: nat): nat {\n    if n == 0 then 1 else 2 * Power(n - 1)\n}\nmethod ComputePower(N: int) returns (y: nat) requires N >= 0\n    ensures y == Power(N)\n{\n    y := 1;\n    var x := 0; \n    while x != N\ndecreases N - x\n    {\n        x, y := x + 1, y + y;\n    } \n}",
            "success": false
        },
        "dafny-language-server_tmp_tmpkir0kenl_Test_hofs_Requires.dfy": {
            "state": "// RUN: %dafny /compile:3 /print:\"%t.print\" /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\nmethod Main()\n{\n  test0(10);\n\ttest5(11);\n\ttest6(12);\n\ttest1();\n\ttest2();\n}\npredicate valid(x:int)\n{\n  x > 0\n}\nfunction ref1(y:int) : int\n  requires valid(y);\n{\n  y - 1\n}\nlemma assumption1()\n  ensures forall a, b :: valid(a) && valid(b) && ref1(a) == ref1(b) ==> a == b;\n{\n}\nmethod test0(a: int)\n{\n  if ref1.requires(a) {\n    // the precondition should suffice to let us call the method\n    ghost var b := ref1(a);\n  }\n}\nmethod test5(a: int)\n{\n  if valid(a) {\n    // valid(a) is the precondition of ref1\n    assert ref1.requires(a);\n  }\n}\nmethod test6(a: int)\n{\n  if ref1.requires(a) {\n    // the precondition of ref1 is valid(a)\n    assert valid(a);\n  }\n}\nmethod test1()\n{\n  if * {\n    assert forall a, b :: valid(a) && valid(b) && ref1(a) == ref1(b) ==> a == b;\n  } else {\n    assert forall a, b :: ref1.requires(a) && ref1.requires(b) && ref1(a) == ref1(b)\n                          ==> a == b;\n  }\n}\nfunction {:opaque} ref2(y:int) : int        // Now with an opaque attribute\n  requires valid(y);\n{\n  y - 1\n}\nlemma assumption2()\n  ensures forall a, b :: valid(a) && valid(b) && ref2(a) == ref2(b) ==> a == b;\n{\n  reveal ref2();\n}\nmethod test2()\n{\n  assumption2();\n  if * {\n  } else {\nassert forall a, b :: ref2.requires(a) && ref2.requires(b) && ref2(a) == ref2(b)\n                          ==> a == b;\n  }\n}",
            "success": true
        },
        "Dafny-Exercises_tmp_tmpjm75muf__Session6Exercises_ExerciseCountMin.dfy": {
            "state": "function min(v:array<int>,i:int):int\ndecreases i\n reads v\n requires 1<=i<=v.Length\n ensures forall k::0<=k<i==> v[k]>=min(v,i)\n {if (i==1) then v[0]\n  else if (v[i-1]<=min(v,i-1)) then v[i-1]\n  else min(v,i-1)\n  }\nfunction countMin(v:array<int>,x:int, i:int):int\ndecreases i\n reads v\n  requires 0<=i<=v.Length\n  ensures !(x in v[0..i]) ==> countMin(v,x,i)==0\n  {\n   if (i==0) then 0\n   else if (v[i-1]==x) then 1+countMin(v,x,i-1)\n   else countMin(v,x,i-1)\n  }\n method mCountMin(v:array<int>) returns (c:int)\nrequires v.Length>0\nensures c==countMin(v,min(v,v.Length),v.Length)\n//Implement and verify an O(v.Length) algorithm \n{\n  var i:=1;\n  c:=1;\n  var mini:=v[0];\n  while(i<v.Length)\ninvariant 1 <= i <= v.Length && 1 <= c <= i\ninvariant mini==min(v,i) && c == countMin(v,mini,i)\n  {\n    if(v[i]==mini){\n      c:=c + 1;\n    }\n    else if(v[i]<mini){\n      c:=1;\n      mini:=v[i];\n    }\n    i:=i+1;\n  }\n}",
            "success": true
        },
        "Prog-Fun-Solutions_tmp_tmp7_gmnz5f_mockExam2_p5.dfy": {
            "state": "// problem 5:\n// name:      Gabriele Berardi\n// s-number: s4878728\n// table:     XXXX\nghost function f(n: int): int {\n  if n < 0 then 0 else 3*f(n-5) + n\n}\nmethod problem5(n:nat) returns (x: int)\nensures x == f(n)\n{\n    var a := 1;\n    var b := 0;\n    var k := n;\n    while k >= 0\n    {\n        b := a*k + b;\n        a := 3*a;\n        k := k - 5;\n    }\n    x := b;\n}",
            "success": false
        },
        "task_id_18.dfy": {
            "state": "method RemoveChars(s1: string, s2: string) returns (v: string)\n    ensures |v| <= |s1|\n    ensures forall i :: 0 <= i < |v| ==> (v[i] in s1) && !(v[i] in s2)\n    ensures forall i :: 0 <= i < |s1| ==> (s1[i] in s2) || (s1[i] in v)\n{\n    var v' : string := [];\n    for i := 0 to |s1|\ninvariant forall i :: 0 <= i < |v'| ==> (v'[i] in s1) && !(v'[i] in s2)\ninvariant forall i :: 0 <= i <= i - 1 + |v'| ==> (s1[i] in s2) || (s1[i] in v')\n    {\n        if !(s1[i] in s2)\n        {\n            v' := v' + [s1[i]];\n        }\n    }\n    return v';\n}",
            "success": false
        },
        "specTesting_tmp_tmpueam35lx_examples_sort_sort.dfy": {
            "state": "method quickSort(intSeq:array<int>)\n    modifies intSeq\n    ensures forall i:nat, j:nat | 0 <= i <= j < intSeq.Length :: intSeq[i] <= intSeq[j]\n    // ensures multiset(intSeq[..]) == multiset(old(intSeq[..]))\nlemma sort(prevSeq:seq<int>) returns (curSeq:seq<int>)\n    ensures (forall i:nat, j:nat | 0 <= i <= j < |curSeq| :: curSeq[i] <= curSeq[j])\n    ensures multiset(prevSeq) == multiset(curSeq)\npredicate post_sort(prevSeq:seq<int>, curSeq:seq<int>)\n{\n    && (forall i:nat, j:nat | 0 <= i <= j < |curSeq| :: curSeq[i] <= curSeq[j])\n    && multiset(prevSeq) == multiset(curSeq)\n}\nlemma multisetAdditivity(m1:multiset<int>, m2:multiset<int>, m3:multiset<int>, m4:multiset<int>)\n    requires m1 == m2 + m3\n    requires m1 == m2 + m4\n    ensures m3 == m4\n    {\n    }\nlemma twoSortedSequencesWithSameElementsAreEqual(s1:seq<int>, s2:seq<int>)\n    requires (forall i:nat, j:nat | 0 <= i <= j < |s1| :: s1[i] <= s1[j])\n    requires (forall i:nat, j:nat | 0 <= i <= j < |s2| :: s2[i] <= s2[j])\n    requires multiset(s1) == multiset(s2)\n    requires |s1| == |s2|\n    ensures s1 == s2\n{\n    if (|s1| != 0) {\n        if s1[|s1|-1] == s2[|s2|-1] {\n            multisetAdditivity(multiset(s1), multiset([s1[|s1|-1]]), multiset(s1[..|s1|-1]), multiset(s2[..|s1|-1]));\n        }\n        twoSortedSequencesWithSameElementsAreEqual(s1[..|s1|-1], s2[..|s2|-1]);\n        } else if s1[|s1|-1] < s2[|s2|-1] {\n        } else {\n        }\n    }\n}\nlemma sort_determinisitc(prevSeq:seq<int>, curSeq:seq<int>, curSeq':seq<int>)\n    requires post_sort(prevSeq, curSeq)\n    requires post_sort(prevSeq, curSeq')\n    ensures curSeq == curSeq'\n{\n    if (|curSeq| != |curSeq'|) {\n    } else {\n        twoSortedSequencesWithSameElementsAreEqual(curSeq, curSeq');\n    }\n}\nlemma sort_determinisitc1(prevSeq:seq<int>, curSeq:seq<int>, curSeq':seq<int>)\n    requires prevSeq == [5,4,3,2,1]\n    requires post_sort(prevSeq, curSeq)\n    requires post_sort(prevSeq, curSeq')\n    ensures curSeq == curSeq'\n{\n}",
            "success": false
        },
        "reverse_strong.dfy": {
            "state": "method reverse(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[a.Length - 1 - i])\n{\n  var i := 0;\n  while i <a.Length / 2\ninvariant forall j :: i <= j < a.Length/2 ==> a[j] == old(a[a.Length-1-j])\ndecreases a.Length - i\n  {\n    a[i], a[a.Length-1-i] := a[a.Length-1-i], a[i];\n    i := i + 1;\n  }\n}",
            "success": false
        },
        "task_id_94.dfy": {
            "state": "method MinSecondValueFirst(s: array<seq<int>>) returns (firstOfMinSecond: int)\n    requires s.Length > 0\n    requires forall i :: 0 <= i < s.Length ==> |s[i]| >= 2\n    ensures exists i :: 0 <= i < s.Length && firstOfMinSecond == s[i][0] && \n        (forall j :: 0 <= j < s.Length ==> s[i][1] <= s[j][1])\n{\n    var minSecondIndex := 0;\n    for i := 1 to s.Length\n    {\n        if s[i][1] < s[minSecondIndex][1]\n        {\n            minSecondIndex := i;\n        }\n    }\n    firstOfMinSecond := s[minSecondIndex][0];\n}",
            "success": false
        },
        "task_id_113.dfy": {
            "state": "predicate IsDigit(c: char)\n{\n    48 <= c as int <= 57\n}\nmethod IsInteger(s: string) returns (result: bool)\n    ensures result <==> (|s| > 0) && (forall i :: 0 <= i < |s| ==> IsDigit(s[i]))\n{\n    result := true;\n    if |s| == 0 {\n        result := false;\n    } else {\n        for i := 0 to |s|\ninvariant (forall j :: 0 <= j < i ==> IsDigit(s[j]))\n        {\n            if !IsDigit(s[i]) {\n                result := false;\n                break;\n            }\n        }\n    }\n}",
            "success": true
        },
        "Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Exercise4_Find_Max.dfy": {
            "state": "method findMax(a:array<int>) returns (pos:int, maxVal: int)\n  requires a.Length > 0;\n  requires forall i :: 0 <= i < a.Length ==> a[i] >= 0;\n  ensures forall i :: 0 <= i < a.Length ==> a[i] <= maxVal;\n  ensures exists i :: 0 <= i < a.Length &&  a[i] == maxVal;\n  ensures 0 <= pos < a.Length\n  ensures a[pos] == maxVal;\n{\n  pos := 0;\n  maxVal := a[0];\n  var j := 1;\n  while(j < a.Length)\ninvariant forall i :: 0 <= i < j ==> a[i] <= maxVal;\ninvariant 0 <= j <= a.Length\n  {\n    if (a[j] > maxVal) \n    {\n      maxVal := a[j];\n      pos := j;\n    }\n    j := j+1;\n  }\n  return;\n}",
            "success": false
        },
        "task_id_759.dfy": {
            "state": "method IsDecimalWithTwoPrecision(s: string) returns (result: bool)\n    ensures result ==> (exists i :: 0 <= i < |s| && s[i] == '.' && |s| - i - 1 == 2)\n    ensures !result ==> !(exists i :: 0 <= i < |s| && s[i] == '.' && |s| - i - 1 == 2)\n{\n    result := false;\n    for i := 0 to |s|\ninvariant result ==> (exists k :: 0 <= k < i && s[k] == '.' && |s| - k - 1 == 2)\n    {\n        if s[i] == '.' && |s| - i - 1 == 2 {\n            result := true;\n            break;\n        }\n    }\n}",
            "success": false
        },
        "Dafny_tmp_tmpmvs2dmry_pancakesort_flip.dfy": {
            "state": "// flips (i.e., reverses) array elements in the range [0..num]\nmethod flip (a: array<int>, num: int)\nrequires a.Length > 0;\nrequires 0 <= num < a.Length;\nmodifies a;\nensures forall k :: 0 <= k <= num ==> a[k] == old(a[num-k])\nensures forall k :: num < k < a.Length ==> a[k] == old(a[k])\n// ensures multiset(a[..]) == old(multiset(a[..]))\n{\n  var tmp:int;\n  var i := 0;\n  var j := num;\n  while (i < j)\ninvariant forall k :: num < k <= i ==> a[k] == old(a[k])\ninvariant forall k :: i <= k < j ==> a[k] == old(a[k])\n  // invariant 0 <= i < j <= num\n  {\n    tmp := a[i];\n    a[i] := a[j];\n    a[j] := tmp;\n    i := i + 1;\n    j := j - 1;\n  }\n}",
            "success": false
        },
        "is_palindrome_strong.dfy": {
            "state": "method IsPalindrome(x: seq<char>) returns (result: bool)\n  ensures result <==> (forall i :: 0 <= i < |x| ==> x[i] == x[|x| - i - 1])\n{\n  if |x|==0 {\n    return true;\n  }\n  var i := 0;\n  var j := |x| - 1;\n  result := true;\n  while (i < j)\ninvariant i <= j\ninvariant result <==> (forall s :: 0 <= s < i ==> x[s] == x[|x| - s - 1])\n  {\n    if x[i] != x[j] {\n      result := false;\n      return;\n    }\n    i := i + 1;\n    j := j - 1;\n  }\n}",
            "success": false
        },
        "Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExercisePositive.dfy": {
            "state": "predicate positive(s:seq<int>)\n{forall u::0<=u<|s| ==> s[u]>=0}\nmethod mpositive(v:array<int>) returns (b:bool)\nensures b==positive(v[0..v.Length])\n{\n    var i:=0;\n    //1. assert positive(v[..0])\n    while i<v.Length && v[i]>=0\n        decreases v.Length - i \n        invariant 0<=i<=v.Length\n        invariant positive(v[..i])\n    {\n        //2. assert 0<=i<v.Length && positive(v[..i]);\n        i:=i+1;\n        //2. assert 0<=i<v.Length && positive(v[..i]);\n    }\n    //3. assert i==v.Length ==> positive(v[..]);\n    //3. assert i<v.Length => v[i]<0;\n    b := i==v.Length;\n}\nmethod mpositive3(v:array<int>) returns (b:bool)\nensures b==positive(v[0..v.Length])\n{\n    var i:=0; b:=true;\n    while(i<v.Length && b)\n        decreases v.Length - i \n        invariant 0 <= i <= v.Length\n        invariant b==positive(v[0..i])\n        invariant !b ==> !positive(v[0..v.Length])\n    {\n        b:=v[i]>=0;\n        i:=i+1;\n    }\n}\nmethod mpositive4(v:array<int>) returns (b:bool)\nensures b==positive(v[0..v.Length])\n{\n    var i:=0; b:=true;\n    while(i<v.Length && b)\n        decreases v.Length - i \n        invariant 0 <= i <= v.Length\n        invariant b==positive(v[0..i])\n        invariant !b ==> !positive(v[0..v.Length])\n    {\n        b:=v[i]>=0;\n        i:=i+1;\n    }\n}\nmethod mpositivertl(v:array<int>) returns (b:bool)\nensures b==positive(v[0..v.Length])\n{\n    var i:=v.Length-1;\n    while(i>=0 && v[i]>=0)\ndecreases i\ndecreases v.Length -i\n    {\n        i:=i-1;\n    }\n    b:= i==-1;\n}",
            "success": false
        },
        "task_id_579.dfy": {
            "state": "predicate InArray(a: array<int>, x: int)\n    reads a\n{\n    exists i :: 0 <= i < a.Length && a[i] == x\n}\nmethod DissimilarElements(a: array<int>, b: array<int>) returns (result: seq<int>)\n    // All elements in the output are either in a or b, but not in both or neither\n    ensures forall x :: x in result ==> (InArray(a, x) != InArray(b, x))\n    // The elements in the output are all different\n    ensures forall i, j :: 0 <= i < j < |result| ==> result[i] != result[j]\n{\n    var res: seq<int> := [];\n    for i := 0 to a.Length\n    {\n        if !InArray(b, a[i]) && a[i] !in res\n        {\n            res := res + [a[i]];\n        }\n    }\n    ghost var partialSize := |res|;\nassert partialSize == |res|;\n    for i := 0 to b.Length\ninvariant forall k, l :: 0 <= k < l < partialSize ==> res[k] != res[l]\n    {\n        if !InArray(a, b[i]) && b[i] !in res\n        {\n            res := res + [b[i]];\n        }\n    }\n    result := res;\n}",
            "success": false
        },
        "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_vampire project_original_Searching.dfy": {
            "state": "// Assuming Array is Object Blood\n// Blood Array<int>\n// index\nmethod Find(blood: array<int>, key: int) returns (index: int)\nrequires blood != null\nensures 0 <= index ==> index < blood.Length && blood[index] == key\nensures index < 0 ==> forall k :: 0 <= k < blood.Length ==> blood[k] != key\n{\n   index := 0;\n   while index < blood.Length\ndecreases blood.Length - index\n   {\n      if blood[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n}",
            "success": false
        },
        "Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_normal_data_completion_MaxPerdV2.dfy": {
            "state": "function contains(v: int, a: array<int>, n: int): bool\nreads a\n  requires n <= a.Length\n{\n  exists j :: 0 <= j < n && a[j] == v\n}\nfunction upper_bound(v: int, a: array<int>, n: int): bool\nreads a\n  requires n <= a.Length\n{\n  forall j :: 0 <= j < n ==> a[j] <= v\n}\nfunction is_max(m: int, a: array<int>, n: int): bool\nreads a\n  requires n <= a.Length\n{\n  contains(m, a, n) && upper_bound(m, a, n)\n}\nmethod max(a: array<int>, n: int) returns (max: int)\n  requires 0 < n <= a.Length;\n  ensures is_max(max, a, n);\n{\n  var i: int := 1;\n  max := a[0];\n  while i < n\ninvariant 1 <= i <= n\ninvariant is_max(max, a, i)\n  {\n    if a[i] > max {\n      max := a[i];\n    }\n    i := i + 1;\n  }\n}",
            "success": true
        },
        "count_lessthan_strong.dfy": {
            "state": "method CountLessThan(numbers: set<int>, threshold: int) returns (count: int)\n  ensures count == |set i | i in numbers && i < threshold|\n{\n  count := 0;\n  var shrink := numbers;\n  var grow := {};\n  while |shrink | > 0\n  {\n    var i: int :| i in shrink;\n    shrink := shrink - {i};\n    var grow' := grow+{i};\n           (set i | i in grow && i < threshold )+ if i < threshold then {i} else {};\n    grow := grow + {i};\n    if i < threshold {\n      count := count + 1;\n    }\n  }\n}",
            "success": false
        },
        "Metodos_Formais_tmp_tmpql2hwcsh_Invariantes_multiplicador.dfy": {
            "state": "// Exemplo de invariantes\n// Invariante significa que o valor n\u00e3o muda desde a pr\u00e9-condi\u00e7\u00e3o at\u00e9 a p\u00f3s-condi\u00e7\u00e3o\nmethod Mult(x:nat, y:nat) returns (r:nat)\nensures r == x * y\n{\n    // par\u00e2metros de entrada s\u00e3o imut\u00e1veis, por isso\n    // \u00e9 preciso a atribuir a vari\u00e1veis locais para usar em blocos de c\u00f3digos para mudar\n    var m := x;\n    var n := y;\nassert  n == 3;\n    r := 0;\n    while m > 0 \ninvariant r == m * n + r //invariante que requer\n    {\n        r := r + n;\n        m := m -1;\n    }\n    return r;\n}\n// Teste do m\u00e9todo para encontrar a invariante\n// x | y | m | n | r\n// 5 | 3 | 5 | 3 | 0\n// 5 | 3 | 4 | 3 | 3\n// 5 | 3 | 3 | 3 | 6\n// 5 | 3 | 2 | 3 | 9\n// 5 | 3 | 1 | 3 | 12\n// 5 | 3 | 0 | 3 | 15\n// vimos o seguinte:\n// m * n + r = x * y\n// 5 * 3 + 0 (15) = 5 * 3 (15)\n// portanto a f\u00f3rmula m*n+r == x*y \u00e9 uma invariante\n// mas s\u00f3 isso n\u00e3o serve, o m ele \u00e9 maior ou igual a zero quando acaba o while\n// por isso, tamb\u00e9m \u00e9 a invariante que necessita\n// com isso dizemos para o programa as altera\u00e7\u00f5es do m de maior ou igual a zero\n// e mostramos a fun\u00e7\u00e3o encontrada que alterava o valor de m e n das variaveis criadas\n// SE OS ALGORITMOS TIVEREM REPETI\u00c7\u00c3O OU RECURS\u00c3O, DEVEM SER MOSTRADOS QUAIS S\u00c3O AS INVARIANTES\n// OU SEJA, OS VALORES QUE N\u00c3O EST\u00c3O SENDO MUDADOS E COLOCAR A F\u00d3RMULA DELE COMO ACIMA",
            "success": false
        },
        "t1_MF_tmp_tmpi_sqie4j_exemplos_introducao_ex4.dfy": {
            "state": "function Fat(n: nat): nat\n{\n   if n == 0 then 1 else n * Fat(n-1)\n}\nmethod Fatorial(n:nat)  returns (r:nat)\n  ensures r == Fat(n)\n{\n    r := 1;\n    var i := 0;\nassert 0 <= i <= n && 1 <= r <= Fat(n);\n    while i < n\ninvariant 0 <= i <= n && 1 <= r <= Fat(n)\n    {\n        i := i + 1;\n        r := r * i;\n    }\n}",
            "success": false
        },
        "HATRA-2022-Paper_tmp_tmp5texxy8l_copilot_verification_Two Sum_two_sum.dfy": {
            "state": "method twoSum(nums: array<int>, target: int) returns (index1: int, index2: int)\n    requires 2 <= nums.Length\n    requires exists i, j :: (0 <= i < j < nums.Length && nums[i] + nums[j] == target)\n    ensures index1 != index2\n    ensures 0 <= index1 < nums.Length\n    ensures 0 <= index2 < nums.Length\n    ensures nums[index1] + nums[index2] == target\n{\n    var i := 0;\n    while i < nums.Length\n    {\n        var j := i + 1;\n        while j < nums.Length\ninvariant nums[i] + nums[j] != target\ninvariant exists k :: i <= k < nums.Length && nums[i] + nums[k] == target\n        {\n            if nums[i] + nums[j] == target\n            {\n                return i, j;\n            } \n            j := j + 1;\n        }\n        i := i + 1;\n    }\n}",
            "success": false
        },
        "task_id_793.dfy": {
            "state": "method LastPosition(arr: array<int>, elem: int) returns (pos: int)\n    requires arr.Length > 0\n    requires forall i, j :: 0 <= i < j < arr.Length ==> arr[i] <= arr[j]\n    ensures pos == -1 || (0 <= pos < arr.Length && arr[pos] == elem && (pos <= arr.Length - 1 || arr[pos + 1] > elem))\n    ensures forall i :: 0 <= i < arr.Length ==> arr[i] == old(arr[i])\n{\n    pos := -1;\n    for i := 0 to arr.Length - 1\ninvariant pos == -1 || (0 <= pos < arr.Length && arr[pos] == elem && (pos <= i || arr[i] > elem))\n    {\n        if arr[i] == elem\n        {\n            pos := i;\n        }\n    }\n}",
            "success": true
        },
        "dafny-language-server_tmp_tmpkir0kenl_Test_vstte2012_Two-Way-Sort.dfy": {
            "state": "// RUN: %dafny /compile:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n// This method is a slight generalization of the\n// code provided in the problem statement since it\n// is generic in the type of the array elements.\nmethod swap<T>(a: array<T>, i: int, j: int)\n  requires 0 <= i < j < a.Length\n  modifies a\n  ensures a[i] == old(a[j])\n  ensures a[j] == old(a[i])\n  ensures forall m :: 0 <= m < a.Length && m != i && m != j ==> a[m] == old(a[m])\n  ensures multiset(a[..]) == old(multiset(a[..]))\n{\n  var t := a[i];\n  a[i] := a[j];\n  a[j] := t;\n}\n// This method is a direct translation of the pseudo\n// code given in the problem statement.\n// The first postcondition expresses that the resulting\n// array is sorted, that is, all occurrences of \"false\"\n// come before all occurrences of \"true\".\n// The second postcondition expresses that the post-state\n// array is a permutation of the pre-state array. To express\n// this, we use Dafny's built-in multisets. The built-in\n// function \"multiset\" takes an array and yields the\n// multiset of the array elements.\n// Note that Dafny guesses a suitable ranking function\n// for the termination proof of the while loop.\n// We use the loop guard from the given pseudo-code.  However,\n// the program also verifies with the stronger guard \"i < j\"\n// (without changing any of the other specifications or\n// annotations).\nmethod two_way_sort(a: array<bool>)\n  modifies a\n  ensures forall m,n :: 0 <= m < n < a.Length ==> (!a[m] || a[n])\n  ensures multiset(a[..]) == old(multiset(a[..]))\n{\n  var i := 0;\n  var j := a.Length - 1;\n  while (i <= j)\ndecreases j - i // termination proof starts here\ninvariant multiset(a[..]) == old(multiset(a[..]))\n  {\n    if (!a[i]) {\n      i := i+1;\n    } else if (a[j]) {\n      j := j-1;\n    } else {\n      swap(a, i, j);\n      i := i+1;\n      j := j-1;\n    }\n  }\n}",
            "success": false
        }
    },
    {
        "Prog-Fun-Solutions_tmp_tmp7_gmnz5f_mockExam2_p6.dfy": {
            "state": "// problem 6:\n// name:      Gabriele Berardi\n// s-number: s4878728\n// table:     XXXXX\nghost function f(n: int): int {\n  if n <= 0 then 1 else n + f(n-1)*f(n-2)\n}\nghost function fSum(n: nat): int {\n // give the body of this function\n  // it should return Sum(i: 0<=i < n: f(i))\n  if n <= 0 then 0 else f(n-1) + fSum(n-1)\n}\nmethod problem6(n:nat) returns (a: int)\nensures a == fSum(n)\n{\n  a := 0;\n  var k := 0;\n  var x := 1;\n  var y := 2;\n  while k < n\ndecreases n - k\ninvariant x == f(k-1)\n  {\n    k := k + 1;\n    a := a + x;\n    x, y := y, k+1 + x*y;    \n  }\n}",
            "success": false
        },
        "dafny-exercise_tmp_tmpouftptir_appendArray.dfy": {
            "state": "method appendArray(a: array<int>, b: array<int>) returns (c: array<int>)\nensures c.Length == a.Length + b.Length\nensures forall i :: 0 <= i < a.Length ==> a[i] == c[i]\nensures forall i :: 0 <= i < b.Length ==> b[i] == c[a.Length + i]\n{\n\tc := new int[a.Length + b.Length];\n\tvar i := 0;\n\twhile i < a.Length\ninvariant forall i :: a.Length <= i < b.Length + a.Length ==> c[i] == b[i - a.Length]\ninvariant a[..i] == c[..a.Length + i]\n\t{\n\t\tc[i] := a[i];\n\t\ti := i + 1;\n\t}\n\twhile i < b.Length + a.Length\n\t{\n\t\tc[i] := b[i - a.Length];\n\t\ti := i + 1;\n\t}\n}",
            "success": false
        },
        "task_id_573.dfy": {
            "state": "method UniqueProduct (arr: array<int>) returns (product: int)\n   ensures product == SetProduct((set i | 0 <= i < arr.Length :: arr[i]))\n{\n    var p := 1;\n    var seen: set<int> := {};\n    for i := 0 to arr.Length\n        invariant 0 <= i <= arr.Length\n        invariant seen == (set k | 0 <= k < i :: arr[k])\n        invariant p == SetProduct((set k | 0 <= k < i :: arr[k]))\n    {\n        if ! (arr[i] in seen) {\n            seen := seen + { arr[i] };\n            p := p * arr[i];\n            SetProductLemma(seen, arr[i]);\n        }\n    }\n    product := p;\n}\nghost function SetProduct(s : set<int>) : int\n{\n    if s == {} then 1\n    else var x :| x in s; \n         x * SetProduct(s - {x})\n}\n/* \n * This is necessary because, when we add one element, we need to make sure\n * that the product of the new set, as a whole, is the same as the product\n * of the old set times the new element.\n */\nlemma SetProductLemma(s: set <int>, x: int) \n requires x in s\n ensures SetProduct(s - {x}) * x == SetProduct(s)\n{\n   if s != {}\n   {\nassert s == s - {x} + {x};\n      var y :| y in s && y * SetProduct(s - {y}) == SetProduct(s);\n      if y == x {}\n      else {\n         calc {\n            SetProduct(s);\n            y * SetProduct(s - {y});\n            { SetProductLemma(s - {y}, x); }\n            y * x * SetProduct(s - {y} - {x});\n            { assert s - {x} - {y} == s - {y} - {x};}\n            y * x * SetProduct(s - {x} - {y});\n            x * y * SetProduct(s - {x} - {y});\n            { SetProductLemma(s - {x}, y); }\n            x * SetProduct(s - {x});\n         }\n      }\n   }\n}",
            "success": true
        },
        "task_id_769.dfy": {
            "state": "method Difference(a: seq<int>, b: seq<int>) returns (diff: seq<int>)\n    ensures forall x :: x in diff <==> (x in a && x !in b)\n    ensures forall i, j :: 0 <= i < j < |diff| ==> diff[i] != diff[j]\n{\n    diff := [];\n    for i := 0 to |a|\ninvariant forall k :: 0 <= k < i ==> a[k] in b ==> a[k] in diff\ninvariant forall k, l :: 0 <= k < l < |diff| ==> diff[k] != diff[l]\ninvariant forall k :: 0 <= k < i ==> a[k] !in b ==> a[k] !in diff\n    {\n        if a[i] !in b && a[i] !in diff\n        {\n            diff := diff + [a[i]];\n        }\n    }\n}",
            "success": false
        },
        "Dafny_Programs_tmp_tmp99966ew4_lemma.dfy": {
            "state": "lemma SkippingLemma(a : array<int>, j : int)\n   requires a != null\n   requires forall i :: 0 <= i < a.Length ==> 0 <= a[i]\n   requires forall i :: 0 < i < a.Length ==> a[i-1]-1 <= a[i]\n   requires 0 <= j < a.Length\n   ensures forall k :: j <= k < j + a[j] && k < a.Length ==> a[k] != 0\n{\n   var i := j;\n   while i < j + a[j] && i < a.Length\n   decreases j + a[j] - i\n      invariant i < a.Length ==> a[j] - (i-j) <= a[i]\n      invariant forall k :: j <= k < i && k < a.Length ==> a[k] != 0\n   {\n      i := i + 1;\n   }\n}\nmethod FindZero(a: array<int>) returns (index: int)\n   requires a != null\n   requires forall i :: 0 <= i < a.Length ==> 0 <= a[i]\n   requires forall i :: 0 < i < a.Length ==> a[i-1]-1 <= a[i]\n   ensures index < 0  ==> forall i :: 0 <= i < a.Length ==> a[i] != 0\n   ensures 0 <= index ==> index < a.Length && a[index] == 0\n{\n   index := 0;\n   while index < a.Length\ninvariant forall i :: 0 <= i < index && i < a.Length ==> a[i] != 0\ninvariant index < a.Length ==> forall k :: 0 <= k < index && k < a.Length ==> a[k] != 0\n   {\n      if a[index] == 0 { return; }\n      SkippingLemma(a, index);\n      index := index + a[index];\n   }\n   index := -1;\n}",
            "success": true
        },
        "Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 3_InsertionSortMultiset.dfy": {
            "state": "// H\u00f6fundur spurningar:  Snorri Agnarsson, snorri@hi.is\n// Permalink spurningar: https://rise4fun.com/Dafny/G4sc3\n// H\u00f6fundur lausnar:     Alexander Gu\u00f0mundsson\n// Permalink lausnar:    https://rise4fun.com/Dafny/nujsu\n// Insertion sort me\u00f0 hj\u00e1lp helmingunarleitar.\nmethod Search( s: seq<int>, x: int ) returns ( k: int )\n    // Ekki m\u00e1 breyta forskilyr\u00f0um e\u00f0a eftirskilyr\u00f0um fallsins\n    requires forall p,q | 0 <= p < q < |s| :: s[p] <= s[q];\n    ensures 0 <= k <= |s|;\n    ensures forall i | 0 <= i < k :: s[i] <= x;\n    ensures forall i | k <= i < |s| :: s[i] >= x;\n    ensures forall z | z in s[..k] :: z <= x;\n    ensures forall z | z in s[k..] :: z >= x;\n    ensures s == s[..k]+s[k..];\n{\n    // Setji\u00f0 vi\u00f0eigandi stofn fallsins h\u00e9r.\n    var p := 0;\n    var q := |s|;\n    if p == q\n    {\n        return p;\n    }\n    while p != q \n        decreases q-p;\n        invariant 0 <= p <= q <= |s|;\n        invariant forall r | 0 <= r < p :: s[r] <= x;\n        invariant forall r | q <= r < |s| :: s[r] >= x;\n    {\n        var m := p + (q-p)/2;\n        if s[m] == x\n        {\n            return m;\n        }\n        if s[m] < x\n        {\n            p := m+1;\n        }\n        else\n        {\n            q := m;\n        }\n    }\n    return p;\n}\nmethod Sort( m: multiset<int> ) returns ( r: seq<int> )\n    ensures multiset(r) == m;\n    ensures forall p,q | 0 <= p < q < |r| :: r[p] <= r[q];\n{\n    // Setji\u00f0 vi\u00f0eigandi frumstillingu \u00e1 r og rest h\u00e9r.\n    // r er skilabreyta en rest er n\u00fd breyta sem \u00fei\u00f0 b\u00fai\u00f0 til.\n    r := [];\n    var rest := m;\n    while rest != multiset{}\ninvariant forall p,q | 0 <= p < q < |r| :: r[p] <= r[q];\ndecreases rest;\n        // Ekki breyta fastayr\u00f0ingu lykkju\n    {\n        // Setji\u00f0 vi\u00f0eigandi stofn lykkjunnar h\u00e9r.\n        // Fjarl\u00e6gi\u00f0 eitt gildi \u00far rest me\u00f0\n        //    var x :| x in rest;\n        //    rest := rest-multiset{x};\n        // og noti\u00f0 Search til a\u00f0 finna r\u00e9ttan sta\u00f0\n        // \u00ed r til a\u00f0 stinga [x] inn \u00ed r.\n        var x :| x in rest;\n        rest := rest - multiset{x};\n        var k := Search(r, x);\n        r := r[..k] + [x] + r[k..];\n    }\n    return r;\n}",
            "success": false
        },
        "Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseFirstNegative.dfy": {
            "state": "predicate positive(s:seq<int>)\n{forall u::0<=u<|s| ==> s[u]>=0}\nmethod mfirstNegative(v:array<int>) returns (b:bool, i:int)\nensures b <==> exists k::0<=k<v.Length && v[k]<0\nensures b ==> 0<=i<v.Length && v[i]<0 && positive(v[0..i])\n{ \n i:=0;\n b:=false;\n while (i<v.Length && !b)\n    invariant 0<=i<=v.Length\n    invariant b <==> exists k::0<=k<i && v[k]<0\n    invariant b ==> v[i-1]<0 && positive(v[0..i-1])\n    decreases v.Length - i\n  { \n    b:=(v[i]<0);\n    i:=i+1;\n   }\n  if (b){i:=i-1;}\n}\nmethod mfirstNegative2(v:array<int>) returns (b:bool, i:int)\nensures b <==> exists k::0<=k<v.Length && v[k]<0\nensures b ==> 0<=i<v.Length && v[i]<0 && positive(v[0..i])\n{ \n i:=0;b:=false;\n while (i<v.Length && !b)\ninvariant b <==> exists k::0<=k<i && v[k]<0\ninvariant 0<=i<=v.Length\ninvariant b ==> v[i-1]<0 && positive(v[0..i-1])\n  { \n    b:=(v[i]<0);\n    if (!b) {i:=i+1;}\n   }\n}",
            "success": false
        },
        "Metodos_Formais_tmp_tmpbez22nnn_Aula_2_ex1.dfy": {
            "state": "method Mult(x:nat, y:nat) returns (r: nat)\nensures r == x * y\n{\n    var m := x;\nassert m == x; // x has the right value\n    var n := y;\nassert r == x*y-n; // r still has the right value\n    r:=0;\n    while m > 0\ndecreases m\n    {\n        r := r + n;\n        m := m - 1;\n    }\n    return r;\n}",
            "success": false
        },
        "insert_strong.dfy": {
            "state": "method insert(line:array<char>, l:int, nl:array<char>, p:int, at:int)\n  requires 0 <= l+p <= line.Length\n  requires 0 <= p <= nl.Length\n  requires 0 <= at <= l\n  modifies line\n  ensures forall i :: (0<=i<p) ==> line[at+i] == nl[i]\n  ensures forall i :: (0<=i<at) ==> line[i] == old(line[i])\n  ensures forall i :: (at+p<=i<l+p) ==> line[i] == old(line[i-p])\n{\n  ghost var initialLine := line[..];\n  var i:int := l;\n  while(i>at)\ninvariant forall i :: (i < p || at+i < l) ==> line[at+i] == (if i<p then nl[i] else line[i])\ndecreases i\n  {\n    i := i - 1;\n    line[i+p] := line[i];\n  }\n  i := 0;\n  while(i<p)\n  {\n    line[at + i] := nl[i];\n    i := i + 1;\n  }\n}",
            "success": false
        },
        "task_id_743.dfy": {
            "state": "method RotateRight(l: seq<int>, n: int) returns (r: seq<int>)\n    requires n >= 0\n    ensures |r| == |l|\n    ensures forall i :: 0 <= i < |l| ==> r[i] == l[(i - n + |l|) % |l|]\n{\n    var rotated: seq<int> := [];\n    for i := 0 to |l|\ninvariant |rotated| == i\ninvariant forall j :: 0 <= j < i ==> rotated[j] == l[(j - n + |l|) % |l|]\n    {\n        rotated := rotated + [l[(i - n + |l|) % |l|]];\n    }\n    return rotated;\n}",
            "success": true
        },
        "Dafny_Verify_tmp_tmphq7j0row_Test_Cases_solved_1_select.dfy": {
            "state": "method SelectionSort(a: array<int>)\n  modifies a\n  ensures forall i,j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures multiset(a[..]) == old(multiset(a[..]))\n{\n  var n := 0;\n  while n != a.Length\n  {\n    var mindex, m := n, n;\n    while m != a.Length\ninvariant forall i :: n <= i < m ==> a[mindex] <= a[i]\n    {\n      if a[m] < a[mindex] {\n        mindex := m;\n      }\n      m := m + 1;\n    }\n    if a[mindex] < a[n] {\n      a[mindex], a[n] := a[n], a[mindex];\n    }\n    n := n + 1;\n  }  \n}",
            "success": false
        },
        "task_id_414.dfy": {
            "state": "method AnyValueExists(seq1: seq<int>, seq2: seq<int>) returns (result: bool)\n    ensures result <==> (exists i :: 0 <= i < |seq1| && seq1[i] in seq2)\n{\n    result := false;\n    for i := 0 to |seq1|\ninvariant result <==> (exists k :: 0 <= k < i && seq1[k] in seq2)\n    {\n        if seq1[i] in seq2 {\n            result := true;\n            break;\n        }\n    }\n}",
            "success": true
        },
        "Correctness_tmp_tmpwqvg5q_4_MethodCalls_q1.dfy": {
            "state": "/**\n  (a) Verify whether or not the following program\n      satisfies total correctness.\n      You should use weakest precondition reasoning\n      and may extend the loop invariant if required.\n      You will need to add a decreases clause to prove termination\n  (a) Weakest precondition proof (without termination) (6 marks)\n      Termination proof (2marks)\n*/\nfunction fusc(n: int): nat\nlemma rule1()\n  ensures fusc(0) == 0\nlemma rule2()\n  ensures fusc(1) == 1\nlemma rule3(n:nat)\n  ensures fusc(2*n) == fusc(n)\nlemma rule4(n:nat)\n  ensures fusc(2*n+1) == fusc(n) + fusc(n+1)\nmethod ComputeFusc(N: int) returns (b: int)\n  requires N >= 0 \n  ensures b == fusc(N)\n{\n  b := 0;\n  var n, a := N, 1;\n  while (n != 0)\n  {\n    ghost var d := n; // termination metric\n    if (n % 2 == 0)\n    {\n      rule4(n/2);\n      rule3(n/2);\n      a := a + b;\n      n := n / 2;\n    } else {\n      rule4((n-1)/2);\n      rule3((n-1)/2);\n      rule3((n+1)/2);\n              b * fusc(n) - b  * fusc(n) + b  * fusc(((n-1)/2)+1) + a * fusc(n);\n              b * fusc(n) - b  * (fusc(n) - fusc(((n-1)/2)+1)) + a * fusc(n);\n              a * fusc(n - 1) + b  * fusc(n) - b  * fusc(n-1) + a * fusc(n) - a * fusc(n-1);\n      b := b + a;\n      n := (n - 1) / 2;\n    }\n  }\n  rule1();\n  rule2();\n}",
            "success": false
        },
        "Workshop_tmp_tmp0cu11bdq_Workshop_Answers_Question6.dfy": {
            "state": "method arrayUpToN(n: int) returns (a: array<int>)\n    requires n >= 0\n    ensures a.Length == n\n    ensures forall j :: 0 < j < n ==> a[j] >= 0\n    ensures forall j, k : int :: 0 <= j <= k < n ==> a[j] <= a[k]\n{\n    var i := 0;\n    a := new int[n];\n    while i < n\ndecreases n - i\ninvariant forall j, k :: 0 <= j <= k < i ==> a[j] <= a[k]\n    {\n        a[i] := i;\n        i := i + 1;\n    }\n}",
            "success": false
        },
        "Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_50_examples_SumArray.dfy": {
            "state": "function Sum(arr: array<int>, len: int): int\n    reads arr\n    requires arr.Length > 0 && 0 <= len <= arr.Length\n{\n    if len == 0 then 0 else arr[len-1] + Sum(arr, len-1)\n}\nmethod SumArray(arr: array<int>) returns (sum: int)\n    requires arr.Length > 0\n    ensures sum == Sum(arr, arr.Length)\n{\n    sum := 0;\n    var i := 0;\n    while i < arr.Length\ninvariant 0 <= i <= arr.Length\ndecreases arr.Length - i\ninvariant sum == Sum(arr, i)\n    {\n        sum := sum + arr[i];\n        i := i + 1;\n    }\n}",
            "success": true
        },
        "task_id_424.dfy": {
            "state": "method ExtractRearChars(l: seq<string>) returns (r: seq<char>)\n    requires forall i :: 0 <= i < |l| ==> |l[i]| > 0\n    ensures |r| == |l|\n    ensures forall i :: 0 <= i < |l| ==> r[i] == l[i][|l[i]| - 1]\n{\n    var rearChars: seq<char> := [];\n    for i := 0 to |l|\ninvariant |rearChars| == i\ninvariant forall j :: 0 <= j < i ==> rearChars[j] == l[j][|l[j]| - 1]\n    {\n        rearChars := rearChars + [l[i][|l[i]| - 1]];\n    }\n    return rearChars;\n}",
            "success": true
        },
        "task_id_3.dfy": {
            "state": "method IsNonPrime(n: int) returns (result: bool)\n    requires n >= 2\n    ensures result <==> (exists k :: 2 <= k < n && n % k == 0)\n{\n    result := false;\n    var i := 2;\n    while i <= n/2\ninvariant result <==> (exists j :: 2 <= j < i && n % j == 0)\n    {\n        if n % i == 0\n        {\n            result := true;\n            break;\n        }\n        i := i + 1;\n    }\n}",
            "success": true
        },
        "task_id_8.dfy": {
            "state": "method SquareElements(a: array<int>) returns (squared: array<int>)\n    ensures squared.Length == a.Length\n    ensures forall i :: 0 <= i < a.Length ==> squared[i] == a[i] * a[i]\n{\n    squared := new int[a.Length];\n    for i := 0 to a.Length\ninvariant forall j :: 0 <= j < i ==> squared[j] == a[j] * a[j]\n    {\n        squared[i] := a[i] * a[i];\n    }\n}",
            "success": true
        },
        "task_id_170.dfy": {
            "state": "function sumTo( a:array<int>, start:int, end:int ) : int\n    requires a != null;\n    requires 0 <= start && start <= end && end <= a.Length;\n    decreases end;\n    reads a;\n    {\n        if (start == end) then 0 else sumTo(a, start, end-1) + a[end-1]\n    }\n    method SumInRange(a: array<int>, start: int, end: int) returns (sum: int)\n    requires a != null\n    requires 0 <= start && start <= end && end <= a.Length\n    ensures sum == sumTo(a, start, end)\n    {\n        sum := 0;\n        for i := start to end\ninvariant sum == sumTo(a, start, i)\n        {\n            sum := sum + a[i];\n        }\n    }",
            "success": true
        },
        "ProjectosCVS_tmp_tmp_02_gmcw_Handout 1_CVS_handout1_55754_55780.dfy": {
            "state": "/**\nCVS 2021-22 Handout 1\nAuthors\nGon\u00e7alo Martins Louren\u00e7o n\u00ba55780\nJoana Soares Faria  n\u00ba55754\n */\n// First Exercise\nlemma peasantMultLemma(a:int, b:int)\n    requires b >= 0\n    ensures b % 2 == 0 ==> (a * b == 2 * a * b / 2)\n    ensures b % 2 == 1 ==> (a * b == a + 2 * a * (b - 1) / 2)\n    {\n        if (b % 2 == 0 && b > 0) { \n            peasantMultLemma(a, b - 2);\n        }\n        if (b % 2 == 1 && b > 1) {\n            peasantMultLemma(a, b - 2);\n        }\n    }\nmethod peasantMult(a: int, b: int) returns (r: int)\n    requires b > 0\n    ensures r == a * b\n    {\n        r := 0;\n        var aa := a;\n        var bb := b;\n        while(bb > 0)\n            decreases bb \n            invariant 0 <= bb <= b\n            invariant r + aa * bb == a * b\n        { \n            // Use of lemma was not necessary for a successful verification\n            // peasantMultLemma(aa, bb);\n            if (bb % 2 == 0)\n            {\n                aa := 2 * aa;\n                bb := bb / 2;\n            } else if (bb % 2 == 1)\n            {\n                r := r + aa;\n                aa := 2 * aa;\n                bb := (bb-1) / 2;\n            }\n        } \n    }\n//Second Exercise\nmethod euclidianDiv(a: int,b : int) returns (q: int,r: int)\n    requires a >= 0\n    requires b > 0\n    ensures a == b * q + r\n    {\nassert a  ==  b * q + r;\n        r := a;\n        q := 0;\n        while(r - b >= 0)\ndecreases r\ninvariant r >= 0\n            // invariant a == b * q + r\n        {\n            r := r - b;\n            q := q + 1;\n        }\n    }",
            "success": false
        },
        "Software-Verification_tmp_tmpv4ueky2d_Best Time to Buy and Sell Stock_best_time_to_buy_and_sell_stock.dfy": {
            "state": "method best_time_to_buy_and_sell_stock(prices: array<int>) returns (max_profit: int)\n    requires 1 <= prices.Length <= 100000\n    requires forall i :: 0 <= i < prices.Length ==> 0 <= prices[i] <= 10000\n    ensures forall i, j :: 0 <= i < j < prices.Length ==> max_profit >= prices[j] - prices[i]\n{\n    var min_price := 10001;\n    max_profit := 0;\n    var i := 0;\nassert max_profit >= prices[i] - min_price;\n    while (i < prices.Length)\ninvariant min_price <= 10001\ninvariant forall j :: 0 <= j < i ==> min_price <= prices[j]\n    {\n        var price := prices[i];\n        if (price < min_price)\n        {\n            min_price := price;\n        }\n        if (price - min_price > max_profit) {\n            max_profit := price - min_price;\n        }\n        i := i + 1;\n    }\n}",
            "success": false
        },
        "dafny_examples_tmp_tmp8qotd4ez_leetcode_0001-two-sum.dfy": {
            "state": "// If this invariant is added explicitly to the loop then the verfication never finishes.\n// It could be {:opaque} for a more controlled verification:\n// assert InMap([], m, target) by {\n//   reveal InMap();\n// }\npredicate InMap(nums: seq<int>, m: map<int, int>, t: int) {\n  forall j :: 0 <= j < |nums| ==> t - nums[j] in m\n}\nmethod TwoSum(nums: array<int>, target: int) returns (r: (int, int))\n  ensures 0 <= r.0 ==> 0 <= r.0 < r.1 < nums.Length && \n                       nums[r.0] + nums[r.1] == target &&\n                       forall i, j :: 0 <= i < j < r.1 ==> nums[i] + nums[j] != target\n  ensures r.0 == -1 <==> forall i, j :: 0 <= i < j < nums.Length ==> nums[i] + nums[j] != target\n{\n  var m: map<int, int> := map[];\n  var i := 0;\n  while i < nums.Length\ninvariant 0 <= i <= nums.Length\ninvariant InMap(nums[..i], m, target) // Once this assertion is removed, the verification finishes quickly, and when this assertion is added, the verification never finishes.\n  {\n    if nums[i] in m {\n      return (m[nums[i]], i);\n    }\n    m := m[target - nums[i] := i];\n    i := i + 1;\n  }\n  return (-1, -1);\n}",
            "success": false
        },
        "CVS-Projto1_tmp_tmpb1o0bu8z_Hoare.dfy": {
            "state": "method Max (x: nat, y:nat) returns (r:nat)\n    ensures (r >= x && r >=y)\n    ensures (r == x || r == y)\n{\n    if (x >= y) { r := x;}\n    else { r := y;}\n}\nmethod Test ()\n{\n    var result := Max(42, 73);\n    assert result == 73;\n}\nmethod m1 (x: int, y: int) returns (z: int)\nrequires 0 < x < y\nensures z >= 0 && z <= y && z != x\n{\n    //assume 0 < x < y\n    z := 0;\n}\nfunction fib (n: nat) : nat\n{\n    if n == 0 then 1 else\n    if n == 1 then 1 else\n    fib(n -1) + fib (n-2)\n}\nmethod Fib (n: nat) returns (r:nat)\n    ensures r == fib(n)\n{\n    if (n == 0) {\n        return 1;\n    }\n    r := 1;\n    var next:=2;\n    var i := 1;\n    while i < n\n        invariant 1 <= i <= n\n        invariant r == fib(i)\n        invariant next == fib(i+1)\n    {\n        var tmp:=next;\n        next:= next + r;\n        r:= tmp;\n        i:= i + 1;\n    }\n    assert r == fib(n);\n    return r;\n}\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\nfunction add(l:List<int>) : int\n{\n    match l\n    case Nil => 0\n    case Cons(x, xs) => x + add(xs)\n}\nmethod addImp (l: List<int>) returns (s: int)\n    ensures s == add(l)\n{\n    var ll := l;\n    s := 0;\n    while ll != Nil\n        decreases ll\n        invariant add(l) == s + add(ll)\n        {\n            s := s + ll.head;\n            ll:= ll.tail;\n        }\n    assert s == add(l);\n}\nmethod MaxA (a: array<int>) returns (m: int)\n    requires a.Length > 0\n    ensures forall i :: 0 <= i < a.Length ==> a[i] <= m\n    ensures exists i :: 0 <= i < a.Length && a[i] == m\n{\n    m := a[0];\n    var i := 1;\n    while i< a.Length\ninvariant 0 <= i <= a.Length\ninvariant forall j :: 0 <= j < i ==> a[j] <= m\ninvariant exists j :: 0 <= j < i && a[j] == m\n    {\n        if a[i] > m {\n            m:= a[i];\n        }\n        i := i +1;\n    }\n}",
            "success": true
        },
        "task_id_807.dfy": {
            "state": "predicate IsOdd(x: int)\n{\n    x % 2 != 0\n}\nmethod FindFirstOdd(a: array<int>) returns (found: bool, index: int)\n    requires a != null\n    ensures !found ==> forall i :: 0 <= i < a.Length ==> !IsOdd(a[i])\n    ensures found ==> 0 <= index < a.Length && IsOdd(a[index]) && forall i :: 0 <= i < index ==> !IsOdd(a[i])\n{\n    found := false;\n    index := 0;\n    while (index < a.Length)\ninvariant 0 <= index <= a.Length\ninvariant !found ==> forall i :: 0 <= i < index ==> !IsOdd(a[i])\ninvariant found ==> forall i :: 0 <= i < index ==> !IsOdd(a[i])\n    {\n        if IsOdd(a[index])\n        {\n            found := true;\n            return;\n        }\n        index := index + 1;\n    }\n}",
            "success": true
        },
        "min_array_strong.dfy": {
            "state": "method minArray(a: array<int>) returns (r:int)\n  requires a.Length > 0\n  ensures forall i :: 0 <= i < a.Length ==> r <= a[i]\n  ensures exists i :: 0 <= i < a.Length && r == a[i]\n{\n  r:=a[0];\n  var i:=1;\n  while i<a.Length\ninvariant r==a[0]\ninvariant exists j::0<=j<i&&r==a[j]\n  {\n    if r>a[i]{\n      r:=a[i];\n    }\n    i:=i+1;\n  }\n}",
            "success": false
        },
        "task_id_594.dfy": {
            "state": "predicate IsEven(n: int)\n{\n    n % 2 == 0\n}\npredicate IsOdd(n: int)\n{\n    n % 2 != 0\n}\nmethod FirstEvenOddDifference(a: array<int>) returns (diff: int)\n    requires a.Length >= 2\n    requires exists i :: 0 <= i < a.Length && IsEven(a[i])\n    requires exists i :: 0 <= i < a.Length && IsOdd(a[i])\n    ensures exists i, j :: 0 <= i < a.Length && 0 <= j < a.Length && IsEven(a[i]) && IsOdd(a[j]) && diff == a[i] - a[j] && \n        (forall k :: 0 <= k < i ==> IsOdd(a[k])) && (forall k :: 0 <= k < j ==> IsEven(a[k]))\n{\n    var firstEven: int := -1;\n    var firstOdd: int := -1;\n    for i := 0 to a.Length\ninvariant forall k :: 0 <= k < firstEven ==> IsOdd(a[k])\n    {\n        if firstEven == -1 && IsEven(a[i])\n        {\n            firstEven := i;\n        }\n        if firstOdd == -1 && IsOdd(a[i])\n        {\n            firstOdd := i;\n        }\n        if firstEven != -1 && firstOdd != -1\n        {\n            break;\n        }\n    }\n    diff := a[firstEven] - a[firstOdd];\n}",
            "success": false
        },
        "dafny-duck_tmp_tmplawbgxjo_p1.dfy": {
            "state": "// Given an array of integers, it returns the sum. [1,3,3,2]->9\nfunction Sum(xs: seq<int>): int {\n    if |xs| == 0 then 0 else Sum(xs[..|xs|-1]) + xs[|xs|-1]\n}\nmethod SumArray(xs: array<int>) returns (s: int)\n    ensures s == Sum(xs[..])\n{\n    s := 0;\n    var i := 0;\n    while i < xs.Length\ndecreases xs.Length - i\ninvariant 0 <= i <= xs.Length\ninvariant s == Sum(xs[..i])\n    {\n        s := s + xs[i];\n        i := i + 1;\n    }\n}",
            "success": false
        },
        "laboratory_tmp_tmps8ws6mu2_dafny-tutorial_exercise11.dfy": {
            "state": "method m()\n{\n    var i, n := 0, 20;\n    while i != n\n    {\n        i := i + 1;\n    }\n}",
            "success": false
        },
        "task_id_554.dfy": {
            "state": "/**\n * Find odd numbers from an array of numbers\n **/\npredicate IsOdd(n: int)\n{\n    n % 2 == 1\n}\nmethod FindOddNumbers(arr: array<int>) returns (oddList: seq<int>)\n    // All numbers in the output are odd and exist in the input \n    ensures forall i :: 0 <= i < |oddList| ==> IsOdd(oddList[i]) && oddList[i] in arr[..]\n    // All odd numbers in the input are in the output\n    ensures forall i :: 0 <= i < arr.Length && IsOdd(arr[i]) ==> arr[i] in oddList\n{\n    oddList := [];\n    for i := 0 to arr.Length\ninvariant forall k :: 0 <= k < |oddList| ==> IsOdd(oddList[k]) && oddList[k] in arr[..]\ninvariant forall k :: 0 <= k < i && IsOdd(arr[k]) ==> arr[k] in oddList\n    {\n        if IsOdd(arr[i])\n        {\n            oddList := oddList + [arr[i]];\n        }\n    }\n}",
            "success": true
        },
        "Dafny-experiences_tmp_tmp150sm9qy_dafny_started_tutorial_dafny_tutorial_array.dfy": {
            "state": "method FindMax(a: array<int>) returns (i: int)\n  // Annotate this method with pre- and postconditions\n  // that ensure it behaves as described.\n  requires a.Length > 0\n  ensures 0<= i < a.Length\n  ensures forall k :: 0 <= k < a.Length ==> a[k] <= a[i]\n{\n  // Fill in the body that calculates the INDEX of the maximum.\n  i := 0;\nassert a[i] == a[0];\n  var index := 1;\n  while index < a.Length\ninvariant 0 <= i < index\ninvariant forall k :: 0 <= k < index ==> a[k] <= a[i]\n  {\n    if a[index] > a[i] {i:= index;}\n    index := index + 1;\n  }\n}",
            "success": false
        },
        "Workshop_tmp_tmp0cu11bdq_Workshop_Answers_Question5.dfy": {
            "state": "method rev(a : array<int>)\n    requires a != null;\n    modifies a;\n    ensures forall k :: 0 <= k < a.Length ==> a[k] == old(a[(a.Length - 1) - k]);\n{\n    var i := 0;\n    while (i < a.Length - 1 - i)\ninvariant a[..i] == old(a[a.Length - 1 - i..a.Length - 1]);\ninvariant 0 <= i <= a.Length / 2;\ninvariant forall k :: a.Length / 2 - i <= k < a.Length / 2 + i ==> a[k] == old(a[a.Length - 1 - k]);\n    {\n        a[i], a[a.Length - 1 - i] := a[a.Length - 1 - i], a[i];\n        i := i + 1;\n    }\n}",
            "success": false
        },
        "Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_50_examples_28.dfy": {
            "state": "method main(x: int, y: int) returns (x_out: int, y_out: int, n: int)\nrequires x >= 0\nrequires y >= 0\nrequires x == y\nensures y_out == n\n{\nassert x_out == n;\n    x_out := x;\n    y_out := y;\n    n := 0;\n    while (x_out != n)\ninvariant 0 <= n <= y\n    {\n        x_out := x_out - 1;\n        y_out := y_out - 1;\n    }\n}",
            "success": false
        },
        "dafny_tmp_tmp2ewu6s7x_ListReverse.dfy": {
            "state": "function reverse(xs: seq<nat>): seq<nat>\n{\n    if xs == [] then [] else reverse(xs[1..]) + [xs[0]]\n}\nlemma ReverseAppendDistr(xs: seq<nat>, ys: seq<nat>)\nensures reverse(xs + ys) == reverse(ys) + reverse(xs)\n{\n    if {\n        case xs == [] =>\n        calc {\nreverse(xs) + reverse(xs[1..]);\n==\n            reverse([] + ys);\n            calc {\n                [] + ys;\n                ys;\n            }\n            reverse(ys);\n            reverse(ys) + reverse([]);\n        }\n        case xs != [] => {\n            var zs := xs + ys;\nassert zs[1..] == xs[1..] + ys;\n        }\n    }\n}\nlemma ReverseInvolution(xxs: seq<nat>)\nensures reverse(reverse(xxs)) == xxs\n{\n    if {\n        case xxs == [] => {}\n        case xxs != [] => calc {\n            reverse(reverse(xxs));\n            ==\n            reverse(reverse(xxs[1..]) + [xxs[0]]);\n            ==\n            { ReverseAppendDistr(reverse(xxs[1..]), [xxs[0]]); }\n            reverse([xxs[0]]) + reverse(reverse(xxs[1..]));\n            ==\n            { ReverseInvolution(xxs[1..]); }\n            calc {\n                reverse([xxs[0]]);\n                ==\n                [] + [xxs[0]];\n                ==\n                [xxs[0]];\n            }\n            [xxs[0]] + xxs[1..];\n            ==\n            xxs;\n        }\n    }\n}",
            "success": false
        },
        "task_id_732.dfy": {
            "state": "predicate IsSpaceCommaDot(c: char)\n{\n    c == ' ' || c == ',' || c == '.'\n}\nmethod ReplaceWithColon(s: string) returns (v: string)\n    ensures |v| == |s|\n    ensures forall i :: 0 <= i < |s| ==> (IsSpaceCommaDot(s[i]) ==> v[i] == ':') && (!IsSpaceCommaDot(s[i]) ==> v[i] == s[i])\n{\n    var s' : string := [];\n    for i := 0 to |s|\ninvariant |s'| == i\ninvariant forall k :: 0 <= k < i ==> (IsSpaceCommaDot(s[k]) ==> s'[k] == ':') && (!IsSpaceCommaDot(s[k]) ==> s'[k] == s[k])\n    {\n        if IsSpaceCommaDot(s[i])\n        {\n            s' := s' + [':'];\n        }\n        else \n        {\n            s' := s' + [s[i]];\n        }\n    }\n    return s';\n}",
            "success": true
        },
        "task_id_445.dfy": {
            "state": "method MultiplyElements(a: seq<int>, b: seq<int>) returns (result: seq<int>)\n    requires |a| == |b|\n    ensures |result| == |a|\n    ensures forall i :: 0 <= i < |result| ==> result[i] == a[i] * b[i]\n{\n    result := [];\n    var i := 0;\n    while i < |a|\ninvariant 0 <= i <= |a|\ninvariant |result| == i\ninvariant forall k :: 0 <= k < i ==> result[k] == a[k] * b[k]\n    {\n        result := result + [a[i] * b[i]];\n        i := i + 1;\n    }\n}",
            "success": true
        },
        "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_pregel algorithms_skeleton_nondet-permutation.dfy": {
            "state": "\ufeffmodule Permutation\n{\n\t/**\n\t * Given n >= 0, generate a permuation of {0,...,n-1} nondeterministically.\n\t */\n\tmethod Generate(n: int) returns (perm: array<int>)\n\t\trequires n >= 0\n\t\tensures perm != null\n\t\tensures perm.Length == n\n\t\tensures fresh(perm)\n\t\tensures isValid(perm, n)\n\t{\nassert isValid(perm, n);\n\t\tvar all := set x | 0 <= x < n;\n\t\tvar used := {};\n\t\tperm := new int[n];\n\t\tCardinalityLemma(n, all);\n\t\twhile used < all\n\t\t{\n\t\t\tCardinalityOrderingLemma(used, all);\n\t\t\tvar dst :| dst in all && dst !in used;\n\t\t\tperm[|used|] := dst;\n\t\t\tused := used + {dst};\n\t\t}\n\t\tprint perm;\n\t}\n\tpredicate isValid(a: array<int>, n: nat)\n\t\trequires a != null && a.Length == n\n\t\treads a\n\t{\n\t\tassume forall i | 0 <= i < n :: i in a[..];\n\t\tdistinct(a)\n\t\t&& (forall i | 0 <= i < a.Length :: 0 <= a[i] < n)\n\t\t&& (forall i | 0 <= i < n :: i in a[..])\n\t}\n\tpredicate distinct(a: array<int>)\n\t\trequires a != null\n\t\treads a\n\t{\n\t\tdistinct'(a, a.Length)\n\t}\n\tpredicate distinct'(a: array<int>, n: int)\n\t\trequires a != null\n\t\trequires a.Length >= n\n\t\treads a\n\t{\n\t\tforall i,j | 0 <= i < n && 0 <= j < n && i != j :: a[i] != a[j]\n\t}\n\tlemma CardinalityLemma (size: int, s: set<int>)\n\t\trequires size >= 0\n\t\trequires s == set x | 0 <= x < size\n\t\tensures\tsize == |s|\n\t{\nassert |s| == size;\n\t\tif(size == 0) {\n\t\t} else {\n\t\t\tCardinalityLemma(size - 1, s - {size - 1});\n\t\t}\n\t}\n\tlemma CardinalityOrderingLemma<T> (s1: set<T>, s2: set<T>)\n\t\trequires s1 < s2\n\t\tensures |s1| < |s2|\n\t{\n\t\tvar e :| e in s2 - s1;\n\t\tif s1 != s2 - {e} {\n\t\t\tCardinalityOrderingLemma(s1, s2 - {e});\n\t\t}\n\t}\n\tlemma SetDiffLemma<T> (s1: set<T>, s2: set<T>)\n\t\trequires s1 < s2\n\t\tensures s2 - s1 != {}\n\t{\n\t\tvar e :| e in s2 - s1;\n\t\tif s2 - s1 != {e} {} // What does Dafny prove here???\n\t}\n}",
            "success": false
        },
        "cs245-verification_tmp_tmp0h_nxhqp_quicksort-partition.dfy": {
            "state": "// Quicksort Partition -- Stephanie McIntyre\n// Based on examples in class \n// Parts have been modified cause you know, arrays are different...\nmethod QuicksortPartition(X: array<int>, n: int, p: int) returns (a: int, b: int)\nmodifies X;\n/*Pre-Condition*/   requires X.Length>=1 && n == X.Length;\n/*Post-Condition*/  ensures b>=n;\n                    ensures forall x:: 0<=x<a<n ==> X[x] <= p;\n                    ensures forall x:: a==n || (0<=a<=x<n ==> X[x] > p);\n                    ensures multiset(X[..])==multiset(old(X[..]))           //This says the new X is a permutation of our old version of X.\n{\n  a := 0;\n  while ( a < n && X[a] <= p ) \ninvariant forall x:: 0<=x<a  ==> X[x] <= p;\ninvariant multiset(X[..])==multiset(old(X[..]))           //This says the new X is a permutation of our old version of X.\ninvariant forall x::a<=x<b<n ==> X[x]>p;\n  { \n    a := a+1;\n  }\n  b := a+1;\n  while ( b<n )\n  { \n    if ( X[b] <= p ) {\n      var t := X[b]; \n      X[b] := X[a]; \n      X[a] := t; \n      a := a+1;\n    }\n    b := b+1;\n  }\n}\n/* The annotations and implied proofs are left for you.\n   I might do them later on next week. */",
            "success": false
        },
        "ironsync-osdi2023_tmp_tmpx80antoe_linear-dafny_docs_DafnyRef_examples_Example-Old2.dfy": {
            "state": "class A {\n  var value: int\n  constructor ()\n     ensures value == 10\n  {\n     value := 10;\n  }\n}\nclass B {\n   var a: A\n   constructor () { a := new A(); }\n   method m()\n     requires a.value == 11\n     modifies this, this.a\n   {\n     label L:\n     a.value := 12;\n     label M:\n     a := new A(); // Line X\n     label N:\n     a.value := 20;\n     label P:\nassert a.value == 20; // Line Q\n                                // but .value in current state\n                                  // reference at Line X\n  }\n}",
            "success": true
        },
        "set_to_seq_strong.dfy": {
            "state": "method SetToSeq<T>(s: set<T>) returns (xs: seq<T>)\n  ensures multiset(s) == multiset(xs)\n{\n  xs := [];\n  var left: set<T> := s;\n  while left != {}\ninvariant multiset(left) + multiset(xs) == multiset(s)\n  {\n    var x :| x in left;\n    left := left - {x};\n    xs := xs + [x];\n  }\n}",
            "success": true
        },
        "task_id_106.dfy": {
            "state": "method AppendArrayToSeq(s: seq<int>, a: array<int>) returns (r: seq<int>)\n    requires a != null\n    ensures |r| == |s| + a.Length\n    ensures forall i :: 0 <= i < |s| ==> r[i] == s[i]\n    ensures forall i :: 0 <= i < a.Length ==> r[|s| + i] == a[i]\n{\n    r := s;\n    for i := 0 to a.Length\ninvariant |r| == |s| + i\ninvariant forall j :: 0 <= j < |s| ==> r[j] == s[j]\ninvariant forall j :: 0 <= j < i ==> r[|s| + j] == a[j]\n    {\n        r := r + [a[i]];\n    }\n}",
            "success": true
        },
        "task_id_474.dfy": {
            "state": "method ReplaceChars(s: string, oldChar: char, newChar: char) returns (v: string)\n    ensures |v| == |s|\n    ensures forall i :: 0 <= i < |s| ==> (s[i] == oldChar ==> v[i] == newChar) && (s[i] != oldChar ==> v[i] == s[i])\n{\n    var s' : string := [];\n    for i := 0 to |s|\ninvariant |s'| == i\ninvariant forall j :: 0 <= j < i ==> (s[j] == oldChar ==> s'[j] == newChar) && (s[j] != oldChar ==> s'[j] == s[j])\n    {\n        if s[i] == oldChar\n        {\n            s' := s' + [newChar];\n        }\n        else \n        {\n            s' := s' + [s[i]];\n        }\n    }\n    return s';\n}",
            "success": true
        },
        "dafny_examples_tmp_tmp8qotd4ez_lib_math_DivMod.dfy": {
            "state": "module DivMod {\n  function {:opaque} DivSub(a: int, b: int): int\n    requires 0 <= a && 0 < b\n  {\n    if a < b then 0 else 1 + DivSub(a - b, b)\n  }\n  function {:opaque} ModSub(a: int, b: int): int\n    requires 0 <= a && 0 < b\n  {\n    if a < b then a else ModSub(a - b, b)\n  }\n  lemma DivModAdd1(a: int, b: int)\n    requires b != 0\n    ensures (a + b) % b == a % b\n    ensures (a + b) / b == a / b + 1\nlemma DivModAdd(a: int, b: int, c: int)\n  {\nassert c * b / b == c;\n    var c := (a + b) / b - (a / b) - 1;\n  }\n  lemma DivModSub1(a: int, b: int)\n    requires b != 0\n    ensures (a - b) % b == a % b\n    ensures (a - b) / b == a / b - 1\n  {\n    var c := (a - b) / b - (a / b) + 1;\n  }\n  lemma ModEq(a: int, b: int)\n    requires 0 <= a && 0 < b\n    ensures a % b == ModSub(a, b)\n  {\n    reveal ModSub();\n    if a >= b {\n      DivModSub1(a, b);\n    }\n  }\n  lemma DivEq(a: int, b: int)\n    requires 0 <= a && 0 < b\n    ensures a / b == DivSub(a, b)\n  {\n    reveal DivSub();\n    if a >= b {\n      DivModSub1(a, b);\n    }\n  }\n  lemma DivModSpec'(a: int, b: int, q: int, r: int)\n    requires 0 <= a && 0 < b\n    requires 0 <= q && 0 <= r < b\n    requires a == q * b + r\n    ensures ModSub(a, b) == r\n    ensures DivSub(a, b) == q\n  {\n    reveal ModSub();\n    reveal DivSub();\n    if q > 0 {\n      DivModSpec'(a - b, b, q - 1, r);\n    }\n  }\n  lemma DivModSpec(a: int, b: int, q: int, r: int)\n    requires 0 <= a && 0 < b\n    requires 0 <= q && 0 <= r < b\n    requires a == q * b + r\n    ensures a % b == r\n    ensures a / b == q\n  {\n    ModEq(a, b);\n    DivEq(a, b);\n    DivModSpec'(a, b, q, r);\n  }\n  lemma DivMul(a: int, b: int)\n    requires 0 <= a && 0 < b\n    ensures a * b / b == a\n  {\n    DivModSpec(a * b, b, a, 0);\n  }\n  lemma DivModMulAdd(a: int, b: int, c: int)\n    requires 0 <= a && 0 <= c < b && 0 < b\n    ensures (a * b + c) / b == a\n    ensures (a * b + c) % b == c\n  {\n    DivModSpec(a * b + c, b, a, c);\n  }\n}",
            "success": false
        },
        "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic examples_sumto_sol.dfy": {
            "state": "function sum_up_to (n: nat): nat\n{\n  if (n == 0) then 0\n  else sum_up_to (n-1) + 1\n}\nmethod SumUpTo (n: nat) returns (r: nat)\n  ensures r == sum_up_to (n);\n{\n  var i := 0;\n  r := 0;\n  while (i < n)\n    invariant 0 <= i <= n;\n    invariant r == sum_up_to (i);\n  {\n    r := r + 1;\n    i := i + 1;\n  }\n}\nfunction total (a: seq<nat>) : nat\n{\n  if |a| == 0 then 0\n  else total (a[0..|a|-1]) + a[|a|-1]\n}\nlemma total_lemma (a: seq<nat>, i:nat) \n  requires |a| > 0;\n  requires 0 <= i < |a|;\n  ensures total (a[0..i]) + a[i] == total (a[0..i+1]);\n{\n  ghost var b := a[0..i+1];\n  calc\n  {\n    total (a[0..i+1]);\n    total (b);\n    total (b[0..|b|-1]) + b[|b|-1];\n    total (b[0..|b|-1]) + a[i];\n    {assert (b[0..|b|-1] == a[0..i]);}\n    total (a[0..i]) + a[i];\n  }\n}\nmethod Total (a: seq<nat>) returns (r:nat)\n  ensures r == total (a[0..|a|]); \n{\n  var i := 0;\n  r := 0;\n  while i < |a|\ninvariant 0 <= i <= |a|;\ninvariant r == total (a[0..i]);\n  { \n    total_lemma (a, i);\n    r := r + a[i];\n    i := i + 1;\n  }\n}",
            "success": true
        },
        "array_sum_strong.dfy": {
            "state": "method arraySum(a: array<int>, b: array<int>) returns (c: array<int> )\n  requires a.Length==b.Length\n  ensures c.Length==a.Length\n  ensures forall i:: 0 <= i< a.Length==> a[i] + b[i]==c[i]\n{\n  c:= new int[a.Length];\n  var i:=0;\n  while i<a.Length\ndecreases c.Length-i\n  {\n    c[i]:=a[i]+b[i];\n    i:=i+1;\n  }\n}",
            "success": false
        },
        "task_id_282.dfy": {
            "state": "method ElementWiseSubtraction(a: array<int>, b: array<int>) returns (result: array<int>)\n    requires a != null && b != null\n    requires a.Length == b.Length\n    ensures result != null\n    ensures result.Length == a.Length\n    ensures forall i :: 0 <= i < result.Length ==> result[i] == a[i] - b[i]\n{\n    result := new int[a.Length];\n    var i := 0;\n    while i < a.Length\n    {\n        result[i] := a[i] - b[i];\n        i := i + 1;\n    }\n}",
            "success": false
        },
        "task_id_2.dfy": {
            "state": "predicate InArray(a: array<int>, x: int)\n    reads a\n{\n    exists i :: 0 <= i < a.Length && a[i] == x\n}\nmethod SharedElements(a: array<int>, b: array<int>) returns (result: seq<int>)\n    // All elements in the output are in both a and b\n    ensures forall x :: x in result ==> (InArray(a, x) && InArray(b, x))\n    // The elements in the output are all different\n    ensures forall i, j :: 0 <= i < j < |result| ==> result[i] != result[j]\n{\n    var res: seq<int> := [];\n    for i := 0 to a.Length\ninvariant forall x :: x in res ==> (InArray(a, x) && InArray(b, x))\ninvariant forall j, k :: 0 <= j < k < |res| ==> res[j] != res[k]\n    {\n        if InArray(b, a[i]) && a[i] !in res\n        {\n            res := res + [a[i]];\n        }\n    }\n    result := res;\n}",
            "success": true
        },
        "task_id_145.dfy": {
            "state": "method MaxDifference(a: array<int>) returns (diff: int)\n    requires a.Length > 1\n    ensures forall i, j :: 0 <= i < a.Length && 0 <= j < a.Length ==> a[i] - a[j] <= diff\n{\n    var minVal := a[0];\n    var maxVal := a[0];\n    for i := 1 to a.Length\ninvariant forall j :: 0 <= j < i ==> minVal <= a[j] && a[j] <= maxVal\n    {\n        if a[i] < minVal {\n            minVal := a[i];\n        } else if a[i] > maxVal {\n            maxVal := a[i];\n        }\n    }\n    diff := maxVal - minVal;\n}",
            "success": true
        },
        "Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseContained.dfy": {
            "state": "predicate strictSorted(s : seq<int>) {\n\tforall u, w :: 0 <= u < w < |s| ==> s[u] < s[w]\n}\nmethod mcontained(v:array<int>,w:array<int>,n:int,m:int) returns (b:bool)\n//Specify and implement an O(m+n) algorithm that returns b\n//v and w are strictly increasing ordered arrays\n//b is true iff the first n elements of v are contained in the first m elements of w\nrequires n<=m && n>=0\nrequires strictSorted(v[..])\nrequires strictSorted(w[..])\nrequires v.Length >= n && w.Length >= m\nensures b==forall k:: 0<= k< n ==> v[k] in w[..m]//exists j :: 0 <= j < m && v[k] == w[j]\n{\n\tvar i:=0;\n\tvar j:=0;\n\twhile(i<n && j<m && (v[i] >= w[j])) //&& b)\ninvariant forall k::0<=k<i ==> v[k] in w[..m]//exists j :: 0 <= j < m && v[k] == w[j]\ndecreases w.Length-j\ninvariant i<=j\n\t{\t\n\t\tif(v[i] == w[j]){\n\t\t\ti:=i+1;\n\t\t}\n\t\tj:=j+1;\n\t}\n\tb := i==n;\n}",
            "success": false
        },
        "ironsync-osdi2023_tmp_tmpx80antoe_linear-dafny_docs_DafnyRef_examples_Example-Old.dfy": {
            "state": "class A {\n  var value: int\n  method m(i: int)\n    requires i == 6\n    requires value == 42\n    modifies this\n  {\n    var j: int := 17;\n    value := 43;\n    label L:\n    j := 18;\n    value := 44;\n    label M:\nassert(j + 1 == 19);\n    // value is this.value; 'this' is the same\n    // same reference in current and pre state but the\n    // values stored in the heap as its fields are different;\n    // '.value' evaluates to 42 in the pre-state, 43 at L,\n    // and 44 in the current state\n  }\n}",
            "success": true
        },
        "Dafny_Programs_tmp_tmp99966ew4_binary_search.dfy": {
            "state": "predicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n}\nmethod BinarySearch(a: array<int>, value: int) returns (index: int)\n   requires a != null && 0 <= a.Length && sorted(a)\n   ensures 0 <= index ==> index < a.Length && a[index] == value\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != value\n{\n   var low, high := 0, a.Length;\n   while low < high\n         0 <= i < a.Length && !(low <= i < high) ==> a[i] != value\n   {\n      var mid := (low + high) / 2;\n      if a[mid] < value\n      {\n         low := mid + 1;\n      }\n      else if value < a[mid]\n      {\n         high := mid;\n      }\n      else\n      {\n         return mid;\n      }\n   }\n   return -1;\n}",
            "success": false
        },
        "llm-verified-eval_tmp_tmpd2deqn_i_dafny_161.dfy": {
            "state": "function IsLetter(c: char): bool \n{\n  (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') \n}\nfunction NoLetters(s: string, n: nat): bool \n  requires n <= |s|\n{\n  forall c :: 0 <= c < n ==> !IsLetter(s[c])\n}\nfunction ToggleCase(c: char): char\n{\n  if c >= 'a' && c <= 'z' \n  then \n    (c - 'a' + 'A')\n  else if c >= 'A' && c <= 'Z' \n    then \n      (c - 'A' + 'a')\n    else \n      c\n}\nfunction isReverse(s: string, s_prime: string): bool{\n  (|s| == |s_prime|) &&\n  (forall si :: 0 <= si < |s|/2 ==> s_prime[|s| - si - 1] == s[si])\n}\nmethod Reverse(original: seq<char>) returns (reversed: seq<char>)\n  ensures |reversed| == |original| \n  ensures forall i :: 0 <= i < |original| ==> reversed[i] == original[|original| - 1 - i] \n{\n  reversed := []; \n  var i := |original|;\n  while i > 0\n    decreases i\n    invariant 0 <= i <= |original|\n    invariant  |reversed| == |original| - i\n    invariant forall j :: 0 <= j < |original|-i ==>\n    reversed[j] == original[|original| - 1 - j]\n  {\n    i := i - 1;\n    reversed := reversed + [original[i]]; \n  }\n}\nmethod solve(s: string) returns (result: string)\n  ensures |result| == |s| \n  ensures !NoLetters(s, |s|) ==> forall i :: 0 <= i < |s| && IsLetter(s[i]) ==> result[i] == ToggleCase(s[i])\n  ensures !NoLetters(s, |s|) ==> forall i :: 0 <= i < |s| && !IsLetter(s[i]) ==> result[i] == s[i] \n  ensures NoLetters(s, |s|) ==> isReverse(result, s) \n{\n    var flg : bool := false;\n    result := \"\";\n    for i := 0 to |s|\ninvariant !NoLetters(s, i+1) ==> forall j :: 0 <= j < i+1 && !IsLetter(s[j]) ==> result[j] == s[j]\n    {\n      if IsLetter(s[i])\n      {\n        result := result + [ToggleCase(s[i])];\n        flg := true;\n      } else {\n        result := result + [s[i]];\n      }\n    }\n    if !flg\n    {\n      result := Reverse(s);\n    }\n}",
            "success": false
        },
        "Dafny_Verify_tmp_tmphq7j0row_dataset_C_convert_examples_15.dfy": {
            "state": "method main(n: int, k: int) returns (k_out: int)\n    requires n > 0;\n\trequires k > n;\n\tensures k_out >= 0;\n{\n\tk_out := k;\n    var j: int := 0;\n    while(j < n)\ndecreases k + n - j;\ninvariant j <= n || k >= 1\ninvariant 0 <= j <= n\n    {\n        j := j + 1;\n        k_out := k_out - 1;\n    }\n}\n// C code:\n// MODULE main\n// \tint i;\n// \tint n;\n// \tint j;\n// \tint k;\n// \tassume(n > 0);\n// \tassume(k > n);\n// \tassume(j == 0);\n// \twhile(j < n){\n// \t\tj = j + 1;\n// \t\tk = k - 1;\n// \t}\n// \tassert(k >= 0);\t\n// END MODULE\n// Invariant\n// (\n    // not (or (<= 1 (+ n (+ (* (- 1) j) (* (- 1) k)))) (\n    //     and (<= k (- 1)) (<= (+ n (* (- 1) j)) (- 1)))))",
            "success": false
        },
        "Dafny_Verify_tmp_tmphq7j0row_Generated_Code_Mult.dfy_1.dfy": {
            "state": "method mult(a:int, b:int) returns (x:int)\n  \trequires a >= 0 && b >= 0\n  \tensures x == a * b\n{\n  \tx := 0;\n\tvar y := a;\n  \twhile y > 0\ninvariant x == (a - y) * b\ndecreases y\n\t{\n\t\tx := x + b;\n\t\ty := y - 1;\n\t}\n}",
            "success": true
        },
        "Dafny_Verify_tmp_tmphq7j0row_Generated_Code_ComputePower.dfy_3.dfy": {
            "state": "function Power(n: nat): nat {\n    if n == 0 then 1 else 2 * Power(n - 1)\n}\nmethod ComputePower(n: nat) returns (p: nat)\n    ensures p == Power(n)\n{\n    p := 1;\n    var i := 0;\nassert p == Power(i);\n    while i != n\ninvariant i <= n && p == Power(i)\n    {\n        i := i + 1;\n        p := p * 2;\n    }\n}",
            "success": true
        },
        "Dafny_tmp_tmpv_d3qi10_3_cumsum.dfy": {
            "state": "function sum(a: array<int>, i: int): int\n    requires 0 <= i < a.Length\n    reads a\n{\n    a[i] + if i == 0 then 0 else sum(a, i - 1)\n}\nmethod cumsum(a: array<int>, b: array<int>)\n    requires  a.Length == b.Length && a.Length > 0 && a != b\n    // when you change a  , that's not the same object than b . \n    //requires b.Length > 0 \n    ensures forall i | 0 <= i < a.Length :: b[i] == sum(a, i)\n    modifies b\n{\n    b[0] := a[0]; // Initialise le premier \u00e9l\u00e9ment de b\n    var i := 1;\n    while i < a.Length\ninvariant b[i - 1] == sum(a, i - 1) // La somme cumul\u00e9e du pr\u00e9vu est bien calcul\u00e9e.\n    {\n        b[i] := b[i - 1] + a[i]; // Calcule la somme cumul\u00e9e pour chaque \u00e9l\u00e9ment\n        i := i + 1;\n    }\n}",
            "success": false
        },
        "task_id_412.dfy": {
            "state": "/**\n * Remove odd numbers from an array of numbers\n **/\npredicate IsEven(n: int)\n{\n    n % 2 == 0\n}\nmethod RemoveOddNumbers(arr: array<int>) returns (evenList: seq<int>)\n    // All numbers in the output are even and exist in the input \n    ensures forall i :: 0 <= i < |evenList| ==> IsEven(evenList[i]) && evenList[i] in arr[..]\n    // All even numbers in the input are in the output\n    ensures forall i :: 0 <= i < arr.Length && IsEven(arr[i]) ==> arr[i] in evenList\n{\n    evenList := [];\n    for i := 0 to arr.Length\ninvariant forall k :: 0 <= k < |evenList| ==> IsEven(evenList[k]) && evenList[k] in arr[..]\ninvariant forall k :: 0 <= k < i && IsEven(arr[k]) ==> arr[k] in evenList\n    {\n        if IsEven(arr[i])\n        {\n            evenList := evenList + [arr[i]];\n        }\n    }\n}",
            "success": true
        },
        "task_id_603.dfy": {
            "state": "method LucidNumbers(n: int) returns (lucid: seq<int>)\n    requires n >= 0\n    ensures forall i :: 0 <= i < |lucid| ==> lucid[i] % 3 == 0\n    ensures forall i :: 0 <= i < |lucid| ==> lucid[i] <= n\n    ensures forall i, j :: 0 <= i < j < |lucid| ==> lucid[i] < lucid[j]\n{\n    lucid := [];\n    var i := 0;\n    while i <= n\ninvariant 0 <= i <= n + 1\ninvariant forall k :: 0 <= k < |lucid| ==> lucid[k] % 3 == 0\ninvariant forall i, j :: 0 <= i < j < |lucid| ==> lucid[i] < lucid[j]\n    {\n        if i % 3 == 0 {\n            lucid := lucid + [i];\n        }\n        i := i + 1;\n    }\n}",
            "success": false
        },
        "sat_dfy_tmp_tmpfcyj8am9_dfy_Seq.dfy": {
            "state": "module Seq {\n    function seq_sum(s: seq<int>) : (sum: int)\n    {\n        if s == [] then\n            0\n        else\n            var x := s[0];\n            var remaining := s[1..];\n            x + seq_sum(remaining)\n    }\n    lemma SeqPartsSameSum(s: seq<int>, s1: seq<int>, s2: seq<int>)\n        requires s == s1 + s2\n        ensures seq_sum(s) == seq_sum(s1) + seq_sum(s2)\n    {\n        if s == [] {\n        } else if s1 == [] {\n        } else {\n            var x := s1[0];\n            var s1' := s1[1..];\n            SeqPartsSameSum(s[1..], s1[1..], s2);\n        }\n    }\n    lemma DifferentPermutationSameSum(s1: seq<int>, s2: seq<int>)\n        requires multiset(s1) == multiset(s2)\n        ensures seq_sum(s1) == seq_sum(s2)\n    {\n        if s1 == [] {\n        } else {\n            var x :| x in s1;\n            var i1, i2 :| 0 <= i1 < |s1| && 0 <= i2 < |s2| && s1[i1] == s2[i2] && s1[i1] == x;\nassert s1[..i1] == s1[..i1+1][1..];\nassert s1[..i1+1] == s1[..i1] + s1[i1..i1+1];\nassert s1[..i1] == s1[..i1+1][1..];\n            var remaining1 := s1[..i1] + s1[i1+1..];\n            SeqPartsSameSum(s1[..i1+1], s1[..i1], [x]);\n            SeqPartsSameSum(s1, s1[..i1+1], s1[i1+1..]);\n            SeqPartsSameSum(remaining1, s1[..i1], s1[i1+1..]);\n            var remaining2 := s2[..i2] + s2[i2+1..];\n            SeqPartsSameSum(s2[..i2+1], s2[..i2], [x]);\n            SeqPartsSameSum(s2, s2[..i2+1], s2[i2+1..]);\n            SeqPartsSameSum(remaining2, s2[..i2], s2[i2+1..]);\n            DifferentPermutationSameSum(remaining1, remaining2);\n        }\n    }\n}",
            "success": false
        },
        "online_max_strong.dfy": {
            "state": "method onlineMax(a: array<int>, x: int) returns (ghost m:int, p:int)\n  requires 1<=x<a.Length\n  requires a.Length!=0\n  ensures x<=p<a.Length\n  ensures forall i::0<=i<x==> a[i]<=m\n  ensures exists i::0<=i<x && a[i]==m\n  ensures x<=p<a.Length-1 ==> (forall i::0<=i<p ==> a[i]<a[p])\n  ensures (forall i::x<=i<a.Length && a[i]<=m) ==> p==a.Length-1\n{\n  p:= 0;\n  var best := a[0];\n  var i:=1;\n  while i<x\ninvariant x<=i<=a.Length\ninvariant forall j::0<=j<i ==> a[j]<=best\ninvariant (forall j::x<=j<p ==> a[j]<best)\n  {\n    if a[i]>best{\n      best:=a[i];\n    }\n    i:=i+1;\n  }\n  m:=best;\n  i:=x;\n  while i<a.Length\n  {\n    if a[i]>best{\n      p:=i;\n      return;\n    }\n    i:=i+1;\n  }\n  p:=a.Length-1;\n}",
            "success": false
        },
        "cs245-verification_tmp_tmp0h_nxhqp_SortingIssues_FirstAttempt.dfy": {
            "state": "// Sorting: \n//        Pre/Post Condition Issues - An investigation \n//                                      -- Stephanie McIntyre\n// Based on examples in class \n// First Attempt at specifying requirements for sorting array A in incrementing order\n// We want our Hoare triple of (|Pre-Condition|) Code (|Post-Condition|) to hold iff A is properly sorted.\nmethod sort(A: array<int>, n: int)\nmodifies A; requires n==A.Length;\n/* Pre-Condition */   requires n>=0;            \n/* Post-Condition */  ensures forall i,j:: 0<=i<=j<n ==> A[i]<=A[j];  //This states that A is sorted.\n//Can we write code that does not sort A that still satisfies the requirements? \n//Consider the following program:\n{\nassert forall i,j::0<=i<=j<n ==> A[i]<=A[j];\n  var k := 0;\n  while(k<n)\ndecreases n-k;\n  {\n    A[k] := k;\n    k := k+1;\n  }\n}",
            "success": false
        },
        "Dafny_Verify_tmp_tmphq7j0row_AI_agent_verify_examples_ComputePower.dfy": {
            "state": "function Power(n: nat): nat {\n    if n == 0 then 1 else 2 * Power(n - 1)\n}\nmethod ComputePower(N: int) returns (y: nat) requires N >= 0\n    ensures y == Power(N)\n{\n    y := 1;\n    var x := 0; \n    while x != N\ndecreases N - x\ndecreases N - x\n    {\n        x, y := x + 1, y + y;\n    } \n}",
            "success": false
        },
        "dafny-language-server_tmp_tmpkir0kenl_Test_hofs_Requires.dfy": {
            "state": "// RUN: %dafny /compile:3 /print:\"%t.print\" /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\nmethod Main()\n{\n  test0(10);\n\ttest5(11);\n\ttest6(12);\n\ttest1();\n\ttest2();\n}\npredicate valid(x:int)\n{\n  x > 0\n}\nfunction ref1(y:int) : int\n  requires valid(y);\n{\n  y - 1\n}\nlemma assumption1()\n  ensures forall a, b :: valid(a) && valid(b) && ref1(a) == ref1(b) ==> a == b;\n{\n}\nmethod test0(a: int)\n{\n  if ref1.requires(a) {\n    // the precondition should suffice to let us call the method\n    ghost var b := ref1(a);\n  }\n}\nmethod test5(a: int)\n{\n  if valid(a) {\n    // valid(a) is the precondition of ref1\n    assert ref1.requires(a);\n  }\n}\nmethod test6(a: int)\n{\n  if ref1.requires(a) {\n    // the precondition of ref1 is valid(a)\n    assert valid(a);\n  }\n}\nmethod test1()\n{\n  if * {\n    assert forall a, b :: valid(a) && valid(b) && ref1(a) == ref1(b) ==> a == b;\n  } else {\n    assert forall a, b :: ref1.requires(a) && ref1.requires(b) && ref1(a) == ref1(b)\n                          ==> a == b;\n  }\n}\nfunction {:opaque} ref2(y:int) : int        // Now with an opaque attribute\n  requires valid(y);\n{\n  y - 1\n}\nlemma assumption2()\n  ensures forall a, b :: valid(a) && valid(b) && ref2(a) == ref2(b) ==> a == b;\n{\n  reveal ref2();\n}\nmethod test2()\n{\n  assumption2();\n  if * {\n  } else {\nassert forall a, b :: ref2.requires(a) && ref2.requires(b) && ref2(a) == ref2(b)\n                          ==> a == b;\n  }\n}",
            "success": true
        },
        "Dafny-Exercises_tmp_tmpjm75muf__Session6Exercises_ExerciseCountMin.dfy": {
            "state": "function min(v:array<int>,i:int):int\ndecreases i\n reads v\n requires 1<=i<=v.Length\n ensures forall k::0<=k<i==> v[k]>=min(v,i)\n {if (i==1) then v[0]\n  else if (v[i-1]<=min(v,i-1)) then v[i-1]\n  else min(v,i-1)\n  }\nfunction countMin(v:array<int>,x:int, i:int):int\ndecreases i\n reads v\n  requires 0<=i<=v.Length\n  ensures !(x in v[0..i]) ==> countMin(v,x,i)==0\n  {\n   if (i==0) then 0\n   else if (v[i-1]==x) then 1+countMin(v,x,i-1)\n   else countMin(v,x,i-1)\n  }\n method mCountMin(v:array<int>) returns (c:int)\nrequires v.Length>0\nensures c==countMin(v,min(v,v.Length),v.Length)\n//Implement and verify an O(v.Length) algorithm \n{\n  var i:=1;\n  c:=1;\n  var mini:=v[0];\n  while(i<v.Length)\ninvariant 1 <= i <= v.Length && 1 <= c <= i\ninvariant mini==min(v,i) && c == countMin(v,mini,i)\n  {\n    if(v[i]==mini){\n      c:=c + 1;\n    }\n    else if(v[i]<mini){\n      c:=1;\n      mini:=v[i];\n    }\n    i:=i+1;\n  }\n}",
            "success": true
        },
        "Prog-Fun-Solutions_tmp_tmp7_gmnz5f_mockExam2_p5.dfy": {
            "state": "// problem 5:\n// name:      Gabriele Berardi\n// s-number: s4878728\n// table:     XXXX\nghost function f(n: int): int {\n  if n < 0 then 0 else 3*f(n-5) + n\n}\nmethod problem5(n:nat) returns (x: int)\nensures x == f(n)\n{\n    var a := 1;\n    var b := 0;\n    var k := n;\n    while k >= 0\n    {\n        b := a*k + b;\n        a := 3*a;\n        k := k - 5;\n    }\n    x := b;\n}",
            "success": false
        },
        "task_id_18.dfy": {
            "state": "method RemoveChars(s1: string, s2: string) returns (v: string)\n    ensures |v| <= |s1|\n    ensures forall i :: 0 <= i < |v| ==> (v[i] in s1) && !(v[i] in s2)\n    ensures forall i :: 0 <= i < |s1| ==> (s1[i] in s2) || (s1[i] in v)\n{\n    var v' : string := [];\n    for i := 0 to |s1|\ninvariant |v'| <= i\ninvariant forall i :: 0 <= i < |v'| ==> (v'[i] in s1) && !(v'[i] in s2)\ninvariant forall i :: 0 <= i <= i - 1 + |v'| ==> (s1[i] in s2) || (s1[i] in v')\n    {\n        if !(s1[i] in s2)\n        {\n            v' := v' + [s1[i]];\n        }\n    }\n    return v';\n}",
            "success": false
        },
        "specTesting_tmp_tmpueam35lx_examples_sort_sort.dfy": {
            "state": "method quickSort(intSeq:array<int>)\n    modifies intSeq\n    ensures forall i:nat, j:nat | 0 <= i <= j < intSeq.Length :: intSeq[i] <= intSeq[j]\n    // ensures multiset(intSeq[..]) == multiset(old(intSeq[..]))\nlemma sort(prevSeq:seq<int>) returns (curSeq:seq<int>)\n    ensures (forall i:nat, j:nat | 0 <= i <= j < |curSeq| :: curSeq[i] <= curSeq[j])\n    ensures multiset(prevSeq) == multiset(curSeq)\npredicate post_sort(prevSeq:seq<int>, curSeq:seq<int>)\n{\n    && (forall i:nat, j:nat | 0 <= i <= j < |curSeq| :: curSeq[i] <= curSeq[j])\n    && multiset(prevSeq) == multiset(curSeq)\n}\nlemma multisetAdditivity(m1:multiset<int>, m2:multiset<int>, m3:multiset<int>, m4:multiset<int>)\n    requires m1 == m2 + m3\n    requires m1 == m2 + m4\n    ensures m3 == m4\n    {\n    }\nlemma twoSortedSequencesWithSameElementsAreEqual(s1:seq<int>, s2:seq<int>)\n    requires (forall i:nat, j:nat | 0 <= i <= j < |s1| :: s1[i] <= s1[j])\n    requires (forall i:nat, j:nat | 0 <= i <= j < |s2| :: s2[i] <= s2[j])\n    requires multiset(s1) == multiset(s2)\n    requires |s1| == |s2|\n    ensures s1 == s2\n{\n    if (|s1| != 0) {\n        if s1[|s1|-1] == s2[|s2|-1] {\n            multisetAdditivity(multiset(s1), multiset([s1[|s1|-1]]), multiset(s1[..|s1|-1]), multiset(s2[..|s1|-1]));\n        }\n        twoSortedSequencesWithSameElementsAreEqual(s1[..|s1|-1], s2[..|s2|-1]);\n        } else if s1[|s1|-1] < s2[|s2|-1] {\n        } else {\n        }\n    }\n}\nlemma sort_determinisitc(prevSeq:seq<int>, curSeq:seq<int>, curSeq':seq<int>)\n    requires post_sort(prevSeq, curSeq)\n    requires post_sort(prevSeq, curSeq')\n    ensures curSeq == curSeq'\n{\n    if (|curSeq| != |curSeq'|) {\n    } else {\n        twoSortedSequencesWithSameElementsAreEqual(curSeq, curSeq');\n    }\n}\nlemma sort_determinisitc1(prevSeq:seq<int>, curSeq:seq<int>, curSeq':seq<int>)\n    requires prevSeq == [5,4,3,2,1]\n    requires post_sort(prevSeq, curSeq)\n    requires post_sort(prevSeq, curSeq')\n    ensures curSeq == curSeq'\n{\n}",
            "success": false
        },
        "reverse_strong.dfy": {
            "state": "method reverse(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[a.Length - 1 - i])\n{\n  var i := 0;\n  while i <a.Length / 2\ninvariant forall j :: 0 <= j < i ==> a[j] == old(a[a.Length-1-j])\ninvariant forall j :: i <= j < a.Length/2 ==> a[j] == old(a[a.Length-1-j])\ndecreases a.Length - i\n  {\n    a[i], a[a.Length-1-i] := a[a.Length-1-i], a[i];\n    i := i + 1;\n  }\n}",
            "success": false
        },
        "task_id_94.dfy": {
            "state": "method MinSecondValueFirst(s: array<seq<int>>) returns (firstOfMinSecond: int)\n    requires s.Length > 0\n    requires forall i :: 0 <= i < s.Length ==> |s[i]| >= 2\n    ensures exists i :: 0 <= i < s.Length && firstOfMinSecond == s[i][0] && \n        (forall j :: 0 <= j < s.Length ==> s[i][1] <= s[j][1])\n{\n    var minSecondIndex := 0;\n    for i := 1 to s.Length\n    {\n        if s[i][1] < s[minSecondIndex][1]\n        {\n            minSecondIndex := i;\n        }\n    }\n    firstOfMinSecond := s[minSecondIndex][0];\n}",
            "success": false
        },
        "task_id_113.dfy": {
            "state": "predicate IsDigit(c: char)\n{\n    48 <= c as int <= 57\n}\nmethod IsInteger(s: string) returns (result: bool)\n    ensures result <==> (|s| > 0) && (forall i :: 0 <= i < |s| ==> IsDigit(s[i]))\n{\n    result := true;\n    if |s| == 0 {\n        result := false;\n    } else {\n        for i := 0 to |s|\ninvariant (forall j :: 0 <= j < i ==> IsDigit(s[j]))\n        {\n            if !IsDigit(s[i]) {\n                result := false;\n                break;\n            }\n        }\n    }\n}",
            "success": true
        },
        "Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Exercise4_Find_Max.dfy": {
            "state": "method findMax(a:array<int>) returns (pos:int, maxVal: int)\n  requires a.Length > 0;\n  requires forall i :: 0 <= i < a.Length ==> a[i] >= 0;\n  ensures forall i :: 0 <= i < a.Length ==> a[i] <= maxVal;\n  ensures exists i :: 0 <= i < a.Length &&  a[i] == maxVal;\n  ensures 0 <= pos < a.Length\n  ensures a[pos] == maxVal;\n{\n  pos := 0;\n  maxVal := a[0];\n  var j := 1;\n  while(j < a.Length)\ninvariant exists i :: 0 <= i < j && a[i] == maxVal\ninvariant forall i :: 0 <= i < j ==> a[i] <= maxVal;\ninvariant 0 <= j <= a.Length\n  {\n    if (a[j] > maxVal) \n    {\n      maxVal := a[j];\n      pos := j;\n    }\n    j := j+1;\n  }\n  return;\n}",
            "success": false
        },
        "task_id_759.dfy": {
            "state": "method IsDecimalWithTwoPrecision(s: string) returns (result: bool)\n    ensures result ==> (exists i :: 0 <= i < |s| && s[i] == '.' && |s| - i - 1 == 2)\n    ensures !result ==> !(exists i :: 0 <= i < |s| && s[i] == '.' && |s| - i - 1 == 2)\n{\n    result := false;\n    for i := 0 to |s|\ninvariant !result ==> !(exists k :: 0 <= k < i && s[k] == '.' && |s| - k - 1 == 2)\ninvariant result ==> (exists k :: 0 <= k < i && s[k] == '.' && |s| - k - 1 == 2)\n    {\n        if s[i] == '.' && |s| - i - 1 == 2 {\n            result := true;\n            break;\n        }\n    }\n}",
            "success": true
        },
        "Dafny_tmp_tmpmvs2dmry_pancakesort_flip.dfy": {
            "state": "// flips (i.e., reverses) array elements in the range [0..num]\nmethod flip (a: array<int>, num: int)\nrequires a.Length > 0;\nrequires 0 <= num < a.Length;\nmodifies a;\nensures forall k :: 0 <= k <= num ==> a[k] == old(a[num-k])\nensures forall k :: num < k < a.Length ==> a[k] == old(a[k])\n// ensures multiset(a[..]) == old(multiset(a[..]))\n{\n  var tmp:int;\n  var i := 0;\n  var j := num;\n  while (i < j)\ninvariant forall k :: 0 <= k <= i ==> a[k] == old(a[k])\ninvariant forall k :: num < k <= i ==> a[k] == old(a[k])\ninvariant forall k :: i <= k < j ==> a[k] == old(a[k])\n  // invariant 0 <= i < j <= num\n  {\n    tmp := a[i];\n    a[i] := a[j];\n    a[j] := tmp;\n    i := i + 1;\n    j := j - 1;\n  }\n}",
            "success": false
        },
        "is_palindrome_strong.dfy": {
            "state": "method IsPalindrome(x: seq<char>) returns (result: bool)\n  ensures result <==> (forall i :: 0 <= i < |x| ==> x[i] == x[|x| - i - 1])\n{\n  if |x|==0 {\n    return true;\n  }\n  var i := 0;\n  var j := |x| - 1;\n  result := true;\n  while (i < j)\ninvariant 0 <= i <= |x|/2\ninvariant i <= j\ninvariant result <==> (forall s :: 0 <= s < i ==> x[s] == x[|x| - s - 1])\n  {\n    if x[i] != x[j] {\n      result := false;\n      return;\n    }\n    i := i + 1;\n    j := j - 1;\n  }\n}",
            "success": false
        },
        "Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExercisePositive.dfy": {
            "state": "predicate positive(s:seq<int>)\n{forall u::0<=u<|s| ==> s[u]>=0}\nmethod mpositive(v:array<int>) returns (b:bool)\nensures b==positive(v[0..v.Length])\n{\n    var i:=0;\n    //1. assert positive(v[..0])\n    while i<v.Length && v[i]>=0\n        decreases v.Length - i \n        invariant 0<=i<=v.Length\n        invariant positive(v[..i])\n    {\n        //2. assert 0<=i<v.Length && positive(v[..i]);\n        i:=i+1;\n        //2. assert 0<=i<v.Length && positive(v[..i]);\n    }\n    //3. assert i==v.Length ==> positive(v[..]);\n    //3. assert i<v.Length => v[i]<0;\n    b := i==v.Length;\n}\nmethod mpositive3(v:array<int>) returns (b:bool)\nensures b==positive(v[0..v.Length])\n{\n    var i:=0; b:=true;\n    while(i<v.Length && b)\n        decreases v.Length - i \n        invariant 0 <= i <= v.Length\n        invariant b==positive(v[0..i])\n        invariant !b ==> !positive(v[0..v.Length])\n    {\n        b:=v[i]>=0;\n        i:=i+1;\n    }\n}\nmethod mpositive4(v:array<int>) returns (b:bool)\nensures b==positive(v[0..v.Length])\n{\n    var i:=0; b:=true;\n    while(i<v.Length && b)\n        decreases v.Length - i \n        invariant 0 <= i <= v.Length\n        invariant b==positive(v[0..i])\n        invariant !b ==> !positive(v[0..v.Length])\n    {\n        b:=v[i]>=0;\n        i:=i+1;\n    }\n}\nmethod mpositivertl(v:array<int>) returns (b:bool)\nensures b==positive(v[0..v.Length])\n{\n    var i:=v.Length-1;\n    while(i>=0 && v[i]>=0)\ninvariant i+1>=0\ndecreases i\ndecreases v.Length -i\n    {\n        i:=i-1;\n    }\n    b:= i==-1;\n}",
            "success": false
        },
        "task_id_579.dfy": {
            "state": "predicate InArray(a: array<int>, x: int)\n    reads a\n{\n    exists i :: 0 <= i < a.Length && a[i] == x\n}\nmethod DissimilarElements(a: array<int>, b: array<int>) returns (result: seq<int>)\n    // All elements in the output are either in a or b, but not in both or neither\n    ensures forall x :: x in result ==> (InArray(a, x) != InArray(b, x))\n    // The elements in the output are all different\n    ensures forall i, j :: 0 <= i < j < |result| ==> result[i] != result[j]\n{\n    var res: seq<int> := [];\n    for i := 0 to a.Length\n    {\n        if !InArray(b, a[i]) && a[i] !in res\n        {\n            res := res + [a[i]];\n        }\n    }\n    ghost var partialSize := |res|;\nassert partialSize == |res|;\n    for i := 0 to b.Length\ninvariant forall k, l :: 0 <= k < l < partialSize ==> res[k] != res[l]\n    {\n        if !InArray(a, b[i]) && b[i] !in res\n        {\n            res := res + [b[i]];\n        }\n    }\n    result := res;\n}",
            "success": false
        },
        "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_vampire project_original_Searching.dfy": {
            "state": "// Assuming Array is Object Blood\n// Blood Array<int>\n// index\nmethod Find(blood: array<int>, key: int) returns (index: int)\nrequires blood != null\nensures 0 <= index ==> index < blood.Length && blood[index] == key\nensures index < 0 ==> forall k :: 0 <= k < blood.Length ==> blood[k] != key\n{\n   index := 0;\n   while index < blood.Length\ndecreases blood.Length - index\n   {\n      if blood[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n}",
            "success": false
        },
        "Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_normal_data_completion_MaxPerdV2.dfy": {
            "state": "function contains(v: int, a: array<int>, n: int): bool\nreads a\n  requires n <= a.Length\n{\n  exists j :: 0 <= j < n && a[j] == v\n}\nfunction upper_bound(v: int, a: array<int>, n: int): bool\nreads a\n  requires n <= a.Length\n{\n  forall j :: 0 <= j < n ==> a[j] <= v\n}\nfunction is_max(m: int, a: array<int>, n: int): bool\nreads a\n  requires n <= a.Length\n{\n  contains(m, a, n) && upper_bound(m, a, n)\n}\nmethod max(a: array<int>, n: int) returns (max: int)\n  requires 0 < n <= a.Length;\n  ensures is_max(max, a, n);\n{\n  var i: int := 1;\n  max := a[0];\n  while i < n\ninvariant 1 <= i <= n\ninvariant is_max(max, a, i)\n  {\n    if a[i] > max {\n      max := a[i];\n    }\n    i := i + 1;\n  }\n}",
            "success": true
        },
        "count_lessthan_strong.dfy": {
            "state": "method CountLessThan(numbers: set<int>, threshold: int) returns (count: int)\n  ensures count == |set i | i in numbers && i < threshold|\n{\n  count := 0;\n  var shrink := numbers;\n  var grow := {};\n  while |shrink | > 0\n  {\n    var i: int :| i in shrink;\n    shrink := shrink - {i};\n    var grow' := grow+{i};\n           (set i | i in grow && i < threshold )+ if i < threshold then {i} else {};\n    grow := grow + {i};\n    if i < threshold {\n      count := count + 1;\n    }\n  }\n}",
            "success": false
        },
        "Metodos_Formais_tmp_tmpql2hwcsh_Invariantes_multiplicador.dfy": {
            "state": "// Exemplo de invariantes\n// Invariante significa que o valor n\u00e3o muda desde a pr\u00e9-condi\u00e7\u00e3o at\u00e9 a p\u00f3s-condi\u00e7\u00e3o\nmethod Mult(x:nat, y:nat) returns (r:nat)\nensures r == x * y\n{\n    // par\u00e2metros de entrada s\u00e3o imut\u00e1veis, por isso\n    // \u00e9 preciso a atribuir a vari\u00e1veis locais para usar em blocos de c\u00f3digos para mudar\n    var m := x;\n    var n := y;\nassert  n == 3;\n    r := 0;\n    while m > 0 \ninvariant m >= 0 //invariante que deve ter nada a ver com a f\u00f3rmula dela\ninvariant r == m * n + r //invariante que requer\n    {\n        r := r + n;\n        m := m -1;\n    }\n    return r;\n}\n// Teste do m\u00e9todo para encontrar a invariante\n// x | y | m | n | r\n// 5 | 3 | 5 | 3 | 0\n// 5 | 3 | 4 | 3 | 3\n// 5 | 3 | 3 | 3 | 6\n// 5 | 3 | 2 | 3 | 9\n// 5 | 3 | 1 | 3 | 12\n// 5 | 3 | 0 | 3 | 15\n// vimos o seguinte:\n// m * n + r = x * y\n// 5 * 3 + 0 (15) = 5 * 3 (15)\n// portanto a f\u00f3rmula m*n+r == x*y \u00e9 uma invariante\n// mas s\u00f3 isso n\u00e3o serve, o m ele \u00e9 maior ou igual a zero quando acaba o while\n// por isso, tamb\u00e9m \u00e9 a invariante que necessita\n// com isso dizemos para o programa as altera\u00e7\u00f5es do m de maior ou igual a zero\n// e mostramos a fun\u00e7\u00e3o encontrada que alterava o valor de m e n das variaveis criadas\n// SE OS ALGORITMOS TIVEREM REPETI\u00c7\u00c3O OU RECURS\u00c3O, DEVEM SER MOSTRADOS QUAIS S\u00c3O AS INVARIANTES\n// OU SEJA, OS VALORES QUE N\u00c3O EST\u00c3O SENDO MUDADOS E COLOCAR A F\u00d3RMULA DELE COMO ACIMA",
            "success": false
        },
        "t1_MF_tmp_tmpi_sqie4j_exemplos_introducao_ex4.dfy": {
            "state": "function Fat(n: nat): nat\n{\n   if n == 0 then 1 else n * Fat(n-1)\n}\nmethod Fatorial(n:nat)  returns (r:nat)\n  ensures r == Fat(n)\n{\n    r := 1;\n    var i := 0;\nassert 0 <= i <= n && 1 <= r <= Fat(n);\n    while i < n\ndecreases n - i\ninvariant 0 <= i <= n && 1 <= r <= Fat(n)\n    {\n        i := i + 1;\n        r := r * i;\n    }\n}",
            "success": false
        },
        "HATRA-2022-Paper_tmp_tmp5texxy8l_copilot_verification_Two Sum_two_sum.dfy": {
            "state": "method twoSum(nums: array<int>, target: int) returns (index1: int, index2: int)\n    requires 2 <= nums.Length\n    requires exists i, j :: (0 <= i < j < nums.Length && nums[i] + nums[j] == target)\n    ensures index1 != index2\n    ensures 0 <= index1 < nums.Length\n    ensures 0 <= index2 < nums.Length\n    ensures nums[index1] + nums[index2] == target\n{\n    var i := 0;\n    while i < nums.Length\n    {\n        var j := i + 1;\n        while j < nums.Length\ninvariant 0 <= j <= nums.Length\ninvariant nums[i] + nums[j] != target\ninvariant exists k :: i <= k < nums.Length && nums[i] + nums[k] == target\n        {\n            if nums[i] + nums[j] == target\n            {\n                return i, j;\n            } \n            j := j + 1;\n        }\n        i := i + 1;\n    }\n}",
            "success": false
        },
        "task_id_793.dfy": {
            "state": "method LastPosition(arr: array<int>, elem: int) returns (pos: int)\n    requires arr.Length > 0\n    requires forall i, j :: 0 <= i < j < arr.Length ==> arr[i] <= arr[j]\n    ensures pos == -1 || (0 <= pos < arr.Length && arr[pos] == elem && (pos <= arr.Length - 1 || arr[pos + 1] > elem))\n    ensures forall i :: 0 <= i < arr.Length ==> arr[i] == old(arr[i])\n{\n    pos := -1;\n    for i := 0 to arr.Length - 1\ninvariant pos == -1 || (0 <= pos < arr.Length && arr[pos] == elem && (pos <= i || arr[i] > elem))\n    {\n        if arr[i] == elem\n        {\n            pos := i;\n        }\n    }\n}",
            "success": true
        },
        "dafny-language-server_tmp_tmpkir0kenl_Test_vstte2012_Two-Way-Sort.dfy": {
            "state": "// RUN: %dafny /compile:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n// This method is a slight generalization of the\n// code provided in the problem statement since it\n// is generic in the type of the array elements.\nmethod swap<T>(a: array<T>, i: int, j: int)\n  requires 0 <= i < j < a.Length\n  modifies a\n  ensures a[i] == old(a[j])\n  ensures a[j] == old(a[i])\n  ensures forall m :: 0 <= m < a.Length && m != i && m != j ==> a[m] == old(a[m])\n  ensures multiset(a[..]) == old(multiset(a[..]))\n{\n  var t := a[i];\n  a[i] := a[j];\n  a[j] := t;\n}\n// This method is a direct translation of the pseudo\n// code given in the problem statement.\n// The first postcondition expresses that the resulting\n// array is sorted, that is, all occurrences of \"false\"\n// come before all occurrences of \"true\".\n// The second postcondition expresses that the post-state\n// array is a permutation of the pre-state array. To express\n// this, we use Dafny's built-in multisets. The built-in\n// function \"multiset\" takes an array and yields the\n// multiset of the array elements.\n// Note that Dafny guesses a suitable ranking function\n// for the termination proof of the while loop.\n// We use the loop guard from the given pseudo-code.  However,\n// the program also verifies with the stronger guard \"i < j\"\n// (without changing any of the other specifications or\n// annotations).\nmethod two_way_sort(a: array<bool>)\n  modifies a\n  ensures forall m,n :: 0 <= m < n < a.Length ==> (!a[m] || a[n])\n  ensures multiset(a[..]) == old(multiset(a[..]))\n{\n  var i := 0;\n  var j := a.Length - 1;\n  while (i <= j)\ninvariant forall m :: 0 <= m < i ==> a[m]\ndecreases j - i // termination proof starts here\ninvariant multiset(a[..]) == old(multiset(a[..]))\n  {\n    if (!a[i]) {\n      i := i+1;\n    } else if (a[j]) {\n      j := j-1;\n    } else {\n      swap(a, i, j);\n      i := i+1;\n      j := j-1;\n    }\n  }\n}",
            "success": false
        }
    },
    {
        "Prog-Fun-Solutions_tmp_tmp7_gmnz5f_mockExam2_p6.dfy": {
            "state": "// problem 6:\n// name:      Gabriele Berardi\n// s-number: s4878728\n// table:     XXXXX\nghost function f(n: int): int {\n  if n <= 0 then 1 else n + f(n-1)*f(n-2)\n}\nghost function fSum(n: nat): int {\n // give the body of this function\n  // it should return Sum(i: 0<=i < n: f(i))\n  if n <= 0 then 0 else f(n-1) + fSum(n-1)\n}\nmethod problem6(n:nat) returns (a: int)\nensures a == fSum(n)\n{\n  a := 0;\n  var k := 0;\n  var x := 1;\n  var y := 2;\n  while k < n\ndecreases n - k\ninvariant x == f(k-1)\n  {\n    k := k + 1;\n    a := a + x;\n    x, y := y, k+1 + x*y;    \n  }\n}",
            "success": false
        },
        "dafny-exercise_tmp_tmpouftptir_appendArray.dfy": {
            "state": "method appendArray(a: array<int>, b: array<int>) returns (c: array<int>)\nensures c.Length == a.Length + b.Length\nensures forall i :: 0 <= i < a.Length ==> a[i] == c[i]\nensures forall i :: 0 <= i < b.Length ==> b[i] == c[a.Length + i]\n{\n\tc := new int[a.Length + b.Length];\n\tvar i := 0;\n\twhile i < a.Length\ndecreases b.Length\ninvariant forall i :: a.Length <= i < b.Length + a.Length ==> c[i] == b[i - a.Length]\ninvariant a[..i] == c[..a.Length + i]\n\t{\n\t\tc[i] := a[i];\n\t\ti := i + 1;\n\t}\n\twhile i < b.Length + a.Length\n\t{\n\t\tc[i] := b[i - a.Length];\n\t\ti := i + 1;\n\t}\n}",
            "success": false
        },
        "task_id_573.dfy": {
            "state": "method UniqueProduct (arr: array<int>) returns (product: int)\n   ensures product == SetProduct((set i | 0 <= i < arr.Length :: arr[i]))\n{\n    var p := 1;\n    var seen: set<int> := {};\n    for i := 0 to arr.Length\n        invariant 0 <= i <= arr.Length\n        invariant seen == (set k | 0 <= k < i :: arr[k])\n        invariant p == SetProduct((set k | 0 <= k < i :: arr[k]))\n    {\n        if ! (arr[i] in seen) {\n            seen := seen + { arr[i] };\n            p := p * arr[i];\n            SetProductLemma(seen, arr[i]);\n        }\n    }\n    product := p;\n}\nghost function SetProduct(s : set<int>) : int\n{\n    if s == {} then 1\n    else var x :| x in s; \n         x * SetProduct(s - {x})\n}\n/* \n * This is necessary because, when we add one element, we need to make sure\n * that the product of the new set, as a whole, is the same as the product\n * of the old set times the new element.\n */\nlemma SetProductLemma(s: set <int>, x: int) \n requires x in s\n ensures SetProduct(s - {x}) * x == SetProduct(s)\n{\n   if s != {}\n   {\nassert s == s - {x} + {x};\n      var y :| y in s && y * SetProduct(s - {y}) == SetProduct(s);\n      if y == x {}\n      else {\n         calc {\n            SetProduct(s);\n            y * SetProduct(s - {y});\n            { SetProductLemma(s - {y}, x); }\n            y * x * SetProduct(s - {y} - {x});\n            { assert s - {x} - {y} == s - {y} - {x};}\n            y * x * SetProduct(s - {x} - {y});\n            x * y * SetProduct(s - {x} - {y});\n            { SetProductLemma(s - {x}, y); }\n            x * SetProduct(s - {x});\n         }\n      }\n   }\n}",
            "success": true
        },
        "task_id_769.dfy": {
            "state": "method Difference(a: seq<int>, b: seq<int>) returns (diff: seq<int>)\n    ensures forall x :: x in diff <==> (x in a && x !in b)\n    ensures forall i, j :: 0 <= i < j < |diff| ==> diff[i] != diff[j]\n{\n    diff := [];\n    for i := 0 to |a|\ninvariant 0 <= i <= |a|\ninvariant forall k :: 0 <= k < i ==> a[k] in b ==> a[k] in diff\ninvariant forall k, l :: 0 <= k < l < |diff| ==> diff[k] != diff[l]\ninvariant forall k :: 0 <= k < i ==> a[k] !in b ==> a[k] !in diff\n    {\n        if a[i] !in b && a[i] !in diff\n        {\n            diff := diff + [a[i]];\n        }\n    }\n}",
            "success": false
        },
        "Dafny_Programs_tmp_tmp99966ew4_lemma.dfy": {
            "state": "lemma SkippingLemma(a : array<int>, j : int)\n   requires a != null\n   requires forall i :: 0 <= i < a.Length ==> 0 <= a[i]\n   requires forall i :: 0 < i < a.Length ==> a[i-1]-1 <= a[i]\n   requires 0 <= j < a.Length\n   ensures forall k :: j <= k < j + a[j] && k < a.Length ==> a[k] != 0\n{\n   var i := j;\n   while i < j + a[j] && i < a.Length\n   decreases j + a[j] - i\n      invariant i < a.Length ==> a[j] - (i-j) <= a[i]\n      invariant forall k :: j <= k < i && k < a.Length ==> a[k] != 0\n   {\n      i := i + 1;\n   }\n}\nmethod FindZero(a: array<int>) returns (index: int)\n   requires a != null\n   requires forall i :: 0 <= i < a.Length ==> 0 <= a[i]\n   requires forall i :: 0 < i < a.Length ==> a[i-1]-1 <= a[i]\n   ensures index < 0  ==> forall i :: 0 <= i < a.Length ==> a[i] != 0\n   ensures 0 <= index ==> index < a.Length && a[index] == 0\n{\n   index := 0;\n   while index < a.Length\ninvariant forall i :: 0 <= i < index && i < a.Length ==> a[i] != 0\ninvariant index < a.Length ==> forall k :: 0 <= k < index && k < a.Length ==> a[k] != 0\n   {\n      if a[index] == 0 { return; }\n      SkippingLemma(a, index);\n      index := index + a[index];\n   }\n   index := -1;\n}",
            "success": true
        },
        "Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 3_InsertionSortMultiset.dfy": {
            "state": "// H\u00f6fundur spurningar:  Snorri Agnarsson, snorri@hi.is\n// Permalink spurningar: https://rise4fun.com/Dafny/G4sc3\n// H\u00f6fundur lausnar:     Alexander Gu\u00f0mundsson\n// Permalink lausnar:    https://rise4fun.com/Dafny/nujsu\n// Insertion sort me\u00f0 hj\u00e1lp helmingunarleitar.\nmethod Search( s: seq<int>, x: int ) returns ( k: int )\n    // Ekki m\u00e1 breyta forskilyr\u00f0um e\u00f0a eftirskilyr\u00f0um fallsins\n    requires forall p,q | 0 <= p < q < |s| :: s[p] <= s[q];\n    ensures 0 <= k <= |s|;\n    ensures forall i | 0 <= i < k :: s[i] <= x;\n    ensures forall i | k <= i < |s| :: s[i] >= x;\n    ensures forall z | z in s[..k] :: z <= x;\n    ensures forall z | z in s[k..] :: z >= x;\n    ensures s == s[..k]+s[k..];\n{\n    // Setji\u00f0 vi\u00f0eigandi stofn fallsins h\u00e9r.\n    var p := 0;\n    var q := |s|;\n    if p == q\n    {\n        return p;\n    }\n    while p != q \n        decreases q-p;\n        invariant 0 <= p <= q <= |s|;\n        invariant forall r | 0 <= r < p :: s[r] <= x;\n        invariant forall r | q <= r < |s| :: s[r] >= x;\n    {\n        var m := p + (q-p)/2;\n        if s[m] == x\n        {\n            return m;\n        }\n        if s[m] < x\n        {\n            p := m+1;\n        }\n        else\n        {\n            q := m;\n        }\n    }\n    return p;\n}\nmethod Sort( m: multiset<int> ) returns ( r: seq<int> )\n    ensures multiset(r) == m;\n    ensures forall p,q | 0 <= p < q < |r| :: r[p] <= r[q];\n{\n    // Setji\u00f0 vi\u00f0eigandi frumstillingu \u00e1 r og rest h\u00e9r.\n    // r er skilabreyta en rest er n\u00fd breyta sem \u00fei\u00f0 b\u00fai\u00f0 til.\n    r := [];\n    var rest := m;\n    while rest != multiset{}\ninvariant forall p,q | 0 <= p < q < |r| :: r[p] <= r[q];\ndecreases rest;\n        // Ekki breyta fastayr\u00f0ingu lykkju\n    {\n        // Setji\u00f0 vi\u00f0eigandi stofn lykkjunnar h\u00e9r.\n        // Fjarl\u00e6gi\u00f0 eitt gildi \u00far rest me\u00f0\n        //    var x :| x in rest;\n        //    rest := rest-multiset{x};\n        // og noti\u00f0 Search til a\u00f0 finna r\u00e9ttan sta\u00f0\n        // \u00ed r til a\u00f0 stinga [x] inn \u00ed r.\n        var x :| x in rest;\n        rest := rest - multiset{x};\n        var k := Search(r, x);\n        r := r[..k] + [x] + r[k..];\n    }\n    return r;\n}",
            "success": false
        },
        "Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseFirstNegative.dfy": {
            "state": "predicate positive(s:seq<int>)\n{forall u::0<=u<|s| ==> s[u]>=0}\nmethod mfirstNegative(v:array<int>) returns (b:bool, i:int)\nensures b <==> exists k::0<=k<v.Length && v[k]<0\nensures b ==> 0<=i<v.Length && v[i]<0 && positive(v[0..i])\n{ \n i:=0;\n b:=false;\n while (i<v.Length && !b)\n    invariant 0<=i<=v.Length\n    invariant b <==> exists k::0<=k<i && v[k]<0\n    invariant b ==> v[i-1]<0 && positive(v[0..i-1])\n    decreases v.Length - i\n  { \n    b:=(v[i]<0);\n    i:=i+1;\n   }\n  if (b){i:=i-1;}\n}\nmethod mfirstNegative2(v:array<int>) returns (b:bool, i:int)\nensures b <==> exists k::0<=k<v.Length && v[k]<0\nensures b ==> 0<=i<v.Length && v[i]<0 && positive(v[0..i])\n{ \n i:=0;b:=false;\n while (i<v.Length && !b)\ndecreases v.Length-i\ninvariant b <==> exists k::0<=k<i && v[k]<0\ninvariant 0<=i<=v.Length\ninvariant b ==> v[i-1]<0 && positive(v[0..i-1])\n  { \n    b:=(v[i]<0);\n    if (!b) {i:=i+1;}\n   }\n}",
            "success": false
        },
        "Metodos_Formais_tmp_tmpbez22nnn_Aula_2_ex1.dfy": {
            "state": "method Mult(x:nat, y:nat) returns (r: nat)\nensures r == x * y\n{\n    var m := x;\nassert m == x; // x has the right value\n    var n := y;\nassert r == x*y-n; // r still has the right value\n    r:=0;\n    while m > 0\ninvariant m <= x && r == x*y-m; // m <= x\ndecreases m\n    {\n        r := r + n;\n        m := m - 1;\n    }\n    return r;\n}",
            "success": false
        },
        "insert_strong.dfy": {
            "state": "method insert(line:array<char>, l:int, nl:array<char>, p:int, at:int)\n  requires 0 <= l+p <= line.Length\n  requires 0 <= p <= nl.Length\n  requires 0 <= at <= l\n  modifies line\n  ensures forall i :: (0<=i<p) ==> line[at+i] == nl[i]\n  ensures forall i :: (0<=i<at) ==> line[i] == old(line[i])\n  ensures forall i :: (at+p<=i<l+p) ==> line[i] == old(line[i-p])\n{\n  ghost var initialLine := line[..];\n  var i:int := l;\n  while(i>at)\ninvariant forall i :: (i < p || at+i < l) ==> line[at+i] == (if i<p then nl[i] else line[i])\ndecreases i\n  {\n    i := i - 1;\n    line[i+p] := line[i];\n  }\n  i := 0;\n  while(i<p)\n  {\n    line[at + i] := nl[i];\n    i := i + 1;\n  }\n}",
            "success": false
        },
        "task_id_743.dfy": {
            "state": "method RotateRight(l: seq<int>, n: int) returns (r: seq<int>)\n    requires n >= 0\n    ensures |r| == |l|\n    ensures forall i :: 0 <= i < |l| ==> r[i] == l[(i - n + |l|) % |l|]\n{\n    var rotated: seq<int> := [];\n    for i := 0 to |l|\ninvariant |rotated| == i\ninvariant forall j :: 0 <= j < i ==> rotated[j] == l[(j - n + |l|) % |l|]\n    {\n        rotated := rotated + [l[(i - n + |l|) % |l|]];\n    }\n    return rotated;\n}",
            "success": true
        },
        "Dafny_Verify_tmp_tmphq7j0row_Test_Cases_solved_1_select.dfy": {
            "state": "method SelectionSort(a: array<int>)\n  modifies a\n  ensures forall i,j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures multiset(a[..]) == old(multiset(a[..]))\n{\n  var n := 0;\n  while n != a.Length\n  {\n    var mindex, m := n, n;\n    while m != a.Length\ninvariant n <= m <= a.Length\ninvariant forall i :: n <= i < m ==> a[mindex] <= a[i]\n    {\n      if a[m] < a[mindex] {\n        mindex := m;\n      }\n      m := m + 1;\n    }\n    if a[mindex] < a[n] {\n      a[mindex], a[n] := a[n], a[mindex];\n    }\n    n := n + 1;\n  }  \n}",
            "success": false
        },
        "task_id_414.dfy": {
            "state": "method AnyValueExists(seq1: seq<int>, seq2: seq<int>) returns (result: bool)\n    ensures result <==> (exists i :: 0 <= i < |seq1| && seq1[i] in seq2)\n{\n    result := false;\n    for i := 0 to |seq1|\ninvariant result <==> (exists k :: 0 <= k < i && seq1[k] in seq2)\n    {\n        if seq1[i] in seq2 {\n            result := true;\n            break;\n        }\n    }\n}",
            "success": true
        },
        "Correctness_tmp_tmpwqvg5q_4_MethodCalls_q1.dfy": {
            "state": "/**\n  (a) Verify whether or not the following program\n      satisfies total correctness.\n      You should use weakest precondition reasoning\n      and may extend the loop invariant if required.\n      You will need to add a decreases clause to prove termination\n  (a) Weakest precondition proof (without termination) (6 marks)\n      Termination proof (2marks)\n*/\nfunction fusc(n: int): nat\nlemma rule1()\n  ensures fusc(0) == 0\nlemma rule2()\n  ensures fusc(1) == 1\nlemma rule3(n:nat)\n  ensures fusc(2*n) == fusc(n)\nlemma rule4(n:nat)\n  ensures fusc(2*n+1) == fusc(n) + fusc(n+1)\nmethod ComputeFusc(N: int) returns (b: int)\n  requires N >= 0 \n  ensures b == fusc(N)\n{\n  b := 0;\n  var n, a := N, 1;\n  while (n != 0)\n  {\n    ghost var d := n; // termination metric\n    if (n % 2 == 0)\n    {\n      rule4(n/2);\n      rule3(n/2);\n      a := a + b;\n      n := n / 2;\n    } else {\n      rule4((n-1)/2);\n      rule3((n-1)/2);\n      rule3((n+1)/2);\n              b * fusc(n) - b  * fusc(n) + b  * fusc(((n-1)/2)+1) + a * fusc(n);\n              b * fusc(n) - b  * (fusc(n) - fusc(((n-1)/2)+1)) + a * fusc(n);\n              a * fusc(n - 1) + b  * fusc(n) - b  * fusc(n-1) + a * fusc(n) - a * fusc(n-1);\n      b := b + a;\n      n := (n - 1) / 2;\n    }\n  }\n  rule1();\n  rule2();\n}",
            "success": false
        },
        "Workshop_tmp_tmp0cu11bdq_Workshop_Answers_Question6.dfy": {
            "state": "method arrayUpToN(n: int) returns (a: array<int>)\n    requires n >= 0\n    ensures a.Length == n\n    ensures forall j :: 0 < j < n ==> a[j] >= 0\n    ensures forall j, k : int :: 0 <= j <= k < n ==> a[j] <= a[k]\n{\n    var i := 0;\n    a := new int[n];\n    while i < n\ndecreases n - i\ninvariant forall j, k :: 0 <= j <= k < i ==> a[j] <= a[k]\n    {\n        a[i] := i;\n        i := i + 1;\n    }\n}",
            "success": false
        },
        "Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_50_examples_SumArray.dfy": {
            "state": "function Sum(arr: array<int>, len: int): int\n    reads arr\n    requires arr.Length > 0 && 0 <= len <= arr.Length\n{\n    if len == 0 then 0 else arr[len-1] + Sum(arr, len-1)\n}\nmethod SumArray(arr: array<int>) returns (sum: int)\n    requires arr.Length > 0\n    ensures sum == Sum(arr, arr.Length)\n{\n    sum := 0;\n    var i := 0;\n    while i < arr.Length\ninvariant 0 <= i <= arr.Length\ndecreases arr.Length - i\ninvariant sum == Sum(arr, i)\n    {\n        sum := sum + arr[i];\n        i := i + 1;\n    }\n}",
            "success": true
        },
        "task_id_424.dfy": {
            "state": "method ExtractRearChars(l: seq<string>) returns (r: seq<char>)\n    requires forall i :: 0 <= i < |l| ==> |l[i]| > 0\n    ensures |r| == |l|\n    ensures forall i :: 0 <= i < |l| ==> r[i] == l[i][|l[i]| - 1]\n{\n    var rearChars: seq<char> := [];\n    for i := 0 to |l|\ninvariant |rearChars| == i\ninvariant forall j :: 0 <= j < i ==> rearChars[j] == l[j][|l[j]| - 1]\n    {\n        rearChars := rearChars + [l[i][|l[i]| - 1]];\n    }\n    return rearChars;\n}",
            "success": true
        },
        "task_id_3.dfy": {
            "state": "method IsNonPrime(n: int) returns (result: bool)\n    requires n >= 2\n    ensures result <==> (exists k :: 2 <= k < n && n % k == 0)\n{\n    result := false;\n    var i := 2;\n    while i <= n/2\ninvariant result <==> (exists j :: 2 <= j < i && n % j == 0)\n    {\n        if n % i == 0\n        {\n            result := true;\n            break;\n        }\n        i := i + 1;\n    }\n}",
            "success": true
        },
        "task_id_8.dfy": {
            "state": "method SquareElements(a: array<int>) returns (squared: array<int>)\n    ensures squared.Length == a.Length\n    ensures forall i :: 0 <= i < a.Length ==> squared[i] == a[i] * a[i]\n{\n    squared := new int[a.Length];\n    for i := 0 to a.Length\ninvariant forall j :: 0 <= j < i ==> squared[j] == a[j] * a[j]\n    {\n        squared[i] := a[i] * a[i];\n    }\n}",
            "success": true
        },
        "task_id_170.dfy": {
            "state": "function sumTo( a:array<int>, start:int, end:int ) : int\n    requires a != null;\n    requires 0 <= start && start <= end && end <= a.Length;\n    decreases end;\n    reads a;\n    {\n        if (start == end) then 0 else sumTo(a, start, end-1) + a[end-1]\n    }\n    method SumInRange(a: array<int>, start: int, end: int) returns (sum: int)\n    requires a != null\n    requires 0 <= start && start <= end && end <= a.Length\n    ensures sum == sumTo(a, start, end)\n    {\n        sum := 0;\n        for i := start to end\ninvariant sum == sumTo(a, start, i)\n        {\n            sum := sum + a[i];\n        }\n    }",
            "success": true
        },
        "ProjectosCVS_tmp_tmp_02_gmcw_Handout 1_CVS_handout1_55754_55780.dfy": {
            "state": "/**\nCVS 2021-22 Handout 1\nAuthors\nGon\u00e7alo Martins Louren\u00e7o n\u00ba55780\nJoana Soares Faria  n\u00ba55754\n */\n// First Exercise\nlemma peasantMultLemma(a:int, b:int)\n    requires b >= 0\n    ensures b % 2 == 0 ==> (a * b == 2 * a * b / 2)\n    ensures b % 2 == 1 ==> (a * b == a + 2 * a * (b - 1) / 2)\n    {\n        if (b % 2 == 0 && b > 0) { \n            peasantMultLemma(a, b - 2);\n        }\n        if (b % 2 == 1 && b > 1) {\n            peasantMultLemma(a, b - 2);\n        }\n    }\nmethod peasantMult(a: int, b: int) returns (r: int)\n    requires b > 0\n    ensures r == a * b\n    {\n        r := 0;\n        var aa := a;\n        var bb := b;\n        while(bb > 0)\n            decreases bb \n            invariant 0 <= bb <= b\n            invariant r + aa * bb == a * b\n        { \n            // Use of lemma was not necessary for a successful verification\n            // peasantMultLemma(aa, bb);\n            if (bb % 2 == 0)\n            {\n                aa := 2 * aa;\n                bb := bb / 2;\n            } else if (bb % 2 == 1)\n            {\n                r := r + aa;\n                aa := 2 * aa;\n                bb := (bb-1) / 2;\n            }\n        } \n    }\n//Second Exercise\nmethod euclidianDiv(a: int,b : int) returns (q: int,r: int)\n    requires a >= 0\n    requires b > 0\n    ensures a == b * q + r\n    {\nassert a  ==  b * q + r;\n        r := a;\n        q := 0;\n        while(r - b >= 0)\ninvariant r <= a\ndecreases r\ninvariant r >= 0\n            // invariant a == b * q + r\n        {\n            r := r - b;\n            q := q + 1;\n        }\n    }",
            "success": false
        },
        "Software-Verification_tmp_tmpv4ueky2d_Best Time to Buy and Sell Stock_best_time_to_buy_and_sell_stock.dfy": {
            "state": "method best_time_to_buy_and_sell_stock(prices: array<int>) returns (max_profit: int)\n    requires 1 <= prices.Length <= 100000\n    requires forall i :: 0 <= i < prices.Length ==> 0 <= prices[i] <= 10000\n    ensures forall i, j :: 0 <= i < j < prices.Length ==> max_profit >= prices[j] - prices[i]\n{\n    var min_price := 10001;\n    max_profit := 0;\n    var i := 0;\nassert max_profit >= prices[i] - min_price;\n    while (i < prices.Length)\ninvariant i <= prices.Length\ninvariant min_price <= 10001\ninvariant forall j :: 0 <= j < i ==> min_price <= prices[j]\n    {\n        var price := prices[i];\n        if (price < min_price)\n        {\n            min_price := price;\n        }\n        if (price - min_price > max_profit) {\n            max_profit := price - min_price;\n        }\n        i := i + 1;\n    }\n}",
            "success": false
        },
        "dafny_examples_tmp_tmp8qotd4ez_leetcode_0001-two-sum.dfy": {
            "state": "// If this invariant is added explicitly to the loop then the verfication never finishes.\n// It could be {:opaque} for a more controlled verification:\n// assert InMap([], m, target) by {\n//   reveal InMap();\n// }\npredicate InMap(nums: seq<int>, m: map<int, int>, t: int) {\n  forall j :: 0 <= j < |nums| ==> t - nums[j] in m\n}\nmethod TwoSum(nums: array<int>, target: int) returns (r: (int, int))\n  ensures 0 <= r.0 ==> 0 <= r.0 < r.1 < nums.Length && \n                       nums[r.0] + nums[r.1] == target &&\n                       forall i, j :: 0 <= i < j < r.1 ==> nums[i] + nums[j] != target\n  ensures r.0 == -1 <==> forall i, j :: 0 <= i < j < nums.Length ==> nums[i] + nums[j] != target\n{\n  var m: map<int, int> := map[];\n  var i := 0;\nassert 0 <= i < nums.Length ==> InMap(nums[..i], m, target);\n  while i < nums.Length\ninvariant 0 <= i <= nums.Length\ninvariant InMap(nums[..i], m, target) // Once this assertion is removed, the verification finishes quickly, and when this assertion is added, the verification never finishes.\n  {\n    if nums[i] in m {\n      return (m[nums[i]], i);\n    }\n    m := m[target - nums[i] := i];\n    i := i + 1;\n  }\n  return (-1, -1);\n}",
            "success": false
        },
        "CVS-Projto1_tmp_tmpb1o0bu8z_Hoare.dfy": {
            "state": "method Max (x: nat, y:nat) returns (r:nat)\n    ensures (r >= x && r >=y)\n    ensures (r == x || r == y)\n{\n    if (x >= y) { r := x;}\n    else { r := y;}\n}\nmethod Test ()\n{\n    var result := Max(42, 73);\n    assert result == 73;\n}\nmethod m1 (x: int, y: int) returns (z: int)\nrequires 0 < x < y\nensures z >= 0 && z <= y && z != x\n{\n    //assume 0 < x < y\n    z := 0;\n}\nfunction fib (n: nat) : nat\n{\n    if n == 0 then 1 else\n    if n == 1 then 1 else\n    fib(n -1) + fib (n-2)\n}\nmethod Fib (n: nat) returns (r:nat)\n    ensures r == fib(n)\n{\n    if (n == 0) {\n        return 1;\n    }\n    r := 1;\n    var next:=2;\n    var i := 1;\n    while i < n\n        invariant 1 <= i <= n\n        invariant r == fib(i)\n        invariant next == fib(i+1)\n    {\n        var tmp:=next;\n        next:= next + r;\n        r:= tmp;\n        i:= i + 1;\n    }\n    assert r == fib(n);\n    return r;\n}\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\nfunction add(l:List<int>) : int\n{\n    match l\n    case Nil => 0\n    case Cons(x, xs) => x + add(xs)\n}\nmethod addImp (l: List<int>) returns (s: int)\n    ensures s == add(l)\n{\n    var ll := l;\n    s := 0;\n    while ll != Nil\n        decreases ll\n        invariant add(l) == s + add(ll)\n        {\n            s := s + ll.head;\n            ll:= ll.tail;\n        }\n    assert s == add(l);\n}\nmethod MaxA (a: array<int>) returns (m: int)\n    requires a.Length > 0\n    ensures forall i :: 0 <= i < a.Length ==> a[i] <= m\n    ensures exists i :: 0 <= i < a.Length && a[i] == m\n{\n    m := a[0];\n    var i := 1;\n    while i< a.Length\ninvariant 0 <= i <= a.Length\ninvariant forall j :: 0 <= j < i ==> a[j] <= m\ninvariant exists j :: 0 <= j < i && a[j] == m\n    {\n        if a[i] > m {\n            m:= a[i];\n        }\n        i := i +1;\n    }\n}",
            "success": true
        },
        "task_id_807.dfy": {
            "state": "predicate IsOdd(x: int)\n{\n    x % 2 != 0\n}\nmethod FindFirstOdd(a: array<int>) returns (found: bool, index: int)\n    requires a != null\n    ensures !found ==> forall i :: 0 <= i < a.Length ==> !IsOdd(a[i])\n    ensures found ==> 0 <= index < a.Length && IsOdd(a[index]) && forall i :: 0 <= i < index ==> !IsOdd(a[i])\n{\n    found := false;\n    index := 0;\n    while (index < a.Length)\ninvariant 0 <= index <= a.Length\ninvariant !found ==> forall i :: 0 <= i < index ==> !IsOdd(a[i])\ninvariant found ==> forall i :: 0 <= i < index ==> !IsOdd(a[i])\n    {\n        if IsOdd(a[index])\n        {\n            found := true;\n            return;\n        }\n        index := index + 1;\n    }\n}",
            "success": true
        },
        "min_array_strong.dfy": {
            "state": "method minArray(a: array<int>) returns (r:int)\n  requires a.Length > 0\n  ensures forall i :: 0 <= i < a.Length ==> r <= a[i]\n  ensures exists i :: 0 <= i < a.Length && r == a[i]\n{\n  r:=a[0];\n  var i:=1;\n  while i<a.Length\ninvariant r==a[0]\ninvariant exists j::0<=j<i&&r==a[j]\n  {\n    if r>a[i]{\n      r:=a[i];\n    }\n    i:=i+1;\n  }\n}",
            "success": false
        },
        "task_id_594.dfy": {
            "state": "predicate IsEven(n: int)\n{\n    n % 2 == 0\n}\npredicate IsOdd(n: int)\n{\n    n % 2 != 0\n}\nmethod FirstEvenOddDifference(a: array<int>) returns (diff: int)\n    requires a.Length >= 2\n    requires exists i :: 0 <= i < a.Length && IsEven(a[i])\n    requires exists i :: 0 <= i < a.Length && IsOdd(a[i])\n    ensures exists i, j :: 0 <= i < a.Length && 0 <= j < a.Length && IsEven(a[i]) && IsOdd(a[j]) && diff == a[i] - a[j] && \n        (forall k :: 0 <= k < i ==> IsOdd(a[k])) && (forall k :: 0 <= k < j ==> IsEven(a[k]))\n{\n    var firstEven: int := -1;\n    var firstOdd: int := -1;\n    for i := 0 to a.Length\ninvariant forall k :: 0 <= k < firstEven ==> IsOdd(a[k])\n    {\n        if firstEven == -1 && IsEven(a[i])\n        {\n            firstEven := i;\n        }\n        if firstOdd == -1 && IsOdd(a[i])\n        {\n            firstOdd := i;\n        }\n        if firstEven != -1 && firstOdd != -1\n        {\n            break;\n        }\n    }\n    diff := a[firstEven] - a[firstOdd];\n}",
            "success": false
        },
        "dafny-duck_tmp_tmplawbgxjo_p1.dfy": {
            "state": "// Given an array of integers, it returns the sum. [1,3,3,2]->9\nfunction Sum(xs: seq<int>): int {\n    if |xs| == 0 then 0 else Sum(xs[..|xs|-1]) + xs[|xs|-1]\n}\nmethod SumArray(xs: array<int>) returns (s: int)\n    ensures s == Sum(xs[..])\n{\n    s := 0;\n    var i := 0;\n    while i < xs.Length\ndecreases xs.Length - i\ndecreases xs.Length - i\ninvariant 0 <= i <= xs.Length\ninvariant s == Sum(xs[..i])\n    {\n        s := s + xs[i];\n        i := i + 1;\n    }\n}",
            "success": false
        },
        "laboratory_tmp_tmps8ws6mu2_dafny-tutorial_exercise11.dfy": {
            "state": "method m()\n{\n    var i, n := 0, 20;\n    while i != n\ninvariant i <= n\n    {\n        i := i + 1;\n    }\n}",
            "success": true
        },
        "task_id_554.dfy": {
            "state": "/**\n * Find odd numbers from an array of numbers\n **/\npredicate IsOdd(n: int)\n{\n    n % 2 == 1\n}\nmethod FindOddNumbers(arr: array<int>) returns (oddList: seq<int>)\n    // All numbers in the output are odd and exist in the input \n    ensures forall i :: 0 <= i < |oddList| ==> IsOdd(oddList[i]) && oddList[i] in arr[..]\n    // All odd numbers in the input are in the output\n    ensures forall i :: 0 <= i < arr.Length && IsOdd(arr[i]) ==> arr[i] in oddList\n{\n    oddList := [];\n    for i := 0 to arr.Length\ninvariant forall k :: 0 <= k < |oddList| ==> IsOdd(oddList[k]) && oddList[k] in arr[..]\ninvariant forall k :: 0 <= k < i && IsOdd(arr[k]) ==> arr[k] in oddList\n    {\n        if IsOdd(arr[i])\n        {\n            oddList := oddList + [arr[i]];\n        }\n    }\n}",
            "success": true
        },
        "Dafny-experiences_tmp_tmp150sm9qy_dafny_started_tutorial_dafny_tutorial_array.dfy": {
            "state": "method FindMax(a: array<int>) returns (i: int)\n  // Annotate this method with pre- and postconditions\n  // that ensure it behaves as described.\n  requires a.Length > 0\n  ensures 0<= i < a.Length\n  ensures forall k :: 0 <= k < a.Length ==> a[k] <= a[i]\n{\n  // Fill in the body that calculates the INDEX of the maximum.\n  i := 0;\nassert a[i] == a[0];\n  var index := 1;\n  while index < a.Length\ninvariant index <= a.Length\ninvariant 0 <= i < index\ninvariant forall k :: 0 <= k < index ==> a[k] <= a[i]\n  {\n    if a[index] > a[i] {i:= index;}\n    index := index + 1;\n  }\n}",
            "success": true
        },
        "Workshop_tmp_tmp0cu11bdq_Workshop_Answers_Question5.dfy": {
            "state": "method rev(a : array<int>)\n    requires a != null;\n    modifies a;\n    ensures forall k :: 0 <= k < a.Length ==> a[k] == old(a[(a.Length - 1) - k]);\n{\n    var i := 0;\n    while (i < a.Length - 1 - i)\ninvariant a[..i] == old(a[a.Length - 1 - i..a.Length - 1]);\ninvariant forall k :: 0 <= k < i ==> a[k] == old(a[a.Length - 1 - k]);\ninvariant 0 <= i <= a.Length / 2;\ninvariant forall k :: a.Length / 2 - i <= k < a.Length / 2 + i ==> a[k] == old(a[a.Length - 1 - k]);\n    {\n        a[i], a[a.Length - 1 - i] := a[a.Length - 1 - i], a[i];\n        i := i + 1;\n    }\n}",
            "success": false
        },
        "Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_50_examples_28.dfy": {
            "state": "method main(x: int, y: int) returns (x_out: int, y_out: int, n: int)\nrequires x >= 0\nrequires y >= 0\nrequires x == y\nensures y_out == n\n{\nassert x_out == n;\n    x_out := x;\n    y_out := y;\n    n := 0;\n    while (x_out != n)\ninvariant x_out <= n\ninvariant 0 <= n <= y\n    {\n        x_out := x_out - 1;\n        y_out := y_out - 1;\n    }\n}",
            "success": false
        },
        "dafny_tmp_tmp2ewu6s7x_ListReverse.dfy": {
            "state": "function reverse(xs: seq<nat>): seq<nat>\n{\n    if xs == [] then [] else reverse(xs[1..]) + [xs[0]]\n}\nlemma ReverseAppendDistr(xs: seq<nat>, ys: seq<nat>)\nensures reverse(xs + ys) == reverse(ys) + reverse(xs)\n{\n    if {\n        case xs == [] =>\n        calc {\nreverse(xs) + reverse(xs[1..]);\n==\n            reverse([] + ys);\n            calc {\n                [] + ys;\n                ys;\n            }\n            reverse(ys);\n            reverse(ys) + reverse([]);\n        }\n        case xs != [] => {\n            var zs := xs + ys;\nassert zs[1..] == xs[1..] + ys;\n        }\n    }\n}\nlemma ReverseInvolution(xxs: seq<nat>)\ndecreases xxs\nensures reverse(reverse(xxs)) == xxs\n{\n    if {\n        case xxs == [] => {}\n        case xxs != [] => calc {\n            reverse(reverse(xxs));\n            ==\n            reverse(reverse(xxs[1..]) + [xxs[0]]);\n            ==\n            { ReverseAppendDistr(reverse(xxs[1..]), [xxs[0]]); }\n            reverse([xxs[0]]) + reverse(reverse(xxs[1..]));\n            ==\n            { ReverseInvolution(xxs[1..]); }\n            calc {\n                reverse([xxs[0]]);\n                ==\n                [] + [xxs[0]];\n                ==\n                [xxs[0]];\n            }\n            [xxs[0]] + xxs[1..];\n            ==\n            xxs;\n        }\n    }\n}",
            "success": false
        },
        "task_id_732.dfy": {
            "state": "predicate IsSpaceCommaDot(c: char)\n{\n    c == ' ' || c == ',' || c == '.'\n}\nmethod ReplaceWithColon(s: string) returns (v: string)\n    ensures |v| == |s|\n    ensures forall i :: 0 <= i < |s| ==> (IsSpaceCommaDot(s[i]) ==> v[i] == ':') && (!IsSpaceCommaDot(s[i]) ==> v[i] == s[i])\n{\n    var s' : string := [];\n    for i := 0 to |s|\ninvariant |s'| == i\ninvariant forall k :: 0 <= k < i ==> (IsSpaceCommaDot(s[k]) ==> s'[k] == ':') && (!IsSpaceCommaDot(s[k]) ==> s'[k] == s[k])\n    {\n        if IsSpaceCommaDot(s[i])\n        {\n            s' := s' + [':'];\n        }\n        else \n        {\n            s' := s' + [s[i]];\n        }\n    }\n    return s';\n}",
            "success": true
        },
        "task_id_445.dfy": {
            "state": "method MultiplyElements(a: seq<int>, b: seq<int>) returns (result: seq<int>)\n    requires |a| == |b|\n    ensures |result| == |a|\n    ensures forall i :: 0 <= i < |result| ==> result[i] == a[i] * b[i]\n{\n    result := [];\n    var i := 0;\n    while i < |a|\ninvariant 0 <= i <= |a|\ninvariant |result| == i\ninvariant forall k :: 0 <= k < i ==> result[k] == a[k] * b[k]\n    {\n        result := result + [a[i] * b[i]];\n        i := i + 1;\n    }\n}",
            "success": true
        },
        "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_pregel algorithms_skeleton_nondet-permutation.dfy": {
            "state": "\ufeffmodule Permutation\n{\n\t/**\n\t * Given n >= 0, generate a permuation of {0,...,n-1} nondeterministically.\n\t */\n\tmethod Generate(n: int) returns (perm: array<int>)\n\t\trequires n >= 0\n\t\tensures perm != null\n\t\tensures perm.Length == n\n\t\tensures fresh(perm)\n\t\tensures isValid(perm, n)\n\t{\nassert isValid(perm, n);\n\t\tvar all := set x | 0 <= x < n;\n\t\tvar used := {};\n\t\tperm := new int[n];\n\t\tCardinalityLemma(n, all);\n\t\twhile used < all\n\t\t{\n\t\t\tCardinalityOrderingLemma(used, all);\n\t\t\tvar dst :| dst in all && dst !in used;\n\t\t\tperm[|used|] := dst;\n\t\t\tused := used + {dst};\n\t\t}\n\t\tprint perm;\n\t}\n\tpredicate isValid(a: array<int>, n: nat)\n\t\trequires a != null && a.Length == n\n\t\treads a\n\t{\n\t\tassume forall i | 0 <= i < n :: i in a[..];\n\t\tdistinct(a)\n\t\t&& (forall i | 0 <= i < a.Length :: 0 <= a[i] < n)\n\t\t&& (forall i | 0 <= i < n :: i in a[..])\n\t}\n\tpredicate distinct(a: array<int>)\n\t\trequires a != null\n\t\treads a\n\t{\n\t\tdistinct'(a, a.Length)\n\t}\n\tpredicate distinct'(a: array<int>, n: int)\n\t\trequires a != null\n\t\trequires a.Length >= n\n\t\treads a\n\t{\n\t\tforall i,j | 0 <= i < n && 0 <= j < n && i != j :: a[i] != a[j]\n\t}\n\tlemma CardinalityLemma (size: int, s: set<int>)\n\t\trequires size >= 0\n\t\trequires s == set x | 0 <= x < size\n\t\tensures\tsize == |s|\n\t{\nassert |s| == size;\n\t\tif(size == 0) {\n\t\t} else {\n\t\t\tCardinalityLemma(size - 1, s - {size - 1});\n\t\t}\n\t}\n\tlemma CardinalityOrderingLemma<T> (s1: set<T>, s2: set<T>)\n\t\trequires s1 < s2\n\t\tensures |s1| < |s2|\n\t{\n\t\tvar e :| e in s2 - s1;\n\t\tif s1 != s2 - {e} {\n\t\t\tCardinalityOrderingLemma(s1, s2 - {e});\n\t\t}\n\t}\n\tlemma SetDiffLemma<T> (s1: set<T>, s2: set<T>)\n\t\trequires s1 < s2\n\t\tensures s2 - s1 != {}\n\t{\n\t\tvar e :| e in s2 - s1;\n\t\tif s2 - s1 != {e} {} // What does Dafny prove here???\n\t}\n}",
            "success": false
        },
        "cs245-verification_tmp_tmp0h_nxhqp_quicksort-partition.dfy": {
            "state": "// Quicksort Partition -- Stephanie McIntyre\n// Based on examples in class \n// Parts have been modified cause you know, arrays are different...\nmethod QuicksortPartition(X: array<int>, n: int, p: int) returns (a: int, b: int)\nmodifies X;\n/*Pre-Condition*/   requires X.Length>=1 && n == X.Length;\n/*Post-Condition*/  ensures b>=n;\n                    ensures forall x:: 0<=x<a<n ==> X[x] <= p;\n                    ensures forall x:: a==n || (0<=a<=x<n ==> X[x] > p);\n                    ensures multiset(X[..])==multiset(old(X[..]))           //This says the new X is a permutation of our old version of X.\n{\n  a := 0;\n  while ( a < n && X[a] <= p ) \ninvariant 0<=a<=n;  //We will want this later\ninvariant forall x:: 0<=x<a  ==> X[x] <= p;\ninvariant multiset(X[..])==multiset(old(X[..]))           //This says the new X is a permutation of our old version of X.\ninvariant forall x::a<=x<b<n ==> X[x]>p;\n  { \n    a := a+1;\n  }\n  b := a+1;\n  while ( b<n )\n  { \n    if ( X[b] <= p ) {\n      var t := X[b]; \n      X[b] := X[a]; \n      X[a] := t; \n      a := a+1;\n    }\n    b := b+1;\n  }\n}\n/* The annotations and implied proofs are left for you.\n   I might do them later on next week. */",
            "success": false
        },
        "ironsync-osdi2023_tmp_tmpx80antoe_linear-dafny_docs_DafnyRef_examples_Example-Old2.dfy": {
            "state": "class A {\n  var value: int\n  constructor ()\n     ensures value == 10\n  {\n     value := 10;\n  }\n}\nclass B {\n   var a: A\n   constructor () { a := new A(); }\n   method m()\n     requires a.value == 11\n     modifies this, this.a\n   {\n     label L:\n     a.value := 12;\n     label M:\n     a := new A(); // Line X\n     label N:\n     a.value := 20;\n     label P:\nassert a.value == 20; // Line Q\n                                // but .value in current state\n                                  // reference at Line X\n  }\n}",
            "success": true
        },
        "set_to_seq_strong.dfy": {
            "state": "method SetToSeq<T>(s: set<T>) returns (xs: seq<T>)\n  ensures multiset(s) == multiset(xs)\n{\n  xs := [];\n  var left: set<T> := s;\n  while left != {}\ninvariant multiset(left) + multiset(xs) == multiset(s)\n  {\n    var x :| x in left;\n    left := left - {x};\n    xs := xs + [x];\n  }\n}",
            "success": true
        },
        "task_id_106.dfy": {
            "state": "method AppendArrayToSeq(s: seq<int>, a: array<int>) returns (r: seq<int>)\n    requires a != null\n    ensures |r| == |s| + a.Length\n    ensures forall i :: 0 <= i < |s| ==> r[i] == s[i]\n    ensures forall i :: 0 <= i < a.Length ==> r[|s| + i] == a[i]\n{\n    r := s;\n    for i := 0 to a.Length\ninvariant |r| == |s| + i\ninvariant forall j :: 0 <= j < |s| ==> r[j] == s[j]\ninvariant forall j :: 0 <= j < i ==> r[|s| + j] == a[j]\n    {\n        r := r + [a[i]];\n    }\n}",
            "success": true
        },
        "task_id_474.dfy": {
            "state": "method ReplaceChars(s: string, oldChar: char, newChar: char) returns (v: string)\n    ensures |v| == |s|\n    ensures forall i :: 0 <= i < |s| ==> (s[i] == oldChar ==> v[i] == newChar) && (s[i] != oldChar ==> v[i] == s[i])\n{\n    var s' : string := [];\n    for i := 0 to |s|\ninvariant |s'| == i\ninvariant forall j :: 0 <= j < i ==> (s[j] == oldChar ==> s'[j] == newChar) && (s[j] != oldChar ==> s'[j] == s[j])\n    {\n        if s[i] == oldChar\n        {\n            s' := s' + [newChar];\n        }\n        else \n        {\n            s' := s' + [s[i]];\n        }\n    }\n    return s';\n}",
            "success": true
        },
        "dafny_examples_tmp_tmp8qotd4ez_lib_math_DivMod.dfy": {
            "state": "module DivMod {\n  function {:opaque} DivSub(a: int, b: int): int\n    requires 0 <= a && 0 < b\n  {\n    if a < b then 0 else 1 + DivSub(a - b, b)\n  }\n  function {:opaque} ModSub(a: int, b: int): int\n    requires 0 <= a && 0 < b\n  {\n    if a < b then a else ModSub(a - b, b)\n  }\n  lemma DivModAdd1(a: int, b: int)\n    requires b != 0\n    ensures (a + b) % b == a % b\n    ensures (a + b) / b == a / b + 1\nlemma DivModAdd(a: int, b: int, c: int)\n  {\nassert c < 2 * b;\nassert c * b / b == c;\n    var c := (a + b) / b - (a / b) - 1;\n  }\n  lemma DivModSub1(a: int, b: int)\n    requires b != 0\n    ensures (a - b) % b == a % b\n    ensures (a - b) / b == a / b - 1\n  {\n    var c := (a - b) / b - (a / b) + 1;\n  }\n  lemma ModEq(a: int, b: int)\n    requires 0 <= a && 0 < b\n    ensures a % b == ModSub(a, b)\n  {\n    reveal ModSub();\n    if a >= b {\n      DivModSub1(a, b);\n    }\n  }\n  lemma DivEq(a: int, b: int)\n    requires 0 <= a && 0 < b\n    ensures a / b == DivSub(a, b)\n  {\n    reveal DivSub();\n    if a >= b {\n      DivModSub1(a, b);\n    }\n  }\n  lemma DivModSpec'(a: int, b: int, q: int, r: int)\n    requires 0 <= a && 0 < b\n    requires 0 <= q && 0 <= r < b\n    requires a == q * b + r\n    ensures ModSub(a, b) == r\n    ensures DivSub(a, b) == q\n  {\n    reveal ModSub();\n    reveal DivSub();\n    if q > 0 {\n      DivModSpec'(a - b, b, q - 1, r);\n    }\n  }\n  lemma DivModSpec(a: int, b: int, q: int, r: int)\n    requires 0 <= a && 0 < b\n    requires 0 <= q && 0 <= r < b\n    requires a == q * b + r\n    ensures a % b == r\n    ensures a / b == q\n  {\n    ModEq(a, b);\n    DivEq(a, b);\n    DivModSpec'(a, b, q, r);\n  }\n  lemma DivMul(a: int, b: int)\n    requires 0 <= a && 0 < b\n    ensures a * b / b == a\n  {\n    DivModSpec(a * b, b, a, 0);\n  }\n  lemma DivModMulAdd(a: int, b: int, c: int)\n    requires 0 <= a && 0 <= c < b && 0 < b\n    ensures (a * b + c) / b == a\n    ensures (a * b + c) % b == c\n  {\n    DivModSpec(a * b + c, b, a, c);\n  }\n}",
            "success": false
        },
        "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic examples_sumto_sol.dfy": {
            "state": "function sum_up_to (n: nat): nat\n{\n  if (n == 0) then 0\n  else sum_up_to (n-1) + 1\n}\nmethod SumUpTo (n: nat) returns (r: nat)\n  ensures r == sum_up_to (n);\n{\n  var i := 0;\n  r := 0;\n  while (i < n)\n    invariant 0 <= i <= n;\n    invariant r == sum_up_to (i);\n  {\n    r := r + 1;\n    i := i + 1;\n  }\n}\nfunction total (a: seq<nat>) : nat\n{\n  if |a| == 0 then 0\n  else total (a[0..|a|-1]) + a[|a|-1]\n}\nlemma total_lemma (a: seq<nat>, i:nat) \n  requires |a| > 0;\n  requires 0 <= i < |a|;\n  ensures total (a[0..i]) + a[i] == total (a[0..i+1]);\n{\n  ghost var b := a[0..i+1];\n  calc\n  {\n    total (a[0..i+1]);\n    total (b);\n    total (b[0..|b|-1]) + b[|b|-1];\n    total (b[0..|b|-1]) + a[i];\n    {assert (b[0..|b|-1] == a[0..i]);}\n    total (a[0..i]) + a[i];\n  }\n}\nmethod Total (a: seq<nat>) returns (r:nat)\n  ensures r == total (a[0..|a|]); \n{\n  var i := 0;\n  r := 0;\n  while i < |a|\ninvariant 0 <= i <= |a|;\ninvariant r == total (a[0..i]);\n  { \n    total_lemma (a, i);\n    r := r + a[i];\n    i := i + 1;\n  }\n}",
            "success": true
        },
        "array_sum_strong.dfy": {
            "state": "method arraySum(a: array<int>, b: array<int>) returns (c: array<int> )\n  requires a.Length==b.Length\n  ensures c.Length==a.Length\n  ensures forall i:: 0 <= i< a.Length==> a[i] + b[i]==c[i]\n{\n  c:= new int[a.Length];\n  var i:=0;\n  while i<a.Length\ndecreases c.Length-i\n  {\n    c[i]:=a[i]+b[i];\n    i:=i+1;\n  }\n}",
            "success": false
        },
        "task_id_282.dfy": {
            "state": "method ElementWiseSubtraction(a: array<int>, b: array<int>) returns (result: array<int>)\n    requires a != null && b != null\n    requires a.Length == b.Length\n    ensures result != null\n    ensures result.Length == a.Length\n    ensures forall i :: 0 <= i < result.Length ==> result[i] == a[i] - b[i]\n{\n    result := new int[a.Length];\n    var i := 0;\n    while i < a.Length\n    {\n        result[i] := a[i] - b[i];\n        i := i + 1;\n    }\n}",
            "success": false
        },
        "task_id_2.dfy": {
            "state": "predicate InArray(a: array<int>, x: int)\n    reads a\n{\n    exists i :: 0 <= i < a.Length && a[i] == x\n}\nmethod SharedElements(a: array<int>, b: array<int>) returns (result: seq<int>)\n    // All elements in the output are in both a and b\n    ensures forall x :: x in result ==> (InArray(a, x) && InArray(b, x))\n    // The elements in the output are all different\n    ensures forall i, j :: 0 <= i < j < |result| ==> result[i] != result[j]\n{\n    var res: seq<int> := [];\n    for i := 0 to a.Length\ninvariant forall x :: x in res ==> (InArray(a, x) && InArray(b, x))\ninvariant forall j, k :: 0 <= j < k < |res| ==> res[j] != res[k]\n    {\n        if InArray(b, a[i]) && a[i] !in res\n        {\n            res := res + [a[i]];\n        }\n    }\n    result := res;\n}",
            "success": true
        },
        "task_id_145.dfy": {
            "state": "method MaxDifference(a: array<int>) returns (diff: int)\n    requires a.Length > 1\n    ensures forall i, j :: 0 <= i < a.Length && 0 <= j < a.Length ==> a[i] - a[j] <= diff\n{\n    var minVal := a[0];\n    var maxVal := a[0];\n    for i := 1 to a.Length\ninvariant forall j :: 0 <= j < i ==> minVal <= a[j] && a[j] <= maxVal\n    {\n        if a[i] < minVal {\n            minVal := a[i];\n        } else if a[i] > maxVal {\n            maxVal := a[i];\n        }\n    }\n    diff := maxVal - minVal;\n}",
            "success": true
        },
        "Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseContained.dfy": {
            "state": "predicate strictSorted(s : seq<int>) {\n\tforall u, w :: 0 <= u < w < |s| ==> s[u] < s[w]\n}\nmethod mcontained(v:array<int>,w:array<int>,n:int,m:int) returns (b:bool)\n//Specify and implement an O(m+n) algorithm that returns b\n//v and w are strictly increasing ordered arrays\n//b is true iff the first n elements of v are contained in the first m elements of w\nrequires n<=m && n>=0\nrequires strictSorted(v[..])\nrequires strictSorted(w[..])\nrequires v.Length >= n && w.Length >= m\nensures b==forall k:: 0<= k< n ==> v[k] in w[..m]//exists j :: 0 <= j < m && v[k] == w[j]\n{\n\tvar i:=0;\n\tvar j:=0;\n\twhile(i<n && j<m && (v[i] >= w[j])) //&& b)\ninvariant 0<=i<=n && 0<=j<=m\ninvariant forall k::0<=k<i ==> v[k] in w[..m]//exists j :: 0 <= j < m && v[k] == w[j]\ndecreases w.Length-j\ninvariant i<=j\n\t{\t\n\t\tif(v[i] == w[j]){\n\t\t\ti:=i+1;\n\t\t}\n\t\tj:=j+1;\n\t}\n\tb := i==n;\n}",
            "success": false
        },
        "ironsync-osdi2023_tmp_tmpx80antoe_linear-dafny_docs_DafnyRef_examples_Example-Old.dfy": {
            "state": "class A {\n  var value: int\n  method m(i: int)\n    requires i == 6\n    requires value == 42\n    modifies this\n  {\n    var j: int := 17;\n    value := 43;\n    label L:\n    j := 18;\n    value := 44;\n    label M:\nassert(j + 1 == 19);\n    // value is this.value; 'this' is the same\n    // same reference in current and pre state but the\n    // values stored in the heap as its fields are different;\n    // '.value' evaluates to 42 in the pre-state, 43 at L,\n    // and 44 in the current state\n  }\n}",
            "success": true
        },
        "Dafny_Programs_tmp_tmp99966ew4_binary_search.dfy": {
            "state": "predicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n}\nmethod BinarySearch(a: array<int>, value: int) returns (index: int)\n   requires a != null && 0 <= a.Length && sorted(a)\n   ensures 0 <= index ==> index < a.Length && a[index] == value\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != value\n{\n   var low, high := 0, a.Length;\n   while low < high\n         0 <= i < a.Length && !(low <= i < high) ==> a[i] != value\n   {\n      var mid := (low + high) / 2;\n      if a[mid] < value\n      {\n         low := mid + 1;\n      }\n      else if value < a[mid]\n      {\n         high := mid;\n      }\n      else\n      {\n         return mid;\n      }\n   }\n   return -1;\n}",
            "success": false
        },
        "llm-verified-eval_tmp_tmpd2deqn_i_dafny_161.dfy": {
            "state": "function IsLetter(c: char): bool \n{\n  (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') \n}\nfunction NoLetters(s: string, n: nat): bool \n  requires n <= |s|\n{\n  forall c :: 0 <= c < n ==> !IsLetter(s[c])\n}\nfunction ToggleCase(c: char): char\n{\n  if c >= 'a' && c <= 'z' \n  then \n    (c - 'a' + 'A')\n  else if c >= 'A' && c <= 'Z' \n    then \n      (c - 'A' + 'a')\n    else \n      c\n}\nfunction isReverse(s: string, s_prime: string): bool{\n  (|s| == |s_prime|) &&\n  (forall si :: 0 <= si < |s|/2 ==> s_prime[|s| - si - 1] == s[si])\n}\nmethod Reverse(original: seq<char>) returns (reversed: seq<char>)\n  ensures |reversed| == |original| \n  ensures forall i :: 0 <= i < |original| ==> reversed[i] == original[|original| - 1 - i] \n{\n  reversed := []; \n  var i := |original|;\n  while i > 0\n    decreases i\n    invariant 0 <= i <= |original|\n    invariant  |reversed| == |original| - i\n    invariant forall j :: 0 <= j < |original|-i ==>\n    reversed[j] == original[|original| - 1 - j]\n  {\n    i := i - 1;\n    reversed := reversed + [original[i]]; \n  }\n}\nmethod solve(s: string) returns (result: string)\n  ensures |result| == |s| \n  ensures !NoLetters(s, |s|) ==> forall i :: 0 <= i < |s| && IsLetter(s[i]) ==> result[i] == ToggleCase(s[i])\n  ensures !NoLetters(s, |s|) ==> forall i :: 0 <= i < |s| && !IsLetter(s[i]) ==> result[i] == s[i] \n  ensures NoLetters(s, |s|) ==> isReverse(result, s) \n{\n    var flg : bool := false;\n    result := \"\";\n    for i := 0 to |s|\ninvariant |result| == i\ninvariant !NoLetters(s, i+1) ==> forall j :: 0 <= j < i+1 && !IsLetter(s[j]) ==> result[j] == s[j]\n    {\n      if IsLetter(s[i])\n      {\n        result := result + [ToggleCase(s[i])];\n        flg := true;\n      } else {\n        result := result + [s[i]];\n      }\n    }\n    if !flg\n    {\n      result := Reverse(s);\n    }\n}",
            "success": false
        },
        "Dafny_Verify_tmp_tmphq7j0row_dataset_C_convert_examples_15.dfy": {
            "state": "method main(n: int, k: int) returns (k_out: int)\n    requires n > 0;\n\trequires k > n;\n\tensures k_out >= 0;\n{\n\tk_out := k;\n    var j: int := 0;\n    while(j < n)\ndecreases k + n - j;\ndecreases k + n - j;\ninvariant j <= n || k >= 1\ninvariant 0 <= j <= n\n    {\n        j := j + 1;\n        k_out := k_out - 1;\n    }\n}\n// C code:\n// MODULE main\n// \tint i;\n// \tint n;\n// \tint j;\n// \tint k;\n// \tassume(n > 0);\n// \tassume(k > n);\n// \tassume(j == 0);\n// \twhile(j < n){\n// \t\tj = j + 1;\n// \t\tk = k - 1;\n// \t}\n// \tassert(k >= 0);\t\n// END MODULE\n// Invariant\n// (\n    // not (or (<= 1 (+ n (+ (* (- 1) j) (* (- 1) k)))) (\n    //     and (<= k (- 1)) (<= (+ n (* (- 1) j)) (- 1)))))",
            "success": false
        },
        "Dafny_Verify_tmp_tmphq7j0row_Generated_Code_Mult.dfy_1.dfy": {
            "state": "method mult(a:int, b:int) returns (x:int)\n  \trequires a >= 0 && b >= 0\n  \tensures x == a * b\n{\n  \tx := 0;\n\tvar y := a;\n  \twhile y > 0\ninvariant x == (a - y) * b\ndecreases y\n\t{\n\t\tx := x + b;\n\t\ty := y - 1;\n\t}\n}",
            "success": true
        },
        "Dafny_Verify_tmp_tmphq7j0row_Generated_Code_ComputePower.dfy_3.dfy": {
            "state": "function Power(n: nat): nat {\n    if n == 0 then 1 else 2 * Power(n - 1)\n}\nmethod ComputePower(n: nat) returns (p: nat)\n    ensures p == Power(n)\n{\n    p := 1;\n    var i := 0;\nassert p == Power(i);\n    while i != n\ninvariant i <= n && p == Power(i)\n    {\n        i := i + 1;\n        p := p * 2;\n    }\n}",
            "success": true
        },
        "Dafny_tmp_tmpv_d3qi10_3_cumsum.dfy": {
            "state": "function sum(a: array<int>, i: int): int\n    requires 0 <= i < a.Length\n    reads a\n{\n    a[i] + if i == 0 then 0 else sum(a, i - 1)\n}\nmethod cumsum(a: array<int>, b: array<int>)\n    requires  a.Length == b.Length && a.Length > 0 && a != b\n    // when you change a  , that's not the same object than b . \n    //requires b.Length > 0 \n    ensures forall i | 0 <= i < a.Length :: b[i] == sum(a, i)\n    modifies b\n{\n    b[0] := a[0]; // Initialise le premier \u00e9l\u00e9ment de b\n    var i := 1;\n    while i < a.Length\ninvariant b[i - 1] == sum(a, i - 1) // La somme cumul\u00e9e du pr\u00e9vu est bien calcul\u00e9e.\n    {\n        b[i] := b[i - 1] + a[i]; // Calcule la somme cumul\u00e9e pour chaque \u00e9l\u00e9ment\n        i := i + 1;\n    }\n}",
            "success": false
        },
        "task_id_412.dfy": {
            "state": "/**\n * Remove odd numbers from an array of numbers\n **/\npredicate IsEven(n: int)\n{\n    n % 2 == 0\n}\nmethod RemoveOddNumbers(arr: array<int>) returns (evenList: seq<int>)\n    // All numbers in the output are even and exist in the input \n    ensures forall i :: 0 <= i < |evenList| ==> IsEven(evenList[i]) && evenList[i] in arr[..]\n    // All even numbers in the input are in the output\n    ensures forall i :: 0 <= i < arr.Length && IsEven(arr[i]) ==> arr[i] in evenList\n{\n    evenList := [];\n    for i := 0 to arr.Length\ninvariant forall k :: 0 <= k < |evenList| ==> IsEven(evenList[k]) && evenList[k] in arr[..]\ninvariant forall k :: 0 <= k < i && IsEven(arr[k]) ==> arr[k] in evenList\n    {\n        if IsEven(arr[i])\n        {\n            evenList := evenList + [arr[i]];\n        }\n    }\n}",
            "success": true
        },
        "task_id_603.dfy": {
            "state": "method LucidNumbers(n: int) returns (lucid: seq<int>)\n    requires n >= 0\n    ensures forall i :: 0 <= i < |lucid| ==> lucid[i] % 3 == 0\n    ensures forall i :: 0 <= i < |lucid| ==> lucid[i] <= n\n    ensures forall i, j :: 0 <= i < j < |lucid| ==> lucid[i] < lucid[j]\n{\n    lucid := [];\n    var i := 0;\n    while i <= n\ninvariant 0 <= i <= n + 1\ninvariant forall k :: 0 <= k < |lucid| ==> lucid[k] % 3 == 0\ninvariant forall i, j :: 0 <= i < j < |lucid| ==> lucid[i] < lucid[j]\n    {\n        if i % 3 == 0 {\n            lucid := lucid + [i];\n        }\n        i := i + 1;\n    }\n}",
            "success": false
        },
        "sat_dfy_tmp_tmpfcyj8am9_dfy_Seq.dfy": {
            "state": "module Seq {\n    function seq_sum(s: seq<int>) : (sum: int)\n    {\n        if s == [] then\n            0\n        else\n            var x := s[0];\n            var remaining := s[1..];\n            x + seq_sum(remaining)\n    }\n    lemma SeqPartsSameSum(s: seq<int>, s1: seq<int>, s2: seq<int>)\n        requires s == s1 + s2\n        ensures seq_sum(s) == seq_sum(s1) + seq_sum(s2)\n    {\n        if s == [] {\nassert |s1| == |s2|;\n        } else if s1 == [] {\n        } else {\n            var x := s1[0];\n            var s1' := s1[1..];\n            SeqPartsSameSum(s[1..], s1[1..], s2);\n        }\n    }\n    lemma DifferentPermutationSameSum(s1: seq<int>, s2: seq<int>)\n        requires multiset(s1) == multiset(s2)\n        ensures seq_sum(s1) == seq_sum(s2)\n    {\n        if s1 == [] {\n        } else {\n            var x :| x in s1;\n            var i1, i2 :| 0 <= i1 < |s1| && 0 <= i2 < |s2| && s1[i1] == s2[i2] && s1[i1] == x;\nassert s1[..i1] == s1[..i1+1][1..];\nassert s1[..i1+1] == s1[..i1] + s1[i1..i1+1];\nassert s1[..i1] == s1[..i1+1][1..];\n            var remaining1 := s1[..i1] + s1[i1+1..];\n            SeqPartsSameSum(s1[..i1+1], s1[..i1], [x]);\n            SeqPartsSameSum(s1, s1[..i1+1], s1[i1+1..]);\n            SeqPartsSameSum(remaining1, s1[..i1], s1[i1+1..]);\n            var remaining2 := s2[..i2] + s2[i2+1..];\n            SeqPartsSameSum(s2[..i2+1], s2[..i2], [x]);\n            SeqPartsSameSum(s2, s2[..i2+1], s2[i2+1..]);\n            SeqPartsSameSum(remaining2, s2[..i2], s2[i2+1..]);\n            DifferentPermutationSameSum(remaining1, remaining2);\n        }\n    }\n}",
            "success": false
        },
        "online_max_strong.dfy": {
            "state": "method onlineMax(a: array<int>, x: int) returns (ghost m:int, p:int)\n  requires 1<=x<a.Length\n  requires a.Length!=0\n  ensures x<=p<a.Length\n  ensures forall i::0<=i<x==> a[i]<=m\n  ensures exists i::0<=i<x && a[i]==m\n  ensures x<=p<a.Length-1 ==> (forall i::0<=i<p ==> a[i]<a[p])\n  ensures (forall i::x<=i<a.Length && a[i]<=m) ==> p==a.Length-1\n{\n  p:= 0;\n  var best := a[0];\n  var i:=1;\n  while i<x\ninvariant forall j::x<=j<p ==> a[j]<best\ninvariant x<=i<=a.Length\ninvariant forall j::0<=j<i ==> a[j]<=best\ninvariant (forall j::x<=j<p ==> a[j]<best)\n  {\n    if a[i]>best{\n      best:=a[i];\n    }\n    i:=i+1;\n  }\n  m:=best;\n  i:=x;\n  while i<a.Length\n  {\n    if a[i]>best{\n      p:=i;\n      return;\n    }\n    i:=i+1;\n  }\n  p:=a.Length-1;\n}",
            "success": false
        },
        "cs245-verification_tmp_tmp0h_nxhqp_SortingIssues_FirstAttempt.dfy": {
            "state": "// Sorting: \n//        Pre/Post Condition Issues - An investigation \n//                                      -- Stephanie McIntyre\n// Based on examples in class \n// First Attempt at specifying requirements for sorting array A in incrementing order\n// We want our Hoare triple of (|Pre-Condition|) Code (|Post-Condition|) to hold iff A is properly sorted.\nmethod sort(A: array<int>, n: int)\nmodifies A; requires n==A.Length;\n/* Pre-Condition */   requires n>=0;            \n/* Post-Condition */  ensures forall i,j:: 0<=i<=j<n ==> A[i]<=A[j];  //This states that A is sorted.\n//Can we write code that does not sort A that still satisfies the requirements? \n//Consider the following program:\n{\nassert forall i,j::0<=i<=j<n ==> A[i]<=A[j];\n  var k := 0;\n  while(k<n)\ninvariant forall i,j::0<=i<=j<=k<n ==> A[i]<=A[j];\ndecreases n-k;\n  {\n    A[k] := k;\n    k := k+1;\n  }\n}",
            "success": false
        },
        "Dafny_Verify_tmp_tmphq7j0row_AI_agent_verify_examples_ComputePower.dfy": {
            "state": "function Power(n: nat): nat {\n    if n == 0 then 1 else 2 * Power(n - 1)\n}\nmethod ComputePower(N: int) returns (y: nat) requires N >= 0\n    ensures y == Power(N)\n{\n    y := 1;\n    var x := 0; \nassert x <= N;\n    while x != N\ndecreases N - x\ndecreases N - x\n    {\n        x, y := x + 1, y + y;\n    } \n}",
            "success": false
        },
        "dafny-language-server_tmp_tmpkir0kenl_Test_hofs_Requires.dfy": {
            "state": "// RUN: %dafny /compile:3 /print:\"%t.print\" /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\nmethod Main()\n{\n  test0(10);\n\ttest5(11);\n\ttest6(12);\n\ttest1();\n\ttest2();\n}\npredicate valid(x:int)\n{\n  x > 0\n}\nfunction ref1(y:int) : int\n  requires valid(y);\n{\n  y - 1\n}\nlemma assumption1()\n  ensures forall a, b :: valid(a) && valid(b) && ref1(a) == ref1(b) ==> a == b;\n{\n}\nmethod test0(a: int)\n{\n  if ref1.requires(a) {\n    // the precondition should suffice to let us call the method\n    ghost var b := ref1(a);\n  }\n}\nmethod test5(a: int)\n{\n  if valid(a) {\n    // valid(a) is the precondition of ref1\n    assert ref1.requires(a);\n  }\n}\nmethod test6(a: int)\n{\n  if ref1.requires(a) {\n    // the precondition of ref1 is valid(a)\n    assert valid(a);\n  }\n}\nmethod test1()\n{\n  if * {\n    assert forall a, b :: valid(a) && valid(b) && ref1(a) == ref1(b) ==> a == b;\n  } else {\n    assert forall a, b :: ref1.requires(a) && ref1.requires(b) && ref1(a) == ref1(b)\n                          ==> a == b;\n  }\n}\nfunction {:opaque} ref2(y:int) : int        // Now with an opaque attribute\n  requires valid(y);\n{\n  y - 1\n}\nlemma assumption2()\n  ensures forall a, b :: valid(a) && valid(b) && ref2(a) == ref2(b) ==> a == b;\n{\n  reveal ref2();\n}\nmethod test2()\n{\n  assumption2();\n  if * {\n  } else {\nassert forall a, b :: ref2.requires(a) && ref2.requires(b) && ref2(a) == ref2(b)\n                          ==> a == b;\n  }\n}",
            "success": true
        },
        "Dafny-Exercises_tmp_tmpjm75muf__Session6Exercises_ExerciseCountMin.dfy": {
            "state": "function min(v:array<int>,i:int):int\ndecreases i\n reads v\n requires 1<=i<=v.Length\n ensures forall k::0<=k<i==> v[k]>=min(v,i)\n {if (i==1) then v[0]\n  else if (v[i-1]<=min(v,i-1)) then v[i-1]\n  else min(v,i-1)\n  }\nfunction countMin(v:array<int>,x:int, i:int):int\ndecreases i\n reads v\n  requires 0<=i<=v.Length\n  ensures !(x in v[0..i]) ==> countMin(v,x,i)==0\n  {\n   if (i==0) then 0\n   else if (v[i-1]==x) then 1+countMin(v,x,i-1)\n   else countMin(v,x,i-1)\n  }\n method mCountMin(v:array<int>) returns (c:int)\nrequires v.Length>0\nensures c==countMin(v,min(v,v.Length),v.Length)\n//Implement and verify an O(v.Length) algorithm \n{\n  var i:=1;\n  c:=1;\n  var mini:=v[0];\n  while(i<v.Length)\ninvariant 1 <= i <= v.Length && 1 <= c <= i\ninvariant mini==min(v,i) && c == countMin(v,mini,i)\n  {\n    if(v[i]==mini){\n      c:=c + 1;\n    }\n    else if(v[i]<mini){\n      c:=1;\n      mini:=v[i];\n    }\n    i:=i+1;\n  }\n}",
            "success": true
        },
        "Prog-Fun-Solutions_tmp_tmp7_gmnz5f_mockExam2_p5.dfy": {
            "state": "// problem 5:\n// name:      Gabriele Berardi\n// s-number: s4878728\n// table:     XXXX\nghost function f(n: int): int {\n  if n < 0 then 0 else 3*f(n-5) + n\n}\nmethod problem5(n:nat) returns (x: int)\nensures x == f(n)\n{\n    var a := 1;\n    var b := 0;\n    var k := n;\n    while k >= 0\n    {\n        b := a*k + b;\n        a := 3*a;\n        k := k - 5;\n    }\n    x := b;\n}",
            "success": false
        },
        "task_id_18.dfy": {
            "state": "method RemoveChars(s1: string, s2: string) returns (v: string)\n    ensures |v| <= |s1|\n    ensures forall i :: 0 <= i < |v| ==> (v[i] in s1) && !(v[i] in s2)\n    ensures forall i :: 0 <= i < |s1| ==> (s1[i] in s2) || (s1[i] in v)\n{\n    var v' : string := [];\n    for i := 0 to |s1|\ninvariant 0 <= i <= |s1|\ninvariant |v'| <= i\ninvariant forall i :: 0 <= i < |v'| ==> (v'[i] in s1) && !(v'[i] in s2)\ninvariant forall i :: 0 <= i <= i - 1 + |v'| ==> (s1[i] in s2) || (s1[i] in v')\n    {\n        if !(s1[i] in s2)\n        {\n            v' := v' + [s1[i]];\n        }\n    }\n    return v';\n}",
            "success": false
        },
        "specTesting_tmp_tmpueam35lx_examples_sort_sort.dfy": {
            "state": "method quickSort(intSeq:array<int>)\n    modifies intSeq\n    ensures forall i:nat, j:nat | 0 <= i <= j < intSeq.Length :: intSeq[i] <= intSeq[j]\n    // ensures multiset(intSeq[..]) == multiset(old(intSeq[..]))\nlemma sort(prevSeq:seq<int>) returns (curSeq:seq<int>)\n    ensures (forall i:nat, j:nat | 0 <= i <= j < |curSeq| :: curSeq[i] <= curSeq[j])\n    ensures multiset(prevSeq) == multiset(curSeq)\npredicate post_sort(prevSeq:seq<int>, curSeq:seq<int>)\n{\n    && (forall i:nat, j:nat | 0 <= i <= j < |curSeq| :: curSeq[i] <= curSeq[j])\n    && multiset(prevSeq) == multiset(curSeq)\n}\nlemma multisetAdditivity(m1:multiset<int>, m2:multiset<int>, m3:multiset<int>, m4:multiset<int>)\n    requires m1 == m2 + m3\n    requires m1 == m2 + m4\n    ensures m3 == m4\n    {\n    }\nlemma twoSortedSequencesWithSameElementsAreEqual(s1:seq<int>, s2:seq<int>)\n    requires (forall i:nat, j:nat | 0 <= i <= j < |s1| :: s1[i] <= s1[j])\n    requires (forall i:nat, j:nat | 0 <= i <= j < |s2| :: s2[i] <= s2[j])\n    requires multiset(s1) == multiset(s2)\n    requires |s1| == |s2|\n    ensures s1 == s2\n{\n    if (|s1| != 0) {\n        if s1[|s1|-1] == s2[|s2|-1] {\n            multisetAdditivity(multiset(s1), multiset([s1[|s1|-1]]), multiset(s1[..|s1|-1]), multiset(s2[..|s1|-1]));\n        }\n        twoSortedSequencesWithSameElementsAreEqual(s1[..|s1|-1], s2[..|s2|-1]);\n        } else if s1[|s1|-1] < s2[|s2|-1] {\n        } else {\n        }\n    }\n}\nlemma sort_determinisitc(prevSeq:seq<int>, curSeq:seq<int>, curSeq':seq<int>)\n    requires post_sort(prevSeq, curSeq)\n    requires post_sort(prevSeq, curSeq')\n    ensures curSeq == curSeq'\n{\n    if (|curSeq| != |curSeq'|) {\n    } else {\n        twoSortedSequencesWithSameElementsAreEqual(curSeq, curSeq');\n    }\n}\nlemma sort_determinisitc1(prevSeq:seq<int>, curSeq:seq<int>, curSeq':seq<int>)\n    requires prevSeq == [5,4,3,2,1]\n    requires post_sort(prevSeq, curSeq)\n    requires post_sort(prevSeq, curSeq')\n    ensures curSeq == curSeq'\n{\n}",
            "success": false
        },
        "reverse_strong.dfy": {
            "state": "method reverse(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[a.Length - 1 - i])\n{\n  var i := 0;\n  while i <a.Length / 2\ninvariant 0 <= i <= a.Length/2\ninvariant forall j :: 0 <= j < i ==> a[j] == old(a[a.Length-1-j])\ninvariant forall j :: i <= j < a.Length/2 ==> a[j] == old(a[a.Length-1-j])\ndecreases a.Length - i\n  {\n    a[i], a[a.Length-1-i] := a[a.Length-1-i], a[i];\n    i := i + 1;\n  }\n}",
            "success": false
        },
        "task_id_94.dfy": {
            "state": "method MinSecondValueFirst(s: array<seq<int>>) returns (firstOfMinSecond: int)\n    requires s.Length > 0\n    requires forall i :: 0 <= i < s.Length ==> |s[i]| >= 2\n    ensures exists i :: 0 <= i < s.Length && firstOfMinSecond == s[i][0] && \n        (forall j :: 0 <= j < s.Length ==> s[i][1] <= s[j][1])\n{\n    var minSecondIndex := 0;\n    for i := 1 to s.Length\ninvariant minSecondIndex > 0 ==> s[minSecondIndex][1] <= s[0][1]\n    {\n        if s[i][1] < s[minSecondIndex][1]\n        {\n            minSecondIndex := i;\n        }\n    }\n    firstOfMinSecond := s[minSecondIndex][0];\n}",
            "success": false
        },
        "task_id_113.dfy": {
            "state": "predicate IsDigit(c: char)\n{\n    48 <= c as int <= 57\n}\nmethod IsInteger(s: string) returns (result: bool)\n    ensures result <==> (|s| > 0) && (forall i :: 0 <= i < |s| ==> IsDigit(s[i]))\n{\n    result := true;\n    if |s| == 0 {\n        result := false;\n    } else {\n        for i := 0 to |s|\ninvariant (forall j :: 0 <= j < i ==> IsDigit(s[j]))\n        {\n            if !IsDigit(s[i]) {\n                result := false;\n                break;\n            }\n        }\n    }\n}",
            "success": true
        },
        "Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Exercise4_Find_Max.dfy": {
            "state": "method findMax(a:array<int>) returns (pos:int, maxVal: int)\n  requires a.Length > 0;\n  requires forall i :: 0 <= i < a.Length ==> a[i] >= 0;\n  ensures forall i :: 0 <= i < a.Length ==> a[i] <= maxVal;\n  ensures exists i :: 0 <= i < a.Length &&  a[i] == maxVal;\n  ensures 0 <= pos < a.Length\n  ensures a[pos] == maxVal;\n{\n  pos := 0;\n  maxVal := a[0];\n  var j := 1;\n  while(j < a.Length)\ninvariant 0 <= pos < j;\ninvariant exists i :: 0 <= i < j && a[i] == maxVal\ninvariant forall i :: 0 <= i < j ==> a[i] <= maxVal;\ninvariant 0 <= j <= a.Length\n  {\n    if (a[j] > maxVal) \n    {\n      maxVal := a[j];\n      pos := j;\n    }\n    j := j+1;\n  }\n  return;\n}",
            "success": false
        },
        "task_id_759.dfy": {
            "state": "method IsDecimalWithTwoPrecision(s: string) returns (result: bool)\n    ensures result ==> (exists i :: 0 <= i < |s| && s[i] == '.' && |s| - i - 1 == 2)\n    ensures !result ==> !(exists i :: 0 <= i < |s| && s[i] == '.' && |s| - i - 1 == 2)\n{\n    result := false;\n    for i := 0 to |s|\ninvariant !result ==> !(exists k :: 0 <= k < i && s[k] == '.' && |s| - k - 1 == 2)\ninvariant result ==> (exists k :: 0 <= k < i && s[k] == '.' && |s| - k - 1 == 2)\n    {\n        if s[i] == '.' && |s| - i - 1 == 2 {\n            result := true;\n            break;\n        }\n    }\n}",
            "success": true
        },
        "Dafny_tmp_tmpmvs2dmry_pancakesort_flip.dfy": {
            "state": "// flips (i.e., reverses) array elements in the range [0..num]\nmethod flip (a: array<int>, num: int)\nrequires a.Length > 0;\nrequires 0 <= num < a.Length;\nmodifies a;\nensures forall k :: 0 <= k <= num ==> a[k] == old(a[num-k])\nensures forall k :: num < k < a.Length ==> a[k] == old(a[k])\n// ensures multiset(a[..]) == old(multiset(a[..]))\n{\n  var tmp:int;\n  var i := 0;\n  var j := num;\n  while (i < j)\ndecreases j\ninvariant forall k :: 0 <= k <= i ==> a[k] == old(a[k])\ninvariant forall k :: num < k <= i ==> a[k] == old(a[k])\ninvariant forall k :: i <= k < j ==> a[k] == old(a[k])\n  // invariant 0 <= i < j <= num\n  {\n    tmp := a[i];\n    a[i] := a[j];\n    a[j] := tmp;\n    i := i + 1;\n    j := j - 1;\n  }\n}",
            "success": false
        },
        "is_palindrome_strong.dfy": {
            "state": "method IsPalindrome(x: seq<char>) returns (result: bool)\n  ensures result <==> (forall i :: 0 <= i < |x| ==> x[i] == x[|x| - i - 1])\n{\n  if |x|==0 {\n    return true;\n  }\n  var i := 0;\n  var j := |x| - 1;\n  result := true;\n  while (i < j)\ninvariant 0 <= i <= |x|/2\ninvariant i <= j\ninvariant result <==> (forall s :: 0 <= s < i ==> x[s] == x[|x| - s - 1])\n  {\n    if x[i] != x[j] {\n      result := false;\n      return;\n    }\n    i := i + 1;\n    j := j - 1;\n  }\n}",
            "success": false
        },
        "Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExercisePositive.dfy": {
            "state": "predicate positive(s:seq<int>)\n{forall u::0<=u<|s| ==> s[u]>=0}\nmethod mpositive(v:array<int>) returns (b:bool)\nensures b==positive(v[0..v.Length])\n{\n    var i:=0;\n    //1. assert positive(v[..0])\n    while i<v.Length && v[i]>=0\n        decreases v.Length - i \n        invariant 0<=i<=v.Length\n        invariant positive(v[..i])\n    {\n        //2. assert 0<=i<v.Length && positive(v[..i]);\n        i:=i+1;\n        //2. assert 0<=i<v.Length && positive(v[..i]);\n    }\n    //3. assert i==v.Length ==> positive(v[..]);\n    //3. assert i<v.Length => v[i]<0;\n    b := i==v.Length;\n}\nmethod mpositive3(v:array<int>) returns (b:bool)\nensures b==positive(v[0..v.Length])\n{\n    var i:=0; b:=true;\n    while(i<v.Length && b)\n        decreases v.Length - i \n        invariant 0 <= i <= v.Length\n        invariant b==positive(v[0..i])\n        invariant !b ==> !positive(v[0..v.Length])\n    {\n        b:=v[i]>=0;\n        i:=i+1;\n    }\n}\nmethod mpositive4(v:array<int>) returns (b:bool)\nensures b==positive(v[0..v.Length])\n{\n    var i:=0; b:=true;\n    while(i<v.Length && b)\n        decreases v.Length - i \n        invariant 0 <= i <= v.Length\n        invariant b==positive(v[0..i])\n        invariant !b ==> !positive(v[0..v.Length])\n    {\n        b:=v[i]>=0;\n        i:=i+1;\n    }\n}\nmethod mpositivertl(v:array<int>) returns (b:bool)\nensures b==positive(v[0..v.Length])\n{\nassert positive(v[v.Length..v.Length]);\n    var i:=v.Length-1;\n    while(i>=0 && v[i]>=0)\ninvariant i+1>=0\ndecreases i\ndecreases v.Length -i\n    {\n        i:=i-1;\n    }\n    b:= i==-1;\n}",
            "success": false
        },
        "task_id_579.dfy": {
            "state": "predicate InArray(a: array<int>, x: int)\n    reads a\n{\n    exists i :: 0 <= i < a.Length && a[i] == x\n}\nmethod DissimilarElements(a: array<int>, b: array<int>) returns (result: seq<int>)\n    // All elements in the output are either in a or b, but not in both or neither\n    ensures forall x :: x in result ==> (InArray(a, x) != InArray(b, x))\n    // The elements in the output are all different\n    ensures forall i, j :: 0 <= i < j < |result| ==> result[i] != result[j]\n{\n    var res: seq<int> := [];\n    for i := 0 to a.Length\n    {\n        if !InArray(b, a[i]) && a[i] !in res\n        {\n            res := res + [a[i]];\n        }\n    }\n    ghost var partialSize := |res|;\nassert partialSize == |res|;\n    for i := 0 to b.Length\ninvariant forall k, l :: 0 <= k < l < partialSize ==> res[k] != res[l]\n    {\n        if !InArray(a, b[i]) && b[i] !in res\n        {\n            res := res + [b[i]];\n        }\n    }\n    result := res;\n}",
            "success": false
        },
        "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_vampire project_original_Searching.dfy": {
            "state": "// Assuming Array is Object Blood\n// Blood Array<int>\n// index\nmethod Find(blood: array<int>, key: int) returns (index: int)\nrequires blood != null\nensures 0 <= index ==> index < blood.Length && blood[index] == key\nensures index < 0 ==> forall k :: 0 <= k < blood.Length ==> blood[k] != key\n{\n   index := 0;\n   while index < blood.Length\ndecreases blood.Length - index\n   {\n      if blood[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n}",
            "success": false
        },
        "Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_normal_data_completion_MaxPerdV2.dfy": {
            "state": "function contains(v: int, a: array<int>, n: int): bool\nreads a\n  requires n <= a.Length\n{\n  exists j :: 0 <= j < n && a[j] == v\n}\nfunction upper_bound(v: int, a: array<int>, n: int): bool\nreads a\n  requires n <= a.Length\n{\n  forall j :: 0 <= j < n ==> a[j] <= v\n}\nfunction is_max(m: int, a: array<int>, n: int): bool\nreads a\n  requires n <= a.Length\n{\n  contains(m, a, n) && upper_bound(m, a, n)\n}\nmethod max(a: array<int>, n: int) returns (max: int)\n  requires 0 < n <= a.Length;\n  ensures is_max(max, a, n);\n{\n  var i: int := 1;\n  max := a[0];\n  while i < n\ninvariant 1 <= i <= n\ninvariant is_max(max, a, i)\n  {\n    if a[i] > max {\n      max := a[i];\n    }\n    i := i + 1;\n  }\n}",
            "success": true
        },
        "count_lessthan_strong.dfy": {
            "state": "method CountLessThan(numbers: set<int>, threshold: int) returns (count: int)\n  ensures count == |set i | i in numbers && i < threshold|\n{\n  count := 0;\n  var shrink := numbers;\n  var grow := {};\n  while |shrink | > 0\n  {\n    var i: int :| i in shrink;\n    shrink := shrink - {i};\n    var grow' := grow+{i};\n           (set i | i in grow && i < threshold )+ if i < threshold then {i} else {};\n    grow := grow + {i};\n    if i < threshold {\n      count := count + 1;\n    }\n  }\n}",
            "success": false
        },
        "Metodos_Formais_tmp_tmpql2hwcsh_Invariantes_multiplicador.dfy": {
            "state": "// Exemplo de invariantes\n// Invariante significa que o valor n\u00e3o muda desde a pr\u00e9-condi\u00e7\u00e3o at\u00e9 a p\u00f3s-condi\u00e7\u00e3o\nmethod Mult(x:nat, y:nat) returns (r:nat)\nensures r == x * y\n{\n    // par\u00e2metros de entrada s\u00e3o imut\u00e1veis, por isso\n    // \u00e9 preciso a atribuir a vari\u00e1veis locais para usar em blocos de c\u00f3digos para mudar\n    var m := x;\n    var n := y;\nassert  n == 3;\n    r := 0;\n    while m > 0 \ndecreases m // declara que m deixa de existir\ninvariant m >= 0 //invariante que deve ter nada a ver com a f\u00f3rmula dela\ninvariant r == m * n + r //invariante que requer\n    {\n        r := r + n;\n        m := m -1;\n    }\n    return r;\n}\n// Teste do m\u00e9todo para encontrar a invariante\n// x | y | m | n | r\n// 5 | 3 | 5 | 3 | 0\n// 5 | 3 | 4 | 3 | 3\n// 5 | 3 | 3 | 3 | 6\n// 5 | 3 | 2 | 3 | 9\n// 5 | 3 | 1 | 3 | 12\n// 5 | 3 | 0 | 3 | 15\n// vimos o seguinte:\n// m * n + r = x * y\n// 5 * 3 + 0 (15) = 5 * 3 (15)\n// portanto a f\u00f3rmula m*n+r == x*y \u00e9 uma invariante\n// mas s\u00f3 isso n\u00e3o serve, o m ele \u00e9 maior ou igual a zero quando acaba o while\n// por isso, tamb\u00e9m \u00e9 a invariante que necessita\n// com isso dizemos para o programa as altera\u00e7\u00f5es do m de maior ou igual a zero\n// e mostramos a fun\u00e7\u00e3o encontrada que alterava o valor de m e n das variaveis criadas\n// SE OS ALGORITMOS TIVEREM REPETI\u00c7\u00c3O OU RECURS\u00c3O, DEVEM SER MOSTRADOS QUAIS S\u00c3O AS INVARIANTES\n// OU SEJA, OS VALORES QUE N\u00c3O EST\u00c3O SENDO MUDADOS E COLOCAR A F\u00d3RMULA DELE COMO ACIMA",
            "success": false
        },
        "t1_MF_tmp_tmpi_sqie4j_exemplos_introducao_ex4.dfy": {
            "state": "function Fat(n: nat): nat\n{\n   if n == 0 then 1 else n * Fat(n-1)\n}\nmethod Fatorial(n:nat)  returns (r:nat)\n  ensures r == Fat(n)\n{\n    r := 1;\n    var i := 0;\nassert 0 <= i <= n && 1 <= r <= Fat(n);\n    while i < n\ninvariant i == 0 ==> r == 1\ndecreases n - i\ninvariant 0 <= i <= n && 1 <= r <= Fat(n)\n    {\n        i := i + 1;\n        r := r * i;\n    }\n}",
            "success": false
        },
        "HATRA-2022-Paper_tmp_tmp5texxy8l_copilot_verification_Two Sum_two_sum.dfy": {
            "state": "method twoSum(nums: array<int>, target: int) returns (index1: int, index2: int)\n    requires 2 <= nums.Length\n    requires exists i, j :: (0 <= i < j < nums.Length && nums[i] + nums[j] == target)\n    ensures index1 != index2\n    ensures 0 <= index1 < nums.Length\n    ensures 0 <= index2 < nums.Length\n    ensures nums[index1] + nums[index2] == target\n{\n    var i := 0;\n    while i < nums.Length\n    {\n        var j := i + 1;\n        while j < nums.Length\ninvariant exists k :: 0 <= k < j && nums[k] == nums[j - 1]\ninvariant 0 <= j <= nums.Length\ninvariant nums[i] + nums[j] != target\ninvariant exists k :: i <= k < nums.Length && nums[i] + nums[k] == target\n        {\n            if nums[i] + nums[j] == target\n            {\n                return i, j;\n            } \n            j := j + 1;\n        }\n        i := i + 1;\n    }\n}",
            "success": false
        },
        "task_id_793.dfy": {
            "state": "method LastPosition(arr: array<int>, elem: int) returns (pos: int)\n    requires arr.Length > 0\n    requires forall i, j :: 0 <= i < j < arr.Length ==> arr[i] <= arr[j]\n    ensures pos == -1 || (0 <= pos < arr.Length && arr[pos] == elem && (pos <= arr.Length - 1 || arr[pos + 1] > elem))\n    ensures forall i :: 0 <= i < arr.Length ==> arr[i] == old(arr[i])\n{\n    pos := -1;\n    for i := 0 to arr.Length - 1\ninvariant pos == -1 || (0 <= pos < arr.Length && arr[pos] == elem && (pos <= i || arr[i] > elem))\n    {\n        if arr[i] == elem\n        {\n            pos := i;\n        }\n    }\n}",
            "success": true
        },
        "dafny-language-server_tmp_tmpkir0kenl_Test_vstte2012_Two-Way-Sort.dfy": {
            "state": "// RUN: %dafny /compile:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n// This method is a slight generalization of the\n// code provided in the problem statement since it\n// is generic in the type of the array elements.\nmethod swap<T>(a: array<T>, i: int, j: int)\n  requires 0 <= i < j < a.Length\n  modifies a\n  ensures a[i] == old(a[j])\n  ensures a[j] == old(a[i])\n  ensures forall m :: 0 <= m < a.Length && m != i && m != j ==> a[m] == old(a[m])\n  ensures multiset(a[..]) == old(multiset(a[..]))\n{\n  var t := a[i];\n  a[i] := a[j];\n  a[j] := t;\n}\n// This method is a direct translation of the pseudo\n// code given in the problem statement.\n// The first postcondition expresses that the resulting\n// array is sorted, that is, all occurrences of \"false\"\n// come before all occurrences of \"true\".\n// The second postcondition expresses that the post-state\n// array is a permutation of the pre-state array. To express\n// this, we use Dafny's built-in multisets. The built-in\n// function \"multiset\" takes an array and yields the\n// multiset of the array elements.\n// Note that Dafny guesses a suitable ranking function\n// for the termination proof of the while loop.\n// We use the loop guard from the given pseudo-code.  However,\n// the program also verifies with the stronger guard \"i < j\"\n// (without changing any of the other specifications or\n// annotations).\nmethod two_way_sort(a: array<bool>)\n  modifies a\n  ensures forall m,n :: 0 <= m < n < a.Length ==> (!a[m] || a[n])\n  ensures multiset(a[..]) == old(multiset(a[..]))\n{\n  var i := 0;\n  var j := a.Length - 1;\n  while (i <= j)\ninvariant forall m,n :: 0 <= m < n < j ==> (!a[m] || a[n])\ninvariant forall m :: 0 <= m < i ==> a[m]\ndecreases j - i // termination proof starts here\ninvariant multiset(a[..]) == old(multiset(a[..]))\n  {\n    if (!a[i]) {\n      i := i+1;\n    } else if (a[j]) {\n      j := j-1;\n    } else {\n      swap(a, i, j);\n      i := i+1;\n      j := j-1;\n    }\n  }\n}",
            "success": false
        }
    },
    {
        "Prog-Fun-Solutions_tmp_tmp7_gmnz5f_mockExam2_p6.dfy": {
            "state": "// problem 6:\n// name:      Gabriele Berardi\n// s-number: s4878728\n// table:     XXXXX\nghost function f(n: int): int {\n  if n <= 0 then 1 else n + f(n-1)*f(n-2)\n}\nghost function fSum(n: nat): int {\n // give the body of this function\n  // it should return Sum(i: 0<=i < n: f(i))\n  if n <= 0 then 0 else f(n-1) + fSum(n-1)\n}\nmethod problem6(n:nat) returns (a: int)\nensures a == fSum(n)\n{\n  a := 0;\n  var k := 0;\n  var x := 1;\n  var y := 2;\n  while k < n\ndecreases n - k\ninvariant x == f(k-1)\n  {\n    k := k + 1;\n    a := a + x;\n    x, y := y, k+1 + x*y;    \n  }\n}",
            "success": false
        },
        "dafny-exercise_tmp_tmpouftptir_appendArray.dfy": {
            "state": "method appendArray(a: array<int>, b: array<int>) returns (c: array<int>)\nensures c.Length == a.Length + b.Length\nensures forall i :: 0 <= i < a.Length ==> a[i] == c[i]\nensures forall i :: 0 <= i < b.Length ==> b[i] == c[a.Length + i]\n{\n\tc := new int[a.Length + b.Length];\n\tvar i := 0;\n\twhile i < a.Length\ninvariant 0 <= i <= b.Length\ndecreases b.Length\ninvariant forall i :: a.Length <= i < b.Length + a.Length ==> c[i] == b[i - a.Length]\ninvariant a[..i] == c[..a.Length + i]\n\t{\n\t\tc[i] := a[i];\n\t\ti := i + 1;\n\t}\n\twhile i < b.Length + a.Length\n\t{\n\t\tc[i] := b[i - a.Length];\n\t\ti := i + 1;\n\t}\n}",
            "success": false
        },
        "task_id_573.dfy": {
            "state": "method UniqueProduct (arr: array<int>) returns (product: int)\n   ensures product == SetProduct((set i | 0 <= i < arr.Length :: arr[i]))\n{\n    var p := 1;\n    var seen: set<int> := {};\n    for i := 0 to arr.Length\n        invariant 0 <= i <= arr.Length\n        invariant seen == (set k | 0 <= k < i :: arr[k])\n        invariant p == SetProduct((set k | 0 <= k < i :: arr[k]))\n    {\n        if ! (arr[i] in seen) {\n            seen := seen + { arr[i] };\n            p := p * arr[i];\n            SetProductLemma(seen, arr[i]);\n        }\n    }\n    product := p;\n}\nghost function SetProduct(s : set<int>) : int\n{\n    if s == {} then 1\n    else var x :| x in s; \n         x * SetProduct(s - {x})\n}\n/* \n * This is necessary because, when we add one element, we need to make sure\n * that the product of the new set, as a whole, is the same as the product\n * of the old set times the new element.\n */\nlemma SetProductLemma(s: set <int>, x: int) \n requires x in s\n ensures SetProduct(s - {x}) * x == SetProduct(s)\n{\n   if s != {}\n   {\nassert s == s - {x} + {x};\n      var y :| y in s && y * SetProduct(s - {y}) == SetProduct(s);\n      if y == x {}\n      else {\n         calc {\n            SetProduct(s);\n            y * SetProduct(s - {y});\n            { SetProductLemma(s - {y}, x); }\n            y * x * SetProduct(s - {y} - {x});\n            { assert s - {x} - {y} == s - {y} - {x};}\n            y * x * SetProduct(s - {x} - {y});\n            x * y * SetProduct(s - {x} - {y});\n            { SetProductLemma(s - {x}, y); }\n            x * SetProduct(s - {x});\n         }\n      }\n   }\n}",
            "success": true
        },
        "task_id_769.dfy": {
            "state": "method Difference(a: seq<int>, b: seq<int>) returns (diff: seq<int>)\n    ensures forall x :: x in diff <==> (x in a && x !in b)\n    ensures forall i, j :: 0 <= i < j < |diff| ==> diff[i] != diff[j]\n{\n    diff := [];\n    for i := 0 to |a|\ninvariant forall k :: 0 <= k < i ==> a[k] in b ==> a[k] !in diff\ninvariant 0 <= i <= |a|\ninvariant forall k :: 0 <= k < i ==> a[k] in b ==> a[k] in diff\ninvariant forall k, l :: 0 <= k < l < |diff| ==> diff[k] != diff[l]\ninvariant forall k :: 0 <= k < i ==> a[k] !in b ==> a[k] !in diff\n    {\n        if a[i] !in b && a[i] !in diff\n        {\n            diff := diff + [a[i]];\n        }\n    }\n}",
            "success": false
        },
        "Dafny_Programs_tmp_tmp99966ew4_lemma.dfy": {
            "state": "lemma SkippingLemma(a : array<int>, j : int)\n   requires a != null\n   requires forall i :: 0 <= i < a.Length ==> 0 <= a[i]\n   requires forall i :: 0 < i < a.Length ==> a[i-1]-1 <= a[i]\n   requires 0 <= j < a.Length\n   ensures forall k :: j <= k < j + a[j] && k < a.Length ==> a[k] != 0\n{\n   var i := j;\n   while i < j + a[j] && i < a.Length\n   decreases j + a[j] - i\n      invariant i < a.Length ==> a[j] - (i-j) <= a[i]\n      invariant forall k :: j <= k < i && k < a.Length ==> a[k] != 0\n   {\n      i := i + 1;\n   }\n}\nmethod FindZero(a: array<int>) returns (index: int)\n   requires a != null\n   requires forall i :: 0 <= i < a.Length ==> 0 <= a[i]\n   requires forall i :: 0 < i < a.Length ==> a[i-1]-1 <= a[i]\n   ensures index < 0  ==> forall i :: 0 <= i < a.Length ==> a[i] != 0\n   ensures 0 <= index ==> index < a.Length && a[index] == 0\n{\n   index := 0;\n   while index < a.Length\ninvariant forall i :: 0 <= i < index && i < a.Length ==> a[i] != 0\ninvariant index < a.Length ==> forall k :: 0 <= k < index && k < a.Length ==> a[k] != 0\n   {\n      if a[index] == 0 { return; }\n      SkippingLemma(a, index);\n      index := index + a[index];\n   }\n   index := -1;\n}",
            "success": true
        },
        "Dafny_tmp_tmp0wu8wmfr_Heimaverkefni 3_InsertionSortMultiset.dfy": {
            "state": "// H\u00f6fundur spurningar:  Snorri Agnarsson, snorri@hi.is\n// Permalink spurningar: https://rise4fun.com/Dafny/G4sc3\n// H\u00f6fundur lausnar:     Alexander Gu\u00f0mundsson\n// Permalink lausnar:    https://rise4fun.com/Dafny/nujsu\n// Insertion sort me\u00f0 hj\u00e1lp helmingunarleitar.\nmethod Search( s: seq<int>, x: int ) returns ( k: int )\n    // Ekki m\u00e1 breyta forskilyr\u00f0um e\u00f0a eftirskilyr\u00f0um fallsins\n    requires forall p,q | 0 <= p < q < |s| :: s[p] <= s[q];\n    ensures 0 <= k <= |s|;\n    ensures forall i | 0 <= i < k :: s[i] <= x;\n    ensures forall i | k <= i < |s| :: s[i] >= x;\n    ensures forall z | z in s[..k] :: z <= x;\n    ensures forall z | z in s[k..] :: z >= x;\n    ensures s == s[..k]+s[k..];\n{\n    // Setji\u00f0 vi\u00f0eigandi stofn fallsins h\u00e9r.\n    var p := 0;\n    var q := |s|;\n    if p == q\n    {\n        return p;\n    }\n    while p != q \n        decreases q-p;\n        invariant 0 <= p <= q <= |s|;\n        invariant forall r | 0 <= r < p :: s[r] <= x;\n        invariant forall r | q <= r < |s| :: s[r] >= x;\n    {\n        var m := p + (q-p)/2;\n        if s[m] == x\n        {\n            return m;\n        }\n        if s[m] < x\n        {\n            p := m+1;\n        }\n        else\n        {\n            q := m;\n        }\n    }\n    return p;\n}\nmethod Sort( m: multiset<int> ) returns ( r: seq<int> )\n    ensures multiset(r) == m;\n    ensures forall p,q | 0 <= p < q < |r| :: r[p] <= r[q];\n{\n    // Setji\u00f0 vi\u00f0eigandi frumstillingu \u00e1 r og rest h\u00e9r.\n    // r er skilabreyta en rest er n\u00fd breyta sem \u00fei\u00f0 b\u00fai\u00f0 til.\n    r := [];\n    var rest := m;\n    while rest != multiset{}\ninvariant forall p,q | 0 <= p < q < |r| :: r[p] <= r[q];\ninvariant forall p,q | 0 <= p < q < |r| :: r[p] <= r[q];\ndecreases rest;\n        // Ekki breyta fastayr\u00f0ingu lykkju\n    {\n        // Setji\u00f0 vi\u00f0eigandi stofn lykkjunnar h\u00e9r.\n        // Fjarl\u00e6gi\u00f0 eitt gildi \u00far rest me\u00f0\n        //    var x :| x in rest;\n        //    rest := rest-multiset{x};\n        // og noti\u00f0 Search til a\u00f0 finna r\u00e9ttan sta\u00f0\n        // \u00ed r til a\u00f0 stinga [x] inn \u00ed r.\n        var x :| x in rest;\n        rest := rest - multiset{x};\n        var k := Search(r, x);\n        r := r[..k] + [x] + r[k..];\n    }\n    return r;\n}",
            "success": false
        },
        "Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseFirstNegative.dfy": {
            "state": "predicate positive(s:seq<int>)\n{forall u::0<=u<|s| ==> s[u]>=0}\nmethod mfirstNegative(v:array<int>) returns (b:bool, i:int)\nensures b <==> exists k::0<=k<v.Length && v[k]<0\nensures b ==> 0<=i<v.Length && v[i]<0 && positive(v[0..i])\n{ \n i:=0;\n b:=false;\n while (i<v.Length && !b)\n    invariant 0<=i<=v.Length\n    invariant b <==> exists k::0<=k<i && v[k]<0\n    invariant b ==> v[i-1]<0 && positive(v[0..i-1])\n    decreases v.Length - i\n  { \n    b:=(v[i]<0);\n    i:=i+1;\n   }\n  if (b){i:=i-1;}\n}\nmethod mfirstNegative2(v:array<int>) returns (b:bool, i:int)\nensures b <==> exists k::0<=k<v.Length && v[k]<0\nensures b ==> 0<=i<v.Length && v[i]<0 && positive(v[0..i])\n{ \n i:=0;b:=false;\n while (i<v.Length && !b)\ndecreases v.Length-i\ndecreases v.Length-i\ninvariant b <==> exists k::0<=k<i && v[k]<0\ninvariant 0<=i<=v.Length\ninvariant b ==> v[i-1]<0 && positive(v[0..i-1])\n  { \n    b:=(v[i]<0);\n    if (!b) {i:=i+1;}\n   }\n}",
            "success": false
        },
        "Metodos_Formais_tmp_tmpbez22nnn_Aula_2_ex1.dfy": {
            "state": "method Mult(x:nat, y:nat) returns (r: nat)\nensures r == x * y\n{\n    var m := x;\nassert m == x; // x has the right value\n    var n := y;\nassert r == x*y-n; // r still has the right value\n    r:=0;\n    while m > 0\ninvariant forall k :: 0 <= k < r ==> x - k != m;\ninvariant m <= x && r == x*y-m; // m <= x\ndecreases m\n    {\n        r := r + n;\n        m := m - 1;\n    }\n    return r;\n}",
            "success": false
        },
        "insert_strong.dfy": {
            "state": "method insert(line:array<char>, l:int, nl:array<char>, p:int, at:int)\n  requires 0 <= l+p <= line.Length\n  requires 0 <= p <= nl.Length\n  requires 0 <= at <= l\n  modifies line\n  ensures forall i :: (0<=i<p) ==> line[at+i] == nl[i]\n  ensures forall i :: (0<=i<at) ==> line[i] == old(line[i])\n  ensures forall i :: (at+p<=i<l+p) ==> line[i] == old(line[i-p])\n{\n  ghost var initialLine := line[..];\n  var i:int := l;\n  while(i>at)\ninvariant forall i::(0<=i<l) ==> line[i] == initialLine[i]\ninvariant forall i :: (i < p || at+i < l) ==> line[at+i] == (if i<p then nl[i] else line[i])\ndecreases i\n  {\n    i := i - 1;\n    line[i+p] := line[i];\n  }\n  i := 0;\n  while(i<p)\n  {\n    line[at + i] := nl[i];\n    i := i + 1;\n  }\n}",
            "success": false
        },
        "task_id_743.dfy": {
            "state": "method RotateRight(l: seq<int>, n: int) returns (r: seq<int>)\n    requires n >= 0\n    ensures |r| == |l|\n    ensures forall i :: 0 <= i < |l| ==> r[i] == l[(i - n + |l|) % |l|]\n{\n    var rotated: seq<int> := [];\n    for i := 0 to |l|\ninvariant |rotated| == i\ninvariant forall j :: 0 <= j < i ==> rotated[j] == l[(j - n + |l|) % |l|]\n    {\n        rotated := rotated + [l[(i - n + |l|) % |l|]];\n    }\n    return rotated;\n}",
            "success": true
        },
        "Dafny_Verify_tmp_tmphq7j0row_Test_Cases_solved_1_select.dfy": {
            "state": "method SelectionSort(a: array<int>)\n  modifies a\n  ensures forall i,j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures multiset(a[..]) == old(multiset(a[..]))\n{\n  var n := 0;\n  while n != a.Length\ninvariant multiset(a[..]) == old(multiset(a[..]))\n  {\n    var mindex, m := n, n;\n    while m != a.Length\ninvariant n <= m <= a.Length\ninvariant forall i :: n <= i < m ==> a[mindex] <= a[i]\n    {\n      if a[m] < a[mindex] {\n        mindex := m;\n      }\n      m := m + 1;\n    }\n    if a[mindex] < a[n] {\n      a[mindex], a[n] := a[n], a[mindex];\n    }\n    n := n + 1;\n  }  \n}",
            "success": false
        },
        "task_id_414.dfy": {
            "state": "method AnyValueExists(seq1: seq<int>, seq2: seq<int>) returns (result: bool)\n    ensures result <==> (exists i :: 0 <= i < |seq1| && seq1[i] in seq2)\n{\n    result := false;\n    for i := 0 to |seq1|\ninvariant result <==> (exists k :: 0 <= k < i && seq1[k] in seq2)\n    {\n        if seq1[i] in seq2 {\n            result := true;\n            break;\n        }\n    }\n}",
            "success": true
        },
        "Correctness_tmp_tmpwqvg5q_4_MethodCalls_q1.dfy": {
            "state": "/**\n  (a) Verify whether or not the following program\n      satisfies total correctness.\n      You should use weakest precondition reasoning\n      and may extend the loop invariant if required.\n      You will need to add a decreases clause to prove termination\n  (a) Weakest precondition proof (without termination) (6 marks)\n      Termination proof (2marks)\n*/\nfunction fusc(n: int): nat\nlemma rule1()\n  ensures fusc(0) == 0\nlemma rule2()\n  ensures fusc(1) == 1\nlemma rule3(n:nat)\n  ensures fusc(2*n) == fusc(n)\nlemma rule4(n:nat)\n  ensures fusc(2*n+1) == fusc(n) + fusc(n+1)\nmethod ComputeFusc(N: int) returns (b: int)\n  requires N >= 0 \n  ensures b == fusc(N)\n{\n  b := 0;\n  var n, a := N, 1;\n  while (n != 0)\n  {\n    ghost var d := n; // termination metric\n    if (n % 2 == 0)\n    {\n      rule4(n/2);\n      rule3(n/2);\n      a := a + b;\n      n := n / 2;\n    } else {\n      rule4((n-1)/2);\n      rule3((n-1)/2);\n      rule3((n+1)/2);\n              b * fusc(n) - b  * fusc(n) + b  * fusc(((n-1)/2)+1) + a * fusc(n);\n              b * fusc(n) - b  * (fusc(n) - fusc(((n-1)/2)+1)) + a * fusc(n);\n              a * fusc(n - 1) + b  * fusc(n) - b  * fusc(n-1) + a * fusc(n) - a * fusc(n-1);\n      b := b + a;\n      n := (n - 1) / 2;\n    }\n  }\n  rule1();\n  rule2();\n}",
            "success": false
        },
        "Workshop_tmp_tmp0cu11bdq_Workshop_Answers_Question6.dfy": {
            "state": "method arrayUpToN(n: int) returns (a: array<int>)\n    requires n >= 0\n    ensures a.Length == n\n    ensures forall j :: 0 < j < n ==> a[j] >= 0\n    ensures forall j, k : int :: 0 <= j <= k < n ==> a[j] <= a[k]\n{\n    var i := 0;\n    a := new int[n];\n    while i < n\ndecreases n - i\ninvariant forall j, k :: 0 <= j <= k < i ==> a[j] <= a[k]\n    {\n        a[i] := i;\n        i := i + 1;\n    }\n}",
            "success": false
        },
        "Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_50_examples_SumArray.dfy": {
            "state": "function Sum(arr: array<int>, len: int): int\n    reads arr\n    requires arr.Length > 0 && 0 <= len <= arr.Length\n{\n    if len == 0 then 0 else arr[len-1] + Sum(arr, len-1)\n}\nmethod SumArray(arr: array<int>) returns (sum: int)\n    requires arr.Length > 0\n    ensures sum == Sum(arr, arr.Length)\n{\n    sum := 0;\n    var i := 0;\n    while i < arr.Length\ninvariant 0 <= i <= arr.Length\ndecreases arr.Length - i\ninvariant sum == Sum(arr, i)\n    {\n        sum := sum + arr[i];\n        i := i + 1;\n    }\n}",
            "success": true
        },
        "task_id_424.dfy": {
            "state": "method ExtractRearChars(l: seq<string>) returns (r: seq<char>)\n    requires forall i :: 0 <= i < |l| ==> |l[i]| > 0\n    ensures |r| == |l|\n    ensures forall i :: 0 <= i < |l| ==> r[i] == l[i][|l[i]| - 1]\n{\n    var rearChars: seq<char> := [];\n    for i := 0 to |l|\ninvariant |rearChars| == i\ninvariant forall j :: 0 <= j < i ==> rearChars[j] == l[j][|l[j]| - 1]\n    {\n        rearChars := rearChars + [l[i][|l[i]| - 1]];\n    }\n    return rearChars;\n}",
            "success": true
        },
        "task_id_3.dfy": {
            "state": "method IsNonPrime(n: int) returns (result: bool)\n    requires n >= 2\n    ensures result <==> (exists k :: 2 <= k < n && n % k == 0)\n{\n    result := false;\n    var i := 2;\n    while i <= n/2\ninvariant result <==> (exists j :: 2 <= j < i && n % j == 0)\n    {\n        if n % i == 0\n        {\n            result := true;\n            break;\n        }\n        i := i + 1;\n    }\n}",
            "success": true
        },
        "task_id_8.dfy": {
            "state": "method SquareElements(a: array<int>) returns (squared: array<int>)\n    ensures squared.Length == a.Length\n    ensures forall i :: 0 <= i < a.Length ==> squared[i] == a[i] * a[i]\n{\n    squared := new int[a.Length];\n    for i := 0 to a.Length\ninvariant forall j :: 0 <= j < i ==> squared[j] == a[j] * a[j]\n    {\n        squared[i] := a[i] * a[i];\n    }\n}",
            "success": true
        },
        "task_id_170.dfy": {
            "state": "function sumTo( a:array<int>, start:int, end:int ) : int\n    requires a != null;\n    requires 0 <= start && start <= end && end <= a.Length;\n    decreases end;\n    reads a;\n    {\n        if (start == end) then 0 else sumTo(a, start, end-1) + a[end-1]\n    }\n    method SumInRange(a: array<int>, start: int, end: int) returns (sum: int)\n    requires a != null\n    requires 0 <= start && start <= end && end <= a.Length\n    ensures sum == sumTo(a, start, end)\n    {\n        sum := 0;\n        for i := start to end\ninvariant sum == sumTo(a, start, i)\n        {\n            sum := sum + a[i];\n        }\n    }",
            "success": true
        },
        "ProjectosCVS_tmp_tmp_02_gmcw_Handout 1_CVS_handout1_55754_55780.dfy": {
            "state": "/**\nCVS 2021-22 Handout 1\nAuthors\nGon\u00e7alo Martins Louren\u00e7o n\u00ba55780\nJoana Soares Faria  n\u00ba55754\n */\n// First Exercise\nlemma peasantMultLemma(a:int, b:int)\n    requires b >= 0\n    ensures b % 2 == 0 ==> (a * b == 2 * a * b / 2)\n    ensures b % 2 == 1 ==> (a * b == a + 2 * a * (b - 1) / 2)\n    {\n        if (b % 2 == 0 && b > 0) { \n            peasantMultLemma(a, b - 2);\n        }\n        if (b % 2 == 1 && b > 1) {\n            peasantMultLemma(a, b - 2);\n        }\n    }\nmethod peasantMult(a: int, b: int) returns (r: int)\n    requires b > 0\n    ensures r == a * b\n    {\n        r := 0;\n        var aa := a;\n        var bb := b;\n        while(bb > 0)\n            decreases bb \n            invariant 0 <= bb <= b\n            invariant r + aa * bb == a * b\n        { \n            // Use of lemma was not necessary for a successful verification\n            // peasantMultLemma(aa, bb);\n            if (bb % 2 == 0)\n            {\n                aa := 2 * aa;\n                bb := bb / 2;\n            } else if (bb % 2 == 1)\n            {\n                r := r + aa;\n                aa := 2 * aa;\n                bb := (bb-1) / 2;\n            }\n        } \n    }\n//Second Exercise\nmethod euclidianDiv(a: int,b : int) returns (q: int,r: int)\n    requires a >= 0\n    requires b > 0\n    ensures a == b * q + r\n    {\nassert a  ==  b * q + r;\n        r := a;\n        q := 0;\n        while(r - b >= 0)\ninvariant r <= a\ninvariant r <= a\ndecreases r\ninvariant r >= 0\n            // invariant a == b * q + r\n        {\n            r := r - b;\n            q := q + 1;\n        }\n    }",
            "success": false
        },
        "Software-Verification_tmp_tmpv4ueky2d_Best Time to Buy and Sell Stock_best_time_to_buy_and_sell_stock.dfy": {
            "state": "method best_time_to_buy_and_sell_stock(prices: array<int>) returns (max_profit: int)\n    requires 1 <= prices.Length <= 100000\n    requires forall i :: 0 <= i < prices.Length ==> 0 <= prices[i] <= 10000\n    ensures forall i, j :: 0 <= i < j < prices.Length ==> max_profit >= prices[j] - prices[i]\n{\n    var min_price := 10001;\n    max_profit := 0;\n    var i := 0;\nassert max_profit >= prices[i] - min_price;\n    while (i < prices.Length)\ninvariant i <= prices.Length\ninvariant forall k, l :: 0 <= k < l < i ==> max_profit >= prices[l] - prices[k]\ninvariant min_price <= 10001\ninvariant forall j :: 0 <= j < i ==> min_price <= prices[j]\n    {\n        var price := prices[i];\n        if (price < min_price)\n        {\n            min_price := price;\n        }\n        if (price - min_price > max_profit) {\n            max_profit := price - min_price;\n        }\n        i := i + 1;\n    }\n}",
            "success": true
        },
        "dafny_examples_tmp_tmp8qotd4ez_leetcode_0001-two-sum.dfy": {
            "state": "// If this invariant is added explicitly to the loop then the verfication never finishes.\n// It could be {:opaque} for a more controlled verification:\n// assert InMap([], m, target) by {\n//   reveal InMap();\n// }\npredicate InMap(nums: seq<int>, m: map<int, int>, t: int) {\n  forall j :: 0 <= j < |nums| ==> t - nums[j] in m\n}\nmethod TwoSum(nums: array<int>, target: int) returns (r: (int, int))\n  ensures 0 <= r.0 ==> 0 <= r.0 < r.1 < nums.Length && \n                       nums[r.0] + nums[r.1] == target &&\n                       forall i, j :: 0 <= i < j < r.1 ==> nums[i] + nums[j] != target\n  ensures r.0 == -1 <==> forall i, j :: 0 <= i < j < nums.Length ==> nums[i] + nums[j] != target\n{\n  var m: map<int, int> := map[];\n  var i := 0;\nassert 0 <= i < nums.Length ==> InMap(nums[..i], m, target);\n  while i < nums.Length\ninvariant 0 <= i <= nums.Length\ninvariant 0 <= i <= nums.Length\ninvariant InMap(nums[..i], m, target) // Once this assertion is removed, the verification finishes quickly, and when this assertion is added, the verification never finishes.\n  {\n    if nums[i] in m {\n      return (m[nums[i]], i);\n    }\n    m := m[target - nums[i] := i];\n    i := i + 1;\n  }\n  return (-1, -1);\n}",
            "success": false
        },
        "CVS-Projto1_tmp_tmpb1o0bu8z_Hoare.dfy": {
            "state": "method Max (x: nat, y:nat) returns (r:nat)\n    ensures (r >= x && r >=y)\n    ensures (r == x || r == y)\n{\n    if (x >= y) { r := x;}\n    else { r := y;}\n}\nmethod Test ()\n{\n    var result := Max(42, 73);\n    assert result == 73;\n}\nmethod m1 (x: int, y: int) returns (z: int)\nrequires 0 < x < y\nensures z >= 0 && z <= y && z != x\n{\n    //assume 0 < x < y\n    z := 0;\n}\nfunction fib (n: nat) : nat\n{\n    if n == 0 then 1 else\n    if n == 1 then 1 else\n    fib(n -1) + fib (n-2)\n}\nmethod Fib (n: nat) returns (r:nat)\n    ensures r == fib(n)\n{\n    if (n == 0) {\n        return 1;\n    }\n    r := 1;\n    var next:=2;\n    var i := 1;\n    while i < n\n        invariant 1 <= i <= n\n        invariant r == fib(i)\n        invariant next == fib(i+1)\n    {\n        var tmp:=next;\n        next:= next + r;\n        r:= tmp;\n        i:= i + 1;\n    }\n    assert r == fib(n);\n    return r;\n}\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\nfunction add(l:List<int>) : int\n{\n    match l\n    case Nil => 0\n    case Cons(x, xs) => x + add(xs)\n}\nmethod addImp (l: List<int>) returns (s: int)\n    ensures s == add(l)\n{\n    var ll := l;\n    s := 0;\n    while ll != Nil\n        decreases ll\n        invariant add(l) == s + add(ll)\n        {\n            s := s + ll.head;\n            ll:= ll.tail;\n        }\n    assert s == add(l);\n}\nmethod MaxA (a: array<int>) returns (m: int)\n    requires a.Length > 0\n    ensures forall i :: 0 <= i < a.Length ==> a[i] <= m\n    ensures exists i :: 0 <= i < a.Length && a[i] == m\n{\n    m := a[0];\n    var i := 1;\n    while i< a.Length\ninvariant 0 <= i <= a.Length\ninvariant forall j :: 0 <= j < i ==> a[j] <= m\ninvariant exists j :: 0 <= j < i && a[j] == m\n    {\n        if a[i] > m {\n            m:= a[i];\n        }\n        i := i +1;\n    }\n}",
            "success": true
        },
        "task_id_807.dfy": {
            "state": "predicate IsOdd(x: int)\n{\n    x % 2 != 0\n}\nmethod FindFirstOdd(a: array<int>) returns (found: bool, index: int)\n    requires a != null\n    ensures !found ==> forall i :: 0 <= i < a.Length ==> !IsOdd(a[i])\n    ensures found ==> 0 <= index < a.Length && IsOdd(a[index]) && forall i :: 0 <= i < index ==> !IsOdd(a[i])\n{\n    found := false;\n    index := 0;\n    while (index < a.Length)\ninvariant 0 <= index <= a.Length\ninvariant !found ==> forall i :: 0 <= i < index ==> !IsOdd(a[i])\ninvariant found ==> forall i :: 0 <= i < index ==> !IsOdd(a[i])\n    {\n        if IsOdd(a[index])\n        {\n            found := true;\n            return;\n        }\n        index := index + 1;\n    }\n}",
            "success": true
        },
        "min_array_strong.dfy": {
            "state": "method minArray(a: array<int>) returns (r:int)\n  requires a.Length > 0\n  ensures forall i :: 0 <= i < a.Length ==> r <= a[i]\n  ensures exists i :: 0 <= i < a.Length && r == a[i]\n{\n  r:=a[0];\n  var i:=1;\n  while i<a.Length\ninvariant r==a[0]\ninvariant exists j::0<=j<i&&r==a[j]\n  {\n    if r>a[i]{\n      r:=a[i];\n    }\n    i:=i+1;\n  }\n}",
            "success": false
        },
        "task_id_594.dfy": {
            "state": "predicate IsEven(n: int)\n{\n    n % 2 == 0\n}\npredicate IsOdd(n: int)\n{\n    n % 2 != 0\n}\nmethod FirstEvenOddDifference(a: array<int>) returns (diff: int)\n    requires a.Length >= 2\n    requires exists i :: 0 <= i < a.Length && IsEven(a[i])\n    requires exists i :: 0 <= i < a.Length && IsOdd(a[i])\n    ensures exists i, j :: 0 <= i < a.Length && 0 <= j < a.Length && IsEven(a[i]) && IsOdd(a[j]) && diff == a[i] - a[j] && \n        (forall k :: 0 <= k < i ==> IsOdd(a[k])) && (forall k :: 0 <= k < j ==> IsEven(a[k]))\n{\n    var firstEven: int := -1;\n    var firstOdd: int := -1;\n    for i := 0 to a.Length\ninvariant forall k :: 0 <= k < firstEven ==> IsOdd(a[k])\ninvariant firstEven != -1 ==> IsEven(a[firstEven])\n    {\n        if firstEven == -1 && IsEven(a[i])\n        {\n            firstEven := i;\n        }\n        if firstOdd == -1 && IsOdd(a[i])\n        {\n            firstOdd := i;\n        }\n        if firstEven != -1 && firstOdd != -1\n        {\n            break;\n        }\n    }\n    diff := a[firstEven] - a[firstOdd];\n}",
            "success": false
        },
        "dafny-duck_tmp_tmplawbgxjo_p1.dfy": {
            "state": "// Given an array of integers, it returns the sum. [1,3,3,2]->9\nfunction Sum(xs: seq<int>): int {\n    if |xs| == 0 then 0 else Sum(xs[..|xs|-1]) + xs[|xs|-1]\n}\nmethod SumArray(xs: array<int>) returns (s: int)\n    ensures s == Sum(xs[..])\n{\n    s := 0;\n    var i := 0;\n    while i < xs.Length\ndecreases xs.Length - i\ndecreases xs.Length - i\ndecreases xs.Length - i\ninvariant 0 <= i <= xs.Length\ninvariant s == Sum(xs[..i])\n    {\n        s := s + xs[i];\n        i := i + 1;\n    }\n}",
            "success": false
        },
        "laboratory_tmp_tmps8ws6mu2_dafny-tutorial_exercise11.dfy": {
            "state": "method m()\n{\n    var i, n := 0, 20;\n    while i != n\ninvariant i <= n\n    {\n        i := i + 1;\n    }\n}",
            "success": true
        },
        "task_id_554.dfy": {
            "state": "/**\n * Find odd numbers from an array of numbers\n **/\npredicate IsOdd(n: int)\n{\n    n % 2 == 1\n}\nmethod FindOddNumbers(arr: array<int>) returns (oddList: seq<int>)\n    // All numbers in the output are odd and exist in the input \n    ensures forall i :: 0 <= i < |oddList| ==> IsOdd(oddList[i]) && oddList[i] in arr[..]\n    // All odd numbers in the input are in the output\n    ensures forall i :: 0 <= i < arr.Length && IsOdd(arr[i]) ==> arr[i] in oddList\n{\n    oddList := [];\n    for i := 0 to arr.Length\ninvariant forall k :: 0 <= k < |oddList| ==> IsOdd(oddList[k]) && oddList[k] in arr[..]\ninvariant forall k :: 0 <= k < i && IsOdd(arr[k]) ==> arr[k] in oddList\n    {\n        if IsOdd(arr[i])\n        {\n            oddList := oddList + [arr[i]];\n        }\n    }\n}",
            "success": true
        },
        "Dafny-experiences_tmp_tmp150sm9qy_dafny_started_tutorial_dafny_tutorial_array.dfy": {
            "state": "method FindMax(a: array<int>) returns (i: int)\n  // Annotate this method with pre- and postconditions\n  // that ensure it behaves as described.\n  requires a.Length > 0\n  ensures 0<= i < a.Length\n  ensures forall k :: 0 <= k < a.Length ==> a[k] <= a[i]\n{\n  // Fill in the body that calculates the INDEX of the maximum.\n  i := 0;\nassert a[i] == a[0];\n  var index := 1;\n  while index < a.Length\ninvariant index <= a.Length\ninvariant 0 <= i < index\ninvariant forall k :: 0 <= k < index ==> a[k] <= a[i]\n  {\n    if a[index] > a[i] {i:= index;}\n    index := index + 1;\n  }\n}",
            "success": true
        },
        "Workshop_tmp_tmp0cu11bdq_Workshop_Answers_Question5.dfy": {
            "state": "method rev(a : array<int>)\n    requires a != null;\n    modifies a;\n    ensures forall k :: 0 <= k < a.Length ==> a[k] == old(a[(a.Length - 1) - k]);\n{\n    var i := 0;\n    while (i < a.Length - 1 - i)\ndecreases a.Length/2 - i;\ninvariant a[..i] == old(a[a.Length - 1 - i..a.Length - 1]);\ninvariant forall k :: 0 <= k < i ==> a[k] == old(a[a.Length - 1 - k]);\ninvariant 0 <= i <= a.Length / 2;\ninvariant forall k :: a.Length / 2 - i <= k < a.Length / 2 + i ==> a[k] == old(a[a.Length - 1 - k]);\n    {\n        a[i], a[a.Length - 1 - i] := a[a.Length - 1 - i], a[i];\n        i := i + 1;\n    }\n}",
            "success": false
        },
        "Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_50_examples_28.dfy": {
            "state": "method main(x: int, y: int) returns (x_out: int, y_out: int, n: int)\nrequires x >= 0\nrequires y >= 0\nrequires x == y\nensures y_out == n\n{\nassert x_out == n;\n    x_out := x;\n    y_out := y;\n    n := 0;\n    while (x_out != n)\ninvariant x_out == n\ninvariant x_out <= n\ninvariant 0 <= n <= y\n    {\n        x_out := x_out - 1;\n        y_out := y_out - 1;\n    }\n}",
            "success": false
        },
        "dafny_tmp_tmp2ewu6s7x_ListReverse.dfy": {
            "state": "function reverse(xs: seq<nat>): seq<nat>\n{\n    if xs == [] then [] else reverse(xs[1..]) + [xs[0]]\n}\nlemma ReverseAppendDistr(xs: seq<nat>, ys: seq<nat>)\nensures reverse(xs + ys) == reverse(ys) + reverse(xs)\n{\n    if {\n        case xs == [] =>\n        calc {\nreverse(xs) + reverse(xs[1..]);\n==\n            reverse([] + ys);\n            calc {\n                [] + ys;\n                ys;\n            }\n            reverse(ys);\n            reverse(ys) + reverse([]);\n        }\n        case xs != [] => {\n            var zs := xs + ys;\nassert zs[1..] == xs[1..] + ys;\n        }\n    }\n}\nlemma ReverseInvolution(xxs: seq<nat>)\ndecreases xxs\nensures reverse(reverse(xxs)) == xxs\n{\n    if {\n        case xxs == [] => {}\n        case xxs != [] => calc {\n            reverse(reverse(xxs));\n            ==\n            reverse(reverse(xxs[1..]) + [xxs[0]]);\n            ==\n            { ReverseAppendDistr(reverse(xxs[1..]), [xxs[0]]); }\n            reverse([xxs[0]]) + reverse(reverse(xxs[1..]));\n            ==\n            { ReverseInvolution(xxs[1..]); }\n            calc {\n                reverse([xxs[0]]);\n                ==\n                [] + [xxs[0]];\n                ==\n                [xxs[0]];\n            }\n            [xxs[0]] + xxs[1..];\n            ==\n            xxs;\n        }\n    }\n}",
            "success": false
        },
        "task_id_732.dfy": {
            "state": "predicate IsSpaceCommaDot(c: char)\n{\n    c == ' ' || c == ',' || c == '.'\n}\nmethod ReplaceWithColon(s: string) returns (v: string)\n    ensures |v| == |s|\n    ensures forall i :: 0 <= i < |s| ==> (IsSpaceCommaDot(s[i]) ==> v[i] == ':') && (!IsSpaceCommaDot(s[i]) ==> v[i] == s[i])\n{\n    var s' : string := [];\n    for i := 0 to |s|\ninvariant |s'| == i\ninvariant forall k :: 0 <= k < i ==> (IsSpaceCommaDot(s[k]) ==> s'[k] == ':') && (!IsSpaceCommaDot(s[k]) ==> s'[k] == s[k])\n    {\n        if IsSpaceCommaDot(s[i])\n        {\n            s' := s' + [':'];\n        }\n        else \n        {\n            s' := s' + [s[i]];\n        }\n    }\n    return s';\n}",
            "success": true
        },
        "task_id_445.dfy": {
            "state": "method MultiplyElements(a: seq<int>, b: seq<int>) returns (result: seq<int>)\n    requires |a| == |b|\n    ensures |result| == |a|\n    ensures forall i :: 0 <= i < |result| ==> result[i] == a[i] * b[i]\n{\n    result := [];\n    var i := 0;\n    while i < |a|\ninvariant 0 <= i <= |a|\ninvariant |result| == i\ninvariant forall k :: 0 <= k < i ==> result[k] == a[k] * b[k]\n    {\n        result := result + [a[i] * b[i]];\n        i := i + 1;\n    }\n}",
            "success": true
        },
        "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_pregel algorithms_skeleton_nondet-permutation.dfy": {
            "state": "\ufeffmodule Permutation\n{\n\t/**\n\t * Given n >= 0, generate a permuation of {0,...,n-1} nondeterministically.\n\t */\n\tmethod Generate(n: int) returns (perm: array<int>)\n\t\trequires n >= 0\n\t\tensures perm != null\n\t\tensures perm.Length == n\n\t\tensures fresh(perm)\n\t\tensures isValid(perm, n)\n\t{\nassert isValid(perm, n);\n\t\tvar all := set x | 0 <= x < n;\n\t\tvar used := {};\n\t\tperm := new int[n];\n\t\tCardinalityLemma(n, all);\n\t\twhile used < all\n\t\t{\n\t\t\tCardinalityOrderingLemma(used, all);\n\t\t\tvar dst :| dst in all && dst !in used;\n\t\t\tperm[|used|] := dst;\n\t\t\tused := used + {dst};\n\t\t}\n\t\tprint perm;\n\t}\n\tpredicate isValid(a: array<int>, n: nat)\n\t\trequires a != null && a.Length == n\n\t\treads a\n\t{\n\t\tassume forall i | 0 <= i < n :: i in a[..];\n\t\tdistinct(a)\n\t\t&& (forall i | 0 <= i < a.Length :: 0 <= a[i] < n)\n\t\t&& (forall i | 0 <= i < n :: i in a[..])\n\t}\n\tpredicate distinct(a: array<int>)\n\t\trequires a != null\n\t\treads a\n\t{\n\t\tdistinct'(a, a.Length)\n\t}\n\tpredicate distinct'(a: array<int>, n: int)\n\t\trequires a != null\n\t\trequires a.Length >= n\n\t\treads a\n\t{\n\t\tforall i,j | 0 <= i < n && 0 <= j < n && i != j :: a[i] != a[j]\n\t}\n\tlemma CardinalityLemma (size: int, s: set<int>)\n\t\trequires size >= 0\n\t\trequires s == set x | 0 <= x < size\n\t\tensures\tsize == |s|\n\t{\nassert |s| == size;\n\t\tif(size == 0) {\n\t\t} else {\n\t\t\tCardinalityLemma(size - 1, s - {size - 1});\n\t\t}\n\t}\n\tlemma CardinalityOrderingLemma<T> (s1: set<T>, s2: set<T>)\n\t\trequires s1 < s2\n\t\tensures |s1| < |s2|\n\t{\nassert s2 - s1 == set x | x in s2 && x !in s1;\n\t\tvar e :| e in s2 - s1;\n\t\tif s1 != s2 - {e} {\n\t\t\tCardinalityOrderingLemma(s1, s2 - {e});\n\t\t}\n\t}\n\tlemma SetDiffLemma<T> (s1: set<T>, s2: set<T>)\n\t\trequires s1 < s2\n\t\tensures s2 - s1 != {}\n\t{\n\t\tvar e :| e in s2 - s1;\n\t\tif s2 - s1 != {e} {} // What does Dafny prove here???\n\t}\n}",
            "success": false
        },
        "cs245-verification_tmp_tmp0h_nxhqp_quicksort-partition.dfy": {
            "state": "// Quicksort Partition -- Stephanie McIntyre\n// Based on examples in class \n// Parts have been modified cause you know, arrays are different...\nmethod QuicksortPartition(X: array<int>, n: int, p: int) returns (a: int, b: int)\nmodifies X;\n/*Pre-Condition*/   requires X.Length>=1 && n == X.Length;\n/*Post-Condition*/  ensures b>=n;\n                    ensures forall x:: 0<=x<a<n ==> X[x] <= p;\n                    ensures forall x:: a==n || (0<=a<=x<n ==> X[x] > p);\n                    ensures multiset(X[..])==multiset(old(X[..]))           //This says the new X is a permutation of our old version of X.\n{\n  a := 0;\n  while ( a < n && X[a] <= p ) \ninvariant 0<=a<=n;  //We will want this later\ninvariant 0<=a<=n;  //We will want this later\ninvariant forall x:: 0<=x<a  ==> X[x] <= p;\ninvariant multiset(X[..])==multiset(old(X[..]))           //This says the new X is a permutation of our old version of X.\ninvariant forall x::a<=x<b<n ==> X[x]>p;\n  { \n    a := a+1;\n  }\n  b := a+1;\n  while ( b<n )\n  { \n    if ( X[b] <= p ) {\n      var t := X[b]; \n      X[b] := X[a]; \n      X[a] := t; \n      a := a+1;\n    }\n    b := b+1;\n  }\n}\n/* The annotations and implied proofs are left for you.\n   I might do them later on next week. */",
            "success": false
        },
        "ironsync-osdi2023_tmp_tmpx80antoe_linear-dafny_docs_DafnyRef_examples_Example-Old2.dfy": {
            "state": "class A {\n  var value: int\n  constructor ()\n     ensures value == 10\n  {\n     value := 10;\n  }\n}\nclass B {\n   var a: A\n   constructor () { a := new A(); }\n   method m()\n     requires a.value == 11\n     modifies this, this.a\n   {\n     label L:\n     a.value := 12;\n     label M:\n     a := new A(); // Line X\n     label N:\n     a.value := 20;\n     label P:\nassert a.value == 20; // Line Q\n                                // but .value in current state\n                                  // reference at Line X\n  }\n}",
            "success": true
        },
        "set_to_seq_strong.dfy": {
            "state": "method SetToSeq<T>(s: set<T>) returns (xs: seq<T>)\n  ensures multiset(s) == multiset(xs)\n{\n  xs := [];\n  var left: set<T> := s;\n  while left != {}\ninvariant multiset(left) + multiset(xs) == multiset(s)\n  {\n    var x :| x in left;\n    left := left - {x};\n    xs := xs + [x];\n  }\n}",
            "success": true
        },
        "task_id_106.dfy": {
            "state": "method AppendArrayToSeq(s: seq<int>, a: array<int>) returns (r: seq<int>)\n    requires a != null\n    ensures |r| == |s| + a.Length\n    ensures forall i :: 0 <= i < |s| ==> r[i] == s[i]\n    ensures forall i :: 0 <= i < a.Length ==> r[|s| + i] == a[i]\n{\n    r := s;\n    for i := 0 to a.Length\ninvariant |r| == |s| + i\ninvariant forall j :: 0 <= j < |s| ==> r[j] == s[j]\ninvariant forall j :: 0 <= j < i ==> r[|s| + j] == a[j]\n    {\n        r := r + [a[i]];\n    }\n}",
            "success": true
        },
        "task_id_474.dfy": {
            "state": "method ReplaceChars(s: string, oldChar: char, newChar: char) returns (v: string)\n    ensures |v| == |s|\n    ensures forall i :: 0 <= i < |s| ==> (s[i] == oldChar ==> v[i] == newChar) && (s[i] != oldChar ==> v[i] == s[i])\n{\n    var s' : string := [];\n    for i := 0 to |s|\ninvariant |s'| == i\ninvariant forall j :: 0 <= j < i ==> (s[j] == oldChar ==> s'[j] == newChar) && (s[j] != oldChar ==> s'[j] == s[j])\n    {\n        if s[i] == oldChar\n        {\n            s' := s' + [newChar];\n        }\n        else \n        {\n            s' := s' + [s[i]];\n        }\n    }\n    return s';\n}",
            "success": true
        },
        "dafny_examples_tmp_tmp8qotd4ez_lib_math_DivMod.dfy": {
            "state": "module DivMod {\n  function {:opaque} DivSub(a: int, b: int): int\n    requires 0 <= a && 0 < b\n  {\n    if a < b then 0 else 1 + DivSub(a - b, b)\n  }\n  function {:opaque} ModSub(a: int, b: int): int\n    requires 0 <= a && 0 < b\n  {\n    if a < b then a else ModSub(a - b, b)\n  }\n  lemma DivModAdd1(a: int, b: int)\n    requires b != 0\n    ensures (a + b) % b == a % b\n    ensures (a + b) / b == a / b + 1\nlemma DivModAdd(a: int, b: int, c: int)\n  {\nassert (a * b + c) - (a * b + c) % b == (a * b + c) / b;\nassert c < 2 * b;\nassert c * b / b == c;\n    var c := (a + b) / b - (a / b) - 1;\n  }\n  lemma DivModSub1(a: int, b: int)\n    requires b != 0\n    ensures (a - b) % b == a % b\n    ensures (a - b) / b == a / b - 1\n  {\n    var c := (a - b) / b - (a / b) + 1;\n  }\n  lemma ModEq(a: int, b: int)\n    requires 0 <= a && 0 < b\n    ensures a % b == ModSub(a, b)\n  {\n    reveal ModSub();\n    if a >= b {\n      DivModSub1(a, b);\n    }\n  }\n  lemma DivEq(a: int, b: int)\n    requires 0 <= a && 0 < b\n    ensures a / b == DivSub(a, b)\n  {\n    reveal DivSub();\n    if a >= b {\n      DivModSub1(a, b);\n    }\n  }\n  lemma DivModSpec'(a: int, b: int, q: int, r: int)\n    requires 0 <= a && 0 < b\n    requires 0 <= q && 0 <= r < b\n    requires a == q * b + r\n    ensures ModSub(a, b) == r\n    ensures DivSub(a, b) == q\n  {\n    reveal ModSub();\n    reveal DivSub();\n    if q > 0 {\n      DivModSpec'(a - b, b, q - 1, r);\n    }\n  }\n  lemma DivModSpec(a: int, b: int, q: int, r: int)\n    requires 0 <= a && 0 < b\n    requires 0 <= q && 0 <= r < b\n    requires a == q * b + r\n    ensures a % b == r\n    ensures a / b == q\n  {\n    ModEq(a, b);\n    DivEq(a, b);\n    DivModSpec'(a, b, q, r);\n  }\n  lemma DivMul(a: int, b: int)\n    requires 0 <= a && 0 < b\n    ensures a * b / b == a\n  {\n    DivModSpec(a * b, b, a, 0);\n  }\n  lemma DivModMulAdd(a: int, b: int, c: int)\n    requires 0 <= a && 0 <= c < b && 0 < b\n    ensures (a * b + c) / b == a\n    ensures (a * b + c) % b == c\n  {\n    DivModSpec(a * b + c, b, a, c);\n  }\n}",
            "success": false
        },
        "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_basic examples_sumto_sol.dfy": {
            "state": "function sum_up_to (n: nat): nat\n{\n  if (n == 0) then 0\n  else sum_up_to (n-1) + 1\n}\nmethod SumUpTo (n: nat) returns (r: nat)\n  ensures r == sum_up_to (n);\n{\n  var i := 0;\n  r := 0;\n  while (i < n)\n    invariant 0 <= i <= n;\n    invariant r == sum_up_to (i);\n  {\n    r := r + 1;\n    i := i + 1;\n  }\n}\nfunction total (a: seq<nat>) : nat\n{\n  if |a| == 0 then 0\n  else total (a[0..|a|-1]) + a[|a|-1]\n}\nlemma total_lemma (a: seq<nat>, i:nat) \n  requires |a| > 0;\n  requires 0 <= i < |a|;\n  ensures total (a[0..i]) + a[i] == total (a[0..i+1]);\n{\n  ghost var b := a[0..i+1];\n  calc\n  {\n    total (a[0..i+1]);\n    total (b);\n    total (b[0..|b|-1]) + b[|b|-1];\n    total (b[0..|b|-1]) + a[i];\n    {assert (b[0..|b|-1] == a[0..i]);}\n    total (a[0..i]) + a[i];\n  }\n}\nmethod Total (a: seq<nat>) returns (r:nat)\n  ensures r == total (a[0..|a|]); \n{\n  var i := 0;\n  r := 0;\n  while i < |a|\ninvariant 0 <= i <= |a|;\ninvariant r == total (a[0..i]);\n  { \n    total_lemma (a, i);\n    r := r + a[i];\n    i := i + 1;\n  }\n}",
            "success": true
        },
        "array_sum_strong.dfy": {
            "state": "method arraySum(a: array<int>, b: array<int>) returns (c: array<int> )\n  requires a.Length==b.Length\n  ensures c.Length==a.Length\n  ensures forall i:: 0 <= i< a.Length==> a[i] + b[i]==c[i]\n{\n  c:= new int[a.Length];\n  var i:=0;\n  while i<a.Length\ndecreases c.Length-i\n  {\n    c[i]:=a[i]+b[i];\n    i:=i+1;\n  }\n}",
            "success": false
        },
        "task_id_282.dfy": {
            "state": "method ElementWiseSubtraction(a: array<int>, b: array<int>) returns (result: array<int>)\n    requires a != null && b != null\n    requires a.Length == b.Length\n    ensures result != null\n    ensures result.Length == a.Length\n    ensures forall i :: 0 <= i < result.Length ==> result[i] == a[i] - b[i]\n{\n    result := new int[a.Length];\n    var i := 0;\n    while i < a.Length\n    {\n        result[i] := a[i] - b[i];\n        i := i + 1;\n    }\n}",
            "success": false
        },
        "task_id_2.dfy": {
            "state": "predicate InArray(a: array<int>, x: int)\n    reads a\n{\n    exists i :: 0 <= i < a.Length && a[i] == x\n}\nmethod SharedElements(a: array<int>, b: array<int>) returns (result: seq<int>)\n    // All elements in the output are in both a and b\n    ensures forall x :: x in result ==> (InArray(a, x) && InArray(b, x))\n    // The elements in the output are all different\n    ensures forall i, j :: 0 <= i < j < |result| ==> result[i] != result[j]\n{\n    var res: seq<int> := [];\n    for i := 0 to a.Length\ninvariant forall x :: x in res ==> (InArray(a, x) && InArray(b, x))\ninvariant forall j, k :: 0 <= j < k < |res| ==> res[j] != res[k]\n    {\n        if InArray(b, a[i]) && a[i] !in res\n        {\n            res := res + [a[i]];\n        }\n    }\n    result := res;\n}",
            "success": true
        },
        "task_id_145.dfy": {
            "state": "method MaxDifference(a: array<int>) returns (diff: int)\n    requires a.Length > 1\n    ensures forall i, j :: 0 <= i < a.Length && 0 <= j < a.Length ==> a[i] - a[j] <= diff\n{\n    var minVal := a[0];\n    var maxVal := a[0];\n    for i := 1 to a.Length\ninvariant forall j :: 0 <= j < i ==> minVal <= a[j] && a[j] <= maxVal\n    {\n        if a[i] < minVal {\n            minVal := a[i];\n        } else if a[i] > maxVal {\n            maxVal := a[i];\n        }\n    }\n    diff := maxVal - minVal;\n}",
            "success": true
        },
        "Dafny-Exercises_tmp_tmpjm75muf__Session4Exercises_ExerciseContained.dfy": {
            "state": "predicate strictSorted(s : seq<int>) {\n\tforall u, w :: 0 <= u < w < |s| ==> s[u] < s[w]\n}\nmethod mcontained(v:array<int>,w:array<int>,n:int,m:int) returns (b:bool)\n//Specify and implement an O(m+n) algorithm that returns b\n//v and w are strictly increasing ordered arrays\n//b is true iff the first n elements of v are contained in the first m elements of w\nrequires n<=m && n>=0\nrequires strictSorted(v[..])\nrequires strictSorted(w[..])\nrequires v.Length >= n && w.Length >= m\nensures b==forall k:: 0<= k< n ==> v[k] in w[..m]//exists j :: 0 <= j < m && v[k] == w[j]\n{\n\tvar i:=0;\n\tvar j:=0;\n\twhile(i<n && j<m && (v[i] >= w[j])) //&& b)\ndecreases v.Length-i\ninvariant 0<=i<=n && 0<=j<=m\ninvariant forall k::0<=k<i ==> v[k] in w[..m]//exists j :: 0 <= j < m && v[k] == w[j]\ndecreases w.Length-j\ninvariant i<=j\n\t{\t\n\t\tif(v[i] == w[j]){\n\t\t\ti:=i+1;\n\t\t}\n\t\tj:=j+1;\n\t}\n\tb := i==n;\n}",
            "success": false
        },
        "ironsync-osdi2023_tmp_tmpx80antoe_linear-dafny_docs_DafnyRef_examples_Example-Old.dfy": {
            "state": "class A {\n  var value: int\n  method m(i: int)\n    requires i == 6\n    requires value == 42\n    modifies this\n  {\n    var j: int := 17;\n    value := 43;\n    label L:\n    j := 18;\n    value := 44;\n    label M:\nassert(j + 1 == 19);\n    // value is this.value; 'this' is the same\n    // same reference in current and pre state but the\n    // values stored in the heap as its fields are different;\n    // '.value' evaluates to 42 in the pre-state, 43 at L,\n    // and 44 in the current state\n  }\n}",
            "success": true
        },
        "Dafny_Programs_tmp_tmp99966ew4_binary_search.dfy": {
            "state": "predicate sorted(a: array<int>)\n   requires a != null\n   reads a\n{\n   forall j, k :: 0 <= j < k < a.Length ==> a[j] <= a[k]\n}\nmethod BinarySearch(a: array<int>, value: int) returns (index: int)\n   requires a != null && 0 <= a.Length && sorted(a)\n   ensures 0 <= index ==> index < a.Length && a[index] == value\n   ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != value\n{\n   var low, high := 0, a.Length;\n   while low < high\n         0 <= i < a.Length && !(low <= i < high) ==> a[i] != value\n   {\n      var mid := (low + high) / 2;\n      if a[mid] < value\n      {\n         low := mid + 1;\n      }\n      else if value < a[mid]\n      {\n         high := mid;\n      }\n      else\n      {\n         return mid;\n      }\n   }\n   return -1;\n}",
            "success": false
        },
        "llm-verified-eval_tmp_tmpd2deqn_i_dafny_161.dfy": {
            "state": "function IsLetter(c: char): bool \n{\n  (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') \n}\nfunction NoLetters(s: string, n: nat): bool \n  requires n <= |s|\n{\n  forall c :: 0 <= c < n ==> !IsLetter(s[c])\n}\nfunction ToggleCase(c: char): char\n{\n  if c >= 'a' && c <= 'z' \n  then \n    (c - 'a' + 'A')\n  else if c >= 'A' && c <= 'Z' \n    then \n      (c - 'A' + 'a')\n    else \n      c\n}\nfunction isReverse(s: string, s_prime: string): bool{\n  (|s| == |s_prime|) &&\n  (forall si :: 0 <= si < |s|/2 ==> s_prime[|s| - si - 1] == s[si])\n}\nmethod Reverse(original: seq<char>) returns (reversed: seq<char>)\n  ensures |reversed| == |original| \n  ensures forall i :: 0 <= i < |original| ==> reversed[i] == original[|original| - 1 - i] \n{\n  reversed := []; \n  var i := |original|;\n  while i > 0\n    decreases i\n    invariant 0 <= i <= |original|\n    invariant  |reversed| == |original| - i\n    invariant forall j :: 0 <= j < |original|-i ==>\n    reversed[j] == original[|original| - 1 - j]\n  {\n    i := i - 1;\n    reversed := reversed + [original[i]]; \n  }\n}\nmethod solve(s: string) returns (result: string)\n  ensures |result| == |s| \n  ensures !NoLetters(s, |s|) ==> forall i :: 0 <= i < |s| && IsLetter(s[i]) ==> result[i] == ToggleCase(s[i])\n  ensures !NoLetters(s, |s|) ==> forall i :: 0 <= i < |s| && !IsLetter(s[i]) ==> result[i] == s[i] \n  ensures NoLetters(s, |s|) ==> isReverse(result, s) \n{\n    var flg : bool := false;\n    result := \"\";\n    for i := 0 to |s|\ninvariant flg ==> !NoLetters(s, i+1)\ninvariant |result| == i\ninvariant !NoLetters(s, i+1) ==> forall j :: 0 <= j < i+1 && !IsLetter(s[j]) ==> result[j] == s[j]\n    {\n      if IsLetter(s[i])\n      {\n        result := result + [ToggleCase(s[i])];\n        flg := true;\n      } else {\n        result := result + [s[i]];\n      }\n    }\n    if !flg\n    {\n      result := Reverse(s);\n    }\n}",
            "success": false
        },
        "Dafny_Verify_tmp_tmphq7j0row_dataset_C_convert_examples_15.dfy": {
            "state": "method main(n: int, k: int) returns (k_out: int)\n    requires n > 0;\n\trequires k > n;\n\tensures k_out >= 0;\n{\n\tk_out := k;\n    var j: int := 0;\n    while(j < n)\ndecreases k + n - j;\ndecreases k + n - j;\ndecreases k + n - j;\ninvariant j <= n || k >= 1\ninvariant 0 <= j <= n\n    {\n        j := j + 1;\n        k_out := k_out - 1;\n    }\n}\n// C code:\n// MODULE main\n// \tint i;\n// \tint n;\n// \tint j;\n// \tint k;\n// \tassume(n > 0);\n// \tassume(k > n);\n// \tassume(j == 0);\n// \twhile(j < n){\n// \t\tj = j + 1;\n// \t\tk = k - 1;\n// \t}\n// \tassert(k >= 0);\t\n// END MODULE\n// Invariant\n// (\n    // not (or (<= 1 (+ n (+ (* (- 1) j) (* (- 1) k)))) (\n    //     and (<= k (- 1)) (<= (+ n (* (- 1) j)) (- 1)))))",
            "success": false
        },
        "Dafny_Verify_tmp_tmphq7j0row_Generated_Code_Mult.dfy_1.dfy": {
            "state": "method mult(a:int, b:int) returns (x:int)\n  \trequires a >= 0 && b >= 0\n  \tensures x == a * b\n{\n  \tx := 0;\n\tvar y := a;\n  \twhile y > 0\ninvariant x == (a - y) * b\ndecreases y\n\t{\n\t\tx := x + b;\n\t\ty := y - 1;\n\t}\n}",
            "success": true
        },
        "Dafny_Verify_tmp_tmphq7j0row_Generated_Code_ComputePower.dfy_3.dfy": {
            "state": "function Power(n: nat): nat {\n    if n == 0 then 1 else 2 * Power(n - 1)\n}\nmethod ComputePower(n: nat) returns (p: nat)\n    ensures p == Power(n)\n{\n    p := 1;\n    var i := 0;\nassert p == Power(i);\n    while i != n\ninvariant i <= n && p == Power(i)\n    {\n        i := i + 1;\n        p := p * 2;\n    }\n}",
            "success": true
        },
        "Dafny_tmp_tmpv_d3qi10_3_cumsum.dfy": {
            "state": "function sum(a: array<int>, i: int): int\n    requires 0 <= i < a.Length\n    reads a\n{\n    a[i] + if i == 0 then 0 else sum(a, i - 1)\n}\nmethod cumsum(a: array<int>, b: array<int>)\n    requires  a.Length == b.Length && a.Length > 0 && a != b\n    // when you change a  , that's not the same object than b . \n    //requires b.Length > 0 \n    ensures forall i | 0 <= i < a.Length :: b[i] == sum(a, i)\n    modifies b\n{\n    b[0] := a[0]; // Initialise le premier \u00e9l\u00e9ment de b\n    var i := 1;\n    while i < a.Length\ninvariant a.Length - i <= b.Length // Taille de b suffisante\ninvariant b[i - 1] == sum(a, i - 1) // La somme cumul\u00e9e du pr\u00e9vu est bien calcul\u00e9e.\n    {\n        b[i] := b[i - 1] + a[i]; // Calcule la somme cumul\u00e9e pour chaque \u00e9l\u00e9ment\n        i := i + 1;\n    }\n}",
            "success": false
        },
        "task_id_412.dfy": {
            "state": "/**\n * Remove odd numbers from an array of numbers\n **/\npredicate IsEven(n: int)\n{\n    n % 2 == 0\n}\nmethod RemoveOddNumbers(arr: array<int>) returns (evenList: seq<int>)\n    // All numbers in the output are even and exist in the input \n    ensures forall i :: 0 <= i < |evenList| ==> IsEven(evenList[i]) && evenList[i] in arr[..]\n    // All even numbers in the input are in the output\n    ensures forall i :: 0 <= i < arr.Length && IsEven(arr[i]) ==> arr[i] in evenList\n{\n    evenList := [];\n    for i := 0 to arr.Length\ninvariant forall k :: 0 <= k < |evenList| ==> IsEven(evenList[k]) && evenList[k] in arr[..]\ninvariant forall k :: 0 <= k < i && IsEven(arr[k]) ==> arr[k] in evenList\n    {\n        if IsEven(arr[i])\n        {\n            evenList := evenList + [arr[i]];\n        }\n    }\n}",
            "success": true
        },
        "task_id_603.dfy": {
            "state": "method LucidNumbers(n: int) returns (lucid: seq<int>)\n    requires n >= 0\n    ensures forall i :: 0 <= i < |lucid| ==> lucid[i] % 3 == 0\n    ensures forall i :: 0 <= i < |lucid| ==> lucid[i] <= n\n    ensures forall i, j :: 0 <= i < j < |lucid| ==> lucid[i] < lucid[j]\n{\n    lucid := [];\n    var i := 0;\n    while i <= n\ninvariant 0 <= i <= n + 1\ninvariant forall k :: 0 <= k < |lucid| ==> lucid[k] % 3 == 0\ninvariant forall i, j :: 0 <= i < j < |lucid| ==> lucid[i] < lucid[j]\n    {\n        if i % 3 == 0 {\n            lucid := lucid + [i];\n        }\n        i := i + 1;\n    }\n}",
            "success": false
        },
        "sat_dfy_tmp_tmpfcyj8am9_dfy_Seq.dfy": {
            "state": "module Seq {\n    function seq_sum(s: seq<int>) : (sum: int)\n    {\n        if s == [] then\n            0\n        else\n            var x := s[0];\n            var remaining := s[1..];\n            x + seq_sum(remaining)\n    }\n    lemma SeqPartsSameSum(s: seq<int>, s1: seq<int>, s2: seq<int>)\n        requires s == s1 + s2\n        ensures seq_sum(s) == seq_sum(s1) + seq_sum(s2)\n    {\n        if s == [] {\nassert multiset(s1) == multiset(s2);\nassert |s1| == |s2|;\n        } else if s1 == [] {\n        } else {\n            var x := s1[0];\n            var s1' := s1[1..];\n            SeqPartsSameSum(s[1..], s1[1..], s2);\n        }\n    }\n    lemma DifferentPermutationSameSum(s1: seq<int>, s2: seq<int>)\n        requires multiset(s1) == multiset(s2)\n        ensures seq_sum(s1) == seq_sum(s2)\n    {\n        if s1 == [] {\n        } else {\n            var x :| x in s1;\n            var i1, i2 :| 0 <= i1 < |s1| && 0 <= i2 < |s2| && s1[i1] == s2[i2] && s1[i1] == x;\nassert s1[..i1] == s1[..i1+1][1..];\nassert s1[..i1+1] == s1[..i1] + s1[i1..i1+1];\nassert s1[..i1] == s1[..i1+1][1..];\n            var remaining1 := s1[..i1] + s1[i1+1..];\n            SeqPartsSameSum(s1[..i1+1], s1[..i1], [x]);\n            SeqPartsSameSum(s1, s1[..i1+1], s1[i1+1..]);\n            SeqPartsSameSum(remaining1, s1[..i1], s1[i1+1..]);\n            var remaining2 := s2[..i2] + s2[i2+1..];\n            SeqPartsSameSum(s2[..i2+1], s2[..i2], [x]);\n            SeqPartsSameSum(s2, s2[..i2+1], s2[i2+1..]);\n            SeqPartsSameSum(remaining2, s2[..i2], s2[i2+1..]);\n            DifferentPermutationSameSum(remaining1, remaining2);\n        }\n    }\n}",
            "success": false
        },
        "online_max_strong.dfy": {
            "state": "method onlineMax(a: array<int>, x: int) returns (ghost m:int, p:int)\n  requires 1<=x<a.Length\n  requires a.Length!=0\n  ensures x<=p<a.Length\n  ensures forall i::0<=i<x==> a[i]<=m\n  ensures exists i::0<=i<x && a[i]==m\n  ensures x<=p<a.Length-1 ==> (forall i::0<=i<p ==> a[i]<a[p])\n  ensures (forall i::x<=i<a.Length && a[i]<=m) ==> p==a.Length-1\n{\n  p:= 0;\n  var best := a[0];\n  var i:=1;\n  while i<x\ninvariant x<=i<=a.Length\ninvariant forall j::x<=j<p ==> a[j]<best\ninvariant x<=i<=a.Length\ninvariant forall j::0<=j<i ==> a[j]<=best\ninvariant (forall j::x<=j<p ==> a[j]<best)\n  {\n    if a[i]>best{\n      best:=a[i];\n    }\n    i:=i+1;\n  }\n  m:=best;\n  i:=x;\n  while i<a.Length\n  {\n    if a[i]>best{\n      p:=i;\n      return;\n    }\n    i:=i+1;\n  }\n  p:=a.Length-1;\n}",
            "success": false
        },
        "cs245-verification_tmp_tmp0h_nxhqp_SortingIssues_FirstAttempt.dfy": {
            "state": "// Sorting: \n//        Pre/Post Condition Issues - An investigation \n//                                      -- Stephanie McIntyre\n// Based on examples in class \n// First Attempt at specifying requirements for sorting array A in incrementing order\n// We want our Hoare triple of (|Pre-Condition|) Code (|Post-Condition|) to hold iff A is properly sorted.\nmethod sort(A: array<int>, n: int)\nmodifies A; requires n==A.Length;\n/* Pre-Condition */   requires n>=0;            \n/* Post-Condition */  ensures forall i,j:: 0<=i<=j<n ==> A[i]<=A[j];  //This states that A is sorted.\n//Can we write code that does not sort A that still satisfies the requirements? \n//Consider the following program:\n{\nassert forall i,j::0<=i<=j<n ==> A[i]<=A[j];\n  var k := 0;\n  while(k<n)\ninvariant k<=n;\ninvariant forall i,j::0<=i<=j<=k<n ==> A[i]<=A[j];\ndecreases n-k;\n  {\n    A[k] := k;\n    k := k+1;\n  }\n}",
            "success": false
        },
        "Dafny_Verify_tmp_tmphq7j0row_AI_agent_verify_examples_ComputePower.dfy": {
            "state": "function Power(n: nat): nat {\n    if n == 0 then 1 else 2 * Power(n - 1)\n}\nmethod ComputePower(N: int) returns (y: nat) requires N >= 0\n    ensures y == Power(N)\n{\n    y := 1;\n    var x := 0; \nassert x <= N;\n    while x != N\ndecreases N - x;\ndecreases N - x\ndecreases N - x\n    {\n        x, y := x + 1, y + y;\n    } \n}",
            "success": false
        },
        "dafny-language-server_tmp_tmpkir0kenl_Test_hofs_Requires.dfy": {
            "state": "// RUN: %dafny /compile:3 /print:\"%t.print\" /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\nmethod Main()\n{\n  test0(10);\n\ttest5(11);\n\ttest6(12);\n\ttest1();\n\ttest2();\n}\npredicate valid(x:int)\n{\n  x > 0\n}\nfunction ref1(y:int) : int\n  requires valid(y);\n{\n  y - 1\n}\nlemma assumption1()\n  ensures forall a, b :: valid(a) && valid(b) && ref1(a) == ref1(b) ==> a == b;\n{\n}\nmethod test0(a: int)\n{\n  if ref1.requires(a) {\n    // the precondition should suffice to let us call the method\n    ghost var b := ref1(a);\n  }\n}\nmethod test5(a: int)\n{\n  if valid(a) {\n    // valid(a) is the precondition of ref1\n    assert ref1.requires(a);\n  }\n}\nmethod test6(a: int)\n{\n  if ref1.requires(a) {\n    // the precondition of ref1 is valid(a)\n    assert valid(a);\n  }\n}\nmethod test1()\n{\n  if * {\n    assert forall a, b :: valid(a) && valid(b) && ref1(a) == ref1(b) ==> a == b;\n  } else {\n    assert forall a, b :: ref1.requires(a) && ref1.requires(b) && ref1(a) == ref1(b)\n                          ==> a == b;\n  }\n}\nfunction {:opaque} ref2(y:int) : int        // Now with an opaque attribute\n  requires valid(y);\n{\n  y - 1\n}\nlemma assumption2()\n  ensures forall a, b :: valid(a) && valid(b) && ref2(a) == ref2(b) ==> a == b;\n{\n  reveal ref2();\n}\nmethod test2()\n{\n  assumption2();\n  if * {\n  } else {\nassert forall a, b :: ref2.requires(a) && ref2.requires(b) && ref2(a) == ref2(b)\n                          ==> a == b;\n  }\n}",
            "success": true
        },
        "Dafny-Exercises_tmp_tmpjm75muf__Session6Exercises_ExerciseCountMin.dfy": {
            "state": "function min(v:array<int>,i:int):int\ndecreases i\n reads v\n requires 1<=i<=v.Length\n ensures forall k::0<=k<i==> v[k]>=min(v,i)\n {if (i==1) then v[0]\n  else if (v[i-1]<=min(v,i-1)) then v[i-1]\n  else min(v,i-1)\n  }\nfunction countMin(v:array<int>,x:int, i:int):int\ndecreases i\n reads v\n  requires 0<=i<=v.Length\n  ensures !(x in v[0..i]) ==> countMin(v,x,i)==0\n  {\n   if (i==0) then 0\n   else if (v[i-1]==x) then 1+countMin(v,x,i-1)\n   else countMin(v,x,i-1)\n  }\n method mCountMin(v:array<int>) returns (c:int)\nrequires v.Length>0\nensures c==countMin(v,min(v,v.Length),v.Length)\n//Implement and verify an O(v.Length) algorithm \n{\n  var i:=1;\n  c:=1;\n  var mini:=v[0];\n  while(i<v.Length)\ninvariant 1 <= i <= v.Length && 1 <= c <= i\ninvariant mini==min(v,i) && c == countMin(v,mini,i)\n  {\n    if(v[i]==mini){\n      c:=c + 1;\n    }\n    else if(v[i]<mini){\n      c:=1;\n      mini:=v[i];\n    }\n    i:=i+1;\n  }\n}",
            "success": true
        },
        "Prog-Fun-Solutions_tmp_tmp7_gmnz5f_mockExam2_p5.dfy": {
            "state": "// problem 5:\n// name:      Gabriele Berardi\n// s-number: s4878728\n// table:     XXXX\nghost function f(n: int): int {\n  if n < 0 then 0 else 3*f(n-5) + n\n}\nmethod problem5(n:nat) returns (x: int)\nensures x == f(n)\n{\n    var a := 1;\n    var b := 0;\n    var k := n;\n    while k >= 0\n    {\n        b := a*k + b;\n        a := 3*a;\n        k := k - 5;\n    }\n    x := b;\n}",
            "success": false
        },
        "task_id_18.dfy": {
            "state": "method RemoveChars(s1: string, s2: string) returns (v: string)\n    ensures |v| <= |s1|\n    ensures forall i :: 0 <= i < |v| ==> (v[i] in s1) && !(v[i] in s2)\n    ensures forall i :: 0 <= i < |s1| ==> (s1[i] in s2) || (s1[i] in v)\n{\n    var v' : string := [];\n    for i := 0 to |s1|\ninvariant 0 <= i <= |s1|\ninvariant |v'| <= i\ninvariant forall i :: 0 <= i < |v'| ==> (v'[i] in s1) && !(v'[i] in s2)\ninvariant forall i :: 0 <= i <= i - 1 + |v'| ==> (s1[i] in s2) || (s1[i] in v')\n    {\n        if !(s1[i] in s2)\n        {\n            v' := v' + [s1[i]];\n        }\n    }\n    return v';\n}",
            "success": false
        },
        "specTesting_tmp_tmpueam35lx_examples_sort_sort.dfy": {
            "state": "method quickSort(intSeq:array<int>)\n    modifies intSeq\n    ensures forall i:nat, j:nat | 0 <= i <= j < intSeq.Length :: intSeq[i] <= intSeq[j]\n    // ensures multiset(intSeq[..]) == multiset(old(intSeq[..]))\nlemma sort(prevSeq:seq<int>) returns (curSeq:seq<int>)\n    ensures (forall i:nat, j:nat | 0 <= i <= j < |curSeq| :: curSeq[i] <= curSeq[j])\n    ensures multiset(prevSeq) == multiset(curSeq)\npredicate post_sort(prevSeq:seq<int>, curSeq:seq<int>)\n{\n    && (forall i:nat, j:nat | 0 <= i <= j < |curSeq| :: curSeq[i] <= curSeq[j])\n    && multiset(prevSeq) == multiset(curSeq)\n}\nlemma multisetAdditivity(m1:multiset<int>, m2:multiset<int>, m3:multiset<int>, m4:multiset<int>)\n    requires m1 == m2 + m3\n    requires m1 == m2 + m4\n    ensures m3 == m4\n    {\n    }\nlemma twoSortedSequencesWithSameElementsAreEqual(s1:seq<int>, s2:seq<int>)\n    requires (forall i:nat, j:nat | 0 <= i <= j < |s1| :: s1[i] <= s1[j])\n    requires (forall i:nat, j:nat | 0 <= i <= j < |s2| :: s2[i] <= s2[j])\n    requires multiset(s1) == multiset(s2)\n    requires |s1| == |s2|\n    ensures s1 == s2\n{\n    if (|s1| != 0) {\n        if s1[|s1|-1] == s2[|s2|-1] {\n            multisetAdditivity(multiset(s1), multiset([s1[|s1|-1]]), multiset(s1[..|s1|-1]), multiset(s2[..|s1|-1]));\n        }\n        twoSortedSequencesWithSameElementsAreEqual(s1[..|s1|-1], s2[..|s2|-1]);\n        } else if s1[|s1|-1] < s2[|s2|-1] {\n        } else {\n        }\n    }\n}\nlemma sort_determinisitc(prevSeq:seq<int>, curSeq:seq<int>, curSeq':seq<int>)\n    requires post_sort(prevSeq, curSeq)\n    requires post_sort(prevSeq, curSeq')\n    ensures curSeq == curSeq'\n{\n    if (|curSeq| != |curSeq'|) {\n    } else {\n        twoSortedSequencesWithSameElementsAreEqual(curSeq, curSeq');\n    }\n}\nlemma sort_determinisitc1(prevSeq:seq<int>, curSeq:seq<int>, curSeq':seq<int>)\n    requires prevSeq == [5,4,3,2,1]\n    requires post_sort(prevSeq, curSeq)\n    requires post_sort(prevSeq, curSeq')\n    ensures curSeq == curSeq'\n{\n}",
            "success": false
        },
        "reverse_strong.dfy": {
            "state": "method reverse(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[a.Length - 1 - i])\n{\n  var i := 0;\n  while i <a.Length / 2\ninvariant forall j, k :: 0 <= j < k < a.Length ==> a[j] == old(a[k])\ninvariant 0 <= i <= a.Length/2\ninvariant forall j :: 0 <= j < i ==> a[j] == old(a[a.Length-1-j])\ninvariant forall j :: i <= j < a.Length/2 ==> a[j] == old(a[a.Length-1-j])\ndecreases a.Length - i\n  {\n    a[i], a[a.Length-1-i] := a[a.Length-1-i], a[i];\n    i := i + 1;\n  }\n}",
            "success": false
        },
        "task_id_94.dfy": {
            "state": "method MinSecondValueFirst(s: array<seq<int>>) returns (firstOfMinSecond: int)\n    requires s.Length > 0\n    requires forall i :: 0 <= i < s.Length ==> |s[i]| >= 2\n    ensures exists i :: 0 <= i < s.Length && firstOfMinSecond == s[i][0] && \n        (forall j :: 0 <= j < s.Length ==> s[i][1] <= s[j][1])\n{\n    var minSecondIndex := 0;\n    for i := 1 to s.Length\ninvariant exists i :: 0 <= i < s.Length && s[i][0] == firstOfMinSecond && s[i][1] <= s[minSecondIndex][1]\ninvariant minSecondIndex > 0 ==> s[minSecondIndex][1] <= s[0][1]\n    {\n        if s[i][1] < s[minSecondIndex][1]\n        {\n            minSecondIndex := i;\n        }\n    }\n    firstOfMinSecond := s[minSecondIndex][0];\n}",
            "success": false
        },
        "task_id_113.dfy": {
            "state": "predicate IsDigit(c: char)\n{\n    48 <= c as int <= 57\n}\nmethod IsInteger(s: string) returns (result: bool)\n    ensures result <==> (|s| > 0) && (forall i :: 0 <= i < |s| ==> IsDigit(s[i]))\n{\n    result := true;\n    if |s| == 0 {\n        result := false;\n    } else {\n        for i := 0 to |s|\ninvariant (forall j :: 0 <= j < i ==> IsDigit(s[j]))\n        {\n            if !IsDigit(s[i]) {\n                result := false;\n                break;\n            }\n        }\n    }\n}",
            "success": true
        },
        "Final-Project-Dafny_tmp_tmpmcywuqox_Attempts_Exercise4_Find_Max.dfy": {
            "state": "method findMax(a:array<int>) returns (pos:int, maxVal: int)\n  requires a.Length > 0;\n  requires forall i :: 0 <= i < a.Length ==> a[i] >= 0;\n  ensures forall i :: 0 <= i < a.Length ==> a[i] <= maxVal;\n  ensures exists i :: 0 <= i < a.Length &&  a[i] == maxVal;\n  ensures 0 <= pos < a.Length\n  ensures a[pos] == maxVal;\n{\n  pos := 0;\n  maxVal := a[0];\n  var j := 1;\n  while(j < a.Length)\ninvariant 0 <= j <= a.Length\ninvariant 0 <= pos < j;\ninvariant exists i :: 0 <= i < j && a[i] == maxVal\ninvariant forall i :: 0 <= i < j ==> a[i] <= maxVal;\ninvariant 0 <= j <= a.Length\n  {\n    if (a[j] > maxVal) \n    {\n      maxVal := a[j];\n      pos := j;\n    }\n    j := j+1;\n  }\n  return;\n}",
            "success": false
        },
        "task_id_759.dfy": {
            "state": "method IsDecimalWithTwoPrecision(s: string) returns (result: bool)\n    ensures result ==> (exists i :: 0 <= i < |s| && s[i] == '.' && |s| - i - 1 == 2)\n    ensures !result ==> !(exists i :: 0 <= i < |s| && s[i] == '.' && |s| - i - 1 == 2)\n{\n    result := false;\n    for i := 0 to |s|\ninvariant !result ==> !(exists k :: 0 <= k < i && s[k] == '.' && |s| - k - 1 == 2)\ninvariant result ==> (exists k :: 0 <= k < i && s[k] == '.' && |s| - k - 1 == 2)\n    {\n        if s[i] == '.' && |s| - i - 1 == 2 {\n            result := true;\n            break;\n        }\n    }\n}",
            "success": true
        },
        "Dafny_tmp_tmpmvs2dmry_pancakesort_flip.dfy": {
            "state": "// flips (i.e., reverses) array elements in the range [0..num]\nmethod flip (a: array<int>, num: int)\nrequires a.Length > 0;\nrequires 0 <= num < a.Length;\nmodifies a;\nensures forall k :: 0 <= k <= num ==> a[k] == old(a[num-k])\nensures forall k :: num < k < a.Length ==> a[k] == old(a[k])\n// ensures multiset(a[..]) == old(multiset(a[..]))\n{\n  var tmp:int;\n  var i := 0;\n  var j := num;\n  while (i < j)\ninvariant forall k :: j < k < num ==> a[k] == old(a[k])\ndecreases j\ninvariant forall k :: 0 <= k <= i ==> a[k] == old(a[k])\ninvariant forall k :: num < k <= i ==> a[k] == old(a[k])\ninvariant forall k :: i <= k < j ==> a[k] == old(a[k])\n  // invariant 0 <= i < j <= num\n  {\n    tmp := a[i];\n    a[i] := a[j];\n    a[j] := tmp;\n    i := i + 1;\n    j := j - 1;\n  }\n}",
            "success": false
        },
        "is_palindrome_strong.dfy": {
            "state": "method IsPalindrome(x: seq<char>) returns (result: bool)\n  ensures result <==> (forall i :: 0 <= i < |x| ==> x[i] == x[|x| - i - 1])\n{\n  if |x|==0 {\n    return true;\n  }\n  var i := 0;\n  var j := |x| - 1;\n  result := true;\n  while (i < j)\ninvariant result <==> (forall s :: 0 <= s < i ==> x[s] == x[|x| - s - 1])\ninvariant 0 <= i <= |x|/2\ninvariant i <= j\ninvariant result <==> (forall s :: 0 <= s < i ==> x[s] == x[|x| - s - 1])\n  {\n    if x[i] != x[j] {\n      result := false;\n      return;\n    }\n    i := i + 1;\n    j := j - 1;\n  }\n}",
            "success": false
        },
        "Dafny-Exercises_tmp_tmpjm75muf__Session2Exercises_ExercisePositive.dfy": {
            "state": "predicate positive(s:seq<int>)\n{forall u::0<=u<|s| ==> s[u]>=0}\nmethod mpositive(v:array<int>) returns (b:bool)\nensures b==positive(v[0..v.Length])\n{\n    var i:=0;\n    //1. assert positive(v[..0])\n    while i<v.Length && v[i]>=0\n        decreases v.Length - i \n        invariant 0<=i<=v.Length\n        invariant positive(v[..i])\n    {\n        //2. assert 0<=i<v.Length && positive(v[..i]);\n        i:=i+1;\n        //2. assert 0<=i<v.Length && positive(v[..i]);\n    }\n    //3. assert i==v.Length ==> positive(v[..]);\n    //3. assert i<v.Length => v[i]<0;\n    b := i==v.Length;\n}\nmethod mpositive3(v:array<int>) returns (b:bool)\nensures b==positive(v[0..v.Length])\n{\n    var i:=0; b:=true;\n    while(i<v.Length && b)\n        decreases v.Length - i \n        invariant 0 <= i <= v.Length\n        invariant b==positive(v[0..i])\n        invariant !b ==> !positive(v[0..v.Length])\n    {\n        b:=v[i]>=0;\n        i:=i+1;\n    }\n}\nmethod mpositive4(v:array<int>) returns (b:bool)\nensures b==positive(v[0..v.Length])\n{\n    var i:=0; b:=true;\n    while(i<v.Length && b)\n        decreases v.Length - i \n        invariant 0 <= i <= v.Length\n        invariant b==positive(v[0..i])\n        invariant !b ==> !positive(v[0..v.Length])\n    {\n        b:=v[i]>=0;\n        i:=i+1;\n    }\n}\nmethod mpositivertl(v:array<int>) returns (b:bool)\nensures b==positive(v[0..v.Length])\n{\nassert positive(v[v.Length..v.Length]);\n    var i:=v.Length-1;\n    while(i>=0 && v[i]>=0)\ninvariant i+1>=0\ndecreases i\ndecreases v.Length -i\n    {\n        i:=i-1;\n    }\n    b:= i==-1;\n}",
            "success": false
        },
        "task_id_579.dfy": {
            "state": "predicate InArray(a: array<int>, x: int)\n    reads a\n{\n    exists i :: 0 <= i < a.Length && a[i] == x\n}\nmethod DissimilarElements(a: array<int>, b: array<int>) returns (result: seq<int>)\n    // All elements in the output are either in a or b, but not in both or neither\n    ensures forall x :: x in result ==> (InArray(a, x) != InArray(b, x))\n    // The elements in the output are all different\n    ensures forall i, j :: 0 <= i < j < |result| ==> result[i] != result[j]\n{\n    var res: seq<int> := [];\n    for i := 0 to a.Length\n    {\n        if !InArray(b, a[i]) && a[i] !in res\n        {\n            res := res + [a[i]];\n        }\n    }\n    ghost var partialSize := |res|;\nassert partialSize == |res|;\n    for i := 0 to b.Length\ninvariant 0 <= i <= b.Length\ninvariant forall k, l :: 0 <= k < l < partialSize ==> res[k] != res[l]\n    {\n        if !InArray(a, b[i]) && b[i] !in res\n        {\n            res := res + [b[i]];\n        }\n    }\n    result := res;\n}",
            "success": false
        },
        "Program-Verification-Dataset_tmp_tmpgbdrlnu__Dafny_vampire project_original_Searching.dfy": {
            "state": "// Assuming Array is Object Blood\n// Blood Array<int>\n// index\nmethod Find(blood: array<int>, key: int) returns (index: int)\nrequires blood != null\nensures 0 <= index ==> index < blood.Length && blood[index] == key\nensures index < 0 ==> forall k :: 0 <= k < blood.Length ==> blood[k] != key\n{\n   index := 0;\n   while index < blood.Length\ndecreases blood.Length - index\n   {\n      if blood[index] == key { return; }\n      index := index + 1;\n   }\n   index := -1;\n}",
            "success": false
        },
        "Dafny_Verify_tmp_tmphq7j0row_Fine_Tune_Examples_normal_data_completion_MaxPerdV2.dfy": {
            "state": "function contains(v: int, a: array<int>, n: int): bool\nreads a\n  requires n <= a.Length\n{\n  exists j :: 0 <= j < n && a[j] == v\n}\nfunction upper_bound(v: int, a: array<int>, n: int): bool\nreads a\n  requires n <= a.Length\n{\n  forall j :: 0 <= j < n ==> a[j] <= v\n}\nfunction is_max(m: int, a: array<int>, n: int): bool\nreads a\n  requires n <= a.Length\n{\n  contains(m, a, n) && upper_bound(m, a, n)\n}\nmethod max(a: array<int>, n: int) returns (max: int)\n  requires 0 < n <= a.Length;\n  ensures is_max(max, a, n);\n{\n  var i: int := 1;\n  max := a[0];\n  while i < n\ninvariant 1 <= i <= n\ninvariant is_max(max, a, i)\n  {\n    if a[i] > max {\n      max := a[i];\n    }\n    i := i + 1;\n  }\n}",
            "success": true
        },
        "count_lessthan_strong.dfy": {
            "state": "method CountLessThan(numbers: set<int>, threshold: int) returns (count: int)\n  ensures count == |set i | i in numbers && i < threshold|\n{\n  count := 0;\n  var shrink := numbers;\n  var grow := {};\n  while |shrink | > 0\n  {\n    var i: int :| i in shrink;\n    shrink := shrink - {i};\n    var grow' := grow+{i};\n           (set i | i in grow && i < threshold )+ if i < threshold then {i} else {};\n    grow := grow + {i};\n    if i < threshold {\n      count := count + 1;\n    }\n  }\n}",
            "success": false
        },
        "Metodos_Formais_tmp_tmpql2hwcsh_Invariantes_multiplicador.dfy": {
            "state": "// Exemplo de invariantes\n// Invariante significa que o valor n\u00e3o muda desde a pr\u00e9-condi\u00e7\u00e3o at\u00e9 a p\u00f3s-condi\u00e7\u00e3o\nmethod Mult(x:nat, y:nat) returns (r:nat)\nensures r == x * y\n{\n    // par\u00e2metros de entrada s\u00e3o imut\u00e1veis, por isso\n    // \u00e9 preciso a atribuir a vari\u00e1veis locais para usar em blocos de c\u00f3digos para mudar\n    var m := x;\n    var n := y;\nassert  n == 3;\n    r := 0;\n    while m > 0 \ndecreases m // declara em que condi\u00e7\u00f5es m deixa de existir\ndecreases m // declara que m deixa de existir\ninvariant m >= 0 //invariante que deve ter nada a ver com a f\u00f3rmula dela\ninvariant r == m * n + r //invariante que requer\n    {\n        r := r + n;\n        m := m -1;\n    }\n    return r;\n}\n// Teste do m\u00e9todo para encontrar a invariante\n// x | y | m | n | r\n// 5 | 3 | 5 | 3 | 0\n// 5 | 3 | 4 | 3 | 3\n// 5 | 3 | 3 | 3 | 6\n// 5 | 3 | 2 | 3 | 9\n// 5 | 3 | 1 | 3 | 12\n// 5 | 3 | 0 | 3 | 15\n// vimos o seguinte:\n// m * n + r = x * y\n// 5 * 3 + 0 (15) = 5 * 3 (15)\n// portanto a f\u00f3rmula m*n+r == x*y \u00e9 uma invariante\n// mas s\u00f3 isso n\u00e3o serve, o m ele \u00e9 maior ou igual a zero quando acaba o while\n// por isso, tamb\u00e9m \u00e9 a invariante que necessita\n// com isso dizemos para o programa as altera\u00e7\u00f5es do m de maior ou igual a zero\n// e mostramos a fun\u00e7\u00e3o encontrada que alterava o valor de m e n das variaveis criadas\n// SE OS ALGORITMOS TIVEREM REPETI\u00c7\u00c3O OU RECURS\u00c3O, DEVEM SER MOSTRADOS QUAIS S\u00c3O AS INVARIANTES\n// OU SEJA, OS VALORES QUE N\u00c3O EST\u00c3O SENDO MUDADOS E COLOCAR A F\u00d3RMULA DELE COMO ACIMA",
            "success": false
        },
        "t1_MF_tmp_tmpi_sqie4j_exemplos_introducao_ex4.dfy": {
            "state": "function Fat(n: nat): nat\n{\n   if n == 0 then 1 else n * Fat(n-1)\n}\nmethod Fatorial(n:nat)  returns (r:nat)\n  ensures r == Fat(n)\n{\n    r := 1;\n    var i := 0;\nassert 0 <= i <= n && 1 <= r <= Fat(n);\n    while i < n\ndecreases n\ninvariant i == 0 ==> r == 1\ndecreases n - i\ninvariant 0 <= i <= n && 1 <= r <= Fat(n)\n    {\n        i := i + 1;\n        r := r * i;\n    }\n}",
            "success": false
        },
        "HATRA-2022-Paper_tmp_tmp5texxy8l_copilot_verification_Two Sum_two_sum.dfy": {
            "state": "method twoSum(nums: array<int>, target: int) returns (index1: int, index2: int)\n    requires 2 <= nums.Length\n    requires exists i, j :: (0 <= i < j < nums.Length && nums[i] + nums[j] == target)\n    ensures index1 != index2\n    ensures 0 <= index1 < nums.Length\n    ensures 0 <= index2 < nums.Length\n    ensures nums[index1] + nums[index2] == target\n{\n    var i := 0;\n    while i < nums.Length\ninvariant forall k :: i <= k < nums.Length ==> nums[i] + nums[k] != target\n    {\n        var j := i + 1;\n        while j < nums.Length\ninvariant exists k :: 0 <= k < j && nums[k] == nums[j - 1]\ninvariant 0 <= j <= nums.Length\ninvariant nums[i] + nums[j] != target\ninvariant exists k :: i <= k < nums.Length && nums[i] + nums[k] == target\n        {\n            if nums[i] + nums[j] == target\n            {\n                return i, j;\n            } \n            j := j + 1;\n        }\n        i := i + 1;\n    }\n}",
            "success": false
        },
        "task_id_793.dfy": {
            "state": "method LastPosition(arr: array<int>, elem: int) returns (pos: int)\n    requires arr.Length > 0\n    requires forall i, j :: 0 <= i < j < arr.Length ==> arr[i] <= arr[j]\n    ensures pos == -1 || (0 <= pos < arr.Length && arr[pos] == elem && (pos <= arr.Length - 1 || arr[pos + 1] > elem))\n    ensures forall i :: 0 <= i < arr.Length ==> arr[i] == old(arr[i])\n{\n    pos := -1;\n    for i := 0 to arr.Length - 1\ninvariant pos == -1 || (0 <= pos < arr.Length && arr[pos] == elem && (pos <= i || arr[i] > elem))\n    {\n        if arr[i] == elem\n        {\n            pos := i;\n        }\n    }\n}",
            "success": true
        },
        "dafny-language-server_tmp_tmpkir0kenl_Test_vstte2012_Two-Way-Sort.dfy": {
            "state": "// RUN: %dafny /compile:0 /dprint:\"%t.dprint\" \"%s\" > \"%t\"\n// RUN: %diff \"%s.expect\" \"%t\"\n// This method is a slight generalization of the\n// code provided in the problem statement since it\n// is generic in the type of the array elements.\nmethod swap<T>(a: array<T>, i: int, j: int)\n  requires 0 <= i < j < a.Length\n  modifies a\n  ensures a[i] == old(a[j])\n  ensures a[j] == old(a[i])\n  ensures forall m :: 0 <= m < a.Length && m != i && m != j ==> a[m] == old(a[m])\n  ensures multiset(a[..]) == old(multiset(a[..]))\n{\n  var t := a[i];\n  a[i] := a[j];\n  a[j] := t;\n}\n// This method is a direct translation of the pseudo\n// code given in the problem statement.\n// The first postcondition expresses that the resulting\n// array is sorted, that is, all occurrences of \"false\"\n// come before all occurrences of \"true\".\n// The second postcondition expresses that the post-state\n// array is a permutation of the pre-state array. To express\n// this, we use Dafny's built-in multisets. The built-in\n// function \"multiset\" takes an array and yields the\n// multiset of the array elements.\n// Note that Dafny guesses a suitable ranking function\n// for the termination proof of the while loop.\n// We use the loop guard from the given pseudo-code.  However,\n// the program also verifies with the stronger guard \"i < j\"\n// (without changing any of the other specifications or\n// annotations).\nmethod two_way_sort(a: array<bool>)\n  modifies a\n  ensures forall m,n :: 0 <= m < n < a.Length ==> (!a[m] || a[n])\n  ensures multiset(a[..]) == old(multiset(a[..]))\n{\n  var i := 0;\n  var j := a.Length - 1;\n  while (i <= j)\ninvariant i + j == a.Length - 1 // loop invariant\ninvariant forall m,n :: 0 <= m < n < j ==> (!a[m] || a[n])\ninvariant forall m :: 0 <= m < i ==> a[m]\ndecreases j - i // termination proof starts here\ninvariant multiset(a[..]) == old(multiset(a[..]))\n  {\n    if (!a[i]) {\n      i := i+1;\n    } else if (a[j]) {\n      j := j-1;\n    } else {\n      swap(a, i, j);\n      i := i+1;\n      j := j-1;\n    }\n  }\n}",
            "success": false
        }
    }
]