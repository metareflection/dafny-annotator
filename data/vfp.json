[{"id": "example_binarySearchCorrect_0", "type": "call", "program": "predicate {:spec} sorted(s: seq<int>)\n{\n  forall i, j :: 0 <= i < j < |s| ==> s[i] <= s[j]\n}\n\nfunction binarySearch(s: seq<int>, key: int): int\n  requires sorted(s)\n{\n  binarySearchHelper(s, key, 0, |s|)\n}\n\nfunction binarySearchHelper(s: seq<int>, key: int, lo: int, hi: int): int\n  requires 0 <= lo <= hi <= |s|\n  requires sorted(s)\n  decreases hi - lo\n{\n  if lo >= hi then |s|\n  else\n    var mid := lo + (hi - lo) / 2;\n    if s[mid] == key then mid\n    else if s[mid] > key then binarySearchHelper(s, key, lo, mid)\n    else binarySearchHelper(s, key, mid + 1, hi)\n}\n\nlemma binarySearchCorrect(s: seq<int>, key: int)\n  requires sorted(s)\n  ensures var idx := binarySearch(s, key);\n    0 <= idx <= |s| &&\n    (idx < |s| ==> s[idx] == key) &&\n    (idx == |s| ==> key !in s)\n{\n  \n/*[CODE HERE]*/\n}\n\nlemma binarySearchHelperCorrect(s: seq<int>, key: int, lo: int, hi: int)\n  requires 0 <= lo <= hi <= |s|\n  requires sorted(s)\n  ensures var idx := binarySearchHelper(s, key, lo, hi);\n    0 <= idx <= |s| &&\n    (idx < |s| ==> s[idx] == key) &&\n    (idx == |s| ==> (forall i :: lo <= i < hi ==> s[i] != key))\n  decreases hi - lo\n{\n  if lo >= hi {\n  } else {\n    var mid := lo + (hi - lo) / 2;\n    if s[mid] == key {\n    } else if s[mid] > key {\n      binarySearchHelperCorrect(s, key, lo, mid);\n      var idx := binarySearchHelper(s, key, lo, mid);\n      if idx == |s| {\n        forall i | mid <= i < hi\n          ensures s[i] != key\n        {\n          assert s[mid] > key;\n          assert sorted(s);\n          assert s[i] >= s[mid];\n          assert s[i] > key;\n        }\n      }\n    } else {\n      binarySearchHelperCorrect(s, key, mid + 1, hi);\n      var idx := binarySearchHelper(s, key, mid + 1, hi);\n      if idx == |s| {\n        forall i | lo <= i <= mid\n          ensures s[i] != key\n        {\n          assert s[mid] < key;\n          assert sorted(s);\n          assert s[i] <= s[mid];\n          assert s[i] < key;\n        }\n      }\n    }\n  }\n}", "output": "binarySearchHelperCorrect(s, key, 0, |s|);"}, {"id": "example_binarySearchHelperCorrect_0", "type": "assert", "program": "predicate {:spec} sorted(s: seq<int>)\n{\n  forall i, j :: 0 <= i < j < |s| ==> s[i] <= s[j]\n}\n\nfunction binarySearch(s: seq<int>, key: int): int\n  requires sorted(s)\n{\n  binarySearchHelper(s, key, 0, |s|)\n}\n\nfunction binarySearchHelper(s: seq<int>, key: int, lo: int, hi: int): int\n  requires 0 <= lo <= hi <= |s|\n  requires sorted(s)\n  decreases hi - lo\n{\n  if lo >= hi then |s|\n  else\n    var mid := lo + (hi - lo) / 2;\n    if s[mid] == key then mid\n    else if s[mid] > key then binarySearchHelper(s, key, lo, mid)\n    else binarySearchHelper(s, key, mid + 1, hi)\n}\n\nlemma binarySearchCorrect(s: seq<int>, key: int)\n  requires sorted(s)\n  ensures var idx := binarySearch(s, key);\n    0 <= idx <= |s| &&\n    (idx < |s| ==> s[idx] == key) &&\n    (idx == |s| ==> key !in s)\n{\n  binarySearchHelperCorrect(s, key, 0, |s|);\n}\n\nlemma binarySearchHelperCorrect(s: seq<int>, key: int, lo: int, hi: int)\n  requires 0 <= lo <= hi <= |s|\n  requires sorted(s)\n  ensures var idx := binarySearchHelper(s, key, lo, hi);\n    0 <= idx <= |s| &&\n    (idx < |s| ==> s[idx] == key) &&\n    (idx == |s| ==> (forall i :: lo <= i < hi ==> s[i] != key))\n  decreases hi - lo\n{\n  if lo >= hi {\n  } else {\n    var mid := lo + (hi - lo) / 2;\n    if s[mid] == key {\n    } else if s[mid] > key {\n      binarySearchHelperCorrect(s, key, lo, mid);\n      var idx := binarySearchHelper(s, key, lo, mid);\n      if idx == |s| {\n        forall i | mid <= i < hi\n          ensures s[i] != key\n        {\n          assert s[mid] > key;\n          assert sorted(s);\n          assert s[i] >= s[mid];\n          assert s[i] > key;\n        }\n      }\n    } else {\n      binarySearchHelperCorrect(s, key, mid + 1, hi);\n      var idx := binarySearchHelper(s, key, mid + 1, hi);\n      if idx == |s| {\n        forall i | lo <= i <= mid\n          ensures s[i] != key\n        {\n          assert s[mid] < key;\n          assert sorted(s);\n          assert s[i] <= s[mid];\n          \n/*[CODE HERE]*/\n        }\n      }\n    }\n  }\n}", "output": "assert s[i] < key;"}, {"id": "example_binarySearchHelperCorrect_1", "type": "assert", "program": "predicate {:spec} sorted(s: seq<int>)\n{\n  forall i, j :: 0 <= i < j < |s| ==> s[i] <= s[j]\n}\n\nfunction binarySearch(s: seq<int>, key: int): int\n  requires sorted(s)\n{\n  binarySearchHelper(s, key, 0, |s|)\n}\n\nfunction binarySearchHelper(s: seq<int>, key: int, lo: int, hi: int): int\n  requires 0 <= lo <= hi <= |s|\n  requires sorted(s)\n  decreases hi - lo\n{\n  if lo >= hi then |s|\n  else\n    var mid := lo + (hi - lo) / 2;\n    if s[mid] == key then mid\n    else if s[mid] > key then binarySearchHelper(s, key, lo, mid)\n    else binarySearchHelper(s, key, mid + 1, hi)\n}\n\nlemma binarySearchCorrect(s: seq<int>, key: int)\n  requires sorted(s)\n  ensures var idx := binarySearch(s, key);\n    0 <= idx <= |s| &&\n    (idx < |s| ==> s[idx] == key) &&\n    (idx == |s| ==> key !in s)\n{\n  binarySearchHelperCorrect(s, key, 0, |s|);\n}\n\nlemma binarySearchHelperCorrect(s: seq<int>, key: int, lo: int, hi: int)\n  requires 0 <= lo <= hi <= |s|\n  requires sorted(s)\n  ensures var idx := binarySearchHelper(s, key, lo, hi);\n    0 <= idx <= |s| &&\n    (idx < |s| ==> s[idx] == key) &&\n    (idx == |s| ==> (forall i :: lo <= i < hi ==> s[i] != key))\n  decreases hi - lo\n{\n  if lo >= hi {\n  } else {\n    var mid := lo + (hi - lo) / 2;\n    if s[mid] == key {\n    } else if s[mid] > key {\n      binarySearchHelperCorrect(s, key, lo, mid);\n      var idx := binarySearchHelper(s, key, lo, mid);\n      if idx == |s| {\n        forall i | mid <= i < hi\n          ensures s[i] != key\n        {\n          assert s[mid] > key;\n          assert sorted(s);\n          assert s[i] >= s[mid];\n          assert s[i] > key;\n        }\n      }\n    } else {\n      binarySearchHelperCorrect(s, key, mid + 1, hi);\n      var idx := binarySearchHelper(s, key, mid + 1, hi);\n      if idx == |s| {\n        forall i | lo <= i <= mid\n          ensures s[i] != key\n        {\n          assert s[mid] < key;\n          assert sorted(s);\n          \n/*[CODE HERE]*/\n          assert s[i] < key;\n        }\n      }\n    }\n  }\n}", "output": "assert s[i] <= s[mid];"}, {"id": "example_binarySearchHelperCorrect_2", "type": "assert", "program": "predicate {:spec} sorted(s: seq<int>)\n{\n  forall i, j :: 0 <= i < j < |s| ==> s[i] <= s[j]\n}\n\nfunction binarySearch(s: seq<int>, key: int): int\n  requires sorted(s)\n{\n  binarySearchHelper(s, key, 0, |s|)\n}\n\nfunction binarySearchHelper(s: seq<int>, key: int, lo: int, hi: int): int\n  requires 0 <= lo <= hi <= |s|\n  requires sorted(s)\n  decreases hi - lo\n{\n  if lo >= hi then |s|\n  else\n    var mid := lo + (hi - lo) / 2;\n    if s[mid] == key then mid\n    else if s[mid] > key then binarySearchHelper(s, key, lo, mid)\n    else binarySearchHelper(s, key, mid + 1, hi)\n}\n\nlemma binarySearchCorrect(s: seq<int>, key: int)\n  requires sorted(s)\n  ensures var idx := binarySearch(s, key);\n    0 <= idx <= |s| &&\n    (idx < |s| ==> s[idx] == key) &&\n    (idx == |s| ==> key !in s)\n{\n  binarySearchHelperCorrect(s, key, 0, |s|);\n}\n\nlemma binarySearchHelperCorrect(s: seq<int>, key: int, lo: int, hi: int)\n  requires 0 <= lo <= hi <= |s|\n  requires sorted(s)\n  ensures var idx := binarySearchHelper(s, key, lo, hi);\n    0 <= idx <= |s| &&\n    (idx < |s| ==> s[idx] == key) &&\n    (idx == |s| ==> (forall i :: lo <= i < hi ==> s[i] != key))\n  decreases hi - lo\n{\n  if lo >= hi {\n  } else {\n    var mid := lo + (hi - lo) / 2;\n    if s[mid] == key {\n    } else if s[mid] > key {\n      binarySearchHelperCorrect(s, key, lo, mid);\n      var idx := binarySearchHelper(s, key, lo, mid);\n      if idx == |s| {\n        forall i | mid <= i < hi\n          ensures s[i] != key\n        {\n          assert s[mid] > key;\n          assert sorted(s);\n          assert s[i] >= s[mid];\n          assert s[i] > key;\n        }\n      }\n    } else {\n      binarySearchHelperCorrect(s, key, mid + 1, hi);\n      var idx := binarySearchHelper(s, key, mid + 1, hi);\n      if idx == |s| {\n        forall i | lo <= i <= mid\n          ensures s[i] != key\n        {\n          assert s[mid] < key;\n          \n/*[CODE HERE]*/\n          assert s[i] <= s[mid];\n          assert s[i] < key;\n        }\n      }\n    }\n  }\n}", "output": "assert sorted(s);"}, {"id": "example_binarySearchHelperCorrect_3", "type": "assert", "program": "predicate {:spec} sorted(s: seq<int>)\n{\n  forall i, j :: 0 <= i < j < |s| ==> s[i] <= s[j]\n}\n\nfunction binarySearch(s: seq<int>, key: int): int\n  requires sorted(s)\n{\n  binarySearchHelper(s, key, 0, |s|)\n}\n\nfunction binarySearchHelper(s: seq<int>, key: int, lo: int, hi: int): int\n  requires 0 <= lo <= hi <= |s|\n  requires sorted(s)\n  decreases hi - lo\n{\n  if lo >= hi then |s|\n  else\n    var mid := lo + (hi - lo) / 2;\n    if s[mid] == key then mid\n    else if s[mid] > key then binarySearchHelper(s, key, lo, mid)\n    else binarySearchHelper(s, key, mid + 1, hi)\n}\n\nlemma binarySearchCorrect(s: seq<int>, key: int)\n  requires sorted(s)\n  ensures var idx := binarySearch(s, key);\n    0 <= idx <= |s| &&\n    (idx < |s| ==> s[idx] == key) &&\n    (idx == |s| ==> key !in s)\n{\n  binarySearchHelperCorrect(s, key, 0, |s|);\n}\n\nlemma binarySearchHelperCorrect(s: seq<int>, key: int, lo: int, hi: int)\n  requires 0 <= lo <= hi <= |s|\n  requires sorted(s)\n  ensures var idx := binarySearchHelper(s, key, lo, hi);\n    0 <= idx <= |s| &&\n    (idx < |s| ==> s[idx] == key) &&\n    (idx == |s| ==> (forall i :: lo <= i < hi ==> s[i] != key))\n  decreases hi - lo\n{\n  if lo >= hi {\n  } else {\n    var mid := lo + (hi - lo) / 2;\n    if s[mid] == key {\n    } else if s[mid] > key {\n      binarySearchHelperCorrect(s, key, lo, mid);\n      var idx := binarySearchHelper(s, key, lo, mid);\n      if idx == |s| {\n        forall i | mid <= i < hi\n          ensures s[i] != key\n        {\n          assert s[mid] > key;\n          assert sorted(s);\n          assert s[i] >= s[mid];\n          assert s[i] > key;\n        }\n      }\n    } else {\n      binarySearchHelperCorrect(s, key, mid + 1, hi);\n      var idx := binarySearchHelper(s, key, mid + 1, hi);\n      if idx == |s| {\n        forall i | lo <= i <= mid\n          ensures s[i] != key\n        {\n          \n/*[CODE HERE]*/\n          assert sorted(s);\n          assert s[i] <= s[mid];\n          assert s[i] < key;\n        }\n      }\n    }\n  }\n}", "output": "assert s[mid] < key;"}, {"id": "example_binarySearchHelperCorrect_4", "type": "call", "program": "predicate {:spec} sorted(s: seq<int>)\n{\n  forall i, j :: 0 <= i < j < |s| ==> s[i] <= s[j]\n}\n\nfunction binarySearch(s: seq<int>, key: int): int\n  requires sorted(s)\n{\n  binarySearchHelper(s, key, 0, |s|)\n}\n\nfunction binarySearchHelper(s: seq<int>, key: int, lo: int, hi: int): int\n  requires 0 <= lo <= hi <= |s|\n  requires sorted(s)\n  decreases hi - lo\n{\n  if lo >= hi then |s|\n  else\n    var mid := lo + (hi - lo) / 2;\n    if s[mid] == key then mid\n    else if s[mid] > key then binarySearchHelper(s, key, lo, mid)\n    else binarySearchHelper(s, key, mid + 1, hi)\n}\n\nlemma binarySearchCorrect(s: seq<int>, key: int)\n  requires sorted(s)\n  ensures var idx := binarySearch(s, key);\n    0 <= idx <= |s| &&\n    (idx < |s| ==> s[idx] == key) &&\n    (idx == |s| ==> key !in s)\n{\n  binarySearchHelperCorrect(s, key, 0, |s|);\n}\n\nlemma binarySearchHelperCorrect(s: seq<int>, key: int, lo: int, hi: int)\n  requires 0 <= lo <= hi <= |s|\n  requires sorted(s)\n  ensures var idx := binarySearchHelper(s, key, lo, hi);\n    0 <= idx <= |s| &&\n    (idx < |s| ==> s[idx] == key) &&\n    (idx == |s| ==> (forall i :: lo <= i < hi ==> s[i] != key))\n  decreases hi - lo\n{\n  if lo >= hi {\n  } else {\n    var mid := lo + (hi - lo) / 2;\n    if s[mid] == key {\n    } else if s[mid] > key {\n      binarySearchHelperCorrect(s, key, lo, mid);\n      var idx := binarySearchHelper(s, key, lo, mid);\n      if idx == |s| {\n        forall i | mid <= i < hi\n          ensures s[i] != key\n        {\n          assert s[mid] > key;\n          assert sorted(s);\n          assert s[i] >= s[mid];\n          assert s[i] > key;\n        }\n      }\n    } else {\n      \n/*[CODE HERE]*/\n      var idx := binarySearchHelper(s, key, mid + 1, hi);\n      if idx == |s| {\n        forall i | lo <= i <= mid\n          ensures s[i] != key\n        {\n          assert s[mid] < key;\n          assert sorted(s);\n          assert s[i] <= s[mid];\n          assert s[i] < key;\n        }\n      }\n    }\n  }\n}", "output": "binarySearchHelperCorrect(s, key, mid + 1, hi);"}, {"id": "example_binarySearchHelperCorrect_5", "type": "assert", "program": "predicate {:spec} sorted(s: seq<int>)\n{\n  forall i, j :: 0 <= i < j < |s| ==> s[i] <= s[j]\n}\n\nfunction binarySearch(s: seq<int>, key: int): int\n  requires sorted(s)\n{\n  binarySearchHelper(s, key, 0, |s|)\n}\n\nfunction binarySearchHelper(s: seq<int>, key: int, lo: int, hi: int): int\n  requires 0 <= lo <= hi <= |s|\n  requires sorted(s)\n  decreases hi - lo\n{\n  if lo >= hi then |s|\n  else\n    var mid := lo + (hi - lo) / 2;\n    if s[mid] == key then mid\n    else if s[mid] > key then binarySearchHelper(s, key, lo, mid)\n    else binarySearchHelper(s, key, mid + 1, hi)\n}\n\nlemma binarySearchCorrect(s: seq<int>, key: int)\n  requires sorted(s)\n  ensures var idx := binarySearch(s, key);\n    0 <= idx <= |s| &&\n    (idx < |s| ==> s[idx] == key) &&\n    (idx == |s| ==> key !in s)\n{\n  binarySearchHelperCorrect(s, key, 0, |s|);\n}\n\nlemma binarySearchHelperCorrect(s: seq<int>, key: int, lo: int, hi: int)\n  requires 0 <= lo <= hi <= |s|\n  requires sorted(s)\n  ensures var idx := binarySearchHelper(s, key, lo, hi);\n    0 <= idx <= |s| &&\n    (idx < |s| ==> s[idx] == key) &&\n    (idx == |s| ==> (forall i :: lo <= i < hi ==> s[i] != key))\n  decreases hi - lo\n{\n  if lo >= hi {\n  } else {\n    var mid := lo + (hi - lo) / 2;\n    if s[mid] == key {\n    } else if s[mid] > key {\n      binarySearchHelperCorrect(s, key, lo, mid);\n      var idx := binarySearchHelper(s, key, lo, mid);\n      if idx == |s| {\n        forall i | mid <= i < hi\n          ensures s[i] != key\n        {\n          assert s[mid] > key;\n          assert sorted(s);\n          assert s[i] >= s[mid];\n          \n/*[CODE HERE]*/\n        }\n      }\n    } else {\n      binarySearchHelperCorrect(s, key, mid + 1, hi);\n      var idx := binarySearchHelper(s, key, mid + 1, hi);\n      if idx == |s| {\n        forall i | lo <= i <= mid\n          ensures s[i] != key\n        {\n          assert s[mid] < key;\n          assert sorted(s);\n          assert s[i] <= s[mid];\n          assert s[i] < key;\n        }\n      }\n    }\n  }\n}", "output": "assert s[i] > key;"}, {"id": "example_binarySearchHelperCorrect_6", "type": "assert", "program": "predicate {:spec} sorted(s: seq<int>)\n{\n  forall i, j :: 0 <= i < j < |s| ==> s[i] <= s[j]\n}\n\nfunction binarySearch(s: seq<int>, key: int): int\n  requires sorted(s)\n{\n  binarySearchHelper(s, key, 0, |s|)\n}\n\nfunction binarySearchHelper(s: seq<int>, key: int, lo: int, hi: int): int\n  requires 0 <= lo <= hi <= |s|\n  requires sorted(s)\n  decreases hi - lo\n{\n  if lo >= hi then |s|\n  else\n    var mid := lo + (hi - lo) / 2;\n    if s[mid] == key then mid\n    else if s[mid] > key then binarySearchHelper(s, key, lo, mid)\n    else binarySearchHelper(s, key, mid + 1, hi)\n}\n\nlemma binarySearchCorrect(s: seq<int>, key: int)\n  requires sorted(s)\n  ensures var idx := binarySearch(s, key);\n    0 <= idx <= |s| &&\n    (idx < |s| ==> s[idx] == key) &&\n    (idx == |s| ==> key !in s)\n{\n  binarySearchHelperCorrect(s, key, 0, |s|);\n}\n\nlemma binarySearchHelperCorrect(s: seq<int>, key: int, lo: int, hi: int)\n  requires 0 <= lo <= hi <= |s|\n  requires sorted(s)\n  ensures var idx := binarySearchHelper(s, key, lo, hi);\n    0 <= idx <= |s| &&\n    (idx < |s| ==> s[idx] == key) &&\n    (idx == |s| ==> (forall i :: lo <= i < hi ==> s[i] != key))\n  decreases hi - lo\n{\n  if lo >= hi {\n  } else {\n    var mid := lo + (hi - lo) / 2;\n    if s[mid] == key {\n    } else if s[mid] > key {\n      binarySearchHelperCorrect(s, key, lo, mid);\n      var idx := binarySearchHelper(s, key, lo, mid);\n      if idx == |s| {\n        forall i | mid <= i < hi\n          ensures s[i] != key\n        {\n          assert s[mid] > key;\n          assert sorted(s);\n          \n/*[CODE HERE]*/\n          assert s[i] > key;\n        }\n      }\n    } else {\n      binarySearchHelperCorrect(s, key, mid + 1, hi);\n      var idx := binarySearchHelper(s, key, mid + 1, hi);\n      if idx == |s| {\n        forall i | lo <= i <= mid\n          ensures s[i] != key\n        {\n          assert s[mid] < key;\n          assert sorted(s);\n          assert s[i] <= s[mid];\n          assert s[i] < key;\n        }\n      }\n    }\n  }\n}", "output": "assert s[i] >= s[mid];"}, {"id": "example_binarySearchHelperCorrect_7", "type": "assert", "program": "predicate {:spec} sorted(s: seq<int>)\n{\n  forall i, j :: 0 <= i < j < |s| ==> s[i] <= s[j]\n}\n\nfunction binarySearch(s: seq<int>, key: int): int\n  requires sorted(s)\n{\n  binarySearchHelper(s, key, 0, |s|)\n}\n\nfunction binarySearchHelper(s: seq<int>, key: int, lo: int, hi: int): int\n  requires 0 <= lo <= hi <= |s|\n  requires sorted(s)\n  decreases hi - lo\n{\n  if lo >= hi then |s|\n  else\n    var mid := lo + (hi - lo) / 2;\n    if s[mid] == key then mid\n    else if s[mid] > key then binarySearchHelper(s, key, lo, mid)\n    else binarySearchHelper(s, key, mid + 1, hi)\n}\n\nlemma binarySearchCorrect(s: seq<int>, key: int)\n  requires sorted(s)\n  ensures var idx := binarySearch(s, key);\n    0 <= idx <= |s| &&\n    (idx < |s| ==> s[idx] == key) &&\n    (idx == |s| ==> key !in s)\n{\n  binarySearchHelperCorrect(s, key, 0, |s|);\n}\n\nlemma binarySearchHelperCorrect(s: seq<int>, key: int, lo: int, hi: int)\n  requires 0 <= lo <= hi <= |s|\n  requires sorted(s)\n  ensures var idx := binarySearchHelper(s, key, lo, hi);\n    0 <= idx <= |s| &&\n    (idx < |s| ==> s[idx] == key) &&\n    (idx == |s| ==> (forall i :: lo <= i < hi ==> s[i] != key))\n  decreases hi - lo\n{\n  if lo >= hi {\n  } else {\n    var mid := lo + (hi - lo) / 2;\n    if s[mid] == key {\n    } else if s[mid] > key {\n      binarySearchHelperCorrect(s, key, lo, mid);\n      var idx := binarySearchHelper(s, key, lo, mid);\n      if idx == |s| {\n        forall i | mid <= i < hi\n          ensures s[i] != key\n        {\n          assert s[mid] > key;\n          \n/*[CODE HERE]*/\n          assert s[i] >= s[mid];\n          assert s[i] > key;\n        }\n      }\n    } else {\n      binarySearchHelperCorrect(s, key, mid + 1, hi);\n      var idx := binarySearchHelper(s, key, mid + 1, hi);\n      if idx == |s| {\n        forall i | lo <= i <= mid\n          ensures s[i] != key\n        {\n          assert s[mid] < key;\n          assert sorted(s);\n          assert s[i] <= s[mid];\n          assert s[i] < key;\n        }\n      }\n    }\n  }\n}", "output": "assert sorted(s);"}, {"id": "example_binarySearchHelperCorrect_8", "type": "assert", "program": "predicate {:spec} sorted(s: seq<int>)\n{\n  forall i, j :: 0 <= i < j < |s| ==> s[i] <= s[j]\n}\n\nfunction binarySearch(s: seq<int>, key: int): int\n  requires sorted(s)\n{\n  binarySearchHelper(s, key, 0, |s|)\n}\n\nfunction binarySearchHelper(s: seq<int>, key: int, lo: int, hi: int): int\n  requires 0 <= lo <= hi <= |s|\n  requires sorted(s)\n  decreases hi - lo\n{\n  if lo >= hi then |s|\n  else\n    var mid := lo + (hi - lo) / 2;\n    if s[mid] == key then mid\n    else if s[mid] > key then binarySearchHelper(s, key, lo, mid)\n    else binarySearchHelper(s, key, mid + 1, hi)\n}\n\nlemma binarySearchCorrect(s: seq<int>, key: int)\n  requires sorted(s)\n  ensures var idx := binarySearch(s, key);\n    0 <= idx <= |s| &&\n    (idx < |s| ==> s[idx] == key) &&\n    (idx == |s| ==> key !in s)\n{\n  binarySearchHelperCorrect(s, key, 0, |s|);\n}\n\nlemma binarySearchHelperCorrect(s: seq<int>, key: int, lo: int, hi: int)\n  requires 0 <= lo <= hi <= |s|\n  requires sorted(s)\n  ensures var idx := binarySearchHelper(s, key, lo, hi);\n    0 <= idx <= |s| &&\n    (idx < |s| ==> s[idx] == key) &&\n    (idx == |s| ==> (forall i :: lo <= i < hi ==> s[i] != key))\n  decreases hi - lo\n{\n  if lo >= hi {\n  } else {\n    var mid := lo + (hi - lo) / 2;\n    if s[mid] == key {\n    } else if s[mid] > key {\n      binarySearchHelperCorrect(s, key, lo, mid);\n      var idx := binarySearchHelper(s, key, lo, mid);\n      if idx == |s| {\n        forall i | mid <= i < hi\n          ensures s[i] != key\n        {\n          \n/*[CODE HERE]*/\n          assert sorted(s);\n          assert s[i] >= s[mid];\n          assert s[i] > key;\n        }\n      }\n    } else {\n      binarySearchHelperCorrect(s, key, mid + 1, hi);\n      var idx := binarySearchHelper(s, key, mid + 1, hi);\n      if idx == |s| {\n        forall i | lo <= i <= mid\n          ensures s[i] != key\n        {\n          assert s[mid] < key;\n          assert sorted(s);\n          assert s[i] <= s[mid];\n          assert s[i] < key;\n        }\n      }\n    }\n  }\n}", "output": "assert s[mid] > key;"}, {"id": "example_binarySearchHelperCorrect_9", "type": "call", "program": "predicate {:spec} sorted(s: seq<int>)\n{\n  forall i, j :: 0 <= i < j < |s| ==> s[i] <= s[j]\n}\n\nfunction binarySearch(s: seq<int>, key: int): int\n  requires sorted(s)\n{\n  binarySearchHelper(s, key, 0, |s|)\n}\n\nfunction binarySearchHelper(s: seq<int>, key: int, lo: int, hi: int): int\n  requires 0 <= lo <= hi <= |s|\n  requires sorted(s)\n  decreases hi - lo\n{\n  if lo >= hi then |s|\n  else\n    var mid := lo + (hi - lo) / 2;\n    if s[mid] == key then mid\n    else if s[mid] > key then binarySearchHelper(s, key, lo, mid)\n    else binarySearchHelper(s, key, mid + 1, hi)\n}\n\nlemma binarySearchCorrect(s: seq<int>, key: int)\n  requires sorted(s)\n  ensures var idx := binarySearch(s, key);\n    0 <= idx <= |s| &&\n    (idx < |s| ==> s[idx] == key) &&\n    (idx == |s| ==> key !in s)\n{\n  binarySearchHelperCorrect(s, key, 0, |s|);\n}\n\nlemma binarySearchHelperCorrect(s: seq<int>, key: int, lo: int, hi: int)\n  requires 0 <= lo <= hi <= |s|\n  requires sorted(s)\n  ensures var idx := binarySearchHelper(s, key, lo, hi);\n    0 <= idx <= |s| &&\n    (idx < |s| ==> s[idx] == key) &&\n    (idx == |s| ==> (forall i :: lo <= i < hi ==> s[i] != key))\n  decreases hi - lo\n{\n  if lo >= hi {\n  } else {\n    var mid := lo + (hi - lo) / 2;\n    if s[mid] == key {\n    } else if s[mid] > key {\n      \n/*[CODE HERE]*/\n      var idx := binarySearchHelper(s, key, lo, mid);\n      if idx == |s| {\n        forall i | mid <= i < hi\n          ensures s[i] != key\n        {\n          assert s[mid] > key;\n          assert sorted(s);\n          assert s[i] >= s[mid];\n          assert s[i] > key;\n        }\n      }\n    } else {\n      binarySearchHelperCorrect(s, key, mid + 1, hi);\n      var idx := binarySearchHelper(s, key, mid + 1, hi);\n      if idx == |s| {\n        forall i | lo <= i <= mid\n          ensures s[i] != key\n        {\n          assert s[mid] < key;\n          assert sorted(s);\n          assert s[i] <= s[mid];\n          assert s[i] < key;\n        }\n      }\n    }\n  }\n}", "output": "binarySearchHelperCorrect(s, key, lo, mid);"}, {"id": "example_Insert_InTree_Subset_0", "type": "call", "program": "datatype Tree = Leaf | Node(value: int, left: Tree, right: Tree)\n\nghost predicate {:spec} IsBST(t: Tree)\n  decreases t\n{\n  match t\n  case Leaf => true\n  case Node(v, l, r) =>\n    IsBST(l) && IsBST(r) &&\n    (forall x :: InTree(x, l) ==> x < v) &&\n    (forall x :: InTree(x, r) ==> x > v)\n}\n\npredicate {:spec} InTree(x: int, t: Tree)\n  decreases t\n{\n  match t\n  case Leaf => false\n  case Node(v, l, r) =>\n    x == v || InTree(x, l) || InTree(x, r)\n}\n\nfunction {:spec} Contains(t: Tree, key: int): bool\n  requires IsBST(t)\n  decreases t\n{\n  match t\n  case Leaf => false\n  case Node(v, l, r) =>\n    if key == v then true\n    else if (key < v) then Contains(l, key)\n    else Contains(r, key)\n}\n\nfunction {:spec} Insert(t: Tree, x: int): Tree\n  requires IsBST(t)\n  ensures InTree(x, Insert(t, x))\n{\n  match t\n  case Leaf => Node(x, Leaf, Leaf)\n  case Node(v, l, r) => \n      if (x == v) then t\n      else if (x < v) then Node(v, Insert(l, x), r)\n      else Node(v, l, Insert(r, x))\n}\n\nfunction {:spec} Min(t: Tree): int \n  requires IsBST(t)\n  requires t.Node?\n{\n  match t\n  case Node(v, Leaf, _) => v\n  case Node(v, l, _) => Min(l)\n}\n\nlemma Contains_Correct(t: Tree, k: int)\n  requires IsBST(t)\n  ensures Contains(t, k) <==> InTree(k, t)\n  decreases t\n{}\n\nlemma Insert_InTree_Subset(t: Tree, x: int, y: int)\n  requires IsBST(t)\n  ensures InTree(y, Insert(t, x)) ==> InTree(y, t) || y == x\n  decreases t\n{\n  match t\n  case Leaf =>\n  case Node(v, l, r) =>\n    if x == v {\n    } else if x < v {\n      Insert_InTree_Subset(l, x, y);\n    } else {\n      \n/*[CODE HERE]*/\n    }\n}\n\nlemma Insert_Preserves_BST(t: Tree, x: int)\n  requires IsBST(t)\n  ensures IsBST(Insert(t, x))\n{\n  match t\n  case Leaf => \n  case Node(v, l, r) =>\n    if x == v {\n    } else if x < v {\n      forall y | InTree(y, Insert(l, x))\n        ensures y < v\n      {\n        Insert_InTree_Subset(l, x, y);\n      }\n    } else {\n      forall y | InTree(y, Insert(r, x))\n        ensures y > v\n      {\n        Insert_InTree_Subset(r, x, y);\n      }\n    }\n}\n\nlemma Min_Absolute(t: Tree)\n  requires IsBST(t)\n  requires t.Node?\n  ensures forall v :: InTree(v, t) ==> Min(t) <= v\n  ensures InTree(Min(t), t)\n{}\n\nlemma Insert_Preserves_Node(t: Tree, x: int)\n  requires IsBST(t)\n  requires t.Node?\n  ensures Insert(t, x).Node?\n{}\n\nlemma Insert_New_Min(t: Tree, x: int)\n  requires IsBST(t)\n  requires t.Node?\n  requires !Contains(t, x)\n  requires x < Min(t)\n  requires IsBST(Insert(t, x))\n  ensures Min(Insert(t, x)) == x\n{\n  match t\n  case Node(v, l, r) =>\n    match l\n    case Leaf =>\n    case Node(_, _, _) =>\n      Min_Absolute(l);\n}", "output": "Insert_InTree_Subset(r, x, y);"}, {"id": "example_Insert_InTree_Subset_1", "type": "call", "program": "datatype Tree = Leaf | Node(value: int, left: Tree, right: Tree)\n\nghost predicate {:spec} IsBST(t: Tree)\n  decreases t\n{\n  match t\n  case Leaf => true\n  case Node(v, l, r) =>\n    IsBST(l) && IsBST(r) &&\n    (forall x :: InTree(x, l) ==> x < v) &&\n    (forall x :: InTree(x, r) ==> x > v)\n}\n\npredicate {:spec} InTree(x: int, t: Tree)\n  decreases t\n{\n  match t\n  case Leaf => false\n  case Node(v, l, r) =>\n    x == v || InTree(x, l) || InTree(x, r)\n}\n\nfunction {:spec} Contains(t: Tree, key: int): bool\n  requires IsBST(t)\n  decreases t\n{\n  match t\n  case Leaf => false\n  case Node(v, l, r) =>\n    if key == v then true\n    else if (key < v) then Contains(l, key)\n    else Contains(r, key)\n}\n\nfunction {:spec} Insert(t: Tree, x: int): Tree\n  requires IsBST(t)\n  ensures InTree(x, Insert(t, x))\n{\n  match t\n  case Leaf => Node(x, Leaf, Leaf)\n  case Node(v, l, r) => \n      if (x == v) then t\n      else if (x < v) then Node(v, Insert(l, x), r)\n      else Node(v, l, Insert(r, x))\n}\n\nfunction {:spec} Min(t: Tree): int \n  requires IsBST(t)\n  requires t.Node?\n{\n  match t\n  case Node(v, Leaf, _) => v\n  case Node(v, l, _) => Min(l)\n}\n\nlemma Contains_Correct(t: Tree, k: int)\n  requires IsBST(t)\n  ensures Contains(t, k) <==> InTree(k, t)\n  decreases t\n{}\n\nlemma Insert_InTree_Subset(t: Tree, x: int, y: int)\n  requires IsBST(t)\n  ensures InTree(y, Insert(t, x)) ==> InTree(y, t) || y == x\n  decreases t\n{\n  match t\n  case Leaf =>\n  case Node(v, l, r) =>\n    if x == v {\n    } else if x < v {\n      \n/*[CODE HERE]*/\n    } else {\n      Insert_InTree_Subset(r, x, y);\n    }\n}\n\nlemma Insert_Preserves_BST(t: Tree, x: int)\n  requires IsBST(t)\n  ensures IsBST(Insert(t, x))\n{\n  match t\n  case Leaf => \n  case Node(v, l, r) =>\n    if x == v {\n    } else if x < v {\n      forall y | InTree(y, Insert(l, x))\n        ensures y < v\n      {\n        Insert_InTree_Subset(l, x, y);\n      }\n    } else {\n      forall y | InTree(y, Insert(r, x))\n        ensures y > v\n      {\n        Insert_InTree_Subset(r, x, y);\n      }\n    }\n}\n\nlemma Min_Absolute(t: Tree)\n  requires IsBST(t)\n  requires t.Node?\n  ensures forall v :: InTree(v, t) ==> Min(t) <= v\n  ensures InTree(Min(t), t)\n{}\n\nlemma Insert_Preserves_Node(t: Tree, x: int)\n  requires IsBST(t)\n  requires t.Node?\n  ensures Insert(t, x).Node?\n{}\n\nlemma Insert_New_Min(t: Tree, x: int)\n  requires IsBST(t)\n  requires t.Node?\n  requires !Contains(t, x)\n  requires x < Min(t)\n  requires IsBST(Insert(t, x))\n  ensures Min(Insert(t, x)) == x\n{\n  match t\n  case Node(v, l, r) =>\n    match l\n    case Leaf =>\n    case Node(_, _, _) =>\n      Min_Absolute(l);\n}", "output": "Insert_InTree_Subset(l, x, y);"}, {"id": "example_Insert_Preserves_BST_0", "type": "call", "program": "datatype Tree = Leaf | Node(value: int, left: Tree, right: Tree)\n\nghost predicate {:spec} IsBST(t: Tree)\n  decreases t\n{\n  match t\n  case Leaf => true\n  case Node(v, l, r) =>\n    IsBST(l) && IsBST(r) &&\n    (forall x :: InTree(x, l) ==> x < v) &&\n    (forall x :: InTree(x, r) ==> x > v)\n}\n\npredicate {:spec} InTree(x: int, t: Tree)\n  decreases t\n{\n  match t\n  case Leaf => false\n  case Node(v, l, r) =>\n    x == v || InTree(x, l) || InTree(x, r)\n}\n\nfunction {:spec} Contains(t: Tree, key: int): bool\n  requires IsBST(t)\n  decreases t\n{\n  match t\n  case Leaf => false\n  case Node(v, l, r) =>\n    if key == v then true\n    else if (key < v) then Contains(l, key)\n    else Contains(r, key)\n}\n\nfunction {:spec} Insert(t: Tree, x: int): Tree\n  requires IsBST(t)\n  ensures InTree(x, Insert(t, x))\n{\n  match t\n  case Leaf => Node(x, Leaf, Leaf)\n  case Node(v, l, r) => \n      if (x == v) then t\n      else if (x < v) then Node(v, Insert(l, x), r)\n      else Node(v, l, Insert(r, x))\n}\n\nfunction {:spec} Min(t: Tree): int \n  requires IsBST(t)\n  requires t.Node?\n{\n  match t\n  case Node(v, Leaf, _) => v\n  case Node(v, l, _) => Min(l)\n}\n\nlemma Contains_Correct(t: Tree, k: int)\n  requires IsBST(t)\n  ensures Contains(t, k) <==> InTree(k, t)\n  decreases t\n{}\n\nlemma Insert_InTree_Subset(t: Tree, x: int, y: int)\n  requires IsBST(t)\n  ensures InTree(y, Insert(t, x)) ==> InTree(y, t) || y == x\n  decreases t\n{\n  match t\n  case Leaf =>\n  case Node(v, l, r) =>\n    if x == v {\n    } else if x < v {\n      Insert_InTree_Subset(l, x, y);\n    } else {\n      Insert_InTree_Subset(r, x, y);\n    }\n}\n\nlemma Insert_Preserves_BST(t: Tree, x: int)\n  requires IsBST(t)\n  ensures IsBST(Insert(t, x))\n{\n  match t\n  case Leaf => \n  case Node(v, l, r) =>\n    if x == v {\n    } else if x < v {\n      forall y | InTree(y, Insert(l, x))\n        ensures y < v\n      {\n        Insert_InTree_Subset(l, x, y);\n      }\n    } else {\n      forall y | InTree(y, Insert(r, x))\n        ensures y > v\n      {\n        \n/*[CODE HERE]*/\n      }\n    }\n}\n\nlemma Min_Absolute(t: Tree)\n  requires IsBST(t)\n  requires t.Node?\n  ensures forall v :: InTree(v, t) ==> Min(t) <= v\n  ensures InTree(Min(t), t)\n{}\n\nlemma Insert_Preserves_Node(t: Tree, x: int)\n  requires IsBST(t)\n  requires t.Node?\n  ensures Insert(t, x).Node?\n{}\n\nlemma Insert_New_Min(t: Tree, x: int)\n  requires IsBST(t)\n  requires t.Node?\n  requires !Contains(t, x)\n  requires x < Min(t)\n  requires IsBST(Insert(t, x))\n  ensures Min(Insert(t, x)) == x\n{\n  match t\n  case Node(v, l, r) =>\n    match l\n    case Leaf =>\n    case Node(_, _, _) =>\n      Min_Absolute(l);\n}", "output": "Insert_InTree_Subset(r, x, y);"}, {"id": "example_Insert_Preserves_BST_1", "type": "call", "program": "datatype Tree = Leaf | Node(value: int, left: Tree, right: Tree)\n\nghost predicate {:spec} IsBST(t: Tree)\n  decreases t\n{\n  match t\n  case Leaf => true\n  case Node(v, l, r) =>\n    IsBST(l) && IsBST(r) &&\n    (forall x :: InTree(x, l) ==> x < v) &&\n    (forall x :: InTree(x, r) ==> x > v)\n}\n\npredicate {:spec} InTree(x: int, t: Tree)\n  decreases t\n{\n  match t\n  case Leaf => false\n  case Node(v, l, r) =>\n    x == v || InTree(x, l) || InTree(x, r)\n}\n\nfunction {:spec} Contains(t: Tree, key: int): bool\n  requires IsBST(t)\n  decreases t\n{\n  match t\n  case Leaf => false\n  case Node(v, l, r) =>\n    if key == v then true\n    else if (key < v) then Contains(l, key)\n    else Contains(r, key)\n}\n\nfunction {:spec} Insert(t: Tree, x: int): Tree\n  requires IsBST(t)\n  ensures InTree(x, Insert(t, x))\n{\n  match t\n  case Leaf => Node(x, Leaf, Leaf)\n  case Node(v, l, r) => \n      if (x == v) then t\n      else if (x < v) then Node(v, Insert(l, x), r)\n      else Node(v, l, Insert(r, x))\n}\n\nfunction {:spec} Min(t: Tree): int \n  requires IsBST(t)\n  requires t.Node?\n{\n  match t\n  case Node(v, Leaf, _) => v\n  case Node(v, l, _) => Min(l)\n}\n\nlemma Contains_Correct(t: Tree, k: int)\n  requires IsBST(t)\n  ensures Contains(t, k) <==> InTree(k, t)\n  decreases t\n{}\n\nlemma Insert_InTree_Subset(t: Tree, x: int, y: int)\n  requires IsBST(t)\n  ensures InTree(y, Insert(t, x)) ==> InTree(y, t) || y == x\n  decreases t\n{\n  match t\n  case Leaf =>\n  case Node(v, l, r) =>\n    if x == v {\n    } else if x < v {\n      Insert_InTree_Subset(l, x, y);\n    } else {\n      Insert_InTree_Subset(r, x, y);\n    }\n}\n\nlemma Insert_Preserves_BST(t: Tree, x: int)\n  requires IsBST(t)\n  ensures IsBST(Insert(t, x))\n{\n  match t\n  case Leaf => \n  case Node(v, l, r) =>\n    if x == v {\n    } else if x < v {\n      forall y | InTree(y, Insert(l, x))\n        ensures y < v\n      {\n        \n/*[CODE HERE]*/\n      }\n    } else {\n      forall y | InTree(y, Insert(r, x))\n        ensures y > v\n      {\n        Insert_InTree_Subset(r, x, y);\n      }\n    }\n}\n\nlemma Min_Absolute(t: Tree)\n  requires IsBST(t)\n  requires t.Node?\n  ensures forall v :: InTree(v, t) ==> Min(t) <= v\n  ensures InTree(Min(t), t)\n{}\n\nlemma Insert_Preserves_Node(t: Tree, x: int)\n  requires IsBST(t)\n  requires t.Node?\n  ensures Insert(t, x).Node?\n{}\n\nlemma Insert_New_Min(t: Tree, x: int)\n  requires IsBST(t)\n  requires t.Node?\n  requires !Contains(t, x)\n  requires x < Min(t)\n  requires IsBST(Insert(t, x))\n  ensures Min(Insert(t, x)) == x\n{\n  match t\n  case Node(v, l, r) =>\n    match l\n    case Leaf =>\n    case Node(_, _, _) =>\n      Min_Absolute(l);\n}", "output": "Insert_InTree_Subset(l, x, y);"}, {"id": "example_Insert_New_Min_0", "type": "call", "program": "datatype Tree = Leaf | Node(value: int, left: Tree, right: Tree)\n\nghost predicate {:spec} IsBST(t: Tree)\n  decreases t\n{\n  match t\n  case Leaf => true\n  case Node(v, l, r) =>\n    IsBST(l) && IsBST(r) &&\n    (forall x :: InTree(x, l) ==> x < v) &&\n    (forall x :: InTree(x, r) ==> x > v)\n}\n\npredicate {:spec} InTree(x: int, t: Tree)\n  decreases t\n{\n  match t\n  case Leaf => false\n  case Node(v, l, r) =>\n    x == v || InTree(x, l) || InTree(x, r)\n}\n\nfunction {:spec} Contains(t: Tree, key: int): bool\n  requires IsBST(t)\n  decreases t\n{\n  match t\n  case Leaf => false\n  case Node(v, l, r) =>\n    if key == v then true\n    else if (key < v) then Contains(l, key)\n    else Contains(r, key)\n}\n\nfunction {:spec} Insert(t: Tree, x: int): Tree\n  requires IsBST(t)\n  ensures InTree(x, Insert(t, x))\n{\n  match t\n  case Leaf => Node(x, Leaf, Leaf)\n  case Node(v, l, r) => \n      if (x == v) then t\n      else if (x < v) then Node(v, Insert(l, x), r)\n      else Node(v, l, Insert(r, x))\n}\n\nfunction {:spec} Min(t: Tree): int \n  requires IsBST(t)\n  requires t.Node?\n{\n  match t\n  case Node(v, Leaf, _) => v\n  case Node(v, l, _) => Min(l)\n}\n\nlemma Contains_Correct(t: Tree, k: int)\n  requires IsBST(t)\n  ensures Contains(t, k) <==> InTree(k, t)\n  decreases t\n{}\n\nlemma Insert_InTree_Subset(t: Tree, x: int, y: int)\n  requires IsBST(t)\n  ensures InTree(y, Insert(t, x)) ==> InTree(y, t) || y == x\n  decreases t\n{\n  match t\n  case Leaf =>\n  case Node(v, l, r) =>\n    if x == v {\n    } else if x < v {\n      Insert_InTree_Subset(l, x, y);\n    } else {\n      Insert_InTree_Subset(r, x, y);\n    }\n}\n\nlemma Insert_Preserves_BST(t: Tree, x: int)\n  requires IsBST(t)\n  ensures IsBST(Insert(t, x))\n{\n  match t\n  case Leaf => \n  case Node(v, l, r) =>\n    if x == v {\n    } else if x < v {\n      forall y | InTree(y, Insert(l, x))\n        ensures y < v\n      {\n        Insert_InTree_Subset(l, x, y);\n      }\n    } else {\n      forall y | InTree(y, Insert(r, x))\n        ensures y > v\n      {\n        Insert_InTree_Subset(r, x, y);\n      }\n    }\n}\n\nlemma Min_Absolute(t: Tree)\n  requires IsBST(t)\n  requires t.Node?\n  ensures forall v :: InTree(v, t) ==> Min(t) <= v\n  ensures InTree(Min(t), t)\n{}\n\nlemma Insert_Preserves_Node(t: Tree, x: int)\n  requires IsBST(t)\n  requires t.Node?\n  ensures Insert(t, x).Node?\n{}\n\nlemma Insert_New_Min(t: Tree, x: int)\n  requires IsBST(t)\n  requires t.Node?\n  requires !Contains(t, x)\n  requires x < Min(t)\n  requires IsBST(Insert(t, x))\n  ensures Min(Insert(t, x)) == x\n{\n  match t\n  case Node(v, l, r) =>\n    match l\n    case Leaf =>\n    case Node(_, _, _) =>\n      \n/*[CODE HERE]*/\n}", "output": "Min_Absolute(l);"}, {"id": "example_iter5_biz_day_idempotent_0", "type": "assert", "program": "datatype Day = Sunday | Monday | Tuesday | Wednesday | Thursday | Friday | Saturday\n\nfunction next_biz_day(d: Day): Day\n{\n  match d\n  case Monday => Tuesday\n  case Tuesday => Wednesday\n  case Wednesday => Thursday\n  case Thursday => Friday\n  case Friday => Monday\n  case Saturday => Monday\n  case Sunday => Monday\n}\n\nfunction iter_biz_day(d: Day, n: nat): Day\n  decreases n\n{\n  if n == 0 then d\n  else iter_biz_day(next_biz_day(d), n - 1)\n}\n\nlemma iter5_biz_day_idempotent(d: Day)\n  requires d != Saturday && d != Sunday\n  ensures iter_biz_day(d, 5) == iter_biz_day(iter_biz_day(d, 5), 5)\n{\n  // 5 business days from any weekday brings you to the same weekday next week\n  match d\n  case Monday =>\n    assert iter_biz_day(Monday, 1) == Tuesday;\n    assert iter_biz_day(Monday, 2) == Wednesday;\n    assert iter_biz_day(Monday, 3) == Thursday;\n    assert iter_biz_day(Monday, 4) == Friday;\n    assert iter_biz_day(Monday, 5) == Monday;\n    assert iter_biz_day(Monday, 5) == Monday;\n    assert iter_biz_day(iter_biz_day(Monday, 5), 5) == iter_biz_day(Monday, 5);\n  case Tuesday =>\n    assert iter_biz_day(Tuesday, 1) == Wednesday;\n    assert iter_biz_day(Tuesday, 2) == Thursday;\n    assert iter_biz_day(Tuesday, 3) == Friday;\n    assert iter_biz_day(Tuesday, 4) == Monday;\n    assert iter_biz_day(Tuesday, 5) == Tuesday;\n  case Wednesday =>\n    assert iter_biz_day(Wednesday, 1) == Thursday;\n    assert iter_biz_day(Wednesday, 2) == Friday;\n    assert iter_biz_day(Wednesday, 3) == Monday;\n    assert iter_biz_day(Wednesday, 4) == Tuesday;\n    assert iter_biz_day(Wednesday, 5) == Wednesday;\n  case Thursday =>\n    assert iter_biz_day(Thursday, 1) == Friday;\n    assert iter_biz_day(Thursday, 2) == Monday;\n    assert iter_biz_day(Thursday, 3) == Tuesday;\n    assert iter_biz_day(Thursday, 4) == Wednesday;\n    assert iter_biz_day(Thursday, 5) == Thursday;\n  case Friday =>\n    assert iter_biz_day(Friday, 1) == Monday;\n    assert iter_biz_day(Friday, 2) == Tuesday;\n    assert iter_biz_day(Friday, 3) == Wednesday;\n    assert iter_biz_day(Friday, 4) == Thursday;\n    \n/*[CODE HERE]*/\n}", "output": "assert iter_biz_day(Friday, 5) == Friday;"}, {"id": "example_iter5_biz_day_idempotent_1", "type": "assert", "program": "datatype Day = Sunday | Monday | Tuesday | Wednesday | Thursday | Friday | Saturday\n\nfunction next_biz_day(d: Day): Day\n{\n  match d\n  case Monday => Tuesday\n  case Tuesday => Wednesday\n  case Wednesday => Thursday\n  case Thursday => Friday\n  case Friday => Monday\n  case Saturday => Monday\n  case Sunday => Monday\n}\n\nfunction iter_biz_day(d: Day, n: nat): Day\n  decreases n\n{\n  if n == 0 then d\n  else iter_biz_day(next_biz_day(d), n - 1)\n}\n\nlemma iter5_biz_day_idempotent(d: Day)\n  requires d != Saturday && d != Sunday\n  ensures iter_biz_day(d, 5) == iter_biz_day(iter_biz_day(d, 5), 5)\n{\n  // 5 business days from any weekday brings you to the same weekday next week\n  match d\n  case Monday =>\n    assert iter_biz_day(Monday, 1) == Tuesday;\n    assert iter_biz_day(Monday, 2) == Wednesday;\n    assert iter_biz_day(Monday, 3) == Thursday;\n    assert iter_biz_day(Monday, 4) == Friday;\n    assert iter_biz_day(Monday, 5) == Monday;\n    assert iter_biz_day(Monday, 5) == Monday;\n    assert iter_biz_day(iter_biz_day(Monday, 5), 5) == iter_biz_day(Monday, 5);\n  case Tuesday =>\n    assert iter_biz_day(Tuesday, 1) == Wednesday;\n    assert iter_biz_day(Tuesday, 2) == Thursday;\n    assert iter_biz_day(Tuesday, 3) == Friday;\n    assert iter_biz_day(Tuesday, 4) == Monday;\n    assert iter_biz_day(Tuesday, 5) == Tuesday;\n  case Wednesday =>\n    assert iter_biz_day(Wednesday, 1) == Thursday;\n    assert iter_biz_day(Wednesday, 2) == Friday;\n    assert iter_biz_day(Wednesday, 3) == Monday;\n    assert iter_biz_day(Wednesday, 4) == Tuesday;\n    assert iter_biz_day(Wednesday, 5) == Wednesday;\n  case Thursday =>\n    assert iter_biz_day(Thursday, 1) == Friday;\n    assert iter_biz_day(Thursday, 2) == Monday;\n    assert iter_biz_day(Thursday, 3) == Tuesday;\n    assert iter_biz_day(Thursday, 4) == Wednesday;\n    assert iter_biz_day(Thursday, 5) == Thursday;\n  case Friday =>\n    assert iter_biz_day(Friday, 1) == Monday;\n    assert iter_biz_day(Friday, 2) == Tuesday;\n    assert iter_biz_day(Friday, 3) == Wednesday;\n    \n/*[CODE HERE]*/\n    assert iter_biz_day(Friday, 5) == Friday;\n}", "output": "assert iter_biz_day(Friday, 4) == Thursday;"}, {"id": "example_iter5_biz_day_idempotent_2", "type": "assert", "program": "datatype Day = Sunday | Monday | Tuesday | Wednesday | Thursday | Friday | Saturday\n\nfunction next_biz_day(d: Day): Day\n{\n  match d\n  case Monday => Tuesday\n  case Tuesday => Wednesday\n  case Wednesday => Thursday\n  case Thursday => Friday\n  case Friday => Monday\n  case Saturday => Monday\n  case Sunday => Monday\n}\n\nfunction iter_biz_day(d: Day, n: nat): Day\n  decreases n\n{\n  if n == 0 then d\n  else iter_biz_day(next_biz_day(d), n - 1)\n}\n\nlemma iter5_biz_day_idempotent(d: Day)\n  requires d != Saturday && d != Sunday\n  ensures iter_biz_day(d, 5) == iter_biz_day(iter_biz_day(d, 5), 5)\n{\n  // 5 business days from any weekday brings you to the same weekday next week\n  match d\n  case Monday =>\n    assert iter_biz_day(Monday, 1) == Tuesday;\n    assert iter_biz_day(Monday, 2) == Wednesday;\n    assert iter_biz_day(Monday, 3) == Thursday;\n    assert iter_biz_day(Monday, 4) == Friday;\n    assert iter_biz_day(Monday, 5) == Monday;\n    assert iter_biz_day(Monday, 5) == Monday;\n    assert iter_biz_day(iter_biz_day(Monday, 5), 5) == iter_biz_day(Monday, 5);\n  case Tuesday =>\n    assert iter_biz_day(Tuesday, 1) == Wednesday;\n    assert iter_biz_day(Tuesday, 2) == Thursday;\n    assert iter_biz_day(Tuesday, 3) == Friday;\n    assert iter_biz_day(Tuesday, 4) == Monday;\n    assert iter_biz_day(Tuesday, 5) == Tuesday;\n  case Wednesday =>\n    assert iter_biz_day(Wednesday, 1) == Thursday;\n    assert iter_biz_day(Wednesday, 2) == Friday;\n    assert iter_biz_day(Wednesday, 3) == Monday;\n    assert iter_biz_day(Wednesday, 4) == Tuesday;\n    assert iter_biz_day(Wednesday, 5) == Wednesday;\n  case Thursday =>\n    assert iter_biz_day(Thursday, 1) == Friday;\n    assert iter_biz_day(Thursday, 2) == Monday;\n    assert iter_biz_day(Thursday, 3) == Tuesday;\n    assert iter_biz_day(Thursday, 4) == Wednesday;\n    assert iter_biz_day(Thursday, 5) == Thursday;\n  case Friday =>\n    assert iter_biz_day(Friday, 1) == Monday;\n    assert iter_biz_day(Friday, 2) == Tuesday;\n    \n/*[CODE HERE]*/\n    assert iter_biz_day(Friday, 4) == Thursday;\n    assert iter_biz_day(Friday, 5) == Friday;\n}", "output": "assert iter_biz_day(Friday, 3) == Wednesday;"}, {"id": "example_iter5_biz_day_idempotent_3", "type": "assert", "program": "datatype Day = Sunday | Monday | Tuesday | Wednesday | Thursday | Friday | Saturday\n\nfunction next_biz_day(d: Day): Day\n{\n  match d\n  case Monday => Tuesday\n  case Tuesday => Wednesday\n  case Wednesday => Thursday\n  case Thursday => Friday\n  case Friday => Monday\n  case Saturday => Monday\n  case Sunday => Monday\n}\n\nfunction iter_biz_day(d: Day, n: nat): Day\n  decreases n\n{\n  if n == 0 then d\n  else iter_biz_day(next_biz_day(d), n - 1)\n}\n\nlemma iter5_biz_day_idempotent(d: Day)\n  requires d != Saturday && d != Sunday\n  ensures iter_biz_day(d, 5) == iter_biz_day(iter_biz_day(d, 5), 5)\n{\n  // 5 business days from any weekday brings you to the same weekday next week\n  match d\n  case Monday =>\n    assert iter_biz_day(Monday, 1) == Tuesday;\n    assert iter_biz_day(Monday, 2) == Wednesday;\n    assert iter_biz_day(Monday, 3) == Thursday;\n    assert iter_biz_day(Monday, 4) == Friday;\n    assert iter_biz_day(Monday, 5) == Monday;\n    assert iter_biz_day(Monday, 5) == Monday;\n    assert iter_biz_day(iter_biz_day(Monday, 5), 5) == iter_biz_day(Monday, 5);\n  case Tuesday =>\n    assert iter_biz_day(Tuesday, 1) == Wednesday;\n    assert iter_biz_day(Tuesday, 2) == Thursday;\n    assert iter_biz_day(Tuesday, 3) == Friday;\n    assert iter_biz_day(Tuesday, 4) == Monday;\n    assert iter_biz_day(Tuesday, 5) == Tuesday;\n  case Wednesday =>\n    assert iter_biz_day(Wednesday, 1) == Thursday;\n    assert iter_biz_day(Wednesday, 2) == Friday;\n    assert iter_biz_day(Wednesday, 3) == Monday;\n    assert iter_biz_day(Wednesday, 4) == Tuesday;\n    assert iter_biz_day(Wednesday, 5) == Wednesday;\n  case Thursday =>\n    assert iter_biz_day(Thursday, 1) == Friday;\n    assert iter_biz_day(Thursday, 2) == Monday;\n    assert iter_biz_day(Thursday, 3) == Tuesday;\n    assert iter_biz_day(Thursday, 4) == Wednesday;\n    assert iter_biz_day(Thursday, 5) == Thursday;\n  case Friday =>\n    assert iter_biz_day(Friday, 1) == Monday;\n    \n/*[CODE HERE]*/\n    assert iter_biz_day(Friday, 3) == Wednesday;\n    assert iter_biz_day(Friday, 4) == Thursday;\n    assert iter_biz_day(Friday, 5) == Friday;\n}", "output": "assert iter_biz_day(Friday, 2) == Tuesday;"}, {"id": "example_iter5_biz_day_idempotent_4", "type": "assert", "program": "datatype Day = Sunday | Monday | Tuesday | Wednesday | Thursday | Friday | Saturday\n\nfunction next_biz_day(d: Day): Day\n{\n  match d\n  case Monday => Tuesday\n  case Tuesday => Wednesday\n  case Wednesday => Thursday\n  case Thursday => Friday\n  case Friday => Monday\n  case Saturday => Monday\n  case Sunday => Monday\n}\n\nfunction iter_biz_day(d: Day, n: nat): Day\n  decreases n\n{\n  if n == 0 then d\n  else iter_biz_day(next_biz_day(d), n - 1)\n}\n\nlemma iter5_biz_day_idempotent(d: Day)\n  requires d != Saturday && d != Sunday\n  ensures iter_biz_day(d, 5) == iter_biz_day(iter_biz_day(d, 5), 5)\n{\n  // 5 business days from any weekday brings you to the same weekday next week\n  match d\n  case Monday =>\n    assert iter_biz_day(Monday, 1) == Tuesday;\n    assert iter_biz_day(Monday, 2) == Wednesday;\n    assert iter_biz_day(Monday, 3) == Thursday;\n    assert iter_biz_day(Monday, 4) == Friday;\n    assert iter_biz_day(Monday, 5) == Monday;\n    assert iter_biz_day(Monday, 5) == Monday;\n    assert iter_biz_day(iter_biz_day(Monday, 5), 5) == iter_biz_day(Monday, 5);\n  case Tuesday =>\n    assert iter_biz_day(Tuesday, 1) == Wednesday;\n    assert iter_biz_day(Tuesday, 2) == Thursday;\n    assert iter_biz_day(Tuesday, 3) == Friday;\n    assert iter_biz_day(Tuesday, 4) == Monday;\n    assert iter_biz_day(Tuesday, 5) == Tuesday;\n  case Wednesday =>\n    assert iter_biz_day(Wednesday, 1) == Thursday;\n    assert iter_biz_day(Wednesday, 2) == Friday;\n    assert iter_biz_day(Wednesday, 3) == Monday;\n    assert iter_biz_day(Wednesday, 4) == Tuesday;\n    assert iter_biz_day(Wednesday, 5) == Wednesday;\n  case Thursday =>\n    assert iter_biz_day(Thursday, 1) == Friday;\n    assert iter_biz_day(Thursday, 2) == Monday;\n    assert iter_biz_day(Thursday, 3) == Tuesday;\n    assert iter_biz_day(Thursday, 4) == Wednesday;\n    assert iter_biz_day(Thursday, 5) == Thursday;\n  case Friday =>\n    \n/*[CODE HERE]*/\n    assert iter_biz_day(Friday, 2) == Tuesday;\n    assert iter_biz_day(Friday, 3) == Wednesday;\n    assert iter_biz_day(Friday, 4) == Thursday;\n    assert iter_biz_day(Friday, 5) == Friday;\n}", "output": "assert iter_biz_day(Friday, 1) == Monday;"}, {"id": "example_iter5_biz_day_idempotent_5", "type": "assert", "program": "datatype Day = Sunday | Monday | Tuesday | Wednesday | Thursday | Friday | Saturday\n\nfunction next_biz_day(d: Day): Day\n{\n  match d\n  case Monday => Tuesday\n  case Tuesday => Wednesday\n  case Wednesday => Thursday\n  case Thursday => Friday\n  case Friday => Monday\n  case Saturday => Monday\n  case Sunday => Monday\n}\n\nfunction iter_biz_day(d: Day, n: nat): Day\n  decreases n\n{\n  if n == 0 then d\n  else iter_biz_day(next_biz_day(d), n - 1)\n}\n\nlemma iter5_biz_day_idempotent(d: Day)\n  requires d != Saturday && d != Sunday\n  ensures iter_biz_day(d, 5) == iter_biz_day(iter_biz_day(d, 5), 5)\n{\n  // 5 business days from any weekday brings you to the same weekday next week\n  match d\n  case Monday =>\n    assert iter_biz_day(Monday, 1) == Tuesday;\n    assert iter_biz_day(Monday, 2) == Wednesday;\n    assert iter_biz_day(Monday, 3) == Thursday;\n    assert iter_biz_day(Monday, 4) == Friday;\n    assert iter_biz_day(Monday, 5) == Monday;\n    assert iter_biz_day(Monday, 5) == Monday;\n    assert iter_biz_day(iter_biz_day(Monday, 5), 5) == iter_biz_day(Monday, 5);\n  case Tuesday =>\n    assert iter_biz_day(Tuesday, 1) == Wednesday;\n    assert iter_biz_day(Tuesday, 2) == Thursday;\n    assert iter_biz_day(Tuesday, 3) == Friday;\n    assert iter_biz_day(Tuesday, 4) == Monday;\n    assert iter_biz_day(Tuesday, 5) == Tuesday;\n  case Wednesday =>\n    assert iter_biz_day(Wednesday, 1) == Thursday;\n    assert iter_biz_day(Wednesday, 2) == Friday;\n    assert iter_biz_day(Wednesday, 3) == Monday;\n    assert iter_biz_day(Wednesday, 4) == Tuesday;\n    assert iter_biz_day(Wednesday, 5) == Wednesday;\n  case Thursday =>\n    assert iter_biz_day(Thursday, 1) == Friday;\n    assert iter_biz_day(Thursday, 2) == Monday;\n    assert iter_biz_day(Thursday, 3) == Tuesday;\n    assert iter_biz_day(Thursday, 4) == Wednesday;\n    \n/*[CODE HERE]*/\n  case Friday =>\n    assert iter_biz_day(Friday, 1) == Monday;\n    assert iter_biz_day(Friday, 2) == Tuesday;\n    assert iter_biz_day(Friday, 3) == Wednesday;\n    assert iter_biz_day(Friday, 4) == Thursday;\n    assert iter_biz_day(Friday, 5) == Friday;\n}", "output": "assert iter_biz_day(Thursday, 5) == Thursday;"}, {"id": "example_iter5_biz_day_idempotent_6", "type": "assert", "program": "datatype Day = Sunday | Monday | Tuesday | Wednesday | Thursday | Friday | Saturday\n\nfunction next_biz_day(d: Day): Day\n{\n  match d\n  case Monday => Tuesday\n  case Tuesday => Wednesday\n  case Wednesday => Thursday\n  case Thursday => Friday\n  case Friday => Monday\n  case Saturday => Monday\n  case Sunday => Monday\n}\n\nfunction iter_biz_day(d: Day, n: nat): Day\n  decreases n\n{\n  if n == 0 then d\n  else iter_biz_day(next_biz_day(d), n - 1)\n}\n\nlemma iter5_biz_day_idempotent(d: Day)\n  requires d != Saturday && d != Sunday\n  ensures iter_biz_day(d, 5) == iter_biz_day(iter_biz_day(d, 5), 5)\n{\n  // 5 business days from any weekday brings you to the same weekday next week\n  match d\n  case Monday =>\n    assert iter_biz_day(Monday, 1) == Tuesday;\n    assert iter_biz_day(Monday, 2) == Wednesday;\n    assert iter_biz_day(Monday, 3) == Thursday;\n    assert iter_biz_day(Monday, 4) == Friday;\n    assert iter_biz_day(Monday, 5) == Monday;\n    assert iter_biz_day(Monday, 5) == Monday;\n    assert iter_biz_day(iter_biz_day(Monday, 5), 5) == iter_biz_day(Monday, 5);\n  case Tuesday =>\n    assert iter_biz_day(Tuesday, 1) == Wednesday;\n    assert iter_biz_day(Tuesday, 2) == Thursday;\n    assert iter_biz_day(Tuesday, 3) == Friday;\n    assert iter_biz_day(Tuesday, 4) == Monday;\n    assert iter_biz_day(Tuesday, 5) == Tuesday;\n  case Wednesday =>\n    assert iter_biz_day(Wednesday, 1) == Thursday;\n    assert iter_biz_day(Wednesday, 2) == Friday;\n    assert iter_biz_day(Wednesday, 3) == Monday;\n    assert iter_biz_day(Wednesday, 4) == Tuesday;\n    assert iter_biz_day(Wednesday, 5) == Wednesday;\n  case Thursday =>\n    assert iter_biz_day(Thursday, 1) == Friday;\n    assert iter_biz_day(Thursday, 2) == Monday;\n    assert iter_biz_day(Thursday, 3) == Tuesday;\n    \n/*[CODE HERE]*/\n    assert iter_biz_day(Thursday, 5) == Thursday;\n  case Friday =>\n    assert iter_biz_day(Friday, 1) == Monday;\n    assert iter_biz_day(Friday, 2) == Tuesday;\n    assert iter_biz_day(Friday, 3) == Wednesday;\n    assert iter_biz_day(Friday, 4) == Thursday;\n    assert iter_biz_day(Friday, 5) == Friday;\n}", "output": "assert iter_biz_day(Thursday, 4) == Wednesday;"}, {"id": "example_iter5_biz_day_idempotent_7", "type": "assert", "program": "datatype Day = Sunday | Monday | Tuesday | Wednesday | Thursday | Friday | Saturday\n\nfunction next_biz_day(d: Day): Day\n{\n  match d\n  case Monday => Tuesday\n  case Tuesday => Wednesday\n  case Wednesday => Thursday\n  case Thursday => Friday\n  case Friday => Monday\n  case Saturday => Monday\n  case Sunday => Monday\n}\n\nfunction iter_biz_day(d: Day, n: nat): Day\n  decreases n\n{\n  if n == 0 then d\n  else iter_biz_day(next_biz_day(d), n - 1)\n}\n\nlemma iter5_biz_day_idempotent(d: Day)\n  requires d != Saturday && d != Sunday\n  ensures iter_biz_day(d, 5) == iter_biz_day(iter_biz_day(d, 5), 5)\n{\n  // 5 business days from any weekday brings you to the same weekday next week\n  match d\n  case Monday =>\n    assert iter_biz_day(Monday, 1) == Tuesday;\n    assert iter_biz_day(Monday, 2) == Wednesday;\n    assert iter_biz_day(Monday, 3) == Thursday;\n    assert iter_biz_day(Monday, 4) == Friday;\n    assert iter_biz_day(Monday, 5) == Monday;\n    assert iter_biz_day(Monday, 5) == Monday;\n    assert iter_biz_day(iter_biz_day(Monday, 5), 5) == iter_biz_day(Monday, 5);\n  case Tuesday =>\n    assert iter_biz_day(Tuesday, 1) == Wednesday;\n    assert iter_biz_day(Tuesday, 2) == Thursday;\n    assert iter_biz_day(Tuesday, 3) == Friday;\n    assert iter_biz_day(Tuesday, 4) == Monday;\n    assert iter_biz_day(Tuesday, 5) == Tuesday;\n  case Wednesday =>\n    assert iter_biz_day(Wednesday, 1) == Thursday;\n    assert iter_biz_day(Wednesday, 2) == Friday;\n    assert iter_biz_day(Wednesday, 3) == Monday;\n    assert iter_biz_day(Wednesday, 4) == Tuesday;\n    assert iter_biz_day(Wednesday, 5) == Wednesday;\n  case Thursday =>\n    assert iter_biz_day(Thursday, 1) == Friday;\n    assert iter_biz_day(Thursday, 2) == Monday;\n    \n/*[CODE HERE]*/\n    assert iter_biz_day(Thursday, 4) == Wednesday;\n    assert iter_biz_day(Thursday, 5) == Thursday;\n  case Friday =>\n    assert iter_biz_day(Friday, 1) == Monday;\n    assert iter_biz_day(Friday, 2) == Tuesday;\n    assert iter_biz_day(Friday, 3) == Wednesday;\n    assert iter_biz_day(Friday, 4) == Thursday;\n    assert iter_biz_day(Friday, 5) == Friday;\n}", "output": "assert iter_biz_day(Thursday, 3) == Tuesday;"}, {"id": "example_iter5_biz_day_idempotent_8", "type": "assert", "program": "datatype Day = Sunday | Monday | Tuesday | Wednesday | Thursday | Friday | Saturday\n\nfunction next_biz_day(d: Day): Day\n{\n  match d\n  case Monday => Tuesday\n  case Tuesday => Wednesday\n  case Wednesday => Thursday\n  case Thursday => Friday\n  case Friday => Monday\n  case Saturday => Monday\n  case Sunday => Monday\n}\n\nfunction iter_biz_day(d: Day, n: nat): Day\n  decreases n\n{\n  if n == 0 then d\n  else iter_biz_day(next_biz_day(d), n - 1)\n}\n\nlemma iter5_biz_day_idempotent(d: Day)\n  requires d != Saturday && d != Sunday\n  ensures iter_biz_day(d, 5) == iter_biz_day(iter_biz_day(d, 5), 5)\n{\n  // 5 business days from any weekday brings you to the same weekday next week\n  match d\n  case Monday =>\n    assert iter_biz_day(Monday, 1) == Tuesday;\n    assert iter_biz_day(Monday, 2) == Wednesday;\n    assert iter_biz_day(Monday, 3) == Thursday;\n    assert iter_biz_day(Monday, 4) == Friday;\n    assert iter_biz_day(Monday, 5) == Monday;\n    assert iter_biz_day(Monday, 5) == Monday;\n    assert iter_biz_day(iter_biz_day(Monday, 5), 5) == iter_biz_day(Monday, 5);\n  case Tuesday =>\n    assert iter_biz_day(Tuesday, 1) == Wednesday;\n    assert iter_biz_day(Tuesday, 2) == Thursday;\n    assert iter_biz_day(Tuesday, 3) == Friday;\n    assert iter_biz_day(Tuesday, 4) == Monday;\n    assert iter_biz_day(Tuesday, 5) == Tuesday;\n  case Wednesday =>\n    assert iter_biz_day(Wednesday, 1) == Thursday;\n    assert iter_biz_day(Wednesday, 2) == Friday;\n    assert iter_biz_day(Wednesday, 3) == Monday;\n    assert iter_biz_day(Wednesday, 4) == Tuesday;\n    assert iter_biz_day(Wednesday, 5) == Wednesday;\n  case Thursday =>\n    assert iter_biz_day(Thursday, 1) == Friday;\n    \n/*[CODE HERE]*/\n    assert iter_biz_day(Thursday, 3) == Tuesday;\n    assert iter_biz_day(Thursday, 4) == Wednesday;\n    assert iter_biz_day(Thursday, 5) == Thursday;\n  case Friday =>\n    assert iter_biz_day(Friday, 1) == Monday;\n    assert iter_biz_day(Friday, 2) == Tuesday;\n    assert iter_biz_day(Friday, 3) == Wednesday;\n    assert iter_biz_day(Friday, 4) == Thursday;\n    assert iter_biz_day(Friday, 5) == Friday;\n}", "output": "assert iter_biz_day(Thursday, 2) == Monday;"}, {"id": "example_iter5_biz_day_idempotent_9", "type": "assert", "program": "datatype Day = Sunday | Monday | Tuesday | Wednesday | Thursday | Friday | Saturday\n\nfunction next_biz_day(d: Day): Day\n{\n  match d\n  case Monday => Tuesday\n  case Tuesday => Wednesday\n  case Wednesday => Thursday\n  case Thursday => Friday\n  case Friday => Monday\n  case Saturday => Monday\n  case Sunday => Monday\n}\n\nfunction iter_biz_day(d: Day, n: nat): Day\n  decreases n\n{\n  if n == 0 then d\n  else iter_biz_day(next_biz_day(d), n - 1)\n}\n\nlemma iter5_biz_day_idempotent(d: Day)\n  requires d != Saturday && d != Sunday\n  ensures iter_biz_day(d, 5) == iter_biz_day(iter_biz_day(d, 5), 5)\n{\n  // 5 business days from any weekday brings you to the same weekday next week\n  match d\n  case Monday =>\n    assert iter_biz_day(Monday, 1) == Tuesday;\n    assert iter_biz_day(Monday, 2) == Wednesday;\n    assert iter_biz_day(Monday, 3) == Thursday;\n    assert iter_biz_day(Monday, 4) == Friday;\n    assert iter_biz_day(Monday, 5) == Monday;\n    assert iter_biz_day(Monday, 5) == Monday;\n    assert iter_biz_day(iter_biz_day(Monday, 5), 5) == iter_biz_day(Monday, 5);\n  case Tuesday =>\n    assert iter_biz_day(Tuesday, 1) == Wednesday;\n    assert iter_biz_day(Tuesday, 2) == Thursday;\n    assert iter_biz_day(Tuesday, 3) == Friday;\n    assert iter_biz_day(Tuesday, 4) == Monday;\n    assert iter_biz_day(Tuesday, 5) == Tuesday;\n  case Wednesday =>\n    assert iter_biz_day(Wednesday, 1) == Thursday;\n    assert iter_biz_day(Wednesday, 2) == Friday;\n    assert iter_biz_day(Wednesday, 3) == Monday;\n    assert iter_biz_day(Wednesday, 4) == Tuesday;\n    assert iter_biz_day(Wednesday, 5) == Wednesday;\n  case Thursday =>\n    \n/*[CODE HERE]*/\n    assert iter_biz_day(Thursday, 2) == Monday;\n    assert iter_biz_day(Thursday, 3) == Tuesday;\n    assert iter_biz_day(Thursday, 4) == Wednesday;\n    assert iter_biz_day(Thursday, 5) == Thursday;\n  case Friday =>\n    assert iter_biz_day(Friday, 1) == Monday;\n    assert iter_biz_day(Friday, 2) == Tuesday;\n    assert iter_biz_day(Friday, 3) == Wednesday;\n    assert iter_biz_day(Friday, 4) == Thursday;\n    assert iter_biz_day(Friday, 5) == Friday;\n}", "output": "assert iter_biz_day(Thursday, 1) == Friday;"}, {"id": "example_iter5_biz_day_idempotent_10", "type": "assert", "program": "datatype Day = Sunday | Monday | Tuesday | Wednesday | Thursday | Friday | Saturday\n\nfunction next_biz_day(d: Day): Day\n{\n  match d\n  case Monday => Tuesday\n  case Tuesday => Wednesday\n  case Wednesday => Thursday\n  case Thursday => Friday\n  case Friday => Monday\n  case Saturday => Monday\n  case Sunday => Monday\n}\n\nfunction iter_biz_day(d: Day, n: nat): Day\n  decreases n\n{\n  if n == 0 then d\n  else iter_biz_day(next_biz_day(d), n - 1)\n}\n\nlemma iter5_biz_day_idempotent(d: Day)\n  requires d != Saturday && d != Sunday\n  ensures iter_biz_day(d, 5) == iter_biz_day(iter_biz_day(d, 5), 5)\n{\n  // 5 business days from any weekday brings you to the same weekday next week\n  match d\n  case Monday =>\n    assert iter_biz_day(Monday, 1) == Tuesday;\n    assert iter_biz_day(Monday, 2) == Wednesday;\n    assert iter_biz_day(Monday, 3) == Thursday;\n    assert iter_biz_day(Monday, 4) == Friday;\n    assert iter_biz_day(Monday, 5) == Monday;\n    assert iter_biz_day(Monday, 5) == Monday;\n    assert iter_biz_day(iter_biz_day(Monday, 5), 5) == iter_biz_day(Monday, 5);\n  case Tuesday =>\n    assert iter_biz_day(Tuesday, 1) == Wednesday;\n    assert iter_biz_day(Tuesday, 2) == Thursday;\n    assert iter_biz_day(Tuesday, 3) == Friday;\n    assert iter_biz_day(Tuesday, 4) == Monday;\n    assert iter_biz_day(Tuesday, 5) == Tuesday;\n  case Wednesday =>\n    assert iter_biz_day(Wednesday, 1) == Thursday;\n    assert iter_biz_day(Wednesday, 2) == Friday;\n    assert iter_biz_day(Wednesday, 3) == Monday;\n    assert iter_biz_day(Wednesday, 4) == Tuesday;\n    \n/*[CODE HERE]*/\n  case Thursday =>\n    assert iter_biz_day(Thursday, 1) == Friday;\n    assert iter_biz_day(Thursday, 2) == Monday;\n    assert iter_biz_day(Thursday, 3) == Tuesday;\n    assert iter_biz_day(Thursday, 4) == Wednesday;\n    assert iter_biz_day(Thursday, 5) == Thursday;\n  case Friday =>\n    assert iter_biz_day(Friday, 1) == Monday;\n    assert iter_biz_day(Friday, 2) == Tuesday;\n    assert iter_biz_day(Friday, 3) == Wednesday;\n    assert iter_biz_day(Friday, 4) == Thursday;\n    assert iter_biz_day(Friday, 5) == Friday;\n}", "output": "assert iter_biz_day(Wednesday, 5) == Wednesday;"}, {"id": "example_iter5_biz_day_idempotent_11", "type": "assert", "program": "datatype Day = Sunday | Monday | Tuesday | Wednesday | Thursday | Friday | Saturday\n\nfunction next_biz_day(d: Day): Day\n{\n  match d\n  case Monday => Tuesday\n  case Tuesday => Wednesday\n  case Wednesday => Thursday\n  case Thursday => Friday\n  case Friday => Monday\n  case Saturday => Monday\n  case Sunday => Monday\n}\n\nfunction iter_biz_day(d: Day, n: nat): Day\n  decreases n\n{\n  if n == 0 then d\n  else iter_biz_day(next_biz_day(d), n - 1)\n}\n\nlemma iter5_biz_day_idempotent(d: Day)\n  requires d != Saturday && d != Sunday\n  ensures iter_biz_day(d, 5) == iter_biz_day(iter_biz_day(d, 5), 5)\n{\n  // 5 business days from any weekday brings you to the same weekday next week\n  match d\n  case Monday =>\n    assert iter_biz_day(Monday, 1) == Tuesday;\n    assert iter_biz_day(Monday, 2) == Wednesday;\n    assert iter_biz_day(Monday, 3) == Thursday;\n    assert iter_biz_day(Monday, 4) == Friday;\n    assert iter_biz_day(Monday, 5) == Monday;\n    assert iter_biz_day(Monday, 5) == Monday;\n    assert iter_biz_day(iter_biz_day(Monday, 5), 5) == iter_biz_day(Monday, 5);\n  case Tuesday =>\n    assert iter_biz_day(Tuesday, 1) == Wednesday;\n    assert iter_biz_day(Tuesday, 2) == Thursday;\n    assert iter_biz_day(Tuesday, 3) == Friday;\n    assert iter_biz_day(Tuesday, 4) == Monday;\n    assert iter_biz_day(Tuesday, 5) == Tuesday;\n  case Wednesday =>\n    assert iter_biz_day(Wednesday, 1) == Thursday;\n    assert iter_biz_day(Wednesday, 2) == Friday;\n    assert iter_biz_day(Wednesday, 3) == Monday;\n    \n/*[CODE HERE]*/\n    assert iter_biz_day(Wednesday, 5) == Wednesday;\n  case Thursday =>\n    assert iter_biz_day(Thursday, 1) == Friday;\n    assert iter_biz_day(Thursday, 2) == Monday;\n    assert iter_biz_day(Thursday, 3) == Tuesday;\n    assert iter_biz_day(Thursday, 4) == Wednesday;\n    assert iter_biz_day(Thursday, 5) == Thursday;\n  case Friday =>\n    assert iter_biz_day(Friday, 1) == Monday;\n    assert iter_biz_day(Friday, 2) == Tuesday;\n    assert iter_biz_day(Friday, 3) == Wednesday;\n    assert iter_biz_day(Friday, 4) == Thursday;\n    assert iter_biz_day(Friday, 5) == Friday;\n}", "output": "assert iter_biz_day(Wednesday, 4) == Tuesday;"}, {"id": "example_iter5_biz_day_idempotent_12", "type": "assert", "program": "datatype Day = Sunday | Monday | Tuesday | Wednesday | Thursday | Friday | Saturday\n\nfunction next_biz_day(d: Day): Day\n{\n  match d\n  case Monday => Tuesday\n  case Tuesday => Wednesday\n  case Wednesday => Thursday\n  case Thursday => Friday\n  case Friday => Monday\n  case Saturday => Monday\n  case Sunday => Monday\n}\n\nfunction iter_biz_day(d: Day, n: nat): Day\n  decreases n\n{\n  if n == 0 then d\n  else iter_biz_day(next_biz_day(d), n - 1)\n}\n\nlemma iter5_biz_day_idempotent(d: Day)\n  requires d != Saturday && d != Sunday\n  ensures iter_biz_day(d, 5) == iter_biz_day(iter_biz_day(d, 5), 5)\n{\n  // 5 business days from any weekday brings you to the same weekday next week\n  match d\n  case Monday =>\n    assert iter_biz_day(Monday, 1) == Tuesday;\n    assert iter_biz_day(Monday, 2) == Wednesday;\n    assert iter_biz_day(Monday, 3) == Thursday;\n    assert iter_biz_day(Monday, 4) == Friday;\n    assert iter_biz_day(Monday, 5) == Monday;\n    assert iter_biz_day(Monday, 5) == Monday;\n    assert iter_biz_day(iter_biz_day(Monday, 5), 5) == iter_biz_day(Monday, 5);\n  case Tuesday =>\n    assert iter_biz_day(Tuesday, 1) == Wednesday;\n    assert iter_biz_day(Tuesday, 2) == Thursday;\n    assert iter_biz_day(Tuesday, 3) == Friday;\n    assert iter_biz_day(Tuesday, 4) == Monday;\n    assert iter_biz_day(Tuesday, 5) == Tuesday;\n  case Wednesday =>\n    assert iter_biz_day(Wednesday, 1) == Thursday;\n    assert iter_biz_day(Wednesday, 2) == Friday;\n    \n/*[CODE HERE]*/\n    assert iter_biz_day(Wednesday, 4) == Tuesday;\n    assert iter_biz_day(Wednesday, 5) == Wednesday;\n  case Thursday =>\n    assert iter_biz_day(Thursday, 1) == Friday;\n    assert iter_biz_day(Thursday, 2) == Monday;\n    assert iter_biz_day(Thursday, 3) == Tuesday;\n    assert iter_biz_day(Thursday, 4) == Wednesday;\n    assert iter_biz_day(Thursday, 5) == Thursday;\n  case Friday =>\n    assert iter_biz_day(Friday, 1) == Monday;\n    assert iter_biz_day(Friday, 2) == Tuesday;\n    assert iter_biz_day(Friday, 3) == Wednesday;\n    assert iter_biz_day(Friday, 4) == Thursday;\n    assert iter_biz_day(Friday, 5) == Friday;\n}", "output": "assert iter_biz_day(Wednesday, 3) == Monday;"}, {"id": "example_iter5_biz_day_idempotent_13", "type": "assert", "program": "datatype Day = Sunday | Monday | Tuesday | Wednesday | Thursday | Friday | Saturday\n\nfunction next_biz_day(d: Day): Day\n{\n  match d\n  case Monday => Tuesday\n  case Tuesday => Wednesday\n  case Wednesday => Thursday\n  case Thursday => Friday\n  case Friday => Monday\n  case Saturday => Monday\n  case Sunday => Monday\n}\n\nfunction iter_biz_day(d: Day, n: nat): Day\n  decreases n\n{\n  if n == 0 then d\n  else iter_biz_day(next_biz_day(d), n - 1)\n}\n\nlemma iter5_biz_day_idempotent(d: Day)\n  requires d != Saturday && d != Sunday\n  ensures iter_biz_day(d, 5) == iter_biz_day(iter_biz_day(d, 5), 5)\n{\n  // 5 business days from any weekday brings you to the same weekday next week\n  match d\n  case Monday =>\n    assert iter_biz_day(Monday, 1) == Tuesday;\n    assert iter_biz_day(Monday, 2) == Wednesday;\n    assert iter_biz_day(Monday, 3) == Thursday;\n    assert iter_biz_day(Monday, 4) == Friday;\n    assert iter_biz_day(Monday, 5) == Monday;\n    assert iter_biz_day(Monday, 5) == Monday;\n    assert iter_biz_day(iter_biz_day(Monday, 5), 5) == iter_biz_day(Monday, 5);\n  case Tuesday =>\n    assert iter_biz_day(Tuesday, 1) == Wednesday;\n    assert iter_biz_day(Tuesday, 2) == Thursday;\n    assert iter_biz_day(Tuesday, 3) == Friday;\n    assert iter_biz_day(Tuesday, 4) == Monday;\n    assert iter_biz_day(Tuesday, 5) == Tuesday;\n  case Wednesday =>\n    assert iter_biz_day(Wednesday, 1) == Thursday;\n    \n/*[CODE HERE]*/\n    assert iter_biz_day(Wednesday, 3) == Monday;\n    assert iter_biz_day(Wednesday, 4) == Tuesday;\n    assert iter_biz_day(Wednesday, 5) == Wednesday;\n  case Thursday =>\n    assert iter_biz_day(Thursday, 1) == Friday;\n    assert iter_biz_day(Thursday, 2) == Monday;\n    assert iter_biz_day(Thursday, 3) == Tuesday;\n    assert iter_biz_day(Thursday, 4) == Wednesday;\n    assert iter_biz_day(Thursday, 5) == Thursday;\n  case Friday =>\n    assert iter_biz_day(Friday, 1) == Monday;\n    assert iter_biz_day(Friday, 2) == Tuesday;\n    assert iter_biz_day(Friday, 3) == Wednesday;\n    assert iter_biz_day(Friday, 4) == Thursday;\n    assert iter_biz_day(Friday, 5) == Friday;\n}", "output": "assert iter_biz_day(Wednesday, 2) == Friday;"}, {"id": "example_iter5_biz_day_idempotent_14", "type": "assert", "program": "datatype Day = Sunday | Monday | Tuesday | Wednesday | Thursday | Friday | Saturday\n\nfunction next_biz_day(d: Day): Day\n{\n  match d\n  case Monday => Tuesday\n  case Tuesday => Wednesday\n  case Wednesday => Thursday\n  case Thursday => Friday\n  case Friday => Monday\n  case Saturday => Monday\n  case Sunday => Monday\n}\n\nfunction iter_biz_day(d: Day, n: nat): Day\n  decreases n\n{\n  if n == 0 then d\n  else iter_biz_day(next_biz_day(d), n - 1)\n}\n\nlemma iter5_biz_day_idempotent(d: Day)\n  requires d != Saturday && d != Sunday\n  ensures iter_biz_day(d, 5) == iter_biz_day(iter_biz_day(d, 5), 5)\n{\n  // 5 business days from any weekday brings you to the same weekday next week\n  match d\n  case Monday =>\n    assert iter_biz_day(Monday, 1) == Tuesday;\n    assert iter_biz_day(Monday, 2) == Wednesday;\n    assert iter_biz_day(Monday, 3) == Thursday;\n    assert iter_biz_day(Monday, 4) == Friday;\n    assert iter_biz_day(Monday, 5) == Monday;\n    assert iter_biz_day(Monday, 5) == Monday;\n    assert iter_biz_day(iter_biz_day(Monday, 5), 5) == iter_biz_day(Monday, 5);\n  case Tuesday =>\n    assert iter_biz_day(Tuesday, 1) == Wednesday;\n    assert iter_biz_day(Tuesday, 2) == Thursday;\n    assert iter_biz_day(Tuesday, 3) == Friday;\n    assert iter_biz_day(Tuesday, 4) == Monday;\n    assert iter_biz_day(Tuesday, 5) == Tuesday;\n  case Wednesday =>\n    \n/*[CODE HERE]*/\n    assert iter_biz_day(Wednesday, 2) == Friday;\n    assert iter_biz_day(Wednesday, 3) == Monday;\n    assert iter_biz_day(Wednesday, 4) == Tuesday;\n    assert iter_biz_day(Wednesday, 5) == Wednesday;\n  case Thursday =>\n    assert iter_biz_day(Thursday, 1) == Friday;\n    assert iter_biz_day(Thursday, 2) == Monday;\n    assert iter_biz_day(Thursday, 3) == Tuesday;\n    assert iter_biz_day(Thursday, 4) == Wednesday;\n    assert iter_biz_day(Thursday, 5) == Thursday;\n  case Friday =>\n    assert iter_biz_day(Friday, 1) == Monday;\n    assert iter_biz_day(Friday, 2) == Tuesday;\n    assert iter_biz_day(Friday, 3) == Wednesday;\n    assert iter_biz_day(Friday, 4) == Thursday;\n    assert iter_biz_day(Friday, 5) == Friday;\n}", "output": "assert iter_biz_day(Wednesday, 1) == Thursday;"}, {"id": "example_iter5_biz_day_idempotent_15", "type": "assert", "program": "datatype Day = Sunday | Monday | Tuesday | Wednesday | Thursday | Friday | Saturday\n\nfunction next_biz_day(d: Day): Day\n{\n  match d\n  case Monday => Tuesday\n  case Tuesday => Wednesday\n  case Wednesday => Thursday\n  case Thursday => Friday\n  case Friday => Monday\n  case Saturday => Monday\n  case Sunday => Monday\n}\n\nfunction iter_biz_day(d: Day, n: nat): Day\n  decreases n\n{\n  if n == 0 then d\n  else iter_biz_day(next_biz_day(d), n - 1)\n}\n\nlemma iter5_biz_day_idempotent(d: Day)\n  requires d != Saturday && d != Sunday\n  ensures iter_biz_day(d, 5) == iter_biz_day(iter_biz_day(d, 5), 5)\n{\n  // 5 business days from any weekday brings you to the same weekday next week\n  match d\n  case Monday =>\n    assert iter_biz_day(Monday, 1) == Tuesday;\n    assert iter_biz_day(Monday, 2) == Wednesday;\n    assert iter_biz_day(Monday, 3) == Thursday;\n    assert iter_biz_day(Monday, 4) == Friday;\n    assert iter_biz_day(Monday, 5) == Monday;\n    assert iter_biz_day(Monday, 5) == Monday;\n    assert iter_biz_day(iter_biz_day(Monday, 5), 5) == iter_biz_day(Monday, 5);\n  case Tuesday =>\n    assert iter_biz_day(Tuesday, 1) == Wednesday;\n    assert iter_biz_day(Tuesday, 2) == Thursday;\n    assert iter_biz_day(Tuesday, 3) == Friday;\n    assert iter_biz_day(Tuesday, 4) == Monday;\n    \n/*[CODE HERE]*/\n  case Wednesday =>\n    assert iter_biz_day(Wednesday, 1) == Thursday;\n    assert iter_biz_day(Wednesday, 2) == Friday;\n    assert iter_biz_day(Wednesday, 3) == Monday;\n    assert iter_biz_day(Wednesday, 4) == Tuesday;\n    assert iter_biz_day(Wednesday, 5) == Wednesday;\n  case Thursday =>\n    assert iter_biz_day(Thursday, 1) == Friday;\n    assert iter_biz_day(Thursday, 2) == Monday;\n    assert iter_biz_day(Thursday, 3) == Tuesday;\n    assert iter_biz_day(Thursday, 4) == Wednesday;\n    assert iter_biz_day(Thursday, 5) == Thursday;\n  case Friday =>\n    assert iter_biz_day(Friday, 1) == Monday;\n    assert iter_biz_day(Friday, 2) == Tuesday;\n    assert iter_biz_day(Friday, 3) == Wednesday;\n    assert iter_biz_day(Friday, 4) == Thursday;\n    assert iter_biz_day(Friday, 5) == Friday;\n}", "output": "assert iter_biz_day(Tuesday, 5) == Tuesday;"}, {"id": "example_iter5_biz_day_idempotent_16", "type": "assert", "program": "datatype Day = Sunday | Monday | Tuesday | Wednesday | Thursday | Friday | Saturday\n\nfunction next_biz_day(d: Day): Day\n{\n  match d\n  case Monday => Tuesday\n  case Tuesday => Wednesday\n  case Wednesday => Thursday\n  case Thursday => Friday\n  case Friday => Monday\n  case Saturday => Monday\n  case Sunday => Monday\n}\n\nfunction iter_biz_day(d: Day, n: nat): Day\n  decreases n\n{\n  if n == 0 then d\n  else iter_biz_day(next_biz_day(d), n - 1)\n}\n\nlemma iter5_biz_day_idempotent(d: Day)\n  requires d != Saturday && d != Sunday\n  ensures iter_biz_day(d, 5) == iter_biz_day(iter_biz_day(d, 5), 5)\n{\n  // 5 business days from any weekday brings you to the same weekday next week\n  match d\n  case Monday =>\n    assert iter_biz_day(Monday, 1) == Tuesday;\n    assert iter_biz_day(Monday, 2) == Wednesday;\n    assert iter_biz_day(Monday, 3) == Thursday;\n    assert iter_biz_day(Monday, 4) == Friday;\n    assert iter_biz_day(Monday, 5) == Monday;\n    assert iter_biz_day(Monday, 5) == Monday;\n    assert iter_biz_day(iter_biz_day(Monday, 5), 5) == iter_biz_day(Monday, 5);\n  case Tuesday =>\n    assert iter_biz_day(Tuesday, 1) == Wednesday;\n    assert iter_biz_day(Tuesday, 2) == Thursday;\n    assert iter_biz_day(Tuesday, 3) == Friday;\n    \n/*[CODE HERE]*/\n    assert iter_biz_day(Tuesday, 5) == Tuesday;\n  case Wednesday =>\n    assert iter_biz_day(Wednesday, 1) == Thursday;\n    assert iter_biz_day(Wednesday, 2) == Friday;\n    assert iter_biz_day(Wednesday, 3) == Monday;\n    assert iter_biz_day(Wednesday, 4) == Tuesday;\n    assert iter_biz_day(Wednesday, 5) == Wednesday;\n  case Thursday =>\n    assert iter_biz_day(Thursday, 1) == Friday;\n    assert iter_biz_day(Thursday, 2) == Monday;\n    assert iter_biz_day(Thursday, 3) == Tuesday;\n    assert iter_biz_day(Thursday, 4) == Wednesday;\n    assert iter_biz_day(Thursday, 5) == Thursday;\n  case Friday =>\n    assert iter_biz_day(Friday, 1) == Monday;\n    assert iter_biz_day(Friday, 2) == Tuesday;\n    assert iter_biz_day(Friday, 3) == Wednesday;\n    assert iter_biz_day(Friday, 4) == Thursday;\n    assert iter_biz_day(Friday, 5) == Friday;\n}", "output": "assert iter_biz_day(Tuesday, 4) == Monday;"}, {"id": "example_iter5_biz_day_idempotent_17", "type": "assert", "program": "datatype Day = Sunday | Monday | Tuesday | Wednesday | Thursday | Friday | Saturday\n\nfunction next_biz_day(d: Day): Day\n{\n  match d\n  case Monday => Tuesday\n  case Tuesday => Wednesday\n  case Wednesday => Thursday\n  case Thursday => Friday\n  case Friday => Monday\n  case Saturday => Monday\n  case Sunday => Monday\n}\n\nfunction iter_biz_day(d: Day, n: nat): Day\n  decreases n\n{\n  if n == 0 then d\n  else iter_biz_day(next_biz_day(d), n - 1)\n}\n\nlemma iter5_biz_day_idempotent(d: Day)\n  requires d != Saturday && d != Sunday\n  ensures iter_biz_day(d, 5) == iter_biz_day(iter_biz_day(d, 5), 5)\n{\n  // 5 business days from any weekday brings you to the same weekday next week\n  match d\n  case Monday =>\n    assert iter_biz_day(Monday, 1) == Tuesday;\n    assert iter_biz_day(Monday, 2) == Wednesday;\n    assert iter_biz_day(Monday, 3) == Thursday;\n    assert iter_biz_day(Monday, 4) == Friday;\n    assert iter_biz_day(Monday, 5) == Monday;\n    assert iter_biz_day(Monday, 5) == Monday;\n    assert iter_biz_day(iter_biz_day(Monday, 5), 5) == iter_biz_day(Monday, 5);\n  case Tuesday =>\n    assert iter_biz_day(Tuesday, 1) == Wednesday;\n    assert iter_biz_day(Tuesday, 2) == Thursday;\n    \n/*[CODE HERE]*/\n    assert iter_biz_day(Tuesday, 4) == Monday;\n    assert iter_biz_day(Tuesday, 5) == Tuesday;\n  case Wednesday =>\n    assert iter_biz_day(Wednesday, 1) == Thursday;\n    assert iter_biz_day(Wednesday, 2) == Friday;\n    assert iter_biz_day(Wednesday, 3) == Monday;\n    assert iter_biz_day(Wednesday, 4) == Tuesday;\n    assert iter_biz_day(Wednesday, 5) == Wednesday;\n  case Thursday =>\n    assert iter_biz_day(Thursday, 1) == Friday;\n    assert iter_biz_day(Thursday, 2) == Monday;\n    assert iter_biz_day(Thursday, 3) == Tuesday;\n    assert iter_biz_day(Thursday, 4) == Wednesday;\n    assert iter_biz_day(Thursday, 5) == Thursday;\n  case Friday =>\n    assert iter_biz_day(Friday, 1) == Monday;\n    assert iter_biz_day(Friday, 2) == Tuesday;\n    assert iter_biz_day(Friday, 3) == Wednesday;\n    assert iter_biz_day(Friday, 4) == Thursday;\n    assert iter_biz_day(Friday, 5) == Friday;\n}", "output": "assert iter_biz_day(Tuesday, 3) == Friday;"}, {"id": "example_iter5_biz_day_idempotent_18", "type": "assert", "program": "datatype Day = Sunday | Monday | Tuesday | Wednesday | Thursday | Friday | Saturday\n\nfunction next_biz_day(d: Day): Day\n{\n  match d\n  case Monday => Tuesday\n  case Tuesday => Wednesday\n  case Wednesday => Thursday\n  case Thursday => Friday\n  case Friday => Monday\n  case Saturday => Monday\n  case Sunday => Monday\n}\n\nfunction iter_biz_day(d: Day, n: nat): Day\n  decreases n\n{\n  if n == 0 then d\n  else iter_biz_day(next_biz_day(d), n - 1)\n}\n\nlemma iter5_biz_day_idempotent(d: Day)\n  requires d != Saturday && d != Sunday\n  ensures iter_biz_day(d, 5) == iter_biz_day(iter_biz_day(d, 5), 5)\n{\n  // 5 business days from any weekday brings you to the same weekday next week\n  match d\n  case Monday =>\n    assert iter_biz_day(Monday, 1) == Tuesday;\n    assert iter_biz_day(Monday, 2) == Wednesday;\n    assert iter_biz_day(Monday, 3) == Thursday;\n    assert iter_biz_day(Monday, 4) == Friday;\n    assert iter_biz_day(Monday, 5) == Monday;\n    assert iter_biz_day(Monday, 5) == Monday;\n    assert iter_biz_day(iter_biz_day(Monday, 5), 5) == iter_biz_day(Monday, 5);\n  case Tuesday =>\n    assert iter_biz_day(Tuesday, 1) == Wednesday;\n    \n/*[CODE HERE]*/\n    assert iter_biz_day(Tuesday, 3) == Friday;\n    assert iter_biz_day(Tuesday, 4) == Monday;\n    assert iter_biz_day(Tuesday, 5) == Tuesday;\n  case Wednesday =>\n    assert iter_biz_day(Wednesday, 1) == Thursday;\n    assert iter_biz_day(Wednesday, 2) == Friday;\n    assert iter_biz_day(Wednesday, 3) == Monday;\n    assert iter_biz_day(Wednesday, 4) == Tuesday;\n    assert iter_biz_day(Wednesday, 5) == Wednesday;\n  case Thursday =>\n    assert iter_biz_day(Thursday, 1) == Friday;\n    assert iter_biz_day(Thursday, 2) == Monday;\n    assert iter_biz_day(Thursday, 3) == Tuesday;\n    assert iter_biz_day(Thursday, 4) == Wednesday;\n    assert iter_biz_day(Thursday, 5) == Thursday;\n  case Friday =>\n    assert iter_biz_day(Friday, 1) == Monday;\n    assert iter_biz_day(Friday, 2) == Tuesday;\n    assert iter_biz_day(Friday, 3) == Wednesday;\n    assert iter_biz_day(Friday, 4) == Thursday;\n    assert iter_biz_day(Friday, 5) == Friday;\n}", "output": "assert iter_biz_day(Tuesday, 2) == Thursday;"}, {"id": "example_iter5_biz_day_idempotent_19", "type": "assert", "program": "datatype Day = Sunday | Monday | Tuesday | Wednesday | Thursday | Friday | Saturday\n\nfunction next_biz_day(d: Day): Day\n{\n  match d\n  case Monday => Tuesday\n  case Tuesday => Wednesday\n  case Wednesday => Thursday\n  case Thursday => Friday\n  case Friday => Monday\n  case Saturday => Monday\n  case Sunday => Monday\n}\n\nfunction iter_biz_day(d: Day, n: nat): Day\n  decreases n\n{\n  if n == 0 then d\n  else iter_biz_day(next_biz_day(d), n - 1)\n}\n\nlemma iter5_biz_day_idempotent(d: Day)\n  requires d != Saturday && d != Sunday\n  ensures iter_biz_day(d, 5) == iter_biz_day(iter_biz_day(d, 5), 5)\n{\n  // 5 business days from any weekday brings you to the same weekday next week\n  match d\n  case Monday =>\n    assert iter_biz_day(Monday, 1) == Tuesday;\n    assert iter_biz_day(Monday, 2) == Wednesday;\n    assert iter_biz_day(Monday, 3) == Thursday;\n    assert iter_biz_day(Monday, 4) == Friday;\n    assert iter_biz_day(Monday, 5) == Monday;\n    assert iter_biz_day(Monday, 5) == Monday;\n    assert iter_biz_day(iter_biz_day(Monday, 5), 5) == iter_biz_day(Monday, 5);\n  case Tuesday =>\n    \n/*[CODE HERE]*/\n    assert iter_biz_day(Tuesday, 2) == Thursday;\n    assert iter_biz_day(Tuesday, 3) == Friday;\n    assert iter_biz_day(Tuesday, 4) == Monday;\n    assert iter_biz_day(Tuesday, 5) == Tuesday;\n  case Wednesday =>\n    assert iter_biz_day(Wednesday, 1) == Thursday;\n    assert iter_biz_day(Wednesday, 2) == Friday;\n    assert iter_biz_day(Wednesday, 3) == Monday;\n    assert iter_biz_day(Wednesday, 4) == Tuesday;\n    assert iter_biz_day(Wednesday, 5) == Wednesday;\n  case Thursday =>\n    assert iter_biz_day(Thursday, 1) == Friday;\n    assert iter_biz_day(Thursday, 2) == Monday;\n    assert iter_biz_day(Thursday, 3) == Tuesday;\n    assert iter_biz_day(Thursday, 4) == Wednesday;\n    assert iter_biz_day(Thursday, 5) == Thursday;\n  case Friday =>\n    assert iter_biz_day(Friday, 1) == Monday;\n    assert iter_biz_day(Friday, 2) == Tuesday;\n    assert iter_biz_day(Friday, 3) == Wednesday;\n    assert iter_biz_day(Friday, 4) == Thursday;\n    assert iter_biz_day(Friday, 5) == Friday;\n}", "output": "assert iter_biz_day(Tuesday, 1) == Wednesday;"}, {"id": "example_iter5_biz_day_idempotent_20", "type": "assert", "program": "datatype Day = Sunday | Monday | Tuesday | Wednesday | Thursday | Friday | Saturday\n\nfunction next_biz_day(d: Day): Day\n{\n  match d\n  case Monday => Tuesday\n  case Tuesday => Wednesday\n  case Wednesday => Thursday\n  case Thursday => Friday\n  case Friday => Monday\n  case Saturday => Monday\n  case Sunday => Monday\n}\n\nfunction iter_biz_day(d: Day, n: nat): Day\n  decreases n\n{\n  if n == 0 then d\n  else iter_biz_day(next_biz_day(d), n - 1)\n}\n\nlemma iter5_biz_day_idempotent(d: Day)\n  requires d != Saturday && d != Sunday\n  ensures iter_biz_day(d, 5) == iter_biz_day(iter_biz_day(d, 5), 5)\n{\n  // 5 business days from any weekday brings you to the same weekday next week\n  match d\n  case Monday =>\n    assert iter_biz_day(Monday, 1) == Tuesday;\n    assert iter_biz_day(Monday, 2) == Wednesday;\n    assert iter_biz_day(Monday, 3) == Thursday;\n    assert iter_biz_day(Monday, 4) == Friday;\n    assert iter_biz_day(Monday, 5) == Monday;\n    assert iter_biz_day(Monday, 5) == Monday;\n    \n/*[CODE HERE]*/\n  case Tuesday =>\n    assert iter_biz_day(Tuesday, 1) == Wednesday;\n    assert iter_biz_day(Tuesday, 2) == Thursday;\n    assert iter_biz_day(Tuesday, 3) == Friday;\n    assert iter_biz_day(Tuesday, 4) == Monday;\n    assert iter_biz_day(Tuesday, 5) == Tuesday;\n  case Wednesday =>\n    assert iter_biz_day(Wednesday, 1) == Thursday;\n    assert iter_biz_day(Wednesday, 2) == Friday;\n    assert iter_biz_day(Wednesday, 3) == Monday;\n    assert iter_biz_day(Wednesday, 4) == Tuesday;\n    assert iter_biz_day(Wednesday, 5) == Wednesday;\n  case Thursday =>\n    assert iter_biz_day(Thursday, 1) == Friday;\n    assert iter_biz_day(Thursday, 2) == Monday;\n    assert iter_biz_day(Thursday, 3) == Tuesday;\n    assert iter_biz_day(Thursday, 4) == Wednesday;\n    assert iter_biz_day(Thursday, 5) == Thursday;\n  case Friday =>\n    assert iter_biz_day(Friday, 1) == Monday;\n    assert iter_biz_day(Friday, 2) == Tuesday;\n    assert iter_biz_day(Friday, 3) == Wednesday;\n    assert iter_biz_day(Friday, 4) == Thursday;\n    assert iter_biz_day(Friday, 5) == Friday;\n}", "output": "assert iter_biz_day(iter_biz_day(Monday, 5), 5) == iter_biz_day(Monday, 5);"}, {"id": "example_iter5_biz_day_idempotent_21", "type": "assert", "program": "datatype Day = Sunday | Monday | Tuesday | Wednesday | Thursday | Friday | Saturday\n\nfunction next_biz_day(d: Day): Day\n{\n  match d\n  case Monday => Tuesday\n  case Tuesday => Wednesday\n  case Wednesday => Thursday\n  case Thursday => Friday\n  case Friday => Monday\n  case Saturday => Monday\n  case Sunday => Monday\n}\n\nfunction iter_biz_day(d: Day, n: nat): Day\n  decreases n\n{\n  if n == 0 then d\n  else iter_biz_day(next_biz_day(d), n - 1)\n}\n\nlemma iter5_biz_day_idempotent(d: Day)\n  requires d != Saturday && d != Sunday\n  ensures iter_biz_day(d, 5) == iter_biz_day(iter_biz_day(d, 5), 5)\n{\n  // 5 business days from any weekday brings you to the same weekday next week\n  match d\n  case Monday =>\n    assert iter_biz_day(Monday, 1) == Tuesday;\n    assert iter_biz_day(Monday, 2) == Wednesday;\n    assert iter_biz_day(Monday, 3) == Thursday;\n    assert iter_biz_day(Monday, 4) == Friday;\n    assert iter_biz_day(Monday, 5) == Monday;\n    \n/*[CODE HERE]*/\n    assert iter_biz_day(iter_biz_day(Monday, 5), 5) == iter_biz_day(Monday, 5);\n  case Tuesday =>\n    assert iter_biz_day(Tuesday, 1) == Wednesday;\n    assert iter_biz_day(Tuesday, 2) == Thursday;\n    assert iter_biz_day(Tuesday, 3) == Friday;\n    assert iter_biz_day(Tuesday, 4) == Monday;\n    assert iter_biz_day(Tuesday, 5) == Tuesday;\n  case Wednesday =>\n    assert iter_biz_day(Wednesday, 1) == Thursday;\n    assert iter_biz_day(Wednesday, 2) == Friday;\n    assert iter_biz_day(Wednesday, 3) == Monday;\n    assert iter_biz_day(Wednesday, 4) == Tuesday;\n    assert iter_biz_day(Wednesday, 5) == Wednesday;\n  case Thursday =>\n    assert iter_biz_day(Thursday, 1) == Friday;\n    assert iter_biz_day(Thursday, 2) == Monday;\n    assert iter_biz_day(Thursday, 3) == Tuesday;\n    assert iter_biz_day(Thursday, 4) == Wednesday;\n    assert iter_biz_day(Thursday, 5) == Thursday;\n  case Friday =>\n    assert iter_biz_day(Friday, 1) == Monday;\n    assert iter_biz_day(Friday, 2) == Tuesday;\n    assert iter_biz_day(Friday, 3) == Wednesday;\n    assert iter_biz_day(Friday, 4) == Thursday;\n    assert iter_biz_day(Friday, 5) == Friday;\n}", "output": "assert iter_biz_day(Monday, 5) == Monday;"}, {"id": "example_iter5_biz_day_idempotent_22", "type": "assert", "program": "datatype Day = Sunday | Monday | Tuesday | Wednesday | Thursday | Friday | Saturday\n\nfunction next_biz_day(d: Day): Day\n{\n  match d\n  case Monday => Tuesday\n  case Tuesday => Wednesday\n  case Wednesday => Thursday\n  case Thursday => Friday\n  case Friday => Monday\n  case Saturday => Monday\n  case Sunday => Monday\n}\n\nfunction iter_biz_day(d: Day, n: nat): Day\n  decreases n\n{\n  if n == 0 then d\n  else iter_biz_day(next_biz_day(d), n - 1)\n}\n\nlemma iter5_biz_day_idempotent(d: Day)\n  requires d != Saturday && d != Sunday\n  ensures iter_biz_day(d, 5) == iter_biz_day(iter_biz_day(d, 5), 5)\n{\n  // 5 business days from any weekday brings you to the same weekday next week\n  match d\n  case Monday =>\n    assert iter_biz_day(Monday, 1) == Tuesday;\n    assert iter_biz_day(Monday, 2) == Wednesday;\n    assert iter_biz_day(Monday, 3) == Thursday;\n    assert iter_biz_day(Monday, 4) == Friday;\n    \n/*[CODE HERE]*/\n    assert iter_biz_day(Monday, 5) == Monday;\n    assert iter_biz_day(iter_biz_day(Monday, 5), 5) == iter_biz_day(Monday, 5);\n  case Tuesday =>\n    assert iter_biz_day(Tuesday, 1) == Wednesday;\n    assert iter_biz_day(Tuesday, 2) == Thursday;\n    assert iter_biz_day(Tuesday, 3) == Friday;\n    assert iter_biz_day(Tuesday, 4) == Monday;\n    assert iter_biz_day(Tuesday, 5) == Tuesday;\n  case Wednesday =>\n    assert iter_biz_day(Wednesday, 1) == Thursday;\n    assert iter_biz_day(Wednesday, 2) == Friday;\n    assert iter_biz_day(Wednesday, 3) == Monday;\n    assert iter_biz_day(Wednesday, 4) == Tuesday;\n    assert iter_biz_day(Wednesday, 5) == Wednesday;\n  case Thursday =>\n    assert iter_biz_day(Thursday, 1) == Friday;\n    assert iter_biz_day(Thursday, 2) == Monday;\n    assert iter_biz_day(Thursday, 3) == Tuesday;\n    assert iter_biz_day(Thursday, 4) == Wednesday;\n    assert iter_biz_day(Thursday, 5) == Thursday;\n  case Friday =>\n    assert iter_biz_day(Friday, 1) == Monday;\n    assert iter_biz_day(Friday, 2) == Tuesday;\n    assert iter_biz_day(Friday, 3) == Wednesday;\n    assert iter_biz_day(Friday, 4) == Thursday;\n    assert iter_biz_day(Friday, 5) == Friday;\n}", "output": "assert iter_biz_day(Monday, 5) == Monday;"}, {"id": "example_iter5_biz_day_idempotent_23", "type": "assert", "program": "datatype Day = Sunday | Monday | Tuesday | Wednesday | Thursday | Friday | Saturday\n\nfunction next_biz_day(d: Day): Day\n{\n  match d\n  case Monday => Tuesday\n  case Tuesday => Wednesday\n  case Wednesday => Thursday\n  case Thursday => Friday\n  case Friday => Monday\n  case Saturday => Monday\n  case Sunday => Monday\n}\n\nfunction iter_biz_day(d: Day, n: nat): Day\n  decreases n\n{\n  if n == 0 then d\n  else iter_biz_day(next_biz_day(d), n - 1)\n}\n\nlemma iter5_biz_day_idempotent(d: Day)\n  requires d != Saturday && d != Sunday\n  ensures iter_biz_day(d, 5) == iter_biz_day(iter_biz_day(d, 5), 5)\n{\n  // 5 business days from any weekday brings you to the same weekday next week\n  match d\n  case Monday =>\n    assert iter_biz_day(Monday, 1) == Tuesday;\n    assert iter_biz_day(Monday, 2) == Wednesday;\n    assert iter_biz_day(Monday, 3) == Thursday;\n    \n/*[CODE HERE]*/\n    assert iter_biz_day(Monday, 5) == Monday;\n    assert iter_biz_day(Monday, 5) == Monday;\n    assert iter_biz_day(iter_biz_day(Monday, 5), 5) == iter_biz_day(Monday, 5);\n  case Tuesday =>\n    assert iter_biz_day(Tuesday, 1) == Wednesday;\n    assert iter_biz_day(Tuesday, 2) == Thursday;\n    assert iter_biz_day(Tuesday, 3) == Friday;\n    assert iter_biz_day(Tuesday, 4) == Monday;\n    assert iter_biz_day(Tuesday, 5) == Tuesday;\n  case Wednesday =>\n    assert iter_biz_day(Wednesday, 1) == Thursday;\n    assert iter_biz_day(Wednesday, 2) == Friday;\n    assert iter_biz_day(Wednesday, 3) == Monday;\n    assert iter_biz_day(Wednesday, 4) == Tuesday;\n    assert iter_biz_day(Wednesday, 5) == Wednesday;\n  case Thursday =>\n    assert iter_biz_day(Thursday, 1) == Friday;\n    assert iter_biz_day(Thursday, 2) == Monday;\n    assert iter_biz_day(Thursday, 3) == Tuesday;\n    assert iter_biz_day(Thursday, 4) == Wednesday;\n    assert iter_biz_day(Thursday, 5) == Thursday;\n  case Friday =>\n    assert iter_biz_day(Friday, 1) == Monday;\n    assert iter_biz_day(Friday, 2) == Tuesday;\n    assert iter_biz_day(Friday, 3) == Wednesday;\n    assert iter_biz_day(Friday, 4) == Thursday;\n    assert iter_biz_day(Friday, 5) == Friday;\n}", "output": "assert iter_biz_day(Monday, 4) == Friday;"}, {"id": "example_iter5_biz_day_idempotent_24", "type": "assert", "program": "datatype Day = Sunday | Monday | Tuesday | Wednesday | Thursday | Friday | Saturday\n\nfunction next_biz_day(d: Day): Day\n{\n  match d\n  case Monday => Tuesday\n  case Tuesday => Wednesday\n  case Wednesday => Thursday\n  case Thursday => Friday\n  case Friday => Monday\n  case Saturday => Monday\n  case Sunday => Monday\n}\n\nfunction iter_biz_day(d: Day, n: nat): Day\n  decreases n\n{\n  if n == 0 then d\n  else iter_biz_day(next_biz_day(d), n - 1)\n}\n\nlemma iter5_biz_day_idempotent(d: Day)\n  requires d != Saturday && d != Sunday\n  ensures iter_biz_day(d, 5) == iter_biz_day(iter_biz_day(d, 5), 5)\n{\n  // 5 business days from any weekday brings you to the same weekday next week\n  match d\n  case Monday =>\n    assert iter_biz_day(Monday, 1) == Tuesday;\n    assert iter_biz_day(Monday, 2) == Wednesday;\n    \n/*[CODE HERE]*/\n    assert iter_biz_day(Monday, 4) == Friday;\n    assert iter_biz_day(Monday, 5) == Monday;\n    assert iter_biz_day(Monday, 5) == Monday;\n    assert iter_biz_day(iter_biz_day(Monday, 5), 5) == iter_biz_day(Monday, 5);\n  case Tuesday =>\n    assert iter_biz_day(Tuesday, 1) == Wednesday;\n    assert iter_biz_day(Tuesday, 2) == Thursday;\n    assert iter_biz_day(Tuesday, 3) == Friday;\n    assert iter_biz_day(Tuesday, 4) == Monday;\n    assert iter_biz_day(Tuesday, 5) == Tuesday;\n  case Wednesday =>\n    assert iter_biz_day(Wednesday, 1) == Thursday;\n    assert iter_biz_day(Wednesday, 2) == Friday;\n    assert iter_biz_day(Wednesday, 3) == Monday;\n    assert iter_biz_day(Wednesday, 4) == Tuesday;\n    assert iter_biz_day(Wednesday, 5) == Wednesday;\n  case Thursday =>\n    assert iter_biz_day(Thursday, 1) == Friday;\n    assert iter_biz_day(Thursday, 2) == Monday;\n    assert iter_biz_day(Thursday, 3) == Tuesday;\n    assert iter_biz_day(Thursday, 4) == Wednesday;\n    assert iter_biz_day(Thursday, 5) == Thursday;\n  case Friday =>\n    assert iter_biz_day(Friday, 1) == Monday;\n    assert iter_biz_day(Friday, 2) == Tuesday;\n    assert iter_biz_day(Friday, 3) == Wednesday;\n    assert iter_biz_day(Friday, 4) == Thursday;\n    assert iter_biz_day(Friday, 5) == Friday;\n}", "output": "assert iter_biz_day(Monday, 3) == Thursday;"}, {"id": "example_iter5_biz_day_idempotent_25", "type": "assert", "program": "datatype Day = Sunday | Monday | Tuesday | Wednesday | Thursday | Friday | Saturday\n\nfunction next_biz_day(d: Day): Day\n{\n  match d\n  case Monday => Tuesday\n  case Tuesday => Wednesday\n  case Wednesday => Thursday\n  case Thursday => Friday\n  case Friday => Monday\n  case Saturday => Monday\n  case Sunday => Monday\n}\n\nfunction iter_biz_day(d: Day, n: nat): Day\n  decreases n\n{\n  if n == 0 then d\n  else iter_biz_day(next_biz_day(d), n - 1)\n}\n\nlemma iter5_biz_day_idempotent(d: Day)\n  requires d != Saturday && d != Sunday\n  ensures iter_biz_day(d, 5) == iter_biz_day(iter_biz_day(d, 5), 5)\n{\n  // 5 business days from any weekday brings you to the same weekday next week\n  match d\n  case Monday =>\n    assert iter_biz_day(Monday, 1) == Tuesday;\n    \n/*[CODE HERE]*/\n    assert iter_biz_day(Monday, 3) == Thursday;\n    assert iter_biz_day(Monday, 4) == Friday;\n    assert iter_biz_day(Monday, 5) == Monday;\n    assert iter_biz_day(Monday, 5) == Monday;\n    assert iter_biz_day(iter_biz_day(Monday, 5), 5) == iter_biz_day(Monday, 5);\n  case Tuesday =>\n    assert iter_biz_day(Tuesday, 1) == Wednesday;\n    assert iter_biz_day(Tuesday, 2) == Thursday;\n    assert iter_biz_day(Tuesday, 3) == Friday;\n    assert iter_biz_day(Tuesday, 4) == Monday;\n    assert iter_biz_day(Tuesday, 5) == Tuesday;\n  case Wednesday =>\n    assert iter_biz_day(Wednesday, 1) == Thursday;\n    assert iter_biz_day(Wednesday, 2) == Friday;\n    assert iter_biz_day(Wednesday, 3) == Monday;\n    assert iter_biz_day(Wednesday, 4) == Tuesday;\n    assert iter_biz_day(Wednesday, 5) == Wednesday;\n  case Thursday =>\n    assert iter_biz_day(Thursday, 1) == Friday;\n    assert iter_biz_day(Thursday, 2) == Monday;\n    assert iter_biz_day(Thursday, 3) == Tuesday;\n    assert iter_biz_day(Thursday, 4) == Wednesday;\n    assert iter_biz_day(Thursday, 5) == Thursday;\n  case Friday =>\n    assert iter_biz_day(Friday, 1) == Monday;\n    assert iter_biz_day(Friday, 2) == Tuesday;\n    assert iter_biz_day(Friday, 3) == Wednesday;\n    assert iter_biz_day(Friday, 4) == Thursday;\n    assert iter_biz_day(Friday, 5) == Friday;\n}", "output": "assert iter_biz_day(Monday, 2) == Wednesday;"}, {"id": "example_iter5_biz_day_idempotent_26", "type": "assert", "program": "datatype Day = Sunday | Monday | Tuesday | Wednesday | Thursday | Friday | Saturday\n\nfunction next_biz_day(d: Day): Day\n{\n  match d\n  case Monday => Tuesday\n  case Tuesday => Wednesday\n  case Wednesday => Thursday\n  case Thursday => Friday\n  case Friday => Monday\n  case Saturday => Monday\n  case Sunday => Monday\n}\n\nfunction iter_biz_day(d: Day, n: nat): Day\n  decreases n\n{\n  if n == 0 then d\n  else iter_biz_day(next_biz_day(d), n - 1)\n}\n\nlemma iter5_biz_day_idempotent(d: Day)\n  requires d != Saturday && d != Sunday\n  ensures iter_biz_day(d, 5) == iter_biz_day(iter_biz_day(d, 5), 5)\n{\n  // 5 business days from any weekday brings you to the same weekday next week\n  match d\n  case Monday =>\n    \n/*[CODE HERE]*/\n    assert iter_biz_day(Monday, 2) == Wednesday;\n    assert iter_biz_day(Monday, 3) == Thursday;\n    assert iter_biz_day(Monday, 4) == Friday;\n    assert iter_biz_day(Monday, 5) == Monday;\n    assert iter_biz_day(Monday, 5) == Monday;\n    assert iter_biz_day(iter_biz_day(Monday, 5), 5) == iter_biz_day(Monday, 5);\n  case Tuesday =>\n    assert iter_biz_day(Tuesday, 1) == Wednesday;\n    assert iter_biz_day(Tuesday, 2) == Thursday;\n    assert iter_biz_day(Tuesday, 3) == Friday;\n    assert iter_biz_day(Tuesday, 4) == Monday;\n    assert iter_biz_day(Tuesday, 5) == Tuesday;\n  case Wednesday =>\n    assert iter_biz_day(Wednesday, 1) == Thursday;\n    assert iter_biz_day(Wednesday, 2) == Friday;\n    assert iter_biz_day(Wednesday, 3) == Monday;\n    assert iter_biz_day(Wednesday, 4) == Tuesday;\n    assert iter_biz_day(Wednesday, 5) == Wednesday;\n  case Thursday =>\n    assert iter_biz_day(Thursday, 1) == Friday;\n    assert iter_biz_day(Thursday, 2) == Monday;\n    assert iter_biz_day(Thursday, 3) == Tuesday;\n    assert iter_biz_day(Thursday, 4) == Wednesday;\n    assert iter_biz_day(Thursday, 5) == Thursday;\n  case Friday =>\n    assert iter_biz_day(Friday, 1) == Monday;\n    assert iter_biz_day(Friday, 2) == Tuesday;\n    assert iter_biz_day(Friday, 3) == Wednesday;\n    assert iter_biz_day(Friday, 4) == Thursday;\n    assert iter_biz_day(Friday, 5) == Friday;\n}", "output": "assert iter_biz_day(Monday, 1) == Tuesday;"}, {"id": "example_dedupCorrect_0", "type": "assert", "program": "function dedup(xs: seq<int>): seq<int>\n{\n  if |xs| == 0 then []\n  else if xs[0] in dedup(xs[1..]) then dedup(xs[1..])\n  else [xs[0]] + dedup(xs[1..])\n}\n\npredicate {:spec} noDuplicates(xs: seq<int>)\n{\n  forall i, j :: 0 <= i < j < |xs| ==> xs[i] != xs[j]\n}\n\nfunction {:spec} toSet(xs: seq<int>): set<int>\n{\n  set x | x in xs\n}\n\nlemma dedupCorrect(xs: seq<int>)\n  ensures noDuplicates(dedup(xs))\n  ensures toSet(dedup(xs)) == toSet(xs)\n{\n  if |xs| == 0 {\n  } else {\n    dedupCorrect(xs[1..]);\n    var rest := dedup(xs[1..]);\n    \n    if xs[0] in rest {\n      assert dedup(xs) == rest;\n      assert xs[0] in rest;\n      assert toSet(rest) == toSet(xs[1..]);\n      assert xs[0] in xs[1..];\n      assert toSet(xs) == toSet(xs[1..]) + {xs[0]};\n      assert toSet(xs) == toSet(xs[1..]);\n    } else {\n      assert dedup(xs) == [xs[0]] + rest;\n      assert noDuplicates(rest);\n      assert !(xs[0] in rest);\n      \n      forall i, j | 0 <= i < j < |dedup(xs)|\n        ensures dedup(xs)[i] != dedup(xs)[j]\n      {\n        if i == 0 {\n          assert dedup(xs)[0] == xs[0];\n          assert dedup(xs)[j] == rest[j-1];\n          assert !(xs[0] in rest);\n        } else {\n          assert dedup(xs)[i] == rest[i-1];\n          assert dedup(xs)[j] == rest[j-1];\n        }\n      }\n      \n      assert toSet(dedup(xs)) == toSet([xs[0]] + rest);\n      assert toSet([xs[0]] + rest) == {xs[0]} + toSet(rest);\n      assert toSet(rest) == toSet(xs[1..]);\n      \n/*[CODE HERE]*/\n    }\n  }\n}", "output": "assert toSet(xs) == {xs[0]} + toSet(xs[1..]);"}, {"id": "example_dedupCorrect_1", "type": "assert", "program": "function dedup(xs: seq<int>): seq<int>\n{\n  if |xs| == 0 then []\n  else if xs[0] in dedup(xs[1..]) then dedup(xs[1..])\n  else [xs[0]] + dedup(xs[1..])\n}\n\npredicate {:spec} noDuplicates(xs: seq<int>)\n{\n  forall i, j :: 0 <= i < j < |xs| ==> xs[i] != xs[j]\n}\n\nfunction {:spec} toSet(xs: seq<int>): set<int>\n{\n  set x | x in xs\n}\n\nlemma dedupCorrect(xs: seq<int>)\n  ensures noDuplicates(dedup(xs))\n  ensures toSet(dedup(xs)) == toSet(xs)\n{\n  if |xs| == 0 {\n  } else {\n    dedupCorrect(xs[1..]);\n    var rest := dedup(xs[1..]);\n    \n    if xs[0] in rest {\n      assert dedup(xs) == rest;\n      assert xs[0] in rest;\n      assert toSet(rest) == toSet(xs[1..]);\n      assert xs[0] in xs[1..];\n      assert toSet(xs) == toSet(xs[1..]) + {xs[0]};\n      assert toSet(xs) == toSet(xs[1..]);\n    } else {\n      assert dedup(xs) == [xs[0]] + rest;\n      assert noDuplicates(rest);\n      assert !(xs[0] in rest);\n      \n      forall i, j | 0 <= i < j < |dedup(xs)|\n        ensures dedup(xs)[i] != dedup(xs)[j]\n      {\n        if i == 0 {\n          assert dedup(xs)[0] == xs[0];\n          assert dedup(xs)[j] == rest[j-1];\n          assert !(xs[0] in rest);\n        } else {\n          assert dedup(xs)[i] == rest[i-1];\n          assert dedup(xs)[j] == rest[j-1];\n        }\n      }\n      \n      assert toSet(dedup(xs)) == toSet([xs[0]] + rest);\n      assert toSet([xs[0]] + rest) == {xs[0]} + toSet(rest);\n      \n/*[CODE HERE]*/\n      assert toSet(xs) == {xs[0]} + toSet(xs[1..]);\n    }\n  }\n}", "output": "assert toSet(rest) == toSet(xs[1..]);"}, {"id": "example_dedupCorrect_2", "type": "assert", "program": "function dedup(xs: seq<int>): seq<int>\n{\n  if |xs| == 0 then []\n  else if xs[0] in dedup(xs[1..]) then dedup(xs[1..])\n  else [xs[0]] + dedup(xs[1..])\n}\n\npredicate {:spec} noDuplicates(xs: seq<int>)\n{\n  forall i, j :: 0 <= i < j < |xs| ==> xs[i] != xs[j]\n}\n\nfunction {:spec} toSet(xs: seq<int>): set<int>\n{\n  set x | x in xs\n}\n\nlemma dedupCorrect(xs: seq<int>)\n  ensures noDuplicates(dedup(xs))\n  ensures toSet(dedup(xs)) == toSet(xs)\n{\n  if |xs| == 0 {\n  } else {\n    dedupCorrect(xs[1..]);\n    var rest := dedup(xs[1..]);\n    \n    if xs[0] in rest {\n      assert dedup(xs) == rest;\n      assert xs[0] in rest;\n      assert toSet(rest) == toSet(xs[1..]);\n      assert xs[0] in xs[1..];\n      assert toSet(xs) == toSet(xs[1..]) + {xs[0]};\n      assert toSet(xs) == toSet(xs[1..]);\n    } else {\n      assert dedup(xs) == [xs[0]] + rest;\n      assert noDuplicates(rest);\n      assert !(xs[0] in rest);\n      \n      forall i, j | 0 <= i < j < |dedup(xs)|\n        ensures dedup(xs)[i] != dedup(xs)[j]\n      {\n        if i == 0 {\n          assert dedup(xs)[0] == xs[0];\n          assert dedup(xs)[j] == rest[j-1];\n          assert !(xs[0] in rest);\n        } else {\n          assert dedup(xs)[i] == rest[i-1];\n          assert dedup(xs)[j] == rest[j-1];\n        }\n      }\n      \n      assert toSet(dedup(xs)) == toSet([xs[0]] + rest);\n      \n/*[CODE HERE]*/\n      assert toSet(rest) == toSet(xs[1..]);\n      assert toSet(xs) == {xs[0]} + toSet(xs[1..]);\n    }\n  }\n}", "output": "assert toSet([xs[0]] + rest) == {xs[0]} + toSet(rest);"}, {"id": "example_dedupCorrect_3", "type": "assert", "program": "function dedup(xs: seq<int>): seq<int>\n{\n  if |xs| == 0 then []\n  else if xs[0] in dedup(xs[1..]) then dedup(xs[1..])\n  else [xs[0]] + dedup(xs[1..])\n}\n\npredicate {:spec} noDuplicates(xs: seq<int>)\n{\n  forall i, j :: 0 <= i < j < |xs| ==> xs[i] != xs[j]\n}\n\nfunction {:spec} toSet(xs: seq<int>): set<int>\n{\n  set x | x in xs\n}\n\nlemma dedupCorrect(xs: seq<int>)\n  ensures noDuplicates(dedup(xs))\n  ensures toSet(dedup(xs)) == toSet(xs)\n{\n  if |xs| == 0 {\n  } else {\n    dedupCorrect(xs[1..]);\n    var rest := dedup(xs[1..]);\n    \n    if xs[0] in rest {\n      assert dedup(xs) == rest;\n      assert xs[0] in rest;\n      assert toSet(rest) == toSet(xs[1..]);\n      assert xs[0] in xs[1..];\n      assert toSet(xs) == toSet(xs[1..]) + {xs[0]};\n      assert toSet(xs) == toSet(xs[1..]);\n    } else {\n      assert dedup(xs) == [xs[0]] + rest;\n      assert noDuplicates(rest);\n      assert !(xs[0] in rest);\n      \n      forall i, j | 0 <= i < j < |dedup(xs)|\n        ensures dedup(xs)[i] != dedup(xs)[j]\n      {\n        if i == 0 {\n          assert dedup(xs)[0] == xs[0];\n          assert dedup(xs)[j] == rest[j-1];\n          assert !(xs[0] in rest);\n        } else {\n          assert dedup(xs)[i] == rest[i-1];\n          assert dedup(xs)[j] == rest[j-1];\n        }\n      }\n      \n      \n/*[CODE HERE]*/\n      assert toSet([xs[0]] + rest) == {xs[0]} + toSet(rest);\n      assert toSet(rest) == toSet(xs[1..]);\n      assert toSet(xs) == {xs[0]} + toSet(xs[1..]);\n    }\n  }\n}", "output": "assert toSet(dedup(xs)) == toSet([xs[0]] + rest);"}, {"id": "example_dedupCorrect_4", "type": "assert", "program": "function dedup(xs: seq<int>): seq<int>\n{\n  if |xs| == 0 then []\n  else if xs[0] in dedup(xs[1..]) then dedup(xs[1..])\n  else [xs[0]] + dedup(xs[1..])\n}\n\npredicate {:spec} noDuplicates(xs: seq<int>)\n{\n  forall i, j :: 0 <= i < j < |xs| ==> xs[i] != xs[j]\n}\n\nfunction {:spec} toSet(xs: seq<int>): set<int>\n{\n  set x | x in xs\n}\n\nlemma dedupCorrect(xs: seq<int>)\n  ensures noDuplicates(dedup(xs))\n  ensures toSet(dedup(xs)) == toSet(xs)\n{\n  if |xs| == 0 {\n  } else {\n    dedupCorrect(xs[1..]);\n    var rest := dedup(xs[1..]);\n    \n    if xs[0] in rest {\n      assert dedup(xs) == rest;\n      assert xs[0] in rest;\n      assert toSet(rest) == toSet(xs[1..]);\n      assert xs[0] in xs[1..];\n      assert toSet(xs) == toSet(xs[1..]) + {xs[0]};\n      assert toSet(xs) == toSet(xs[1..]);\n    } else {\n      assert dedup(xs) == [xs[0]] + rest;\n      assert noDuplicates(rest);\n      assert !(xs[0] in rest);\n      \n      forall i, j | 0 <= i < j < |dedup(xs)|\n        ensures dedup(xs)[i] != dedup(xs)[j]\n      {\n        if i == 0 {\n          assert dedup(xs)[0] == xs[0];\n          assert dedup(xs)[j] == rest[j-1];\n          assert !(xs[0] in rest);\n        } else {\n          assert dedup(xs)[i] == rest[i-1];\n          \n/*[CODE HERE]*/\n        }\n      }\n      \n      assert toSet(dedup(xs)) == toSet([xs[0]] + rest);\n      assert toSet([xs[0]] + rest) == {xs[0]} + toSet(rest);\n      assert toSet(rest) == toSet(xs[1..]);\n      assert toSet(xs) == {xs[0]} + toSet(xs[1..]);\n    }\n  }\n}", "output": "assert dedup(xs)[j] == rest[j-1];"}, {"id": "example_dedupCorrect_5", "type": "assert", "program": "function dedup(xs: seq<int>): seq<int>\n{\n  if |xs| == 0 then []\n  else if xs[0] in dedup(xs[1..]) then dedup(xs[1..])\n  else [xs[0]] + dedup(xs[1..])\n}\n\npredicate {:spec} noDuplicates(xs: seq<int>)\n{\n  forall i, j :: 0 <= i < j < |xs| ==> xs[i] != xs[j]\n}\n\nfunction {:spec} toSet(xs: seq<int>): set<int>\n{\n  set x | x in xs\n}\n\nlemma dedupCorrect(xs: seq<int>)\n  ensures noDuplicates(dedup(xs))\n  ensures toSet(dedup(xs)) == toSet(xs)\n{\n  if |xs| == 0 {\n  } else {\n    dedupCorrect(xs[1..]);\n    var rest := dedup(xs[1..]);\n    \n    if xs[0] in rest {\n      assert dedup(xs) == rest;\n      assert xs[0] in rest;\n      assert toSet(rest) == toSet(xs[1..]);\n      assert xs[0] in xs[1..];\n      assert toSet(xs) == toSet(xs[1..]) + {xs[0]};\n      assert toSet(xs) == toSet(xs[1..]);\n    } else {\n      assert dedup(xs) == [xs[0]] + rest;\n      assert noDuplicates(rest);\n      assert !(xs[0] in rest);\n      \n      forall i, j | 0 <= i < j < |dedup(xs)|\n        ensures dedup(xs)[i] != dedup(xs)[j]\n      {\n        if i == 0 {\n          assert dedup(xs)[0] == xs[0];\n          assert dedup(xs)[j] == rest[j-1];\n          assert !(xs[0] in rest);\n        } else {\n          \n/*[CODE HERE]*/\n          assert dedup(xs)[j] == rest[j-1];\n        }\n      }\n      \n      assert toSet(dedup(xs)) == toSet([xs[0]] + rest);\n      assert toSet([xs[0]] + rest) == {xs[0]} + toSet(rest);\n      assert toSet(rest) == toSet(xs[1..]);\n      assert toSet(xs) == {xs[0]} + toSet(xs[1..]);\n    }\n  }\n}", "output": "assert dedup(xs)[i] == rest[i-1];"}, {"id": "example_dedupCorrect_6", "type": "assert", "program": "function dedup(xs: seq<int>): seq<int>\n{\n  if |xs| == 0 then []\n  else if xs[0] in dedup(xs[1..]) then dedup(xs[1..])\n  else [xs[0]] + dedup(xs[1..])\n}\n\npredicate {:spec} noDuplicates(xs: seq<int>)\n{\n  forall i, j :: 0 <= i < j < |xs| ==> xs[i] != xs[j]\n}\n\nfunction {:spec} toSet(xs: seq<int>): set<int>\n{\n  set x | x in xs\n}\n\nlemma dedupCorrect(xs: seq<int>)\n  ensures noDuplicates(dedup(xs))\n  ensures toSet(dedup(xs)) == toSet(xs)\n{\n  if |xs| == 0 {\n  } else {\n    dedupCorrect(xs[1..]);\n    var rest := dedup(xs[1..]);\n    \n    if xs[0] in rest {\n      assert dedup(xs) == rest;\n      assert xs[0] in rest;\n      assert toSet(rest) == toSet(xs[1..]);\n      assert xs[0] in xs[1..];\n      assert toSet(xs) == toSet(xs[1..]) + {xs[0]};\n      assert toSet(xs) == toSet(xs[1..]);\n    } else {\n      assert dedup(xs) == [xs[0]] + rest;\n      assert noDuplicates(rest);\n      assert !(xs[0] in rest);\n      \n      forall i, j | 0 <= i < j < |dedup(xs)|\n        ensures dedup(xs)[i] != dedup(xs)[j]\n      {\n        if i == 0 {\n          assert dedup(xs)[0] == xs[0];\n          assert dedup(xs)[j] == rest[j-1];\n          \n/*[CODE HERE]*/\n        } else {\n          assert dedup(xs)[i] == rest[i-1];\n          assert dedup(xs)[j] == rest[j-1];\n        }\n      }\n      \n      assert toSet(dedup(xs)) == toSet([xs[0]] + rest);\n      assert toSet([xs[0]] + rest) == {xs[0]} + toSet(rest);\n      assert toSet(rest) == toSet(xs[1..]);\n      assert toSet(xs) == {xs[0]} + toSet(xs[1..]);\n    }\n  }\n}", "output": "assert !(xs[0] in rest);"}, {"id": "example_dedupCorrect_7", "type": "assert", "program": "function dedup(xs: seq<int>): seq<int>\n{\n  if |xs| == 0 then []\n  else if xs[0] in dedup(xs[1..]) then dedup(xs[1..])\n  else [xs[0]] + dedup(xs[1..])\n}\n\npredicate {:spec} noDuplicates(xs: seq<int>)\n{\n  forall i, j :: 0 <= i < j < |xs| ==> xs[i] != xs[j]\n}\n\nfunction {:spec} toSet(xs: seq<int>): set<int>\n{\n  set x | x in xs\n}\n\nlemma dedupCorrect(xs: seq<int>)\n  ensures noDuplicates(dedup(xs))\n  ensures toSet(dedup(xs)) == toSet(xs)\n{\n  if |xs| == 0 {\n  } else {\n    dedupCorrect(xs[1..]);\n    var rest := dedup(xs[1..]);\n    \n    if xs[0] in rest {\n      assert dedup(xs) == rest;\n      assert xs[0] in rest;\n      assert toSet(rest) == toSet(xs[1..]);\n      assert xs[0] in xs[1..];\n      assert toSet(xs) == toSet(xs[1..]) + {xs[0]};\n      assert toSet(xs) == toSet(xs[1..]);\n    } else {\n      assert dedup(xs) == [xs[0]] + rest;\n      assert noDuplicates(rest);\n      assert !(xs[0] in rest);\n      \n      forall i, j | 0 <= i < j < |dedup(xs)|\n        ensures dedup(xs)[i] != dedup(xs)[j]\n      {\n        if i == 0 {\n          assert dedup(xs)[0] == xs[0];\n          \n/*[CODE HERE]*/\n          assert !(xs[0] in rest);\n        } else {\n          assert dedup(xs)[i] == rest[i-1];\n          assert dedup(xs)[j] == rest[j-1];\n        }\n      }\n      \n      assert toSet(dedup(xs)) == toSet([xs[0]] + rest);\n      assert toSet([xs[0]] + rest) == {xs[0]} + toSet(rest);\n      assert toSet(rest) == toSet(xs[1..]);\n      assert toSet(xs) == {xs[0]} + toSet(xs[1..]);\n    }\n  }\n}", "output": "assert dedup(xs)[j] == rest[j-1];"}, {"id": "example_dedupCorrect_8", "type": "assert", "program": "function dedup(xs: seq<int>): seq<int>\n{\n  if |xs| == 0 then []\n  else if xs[0] in dedup(xs[1..]) then dedup(xs[1..])\n  else [xs[0]] + dedup(xs[1..])\n}\n\npredicate {:spec} noDuplicates(xs: seq<int>)\n{\n  forall i, j :: 0 <= i < j < |xs| ==> xs[i] != xs[j]\n}\n\nfunction {:spec} toSet(xs: seq<int>): set<int>\n{\n  set x | x in xs\n}\n\nlemma dedupCorrect(xs: seq<int>)\n  ensures noDuplicates(dedup(xs))\n  ensures toSet(dedup(xs)) == toSet(xs)\n{\n  if |xs| == 0 {\n  } else {\n    dedupCorrect(xs[1..]);\n    var rest := dedup(xs[1..]);\n    \n    if xs[0] in rest {\n      assert dedup(xs) == rest;\n      assert xs[0] in rest;\n      assert toSet(rest) == toSet(xs[1..]);\n      assert xs[0] in xs[1..];\n      assert toSet(xs) == toSet(xs[1..]) + {xs[0]};\n      assert toSet(xs) == toSet(xs[1..]);\n    } else {\n      assert dedup(xs) == [xs[0]] + rest;\n      assert noDuplicates(rest);\n      assert !(xs[0] in rest);\n      \n      forall i, j | 0 <= i < j < |dedup(xs)|\n        ensures dedup(xs)[i] != dedup(xs)[j]\n      {\n        if i == 0 {\n          \n/*[CODE HERE]*/\n          assert dedup(xs)[j] == rest[j-1];\n          assert !(xs[0] in rest);\n        } else {\n          assert dedup(xs)[i] == rest[i-1];\n          assert dedup(xs)[j] == rest[j-1];\n        }\n      }\n      \n      assert toSet(dedup(xs)) == toSet([xs[0]] + rest);\n      assert toSet([xs[0]] + rest) == {xs[0]} + toSet(rest);\n      assert toSet(rest) == toSet(xs[1..]);\n      assert toSet(xs) == {xs[0]} + toSet(xs[1..]);\n    }\n  }\n}", "output": "assert dedup(xs)[0] == xs[0];"}, {"id": "example_dedupCorrect_9", "type": "assert", "program": "function dedup(xs: seq<int>): seq<int>\n{\n  if |xs| == 0 then []\n  else if xs[0] in dedup(xs[1..]) then dedup(xs[1..])\n  else [xs[0]] + dedup(xs[1..])\n}\n\npredicate {:spec} noDuplicates(xs: seq<int>)\n{\n  forall i, j :: 0 <= i < j < |xs| ==> xs[i] != xs[j]\n}\n\nfunction {:spec} toSet(xs: seq<int>): set<int>\n{\n  set x | x in xs\n}\n\nlemma dedupCorrect(xs: seq<int>)\n  ensures noDuplicates(dedup(xs))\n  ensures toSet(dedup(xs)) == toSet(xs)\n{\n  if |xs| == 0 {\n  } else {\n    dedupCorrect(xs[1..]);\n    var rest := dedup(xs[1..]);\n    \n    if xs[0] in rest {\n      assert dedup(xs) == rest;\n      assert xs[0] in rest;\n      assert toSet(rest) == toSet(xs[1..]);\n      assert xs[0] in xs[1..];\n      assert toSet(xs) == toSet(xs[1..]) + {xs[0]};\n      assert toSet(xs) == toSet(xs[1..]);\n    } else {\n      assert dedup(xs) == [xs[0]] + rest;\n      assert noDuplicates(rest);\n      \n/*[CODE HERE]*/\n      \n      forall i, j | 0 <= i < j < |dedup(xs)|\n        ensures dedup(xs)[i] != dedup(xs)[j]\n      {\n        if i == 0 {\n          assert dedup(xs)[0] == xs[0];\n          assert dedup(xs)[j] == rest[j-1];\n          assert !(xs[0] in rest);\n        } else {\n          assert dedup(xs)[i] == rest[i-1];\n          assert dedup(xs)[j] == rest[j-1];\n        }\n      }\n      \n      assert toSet(dedup(xs)) == toSet([xs[0]] + rest);\n      assert toSet([xs[0]] + rest) == {xs[0]} + toSet(rest);\n      assert toSet(rest) == toSet(xs[1..]);\n      assert toSet(xs) == {xs[0]} + toSet(xs[1..]);\n    }\n  }\n}", "output": "assert !(xs[0] in rest);"}, {"id": "example_dedupCorrect_10", "type": "assert", "program": "function dedup(xs: seq<int>): seq<int>\n{\n  if |xs| == 0 then []\n  else if xs[0] in dedup(xs[1..]) then dedup(xs[1..])\n  else [xs[0]] + dedup(xs[1..])\n}\n\npredicate {:spec} noDuplicates(xs: seq<int>)\n{\n  forall i, j :: 0 <= i < j < |xs| ==> xs[i] != xs[j]\n}\n\nfunction {:spec} toSet(xs: seq<int>): set<int>\n{\n  set x | x in xs\n}\n\nlemma dedupCorrect(xs: seq<int>)\n  ensures noDuplicates(dedup(xs))\n  ensures toSet(dedup(xs)) == toSet(xs)\n{\n  if |xs| == 0 {\n  } else {\n    dedupCorrect(xs[1..]);\n    var rest := dedup(xs[1..]);\n    \n    if xs[0] in rest {\n      assert dedup(xs) == rest;\n      assert xs[0] in rest;\n      assert toSet(rest) == toSet(xs[1..]);\n      assert xs[0] in xs[1..];\n      assert toSet(xs) == toSet(xs[1..]) + {xs[0]};\n      assert toSet(xs) == toSet(xs[1..]);\n    } else {\n      assert dedup(xs) == [xs[0]] + rest;\n      \n/*[CODE HERE]*/\n      assert !(xs[0] in rest);\n      \n      forall i, j | 0 <= i < j < |dedup(xs)|\n        ensures dedup(xs)[i] != dedup(xs)[j]\n      {\n        if i == 0 {\n          assert dedup(xs)[0] == xs[0];\n          assert dedup(xs)[j] == rest[j-1];\n          assert !(xs[0] in rest);\n        } else {\n          assert dedup(xs)[i] == rest[i-1];\n          assert dedup(xs)[j] == rest[j-1];\n        }\n      }\n      \n      assert toSet(dedup(xs)) == toSet([xs[0]] + rest);\n      assert toSet([xs[0]] + rest) == {xs[0]} + toSet(rest);\n      assert toSet(rest) == toSet(xs[1..]);\n      assert toSet(xs) == {xs[0]} + toSet(xs[1..]);\n    }\n  }\n}", "output": "assert noDuplicates(rest);"}, {"id": "example_dedupCorrect_11", "type": "assert", "program": "function dedup(xs: seq<int>): seq<int>\n{\n  if |xs| == 0 then []\n  else if xs[0] in dedup(xs[1..]) then dedup(xs[1..])\n  else [xs[0]] + dedup(xs[1..])\n}\n\npredicate {:spec} noDuplicates(xs: seq<int>)\n{\n  forall i, j :: 0 <= i < j < |xs| ==> xs[i] != xs[j]\n}\n\nfunction {:spec} toSet(xs: seq<int>): set<int>\n{\n  set x | x in xs\n}\n\nlemma dedupCorrect(xs: seq<int>)\n  ensures noDuplicates(dedup(xs))\n  ensures toSet(dedup(xs)) == toSet(xs)\n{\n  if |xs| == 0 {\n  } else {\n    dedupCorrect(xs[1..]);\n    var rest := dedup(xs[1..]);\n    \n    if xs[0] in rest {\n      assert dedup(xs) == rest;\n      assert xs[0] in rest;\n      assert toSet(rest) == toSet(xs[1..]);\n      assert xs[0] in xs[1..];\n      assert toSet(xs) == toSet(xs[1..]) + {xs[0]};\n      assert toSet(xs) == toSet(xs[1..]);\n    } else {\n      \n/*[CODE HERE]*/\n      assert noDuplicates(rest);\n      assert !(xs[0] in rest);\n      \n      forall i, j | 0 <= i < j < |dedup(xs)|\n        ensures dedup(xs)[i] != dedup(xs)[j]\n      {\n        if i == 0 {\n          assert dedup(xs)[0] == xs[0];\n          assert dedup(xs)[j] == rest[j-1];\n          assert !(xs[0] in rest);\n        } else {\n          assert dedup(xs)[i] == rest[i-1];\n          assert dedup(xs)[j] == rest[j-1];\n        }\n      }\n      \n      assert toSet(dedup(xs)) == toSet([xs[0]] + rest);\n      assert toSet([xs[0]] + rest) == {xs[0]} + toSet(rest);\n      assert toSet(rest) == toSet(xs[1..]);\n      assert toSet(xs) == {xs[0]} + toSet(xs[1..]);\n    }\n  }\n}", "output": "assert dedup(xs) == [xs[0]] + rest;"}, {"id": "example_dedupCorrect_12", "type": "assert", "program": "function dedup(xs: seq<int>): seq<int>\n{\n  if |xs| == 0 then []\n  else if xs[0] in dedup(xs[1..]) then dedup(xs[1..])\n  else [xs[0]] + dedup(xs[1..])\n}\n\npredicate {:spec} noDuplicates(xs: seq<int>)\n{\n  forall i, j :: 0 <= i < j < |xs| ==> xs[i] != xs[j]\n}\n\nfunction {:spec} toSet(xs: seq<int>): set<int>\n{\n  set x | x in xs\n}\n\nlemma dedupCorrect(xs: seq<int>)\n  ensures noDuplicates(dedup(xs))\n  ensures toSet(dedup(xs)) == toSet(xs)\n{\n  if |xs| == 0 {\n  } else {\n    dedupCorrect(xs[1..]);\n    var rest := dedup(xs[1..]);\n    \n    if xs[0] in rest {\n      assert dedup(xs) == rest;\n      assert xs[0] in rest;\n      assert toSet(rest) == toSet(xs[1..]);\n      assert xs[0] in xs[1..];\n      assert toSet(xs) == toSet(xs[1..]) + {xs[0]};\n      \n/*[CODE HERE]*/\n    } else {\n      assert dedup(xs) == [xs[0]] + rest;\n      assert noDuplicates(rest);\n      assert !(xs[0] in rest);\n      \n      forall i, j | 0 <= i < j < |dedup(xs)|\n        ensures dedup(xs)[i] != dedup(xs)[j]\n      {\n        if i == 0 {\n          assert dedup(xs)[0] == xs[0];\n          assert dedup(xs)[j] == rest[j-1];\n          assert !(xs[0] in rest);\n        } else {\n          assert dedup(xs)[i] == rest[i-1];\n          assert dedup(xs)[j] == rest[j-1];\n        }\n      }\n      \n      assert toSet(dedup(xs)) == toSet([xs[0]] + rest);\n      assert toSet([xs[0]] + rest) == {xs[0]} + toSet(rest);\n      assert toSet(rest) == toSet(xs[1..]);\n      assert toSet(xs) == {xs[0]} + toSet(xs[1..]);\n    }\n  }\n}", "output": "assert toSet(xs) == toSet(xs[1..]);"}, {"id": "example_dedupCorrect_13", "type": "assert", "program": "function dedup(xs: seq<int>): seq<int>\n{\n  if |xs| == 0 then []\n  else if xs[0] in dedup(xs[1..]) then dedup(xs[1..])\n  else [xs[0]] + dedup(xs[1..])\n}\n\npredicate {:spec} noDuplicates(xs: seq<int>)\n{\n  forall i, j :: 0 <= i < j < |xs| ==> xs[i] != xs[j]\n}\n\nfunction {:spec} toSet(xs: seq<int>): set<int>\n{\n  set x | x in xs\n}\n\nlemma dedupCorrect(xs: seq<int>)\n  ensures noDuplicates(dedup(xs))\n  ensures toSet(dedup(xs)) == toSet(xs)\n{\n  if |xs| == 0 {\n  } else {\n    dedupCorrect(xs[1..]);\n    var rest := dedup(xs[1..]);\n    \n    if xs[0] in rest {\n      assert dedup(xs) == rest;\n      assert xs[0] in rest;\n      assert toSet(rest) == toSet(xs[1..]);\n      assert xs[0] in xs[1..];\n      \n/*[CODE HERE]*/\n      assert toSet(xs) == toSet(xs[1..]);\n    } else {\n      assert dedup(xs) == [xs[0]] + rest;\n      assert noDuplicates(rest);\n      assert !(xs[0] in rest);\n      \n      forall i, j | 0 <= i < j < |dedup(xs)|\n        ensures dedup(xs)[i] != dedup(xs)[j]\n      {\n        if i == 0 {\n          assert dedup(xs)[0] == xs[0];\n          assert dedup(xs)[j] == rest[j-1];\n          assert !(xs[0] in rest);\n        } else {\n          assert dedup(xs)[i] == rest[i-1];\n          assert dedup(xs)[j] == rest[j-1];\n        }\n      }\n      \n      assert toSet(dedup(xs)) == toSet([xs[0]] + rest);\n      assert toSet([xs[0]] + rest) == {xs[0]} + toSet(rest);\n      assert toSet(rest) == toSet(xs[1..]);\n      assert toSet(xs) == {xs[0]} + toSet(xs[1..]);\n    }\n  }\n}", "output": "assert toSet(xs) == toSet(xs[1..]) + {xs[0]};"}, {"id": "example_dedupCorrect_14", "type": "assert", "program": "function dedup(xs: seq<int>): seq<int>\n{\n  if |xs| == 0 then []\n  else if xs[0] in dedup(xs[1..]) then dedup(xs[1..])\n  else [xs[0]] + dedup(xs[1..])\n}\n\npredicate {:spec} noDuplicates(xs: seq<int>)\n{\n  forall i, j :: 0 <= i < j < |xs| ==> xs[i] != xs[j]\n}\n\nfunction {:spec} toSet(xs: seq<int>): set<int>\n{\n  set x | x in xs\n}\n\nlemma dedupCorrect(xs: seq<int>)\n  ensures noDuplicates(dedup(xs))\n  ensures toSet(dedup(xs)) == toSet(xs)\n{\n  if |xs| == 0 {\n  } else {\n    dedupCorrect(xs[1..]);\n    var rest := dedup(xs[1..]);\n    \n    if xs[0] in rest {\n      assert dedup(xs) == rest;\n      assert xs[0] in rest;\n      assert toSet(rest) == toSet(xs[1..]);\n      \n/*[CODE HERE]*/\n      assert toSet(xs) == toSet(xs[1..]) + {xs[0]};\n      assert toSet(xs) == toSet(xs[1..]);\n    } else {\n      assert dedup(xs) == [xs[0]] + rest;\n      assert noDuplicates(rest);\n      assert !(xs[0] in rest);\n      \n      forall i, j | 0 <= i < j < |dedup(xs)|\n        ensures dedup(xs)[i] != dedup(xs)[j]\n      {\n        if i == 0 {\n          assert dedup(xs)[0] == xs[0];\n          assert dedup(xs)[j] == rest[j-1];\n          assert !(xs[0] in rest);\n        } else {\n          assert dedup(xs)[i] == rest[i-1];\n          assert dedup(xs)[j] == rest[j-1];\n        }\n      }\n      \n      assert toSet(dedup(xs)) == toSet([xs[0]] + rest);\n      assert toSet([xs[0]] + rest) == {xs[0]} + toSet(rest);\n      assert toSet(rest) == toSet(xs[1..]);\n      assert toSet(xs) == {xs[0]} + toSet(xs[1..]);\n    }\n  }\n}", "output": "assert xs[0] in xs[1..];"}, {"id": "example_dedupCorrect_15", "type": "assert", "program": "function dedup(xs: seq<int>): seq<int>\n{\n  if |xs| == 0 then []\n  else if xs[0] in dedup(xs[1..]) then dedup(xs[1..])\n  else [xs[0]] + dedup(xs[1..])\n}\n\npredicate {:spec} noDuplicates(xs: seq<int>)\n{\n  forall i, j :: 0 <= i < j < |xs| ==> xs[i] != xs[j]\n}\n\nfunction {:spec} toSet(xs: seq<int>): set<int>\n{\n  set x | x in xs\n}\n\nlemma dedupCorrect(xs: seq<int>)\n  ensures noDuplicates(dedup(xs))\n  ensures toSet(dedup(xs)) == toSet(xs)\n{\n  if |xs| == 0 {\n  } else {\n    dedupCorrect(xs[1..]);\n    var rest := dedup(xs[1..]);\n    \n    if xs[0] in rest {\n      assert dedup(xs) == rest;\n      assert xs[0] in rest;\n      \n/*[CODE HERE]*/\n      assert xs[0] in xs[1..];\n      assert toSet(xs) == toSet(xs[1..]) + {xs[0]};\n      assert toSet(xs) == toSet(xs[1..]);\n    } else {\n      assert dedup(xs) == [xs[0]] + rest;\n      assert noDuplicates(rest);\n      assert !(xs[0] in rest);\n      \n      forall i, j | 0 <= i < j < |dedup(xs)|\n        ensures dedup(xs)[i] != dedup(xs)[j]\n      {\n        if i == 0 {\n          assert dedup(xs)[0] == xs[0];\n          assert dedup(xs)[j] == rest[j-1];\n          assert !(xs[0] in rest);\n        } else {\n          assert dedup(xs)[i] == rest[i-1];\n          assert dedup(xs)[j] == rest[j-1];\n        }\n      }\n      \n      assert toSet(dedup(xs)) == toSet([xs[0]] + rest);\n      assert toSet([xs[0]] + rest) == {xs[0]} + toSet(rest);\n      assert toSet(rest) == toSet(xs[1..]);\n      assert toSet(xs) == {xs[0]} + toSet(xs[1..]);\n    }\n  }\n}", "output": "assert toSet(rest) == toSet(xs[1..]);"}, {"id": "example_dedupCorrect_16", "type": "assert", "program": "function dedup(xs: seq<int>): seq<int>\n{\n  if |xs| == 0 then []\n  else if xs[0] in dedup(xs[1..]) then dedup(xs[1..])\n  else [xs[0]] + dedup(xs[1..])\n}\n\npredicate {:spec} noDuplicates(xs: seq<int>)\n{\n  forall i, j :: 0 <= i < j < |xs| ==> xs[i] != xs[j]\n}\n\nfunction {:spec} toSet(xs: seq<int>): set<int>\n{\n  set x | x in xs\n}\n\nlemma dedupCorrect(xs: seq<int>)\n  ensures noDuplicates(dedup(xs))\n  ensures toSet(dedup(xs)) == toSet(xs)\n{\n  if |xs| == 0 {\n  } else {\n    dedupCorrect(xs[1..]);\n    var rest := dedup(xs[1..]);\n    \n    if xs[0] in rest {\n      assert dedup(xs) == rest;\n      \n/*[CODE HERE]*/\n      assert toSet(rest) == toSet(xs[1..]);\n      assert xs[0] in xs[1..];\n      assert toSet(xs) == toSet(xs[1..]) + {xs[0]};\n      assert toSet(xs) == toSet(xs[1..]);\n    } else {\n      assert dedup(xs) == [xs[0]] + rest;\n      assert noDuplicates(rest);\n      assert !(xs[0] in rest);\n      \n      forall i, j | 0 <= i < j < |dedup(xs)|\n        ensures dedup(xs)[i] != dedup(xs)[j]\n      {\n        if i == 0 {\n          assert dedup(xs)[0] == xs[0];\n          assert dedup(xs)[j] == rest[j-1];\n          assert !(xs[0] in rest);\n        } else {\n          assert dedup(xs)[i] == rest[i-1];\n          assert dedup(xs)[j] == rest[j-1];\n        }\n      }\n      \n      assert toSet(dedup(xs)) == toSet([xs[0]] + rest);\n      assert toSet([xs[0]] + rest) == {xs[0]} + toSet(rest);\n      assert toSet(rest) == toSet(xs[1..]);\n      assert toSet(xs) == {xs[0]} + toSet(xs[1..]);\n    }\n  }\n}", "output": "assert xs[0] in rest;"}, {"id": "example_dedupCorrect_17", "type": "assert", "program": "function dedup(xs: seq<int>): seq<int>\n{\n  if |xs| == 0 then []\n  else if xs[0] in dedup(xs[1..]) then dedup(xs[1..])\n  else [xs[0]] + dedup(xs[1..])\n}\n\npredicate {:spec} noDuplicates(xs: seq<int>)\n{\n  forall i, j :: 0 <= i < j < |xs| ==> xs[i] != xs[j]\n}\n\nfunction {:spec} toSet(xs: seq<int>): set<int>\n{\n  set x | x in xs\n}\n\nlemma dedupCorrect(xs: seq<int>)\n  ensures noDuplicates(dedup(xs))\n  ensures toSet(dedup(xs)) == toSet(xs)\n{\n  if |xs| == 0 {\n  } else {\n    dedupCorrect(xs[1..]);\n    var rest := dedup(xs[1..]);\n    \n    if xs[0] in rest {\n      \n/*[CODE HERE]*/\n      assert xs[0] in rest;\n      assert toSet(rest) == toSet(xs[1..]);\n      assert xs[0] in xs[1..];\n      assert toSet(xs) == toSet(xs[1..]) + {xs[0]};\n      assert toSet(xs) == toSet(xs[1..]);\n    } else {\n      assert dedup(xs) == [xs[0]] + rest;\n      assert noDuplicates(rest);\n      assert !(xs[0] in rest);\n      \n      forall i, j | 0 <= i < j < |dedup(xs)|\n        ensures dedup(xs)[i] != dedup(xs)[j]\n      {\n        if i == 0 {\n          assert dedup(xs)[0] == xs[0];\n          assert dedup(xs)[j] == rest[j-1];\n          assert !(xs[0] in rest);\n        } else {\n          assert dedup(xs)[i] == rest[i-1];\n          assert dedup(xs)[j] == rest[j-1];\n        }\n      }\n      \n      assert toSet(dedup(xs)) == toSet([xs[0]] + rest);\n      assert toSet([xs[0]] + rest) == {xs[0]} + toSet(rest);\n      assert toSet(rest) == toSet(xs[1..]);\n      assert toSet(xs) == {xs[0]} + toSet(xs[1..]);\n    }\n  }\n}", "output": "assert dedup(xs) == rest;"}, {"id": "example_dedupCorrect_18", "type": "call", "program": "function dedup(xs: seq<int>): seq<int>\n{\n  if |xs| == 0 then []\n  else if xs[0] in dedup(xs[1..]) then dedup(xs[1..])\n  else [xs[0]] + dedup(xs[1..])\n}\n\npredicate {:spec} noDuplicates(xs: seq<int>)\n{\n  forall i, j :: 0 <= i < j < |xs| ==> xs[i] != xs[j]\n}\n\nfunction {:spec} toSet(xs: seq<int>): set<int>\n{\n  set x | x in xs\n}\n\nlemma dedupCorrect(xs: seq<int>)\n  ensures noDuplicates(dedup(xs))\n  ensures toSet(dedup(xs)) == toSet(xs)\n{\n  if |xs| == 0 {\n  } else {\n    \n/*[CODE HERE]*/\n    var rest := dedup(xs[1..]);\n    \n    if xs[0] in rest {\n      assert dedup(xs) == rest;\n      assert xs[0] in rest;\n      assert toSet(rest) == toSet(xs[1..]);\n      assert xs[0] in xs[1..];\n      assert toSet(xs) == toSet(xs[1..]) + {xs[0]};\n      assert toSet(xs) == toSet(xs[1..]);\n    } else {\n      assert dedup(xs) == [xs[0]] + rest;\n      assert noDuplicates(rest);\n      assert !(xs[0] in rest);\n      \n      forall i, j | 0 <= i < j < |dedup(xs)|\n        ensures dedup(xs)[i] != dedup(xs)[j]\n      {\n        if i == 0 {\n          assert dedup(xs)[0] == xs[0];\n          assert dedup(xs)[j] == rest[j-1];\n          assert !(xs[0] in rest);\n        } else {\n          assert dedup(xs)[i] == rest[i-1];\n          assert dedup(xs)[j] == rest[j-1];\n        }\n      }\n      \n      assert toSet(dedup(xs)) == toSet([xs[0]] + rest);\n      assert toSet([xs[0]] + rest) == {xs[0]} + toSet(rest);\n      assert toSet(rest) == toSet(xs[1..]);\n      assert toSet(xs) == {xs[0]} + toSet(xs[1..]);\n    }\n  }\n}", "output": "dedupCorrect(xs[1..]);"}, {"id": "example_OptimizePreservesSemantics_0", "type": "assert", "program": "datatype Expr =\n  | Const(value: int)\n  | Var(name: string)\n  | Add(left: Expr, right: Expr)\n\ntype Environment = string -> int\n\nfunction Eval(e: Expr, env: Environment): int\n{\n  match e\n  case Const(v) => v\n  case Var(x) => env(x)\n  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)\n}\n\nfunction Optimize(e: Expr): Expr\n{\n  match e\n  case Const(v) => Const(v)\n  case Var(x) => Var(x)\n  case Add(e1, e2) =>\n    var o1 := Optimize(e1);\n    var o2 := Optimize(e2);\n    match (o1, o2)\n    case (Const(0), _) => o2\n    case (_, Const(0)) => o1\n    case _ => Add(o1, o2)\n}\n\nlemma OptimizePreservesSemantics(e: Expr, env: Environment)\n  ensures Eval(Optimize(e), env) == Eval(e, env)\n{\n  match e\n  case Const(_) =>\n  case Var(_) =>\n  case Add(e1, e2) =>\n    OptimizePreservesSemantics(e1, env);\n    OptimizePreservesSemantics(e2, env);\n    var o1 := Optimize(e1);\n    var o2 := Optimize(e2);\n    assert Eval(o1, env) == Eval(e1, env);\n    \n/*[CODE HERE]*/\n    \n    match (o1, o2)\n    case (Const(0), _) =>\n      calc {\n        Eval(Optimize(e), env);\n        == Eval(o2, env);\n        == Eval(e2, env);\n        == 0 + Eval(e2, env);\n        == Eval(e1, env) + Eval(e2, env);\n        == Eval(e, env);\n      }\n    case (_, Const(0)) =>\n      calc {\n        Eval(Optimize(e), env);\n        == Eval(o1, env);\n        == Eval(e1, env);\n        == Eval(e1, env) + 0;\n        == Eval(e1, env) + Eval(e2, env);\n        == Eval(e, env);\n      }\n    case _ =>\n      calc {\n        Eval(Optimize(e), env);\n        == Eval(Add(o1, o2), env);\n        == Eval(o1, env) + Eval(o2, env);\n        == Eval(e1, env) + Eval(e2, env);\n        == Eval(e, env);\n      }\n}", "output": "assert Eval(o2, env) == Eval(e2, env);"}, {"id": "example_OptimizePreservesSemantics_1", "type": "assert", "program": "datatype Expr =\n  | Const(value: int)\n  | Var(name: string)\n  | Add(left: Expr, right: Expr)\n\ntype Environment = string -> int\n\nfunction Eval(e: Expr, env: Environment): int\n{\n  match e\n  case Const(v) => v\n  case Var(x) => env(x)\n  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)\n}\n\nfunction Optimize(e: Expr): Expr\n{\n  match e\n  case Const(v) => Const(v)\n  case Var(x) => Var(x)\n  case Add(e1, e2) =>\n    var o1 := Optimize(e1);\n    var o2 := Optimize(e2);\n    match (o1, o2)\n    case (Const(0), _) => o2\n    case (_, Const(0)) => o1\n    case _ => Add(o1, o2)\n}\n\nlemma OptimizePreservesSemantics(e: Expr, env: Environment)\n  ensures Eval(Optimize(e), env) == Eval(e, env)\n{\n  match e\n  case Const(_) =>\n  case Var(_) =>\n  case Add(e1, e2) =>\n    OptimizePreservesSemantics(e1, env);\n    OptimizePreservesSemantics(e2, env);\n    var o1 := Optimize(e1);\n    var o2 := Optimize(e2);\n    \n/*[CODE HERE]*/\n    assert Eval(o2, env) == Eval(e2, env);\n    \n    match (o1, o2)\n    case (Const(0), _) =>\n      calc {\n        Eval(Optimize(e), env);\n        == Eval(o2, env);\n        == Eval(e2, env);\n        == 0 + Eval(e2, env);\n        == Eval(e1, env) + Eval(e2, env);\n        == Eval(e, env);\n      }\n    case (_, Const(0)) =>\n      calc {\n        Eval(Optimize(e), env);\n        == Eval(o1, env);\n        == Eval(e1, env);\n        == Eval(e1, env) + 0;\n        == Eval(e1, env) + Eval(e2, env);\n        == Eval(e, env);\n      }\n    case _ =>\n      calc {\n        Eval(Optimize(e), env);\n        == Eval(Add(o1, o2), env);\n        == Eval(o1, env) + Eval(o2, env);\n        == Eval(e1, env) + Eval(e2, env);\n        == Eval(e, env);\n      }\n}", "output": "assert Eval(o1, env) == Eval(e1, env);"}, {"id": "example_OptimizePreservesSemantics_2", "type": "call", "program": "datatype Expr =\n  | Const(value: int)\n  | Var(name: string)\n  | Add(left: Expr, right: Expr)\n\ntype Environment = string -> int\n\nfunction Eval(e: Expr, env: Environment): int\n{\n  match e\n  case Const(v) => v\n  case Var(x) => env(x)\n  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)\n}\n\nfunction Optimize(e: Expr): Expr\n{\n  match e\n  case Const(v) => Const(v)\n  case Var(x) => Var(x)\n  case Add(e1, e2) =>\n    var o1 := Optimize(e1);\n    var o2 := Optimize(e2);\n    match (o1, o2)\n    case (Const(0), _) => o2\n    case (_, Const(0)) => o1\n    case _ => Add(o1, o2)\n}\n\nlemma OptimizePreservesSemantics(e: Expr, env: Environment)\n  ensures Eval(Optimize(e), env) == Eval(e, env)\n{\n  match e\n  case Const(_) =>\n  case Var(_) =>\n  case Add(e1, e2) =>\n    OptimizePreservesSemantics(e1, env);\n    \n/*[CODE HERE]*/\n    var o1 := Optimize(e1);\n    var o2 := Optimize(e2);\n    assert Eval(o1, env) == Eval(e1, env);\n    assert Eval(o2, env) == Eval(e2, env);\n    \n    match (o1, o2)\n    case (Const(0), _) =>\n      calc {\n        Eval(Optimize(e), env);\n        == Eval(o2, env);\n        == Eval(e2, env);\n        == 0 + Eval(e2, env);\n        == Eval(e1, env) + Eval(e2, env);\n        == Eval(e, env);\n      }\n    case (_, Const(0)) =>\n      calc {\n        Eval(Optimize(e), env);\n        == Eval(o1, env);\n        == Eval(e1, env);\n        == Eval(e1, env) + 0;\n        == Eval(e1, env) + Eval(e2, env);\n        == Eval(e, env);\n      }\n    case _ =>\n      calc {\n        Eval(Optimize(e), env);\n        == Eval(Add(o1, o2), env);\n        == Eval(o1, env) + Eval(o2, env);\n        == Eval(e1, env) + Eval(e2, env);\n        == Eval(e, env);\n      }\n}", "output": "OptimizePreservesSemantics(e2, env);"}, {"id": "example_OptimizePreservesSemantics_3", "type": "call", "program": "datatype Expr =\n  | Const(value: int)\n  | Var(name: string)\n  | Add(left: Expr, right: Expr)\n\ntype Environment = string -> int\n\nfunction Eval(e: Expr, env: Environment): int\n{\n  match e\n  case Const(v) => v\n  case Var(x) => env(x)\n  case Add(e1, e2) => Eval(e1, env) + Eval(e2, env)\n}\n\nfunction Optimize(e: Expr): Expr\n{\n  match e\n  case Const(v) => Const(v)\n  case Var(x) => Var(x)\n  case Add(e1, e2) =>\n    var o1 := Optimize(e1);\n    var o2 := Optimize(e2);\n    match (o1, o2)\n    case (Const(0), _) => o2\n    case (_, Const(0)) => o1\n    case _ => Add(o1, o2)\n}\n\nlemma OptimizePreservesSemantics(e: Expr, env: Environment)\n  ensures Eval(Optimize(e), env) == Eval(e, env)\n{\n  match e\n  case Const(_) =>\n  case Var(_) =>\n  case Add(e1, e2) =>\n    \n/*[CODE HERE]*/\n    OptimizePreservesSemantics(e2, env);\n    var o1 := Optimize(e1);\n    var o2 := Optimize(e2);\n    assert Eval(o1, env) == Eval(e1, env);\n    assert Eval(o2, env) == Eval(e2, env);\n    \n    match (o1, o2)\n    case (Const(0), _) =>\n      calc {\n        Eval(Optimize(e), env);\n        == Eval(o2, env);\n        == Eval(e2, env);\n        == 0 + Eval(e2, env);\n        == Eval(e1, env) + Eval(e2, env);\n        == Eval(e, env);\n      }\n    case (_, Const(0)) =>\n      calc {\n        Eval(Optimize(e), env);\n        == Eval(o1, env);\n        == Eval(e1, env);\n        == Eval(e1, env) + 0;\n        == Eval(e1, env) + Eval(e2, env);\n        == Eval(e, env);\n      }\n    case _ =>\n      calc {\n        Eval(Optimize(e), env);\n        == Eval(Add(o1, o2), env);\n        == Eval(o1, env) + Eval(o2, env);\n        == Eval(e1, env) + Eval(e2, env);\n        == Eval(e, env);\n      }\n}", "output": "OptimizePreservesSemantics(e1, env);"}, {"id": "example_OptimizerOptimal_0", "type": "assert", "program": "datatype Expr =\n  | Const(value: int)\n  | Var(name: string)\n  | Add(left: Expr, right: Expr)\n\npredicate optimal(e: Expr)\n{\n  match e\n  case Const(_) => true\n  case Var(_) => true\n  case Add(Const(0), _) => false\n  case Add(_, Const(0)) => false\n  case Add(e1, e2) => optimal(e1) && optimal(e2)\n}\n\nfunction optimize(e: Expr): Expr\n{\n  match e\n  case Const(v) => Const(v)\n  case Var(x) => Var(x)\n  case Add(Const(0), e2) => optimize(e2)\n  case Add(e1, Const(0)) => optimize(e1)\n  case Add(e1, e2) => \n    var o1 := optimize(e1);\n    var o2 := optimize(e2);\n    match o1\n    case Const(0) => o2\n    case _ => match o2\n      case Const(0) => o1\n      case _ => Add(o1, o2)\n}\n\nlemma OptimizerOptimal(e: Expr)\n  ensures optimal(optimize(e))\n{\n  match e\n  case Const(_) =>\n  case Var(_) =>\n  case Add(e1, e2) =>\n    OptimizerOptimal(e1);\n    OptimizerOptimal(e2);\n    var o1 := optimize(e1);\n    var o2 := optimize(e2);\n    \n/*[CODE HERE]*/\n}", "output": "assert optimal(o1) && optimal(o2);"}, {"id": "example_OptimizerOptimal_1", "type": "call", "program": "datatype Expr =\n  | Const(value: int)\n  | Var(name: string)\n  | Add(left: Expr, right: Expr)\n\npredicate optimal(e: Expr)\n{\n  match e\n  case Const(_) => true\n  case Var(_) => true\n  case Add(Const(0), _) => false\n  case Add(_, Const(0)) => false\n  case Add(e1, e2) => optimal(e1) && optimal(e2)\n}\n\nfunction optimize(e: Expr): Expr\n{\n  match e\n  case Const(v) => Const(v)\n  case Var(x) => Var(x)\n  case Add(Const(0), e2) => optimize(e2)\n  case Add(e1, Const(0)) => optimize(e1)\n  case Add(e1, e2) => \n    var o1 := optimize(e1);\n    var o2 := optimize(e2);\n    match o1\n    case Const(0) => o2\n    case _ => match o2\n      case Const(0) => o1\n      case _ => Add(o1, o2)\n}\n\nlemma OptimizerOptimal(e: Expr)\n  ensures optimal(optimize(e))\n{\n  match e\n  case Const(_) =>\n  case Var(_) =>\n  case Add(e1, e2) =>\n    OptimizerOptimal(e1);\n    \n/*[CODE HERE]*/\n    var o1 := optimize(e1);\n    var o2 := optimize(e2);\n    assert optimal(o1) && optimal(o2);\n}", "output": "OptimizerOptimal(e2);"}, {"id": "example_OptimizerOptimal_2", "type": "call", "program": "datatype Expr =\n  | Const(value: int)\n  | Var(name: string)\n  | Add(left: Expr, right: Expr)\n\npredicate optimal(e: Expr)\n{\n  match e\n  case Const(_) => true\n  case Var(_) => true\n  case Add(Const(0), _) => false\n  case Add(_, Const(0)) => false\n  case Add(e1, e2) => optimal(e1) && optimal(e2)\n}\n\nfunction optimize(e: Expr): Expr\n{\n  match e\n  case Const(v) => Const(v)\n  case Var(x) => Var(x)\n  case Add(Const(0), e2) => optimize(e2)\n  case Add(e1, Const(0)) => optimize(e1)\n  case Add(e1, e2) => \n    var o1 := optimize(e1);\n    var o2 := optimize(e2);\n    match o1\n    case Const(0) => o2\n    case _ => match o2\n      case Const(0) => o1\n      case _ => Add(o1, o2)\n}\n\nlemma OptimizerOptimal(e: Expr)\n  ensures optimal(optimize(e))\n{\n  match e\n  case Const(_) =>\n  case Var(_) =>\n  case Add(e1, e2) =>\n    \n/*[CODE HERE]*/\n    OptimizerOptimal(e2);\n    var o1 := optimize(e1);\n    var o2 := optimize(e2);\n    assert optimal(o1) && optimal(o2);\n}", "output": "OptimizerOptimal(e1);"}, {"id": "example_FacPositive_0", "type": "assert", "program": "function fac(n: nat): nat\n{\n  if n == 0 then 1\n  else n * fac(n - 1)\n}\n\nlemma FacPositive(n: nat)\n  ensures fac(n) > 0\n{\n  if n == 0 {\n    assert fac(0) == 1 > 0;\n  } else {\n    FacPositive(n - 1);\n    assert fac(n - 1) > 0;\n    assert n > 0;\n    \n/*[CODE HERE]*/\n  }\n}", "output": "assert fac(n) == n * fac(n - 1) > 0;"}, {"id": "example_FacPositive_1", "type": "assert", "program": "function fac(n: nat): nat\n{\n  if n == 0 then 1\n  else n * fac(n - 1)\n}\n\nlemma FacPositive(n: nat)\n  ensures fac(n) > 0\n{\n  if n == 0 {\n    assert fac(0) == 1 > 0;\n  } else {\n    FacPositive(n - 1);\n    assert fac(n - 1) > 0;\n    \n/*[CODE HERE]*/\n    assert fac(n) == n * fac(n - 1) > 0;\n  }\n}", "output": "assert n > 0;"}, {"id": "example_FacPositive_2", "type": "assert", "program": "function fac(n: nat): nat\n{\n  if n == 0 then 1\n  else n * fac(n - 1)\n}\n\nlemma FacPositive(n: nat)\n  ensures fac(n) > 0\n{\n  if n == 0 {\n    assert fac(0) == 1 > 0;\n  } else {\n    FacPositive(n - 1);\n    \n/*[CODE HERE]*/\n    assert n > 0;\n    assert fac(n) == n * fac(n - 1) > 0;\n  }\n}", "output": "assert fac(n - 1) > 0;"}, {"id": "example_FacPositive_3", "type": "call", "program": "function fac(n: nat): nat\n{\n  if n == 0 then 1\n  else n * fac(n - 1)\n}\n\nlemma FacPositive(n: nat)\n  ensures fac(n) > 0\n{\n  if n == 0 {\n    assert fac(0) == 1 > 0;\n  } else {\n    \n/*[CODE HERE]*/\n    assert fac(n - 1) > 0;\n    assert n > 0;\n    assert fac(n) == n * fac(n - 1) > 0;\n  }\n}", "output": "FacPositive(n - 1);"}, {"id": "example_FacPositive_4", "type": "assert", "program": "function fac(n: nat): nat\n{\n  if n == 0 then 1\n  else n * fac(n - 1)\n}\n\nlemma FacPositive(n: nat)\n  ensures fac(n) > 0\n{\n  if n == 0 {\n    \n/*[CODE HERE]*/\n  } else {\n    FacPositive(n - 1);\n    assert fac(n - 1) > 0;\n    assert n > 0;\n    assert fac(n) == n * fac(n - 1) > 0;\n  }\n}", "output": "assert fac(0) == 1 > 0;"}, {"id": "example_factorialPositive_0", "type": "assert", "program": "function factorial(n: nat): nat\n{\n  if n == 0 then 1\n  else n * factorial(n - 1)\n}\n\nfunction {:spec} factorialSpec(n: nat): nat\n{\n  if n == 0 then 1\n  else n * factorialSpec(n - 1)\n}\n\nlemma factorialCorrect(n: nat)\n  ensures factorial(n) == factorialSpec(n)\n{\n}\n\nlemma factorialPositive(n: nat)\n  ensures factorial(n) > 0\n{\n  if n == 0 {\n    assert factorial(0) == 1;\n  } else {\n    factorialPositive(n - 1);\n    assert factorial(n - 1) > 0;\n    assert n > 0;\n    assert factorial(n) == n * factorial(n - 1);\n    \n/*[CODE HERE]*/\n  }\n}\n\nlemma factorialIncreasing(n: nat)\n  requires n > 0\n  ensures factorial(n) >= factorial(n - 1)\n{\n  factorialPositive(n - 1);\n  assert factorial(n) == n * factorial(n - 1);\n  assert n >= 1;\n  assert factorial(n - 1) > 0;\n  \n  calc {\n    factorial(n);\n    == n * factorial(n - 1);\n    >= 1 * factorial(n - 1);\n    == factorial(n - 1);\n  }\n}", "output": "assert n * factorial(n - 1) > 0;"}, {"id": "example_factorialPositive_1", "type": "assert", "program": "function factorial(n: nat): nat\n{\n  if n == 0 then 1\n  else n * factorial(n - 1)\n}\n\nfunction {:spec} factorialSpec(n: nat): nat\n{\n  if n == 0 then 1\n  else n * factorialSpec(n - 1)\n}\n\nlemma factorialCorrect(n: nat)\n  ensures factorial(n) == factorialSpec(n)\n{\n}\n\nlemma factorialPositive(n: nat)\n  ensures factorial(n) > 0\n{\n  if n == 0 {\n    assert factorial(0) == 1;\n  } else {\n    factorialPositive(n - 1);\n    assert factorial(n - 1) > 0;\n    assert n > 0;\n    \n/*[CODE HERE]*/\n    assert n * factorial(n - 1) > 0;\n  }\n}\n\nlemma factorialIncreasing(n: nat)\n  requires n > 0\n  ensures factorial(n) >= factorial(n - 1)\n{\n  factorialPositive(n - 1);\n  assert factorial(n) == n * factorial(n - 1);\n  assert n >= 1;\n  assert factorial(n - 1) > 0;\n  \n  calc {\n    factorial(n);\n    == n * factorial(n - 1);\n    >= 1 * factorial(n - 1);\n    == factorial(n - 1);\n  }\n}", "output": "assert factorial(n) == n * factorial(n - 1);"}, {"id": "example_factorialPositive_2", "type": "assert", "program": "function factorial(n: nat): nat\n{\n  if n == 0 then 1\n  else n * factorial(n - 1)\n}\n\nfunction {:spec} factorialSpec(n: nat): nat\n{\n  if n == 0 then 1\n  else n * factorialSpec(n - 1)\n}\n\nlemma factorialCorrect(n: nat)\n  ensures factorial(n) == factorialSpec(n)\n{\n}\n\nlemma factorialPositive(n: nat)\n  ensures factorial(n) > 0\n{\n  if n == 0 {\n    assert factorial(0) == 1;\n  } else {\n    factorialPositive(n - 1);\n    assert factorial(n - 1) > 0;\n    \n/*[CODE HERE]*/\n    assert factorial(n) == n * factorial(n - 1);\n    assert n * factorial(n - 1) > 0;\n  }\n}\n\nlemma factorialIncreasing(n: nat)\n  requires n > 0\n  ensures factorial(n) >= factorial(n - 1)\n{\n  factorialPositive(n - 1);\n  assert factorial(n) == n * factorial(n - 1);\n  assert n >= 1;\n  assert factorial(n - 1) > 0;\n  \n  calc {\n    factorial(n);\n    == n * factorial(n - 1);\n    >= 1 * factorial(n - 1);\n    == factorial(n - 1);\n  }\n}", "output": "assert n > 0;"}, {"id": "example_factorialPositive_3", "type": "assert", "program": "function factorial(n: nat): nat\n{\n  if n == 0 then 1\n  else n * factorial(n - 1)\n}\n\nfunction {:spec} factorialSpec(n: nat): nat\n{\n  if n == 0 then 1\n  else n * factorialSpec(n - 1)\n}\n\nlemma factorialCorrect(n: nat)\n  ensures factorial(n) == factorialSpec(n)\n{\n}\n\nlemma factorialPositive(n: nat)\n  ensures factorial(n) > 0\n{\n  if n == 0 {\n    assert factorial(0) == 1;\n  } else {\n    factorialPositive(n - 1);\n    \n/*[CODE HERE]*/\n    assert n > 0;\n    assert factorial(n) == n * factorial(n - 1);\n    assert n * factorial(n - 1) > 0;\n  }\n}\n\nlemma factorialIncreasing(n: nat)\n  requires n > 0\n  ensures factorial(n) >= factorial(n - 1)\n{\n  factorialPositive(n - 1);\n  assert factorial(n) == n * factorial(n - 1);\n  assert n >= 1;\n  assert factorial(n - 1) > 0;\n  \n  calc {\n    factorial(n);\n    == n * factorial(n - 1);\n    >= 1 * factorial(n - 1);\n    == factorial(n - 1);\n  }\n}", "output": "assert factorial(n - 1) > 0;"}, {"id": "example_factorialPositive_4", "type": "call", "program": "function factorial(n: nat): nat\n{\n  if n == 0 then 1\n  else n * factorial(n - 1)\n}\n\nfunction {:spec} factorialSpec(n: nat): nat\n{\n  if n == 0 then 1\n  else n * factorialSpec(n - 1)\n}\n\nlemma factorialCorrect(n: nat)\n  ensures factorial(n) == factorialSpec(n)\n{\n}\n\nlemma factorialPositive(n: nat)\n  ensures factorial(n) > 0\n{\n  if n == 0 {\n    assert factorial(0) == 1;\n  } else {\n    \n/*[CODE HERE]*/\n    assert factorial(n - 1) > 0;\n    assert n > 0;\n    assert factorial(n) == n * factorial(n - 1);\n    assert n * factorial(n - 1) > 0;\n  }\n}\n\nlemma factorialIncreasing(n: nat)\n  requires n > 0\n  ensures factorial(n) >= factorial(n - 1)\n{\n  factorialPositive(n - 1);\n  assert factorial(n) == n * factorial(n - 1);\n  assert n >= 1;\n  assert factorial(n - 1) > 0;\n  \n  calc {\n    factorial(n);\n    == n * factorial(n - 1);\n    >= 1 * factorial(n - 1);\n    == factorial(n - 1);\n  }\n}", "output": "factorialPositive(n - 1);"}, {"id": "example_factorialPositive_5", "type": "assert", "program": "function factorial(n: nat): nat\n{\n  if n == 0 then 1\n  else n * factorial(n - 1)\n}\n\nfunction {:spec} factorialSpec(n: nat): nat\n{\n  if n == 0 then 1\n  else n * factorialSpec(n - 1)\n}\n\nlemma factorialCorrect(n: nat)\n  ensures factorial(n) == factorialSpec(n)\n{\n}\n\nlemma factorialPositive(n: nat)\n  ensures factorial(n) > 0\n{\n  if n == 0 {\n    \n/*[CODE HERE]*/\n  } else {\n    factorialPositive(n - 1);\n    assert factorial(n - 1) > 0;\n    assert n > 0;\n    assert factorial(n) == n * factorial(n - 1);\n    assert n * factorial(n - 1) > 0;\n  }\n}\n\nlemma factorialIncreasing(n: nat)\n  requires n > 0\n  ensures factorial(n) >= factorial(n - 1)\n{\n  factorialPositive(n - 1);\n  assert factorial(n) == n * factorial(n - 1);\n  assert n >= 1;\n  assert factorial(n - 1) > 0;\n  \n  calc {\n    factorial(n);\n    == n * factorial(n - 1);\n    >= 1 * factorial(n - 1);\n    == factorial(n - 1);\n  }\n}", "output": "assert factorial(0) == 1;"}, {"id": "example_factorialIncreasing_0", "type": "assert", "program": "function factorial(n: nat): nat\n{\n  if n == 0 then 1\n  else n * factorial(n - 1)\n}\n\nfunction {:spec} factorialSpec(n: nat): nat\n{\n  if n == 0 then 1\n  else n * factorialSpec(n - 1)\n}\n\nlemma factorialCorrect(n: nat)\n  ensures factorial(n) == factorialSpec(n)\n{\n}\n\nlemma factorialPositive(n: nat)\n  ensures factorial(n) > 0\n{\n  if n == 0 {\n    assert factorial(0) == 1;\n  } else {\n    factorialPositive(n - 1);\n    assert factorial(n - 1) > 0;\n    assert n > 0;\n    assert factorial(n) == n * factorial(n - 1);\n    assert n * factorial(n - 1) > 0;\n  }\n}\n\nlemma factorialIncreasing(n: nat)\n  requires n > 0\n  ensures factorial(n) >= factorial(n - 1)\n{\n  factorialPositive(n - 1);\n  assert factorial(n) == n * factorial(n - 1);\n  assert n >= 1;\n  \n/*[CODE HERE]*/\n  \n  calc {\n    factorial(n);\n    == n * factorial(n - 1);\n    >= 1 * factorial(n - 1);\n    == factorial(n - 1);\n  }\n}", "output": "assert factorial(n - 1) > 0;"}, {"id": "example_factorialIncreasing_1", "type": "assert", "program": "function factorial(n: nat): nat\n{\n  if n == 0 then 1\n  else n * factorial(n - 1)\n}\n\nfunction {:spec} factorialSpec(n: nat): nat\n{\n  if n == 0 then 1\n  else n * factorialSpec(n - 1)\n}\n\nlemma factorialCorrect(n: nat)\n  ensures factorial(n) == factorialSpec(n)\n{\n}\n\nlemma factorialPositive(n: nat)\n  ensures factorial(n) > 0\n{\n  if n == 0 {\n    assert factorial(0) == 1;\n  } else {\n    factorialPositive(n - 1);\n    assert factorial(n - 1) > 0;\n    assert n > 0;\n    assert factorial(n) == n * factorial(n - 1);\n    assert n * factorial(n - 1) > 0;\n  }\n}\n\nlemma factorialIncreasing(n: nat)\n  requires n > 0\n  ensures factorial(n) >= factorial(n - 1)\n{\n  factorialPositive(n - 1);\n  assert factorial(n) == n * factorial(n - 1);\n  \n/*[CODE HERE]*/\n  assert factorial(n - 1) > 0;\n  \n  calc {\n    factorial(n);\n    == n * factorial(n - 1);\n    >= 1 * factorial(n - 1);\n    == factorial(n - 1);\n  }\n}", "output": "assert n >= 1;"}, {"id": "example_factorialIncreasing_2", "type": "assert", "program": "function factorial(n: nat): nat\n{\n  if n == 0 then 1\n  else n * factorial(n - 1)\n}\n\nfunction {:spec} factorialSpec(n: nat): nat\n{\n  if n == 0 then 1\n  else n * factorialSpec(n - 1)\n}\n\nlemma factorialCorrect(n: nat)\n  ensures factorial(n) == factorialSpec(n)\n{\n}\n\nlemma factorialPositive(n: nat)\n  ensures factorial(n) > 0\n{\n  if n == 0 {\n    assert factorial(0) == 1;\n  } else {\n    factorialPositive(n - 1);\n    assert factorial(n - 1) > 0;\n    assert n > 0;\n    assert factorial(n) == n * factorial(n - 1);\n    assert n * factorial(n - 1) > 0;\n  }\n}\n\nlemma factorialIncreasing(n: nat)\n  requires n > 0\n  ensures factorial(n) >= factorial(n - 1)\n{\n  factorialPositive(n - 1);\n  \n/*[CODE HERE]*/\n  assert n >= 1;\n  assert factorial(n - 1) > 0;\n  \n  calc {\n    factorial(n);\n    == n * factorial(n - 1);\n    >= 1 * factorial(n - 1);\n    == factorial(n - 1);\n  }\n}", "output": "assert factorial(n) == n * factorial(n - 1);"}, {"id": "example_factorialIncreasing_3", "type": "call", "program": "function factorial(n: nat): nat\n{\n  if n == 0 then 1\n  else n * factorial(n - 1)\n}\n\nfunction {:spec} factorialSpec(n: nat): nat\n{\n  if n == 0 then 1\n  else n * factorialSpec(n - 1)\n}\n\nlemma factorialCorrect(n: nat)\n  ensures factorial(n) == factorialSpec(n)\n{\n}\n\nlemma factorialPositive(n: nat)\n  ensures factorial(n) > 0\n{\n  if n == 0 {\n    assert factorial(0) == 1;\n  } else {\n    factorialPositive(n - 1);\n    assert factorial(n - 1) > 0;\n    assert n > 0;\n    assert factorial(n) == n * factorial(n - 1);\n    assert n * factorial(n - 1) > 0;\n  }\n}\n\nlemma factorialIncreasing(n: nat)\n  requires n > 0\n  ensures factorial(n) >= factorial(n - 1)\n{\n  \n/*[CODE HERE]*/\n  assert factorial(n) == n * factorial(n - 1);\n  assert n >= 1;\n  assert factorial(n - 1) > 0;\n  \n  calc {\n    factorial(n);\n    == n * factorial(n - 1);\n    >= 1 * factorial(n - 1);\n    == factorial(n - 1);\n  }\n}", "output": "factorialPositive(n - 1);"}, {"id": "example_fibPairCorrect_0", "type": "assert", "program": "function fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n-1) + fib(n-2)\n}\n\nfunction fibPair(n: nat): (nat, nat)\n{\n  if n == 0 then (0, 1)\n  else\n    var (a, b) := fibPair(n-1);\n    (b, a + b)\n}\n\nlemma fibCorrect(n: nat)\n  ensures fib(0) == 0\n  ensures fib(1) == 1\n  ensures n >= 2 ==> fib(n) == fib(n-1) + fib(n-2)\n{\n  // Trivial by definition\n}\n\nlemma fibPairCorrect(n: nat)\n  ensures fibPair(n) == (fib(n), fib(n+1))\n{\n  if n == 0 {\n    assert fibPair(0) == (0, 1);\n    assert fib(0) == 0;\n    assert fib(1) == 1;\n  } else {\n    fibPairCorrect(n-1);\n    var (a, b) := fibPair(n-1);\n    assert a == fib(n-1);\n    assert b == fib(n);\n    assert fibPair(n) == (b, a + b);\n    assert fibPair(n) == (fib(n), fib(n-1) + fib(n));\n    if n == 1 {\n      assert fib(2) == fib(1) + fib(0) == 1 + 0 == 1;\n      assert fibPair(1) == (1, 1);\n      assert fib(1) == 1;\n    } else {\n      \n/*[CODE HERE]*/\n    }\n  }\n}\n\nlemma fibIncreasing(n: nat)\n  ensures fib(n) <= fib(n+1)\n{\n  if n == 0 {\n    assert fib(0) == 0;\n    assert fib(1) == 1;\n  } else if n == 1 {\n    assert fib(1) == 1;\n    assert fib(2) == 1;\n  } else {\n    assert fib(n+1) == fib(n) + fib(n-1);\n    assert fib(n-1) >= 0;\n    assert fib(n+1) >= fib(n);\n  }\n}", "output": "assert fib(n+1) == fib(n) + fib(n-1);"}, {"id": "example_fibPairCorrect_1", "type": "assert", "program": "function fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n-1) + fib(n-2)\n}\n\nfunction fibPair(n: nat): (nat, nat)\n{\n  if n == 0 then (0, 1)\n  else\n    var (a, b) := fibPair(n-1);\n    (b, a + b)\n}\n\nlemma fibCorrect(n: nat)\n  ensures fib(0) == 0\n  ensures fib(1) == 1\n  ensures n >= 2 ==> fib(n) == fib(n-1) + fib(n-2)\n{\n  // Trivial by definition\n}\n\nlemma fibPairCorrect(n: nat)\n  ensures fibPair(n) == (fib(n), fib(n+1))\n{\n  if n == 0 {\n    assert fibPair(0) == (0, 1);\n    assert fib(0) == 0;\n    assert fib(1) == 1;\n  } else {\n    fibPairCorrect(n-1);\n    var (a, b) := fibPair(n-1);\n    assert a == fib(n-1);\n    assert b == fib(n);\n    assert fibPair(n) == (b, a + b);\n    assert fibPair(n) == (fib(n), fib(n-1) + fib(n));\n    if n == 1 {\n      assert fib(2) == fib(1) + fib(0) == 1 + 0 == 1;\n      assert fibPair(1) == (1, 1);\n      \n/*[CODE HERE]*/\n    } else {\n      assert fib(n+1) == fib(n) + fib(n-1);\n    }\n  }\n}\n\nlemma fibIncreasing(n: nat)\n  ensures fib(n) <= fib(n+1)\n{\n  if n == 0 {\n    assert fib(0) == 0;\n    assert fib(1) == 1;\n  } else if n == 1 {\n    assert fib(1) == 1;\n    assert fib(2) == 1;\n  } else {\n    assert fib(n+1) == fib(n) + fib(n-1);\n    assert fib(n-1) >= 0;\n    assert fib(n+1) >= fib(n);\n  }\n}", "output": "assert fib(1) == 1;"}, {"id": "example_fibPairCorrect_2", "type": "assert", "program": "function fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n-1) + fib(n-2)\n}\n\nfunction fibPair(n: nat): (nat, nat)\n{\n  if n == 0 then (0, 1)\n  else\n    var (a, b) := fibPair(n-1);\n    (b, a + b)\n}\n\nlemma fibCorrect(n: nat)\n  ensures fib(0) == 0\n  ensures fib(1) == 1\n  ensures n >= 2 ==> fib(n) == fib(n-1) + fib(n-2)\n{\n  // Trivial by definition\n}\n\nlemma fibPairCorrect(n: nat)\n  ensures fibPair(n) == (fib(n), fib(n+1))\n{\n  if n == 0 {\n    assert fibPair(0) == (0, 1);\n    assert fib(0) == 0;\n    assert fib(1) == 1;\n  } else {\n    fibPairCorrect(n-1);\n    var (a, b) := fibPair(n-1);\n    assert a == fib(n-1);\n    assert b == fib(n);\n    assert fibPair(n) == (b, a + b);\n    assert fibPair(n) == (fib(n), fib(n-1) + fib(n));\n    if n == 1 {\n      assert fib(2) == fib(1) + fib(0) == 1 + 0 == 1;\n      \n/*[CODE HERE]*/\n      assert fib(1) == 1;\n    } else {\n      assert fib(n+1) == fib(n) + fib(n-1);\n    }\n  }\n}\n\nlemma fibIncreasing(n: nat)\n  ensures fib(n) <= fib(n+1)\n{\n  if n == 0 {\n    assert fib(0) == 0;\n    assert fib(1) == 1;\n  } else if n == 1 {\n    assert fib(1) == 1;\n    assert fib(2) == 1;\n  } else {\n    assert fib(n+1) == fib(n) + fib(n-1);\n    assert fib(n-1) >= 0;\n    assert fib(n+1) >= fib(n);\n  }\n}", "output": "assert fibPair(1) == (1, 1);"}, {"id": "example_fibPairCorrect_3", "type": "assert", "program": "function fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n-1) + fib(n-2)\n}\n\nfunction fibPair(n: nat): (nat, nat)\n{\n  if n == 0 then (0, 1)\n  else\n    var (a, b) := fibPair(n-1);\n    (b, a + b)\n}\n\nlemma fibCorrect(n: nat)\n  ensures fib(0) == 0\n  ensures fib(1) == 1\n  ensures n >= 2 ==> fib(n) == fib(n-1) + fib(n-2)\n{\n  // Trivial by definition\n}\n\nlemma fibPairCorrect(n: nat)\n  ensures fibPair(n) == (fib(n), fib(n+1))\n{\n  if n == 0 {\n    assert fibPair(0) == (0, 1);\n    assert fib(0) == 0;\n    assert fib(1) == 1;\n  } else {\n    fibPairCorrect(n-1);\n    var (a, b) := fibPair(n-1);\n    assert a == fib(n-1);\n    assert b == fib(n);\n    assert fibPair(n) == (b, a + b);\n    assert fibPair(n) == (fib(n), fib(n-1) + fib(n));\n    if n == 1 {\n      \n/*[CODE HERE]*/\n      assert fibPair(1) == (1, 1);\n      assert fib(1) == 1;\n    } else {\n      assert fib(n+1) == fib(n) + fib(n-1);\n    }\n  }\n}\n\nlemma fibIncreasing(n: nat)\n  ensures fib(n) <= fib(n+1)\n{\n  if n == 0 {\n    assert fib(0) == 0;\n    assert fib(1) == 1;\n  } else if n == 1 {\n    assert fib(1) == 1;\n    assert fib(2) == 1;\n  } else {\n    assert fib(n+1) == fib(n) + fib(n-1);\n    assert fib(n-1) >= 0;\n    assert fib(n+1) >= fib(n);\n  }\n}", "output": "assert fib(2) == fib(1) + fib(0) == 1 + 0 == 1;"}, {"id": "example_fibPairCorrect_4", "type": "assert", "program": "function fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n-1) + fib(n-2)\n}\n\nfunction fibPair(n: nat): (nat, nat)\n{\n  if n == 0 then (0, 1)\n  else\n    var (a, b) := fibPair(n-1);\n    (b, a + b)\n}\n\nlemma fibCorrect(n: nat)\n  ensures fib(0) == 0\n  ensures fib(1) == 1\n  ensures n >= 2 ==> fib(n) == fib(n-1) + fib(n-2)\n{\n  // Trivial by definition\n}\n\nlemma fibPairCorrect(n: nat)\n  ensures fibPair(n) == (fib(n), fib(n+1))\n{\n  if n == 0 {\n    assert fibPair(0) == (0, 1);\n    assert fib(0) == 0;\n    assert fib(1) == 1;\n  } else {\n    fibPairCorrect(n-1);\n    var (a, b) := fibPair(n-1);\n    assert a == fib(n-1);\n    assert b == fib(n);\n    assert fibPair(n) == (b, a + b);\n    \n/*[CODE HERE]*/\n    if n == 1 {\n      assert fib(2) == fib(1) + fib(0) == 1 + 0 == 1;\n      assert fibPair(1) == (1, 1);\n      assert fib(1) == 1;\n    } else {\n      assert fib(n+1) == fib(n) + fib(n-1);\n    }\n  }\n}\n\nlemma fibIncreasing(n: nat)\n  ensures fib(n) <= fib(n+1)\n{\n  if n == 0 {\n    assert fib(0) == 0;\n    assert fib(1) == 1;\n  } else if n == 1 {\n    assert fib(1) == 1;\n    assert fib(2) == 1;\n  } else {\n    assert fib(n+1) == fib(n) + fib(n-1);\n    assert fib(n-1) >= 0;\n    assert fib(n+1) >= fib(n);\n  }\n}", "output": "assert fibPair(n) == (fib(n), fib(n-1) + fib(n));"}, {"id": "example_fibPairCorrect_5", "type": "assert", "program": "function fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n-1) + fib(n-2)\n}\n\nfunction fibPair(n: nat): (nat, nat)\n{\n  if n == 0 then (0, 1)\n  else\n    var (a, b) := fibPair(n-1);\n    (b, a + b)\n}\n\nlemma fibCorrect(n: nat)\n  ensures fib(0) == 0\n  ensures fib(1) == 1\n  ensures n >= 2 ==> fib(n) == fib(n-1) + fib(n-2)\n{\n  // Trivial by definition\n}\n\nlemma fibPairCorrect(n: nat)\n  ensures fibPair(n) == (fib(n), fib(n+1))\n{\n  if n == 0 {\n    assert fibPair(0) == (0, 1);\n    assert fib(0) == 0;\n    assert fib(1) == 1;\n  } else {\n    fibPairCorrect(n-1);\n    var (a, b) := fibPair(n-1);\n    assert a == fib(n-1);\n    assert b == fib(n);\n    \n/*[CODE HERE]*/\n    assert fibPair(n) == (fib(n), fib(n-1) + fib(n));\n    if n == 1 {\n      assert fib(2) == fib(1) + fib(0) == 1 + 0 == 1;\n      assert fibPair(1) == (1, 1);\n      assert fib(1) == 1;\n    } else {\n      assert fib(n+1) == fib(n) + fib(n-1);\n    }\n  }\n}\n\nlemma fibIncreasing(n: nat)\n  ensures fib(n) <= fib(n+1)\n{\n  if n == 0 {\n    assert fib(0) == 0;\n    assert fib(1) == 1;\n  } else if n == 1 {\n    assert fib(1) == 1;\n    assert fib(2) == 1;\n  } else {\n    assert fib(n+1) == fib(n) + fib(n-1);\n    assert fib(n-1) >= 0;\n    assert fib(n+1) >= fib(n);\n  }\n}", "output": "assert fibPair(n) == (b, a + b);"}, {"id": "example_fibPairCorrect_6", "type": "assert", "program": "function fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n-1) + fib(n-2)\n}\n\nfunction fibPair(n: nat): (nat, nat)\n{\n  if n == 0 then (0, 1)\n  else\n    var (a, b) := fibPair(n-1);\n    (b, a + b)\n}\n\nlemma fibCorrect(n: nat)\n  ensures fib(0) == 0\n  ensures fib(1) == 1\n  ensures n >= 2 ==> fib(n) == fib(n-1) + fib(n-2)\n{\n  // Trivial by definition\n}\n\nlemma fibPairCorrect(n: nat)\n  ensures fibPair(n) == (fib(n), fib(n+1))\n{\n  if n == 0 {\n    assert fibPair(0) == (0, 1);\n    assert fib(0) == 0;\n    assert fib(1) == 1;\n  } else {\n    fibPairCorrect(n-1);\n    var (a, b) := fibPair(n-1);\n    assert a == fib(n-1);\n    \n/*[CODE HERE]*/\n    assert fibPair(n) == (b, a + b);\n    assert fibPair(n) == (fib(n), fib(n-1) + fib(n));\n    if n == 1 {\n      assert fib(2) == fib(1) + fib(0) == 1 + 0 == 1;\n      assert fibPair(1) == (1, 1);\n      assert fib(1) == 1;\n    } else {\n      assert fib(n+1) == fib(n) + fib(n-1);\n    }\n  }\n}\n\nlemma fibIncreasing(n: nat)\n  ensures fib(n) <= fib(n+1)\n{\n  if n == 0 {\n    assert fib(0) == 0;\n    assert fib(1) == 1;\n  } else if n == 1 {\n    assert fib(1) == 1;\n    assert fib(2) == 1;\n  } else {\n    assert fib(n+1) == fib(n) + fib(n-1);\n    assert fib(n-1) >= 0;\n    assert fib(n+1) >= fib(n);\n  }\n}", "output": "assert b == fib(n);"}, {"id": "example_fibPairCorrect_7", "type": "assert", "program": "function fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n-1) + fib(n-2)\n}\n\nfunction fibPair(n: nat): (nat, nat)\n{\n  if n == 0 then (0, 1)\n  else\n    var (a, b) := fibPair(n-1);\n    (b, a + b)\n}\n\nlemma fibCorrect(n: nat)\n  ensures fib(0) == 0\n  ensures fib(1) == 1\n  ensures n >= 2 ==> fib(n) == fib(n-1) + fib(n-2)\n{\n  // Trivial by definition\n}\n\nlemma fibPairCorrect(n: nat)\n  ensures fibPair(n) == (fib(n), fib(n+1))\n{\n  if n == 0 {\n    assert fibPair(0) == (0, 1);\n    assert fib(0) == 0;\n    assert fib(1) == 1;\n  } else {\n    fibPairCorrect(n-1);\n    var (a, b) := fibPair(n-1);\n    \n/*[CODE HERE]*/\n    assert b == fib(n);\n    assert fibPair(n) == (b, a + b);\n    assert fibPair(n) == (fib(n), fib(n-1) + fib(n));\n    if n == 1 {\n      assert fib(2) == fib(1) + fib(0) == 1 + 0 == 1;\n      assert fibPair(1) == (1, 1);\n      assert fib(1) == 1;\n    } else {\n      assert fib(n+1) == fib(n) + fib(n-1);\n    }\n  }\n}\n\nlemma fibIncreasing(n: nat)\n  ensures fib(n) <= fib(n+1)\n{\n  if n == 0 {\n    assert fib(0) == 0;\n    assert fib(1) == 1;\n  } else if n == 1 {\n    assert fib(1) == 1;\n    assert fib(2) == 1;\n  } else {\n    assert fib(n+1) == fib(n) + fib(n-1);\n    assert fib(n-1) >= 0;\n    assert fib(n+1) >= fib(n);\n  }\n}", "output": "assert a == fib(n-1);"}, {"id": "example_fibPairCorrect_8", "type": "call", "program": "function fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n-1) + fib(n-2)\n}\n\nfunction fibPair(n: nat): (nat, nat)\n{\n  if n == 0 then (0, 1)\n  else\n    var (a, b) := fibPair(n-1);\n    (b, a + b)\n}\n\nlemma fibCorrect(n: nat)\n  ensures fib(0) == 0\n  ensures fib(1) == 1\n  ensures n >= 2 ==> fib(n) == fib(n-1) + fib(n-2)\n{\n  // Trivial by definition\n}\n\nlemma fibPairCorrect(n: nat)\n  ensures fibPair(n) == (fib(n), fib(n+1))\n{\n  if n == 0 {\n    assert fibPair(0) == (0, 1);\n    assert fib(0) == 0;\n    assert fib(1) == 1;\n  } else {\n    \n/*[CODE HERE]*/\n    var (a, b) := fibPair(n-1);\n    assert a == fib(n-1);\n    assert b == fib(n);\n    assert fibPair(n) == (b, a + b);\n    assert fibPair(n) == (fib(n), fib(n-1) + fib(n));\n    if n == 1 {\n      assert fib(2) == fib(1) + fib(0) == 1 + 0 == 1;\n      assert fibPair(1) == (1, 1);\n      assert fib(1) == 1;\n    } else {\n      assert fib(n+1) == fib(n) + fib(n-1);\n    }\n  }\n}\n\nlemma fibIncreasing(n: nat)\n  ensures fib(n) <= fib(n+1)\n{\n  if n == 0 {\n    assert fib(0) == 0;\n    assert fib(1) == 1;\n  } else if n == 1 {\n    assert fib(1) == 1;\n    assert fib(2) == 1;\n  } else {\n    assert fib(n+1) == fib(n) + fib(n-1);\n    assert fib(n-1) >= 0;\n    assert fib(n+1) >= fib(n);\n  }\n}", "output": "fibPairCorrect(n-1);"}, {"id": "example_fibPairCorrect_9", "type": "assert", "program": "function fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n-1) + fib(n-2)\n}\n\nfunction fibPair(n: nat): (nat, nat)\n{\n  if n == 0 then (0, 1)\n  else\n    var (a, b) := fibPair(n-1);\n    (b, a + b)\n}\n\nlemma fibCorrect(n: nat)\n  ensures fib(0) == 0\n  ensures fib(1) == 1\n  ensures n >= 2 ==> fib(n) == fib(n-1) + fib(n-2)\n{\n  // Trivial by definition\n}\n\nlemma fibPairCorrect(n: nat)\n  ensures fibPair(n) == (fib(n), fib(n+1))\n{\n  if n == 0 {\n    assert fibPair(0) == (0, 1);\n    assert fib(0) == 0;\n    \n/*[CODE HERE]*/\n  } else {\n    fibPairCorrect(n-1);\n    var (a, b) := fibPair(n-1);\n    assert a == fib(n-1);\n    assert b == fib(n);\n    assert fibPair(n) == (b, a + b);\n    assert fibPair(n) == (fib(n), fib(n-1) + fib(n));\n    if n == 1 {\n      assert fib(2) == fib(1) + fib(0) == 1 + 0 == 1;\n      assert fibPair(1) == (1, 1);\n      assert fib(1) == 1;\n    } else {\n      assert fib(n+1) == fib(n) + fib(n-1);\n    }\n  }\n}\n\nlemma fibIncreasing(n: nat)\n  ensures fib(n) <= fib(n+1)\n{\n  if n == 0 {\n    assert fib(0) == 0;\n    assert fib(1) == 1;\n  } else if n == 1 {\n    assert fib(1) == 1;\n    assert fib(2) == 1;\n  } else {\n    assert fib(n+1) == fib(n) + fib(n-1);\n    assert fib(n-1) >= 0;\n    assert fib(n+1) >= fib(n);\n  }\n}", "output": "assert fib(1) == 1;"}, {"id": "example_fibPairCorrect_10", "type": "assert", "program": "function fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n-1) + fib(n-2)\n}\n\nfunction fibPair(n: nat): (nat, nat)\n{\n  if n == 0 then (0, 1)\n  else\n    var (a, b) := fibPair(n-1);\n    (b, a + b)\n}\n\nlemma fibCorrect(n: nat)\n  ensures fib(0) == 0\n  ensures fib(1) == 1\n  ensures n >= 2 ==> fib(n) == fib(n-1) + fib(n-2)\n{\n  // Trivial by definition\n}\n\nlemma fibPairCorrect(n: nat)\n  ensures fibPair(n) == (fib(n), fib(n+1))\n{\n  if n == 0 {\n    assert fibPair(0) == (0, 1);\n    \n/*[CODE HERE]*/\n    assert fib(1) == 1;\n  } else {\n    fibPairCorrect(n-1);\n    var (a, b) := fibPair(n-1);\n    assert a == fib(n-1);\n    assert b == fib(n);\n    assert fibPair(n) == (b, a + b);\n    assert fibPair(n) == (fib(n), fib(n-1) + fib(n));\n    if n == 1 {\n      assert fib(2) == fib(1) + fib(0) == 1 + 0 == 1;\n      assert fibPair(1) == (1, 1);\n      assert fib(1) == 1;\n    } else {\n      assert fib(n+1) == fib(n) + fib(n-1);\n    }\n  }\n}\n\nlemma fibIncreasing(n: nat)\n  ensures fib(n) <= fib(n+1)\n{\n  if n == 0 {\n    assert fib(0) == 0;\n    assert fib(1) == 1;\n  } else if n == 1 {\n    assert fib(1) == 1;\n    assert fib(2) == 1;\n  } else {\n    assert fib(n+1) == fib(n) + fib(n-1);\n    assert fib(n-1) >= 0;\n    assert fib(n+1) >= fib(n);\n  }\n}", "output": "assert fib(0) == 0;"}, {"id": "example_fibPairCorrect_11", "type": "assert", "program": "function fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n-1) + fib(n-2)\n}\n\nfunction fibPair(n: nat): (nat, nat)\n{\n  if n == 0 then (0, 1)\n  else\n    var (a, b) := fibPair(n-1);\n    (b, a + b)\n}\n\nlemma fibCorrect(n: nat)\n  ensures fib(0) == 0\n  ensures fib(1) == 1\n  ensures n >= 2 ==> fib(n) == fib(n-1) + fib(n-2)\n{\n  // Trivial by definition\n}\n\nlemma fibPairCorrect(n: nat)\n  ensures fibPair(n) == (fib(n), fib(n+1))\n{\n  if n == 0 {\n    \n/*[CODE HERE]*/\n    assert fib(0) == 0;\n    assert fib(1) == 1;\n  } else {\n    fibPairCorrect(n-1);\n    var (a, b) := fibPair(n-1);\n    assert a == fib(n-1);\n    assert b == fib(n);\n    assert fibPair(n) == (b, a + b);\n    assert fibPair(n) == (fib(n), fib(n-1) + fib(n));\n    if n == 1 {\n      assert fib(2) == fib(1) + fib(0) == 1 + 0 == 1;\n      assert fibPair(1) == (1, 1);\n      assert fib(1) == 1;\n    } else {\n      assert fib(n+1) == fib(n) + fib(n-1);\n    }\n  }\n}\n\nlemma fibIncreasing(n: nat)\n  ensures fib(n) <= fib(n+1)\n{\n  if n == 0 {\n    assert fib(0) == 0;\n    assert fib(1) == 1;\n  } else if n == 1 {\n    assert fib(1) == 1;\n    assert fib(2) == 1;\n  } else {\n    assert fib(n+1) == fib(n) + fib(n-1);\n    assert fib(n-1) >= 0;\n    assert fib(n+1) >= fib(n);\n  }\n}", "output": "assert fibPair(0) == (0, 1);"}, {"id": "example_fibIncreasing_0", "type": "assert", "program": "function fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n-1) + fib(n-2)\n}\n\nfunction fibPair(n: nat): (nat, nat)\n{\n  if n == 0 then (0, 1)\n  else\n    var (a, b) := fibPair(n-1);\n    (b, a + b)\n}\n\nlemma fibCorrect(n: nat)\n  ensures fib(0) == 0\n  ensures fib(1) == 1\n  ensures n >= 2 ==> fib(n) == fib(n-1) + fib(n-2)\n{\n  // Trivial by definition\n}\n\nlemma fibPairCorrect(n: nat)\n  ensures fibPair(n) == (fib(n), fib(n+1))\n{\n  if n == 0 {\n    assert fibPair(0) == (0, 1);\n    assert fib(0) == 0;\n    assert fib(1) == 1;\n  } else {\n    fibPairCorrect(n-1);\n    var (a, b) := fibPair(n-1);\n    assert a == fib(n-1);\n    assert b == fib(n);\n    assert fibPair(n) == (b, a + b);\n    assert fibPair(n) == (fib(n), fib(n-1) + fib(n));\n    if n == 1 {\n      assert fib(2) == fib(1) + fib(0) == 1 + 0 == 1;\n      assert fibPair(1) == (1, 1);\n      assert fib(1) == 1;\n    } else {\n      assert fib(n+1) == fib(n) + fib(n-1);\n    }\n  }\n}\n\nlemma fibIncreasing(n: nat)\n  ensures fib(n) <= fib(n+1)\n{\n  if n == 0 {\n    assert fib(0) == 0;\n    assert fib(1) == 1;\n  } else if n == 1 {\n    assert fib(1) == 1;\n    assert fib(2) == 1;\n  } else {\n    assert fib(n+1) == fib(n) + fib(n-1);\n    assert fib(n-1) >= 0;\n    \n/*[CODE HERE]*/\n  }\n}", "output": "assert fib(n+1) >= fib(n);"}, {"id": "example_fibIncreasing_1", "type": "assert", "program": "function fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n-1) + fib(n-2)\n}\n\nfunction fibPair(n: nat): (nat, nat)\n{\n  if n == 0 then (0, 1)\n  else\n    var (a, b) := fibPair(n-1);\n    (b, a + b)\n}\n\nlemma fibCorrect(n: nat)\n  ensures fib(0) == 0\n  ensures fib(1) == 1\n  ensures n >= 2 ==> fib(n) == fib(n-1) + fib(n-2)\n{\n  // Trivial by definition\n}\n\nlemma fibPairCorrect(n: nat)\n  ensures fibPair(n) == (fib(n), fib(n+1))\n{\n  if n == 0 {\n    assert fibPair(0) == (0, 1);\n    assert fib(0) == 0;\n    assert fib(1) == 1;\n  } else {\n    fibPairCorrect(n-1);\n    var (a, b) := fibPair(n-1);\n    assert a == fib(n-1);\n    assert b == fib(n);\n    assert fibPair(n) == (b, a + b);\n    assert fibPair(n) == (fib(n), fib(n-1) + fib(n));\n    if n == 1 {\n      assert fib(2) == fib(1) + fib(0) == 1 + 0 == 1;\n      assert fibPair(1) == (1, 1);\n      assert fib(1) == 1;\n    } else {\n      assert fib(n+1) == fib(n) + fib(n-1);\n    }\n  }\n}\n\nlemma fibIncreasing(n: nat)\n  ensures fib(n) <= fib(n+1)\n{\n  if n == 0 {\n    assert fib(0) == 0;\n    assert fib(1) == 1;\n  } else if n == 1 {\n    assert fib(1) == 1;\n    assert fib(2) == 1;\n  } else {\n    assert fib(n+1) == fib(n) + fib(n-1);\n    \n/*[CODE HERE]*/\n    assert fib(n+1) >= fib(n);\n  }\n}", "output": "assert fib(n-1) >= 0;"}, {"id": "example_fibIncreasing_2", "type": "assert", "program": "function fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n-1) + fib(n-2)\n}\n\nfunction fibPair(n: nat): (nat, nat)\n{\n  if n == 0 then (0, 1)\n  else\n    var (a, b) := fibPair(n-1);\n    (b, a + b)\n}\n\nlemma fibCorrect(n: nat)\n  ensures fib(0) == 0\n  ensures fib(1) == 1\n  ensures n >= 2 ==> fib(n) == fib(n-1) + fib(n-2)\n{\n  // Trivial by definition\n}\n\nlemma fibPairCorrect(n: nat)\n  ensures fibPair(n) == (fib(n), fib(n+1))\n{\n  if n == 0 {\n    assert fibPair(0) == (0, 1);\n    assert fib(0) == 0;\n    assert fib(1) == 1;\n  } else {\n    fibPairCorrect(n-1);\n    var (a, b) := fibPair(n-1);\n    assert a == fib(n-1);\n    assert b == fib(n);\n    assert fibPair(n) == (b, a + b);\n    assert fibPair(n) == (fib(n), fib(n-1) + fib(n));\n    if n == 1 {\n      assert fib(2) == fib(1) + fib(0) == 1 + 0 == 1;\n      assert fibPair(1) == (1, 1);\n      assert fib(1) == 1;\n    } else {\n      assert fib(n+1) == fib(n) + fib(n-1);\n    }\n  }\n}\n\nlemma fibIncreasing(n: nat)\n  ensures fib(n) <= fib(n+1)\n{\n  if n == 0 {\n    assert fib(0) == 0;\n    assert fib(1) == 1;\n  } else if n == 1 {\n    assert fib(1) == 1;\n    assert fib(2) == 1;\n  } else {\n    \n/*[CODE HERE]*/\n    assert fib(n-1) >= 0;\n    assert fib(n+1) >= fib(n);\n  }\n}", "output": "assert fib(n+1) == fib(n) + fib(n-1);"}, {"id": "example_fibIncreasing_3", "type": "assert", "program": "function fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n-1) + fib(n-2)\n}\n\nfunction fibPair(n: nat): (nat, nat)\n{\n  if n == 0 then (0, 1)\n  else\n    var (a, b) := fibPair(n-1);\n    (b, a + b)\n}\n\nlemma fibCorrect(n: nat)\n  ensures fib(0) == 0\n  ensures fib(1) == 1\n  ensures n >= 2 ==> fib(n) == fib(n-1) + fib(n-2)\n{\n  // Trivial by definition\n}\n\nlemma fibPairCorrect(n: nat)\n  ensures fibPair(n) == (fib(n), fib(n+1))\n{\n  if n == 0 {\n    assert fibPair(0) == (0, 1);\n    assert fib(0) == 0;\n    assert fib(1) == 1;\n  } else {\n    fibPairCorrect(n-1);\n    var (a, b) := fibPair(n-1);\n    assert a == fib(n-1);\n    assert b == fib(n);\n    assert fibPair(n) == (b, a + b);\n    assert fibPair(n) == (fib(n), fib(n-1) + fib(n));\n    if n == 1 {\n      assert fib(2) == fib(1) + fib(0) == 1 + 0 == 1;\n      assert fibPair(1) == (1, 1);\n      assert fib(1) == 1;\n    } else {\n      assert fib(n+1) == fib(n) + fib(n-1);\n    }\n  }\n}\n\nlemma fibIncreasing(n: nat)\n  ensures fib(n) <= fib(n+1)\n{\n  if n == 0 {\n    assert fib(0) == 0;\n    assert fib(1) == 1;\n  } else if n == 1 {\n    assert fib(1) == 1;\n    \n/*[CODE HERE]*/\n  } else {\n    assert fib(n+1) == fib(n) + fib(n-1);\n    assert fib(n-1) >= 0;\n    assert fib(n+1) >= fib(n);\n  }\n}", "output": "assert fib(2) == 1;"}, {"id": "example_fibIncreasing_4", "type": "assert", "program": "function fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n-1) + fib(n-2)\n}\n\nfunction fibPair(n: nat): (nat, nat)\n{\n  if n == 0 then (0, 1)\n  else\n    var (a, b) := fibPair(n-1);\n    (b, a + b)\n}\n\nlemma fibCorrect(n: nat)\n  ensures fib(0) == 0\n  ensures fib(1) == 1\n  ensures n >= 2 ==> fib(n) == fib(n-1) + fib(n-2)\n{\n  // Trivial by definition\n}\n\nlemma fibPairCorrect(n: nat)\n  ensures fibPair(n) == (fib(n), fib(n+1))\n{\n  if n == 0 {\n    assert fibPair(0) == (0, 1);\n    assert fib(0) == 0;\n    assert fib(1) == 1;\n  } else {\n    fibPairCorrect(n-1);\n    var (a, b) := fibPair(n-1);\n    assert a == fib(n-1);\n    assert b == fib(n);\n    assert fibPair(n) == (b, a + b);\n    assert fibPair(n) == (fib(n), fib(n-1) + fib(n));\n    if n == 1 {\n      assert fib(2) == fib(1) + fib(0) == 1 + 0 == 1;\n      assert fibPair(1) == (1, 1);\n      assert fib(1) == 1;\n    } else {\n      assert fib(n+1) == fib(n) + fib(n-1);\n    }\n  }\n}\n\nlemma fibIncreasing(n: nat)\n  ensures fib(n) <= fib(n+1)\n{\n  if n == 0 {\n    assert fib(0) == 0;\n    assert fib(1) == 1;\n  } else if n == 1 {\n    \n/*[CODE HERE]*/\n    assert fib(2) == 1;\n  } else {\n    assert fib(n+1) == fib(n) + fib(n-1);\n    assert fib(n-1) >= 0;\n    assert fib(n+1) >= fib(n);\n  }\n}", "output": "assert fib(1) == 1;"}, {"id": "example_fibIncreasing_5", "type": "assert", "program": "function fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n-1) + fib(n-2)\n}\n\nfunction fibPair(n: nat): (nat, nat)\n{\n  if n == 0 then (0, 1)\n  else\n    var (a, b) := fibPair(n-1);\n    (b, a + b)\n}\n\nlemma fibCorrect(n: nat)\n  ensures fib(0) == 0\n  ensures fib(1) == 1\n  ensures n >= 2 ==> fib(n) == fib(n-1) + fib(n-2)\n{\n  // Trivial by definition\n}\n\nlemma fibPairCorrect(n: nat)\n  ensures fibPair(n) == (fib(n), fib(n+1))\n{\n  if n == 0 {\n    assert fibPair(0) == (0, 1);\n    assert fib(0) == 0;\n    assert fib(1) == 1;\n  } else {\n    fibPairCorrect(n-1);\n    var (a, b) := fibPair(n-1);\n    assert a == fib(n-1);\n    assert b == fib(n);\n    assert fibPair(n) == (b, a + b);\n    assert fibPair(n) == (fib(n), fib(n-1) + fib(n));\n    if n == 1 {\n      assert fib(2) == fib(1) + fib(0) == 1 + 0 == 1;\n      assert fibPair(1) == (1, 1);\n      assert fib(1) == 1;\n    } else {\n      assert fib(n+1) == fib(n) + fib(n-1);\n    }\n  }\n}\n\nlemma fibIncreasing(n: nat)\n  ensures fib(n) <= fib(n+1)\n{\n  if n == 0 {\n    assert fib(0) == 0;\n    \n/*[CODE HERE]*/\n  } else if n == 1 {\n    assert fib(1) == 1;\n    assert fib(2) == 1;\n  } else {\n    assert fib(n+1) == fib(n) + fib(n-1);\n    assert fib(n-1) >= 0;\n    assert fib(n+1) >= fib(n);\n  }\n}", "output": "assert fib(1) == 1;"}, {"id": "example_fibIncreasing_6", "type": "assert", "program": "function fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n-1) + fib(n-2)\n}\n\nfunction fibPair(n: nat): (nat, nat)\n{\n  if n == 0 then (0, 1)\n  else\n    var (a, b) := fibPair(n-1);\n    (b, a + b)\n}\n\nlemma fibCorrect(n: nat)\n  ensures fib(0) == 0\n  ensures fib(1) == 1\n  ensures n >= 2 ==> fib(n) == fib(n-1) + fib(n-2)\n{\n  // Trivial by definition\n}\n\nlemma fibPairCorrect(n: nat)\n  ensures fibPair(n) == (fib(n), fib(n+1))\n{\n  if n == 0 {\n    assert fibPair(0) == (0, 1);\n    assert fib(0) == 0;\n    assert fib(1) == 1;\n  } else {\n    fibPairCorrect(n-1);\n    var (a, b) := fibPair(n-1);\n    assert a == fib(n-1);\n    assert b == fib(n);\n    assert fibPair(n) == (b, a + b);\n    assert fibPair(n) == (fib(n), fib(n-1) + fib(n));\n    if n == 1 {\n      assert fib(2) == fib(1) + fib(0) == 1 + 0 == 1;\n      assert fibPair(1) == (1, 1);\n      assert fib(1) == 1;\n    } else {\n      assert fib(n+1) == fib(n) + fib(n-1);\n    }\n  }\n}\n\nlemma fibIncreasing(n: nat)\n  ensures fib(n) <= fib(n+1)\n{\n  if n == 0 {\n    \n/*[CODE HERE]*/\n    assert fib(1) == 1;\n  } else if n == 1 {\n    assert fib(1) == 1;\n    assert fib(2) == 1;\n  } else {\n    assert fib(n+1) == fib(n) + fib(n-1);\n    assert fib(n-1) >= 0;\n    assert fib(n+1) >= fib(n);\n  }\n}", "output": "assert fib(0) == 0;"}, {"id": "example_toMultisetAppend_0", "type": "assert", "program": "datatype Tree<T> = Leaf(value: T) | Node(left: Tree<T>, right: Tree<T>)\n\nfunction flatten<T>(t: Tree<T>): seq<T>\n{\n  match t\n  case Leaf(v) => [v]\n  case Node(l, r) => flatten(l) + flatten(r)\n}\n\nfunction size<T>(t: Tree<T>): nat\n{\n  match t\n  case Leaf(_) => 1\n  case Node(l, r) => size(l) + size(r)\n}\n\nfunction toMultiset<T>(s: seq<T>): multiset<T>\n{\n  if |s| == 0 then multiset{}\n  else multiset{s[0]} + toMultiset(s[1..])\n}\n\nfunction treeToMultiset<T>(t: Tree<T>): multiset<T>\n{\n  match t\n  case Leaf(v) => multiset{v}\n  case Node(l, r) => treeToMultiset(l) + treeToMultiset(r)\n}\n\nlemma toMultisetAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures toMultiset(s1 + s2) == toMultiset(s1) + toMultiset(s2)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n  } else {\n    toMultisetAppend(s1[1..], s2);\n    \n/*[CODE HERE]*/\n  }\n}\n\nlemma flattenCorrect<T>(t: Tree<T>)\n  ensures |flatten(t)| == size(t)\n  ensures toMultiset(flatten(t)) == treeToMultiset(t)\n{\n  match t\n  case Leaf(v) =>\n  case Node(l, r) =>\n    flattenCorrect(l);\n    flattenCorrect(r);\n    toMultisetAppend(flatten(l), flatten(r));\n}", "output": "assert s1 + s2 == [s1[0]] + (s1[1..] + s2);"}, {"id": "example_toMultisetAppend_1", "type": "call", "program": "datatype Tree<T> = Leaf(value: T) | Node(left: Tree<T>, right: Tree<T>)\n\nfunction flatten<T>(t: Tree<T>): seq<T>\n{\n  match t\n  case Leaf(v) => [v]\n  case Node(l, r) => flatten(l) + flatten(r)\n}\n\nfunction size<T>(t: Tree<T>): nat\n{\n  match t\n  case Leaf(_) => 1\n  case Node(l, r) => size(l) + size(r)\n}\n\nfunction toMultiset<T>(s: seq<T>): multiset<T>\n{\n  if |s| == 0 then multiset{}\n  else multiset{s[0]} + toMultiset(s[1..])\n}\n\nfunction treeToMultiset<T>(t: Tree<T>): multiset<T>\n{\n  match t\n  case Leaf(v) => multiset{v}\n  case Node(l, r) => treeToMultiset(l) + treeToMultiset(r)\n}\n\nlemma toMultisetAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures toMultiset(s1 + s2) == toMultiset(s1) + toMultiset(s2)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n  } else {\n    \n/*[CODE HERE]*/\n    assert s1 + s2 == [s1[0]] + (s1[1..] + s2);\n  }\n}\n\nlemma flattenCorrect<T>(t: Tree<T>)\n  ensures |flatten(t)| == size(t)\n  ensures toMultiset(flatten(t)) == treeToMultiset(t)\n{\n  match t\n  case Leaf(v) =>\n  case Node(l, r) =>\n    flattenCorrect(l);\n    flattenCorrect(r);\n    toMultisetAppend(flatten(l), flatten(r));\n}", "output": "toMultisetAppend(s1[1..], s2);"}, {"id": "example_toMultisetAppend_2", "type": "assert", "program": "datatype Tree<T> = Leaf(value: T) | Node(left: Tree<T>, right: Tree<T>)\n\nfunction flatten<T>(t: Tree<T>): seq<T>\n{\n  match t\n  case Leaf(v) => [v]\n  case Node(l, r) => flatten(l) + flatten(r)\n}\n\nfunction size<T>(t: Tree<T>): nat\n{\n  match t\n  case Leaf(_) => 1\n  case Node(l, r) => size(l) + size(r)\n}\n\nfunction toMultiset<T>(s: seq<T>): multiset<T>\n{\n  if |s| == 0 then multiset{}\n  else multiset{s[0]} + toMultiset(s[1..])\n}\n\nfunction treeToMultiset<T>(t: Tree<T>): multiset<T>\n{\n  match t\n  case Leaf(v) => multiset{v}\n  case Node(l, r) => treeToMultiset(l) + treeToMultiset(r)\n}\n\nlemma toMultisetAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures toMultiset(s1 + s2) == toMultiset(s1) + toMultiset(s2)\n{\n  if |s1| == 0 {\n    \n/*[CODE HERE]*/\n  } else {\n    toMultisetAppend(s1[1..], s2);\n    assert s1 + s2 == [s1[0]] + (s1[1..] + s2);\n  }\n}\n\nlemma flattenCorrect<T>(t: Tree<T>)\n  ensures |flatten(t)| == size(t)\n  ensures toMultiset(flatten(t)) == treeToMultiset(t)\n{\n  match t\n  case Leaf(v) =>\n  case Node(l, r) =>\n    flattenCorrect(l);\n    flattenCorrect(r);\n    toMultisetAppend(flatten(l), flatten(r));\n}", "output": "assert s1 + s2 == s2;"}, {"id": "example_flattenCorrect_0", "type": "call", "program": "datatype Tree<T> = Leaf(value: T) | Node(left: Tree<T>, right: Tree<T>)\n\nfunction flatten<T>(t: Tree<T>): seq<T>\n{\n  match t\n  case Leaf(v) => [v]\n  case Node(l, r) => flatten(l) + flatten(r)\n}\n\nfunction size<T>(t: Tree<T>): nat\n{\n  match t\n  case Leaf(_) => 1\n  case Node(l, r) => size(l) + size(r)\n}\n\nfunction toMultiset<T>(s: seq<T>): multiset<T>\n{\n  if |s| == 0 then multiset{}\n  else multiset{s[0]} + toMultiset(s[1..])\n}\n\nfunction treeToMultiset<T>(t: Tree<T>): multiset<T>\n{\n  match t\n  case Leaf(v) => multiset{v}\n  case Node(l, r) => treeToMultiset(l) + treeToMultiset(r)\n}\n\nlemma toMultisetAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures toMultiset(s1 + s2) == toMultiset(s1) + toMultiset(s2)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n  } else {\n    toMultisetAppend(s1[1..], s2);\n    assert s1 + s2 == [s1[0]] + (s1[1..] + s2);\n  }\n}\n\nlemma flattenCorrect<T>(t: Tree<T>)\n  ensures |flatten(t)| == size(t)\n  ensures toMultiset(flatten(t)) == treeToMultiset(t)\n{\n  match t\n  case Leaf(v) =>\n  case Node(l, r) =>\n    flattenCorrect(l);\n    flattenCorrect(r);\n    \n/*[CODE HERE]*/\n}", "output": "toMultisetAppend(flatten(l), flatten(r));"}, {"id": "example_flattenCorrect_1", "type": "call", "program": "datatype Tree<T> = Leaf(value: T) | Node(left: Tree<T>, right: Tree<T>)\n\nfunction flatten<T>(t: Tree<T>): seq<T>\n{\n  match t\n  case Leaf(v) => [v]\n  case Node(l, r) => flatten(l) + flatten(r)\n}\n\nfunction size<T>(t: Tree<T>): nat\n{\n  match t\n  case Leaf(_) => 1\n  case Node(l, r) => size(l) + size(r)\n}\n\nfunction toMultiset<T>(s: seq<T>): multiset<T>\n{\n  if |s| == 0 then multiset{}\n  else multiset{s[0]} + toMultiset(s[1..])\n}\n\nfunction treeToMultiset<T>(t: Tree<T>): multiset<T>\n{\n  match t\n  case Leaf(v) => multiset{v}\n  case Node(l, r) => treeToMultiset(l) + treeToMultiset(r)\n}\n\nlemma toMultisetAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures toMultiset(s1 + s2) == toMultiset(s1) + toMultiset(s2)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n  } else {\n    toMultisetAppend(s1[1..], s2);\n    assert s1 + s2 == [s1[0]] + (s1[1..] + s2);\n  }\n}\n\nlemma flattenCorrect<T>(t: Tree<T>)\n  ensures |flatten(t)| == size(t)\n  ensures toMultiset(flatten(t)) == treeToMultiset(t)\n{\n  match t\n  case Leaf(v) =>\n  case Node(l, r) =>\n    flattenCorrect(l);\n    \n/*[CODE HERE]*/\n    toMultisetAppend(flatten(l), flatten(r));\n}", "output": "flattenCorrect(r);"}, {"id": "example_flattenCorrect_2", "type": "call", "program": "datatype Tree<T> = Leaf(value: T) | Node(left: Tree<T>, right: Tree<T>)\n\nfunction flatten<T>(t: Tree<T>): seq<T>\n{\n  match t\n  case Leaf(v) => [v]\n  case Node(l, r) => flatten(l) + flatten(r)\n}\n\nfunction size<T>(t: Tree<T>): nat\n{\n  match t\n  case Leaf(_) => 1\n  case Node(l, r) => size(l) + size(r)\n}\n\nfunction toMultiset<T>(s: seq<T>): multiset<T>\n{\n  if |s| == 0 then multiset{}\n  else multiset{s[0]} + toMultiset(s[1..])\n}\n\nfunction treeToMultiset<T>(t: Tree<T>): multiset<T>\n{\n  match t\n  case Leaf(v) => multiset{v}\n  case Node(l, r) => treeToMultiset(l) + treeToMultiset(r)\n}\n\nlemma toMultisetAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures toMultiset(s1 + s2) == toMultiset(s1) + toMultiset(s2)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n  } else {\n    toMultisetAppend(s1[1..], s2);\n    assert s1 + s2 == [s1[0]] + (s1[1..] + s2);\n  }\n}\n\nlemma flattenCorrect<T>(t: Tree<T>)\n  ensures |flatten(t)| == size(t)\n  ensures toMultiset(flatten(t)) == treeToMultiset(t)\n{\n  match t\n  case Leaf(v) =>\n  case Node(l, r) =>\n    \n/*[CODE HERE]*/\n    flattenCorrect(r);\n    toMultisetAppend(flatten(l), flatten(r));\n}", "output": "flattenCorrect(l);"}, {"id": "example_ok3_pizza_0", "type": "assert", "program": "datatype Topping = Tomato | Cheese | Olive | Broccoli | Mushroom | Pepper\n\ndatatype Food = Pasta(toppings: seq<Topping>) | Pizza(toppings: seq<Topping>)\n\npredicate ok(f: Food)\n{\n  match f\n  case Pizza(tops) => |tops| <= 5\n  case Pasta(tops) => |tops| <= 2\n}\n\nlemma ok3_pizza(f: Food)\n  requires ok(f)\n  requires |f.toppings| >= 3\n  ensures f.Pizza?\n{\n  match f\n  case Pizza(_) =>\n    // Already a pizza\n  case Pasta(tops) =>\n    // Pasta with ok(f) means |tops| <= 2\n    // But we require |f.toppings| >= 3\n    assert |tops| <= 2;\n    assert |tops| >= 3;\n    \n/*[CODE HERE]*/\n}", "output": "assert false;"}, {"id": "example_ok3_pizza_1", "type": "assert", "program": "datatype Topping = Tomato | Cheese | Olive | Broccoli | Mushroom | Pepper\n\ndatatype Food = Pasta(toppings: seq<Topping>) | Pizza(toppings: seq<Topping>)\n\npredicate ok(f: Food)\n{\n  match f\n  case Pizza(tops) => |tops| <= 5\n  case Pasta(tops) => |tops| <= 2\n}\n\nlemma ok3_pizza(f: Food)\n  requires ok(f)\n  requires |f.toppings| >= 3\n  ensures f.Pizza?\n{\n  match f\n  case Pizza(_) =>\n    // Already a pizza\n  case Pasta(tops) =>\n    // Pasta with ok(f) means |tops| <= 2\n    // But we require |f.toppings| >= 3\n    assert |tops| <= 2;\n    \n/*[CODE HERE]*/\n    assert false;\n}", "output": "assert |tops| >= 3;"}, {"id": "example_ok3_pizza_2", "type": "assert", "program": "datatype Topping = Tomato | Cheese | Olive | Broccoli | Mushroom | Pepper\n\ndatatype Food = Pasta(toppings: seq<Topping>) | Pizza(toppings: seq<Topping>)\n\npredicate ok(f: Food)\n{\n  match f\n  case Pizza(tops) => |tops| <= 5\n  case Pasta(tops) => |tops| <= 2\n}\n\nlemma ok3_pizza(f: Food)\n  requires ok(f)\n  requires |f.toppings| >= 3\n  ensures f.Pizza?\n{\n  match f\n  case Pizza(_) =>\n    // Already a pizza\n  case Pasta(tops) =>\n    // Pasta with ok(f) means |tops| <= 2\n    // But we require |f.toppings| >= 3\n    \n/*[CODE HERE]*/\n    assert |tops| >= 3;\n    assert false;\n}", "output": "assert |tops| <= 2;"}, {"id": "example_SelfReachable_0", "type": "assert", "program": "// Graph operations: path, reachable, cycle detection\n\ntype Node = nat\n\ndatatype Graph = Graph(nodes: set<Node>, edges: set<(Node, Node)>)\n\npredicate {:spec} validGraph(g: Graph)\n{\n  forall e :: e in g.edges ==> e.0 in g.nodes && e.1 in g.nodes\n}\n\npredicate {:spec} hasEdge(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n{\n  (from, to) in g.edges\n}\n\nfunction {:spec} neighbors(g: Graph, n: Node): set<Node>\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  set m | m in g.nodes && (n, m) in g.edges\n}\n\npredicate {:spec} isPath(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n{\n  |path| > 0 &&\n  (forall i :: 0 <= i < |path| ==> path[i] in g.nodes) &&\n  (forall i :: 0 <= i < |path| - 1 ==> hasEdge(g, path[i], path[i+1]))\n}\n\nghost predicate {:spec} reachable(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n{\n  exists path :: isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to\n}\n\nghost predicate {:spec} hasCycle(g: Graph)\n  requires validGraph(g)\n{\n  exists path :: isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1]\n}\n\nghost predicate {:spec} isAcyclic(g: Graph)\n  requires validGraph(g)\n{\n  !hasCycle(g)\n}\n\nghost predicate {:spec} isTree(g: Graph)\n  requires validGraph(g)\n{\n  isAcyclic(g) &&\n  |g.edges| == |g.nodes| - 1 &&\n  forall n, m :: n in g.nodes && m in g.nodes && n != m ==> reachable(g, n, m)\n}\n\nfunction {:spec} inDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |set m | m in g.nodes && (m, n) in g.edges|\n}\n\nfunction {:spec} outDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |neighbors(g, n)|\n}\n\nghost predicate {:spec} isConnected(g: Graph)\n  requires validGraph(g)\n{\n  forall n, m :: n in g.nodes && m in g.nodes ==> reachable(g, n, m)\n}\n\n// Simplified version without recursion\nghost function {:spec} graphDistance(g: Graph, from: Node, to: Node): nat\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n  requires reachable(g, from, to)\n{\n  var path :| isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to;\n  |path| - 1\n}\n\nlemma SelfReachable(g: Graph, n: Node)\n  requires validGraph(g)\n  requires n in g.nodes\n  ensures reachable(g, n, n)\n{\n  var path := [n];\n  assert |path| == 1;\n  assert |path| >= 1;\n  assert path[0] == n;\n  assert path[|path| - 1] == n;\n\n  // Show isPath\n  forall i | 0 <= i < |path|\n    ensures path[i] in g.nodes\n  {\n    assert path[i] == n;\n  }\n\n  forall i | 0 <= i < |path| - 1\n    ensures hasEdge(g, path[i], path[i+1])\n  {\n    assert false;  // No such i exists since |path| == 1\n  }\n\n  \n/*[CODE HERE]*/\n}\n\nlemma DirectEdgeReachable(g: Graph, a: Node, b: Node)\n  requires validGraph(g)\n  requires a in g.nodes && b in g.nodes\n  requires hasEdge(g, a, b)\n  ensures reachable(g, a, b)\n{\n  assert b in neighbors(g, a);\n  if a == b {\n    SelfReachable(g, a);\n  } else {\n    var path := [a, b];\n    assert |path| == 2;\n    assert |path| >= 1;\n    assert path[0] == a;\n    assert path[|path| - 1] == b;\n\n    // Show isPath\n    forall i | 0 <= i < |path|\n      ensures path[i] in g.nodes\n    {\n      if i == 0 { assert path[i] == a; }\n      else { assert path[i] == b; }\n    }\n\n    forall i | 0 <= i < |path| - 1\n      ensures hasEdge(g, path[i], path[i+1])\n    {\n      assert i == 0;\n      assert path[i] == a && path[i+1] == b;\n    }\n\n    assert isPath(g, path);\n  }\n}\n\nlemma PathOfLengthTwo(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n  requires isPath(g, path)\n  requires |path| == 2\n  ensures path[0] in g.nodes && path[1] in g.nodes\n  ensures hasEdge(g, path[0], path[1])\n{\n  assert 0 <= 0 < |path|;\n  assert path[0] in g.nodes;\n  assert 0 <= 1 < |path|;\n  assert path[1] in g.nodes;\n  assert 0 <= 0 < |path| - 1;\n  assert hasEdge(g, path[0], path[1]);\n}\n\nlemma TreeNoCycle(g: Graph)\n  requires validGraph(g)\n  requires isTree(g)\n  ensures isAcyclic(g)\n{\n  // By definition of isTree\n}\n\nlemma EmptyGraphAcyclic(g: Graph)\n  requires validGraph(g)\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  if hasCycle(g) {\n    var path :| isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1];\n    assert |path| >= 2;\n    assert hasEdge(g, path[0], path[1]);\n    assert (path[0], path[1]) in g.edges;\n    assert false;\n  }\n}\n\nlemma SingleNodeAcyclic(g: Graph)\n  requires validGraph(g)\n  requires |g.nodes| == 1\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  EmptyGraphAcyclic(g);\n}\n\nlemma ValidGraphSubgraph(g: Graph, removed: Node)\n  requires validGraph(g)\n  requires removed in g.nodes\n  ensures validGraph(Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed))\n{\n  var g' := Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed);\n  forall e | e in g'.edges\n    ensures e.0 in g'.nodes && e.1 in g'.nodes\n  {\n    assert e in g.edges;\n    assert e.0 != removed && e.1 != removed;\n    assert e.0 in g.nodes && e.1 in g.nodes;\n    assert e.0 in g'.nodes && e.1 in g'.nodes;\n  }\n}", "output": "assert isPath(g, path);"}, {"id": "example_SelfReachable_1", "type": "assert", "program": "// Graph operations: path, reachable, cycle detection\n\ntype Node = nat\n\ndatatype Graph = Graph(nodes: set<Node>, edges: set<(Node, Node)>)\n\npredicate {:spec} validGraph(g: Graph)\n{\n  forall e :: e in g.edges ==> e.0 in g.nodes && e.1 in g.nodes\n}\n\npredicate {:spec} hasEdge(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n{\n  (from, to) in g.edges\n}\n\nfunction {:spec} neighbors(g: Graph, n: Node): set<Node>\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  set m | m in g.nodes && (n, m) in g.edges\n}\n\npredicate {:spec} isPath(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n{\n  |path| > 0 &&\n  (forall i :: 0 <= i < |path| ==> path[i] in g.nodes) &&\n  (forall i :: 0 <= i < |path| - 1 ==> hasEdge(g, path[i], path[i+1]))\n}\n\nghost predicate {:spec} reachable(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n{\n  exists path :: isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to\n}\n\nghost predicate {:spec} hasCycle(g: Graph)\n  requires validGraph(g)\n{\n  exists path :: isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1]\n}\n\nghost predicate {:spec} isAcyclic(g: Graph)\n  requires validGraph(g)\n{\n  !hasCycle(g)\n}\n\nghost predicate {:spec} isTree(g: Graph)\n  requires validGraph(g)\n{\n  isAcyclic(g) &&\n  |g.edges| == |g.nodes| - 1 &&\n  forall n, m :: n in g.nodes && m in g.nodes && n != m ==> reachable(g, n, m)\n}\n\nfunction {:spec} inDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |set m | m in g.nodes && (m, n) in g.edges|\n}\n\nfunction {:spec} outDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |neighbors(g, n)|\n}\n\nghost predicate {:spec} isConnected(g: Graph)\n  requires validGraph(g)\n{\n  forall n, m :: n in g.nodes && m in g.nodes ==> reachable(g, n, m)\n}\n\n// Simplified version without recursion\nghost function {:spec} graphDistance(g: Graph, from: Node, to: Node): nat\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n  requires reachable(g, from, to)\n{\n  var path :| isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to;\n  |path| - 1\n}\n\nlemma SelfReachable(g: Graph, n: Node)\n  requires validGraph(g)\n  requires n in g.nodes\n  ensures reachable(g, n, n)\n{\n  var path := [n];\n  assert |path| == 1;\n  assert |path| >= 1;\n  assert path[0] == n;\n  assert path[|path| - 1] == n;\n\n  // Show isPath\n  forall i | 0 <= i < |path|\n    ensures path[i] in g.nodes\n  {\n    assert path[i] == n;\n  }\n\n  forall i | 0 <= i < |path| - 1\n    ensures hasEdge(g, path[i], path[i+1])\n  {\n    \n/*[CODE HERE]*/\n// No such i exists since |path| == 1\n  }\n\n  assert isPath(g, path);\n}\n\nlemma DirectEdgeReachable(g: Graph, a: Node, b: Node)\n  requires validGraph(g)\n  requires a in g.nodes && b in g.nodes\n  requires hasEdge(g, a, b)\n  ensures reachable(g, a, b)\n{\n  assert b in neighbors(g, a);\n  if a == b {\n    SelfReachable(g, a);\n  } else {\n    var path := [a, b];\n    assert |path| == 2;\n    assert |path| >= 1;\n    assert path[0] == a;\n    assert path[|path| - 1] == b;\n\n    // Show isPath\n    forall i | 0 <= i < |path|\n      ensures path[i] in g.nodes\n    {\n      if i == 0 { assert path[i] == a; }\n      else { assert path[i] == b; }\n    }\n\n    forall i | 0 <= i < |path| - 1\n      ensures hasEdge(g, path[i], path[i+1])\n    {\n      assert i == 0;\n      assert path[i] == a && path[i+1] == b;\n    }\n\n    assert isPath(g, path);\n  }\n}\n\nlemma PathOfLengthTwo(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n  requires isPath(g, path)\n  requires |path| == 2\n  ensures path[0] in g.nodes && path[1] in g.nodes\n  ensures hasEdge(g, path[0], path[1])\n{\n  assert 0 <= 0 < |path|;\n  assert path[0] in g.nodes;\n  assert 0 <= 1 < |path|;\n  assert path[1] in g.nodes;\n  assert 0 <= 0 < |path| - 1;\n  assert hasEdge(g, path[0], path[1]);\n}\n\nlemma TreeNoCycle(g: Graph)\n  requires validGraph(g)\n  requires isTree(g)\n  ensures isAcyclic(g)\n{\n  // By definition of isTree\n}\n\nlemma EmptyGraphAcyclic(g: Graph)\n  requires validGraph(g)\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  if hasCycle(g) {\n    var path :| isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1];\n    assert |path| >= 2;\n    assert hasEdge(g, path[0], path[1]);\n    assert (path[0], path[1]) in g.edges;\n    assert false;\n  }\n}\n\nlemma SingleNodeAcyclic(g: Graph)\n  requires validGraph(g)\n  requires |g.nodes| == 1\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  EmptyGraphAcyclic(g);\n}\n\nlemma ValidGraphSubgraph(g: Graph, removed: Node)\n  requires validGraph(g)\n  requires removed in g.nodes\n  ensures validGraph(Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed))\n{\n  var g' := Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed);\n  forall e | e in g'.edges\n    ensures e.0 in g'.nodes && e.1 in g'.nodes\n  {\n    assert e in g.edges;\n    assert e.0 != removed && e.1 != removed;\n    assert e.0 in g.nodes && e.1 in g.nodes;\n    assert e.0 in g'.nodes && e.1 in g'.nodes;\n  }\n}", "output": "assert false;"}, {"id": "example_SelfReachable_2", "type": "assert", "program": "// Graph operations: path, reachable, cycle detection\n\ntype Node = nat\n\ndatatype Graph = Graph(nodes: set<Node>, edges: set<(Node, Node)>)\n\npredicate {:spec} validGraph(g: Graph)\n{\n  forall e :: e in g.edges ==> e.0 in g.nodes && e.1 in g.nodes\n}\n\npredicate {:spec} hasEdge(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n{\n  (from, to) in g.edges\n}\n\nfunction {:spec} neighbors(g: Graph, n: Node): set<Node>\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  set m | m in g.nodes && (n, m) in g.edges\n}\n\npredicate {:spec} isPath(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n{\n  |path| > 0 &&\n  (forall i :: 0 <= i < |path| ==> path[i] in g.nodes) &&\n  (forall i :: 0 <= i < |path| - 1 ==> hasEdge(g, path[i], path[i+1]))\n}\n\nghost predicate {:spec} reachable(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n{\n  exists path :: isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to\n}\n\nghost predicate {:spec} hasCycle(g: Graph)\n  requires validGraph(g)\n{\n  exists path :: isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1]\n}\n\nghost predicate {:spec} isAcyclic(g: Graph)\n  requires validGraph(g)\n{\n  !hasCycle(g)\n}\n\nghost predicate {:spec} isTree(g: Graph)\n  requires validGraph(g)\n{\n  isAcyclic(g) &&\n  |g.edges| == |g.nodes| - 1 &&\n  forall n, m :: n in g.nodes && m in g.nodes && n != m ==> reachable(g, n, m)\n}\n\nfunction {:spec} inDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |set m | m in g.nodes && (m, n) in g.edges|\n}\n\nfunction {:spec} outDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |neighbors(g, n)|\n}\n\nghost predicate {:spec} isConnected(g: Graph)\n  requires validGraph(g)\n{\n  forall n, m :: n in g.nodes && m in g.nodes ==> reachable(g, n, m)\n}\n\n// Simplified version without recursion\nghost function {:spec} graphDistance(g: Graph, from: Node, to: Node): nat\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n  requires reachable(g, from, to)\n{\n  var path :| isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to;\n  |path| - 1\n}\n\nlemma SelfReachable(g: Graph, n: Node)\n  requires validGraph(g)\n  requires n in g.nodes\n  ensures reachable(g, n, n)\n{\n  var path := [n];\n  assert |path| == 1;\n  assert |path| >= 1;\n  assert path[0] == n;\n  assert path[|path| - 1] == n;\n\n  // Show isPath\n  forall i | 0 <= i < |path|\n    ensures path[i] in g.nodes\n  {\n    \n/*[CODE HERE]*/\n  }\n\n  forall i | 0 <= i < |path| - 1\n    ensures hasEdge(g, path[i], path[i+1])\n  {\n    assert false;  // No such i exists since |path| == 1\n  }\n\n  assert isPath(g, path);\n}\n\nlemma DirectEdgeReachable(g: Graph, a: Node, b: Node)\n  requires validGraph(g)\n  requires a in g.nodes && b in g.nodes\n  requires hasEdge(g, a, b)\n  ensures reachable(g, a, b)\n{\n  assert b in neighbors(g, a);\n  if a == b {\n    SelfReachable(g, a);\n  } else {\n    var path := [a, b];\n    assert |path| == 2;\n    assert |path| >= 1;\n    assert path[0] == a;\n    assert path[|path| - 1] == b;\n\n    // Show isPath\n    forall i | 0 <= i < |path|\n      ensures path[i] in g.nodes\n    {\n      if i == 0 { assert path[i] == a; }\n      else { assert path[i] == b; }\n    }\n\n    forall i | 0 <= i < |path| - 1\n      ensures hasEdge(g, path[i], path[i+1])\n    {\n      assert i == 0;\n      assert path[i] == a && path[i+1] == b;\n    }\n\n    assert isPath(g, path);\n  }\n}\n\nlemma PathOfLengthTwo(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n  requires isPath(g, path)\n  requires |path| == 2\n  ensures path[0] in g.nodes && path[1] in g.nodes\n  ensures hasEdge(g, path[0], path[1])\n{\n  assert 0 <= 0 < |path|;\n  assert path[0] in g.nodes;\n  assert 0 <= 1 < |path|;\n  assert path[1] in g.nodes;\n  assert 0 <= 0 < |path| - 1;\n  assert hasEdge(g, path[0], path[1]);\n}\n\nlemma TreeNoCycle(g: Graph)\n  requires validGraph(g)\n  requires isTree(g)\n  ensures isAcyclic(g)\n{\n  // By definition of isTree\n}\n\nlemma EmptyGraphAcyclic(g: Graph)\n  requires validGraph(g)\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  if hasCycle(g) {\n    var path :| isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1];\n    assert |path| >= 2;\n    assert hasEdge(g, path[0], path[1]);\n    assert (path[0], path[1]) in g.edges;\n    assert false;\n  }\n}\n\nlemma SingleNodeAcyclic(g: Graph)\n  requires validGraph(g)\n  requires |g.nodes| == 1\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  EmptyGraphAcyclic(g);\n}\n\nlemma ValidGraphSubgraph(g: Graph, removed: Node)\n  requires validGraph(g)\n  requires removed in g.nodes\n  ensures validGraph(Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed))\n{\n  var g' := Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed);\n  forall e | e in g'.edges\n    ensures e.0 in g'.nodes && e.1 in g'.nodes\n  {\n    assert e in g.edges;\n    assert e.0 != removed && e.1 != removed;\n    assert e.0 in g.nodes && e.1 in g.nodes;\n    assert e.0 in g'.nodes && e.1 in g'.nodes;\n  }\n}", "output": "assert path[i] == n;"}, {"id": "example_SelfReachable_3", "type": "assert", "program": "// Graph operations: path, reachable, cycle detection\n\ntype Node = nat\n\ndatatype Graph = Graph(nodes: set<Node>, edges: set<(Node, Node)>)\n\npredicate {:spec} validGraph(g: Graph)\n{\n  forall e :: e in g.edges ==> e.0 in g.nodes && e.1 in g.nodes\n}\n\npredicate {:spec} hasEdge(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n{\n  (from, to) in g.edges\n}\n\nfunction {:spec} neighbors(g: Graph, n: Node): set<Node>\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  set m | m in g.nodes && (n, m) in g.edges\n}\n\npredicate {:spec} isPath(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n{\n  |path| > 0 &&\n  (forall i :: 0 <= i < |path| ==> path[i] in g.nodes) &&\n  (forall i :: 0 <= i < |path| - 1 ==> hasEdge(g, path[i], path[i+1]))\n}\n\nghost predicate {:spec} reachable(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n{\n  exists path :: isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to\n}\n\nghost predicate {:spec} hasCycle(g: Graph)\n  requires validGraph(g)\n{\n  exists path :: isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1]\n}\n\nghost predicate {:spec} isAcyclic(g: Graph)\n  requires validGraph(g)\n{\n  !hasCycle(g)\n}\n\nghost predicate {:spec} isTree(g: Graph)\n  requires validGraph(g)\n{\n  isAcyclic(g) &&\n  |g.edges| == |g.nodes| - 1 &&\n  forall n, m :: n in g.nodes && m in g.nodes && n != m ==> reachable(g, n, m)\n}\n\nfunction {:spec} inDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |set m | m in g.nodes && (m, n) in g.edges|\n}\n\nfunction {:spec} outDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |neighbors(g, n)|\n}\n\nghost predicate {:spec} isConnected(g: Graph)\n  requires validGraph(g)\n{\n  forall n, m :: n in g.nodes && m in g.nodes ==> reachable(g, n, m)\n}\n\n// Simplified version without recursion\nghost function {:spec} graphDistance(g: Graph, from: Node, to: Node): nat\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n  requires reachable(g, from, to)\n{\n  var path :| isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to;\n  |path| - 1\n}\n\nlemma SelfReachable(g: Graph, n: Node)\n  requires validGraph(g)\n  requires n in g.nodes\n  ensures reachable(g, n, n)\n{\n  var path := [n];\n  assert |path| == 1;\n  assert |path| >= 1;\n  assert path[0] == n;\n  \n/*[CODE HERE]*/\n\n  // Show isPath\n  forall i | 0 <= i < |path|\n    ensures path[i] in g.nodes\n  {\n    assert path[i] == n;\n  }\n\n  forall i | 0 <= i < |path| - 1\n    ensures hasEdge(g, path[i], path[i+1])\n  {\n    assert false;  // No such i exists since |path| == 1\n  }\n\n  assert isPath(g, path);\n}\n\nlemma DirectEdgeReachable(g: Graph, a: Node, b: Node)\n  requires validGraph(g)\n  requires a in g.nodes && b in g.nodes\n  requires hasEdge(g, a, b)\n  ensures reachable(g, a, b)\n{\n  assert b in neighbors(g, a);\n  if a == b {\n    SelfReachable(g, a);\n  } else {\n    var path := [a, b];\n    assert |path| == 2;\n    assert |path| >= 1;\n    assert path[0] == a;\n    assert path[|path| - 1] == b;\n\n    // Show isPath\n    forall i | 0 <= i < |path|\n      ensures path[i] in g.nodes\n    {\n      if i == 0 { assert path[i] == a; }\n      else { assert path[i] == b; }\n    }\n\n    forall i | 0 <= i < |path| - 1\n      ensures hasEdge(g, path[i], path[i+1])\n    {\n      assert i == 0;\n      assert path[i] == a && path[i+1] == b;\n    }\n\n    assert isPath(g, path);\n  }\n}\n\nlemma PathOfLengthTwo(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n  requires isPath(g, path)\n  requires |path| == 2\n  ensures path[0] in g.nodes && path[1] in g.nodes\n  ensures hasEdge(g, path[0], path[1])\n{\n  assert 0 <= 0 < |path|;\n  assert path[0] in g.nodes;\n  assert 0 <= 1 < |path|;\n  assert path[1] in g.nodes;\n  assert 0 <= 0 < |path| - 1;\n  assert hasEdge(g, path[0], path[1]);\n}\n\nlemma TreeNoCycle(g: Graph)\n  requires validGraph(g)\n  requires isTree(g)\n  ensures isAcyclic(g)\n{\n  // By definition of isTree\n}\n\nlemma EmptyGraphAcyclic(g: Graph)\n  requires validGraph(g)\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  if hasCycle(g) {\n    var path :| isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1];\n    assert |path| >= 2;\n    assert hasEdge(g, path[0], path[1]);\n    assert (path[0], path[1]) in g.edges;\n    assert false;\n  }\n}\n\nlemma SingleNodeAcyclic(g: Graph)\n  requires validGraph(g)\n  requires |g.nodes| == 1\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  EmptyGraphAcyclic(g);\n}\n\nlemma ValidGraphSubgraph(g: Graph, removed: Node)\n  requires validGraph(g)\n  requires removed in g.nodes\n  ensures validGraph(Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed))\n{\n  var g' := Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed);\n  forall e | e in g'.edges\n    ensures e.0 in g'.nodes && e.1 in g'.nodes\n  {\n    assert e in g.edges;\n    assert e.0 != removed && e.1 != removed;\n    assert e.0 in g.nodes && e.1 in g.nodes;\n    assert e.0 in g'.nodes && e.1 in g'.nodes;\n  }\n}", "output": "assert path[|path| - 1] == n;"}, {"id": "example_SelfReachable_4", "type": "assert", "program": "// Graph operations: path, reachable, cycle detection\n\ntype Node = nat\n\ndatatype Graph = Graph(nodes: set<Node>, edges: set<(Node, Node)>)\n\npredicate {:spec} validGraph(g: Graph)\n{\n  forall e :: e in g.edges ==> e.0 in g.nodes && e.1 in g.nodes\n}\n\npredicate {:spec} hasEdge(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n{\n  (from, to) in g.edges\n}\n\nfunction {:spec} neighbors(g: Graph, n: Node): set<Node>\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  set m | m in g.nodes && (n, m) in g.edges\n}\n\npredicate {:spec} isPath(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n{\n  |path| > 0 &&\n  (forall i :: 0 <= i < |path| ==> path[i] in g.nodes) &&\n  (forall i :: 0 <= i < |path| - 1 ==> hasEdge(g, path[i], path[i+1]))\n}\n\nghost predicate {:spec} reachable(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n{\n  exists path :: isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to\n}\n\nghost predicate {:spec} hasCycle(g: Graph)\n  requires validGraph(g)\n{\n  exists path :: isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1]\n}\n\nghost predicate {:spec} isAcyclic(g: Graph)\n  requires validGraph(g)\n{\n  !hasCycle(g)\n}\n\nghost predicate {:spec} isTree(g: Graph)\n  requires validGraph(g)\n{\n  isAcyclic(g) &&\n  |g.edges| == |g.nodes| - 1 &&\n  forall n, m :: n in g.nodes && m in g.nodes && n != m ==> reachable(g, n, m)\n}\n\nfunction {:spec} inDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |set m | m in g.nodes && (m, n) in g.edges|\n}\n\nfunction {:spec} outDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |neighbors(g, n)|\n}\n\nghost predicate {:spec} isConnected(g: Graph)\n  requires validGraph(g)\n{\n  forall n, m :: n in g.nodes && m in g.nodes ==> reachable(g, n, m)\n}\n\n// Simplified version without recursion\nghost function {:spec} graphDistance(g: Graph, from: Node, to: Node): nat\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n  requires reachable(g, from, to)\n{\n  var path :| isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to;\n  |path| - 1\n}\n\nlemma SelfReachable(g: Graph, n: Node)\n  requires validGraph(g)\n  requires n in g.nodes\n  ensures reachable(g, n, n)\n{\n  var path := [n];\n  assert |path| == 1;\n  assert |path| >= 1;\n  \n/*[CODE HERE]*/\n  assert path[|path| - 1] == n;\n\n  // Show isPath\n  forall i | 0 <= i < |path|\n    ensures path[i] in g.nodes\n  {\n    assert path[i] == n;\n  }\n\n  forall i | 0 <= i < |path| - 1\n    ensures hasEdge(g, path[i], path[i+1])\n  {\n    assert false;  // No such i exists since |path| == 1\n  }\n\n  assert isPath(g, path);\n}\n\nlemma DirectEdgeReachable(g: Graph, a: Node, b: Node)\n  requires validGraph(g)\n  requires a in g.nodes && b in g.nodes\n  requires hasEdge(g, a, b)\n  ensures reachable(g, a, b)\n{\n  assert b in neighbors(g, a);\n  if a == b {\n    SelfReachable(g, a);\n  } else {\n    var path := [a, b];\n    assert |path| == 2;\n    assert |path| >= 1;\n    assert path[0] == a;\n    assert path[|path| - 1] == b;\n\n    // Show isPath\n    forall i | 0 <= i < |path|\n      ensures path[i] in g.nodes\n    {\n      if i == 0 { assert path[i] == a; }\n      else { assert path[i] == b; }\n    }\n\n    forall i | 0 <= i < |path| - 1\n      ensures hasEdge(g, path[i], path[i+1])\n    {\n      assert i == 0;\n      assert path[i] == a && path[i+1] == b;\n    }\n\n    assert isPath(g, path);\n  }\n}\n\nlemma PathOfLengthTwo(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n  requires isPath(g, path)\n  requires |path| == 2\n  ensures path[0] in g.nodes && path[1] in g.nodes\n  ensures hasEdge(g, path[0], path[1])\n{\n  assert 0 <= 0 < |path|;\n  assert path[0] in g.nodes;\n  assert 0 <= 1 < |path|;\n  assert path[1] in g.nodes;\n  assert 0 <= 0 < |path| - 1;\n  assert hasEdge(g, path[0], path[1]);\n}\n\nlemma TreeNoCycle(g: Graph)\n  requires validGraph(g)\n  requires isTree(g)\n  ensures isAcyclic(g)\n{\n  // By definition of isTree\n}\n\nlemma EmptyGraphAcyclic(g: Graph)\n  requires validGraph(g)\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  if hasCycle(g) {\n    var path :| isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1];\n    assert |path| >= 2;\n    assert hasEdge(g, path[0], path[1]);\n    assert (path[0], path[1]) in g.edges;\n    assert false;\n  }\n}\n\nlemma SingleNodeAcyclic(g: Graph)\n  requires validGraph(g)\n  requires |g.nodes| == 1\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  EmptyGraphAcyclic(g);\n}\n\nlemma ValidGraphSubgraph(g: Graph, removed: Node)\n  requires validGraph(g)\n  requires removed in g.nodes\n  ensures validGraph(Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed))\n{\n  var g' := Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed);\n  forall e | e in g'.edges\n    ensures e.0 in g'.nodes && e.1 in g'.nodes\n  {\n    assert e in g.edges;\n    assert e.0 != removed && e.1 != removed;\n    assert e.0 in g.nodes && e.1 in g.nodes;\n    assert e.0 in g'.nodes && e.1 in g'.nodes;\n  }\n}", "output": "assert path[0] == n;"}, {"id": "example_SelfReachable_5", "type": "assert", "program": "// Graph operations: path, reachable, cycle detection\n\ntype Node = nat\n\ndatatype Graph = Graph(nodes: set<Node>, edges: set<(Node, Node)>)\n\npredicate {:spec} validGraph(g: Graph)\n{\n  forall e :: e in g.edges ==> e.0 in g.nodes && e.1 in g.nodes\n}\n\npredicate {:spec} hasEdge(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n{\n  (from, to) in g.edges\n}\n\nfunction {:spec} neighbors(g: Graph, n: Node): set<Node>\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  set m | m in g.nodes && (n, m) in g.edges\n}\n\npredicate {:spec} isPath(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n{\n  |path| > 0 &&\n  (forall i :: 0 <= i < |path| ==> path[i] in g.nodes) &&\n  (forall i :: 0 <= i < |path| - 1 ==> hasEdge(g, path[i], path[i+1]))\n}\n\nghost predicate {:spec} reachable(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n{\n  exists path :: isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to\n}\n\nghost predicate {:spec} hasCycle(g: Graph)\n  requires validGraph(g)\n{\n  exists path :: isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1]\n}\n\nghost predicate {:spec} isAcyclic(g: Graph)\n  requires validGraph(g)\n{\n  !hasCycle(g)\n}\n\nghost predicate {:spec} isTree(g: Graph)\n  requires validGraph(g)\n{\n  isAcyclic(g) &&\n  |g.edges| == |g.nodes| - 1 &&\n  forall n, m :: n in g.nodes && m in g.nodes && n != m ==> reachable(g, n, m)\n}\n\nfunction {:spec} inDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |set m | m in g.nodes && (m, n) in g.edges|\n}\n\nfunction {:spec} outDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |neighbors(g, n)|\n}\n\nghost predicate {:spec} isConnected(g: Graph)\n  requires validGraph(g)\n{\n  forall n, m :: n in g.nodes && m in g.nodes ==> reachable(g, n, m)\n}\n\n// Simplified version without recursion\nghost function {:spec} graphDistance(g: Graph, from: Node, to: Node): nat\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n  requires reachable(g, from, to)\n{\n  var path :| isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to;\n  |path| - 1\n}\n\nlemma SelfReachable(g: Graph, n: Node)\n  requires validGraph(g)\n  requires n in g.nodes\n  ensures reachable(g, n, n)\n{\n  var path := [n];\n  assert |path| == 1;\n  \n/*[CODE HERE]*/\n  assert path[0] == n;\n  assert path[|path| - 1] == n;\n\n  // Show isPath\n  forall i | 0 <= i < |path|\n    ensures path[i] in g.nodes\n  {\n    assert path[i] == n;\n  }\n\n  forall i | 0 <= i < |path| - 1\n    ensures hasEdge(g, path[i], path[i+1])\n  {\n    assert false;  // No such i exists since |path| == 1\n  }\n\n  assert isPath(g, path);\n}\n\nlemma DirectEdgeReachable(g: Graph, a: Node, b: Node)\n  requires validGraph(g)\n  requires a in g.nodes && b in g.nodes\n  requires hasEdge(g, a, b)\n  ensures reachable(g, a, b)\n{\n  assert b in neighbors(g, a);\n  if a == b {\n    SelfReachable(g, a);\n  } else {\n    var path := [a, b];\n    assert |path| == 2;\n    assert |path| >= 1;\n    assert path[0] == a;\n    assert path[|path| - 1] == b;\n\n    // Show isPath\n    forall i | 0 <= i < |path|\n      ensures path[i] in g.nodes\n    {\n      if i == 0 { assert path[i] == a; }\n      else { assert path[i] == b; }\n    }\n\n    forall i | 0 <= i < |path| - 1\n      ensures hasEdge(g, path[i], path[i+1])\n    {\n      assert i == 0;\n      assert path[i] == a && path[i+1] == b;\n    }\n\n    assert isPath(g, path);\n  }\n}\n\nlemma PathOfLengthTwo(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n  requires isPath(g, path)\n  requires |path| == 2\n  ensures path[0] in g.nodes && path[1] in g.nodes\n  ensures hasEdge(g, path[0], path[1])\n{\n  assert 0 <= 0 < |path|;\n  assert path[0] in g.nodes;\n  assert 0 <= 1 < |path|;\n  assert path[1] in g.nodes;\n  assert 0 <= 0 < |path| - 1;\n  assert hasEdge(g, path[0], path[1]);\n}\n\nlemma TreeNoCycle(g: Graph)\n  requires validGraph(g)\n  requires isTree(g)\n  ensures isAcyclic(g)\n{\n  // By definition of isTree\n}\n\nlemma EmptyGraphAcyclic(g: Graph)\n  requires validGraph(g)\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  if hasCycle(g) {\n    var path :| isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1];\n    assert |path| >= 2;\n    assert hasEdge(g, path[0], path[1]);\n    assert (path[0], path[1]) in g.edges;\n    assert false;\n  }\n}\n\nlemma SingleNodeAcyclic(g: Graph)\n  requires validGraph(g)\n  requires |g.nodes| == 1\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  EmptyGraphAcyclic(g);\n}\n\nlemma ValidGraphSubgraph(g: Graph, removed: Node)\n  requires validGraph(g)\n  requires removed in g.nodes\n  ensures validGraph(Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed))\n{\n  var g' := Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed);\n  forall e | e in g'.edges\n    ensures e.0 in g'.nodes && e.1 in g'.nodes\n  {\n    assert e in g.edges;\n    assert e.0 != removed && e.1 != removed;\n    assert e.0 in g.nodes && e.1 in g.nodes;\n    assert e.0 in g'.nodes && e.1 in g'.nodes;\n  }\n}", "output": "assert |path| >= 1;"}, {"id": "example_SelfReachable_6", "type": "assert", "program": "// Graph operations: path, reachable, cycle detection\n\ntype Node = nat\n\ndatatype Graph = Graph(nodes: set<Node>, edges: set<(Node, Node)>)\n\npredicate {:spec} validGraph(g: Graph)\n{\n  forall e :: e in g.edges ==> e.0 in g.nodes && e.1 in g.nodes\n}\n\npredicate {:spec} hasEdge(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n{\n  (from, to) in g.edges\n}\n\nfunction {:spec} neighbors(g: Graph, n: Node): set<Node>\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  set m | m in g.nodes && (n, m) in g.edges\n}\n\npredicate {:spec} isPath(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n{\n  |path| > 0 &&\n  (forall i :: 0 <= i < |path| ==> path[i] in g.nodes) &&\n  (forall i :: 0 <= i < |path| - 1 ==> hasEdge(g, path[i], path[i+1]))\n}\n\nghost predicate {:spec} reachable(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n{\n  exists path :: isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to\n}\n\nghost predicate {:spec} hasCycle(g: Graph)\n  requires validGraph(g)\n{\n  exists path :: isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1]\n}\n\nghost predicate {:spec} isAcyclic(g: Graph)\n  requires validGraph(g)\n{\n  !hasCycle(g)\n}\n\nghost predicate {:spec} isTree(g: Graph)\n  requires validGraph(g)\n{\n  isAcyclic(g) &&\n  |g.edges| == |g.nodes| - 1 &&\n  forall n, m :: n in g.nodes && m in g.nodes && n != m ==> reachable(g, n, m)\n}\n\nfunction {:spec} inDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |set m | m in g.nodes && (m, n) in g.edges|\n}\n\nfunction {:spec} outDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |neighbors(g, n)|\n}\n\nghost predicate {:spec} isConnected(g: Graph)\n  requires validGraph(g)\n{\n  forall n, m :: n in g.nodes && m in g.nodes ==> reachable(g, n, m)\n}\n\n// Simplified version without recursion\nghost function {:spec} graphDistance(g: Graph, from: Node, to: Node): nat\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n  requires reachable(g, from, to)\n{\n  var path :| isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to;\n  |path| - 1\n}\n\nlemma SelfReachable(g: Graph, n: Node)\n  requires validGraph(g)\n  requires n in g.nodes\n  ensures reachable(g, n, n)\n{\n  var path := [n];\n  \n/*[CODE HERE]*/\n  assert |path| >= 1;\n  assert path[0] == n;\n  assert path[|path| - 1] == n;\n\n  // Show isPath\n  forall i | 0 <= i < |path|\n    ensures path[i] in g.nodes\n  {\n    assert path[i] == n;\n  }\n\n  forall i | 0 <= i < |path| - 1\n    ensures hasEdge(g, path[i], path[i+1])\n  {\n    assert false;  // No such i exists since |path| == 1\n  }\n\n  assert isPath(g, path);\n}\n\nlemma DirectEdgeReachable(g: Graph, a: Node, b: Node)\n  requires validGraph(g)\n  requires a in g.nodes && b in g.nodes\n  requires hasEdge(g, a, b)\n  ensures reachable(g, a, b)\n{\n  assert b in neighbors(g, a);\n  if a == b {\n    SelfReachable(g, a);\n  } else {\n    var path := [a, b];\n    assert |path| == 2;\n    assert |path| >= 1;\n    assert path[0] == a;\n    assert path[|path| - 1] == b;\n\n    // Show isPath\n    forall i | 0 <= i < |path|\n      ensures path[i] in g.nodes\n    {\n      if i == 0 { assert path[i] == a; }\n      else { assert path[i] == b; }\n    }\n\n    forall i | 0 <= i < |path| - 1\n      ensures hasEdge(g, path[i], path[i+1])\n    {\n      assert i == 0;\n      assert path[i] == a && path[i+1] == b;\n    }\n\n    assert isPath(g, path);\n  }\n}\n\nlemma PathOfLengthTwo(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n  requires isPath(g, path)\n  requires |path| == 2\n  ensures path[0] in g.nodes && path[1] in g.nodes\n  ensures hasEdge(g, path[0], path[1])\n{\n  assert 0 <= 0 < |path|;\n  assert path[0] in g.nodes;\n  assert 0 <= 1 < |path|;\n  assert path[1] in g.nodes;\n  assert 0 <= 0 < |path| - 1;\n  assert hasEdge(g, path[0], path[1]);\n}\n\nlemma TreeNoCycle(g: Graph)\n  requires validGraph(g)\n  requires isTree(g)\n  ensures isAcyclic(g)\n{\n  // By definition of isTree\n}\n\nlemma EmptyGraphAcyclic(g: Graph)\n  requires validGraph(g)\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  if hasCycle(g) {\n    var path :| isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1];\n    assert |path| >= 2;\n    assert hasEdge(g, path[0], path[1]);\n    assert (path[0], path[1]) in g.edges;\n    assert false;\n  }\n}\n\nlemma SingleNodeAcyclic(g: Graph)\n  requires validGraph(g)\n  requires |g.nodes| == 1\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  EmptyGraphAcyclic(g);\n}\n\nlemma ValidGraphSubgraph(g: Graph, removed: Node)\n  requires validGraph(g)\n  requires removed in g.nodes\n  ensures validGraph(Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed))\n{\n  var g' := Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed);\n  forall e | e in g'.edges\n    ensures e.0 in g'.nodes && e.1 in g'.nodes\n  {\n    assert e in g.edges;\n    assert e.0 != removed && e.1 != removed;\n    assert e.0 in g.nodes && e.1 in g.nodes;\n    assert e.0 in g'.nodes && e.1 in g'.nodes;\n  }\n}", "output": "assert |path| == 1;"}, {"id": "example_DirectEdgeReachable_0", "type": "assert", "program": "// Graph operations: path, reachable, cycle detection\n\ntype Node = nat\n\ndatatype Graph = Graph(nodes: set<Node>, edges: set<(Node, Node)>)\n\npredicate {:spec} validGraph(g: Graph)\n{\n  forall e :: e in g.edges ==> e.0 in g.nodes && e.1 in g.nodes\n}\n\npredicate {:spec} hasEdge(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n{\n  (from, to) in g.edges\n}\n\nfunction {:spec} neighbors(g: Graph, n: Node): set<Node>\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  set m | m in g.nodes && (n, m) in g.edges\n}\n\npredicate {:spec} isPath(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n{\n  |path| > 0 &&\n  (forall i :: 0 <= i < |path| ==> path[i] in g.nodes) &&\n  (forall i :: 0 <= i < |path| - 1 ==> hasEdge(g, path[i], path[i+1]))\n}\n\nghost predicate {:spec} reachable(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n{\n  exists path :: isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to\n}\n\nghost predicate {:spec} hasCycle(g: Graph)\n  requires validGraph(g)\n{\n  exists path :: isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1]\n}\n\nghost predicate {:spec} isAcyclic(g: Graph)\n  requires validGraph(g)\n{\n  !hasCycle(g)\n}\n\nghost predicate {:spec} isTree(g: Graph)\n  requires validGraph(g)\n{\n  isAcyclic(g) &&\n  |g.edges| == |g.nodes| - 1 &&\n  forall n, m :: n in g.nodes && m in g.nodes && n != m ==> reachable(g, n, m)\n}\n\nfunction {:spec} inDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |set m | m in g.nodes && (m, n) in g.edges|\n}\n\nfunction {:spec} outDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |neighbors(g, n)|\n}\n\nghost predicate {:spec} isConnected(g: Graph)\n  requires validGraph(g)\n{\n  forall n, m :: n in g.nodes && m in g.nodes ==> reachable(g, n, m)\n}\n\n// Simplified version without recursion\nghost function {:spec} graphDistance(g: Graph, from: Node, to: Node): nat\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n  requires reachable(g, from, to)\n{\n  var path :| isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to;\n  |path| - 1\n}\n\nlemma SelfReachable(g: Graph, n: Node)\n  requires validGraph(g)\n  requires n in g.nodes\n  ensures reachable(g, n, n)\n{\n  var path := [n];\n  assert |path| == 1;\n  assert |path| >= 1;\n  assert path[0] == n;\n  assert path[|path| - 1] == n;\n\n  // Show isPath\n  forall i | 0 <= i < |path|\n    ensures path[i] in g.nodes\n  {\n    assert path[i] == n;\n  }\n\n  forall i | 0 <= i < |path| - 1\n    ensures hasEdge(g, path[i], path[i+1])\n  {\n    assert false;  // No such i exists since |path| == 1\n  }\n\n  assert isPath(g, path);\n}\n\nlemma DirectEdgeReachable(g: Graph, a: Node, b: Node)\n  requires validGraph(g)\n  requires a in g.nodes && b in g.nodes\n  requires hasEdge(g, a, b)\n  ensures reachable(g, a, b)\n{\n  assert b in neighbors(g, a);\n  if a == b {\n    SelfReachable(g, a);\n  } else {\n    var path := [a, b];\n    assert |path| == 2;\n    assert |path| >= 1;\n    assert path[0] == a;\n    assert path[|path| - 1] == b;\n\n    // Show isPath\n    forall i | 0 <= i < |path|\n      ensures path[i] in g.nodes\n    {\n      if i == 0 { assert path[i] == a; }\n      else { assert path[i] == b; }\n    }\n\n    forall i | 0 <= i < |path| - 1\n      ensures hasEdge(g, path[i], path[i+1])\n    {\n      assert i == 0;\n      assert path[i] == a && path[i+1] == b;\n    }\n\n    \n/*[CODE HERE]*/\n  }\n}\n\nlemma PathOfLengthTwo(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n  requires isPath(g, path)\n  requires |path| == 2\n  ensures path[0] in g.nodes && path[1] in g.nodes\n  ensures hasEdge(g, path[0], path[1])\n{\n  assert 0 <= 0 < |path|;\n  assert path[0] in g.nodes;\n  assert 0 <= 1 < |path|;\n  assert path[1] in g.nodes;\n  assert 0 <= 0 < |path| - 1;\n  assert hasEdge(g, path[0], path[1]);\n}\n\nlemma TreeNoCycle(g: Graph)\n  requires validGraph(g)\n  requires isTree(g)\n  ensures isAcyclic(g)\n{\n  // By definition of isTree\n}\n\nlemma EmptyGraphAcyclic(g: Graph)\n  requires validGraph(g)\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  if hasCycle(g) {\n    var path :| isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1];\n    assert |path| >= 2;\n    assert hasEdge(g, path[0], path[1]);\n    assert (path[0], path[1]) in g.edges;\n    assert false;\n  }\n}\n\nlemma SingleNodeAcyclic(g: Graph)\n  requires validGraph(g)\n  requires |g.nodes| == 1\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  EmptyGraphAcyclic(g);\n}\n\nlemma ValidGraphSubgraph(g: Graph, removed: Node)\n  requires validGraph(g)\n  requires removed in g.nodes\n  ensures validGraph(Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed))\n{\n  var g' := Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed);\n  forall e | e in g'.edges\n    ensures e.0 in g'.nodes && e.1 in g'.nodes\n  {\n    assert e in g.edges;\n    assert e.0 != removed && e.1 != removed;\n    assert e.0 in g.nodes && e.1 in g.nodes;\n    assert e.0 in g'.nodes && e.1 in g'.nodes;\n  }\n}", "output": "assert isPath(g, path);"}, {"id": "example_DirectEdgeReachable_1", "type": "assert", "program": "// Graph operations: path, reachable, cycle detection\n\ntype Node = nat\n\ndatatype Graph = Graph(nodes: set<Node>, edges: set<(Node, Node)>)\n\npredicate {:spec} validGraph(g: Graph)\n{\n  forall e :: e in g.edges ==> e.0 in g.nodes && e.1 in g.nodes\n}\n\npredicate {:spec} hasEdge(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n{\n  (from, to) in g.edges\n}\n\nfunction {:spec} neighbors(g: Graph, n: Node): set<Node>\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  set m | m in g.nodes && (n, m) in g.edges\n}\n\npredicate {:spec} isPath(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n{\n  |path| > 0 &&\n  (forall i :: 0 <= i < |path| ==> path[i] in g.nodes) &&\n  (forall i :: 0 <= i < |path| - 1 ==> hasEdge(g, path[i], path[i+1]))\n}\n\nghost predicate {:spec} reachable(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n{\n  exists path :: isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to\n}\n\nghost predicate {:spec} hasCycle(g: Graph)\n  requires validGraph(g)\n{\n  exists path :: isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1]\n}\n\nghost predicate {:spec} isAcyclic(g: Graph)\n  requires validGraph(g)\n{\n  !hasCycle(g)\n}\n\nghost predicate {:spec} isTree(g: Graph)\n  requires validGraph(g)\n{\n  isAcyclic(g) &&\n  |g.edges| == |g.nodes| - 1 &&\n  forall n, m :: n in g.nodes && m in g.nodes && n != m ==> reachable(g, n, m)\n}\n\nfunction {:spec} inDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |set m | m in g.nodes && (m, n) in g.edges|\n}\n\nfunction {:spec} outDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |neighbors(g, n)|\n}\n\nghost predicate {:spec} isConnected(g: Graph)\n  requires validGraph(g)\n{\n  forall n, m :: n in g.nodes && m in g.nodes ==> reachable(g, n, m)\n}\n\n// Simplified version without recursion\nghost function {:spec} graphDistance(g: Graph, from: Node, to: Node): nat\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n  requires reachable(g, from, to)\n{\n  var path :| isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to;\n  |path| - 1\n}\n\nlemma SelfReachable(g: Graph, n: Node)\n  requires validGraph(g)\n  requires n in g.nodes\n  ensures reachable(g, n, n)\n{\n  var path := [n];\n  assert |path| == 1;\n  assert |path| >= 1;\n  assert path[0] == n;\n  assert path[|path| - 1] == n;\n\n  // Show isPath\n  forall i | 0 <= i < |path|\n    ensures path[i] in g.nodes\n  {\n    assert path[i] == n;\n  }\n\n  forall i | 0 <= i < |path| - 1\n    ensures hasEdge(g, path[i], path[i+1])\n  {\n    assert false;  // No such i exists since |path| == 1\n  }\n\n  assert isPath(g, path);\n}\n\nlemma DirectEdgeReachable(g: Graph, a: Node, b: Node)\n  requires validGraph(g)\n  requires a in g.nodes && b in g.nodes\n  requires hasEdge(g, a, b)\n  ensures reachable(g, a, b)\n{\n  assert b in neighbors(g, a);\n  if a == b {\n    SelfReachable(g, a);\n  } else {\n    var path := [a, b];\n    assert |path| == 2;\n    assert |path| >= 1;\n    assert path[0] == a;\n    assert path[|path| - 1] == b;\n\n    // Show isPath\n    forall i | 0 <= i < |path|\n      ensures path[i] in g.nodes\n    {\n      if i == 0 { assert path[i] == a; }\n      else { assert path[i] == b; }\n    }\n\n    forall i | 0 <= i < |path| - 1\n      ensures hasEdge(g, path[i], path[i+1])\n    {\n      assert i == 0;\n      \n/*[CODE HERE]*/\n    }\n\n    assert isPath(g, path);\n  }\n}\n\nlemma PathOfLengthTwo(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n  requires isPath(g, path)\n  requires |path| == 2\n  ensures path[0] in g.nodes && path[1] in g.nodes\n  ensures hasEdge(g, path[0], path[1])\n{\n  assert 0 <= 0 < |path|;\n  assert path[0] in g.nodes;\n  assert 0 <= 1 < |path|;\n  assert path[1] in g.nodes;\n  assert 0 <= 0 < |path| - 1;\n  assert hasEdge(g, path[0], path[1]);\n}\n\nlemma TreeNoCycle(g: Graph)\n  requires validGraph(g)\n  requires isTree(g)\n  ensures isAcyclic(g)\n{\n  // By definition of isTree\n}\n\nlemma EmptyGraphAcyclic(g: Graph)\n  requires validGraph(g)\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  if hasCycle(g) {\n    var path :| isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1];\n    assert |path| >= 2;\n    assert hasEdge(g, path[0], path[1]);\n    assert (path[0], path[1]) in g.edges;\n    assert false;\n  }\n}\n\nlemma SingleNodeAcyclic(g: Graph)\n  requires validGraph(g)\n  requires |g.nodes| == 1\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  EmptyGraphAcyclic(g);\n}\n\nlemma ValidGraphSubgraph(g: Graph, removed: Node)\n  requires validGraph(g)\n  requires removed in g.nodes\n  ensures validGraph(Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed))\n{\n  var g' := Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed);\n  forall e | e in g'.edges\n    ensures e.0 in g'.nodes && e.1 in g'.nodes\n  {\n    assert e in g.edges;\n    assert e.0 != removed && e.1 != removed;\n    assert e.0 in g.nodes && e.1 in g.nodes;\n    assert e.0 in g'.nodes && e.1 in g'.nodes;\n  }\n}", "output": "assert path[i] == a && path[i+1] == b;"}, {"id": "example_DirectEdgeReachable_2", "type": "assert", "program": "// Graph operations: path, reachable, cycle detection\n\ntype Node = nat\n\ndatatype Graph = Graph(nodes: set<Node>, edges: set<(Node, Node)>)\n\npredicate {:spec} validGraph(g: Graph)\n{\n  forall e :: e in g.edges ==> e.0 in g.nodes && e.1 in g.nodes\n}\n\npredicate {:spec} hasEdge(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n{\n  (from, to) in g.edges\n}\n\nfunction {:spec} neighbors(g: Graph, n: Node): set<Node>\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  set m | m in g.nodes && (n, m) in g.edges\n}\n\npredicate {:spec} isPath(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n{\n  |path| > 0 &&\n  (forall i :: 0 <= i < |path| ==> path[i] in g.nodes) &&\n  (forall i :: 0 <= i < |path| - 1 ==> hasEdge(g, path[i], path[i+1]))\n}\n\nghost predicate {:spec} reachable(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n{\n  exists path :: isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to\n}\n\nghost predicate {:spec} hasCycle(g: Graph)\n  requires validGraph(g)\n{\n  exists path :: isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1]\n}\n\nghost predicate {:spec} isAcyclic(g: Graph)\n  requires validGraph(g)\n{\n  !hasCycle(g)\n}\n\nghost predicate {:spec} isTree(g: Graph)\n  requires validGraph(g)\n{\n  isAcyclic(g) &&\n  |g.edges| == |g.nodes| - 1 &&\n  forall n, m :: n in g.nodes && m in g.nodes && n != m ==> reachable(g, n, m)\n}\n\nfunction {:spec} inDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |set m | m in g.nodes && (m, n) in g.edges|\n}\n\nfunction {:spec} outDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |neighbors(g, n)|\n}\n\nghost predicate {:spec} isConnected(g: Graph)\n  requires validGraph(g)\n{\n  forall n, m :: n in g.nodes && m in g.nodes ==> reachable(g, n, m)\n}\n\n// Simplified version without recursion\nghost function {:spec} graphDistance(g: Graph, from: Node, to: Node): nat\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n  requires reachable(g, from, to)\n{\n  var path :| isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to;\n  |path| - 1\n}\n\nlemma SelfReachable(g: Graph, n: Node)\n  requires validGraph(g)\n  requires n in g.nodes\n  ensures reachable(g, n, n)\n{\n  var path := [n];\n  assert |path| == 1;\n  assert |path| >= 1;\n  assert path[0] == n;\n  assert path[|path| - 1] == n;\n\n  // Show isPath\n  forall i | 0 <= i < |path|\n    ensures path[i] in g.nodes\n  {\n    assert path[i] == n;\n  }\n\n  forall i | 0 <= i < |path| - 1\n    ensures hasEdge(g, path[i], path[i+1])\n  {\n    assert false;  // No such i exists since |path| == 1\n  }\n\n  assert isPath(g, path);\n}\n\nlemma DirectEdgeReachable(g: Graph, a: Node, b: Node)\n  requires validGraph(g)\n  requires a in g.nodes && b in g.nodes\n  requires hasEdge(g, a, b)\n  ensures reachable(g, a, b)\n{\n  assert b in neighbors(g, a);\n  if a == b {\n    SelfReachable(g, a);\n  } else {\n    var path := [a, b];\n    assert |path| == 2;\n    assert |path| >= 1;\n    assert path[0] == a;\n    assert path[|path| - 1] == b;\n\n    // Show isPath\n    forall i | 0 <= i < |path|\n      ensures path[i] in g.nodes\n    {\n      if i == 0 { assert path[i] == a; }\n      else { assert path[i] == b; }\n    }\n\n    forall i | 0 <= i < |path| - 1\n      ensures hasEdge(g, path[i], path[i+1])\n    {\n      \n/*[CODE HERE]*/\n      assert path[i] == a && path[i+1] == b;\n    }\n\n    assert isPath(g, path);\n  }\n}\n\nlemma PathOfLengthTwo(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n  requires isPath(g, path)\n  requires |path| == 2\n  ensures path[0] in g.nodes && path[1] in g.nodes\n  ensures hasEdge(g, path[0], path[1])\n{\n  assert 0 <= 0 < |path|;\n  assert path[0] in g.nodes;\n  assert 0 <= 1 < |path|;\n  assert path[1] in g.nodes;\n  assert 0 <= 0 < |path| - 1;\n  assert hasEdge(g, path[0], path[1]);\n}\n\nlemma TreeNoCycle(g: Graph)\n  requires validGraph(g)\n  requires isTree(g)\n  ensures isAcyclic(g)\n{\n  // By definition of isTree\n}\n\nlemma EmptyGraphAcyclic(g: Graph)\n  requires validGraph(g)\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  if hasCycle(g) {\n    var path :| isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1];\n    assert |path| >= 2;\n    assert hasEdge(g, path[0], path[1]);\n    assert (path[0], path[1]) in g.edges;\n    assert false;\n  }\n}\n\nlemma SingleNodeAcyclic(g: Graph)\n  requires validGraph(g)\n  requires |g.nodes| == 1\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  EmptyGraphAcyclic(g);\n}\n\nlemma ValidGraphSubgraph(g: Graph, removed: Node)\n  requires validGraph(g)\n  requires removed in g.nodes\n  ensures validGraph(Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed))\n{\n  var g' := Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed);\n  forall e | e in g'.edges\n    ensures e.0 in g'.nodes && e.1 in g'.nodes\n  {\n    assert e in g.edges;\n    assert e.0 != removed && e.1 != removed;\n    assert e.0 in g.nodes && e.1 in g.nodes;\n    assert e.0 in g'.nodes && e.1 in g'.nodes;\n  }\n}", "output": "assert i == 0;"}, {"id": "example_DirectEdgeReachable_3", "type": "assert", "program": "// Graph operations: path, reachable, cycle detection\n\ntype Node = nat\n\ndatatype Graph = Graph(nodes: set<Node>, edges: set<(Node, Node)>)\n\npredicate {:spec} validGraph(g: Graph)\n{\n  forall e :: e in g.edges ==> e.0 in g.nodes && e.1 in g.nodes\n}\n\npredicate {:spec} hasEdge(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n{\n  (from, to) in g.edges\n}\n\nfunction {:spec} neighbors(g: Graph, n: Node): set<Node>\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  set m | m in g.nodes && (n, m) in g.edges\n}\n\npredicate {:spec} isPath(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n{\n  |path| > 0 &&\n  (forall i :: 0 <= i < |path| ==> path[i] in g.nodes) &&\n  (forall i :: 0 <= i < |path| - 1 ==> hasEdge(g, path[i], path[i+1]))\n}\n\nghost predicate {:spec} reachable(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n{\n  exists path :: isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to\n}\n\nghost predicate {:spec} hasCycle(g: Graph)\n  requires validGraph(g)\n{\n  exists path :: isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1]\n}\n\nghost predicate {:spec} isAcyclic(g: Graph)\n  requires validGraph(g)\n{\n  !hasCycle(g)\n}\n\nghost predicate {:spec} isTree(g: Graph)\n  requires validGraph(g)\n{\n  isAcyclic(g) &&\n  |g.edges| == |g.nodes| - 1 &&\n  forall n, m :: n in g.nodes && m in g.nodes && n != m ==> reachable(g, n, m)\n}\n\nfunction {:spec} inDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |set m | m in g.nodes && (m, n) in g.edges|\n}\n\nfunction {:spec} outDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |neighbors(g, n)|\n}\n\nghost predicate {:spec} isConnected(g: Graph)\n  requires validGraph(g)\n{\n  forall n, m :: n in g.nodes && m in g.nodes ==> reachable(g, n, m)\n}\n\n// Simplified version without recursion\nghost function {:spec} graphDistance(g: Graph, from: Node, to: Node): nat\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n  requires reachable(g, from, to)\n{\n  var path :| isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to;\n  |path| - 1\n}\n\nlemma SelfReachable(g: Graph, n: Node)\n  requires validGraph(g)\n  requires n in g.nodes\n  ensures reachable(g, n, n)\n{\n  var path := [n];\n  assert |path| == 1;\n  assert |path| >= 1;\n  assert path[0] == n;\n  assert path[|path| - 1] == n;\n\n  // Show isPath\n  forall i | 0 <= i < |path|\n    ensures path[i] in g.nodes\n  {\n    assert path[i] == n;\n  }\n\n  forall i | 0 <= i < |path| - 1\n    ensures hasEdge(g, path[i], path[i+1])\n  {\n    assert false;  // No such i exists since |path| == 1\n  }\n\n  assert isPath(g, path);\n}\n\nlemma DirectEdgeReachable(g: Graph, a: Node, b: Node)\n  requires validGraph(g)\n  requires a in g.nodes && b in g.nodes\n  requires hasEdge(g, a, b)\n  ensures reachable(g, a, b)\n{\n  assert b in neighbors(g, a);\n  if a == b {\n    SelfReachable(g, a);\n  } else {\n    var path := [a, b];\n    assert |path| == 2;\n    assert |path| >= 1;\n    assert path[0] == a;\n    assert path[|path| - 1] == b;\n\n    // Show isPath\n    forall i | 0 <= i < |path|\n      ensures path[i] in g.nodes\n    {\n      if i == 0 { assert path[i] == a; }\n      else { \n/*[CODE HERE]*/\n}\n    }\n\n    forall i | 0 <= i < |path| - 1\n      ensures hasEdge(g, path[i], path[i+1])\n    {\n      assert i == 0;\n      assert path[i] == a && path[i+1] == b;\n    }\n\n    assert isPath(g, path);\n  }\n}\n\nlemma PathOfLengthTwo(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n  requires isPath(g, path)\n  requires |path| == 2\n  ensures path[0] in g.nodes && path[1] in g.nodes\n  ensures hasEdge(g, path[0], path[1])\n{\n  assert 0 <= 0 < |path|;\n  assert path[0] in g.nodes;\n  assert 0 <= 1 < |path|;\n  assert path[1] in g.nodes;\n  assert 0 <= 0 < |path| - 1;\n  assert hasEdge(g, path[0], path[1]);\n}\n\nlemma TreeNoCycle(g: Graph)\n  requires validGraph(g)\n  requires isTree(g)\n  ensures isAcyclic(g)\n{\n  // By definition of isTree\n}\n\nlemma EmptyGraphAcyclic(g: Graph)\n  requires validGraph(g)\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  if hasCycle(g) {\n    var path :| isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1];\n    assert |path| >= 2;\n    assert hasEdge(g, path[0], path[1]);\n    assert (path[0], path[1]) in g.edges;\n    assert false;\n  }\n}\n\nlemma SingleNodeAcyclic(g: Graph)\n  requires validGraph(g)\n  requires |g.nodes| == 1\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  EmptyGraphAcyclic(g);\n}\n\nlemma ValidGraphSubgraph(g: Graph, removed: Node)\n  requires validGraph(g)\n  requires removed in g.nodes\n  ensures validGraph(Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed))\n{\n  var g' := Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed);\n  forall e | e in g'.edges\n    ensures e.0 in g'.nodes && e.1 in g'.nodes\n  {\n    assert e in g.edges;\n    assert e.0 != removed && e.1 != removed;\n    assert e.0 in g.nodes && e.1 in g.nodes;\n    assert e.0 in g'.nodes && e.1 in g'.nodes;\n  }\n}", "output": "assert path[i] == b;"}, {"id": "example_DirectEdgeReachable_4", "type": "assert", "program": "// Graph operations: path, reachable, cycle detection\n\ntype Node = nat\n\ndatatype Graph = Graph(nodes: set<Node>, edges: set<(Node, Node)>)\n\npredicate {:spec} validGraph(g: Graph)\n{\n  forall e :: e in g.edges ==> e.0 in g.nodes && e.1 in g.nodes\n}\n\npredicate {:spec} hasEdge(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n{\n  (from, to) in g.edges\n}\n\nfunction {:spec} neighbors(g: Graph, n: Node): set<Node>\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  set m | m in g.nodes && (n, m) in g.edges\n}\n\npredicate {:spec} isPath(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n{\n  |path| > 0 &&\n  (forall i :: 0 <= i < |path| ==> path[i] in g.nodes) &&\n  (forall i :: 0 <= i < |path| - 1 ==> hasEdge(g, path[i], path[i+1]))\n}\n\nghost predicate {:spec} reachable(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n{\n  exists path :: isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to\n}\n\nghost predicate {:spec} hasCycle(g: Graph)\n  requires validGraph(g)\n{\n  exists path :: isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1]\n}\n\nghost predicate {:spec} isAcyclic(g: Graph)\n  requires validGraph(g)\n{\n  !hasCycle(g)\n}\n\nghost predicate {:spec} isTree(g: Graph)\n  requires validGraph(g)\n{\n  isAcyclic(g) &&\n  |g.edges| == |g.nodes| - 1 &&\n  forall n, m :: n in g.nodes && m in g.nodes && n != m ==> reachable(g, n, m)\n}\n\nfunction {:spec} inDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |set m | m in g.nodes && (m, n) in g.edges|\n}\n\nfunction {:spec} outDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |neighbors(g, n)|\n}\n\nghost predicate {:spec} isConnected(g: Graph)\n  requires validGraph(g)\n{\n  forall n, m :: n in g.nodes && m in g.nodes ==> reachable(g, n, m)\n}\n\n// Simplified version without recursion\nghost function {:spec} graphDistance(g: Graph, from: Node, to: Node): nat\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n  requires reachable(g, from, to)\n{\n  var path :| isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to;\n  |path| - 1\n}\n\nlemma SelfReachable(g: Graph, n: Node)\n  requires validGraph(g)\n  requires n in g.nodes\n  ensures reachable(g, n, n)\n{\n  var path := [n];\n  assert |path| == 1;\n  assert |path| >= 1;\n  assert path[0] == n;\n  assert path[|path| - 1] == n;\n\n  // Show isPath\n  forall i | 0 <= i < |path|\n    ensures path[i] in g.nodes\n  {\n    assert path[i] == n;\n  }\n\n  forall i | 0 <= i < |path| - 1\n    ensures hasEdge(g, path[i], path[i+1])\n  {\n    assert false;  // No such i exists since |path| == 1\n  }\n\n  assert isPath(g, path);\n}\n\nlemma DirectEdgeReachable(g: Graph, a: Node, b: Node)\n  requires validGraph(g)\n  requires a in g.nodes && b in g.nodes\n  requires hasEdge(g, a, b)\n  ensures reachable(g, a, b)\n{\n  assert b in neighbors(g, a);\n  if a == b {\n    SelfReachable(g, a);\n  } else {\n    var path := [a, b];\n    assert |path| == 2;\n    assert |path| >= 1;\n    assert path[0] == a;\n    assert path[|path| - 1] == b;\n\n    // Show isPath\n    forall i | 0 <= i < |path|\n      ensures path[i] in g.nodes\n    {\n      if i == 0 { \n/*[CODE HERE]*/\n}\n      else { assert path[i] == b; }\n    }\n\n    forall i | 0 <= i < |path| - 1\n      ensures hasEdge(g, path[i], path[i+1])\n    {\n      assert i == 0;\n      assert path[i] == a && path[i+1] == b;\n    }\n\n    assert isPath(g, path);\n  }\n}\n\nlemma PathOfLengthTwo(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n  requires isPath(g, path)\n  requires |path| == 2\n  ensures path[0] in g.nodes && path[1] in g.nodes\n  ensures hasEdge(g, path[0], path[1])\n{\n  assert 0 <= 0 < |path|;\n  assert path[0] in g.nodes;\n  assert 0 <= 1 < |path|;\n  assert path[1] in g.nodes;\n  assert 0 <= 0 < |path| - 1;\n  assert hasEdge(g, path[0], path[1]);\n}\n\nlemma TreeNoCycle(g: Graph)\n  requires validGraph(g)\n  requires isTree(g)\n  ensures isAcyclic(g)\n{\n  // By definition of isTree\n}\n\nlemma EmptyGraphAcyclic(g: Graph)\n  requires validGraph(g)\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  if hasCycle(g) {\n    var path :| isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1];\n    assert |path| >= 2;\n    assert hasEdge(g, path[0], path[1]);\n    assert (path[0], path[1]) in g.edges;\n    assert false;\n  }\n}\n\nlemma SingleNodeAcyclic(g: Graph)\n  requires validGraph(g)\n  requires |g.nodes| == 1\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  EmptyGraphAcyclic(g);\n}\n\nlemma ValidGraphSubgraph(g: Graph, removed: Node)\n  requires validGraph(g)\n  requires removed in g.nodes\n  ensures validGraph(Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed))\n{\n  var g' := Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed);\n  forall e | e in g'.edges\n    ensures e.0 in g'.nodes && e.1 in g'.nodes\n  {\n    assert e in g.edges;\n    assert e.0 != removed && e.1 != removed;\n    assert e.0 in g.nodes && e.1 in g.nodes;\n    assert e.0 in g'.nodes && e.1 in g'.nodes;\n  }\n}", "output": "assert path[i] == a;"}, {"id": "example_DirectEdgeReachable_5", "type": "assert", "program": "// Graph operations: path, reachable, cycle detection\n\ntype Node = nat\n\ndatatype Graph = Graph(nodes: set<Node>, edges: set<(Node, Node)>)\n\npredicate {:spec} validGraph(g: Graph)\n{\n  forall e :: e in g.edges ==> e.0 in g.nodes && e.1 in g.nodes\n}\n\npredicate {:spec} hasEdge(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n{\n  (from, to) in g.edges\n}\n\nfunction {:spec} neighbors(g: Graph, n: Node): set<Node>\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  set m | m in g.nodes && (n, m) in g.edges\n}\n\npredicate {:spec} isPath(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n{\n  |path| > 0 &&\n  (forall i :: 0 <= i < |path| ==> path[i] in g.nodes) &&\n  (forall i :: 0 <= i < |path| - 1 ==> hasEdge(g, path[i], path[i+1]))\n}\n\nghost predicate {:spec} reachable(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n{\n  exists path :: isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to\n}\n\nghost predicate {:spec} hasCycle(g: Graph)\n  requires validGraph(g)\n{\n  exists path :: isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1]\n}\n\nghost predicate {:spec} isAcyclic(g: Graph)\n  requires validGraph(g)\n{\n  !hasCycle(g)\n}\n\nghost predicate {:spec} isTree(g: Graph)\n  requires validGraph(g)\n{\n  isAcyclic(g) &&\n  |g.edges| == |g.nodes| - 1 &&\n  forall n, m :: n in g.nodes && m in g.nodes && n != m ==> reachable(g, n, m)\n}\n\nfunction {:spec} inDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |set m | m in g.nodes && (m, n) in g.edges|\n}\n\nfunction {:spec} outDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |neighbors(g, n)|\n}\n\nghost predicate {:spec} isConnected(g: Graph)\n  requires validGraph(g)\n{\n  forall n, m :: n in g.nodes && m in g.nodes ==> reachable(g, n, m)\n}\n\n// Simplified version without recursion\nghost function {:spec} graphDistance(g: Graph, from: Node, to: Node): nat\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n  requires reachable(g, from, to)\n{\n  var path :| isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to;\n  |path| - 1\n}\n\nlemma SelfReachable(g: Graph, n: Node)\n  requires validGraph(g)\n  requires n in g.nodes\n  ensures reachable(g, n, n)\n{\n  var path := [n];\n  assert |path| == 1;\n  assert |path| >= 1;\n  assert path[0] == n;\n  assert path[|path| - 1] == n;\n\n  // Show isPath\n  forall i | 0 <= i < |path|\n    ensures path[i] in g.nodes\n  {\n    assert path[i] == n;\n  }\n\n  forall i | 0 <= i < |path| - 1\n    ensures hasEdge(g, path[i], path[i+1])\n  {\n    assert false;  // No such i exists since |path| == 1\n  }\n\n  assert isPath(g, path);\n}\n\nlemma DirectEdgeReachable(g: Graph, a: Node, b: Node)\n  requires validGraph(g)\n  requires a in g.nodes && b in g.nodes\n  requires hasEdge(g, a, b)\n  ensures reachable(g, a, b)\n{\n  assert b in neighbors(g, a);\n  if a == b {\n    SelfReachable(g, a);\n  } else {\n    var path := [a, b];\n    assert |path| == 2;\n    assert |path| >= 1;\n    assert path[0] == a;\n    \n/*[CODE HERE]*/\n\n    // Show isPath\n    forall i | 0 <= i < |path|\n      ensures path[i] in g.nodes\n    {\n      if i == 0 { assert path[i] == a; }\n      else { assert path[i] == b; }\n    }\n\n    forall i | 0 <= i < |path| - 1\n      ensures hasEdge(g, path[i], path[i+1])\n    {\n      assert i == 0;\n      assert path[i] == a && path[i+1] == b;\n    }\n\n    assert isPath(g, path);\n  }\n}\n\nlemma PathOfLengthTwo(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n  requires isPath(g, path)\n  requires |path| == 2\n  ensures path[0] in g.nodes && path[1] in g.nodes\n  ensures hasEdge(g, path[0], path[1])\n{\n  assert 0 <= 0 < |path|;\n  assert path[0] in g.nodes;\n  assert 0 <= 1 < |path|;\n  assert path[1] in g.nodes;\n  assert 0 <= 0 < |path| - 1;\n  assert hasEdge(g, path[0], path[1]);\n}\n\nlemma TreeNoCycle(g: Graph)\n  requires validGraph(g)\n  requires isTree(g)\n  ensures isAcyclic(g)\n{\n  // By definition of isTree\n}\n\nlemma EmptyGraphAcyclic(g: Graph)\n  requires validGraph(g)\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  if hasCycle(g) {\n    var path :| isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1];\n    assert |path| >= 2;\n    assert hasEdge(g, path[0], path[1]);\n    assert (path[0], path[1]) in g.edges;\n    assert false;\n  }\n}\n\nlemma SingleNodeAcyclic(g: Graph)\n  requires validGraph(g)\n  requires |g.nodes| == 1\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  EmptyGraphAcyclic(g);\n}\n\nlemma ValidGraphSubgraph(g: Graph, removed: Node)\n  requires validGraph(g)\n  requires removed in g.nodes\n  ensures validGraph(Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed))\n{\n  var g' := Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed);\n  forall e | e in g'.edges\n    ensures e.0 in g'.nodes && e.1 in g'.nodes\n  {\n    assert e in g.edges;\n    assert e.0 != removed && e.1 != removed;\n    assert e.0 in g.nodes && e.1 in g.nodes;\n    assert e.0 in g'.nodes && e.1 in g'.nodes;\n  }\n}", "output": "assert path[|path| - 1] == b;"}, {"id": "example_DirectEdgeReachable_6", "type": "assert", "program": "// Graph operations: path, reachable, cycle detection\n\ntype Node = nat\n\ndatatype Graph = Graph(nodes: set<Node>, edges: set<(Node, Node)>)\n\npredicate {:spec} validGraph(g: Graph)\n{\n  forall e :: e in g.edges ==> e.0 in g.nodes && e.1 in g.nodes\n}\n\npredicate {:spec} hasEdge(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n{\n  (from, to) in g.edges\n}\n\nfunction {:spec} neighbors(g: Graph, n: Node): set<Node>\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  set m | m in g.nodes && (n, m) in g.edges\n}\n\npredicate {:spec} isPath(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n{\n  |path| > 0 &&\n  (forall i :: 0 <= i < |path| ==> path[i] in g.nodes) &&\n  (forall i :: 0 <= i < |path| - 1 ==> hasEdge(g, path[i], path[i+1]))\n}\n\nghost predicate {:spec} reachable(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n{\n  exists path :: isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to\n}\n\nghost predicate {:spec} hasCycle(g: Graph)\n  requires validGraph(g)\n{\n  exists path :: isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1]\n}\n\nghost predicate {:spec} isAcyclic(g: Graph)\n  requires validGraph(g)\n{\n  !hasCycle(g)\n}\n\nghost predicate {:spec} isTree(g: Graph)\n  requires validGraph(g)\n{\n  isAcyclic(g) &&\n  |g.edges| == |g.nodes| - 1 &&\n  forall n, m :: n in g.nodes && m in g.nodes && n != m ==> reachable(g, n, m)\n}\n\nfunction {:spec} inDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |set m | m in g.nodes && (m, n) in g.edges|\n}\n\nfunction {:spec} outDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |neighbors(g, n)|\n}\n\nghost predicate {:spec} isConnected(g: Graph)\n  requires validGraph(g)\n{\n  forall n, m :: n in g.nodes && m in g.nodes ==> reachable(g, n, m)\n}\n\n// Simplified version without recursion\nghost function {:spec} graphDistance(g: Graph, from: Node, to: Node): nat\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n  requires reachable(g, from, to)\n{\n  var path :| isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to;\n  |path| - 1\n}\n\nlemma SelfReachable(g: Graph, n: Node)\n  requires validGraph(g)\n  requires n in g.nodes\n  ensures reachable(g, n, n)\n{\n  var path := [n];\n  assert |path| == 1;\n  assert |path| >= 1;\n  assert path[0] == n;\n  assert path[|path| - 1] == n;\n\n  // Show isPath\n  forall i | 0 <= i < |path|\n    ensures path[i] in g.nodes\n  {\n    assert path[i] == n;\n  }\n\n  forall i | 0 <= i < |path| - 1\n    ensures hasEdge(g, path[i], path[i+1])\n  {\n    assert false;  // No such i exists since |path| == 1\n  }\n\n  assert isPath(g, path);\n}\n\nlemma DirectEdgeReachable(g: Graph, a: Node, b: Node)\n  requires validGraph(g)\n  requires a in g.nodes && b in g.nodes\n  requires hasEdge(g, a, b)\n  ensures reachable(g, a, b)\n{\n  assert b in neighbors(g, a);\n  if a == b {\n    SelfReachable(g, a);\n  } else {\n    var path := [a, b];\n    assert |path| == 2;\n    assert |path| >= 1;\n    \n/*[CODE HERE]*/\n    assert path[|path| - 1] == b;\n\n    // Show isPath\n    forall i | 0 <= i < |path|\n      ensures path[i] in g.nodes\n    {\n      if i == 0 { assert path[i] == a; }\n      else { assert path[i] == b; }\n    }\n\n    forall i | 0 <= i < |path| - 1\n      ensures hasEdge(g, path[i], path[i+1])\n    {\n      assert i == 0;\n      assert path[i] == a && path[i+1] == b;\n    }\n\n    assert isPath(g, path);\n  }\n}\n\nlemma PathOfLengthTwo(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n  requires isPath(g, path)\n  requires |path| == 2\n  ensures path[0] in g.nodes && path[1] in g.nodes\n  ensures hasEdge(g, path[0], path[1])\n{\n  assert 0 <= 0 < |path|;\n  assert path[0] in g.nodes;\n  assert 0 <= 1 < |path|;\n  assert path[1] in g.nodes;\n  assert 0 <= 0 < |path| - 1;\n  assert hasEdge(g, path[0], path[1]);\n}\n\nlemma TreeNoCycle(g: Graph)\n  requires validGraph(g)\n  requires isTree(g)\n  ensures isAcyclic(g)\n{\n  // By definition of isTree\n}\n\nlemma EmptyGraphAcyclic(g: Graph)\n  requires validGraph(g)\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  if hasCycle(g) {\n    var path :| isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1];\n    assert |path| >= 2;\n    assert hasEdge(g, path[0], path[1]);\n    assert (path[0], path[1]) in g.edges;\n    assert false;\n  }\n}\n\nlemma SingleNodeAcyclic(g: Graph)\n  requires validGraph(g)\n  requires |g.nodes| == 1\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  EmptyGraphAcyclic(g);\n}\n\nlemma ValidGraphSubgraph(g: Graph, removed: Node)\n  requires validGraph(g)\n  requires removed in g.nodes\n  ensures validGraph(Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed))\n{\n  var g' := Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed);\n  forall e | e in g'.edges\n    ensures e.0 in g'.nodes && e.1 in g'.nodes\n  {\n    assert e in g.edges;\n    assert e.0 != removed && e.1 != removed;\n    assert e.0 in g.nodes && e.1 in g.nodes;\n    assert e.0 in g'.nodes && e.1 in g'.nodes;\n  }\n}", "output": "assert path[0] == a;"}, {"id": "example_DirectEdgeReachable_7", "type": "assert", "program": "// Graph operations: path, reachable, cycle detection\n\ntype Node = nat\n\ndatatype Graph = Graph(nodes: set<Node>, edges: set<(Node, Node)>)\n\npredicate {:spec} validGraph(g: Graph)\n{\n  forall e :: e in g.edges ==> e.0 in g.nodes && e.1 in g.nodes\n}\n\npredicate {:spec} hasEdge(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n{\n  (from, to) in g.edges\n}\n\nfunction {:spec} neighbors(g: Graph, n: Node): set<Node>\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  set m | m in g.nodes && (n, m) in g.edges\n}\n\npredicate {:spec} isPath(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n{\n  |path| > 0 &&\n  (forall i :: 0 <= i < |path| ==> path[i] in g.nodes) &&\n  (forall i :: 0 <= i < |path| - 1 ==> hasEdge(g, path[i], path[i+1]))\n}\n\nghost predicate {:spec} reachable(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n{\n  exists path :: isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to\n}\n\nghost predicate {:spec} hasCycle(g: Graph)\n  requires validGraph(g)\n{\n  exists path :: isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1]\n}\n\nghost predicate {:spec} isAcyclic(g: Graph)\n  requires validGraph(g)\n{\n  !hasCycle(g)\n}\n\nghost predicate {:spec} isTree(g: Graph)\n  requires validGraph(g)\n{\n  isAcyclic(g) &&\n  |g.edges| == |g.nodes| - 1 &&\n  forall n, m :: n in g.nodes && m in g.nodes && n != m ==> reachable(g, n, m)\n}\n\nfunction {:spec} inDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |set m | m in g.nodes && (m, n) in g.edges|\n}\n\nfunction {:spec} outDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |neighbors(g, n)|\n}\n\nghost predicate {:spec} isConnected(g: Graph)\n  requires validGraph(g)\n{\n  forall n, m :: n in g.nodes && m in g.nodes ==> reachable(g, n, m)\n}\n\n// Simplified version without recursion\nghost function {:spec} graphDistance(g: Graph, from: Node, to: Node): nat\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n  requires reachable(g, from, to)\n{\n  var path :| isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to;\n  |path| - 1\n}\n\nlemma SelfReachable(g: Graph, n: Node)\n  requires validGraph(g)\n  requires n in g.nodes\n  ensures reachable(g, n, n)\n{\n  var path := [n];\n  assert |path| == 1;\n  assert |path| >= 1;\n  assert path[0] == n;\n  assert path[|path| - 1] == n;\n\n  // Show isPath\n  forall i | 0 <= i < |path|\n    ensures path[i] in g.nodes\n  {\n    assert path[i] == n;\n  }\n\n  forall i | 0 <= i < |path| - 1\n    ensures hasEdge(g, path[i], path[i+1])\n  {\n    assert false;  // No such i exists since |path| == 1\n  }\n\n  assert isPath(g, path);\n}\n\nlemma DirectEdgeReachable(g: Graph, a: Node, b: Node)\n  requires validGraph(g)\n  requires a in g.nodes && b in g.nodes\n  requires hasEdge(g, a, b)\n  ensures reachable(g, a, b)\n{\n  assert b in neighbors(g, a);\n  if a == b {\n    SelfReachable(g, a);\n  } else {\n    var path := [a, b];\n    assert |path| == 2;\n    \n/*[CODE HERE]*/\n    assert path[0] == a;\n    assert path[|path| - 1] == b;\n\n    // Show isPath\n    forall i | 0 <= i < |path|\n      ensures path[i] in g.nodes\n    {\n      if i == 0 { assert path[i] == a; }\n      else { assert path[i] == b; }\n    }\n\n    forall i | 0 <= i < |path| - 1\n      ensures hasEdge(g, path[i], path[i+1])\n    {\n      assert i == 0;\n      assert path[i] == a && path[i+1] == b;\n    }\n\n    assert isPath(g, path);\n  }\n}\n\nlemma PathOfLengthTwo(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n  requires isPath(g, path)\n  requires |path| == 2\n  ensures path[0] in g.nodes && path[1] in g.nodes\n  ensures hasEdge(g, path[0], path[1])\n{\n  assert 0 <= 0 < |path|;\n  assert path[0] in g.nodes;\n  assert 0 <= 1 < |path|;\n  assert path[1] in g.nodes;\n  assert 0 <= 0 < |path| - 1;\n  assert hasEdge(g, path[0], path[1]);\n}\n\nlemma TreeNoCycle(g: Graph)\n  requires validGraph(g)\n  requires isTree(g)\n  ensures isAcyclic(g)\n{\n  // By definition of isTree\n}\n\nlemma EmptyGraphAcyclic(g: Graph)\n  requires validGraph(g)\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  if hasCycle(g) {\n    var path :| isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1];\n    assert |path| >= 2;\n    assert hasEdge(g, path[0], path[1]);\n    assert (path[0], path[1]) in g.edges;\n    assert false;\n  }\n}\n\nlemma SingleNodeAcyclic(g: Graph)\n  requires validGraph(g)\n  requires |g.nodes| == 1\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  EmptyGraphAcyclic(g);\n}\n\nlemma ValidGraphSubgraph(g: Graph, removed: Node)\n  requires validGraph(g)\n  requires removed in g.nodes\n  ensures validGraph(Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed))\n{\n  var g' := Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed);\n  forall e | e in g'.edges\n    ensures e.0 in g'.nodes && e.1 in g'.nodes\n  {\n    assert e in g.edges;\n    assert e.0 != removed && e.1 != removed;\n    assert e.0 in g.nodes && e.1 in g.nodes;\n    assert e.0 in g'.nodes && e.1 in g'.nodes;\n  }\n}", "output": "assert |path| >= 1;"}, {"id": "example_DirectEdgeReachable_8", "type": "assert", "program": "// Graph operations: path, reachable, cycle detection\n\ntype Node = nat\n\ndatatype Graph = Graph(nodes: set<Node>, edges: set<(Node, Node)>)\n\npredicate {:spec} validGraph(g: Graph)\n{\n  forall e :: e in g.edges ==> e.0 in g.nodes && e.1 in g.nodes\n}\n\npredicate {:spec} hasEdge(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n{\n  (from, to) in g.edges\n}\n\nfunction {:spec} neighbors(g: Graph, n: Node): set<Node>\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  set m | m in g.nodes && (n, m) in g.edges\n}\n\npredicate {:spec} isPath(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n{\n  |path| > 0 &&\n  (forall i :: 0 <= i < |path| ==> path[i] in g.nodes) &&\n  (forall i :: 0 <= i < |path| - 1 ==> hasEdge(g, path[i], path[i+1]))\n}\n\nghost predicate {:spec} reachable(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n{\n  exists path :: isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to\n}\n\nghost predicate {:spec} hasCycle(g: Graph)\n  requires validGraph(g)\n{\n  exists path :: isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1]\n}\n\nghost predicate {:spec} isAcyclic(g: Graph)\n  requires validGraph(g)\n{\n  !hasCycle(g)\n}\n\nghost predicate {:spec} isTree(g: Graph)\n  requires validGraph(g)\n{\n  isAcyclic(g) &&\n  |g.edges| == |g.nodes| - 1 &&\n  forall n, m :: n in g.nodes && m in g.nodes && n != m ==> reachable(g, n, m)\n}\n\nfunction {:spec} inDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |set m | m in g.nodes && (m, n) in g.edges|\n}\n\nfunction {:spec} outDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |neighbors(g, n)|\n}\n\nghost predicate {:spec} isConnected(g: Graph)\n  requires validGraph(g)\n{\n  forall n, m :: n in g.nodes && m in g.nodes ==> reachable(g, n, m)\n}\n\n// Simplified version without recursion\nghost function {:spec} graphDistance(g: Graph, from: Node, to: Node): nat\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n  requires reachable(g, from, to)\n{\n  var path :| isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to;\n  |path| - 1\n}\n\nlemma SelfReachable(g: Graph, n: Node)\n  requires validGraph(g)\n  requires n in g.nodes\n  ensures reachable(g, n, n)\n{\n  var path := [n];\n  assert |path| == 1;\n  assert |path| >= 1;\n  assert path[0] == n;\n  assert path[|path| - 1] == n;\n\n  // Show isPath\n  forall i | 0 <= i < |path|\n    ensures path[i] in g.nodes\n  {\n    assert path[i] == n;\n  }\n\n  forall i | 0 <= i < |path| - 1\n    ensures hasEdge(g, path[i], path[i+1])\n  {\n    assert false;  // No such i exists since |path| == 1\n  }\n\n  assert isPath(g, path);\n}\n\nlemma DirectEdgeReachable(g: Graph, a: Node, b: Node)\n  requires validGraph(g)\n  requires a in g.nodes && b in g.nodes\n  requires hasEdge(g, a, b)\n  ensures reachable(g, a, b)\n{\n  assert b in neighbors(g, a);\n  if a == b {\n    SelfReachable(g, a);\n  } else {\n    var path := [a, b];\n    \n/*[CODE HERE]*/\n    assert |path| >= 1;\n    assert path[0] == a;\n    assert path[|path| - 1] == b;\n\n    // Show isPath\n    forall i | 0 <= i < |path|\n      ensures path[i] in g.nodes\n    {\n      if i == 0 { assert path[i] == a; }\n      else { assert path[i] == b; }\n    }\n\n    forall i | 0 <= i < |path| - 1\n      ensures hasEdge(g, path[i], path[i+1])\n    {\n      assert i == 0;\n      assert path[i] == a && path[i+1] == b;\n    }\n\n    assert isPath(g, path);\n  }\n}\n\nlemma PathOfLengthTwo(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n  requires isPath(g, path)\n  requires |path| == 2\n  ensures path[0] in g.nodes && path[1] in g.nodes\n  ensures hasEdge(g, path[0], path[1])\n{\n  assert 0 <= 0 < |path|;\n  assert path[0] in g.nodes;\n  assert 0 <= 1 < |path|;\n  assert path[1] in g.nodes;\n  assert 0 <= 0 < |path| - 1;\n  assert hasEdge(g, path[0], path[1]);\n}\n\nlemma TreeNoCycle(g: Graph)\n  requires validGraph(g)\n  requires isTree(g)\n  ensures isAcyclic(g)\n{\n  // By definition of isTree\n}\n\nlemma EmptyGraphAcyclic(g: Graph)\n  requires validGraph(g)\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  if hasCycle(g) {\n    var path :| isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1];\n    assert |path| >= 2;\n    assert hasEdge(g, path[0], path[1]);\n    assert (path[0], path[1]) in g.edges;\n    assert false;\n  }\n}\n\nlemma SingleNodeAcyclic(g: Graph)\n  requires validGraph(g)\n  requires |g.nodes| == 1\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  EmptyGraphAcyclic(g);\n}\n\nlemma ValidGraphSubgraph(g: Graph, removed: Node)\n  requires validGraph(g)\n  requires removed in g.nodes\n  ensures validGraph(Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed))\n{\n  var g' := Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed);\n  forall e | e in g'.edges\n    ensures e.0 in g'.nodes && e.1 in g'.nodes\n  {\n    assert e in g.edges;\n    assert e.0 != removed && e.1 != removed;\n    assert e.0 in g.nodes && e.1 in g.nodes;\n    assert e.0 in g'.nodes && e.1 in g'.nodes;\n  }\n}", "output": "assert |path| == 2;"}, {"id": "example_DirectEdgeReachable_9", "type": "call", "program": "// Graph operations: path, reachable, cycle detection\n\ntype Node = nat\n\ndatatype Graph = Graph(nodes: set<Node>, edges: set<(Node, Node)>)\n\npredicate {:spec} validGraph(g: Graph)\n{\n  forall e :: e in g.edges ==> e.0 in g.nodes && e.1 in g.nodes\n}\n\npredicate {:spec} hasEdge(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n{\n  (from, to) in g.edges\n}\n\nfunction {:spec} neighbors(g: Graph, n: Node): set<Node>\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  set m | m in g.nodes && (n, m) in g.edges\n}\n\npredicate {:spec} isPath(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n{\n  |path| > 0 &&\n  (forall i :: 0 <= i < |path| ==> path[i] in g.nodes) &&\n  (forall i :: 0 <= i < |path| - 1 ==> hasEdge(g, path[i], path[i+1]))\n}\n\nghost predicate {:spec} reachable(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n{\n  exists path :: isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to\n}\n\nghost predicate {:spec} hasCycle(g: Graph)\n  requires validGraph(g)\n{\n  exists path :: isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1]\n}\n\nghost predicate {:spec} isAcyclic(g: Graph)\n  requires validGraph(g)\n{\n  !hasCycle(g)\n}\n\nghost predicate {:spec} isTree(g: Graph)\n  requires validGraph(g)\n{\n  isAcyclic(g) &&\n  |g.edges| == |g.nodes| - 1 &&\n  forall n, m :: n in g.nodes && m in g.nodes && n != m ==> reachable(g, n, m)\n}\n\nfunction {:spec} inDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |set m | m in g.nodes && (m, n) in g.edges|\n}\n\nfunction {:spec} outDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |neighbors(g, n)|\n}\n\nghost predicate {:spec} isConnected(g: Graph)\n  requires validGraph(g)\n{\n  forall n, m :: n in g.nodes && m in g.nodes ==> reachable(g, n, m)\n}\n\n// Simplified version without recursion\nghost function {:spec} graphDistance(g: Graph, from: Node, to: Node): nat\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n  requires reachable(g, from, to)\n{\n  var path :| isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to;\n  |path| - 1\n}\n\nlemma SelfReachable(g: Graph, n: Node)\n  requires validGraph(g)\n  requires n in g.nodes\n  ensures reachable(g, n, n)\n{\n  var path := [n];\n  assert |path| == 1;\n  assert |path| >= 1;\n  assert path[0] == n;\n  assert path[|path| - 1] == n;\n\n  // Show isPath\n  forall i | 0 <= i < |path|\n    ensures path[i] in g.nodes\n  {\n    assert path[i] == n;\n  }\n\n  forall i | 0 <= i < |path| - 1\n    ensures hasEdge(g, path[i], path[i+1])\n  {\n    assert false;  // No such i exists since |path| == 1\n  }\n\n  assert isPath(g, path);\n}\n\nlemma DirectEdgeReachable(g: Graph, a: Node, b: Node)\n  requires validGraph(g)\n  requires a in g.nodes && b in g.nodes\n  requires hasEdge(g, a, b)\n  ensures reachable(g, a, b)\n{\n  assert b in neighbors(g, a);\n  if a == b {\n    \n/*[CODE HERE]*/\n  } else {\n    var path := [a, b];\n    assert |path| == 2;\n    assert |path| >= 1;\n    assert path[0] == a;\n    assert path[|path| - 1] == b;\n\n    // Show isPath\n    forall i | 0 <= i < |path|\n      ensures path[i] in g.nodes\n    {\n      if i == 0 { assert path[i] == a; }\n      else { assert path[i] == b; }\n    }\n\n    forall i | 0 <= i < |path| - 1\n      ensures hasEdge(g, path[i], path[i+1])\n    {\n      assert i == 0;\n      assert path[i] == a && path[i+1] == b;\n    }\n\n    assert isPath(g, path);\n  }\n}\n\nlemma PathOfLengthTwo(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n  requires isPath(g, path)\n  requires |path| == 2\n  ensures path[0] in g.nodes && path[1] in g.nodes\n  ensures hasEdge(g, path[0], path[1])\n{\n  assert 0 <= 0 < |path|;\n  assert path[0] in g.nodes;\n  assert 0 <= 1 < |path|;\n  assert path[1] in g.nodes;\n  assert 0 <= 0 < |path| - 1;\n  assert hasEdge(g, path[0], path[1]);\n}\n\nlemma TreeNoCycle(g: Graph)\n  requires validGraph(g)\n  requires isTree(g)\n  ensures isAcyclic(g)\n{\n  // By definition of isTree\n}\n\nlemma EmptyGraphAcyclic(g: Graph)\n  requires validGraph(g)\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  if hasCycle(g) {\n    var path :| isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1];\n    assert |path| >= 2;\n    assert hasEdge(g, path[0], path[1]);\n    assert (path[0], path[1]) in g.edges;\n    assert false;\n  }\n}\n\nlemma SingleNodeAcyclic(g: Graph)\n  requires validGraph(g)\n  requires |g.nodes| == 1\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  EmptyGraphAcyclic(g);\n}\n\nlemma ValidGraphSubgraph(g: Graph, removed: Node)\n  requires validGraph(g)\n  requires removed in g.nodes\n  ensures validGraph(Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed))\n{\n  var g' := Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed);\n  forall e | e in g'.edges\n    ensures e.0 in g'.nodes && e.1 in g'.nodes\n  {\n    assert e in g.edges;\n    assert e.0 != removed && e.1 != removed;\n    assert e.0 in g.nodes && e.1 in g.nodes;\n    assert e.0 in g'.nodes && e.1 in g'.nodes;\n  }\n}", "output": "SelfReachable(g, a);"}, {"id": "example_DirectEdgeReachable_10", "type": "assert", "program": "// Graph operations: path, reachable, cycle detection\n\ntype Node = nat\n\ndatatype Graph = Graph(nodes: set<Node>, edges: set<(Node, Node)>)\n\npredicate {:spec} validGraph(g: Graph)\n{\n  forall e :: e in g.edges ==> e.0 in g.nodes && e.1 in g.nodes\n}\n\npredicate {:spec} hasEdge(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n{\n  (from, to) in g.edges\n}\n\nfunction {:spec} neighbors(g: Graph, n: Node): set<Node>\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  set m | m in g.nodes && (n, m) in g.edges\n}\n\npredicate {:spec} isPath(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n{\n  |path| > 0 &&\n  (forall i :: 0 <= i < |path| ==> path[i] in g.nodes) &&\n  (forall i :: 0 <= i < |path| - 1 ==> hasEdge(g, path[i], path[i+1]))\n}\n\nghost predicate {:spec} reachable(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n{\n  exists path :: isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to\n}\n\nghost predicate {:spec} hasCycle(g: Graph)\n  requires validGraph(g)\n{\n  exists path :: isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1]\n}\n\nghost predicate {:spec} isAcyclic(g: Graph)\n  requires validGraph(g)\n{\n  !hasCycle(g)\n}\n\nghost predicate {:spec} isTree(g: Graph)\n  requires validGraph(g)\n{\n  isAcyclic(g) &&\n  |g.edges| == |g.nodes| - 1 &&\n  forall n, m :: n in g.nodes && m in g.nodes && n != m ==> reachable(g, n, m)\n}\n\nfunction {:spec} inDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |set m | m in g.nodes && (m, n) in g.edges|\n}\n\nfunction {:spec} outDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |neighbors(g, n)|\n}\n\nghost predicate {:spec} isConnected(g: Graph)\n  requires validGraph(g)\n{\n  forall n, m :: n in g.nodes && m in g.nodes ==> reachable(g, n, m)\n}\n\n// Simplified version without recursion\nghost function {:spec} graphDistance(g: Graph, from: Node, to: Node): nat\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n  requires reachable(g, from, to)\n{\n  var path :| isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to;\n  |path| - 1\n}\n\nlemma SelfReachable(g: Graph, n: Node)\n  requires validGraph(g)\n  requires n in g.nodes\n  ensures reachable(g, n, n)\n{\n  var path := [n];\n  assert |path| == 1;\n  assert |path| >= 1;\n  assert path[0] == n;\n  assert path[|path| - 1] == n;\n\n  // Show isPath\n  forall i | 0 <= i < |path|\n    ensures path[i] in g.nodes\n  {\n    assert path[i] == n;\n  }\n\n  forall i | 0 <= i < |path| - 1\n    ensures hasEdge(g, path[i], path[i+1])\n  {\n    assert false;  // No such i exists since |path| == 1\n  }\n\n  assert isPath(g, path);\n}\n\nlemma DirectEdgeReachable(g: Graph, a: Node, b: Node)\n  requires validGraph(g)\n  requires a in g.nodes && b in g.nodes\n  requires hasEdge(g, a, b)\n  ensures reachable(g, a, b)\n{\n  \n/*[CODE HERE]*/\n  if a == b {\n    SelfReachable(g, a);\n  } else {\n    var path := [a, b];\n    assert |path| == 2;\n    assert |path| >= 1;\n    assert path[0] == a;\n    assert path[|path| - 1] == b;\n\n    // Show isPath\n    forall i | 0 <= i < |path|\n      ensures path[i] in g.nodes\n    {\n      if i == 0 { assert path[i] == a; }\n      else { assert path[i] == b; }\n    }\n\n    forall i | 0 <= i < |path| - 1\n      ensures hasEdge(g, path[i], path[i+1])\n    {\n      assert i == 0;\n      assert path[i] == a && path[i+1] == b;\n    }\n\n    assert isPath(g, path);\n  }\n}\n\nlemma PathOfLengthTwo(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n  requires isPath(g, path)\n  requires |path| == 2\n  ensures path[0] in g.nodes && path[1] in g.nodes\n  ensures hasEdge(g, path[0], path[1])\n{\n  assert 0 <= 0 < |path|;\n  assert path[0] in g.nodes;\n  assert 0 <= 1 < |path|;\n  assert path[1] in g.nodes;\n  assert 0 <= 0 < |path| - 1;\n  assert hasEdge(g, path[0], path[1]);\n}\n\nlemma TreeNoCycle(g: Graph)\n  requires validGraph(g)\n  requires isTree(g)\n  ensures isAcyclic(g)\n{\n  // By definition of isTree\n}\n\nlemma EmptyGraphAcyclic(g: Graph)\n  requires validGraph(g)\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  if hasCycle(g) {\n    var path :| isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1];\n    assert |path| >= 2;\n    assert hasEdge(g, path[0], path[1]);\n    assert (path[0], path[1]) in g.edges;\n    assert false;\n  }\n}\n\nlemma SingleNodeAcyclic(g: Graph)\n  requires validGraph(g)\n  requires |g.nodes| == 1\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  EmptyGraphAcyclic(g);\n}\n\nlemma ValidGraphSubgraph(g: Graph, removed: Node)\n  requires validGraph(g)\n  requires removed in g.nodes\n  ensures validGraph(Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed))\n{\n  var g' := Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed);\n  forall e | e in g'.edges\n    ensures e.0 in g'.nodes && e.1 in g'.nodes\n  {\n    assert e in g.edges;\n    assert e.0 != removed && e.1 != removed;\n    assert e.0 in g.nodes && e.1 in g.nodes;\n    assert e.0 in g'.nodes && e.1 in g'.nodes;\n  }\n}", "output": "assert b in neighbors(g, a);"}, {"id": "example_PathOfLengthTwo_0", "type": "assert", "program": "// Graph operations: path, reachable, cycle detection\n\ntype Node = nat\n\ndatatype Graph = Graph(nodes: set<Node>, edges: set<(Node, Node)>)\n\npredicate {:spec} validGraph(g: Graph)\n{\n  forall e :: e in g.edges ==> e.0 in g.nodes && e.1 in g.nodes\n}\n\npredicate {:spec} hasEdge(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n{\n  (from, to) in g.edges\n}\n\nfunction {:spec} neighbors(g: Graph, n: Node): set<Node>\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  set m | m in g.nodes && (n, m) in g.edges\n}\n\npredicate {:spec} isPath(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n{\n  |path| > 0 &&\n  (forall i :: 0 <= i < |path| ==> path[i] in g.nodes) &&\n  (forall i :: 0 <= i < |path| - 1 ==> hasEdge(g, path[i], path[i+1]))\n}\n\nghost predicate {:spec} reachable(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n{\n  exists path :: isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to\n}\n\nghost predicate {:spec} hasCycle(g: Graph)\n  requires validGraph(g)\n{\n  exists path :: isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1]\n}\n\nghost predicate {:spec} isAcyclic(g: Graph)\n  requires validGraph(g)\n{\n  !hasCycle(g)\n}\n\nghost predicate {:spec} isTree(g: Graph)\n  requires validGraph(g)\n{\n  isAcyclic(g) &&\n  |g.edges| == |g.nodes| - 1 &&\n  forall n, m :: n in g.nodes && m in g.nodes && n != m ==> reachable(g, n, m)\n}\n\nfunction {:spec} inDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |set m | m in g.nodes && (m, n) in g.edges|\n}\n\nfunction {:spec} outDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |neighbors(g, n)|\n}\n\nghost predicate {:spec} isConnected(g: Graph)\n  requires validGraph(g)\n{\n  forall n, m :: n in g.nodes && m in g.nodes ==> reachable(g, n, m)\n}\n\n// Simplified version without recursion\nghost function {:spec} graphDistance(g: Graph, from: Node, to: Node): nat\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n  requires reachable(g, from, to)\n{\n  var path :| isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to;\n  |path| - 1\n}\n\nlemma SelfReachable(g: Graph, n: Node)\n  requires validGraph(g)\n  requires n in g.nodes\n  ensures reachable(g, n, n)\n{\n  var path := [n];\n  assert |path| == 1;\n  assert |path| >= 1;\n  assert path[0] == n;\n  assert path[|path| - 1] == n;\n\n  // Show isPath\n  forall i | 0 <= i < |path|\n    ensures path[i] in g.nodes\n  {\n    assert path[i] == n;\n  }\n\n  forall i | 0 <= i < |path| - 1\n    ensures hasEdge(g, path[i], path[i+1])\n  {\n    assert false;  // No such i exists since |path| == 1\n  }\n\n  assert isPath(g, path);\n}\n\nlemma DirectEdgeReachable(g: Graph, a: Node, b: Node)\n  requires validGraph(g)\n  requires a in g.nodes && b in g.nodes\n  requires hasEdge(g, a, b)\n  ensures reachable(g, a, b)\n{\n  assert b in neighbors(g, a);\n  if a == b {\n    SelfReachable(g, a);\n  } else {\n    var path := [a, b];\n    assert |path| == 2;\n    assert |path| >= 1;\n    assert path[0] == a;\n    assert path[|path| - 1] == b;\n\n    // Show isPath\n    forall i | 0 <= i < |path|\n      ensures path[i] in g.nodes\n    {\n      if i == 0 { assert path[i] == a; }\n      else { assert path[i] == b; }\n    }\n\n    forall i | 0 <= i < |path| - 1\n      ensures hasEdge(g, path[i], path[i+1])\n    {\n      assert i == 0;\n      assert path[i] == a && path[i+1] == b;\n    }\n\n    assert isPath(g, path);\n  }\n}\n\nlemma PathOfLengthTwo(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n  requires isPath(g, path)\n  requires |path| == 2\n  ensures path[0] in g.nodes && path[1] in g.nodes\n  ensures hasEdge(g, path[0], path[1])\n{\n  assert 0 <= 0 < |path|;\n  assert path[0] in g.nodes;\n  assert 0 <= 1 < |path|;\n  assert path[1] in g.nodes;\n  assert 0 <= 0 < |path| - 1;\n  \n/*[CODE HERE]*/\n}\n\nlemma TreeNoCycle(g: Graph)\n  requires validGraph(g)\n  requires isTree(g)\n  ensures isAcyclic(g)\n{\n  // By definition of isTree\n}\n\nlemma EmptyGraphAcyclic(g: Graph)\n  requires validGraph(g)\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  if hasCycle(g) {\n    var path :| isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1];\n    assert |path| >= 2;\n    assert hasEdge(g, path[0], path[1]);\n    assert (path[0], path[1]) in g.edges;\n    assert false;\n  }\n}\n\nlemma SingleNodeAcyclic(g: Graph)\n  requires validGraph(g)\n  requires |g.nodes| == 1\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  EmptyGraphAcyclic(g);\n}\n\nlemma ValidGraphSubgraph(g: Graph, removed: Node)\n  requires validGraph(g)\n  requires removed in g.nodes\n  ensures validGraph(Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed))\n{\n  var g' := Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed);\n  forall e | e in g'.edges\n    ensures e.0 in g'.nodes && e.1 in g'.nodes\n  {\n    assert e in g.edges;\n    assert e.0 != removed && e.1 != removed;\n    assert e.0 in g.nodes && e.1 in g.nodes;\n    assert e.0 in g'.nodes && e.1 in g'.nodes;\n  }\n}", "output": "assert hasEdge(g, path[0], path[1]);"}, {"id": "example_PathOfLengthTwo_1", "type": "assert", "program": "// Graph operations: path, reachable, cycle detection\n\ntype Node = nat\n\ndatatype Graph = Graph(nodes: set<Node>, edges: set<(Node, Node)>)\n\npredicate {:spec} validGraph(g: Graph)\n{\n  forall e :: e in g.edges ==> e.0 in g.nodes && e.1 in g.nodes\n}\n\npredicate {:spec} hasEdge(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n{\n  (from, to) in g.edges\n}\n\nfunction {:spec} neighbors(g: Graph, n: Node): set<Node>\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  set m | m in g.nodes && (n, m) in g.edges\n}\n\npredicate {:spec} isPath(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n{\n  |path| > 0 &&\n  (forall i :: 0 <= i < |path| ==> path[i] in g.nodes) &&\n  (forall i :: 0 <= i < |path| - 1 ==> hasEdge(g, path[i], path[i+1]))\n}\n\nghost predicate {:spec} reachable(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n{\n  exists path :: isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to\n}\n\nghost predicate {:spec} hasCycle(g: Graph)\n  requires validGraph(g)\n{\n  exists path :: isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1]\n}\n\nghost predicate {:spec} isAcyclic(g: Graph)\n  requires validGraph(g)\n{\n  !hasCycle(g)\n}\n\nghost predicate {:spec} isTree(g: Graph)\n  requires validGraph(g)\n{\n  isAcyclic(g) &&\n  |g.edges| == |g.nodes| - 1 &&\n  forall n, m :: n in g.nodes && m in g.nodes && n != m ==> reachable(g, n, m)\n}\n\nfunction {:spec} inDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |set m | m in g.nodes && (m, n) in g.edges|\n}\n\nfunction {:spec} outDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |neighbors(g, n)|\n}\n\nghost predicate {:spec} isConnected(g: Graph)\n  requires validGraph(g)\n{\n  forall n, m :: n in g.nodes && m in g.nodes ==> reachable(g, n, m)\n}\n\n// Simplified version without recursion\nghost function {:spec} graphDistance(g: Graph, from: Node, to: Node): nat\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n  requires reachable(g, from, to)\n{\n  var path :| isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to;\n  |path| - 1\n}\n\nlemma SelfReachable(g: Graph, n: Node)\n  requires validGraph(g)\n  requires n in g.nodes\n  ensures reachable(g, n, n)\n{\n  var path := [n];\n  assert |path| == 1;\n  assert |path| >= 1;\n  assert path[0] == n;\n  assert path[|path| - 1] == n;\n\n  // Show isPath\n  forall i | 0 <= i < |path|\n    ensures path[i] in g.nodes\n  {\n    assert path[i] == n;\n  }\n\n  forall i | 0 <= i < |path| - 1\n    ensures hasEdge(g, path[i], path[i+1])\n  {\n    assert false;  // No such i exists since |path| == 1\n  }\n\n  assert isPath(g, path);\n}\n\nlemma DirectEdgeReachable(g: Graph, a: Node, b: Node)\n  requires validGraph(g)\n  requires a in g.nodes && b in g.nodes\n  requires hasEdge(g, a, b)\n  ensures reachable(g, a, b)\n{\n  assert b in neighbors(g, a);\n  if a == b {\n    SelfReachable(g, a);\n  } else {\n    var path := [a, b];\n    assert |path| == 2;\n    assert |path| >= 1;\n    assert path[0] == a;\n    assert path[|path| - 1] == b;\n\n    // Show isPath\n    forall i | 0 <= i < |path|\n      ensures path[i] in g.nodes\n    {\n      if i == 0 { assert path[i] == a; }\n      else { assert path[i] == b; }\n    }\n\n    forall i | 0 <= i < |path| - 1\n      ensures hasEdge(g, path[i], path[i+1])\n    {\n      assert i == 0;\n      assert path[i] == a && path[i+1] == b;\n    }\n\n    assert isPath(g, path);\n  }\n}\n\nlemma PathOfLengthTwo(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n  requires isPath(g, path)\n  requires |path| == 2\n  ensures path[0] in g.nodes && path[1] in g.nodes\n  ensures hasEdge(g, path[0], path[1])\n{\n  assert 0 <= 0 < |path|;\n  assert path[0] in g.nodes;\n  assert 0 <= 1 < |path|;\n  assert path[1] in g.nodes;\n  \n/*[CODE HERE]*/\n  assert hasEdge(g, path[0], path[1]);\n}\n\nlemma TreeNoCycle(g: Graph)\n  requires validGraph(g)\n  requires isTree(g)\n  ensures isAcyclic(g)\n{\n  // By definition of isTree\n}\n\nlemma EmptyGraphAcyclic(g: Graph)\n  requires validGraph(g)\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  if hasCycle(g) {\n    var path :| isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1];\n    assert |path| >= 2;\n    assert hasEdge(g, path[0], path[1]);\n    assert (path[0], path[1]) in g.edges;\n    assert false;\n  }\n}\n\nlemma SingleNodeAcyclic(g: Graph)\n  requires validGraph(g)\n  requires |g.nodes| == 1\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  EmptyGraphAcyclic(g);\n}\n\nlemma ValidGraphSubgraph(g: Graph, removed: Node)\n  requires validGraph(g)\n  requires removed in g.nodes\n  ensures validGraph(Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed))\n{\n  var g' := Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed);\n  forall e | e in g'.edges\n    ensures e.0 in g'.nodes && e.1 in g'.nodes\n  {\n    assert e in g.edges;\n    assert e.0 != removed && e.1 != removed;\n    assert e.0 in g.nodes && e.1 in g.nodes;\n    assert e.0 in g'.nodes && e.1 in g'.nodes;\n  }\n}", "output": "assert 0 <= 0 < |path| - 1;"}, {"id": "example_PathOfLengthTwo_2", "type": "assert", "program": "// Graph operations: path, reachable, cycle detection\n\ntype Node = nat\n\ndatatype Graph = Graph(nodes: set<Node>, edges: set<(Node, Node)>)\n\npredicate {:spec} validGraph(g: Graph)\n{\n  forall e :: e in g.edges ==> e.0 in g.nodes && e.1 in g.nodes\n}\n\npredicate {:spec} hasEdge(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n{\n  (from, to) in g.edges\n}\n\nfunction {:spec} neighbors(g: Graph, n: Node): set<Node>\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  set m | m in g.nodes && (n, m) in g.edges\n}\n\npredicate {:spec} isPath(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n{\n  |path| > 0 &&\n  (forall i :: 0 <= i < |path| ==> path[i] in g.nodes) &&\n  (forall i :: 0 <= i < |path| - 1 ==> hasEdge(g, path[i], path[i+1]))\n}\n\nghost predicate {:spec} reachable(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n{\n  exists path :: isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to\n}\n\nghost predicate {:spec} hasCycle(g: Graph)\n  requires validGraph(g)\n{\n  exists path :: isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1]\n}\n\nghost predicate {:spec} isAcyclic(g: Graph)\n  requires validGraph(g)\n{\n  !hasCycle(g)\n}\n\nghost predicate {:spec} isTree(g: Graph)\n  requires validGraph(g)\n{\n  isAcyclic(g) &&\n  |g.edges| == |g.nodes| - 1 &&\n  forall n, m :: n in g.nodes && m in g.nodes && n != m ==> reachable(g, n, m)\n}\n\nfunction {:spec} inDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |set m | m in g.nodes && (m, n) in g.edges|\n}\n\nfunction {:spec} outDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |neighbors(g, n)|\n}\n\nghost predicate {:spec} isConnected(g: Graph)\n  requires validGraph(g)\n{\n  forall n, m :: n in g.nodes && m in g.nodes ==> reachable(g, n, m)\n}\n\n// Simplified version without recursion\nghost function {:spec} graphDistance(g: Graph, from: Node, to: Node): nat\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n  requires reachable(g, from, to)\n{\n  var path :| isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to;\n  |path| - 1\n}\n\nlemma SelfReachable(g: Graph, n: Node)\n  requires validGraph(g)\n  requires n in g.nodes\n  ensures reachable(g, n, n)\n{\n  var path := [n];\n  assert |path| == 1;\n  assert |path| >= 1;\n  assert path[0] == n;\n  assert path[|path| - 1] == n;\n\n  // Show isPath\n  forall i | 0 <= i < |path|\n    ensures path[i] in g.nodes\n  {\n    assert path[i] == n;\n  }\n\n  forall i | 0 <= i < |path| - 1\n    ensures hasEdge(g, path[i], path[i+1])\n  {\n    assert false;  // No such i exists since |path| == 1\n  }\n\n  assert isPath(g, path);\n}\n\nlemma DirectEdgeReachable(g: Graph, a: Node, b: Node)\n  requires validGraph(g)\n  requires a in g.nodes && b in g.nodes\n  requires hasEdge(g, a, b)\n  ensures reachable(g, a, b)\n{\n  assert b in neighbors(g, a);\n  if a == b {\n    SelfReachable(g, a);\n  } else {\n    var path := [a, b];\n    assert |path| == 2;\n    assert |path| >= 1;\n    assert path[0] == a;\n    assert path[|path| - 1] == b;\n\n    // Show isPath\n    forall i | 0 <= i < |path|\n      ensures path[i] in g.nodes\n    {\n      if i == 0 { assert path[i] == a; }\n      else { assert path[i] == b; }\n    }\n\n    forall i | 0 <= i < |path| - 1\n      ensures hasEdge(g, path[i], path[i+1])\n    {\n      assert i == 0;\n      assert path[i] == a && path[i+1] == b;\n    }\n\n    assert isPath(g, path);\n  }\n}\n\nlemma PathOfLengthTwo(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n  requires isPath(g, path)\n  requires |path| == 2\n  ensures path[0] in g.nodes && path[1] in g.nodes\n  ensures hasEdge(g, path[0], path[1])\n{\n  assert 0 <= 0 < |path|;\n  assert path[0] in g.nodes;\n  assert 0 <= 1 < |path|;\n  \n/*[CODE HERE]*/\n  assert 0 <= 0 < |path| - 1;\n  assert hasEdge(g, path[0], path[1]);\n}\n\nlemma TreeNoCycle(g: Graph)\n  requires validGraph(g)\n  requires isTree(g)\n  ensures isAcyclic(g)\n{\n  // By definition of isTree\n}\n\nlemma EmptyGraphAcyclic(g: Graph)\n  requires validGraph(g)\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  if hasCycle(g) {\n    var path :| isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1];\n    assert |path| >= 2;\n    assert hasEdge(g, path[0], path[1]);\n    assert (path[0], path[1]) in g.edges;\n    assert false;\n  }\n}\n\nlemma SingleNodeAcyclic(g: Graph)\n  requires validGraph(g)\n  requires |g.nodes| == 1\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  EmptyGraphAcyclic(g);\n}\n\nlemma ValidGraphSubgraph(g: Graph, removed: Node)\n  requires validGraph(g)\n  requires removed in g.nodes\n  ensures validGraph(Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed))\n{\n  var g' := Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed);\n  forall e | e in g'.edges\n    ensures e.0 in g'.nodes && e.1 in g'.nodes\n  {\n    assert e in g.edges;\n    assert e.0 != removed && e.1 != removed;\n    assert e.0 in g.nodes && e.1 in g.nodes;\n    assert e.0 in g'.nodes && e.1 in g'.nodes;\n  }\n}", "output": "assert path[1] in g.nodes;"}, {"id": "example_PathOfLengthTwo_3", "type": "assert", "program": "// Graph operations: path, reachable, cycle detection\n\ntype Node = nat\n\ndatatype Graph = Graph(nodes: set<Node>, edges: set<(Node, Node)>)\n\npredicate {:spec} validGraph(g: Graph)\n{\n  forall e :: e in g.edges ==> e.0 in g.nodes && e.1 in g.nodes\n}\n\npredicate {:spec} hasEdge(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n{\n  (from, to) in g.edges\n}\n\nfunction {:spec} neighbors(g: Graph, n: Node): set<Node>\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  set m | m in g.nodes && (n, m) in g.edges\n}\n\npredicate {:spec} isPath(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n{\n  |path| > 0 &&\n  (forall i :: 0 <= i < |path| ==> path[i] in g.nodes) &&\n  (forall i :: 0 <= i < |path| - 1 ==> hasEdge(g, path[i], path[i+1]))\n}\n\nghost predicate {:spec} reachable(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n{\n  exists path :: isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to\n}\n\nghost predicate {:spec} hasCycle(g: Graph)\n  requires validGraph(g)\n{\n  exists path :: isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1]\n}\n\nghost predicate {:spec} isAcyclic(g: Graph)\n  requires validGraph(g)\n{\n  !hasCycle(g)\n}\n\nghost predicate {:spec} isTree(g: Graph)\n  requires validGraph(g)\n{\n  isAcyclic(g) &&\n  |g.edges| == |g.nodes| - 1 &&\n  forall n, m :: n in g.nodes && m in g.nodes && n != m ==> reachable(g, n, m)\n}\n\nfunction {:spec} inDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |set m | m in g.nodes && (m, n) in g.edges|\n}\n\nfunction {:spec} outDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |neighbors(g, n)|\n}\n\nghost predicate {:spec} isConnected(g: Graph)\n  requires validGraph(g)\n{\n  forall n, m :: n in g.nodes && m in g.nodes ==> reachable(g, n, m)\n}\n\n// Simplified version without recursion\nghost function {:spec} graphDistance(g: Graph, from: Node, to: Node): nat\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n  requires reachable(g, from, to)\n{\n  var path :| isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to;\n  |path| - 1\n}\n\nlemma SelfReachable(g: Graph, n: Node)\n  requires validGraph(g)\n  requires n in g.nodes\n  ensures reachable(g, n, n)\n{\n  var path := [n];\n  assert |path| == 1;\n  assert |path| >= 1;\n  assert path[0] == n;\n  assert path[|path| - 1] == n;\n\n  // Show isPath\n  forall i | 0 <= i < |path|\n    ensures path[i] in g.nodes\n  {\n    assert path[i] == n;\n  }\n\n  forall i | 0 <= i < |path| - 1\n    ensures hasEdge(g, path[i], path[i+1])\n  {\n    assert false;  // No such i exists since |path| == 1\n  }\n\n  assert isPath(g, path);\n}\n\nlemma DirectEdgeReachable(g: Graph, a: Node, b: Node)\n  requires validGraph(g)\n  requires a in g.nodes && b in g.nodes\n  requires hasEdge(g, a, b)\n  ensures reachable(g, a, b)\n{\n  assert b in neighbors(g, a);\n  if a == b {\n    SelfReachable(g, a);\n  } else {\n    var path := [a, b];\n    assert |path| == 2;\n    assert |path| >= 1;\n    assert path[0] == a;\n    assert path[|path| - 1] == b;\n\n    // Show isPath\n    forall i | 0 <= i < |path|\n      ensures path[i] in g.nodes\n    {\n      if i == 0 { assert path[i] == a; }\n      else { assert path[i] == b; }\n    }\n\n    forall i | 0 <= i < |path| - 1\n      ensures hasEdge(g, path[i], path[i+1])\n    {\n      assert i == 0;\n      assert path[i] == a && path[i+1] == b;\n    }\n\n    assert isPath(g, path);\n  }\n}\n\nlemma PathOfLengthTwo(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n  requires isPath(g, path)\n  requires |path| == 2\n  ensures path[0] in g.nodes && path[1] in g.nodes\n  ensures hasEdge(g, path[0], path[1])\n{\n  assert 0 <= 0 < |path|;\n  assert path[0] in g.nodes;\n  \n/*[CODE HERE]*/\n  assert path[1] in g.nodes;\n  assert 0 <= 0 < |path| - 1;\n  assert hasEdge(g, path[0], path[1]);\n}\n\nlemma TreeNoCycle(g: Graph)\n  requires validGraph(g)\n  requires isTree(g)\n  ensures isAcyclic(g)\n{\n  // By definition of isTree\n}\n\nlemma EmptyGraphAcyclic(g: Graph)\n  requires validGraph(g)\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  if hasCycle(g) {\n    var path :| isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1];\n    assert |path| >= 2;\n    assert hasEdge(g, path[0], path[1]);\n    assert (path[0], path[1]) in g.edges;\n    assert false;\n  }\n}\n\nlemma SingleNodeAcyclic(g: Graph)\n  requires validGraph(g)\n  requires |g.nodes| == 1\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  EmptyGraphAcyclic(g);\n}\n\nlemma ValidGraphSubgraph(g: Graph, removed: Node)\n  requires validGraph(g)\n  requires removed in g.nodes\n  ensures validGraph(Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed))\n{\n  var g' := Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed);\n  forall e | e in g'.edges\n    ensures e.0 in g'.nodes && e.1 in g'.nodes\n  {\n    assert e in g.edges;\n    assert e.0 != removed && e.1 != removed;\n    assert e.0 in g.nodes && e.1 in g.nodes;\n    assert e.0 in g'.nodes && e.1 in g'.nodes;\n  }\n}", "output": "assert 0 <= 1 < |path|;"}, {"id": "example_PathOfLengthTwo_4", "type": "assert", "program": "// Graph operations: path, reachable, cycle detection\n\ntype Node = nat\n\ndatatype Graph = Graph(nodes: set<Node>, edges: set<(Node, Node)>)\n\npredicate {:spec} validGraph(g: Graph)\n{\n  forall e :: e in g.edges ==> e.0 in g.nodes && e.1 in g.nodes\n}\n\npredicate {:spec} hasEdge(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n{\n  (from, to) in g.edges\n}\n\nfunction {:spec} neighbors(g: Graph, n: Node): set<Node>\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  set m | m in g.nodes && (n, m) in g.edges\n}\n\npredicate {:spec} isPath(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n{\n  |path| > 0 &&\n  (forall i :: 0 <= i < |path| ==> path[i] in g.nodes) &&\n  (forall i :: 0 <= i < |path| - 1 ==> hasEdge(g, path[i], path[i+1]))\n}\n\nghost predicate {:spec} reachable(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n{\n  exists path :: isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to\n}\n\nghost predicate {:spec} hasCycle(g: Graph)\n  requires validGraph(g)\n{\n  exists path :: isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1]\n}\n\nghost predicate {:spec} isAcyclic(g: Graph)\n  requires validGraph(g)\n{\n  !hasCycle(g)\n}\n\nghost predicate {:spec} isTree(g: Graph)\n  requires validGraph(g)\n{\n  isAcyclic(g) &&\n  |g.edges| == |g.nodes| - 1 &&\n  forall n, m :: n in g.nodes && m in g.nodes && n != m ==> reachable(g, n, m)\n}\n\nfunction {:spec} inDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |set m | m in g.nodes && (m, n) in g.edges|\n}\n\nfunction {:spec} outDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |neighbors(g, n)|\n}\n\nghost predicate {:spec} isConnected(g: Graph)\n  requires validGraph(g)\n{\n  forall n, m :: n in g.nodes && m in g.nodes ==> reachable(g, n, m)\n}\n\n// Simplified version without recursion\nghost function {:spec} graphDistance(g: Graph, from: Node, to: Node): nat\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n  requires reachable(g, from, to)\n{\n  var path :| isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to;\n  |path| - 1\n}\n\nlemma SelfReachable(g: Graph, n: Node)\n  requires validGraph(g)\n  requires n in g.nodes\n  ensures reachable(g, n, n)\n{\n  var path := [n];\n  assert |path| == 1;\n  assert |path| >= 1;\n  assert path[0] == n;\n  assert path[|path| - 1] == n;\n\n  // Show isPath\n  forall i | 0 <= i < |path|\n    ensures path[i] in g.nodes\n  {\n    assert path[i] == n;\n  }\n\n  forall i | 0 <= i < |path| - 1\n    ensures hasEdge(g, path[i], path[i+1])\n  {\n    assert false;  // No such i exists since |path| == 1\n  }\n\n  assert isPath(g, path);\n}\n\nlemma DirectEdgeReachable(g: Graph, a: Node, b: Node)\n  requires validGraph(g)\n  requires a in g.nodes && b in g.nodes\n  requires hasEdge(g, a, b)\n  ensures reachable(g, a, b)\n{\n  assert b in neighbors(g, a);\n  if a == b {\n    SelfReachable(g, a);\n  } else {\n    var path := [a, b];\n    assert |path| == 2;\n    assert |path| >= 1;\n    assert path[0] == a;\n    assert path[|path| - 1] == b;\n\n    // Show isPath\n    forall i | 0 <= i < |path|\n      ensures path[i] in g.nodes\n    {\n      if i == 0 { assert path[i] == a; }\n      else { assert path[i] == b; }\n    }\n\n    forall i | 0 <= i < |path| - 1\n      ensures hasEdge(g, path[i], path[i+1])\n    {\n      assert i == 0;\n      assert path[i] == a && path[i+1] == b;\n    }\n\n    assert isPath(g, path);\n  }\n}\n\nlemma PathOfLengthTwo(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n  requires isPath(g, path)\n  requires |path| == 2\n  ensures path[0] in g.nodes && path[1] in g.nodes\n  ensures hasEdge(g, path[0], path[1])\n{\n  assert 0 <= 0 < |path|;\n  \n/*[CODE HERE]*/\n  assert 0 <= 1 < |path|;\n  assert path[1] in g.nodes;\n  assert 0 <= 0 < |path| - 1;\n  assert hasEdge(g, path[0], path[1]);\n}\n\nlemma TreeNoCycle(g: Graph)\n  requires validGraph(g)\n  requires isTree(g)\n  ensures isAcyclic(g)\n{\n  // By definition of isTree\n}\n\nlemma EmptyGraphAcyclic(g: Graph)\n  requires validGraph(g)\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  if hasCycle(g) {\n    var path :| isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1];\n    assert |path| >= 2;\n    assert hasEdge(g, path[0], path[1]);\n    assert (path[0], path[1]) in g.edges;\n    assert false;\n  }\n}\n\nlemma SingleNodeAcyclic(g: Graph)\n  requires validGraph(g)\n  requires |g.nodes| == 1\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  EmptyGraphAcyclic(g);\n}\n\nlemma ValidGraphSubgraph(g: Graph, removed: Node)\n  requires validGraph(g)\n  requires removed in g.nodes\n  ensures validGraph(Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed))\n{\n  var g' := Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed);\n  forall e | e in g'.edges\n    ensures e.0 in g'.nodes && e.1 in g'.nodes\n  {\n    assert e in g.edges;\n    assert e.0 != removed && e.1 != removed;\n    assert e.0 in g.nodes && e.1 in g.nodes;\n    assert e.0 in g'.nodes && e.1 in g'.nodes;\n  }\n}", "output": "assert path[0] in g.nodes;"}, {"id": "example_PathOfLengthTwo_5", "type": "assert", "program": "// Graph operations: path, reachable, cycle detection\n\ntype Node = nat\n\ndatatype Graph = Graph(nodes: set<Node>, edges: set<(Node, Node)>)\n\npredicate {:spec} validGraph(g: Graph)\n{\n  forall e :: e in g.edges ==> e.0 in g.nodes && e.1 in g.nodes\n}\n\npredicate {:spec} hasEdge(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n{\n  (from, to) in g.edges\n}\n\nfunction {:spec} neighbors(g: Graph, n: Node): set<Node>\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  set m | m in g.nodes && (n, m) in g.edges\n}\n\npredicate {:spec} isPath(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n{\n  |path| > 0 &&\n  (forall i :: 0 <= i < |path| ==> path[i] in g.nodes) &&\n  (forall i :: 0 <= i < |path| - 1 ==> hasEdge(g, path[i], path[i+1]))\n}\n\nghost predicate {:spec} reachable(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n{\n  exists path :: isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to\n}\n\nghost predicate {:spec} hasCycle(g: Graph)\n  requires validGraph(g)\n{\n  exists path :: isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1]\n}\n\nghost predicate {:spec} isAcyclic(g: Graph)\n  requires validGraph(g)\n{\n  !hasCycle(g)\n}\n\nghost predicate {:spec} isTree(g: Graph)\n  requires validGraph(g)\n{\n  isAcyclic(g) &&\n  |g.edges| == |g.nodes| - 1 &&\n  forall n, m :: n in g.nodes && m in g.nodes && n != m ==> reachable(g, n, m)\n}\n\nfunction {:spec} inDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |set m | m in g.nodes && (m, n) in g.edges|\n}\n\nfunction {:spec} outDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |neighbors(g, n)|\n}\n\nghost predicate {:spec} isConnected(g: Graph)\n  requires validGraph(g)\n{\n  forall n, m :: n in g.nodes && m in g.nodes ==> reachable(g, n, m)\n}\n\n// Simplified version without recursion\nghost function {:spec} graphDistance(g: Graph, from: Node, to: Node): nat\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n  requires reachable(g, from, to)\n{\n  var path :| isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to;\n  |path| - 1\n}\n\nlemma SelfReachable(g: Graph, n: Node)\n  requires validGraph(g)\n  requires n in g.nodes\n  ensures reachable(g, n, n)\n{\n  var path := [n];\n  assert |path| == 1;\n  assert |path| >= 1;\n  assert path[0] == n;\n  assert path[|path| - 1] == n;\n\n  // Show isPath\n  forall i | 0 <= i < |path|\n    ensures path[i] in g.nodes\n  {\n    assert path[i] == n;\n  }\n\n  forall i | 0 <= i < |path| - 1\n    ensures hasEdge(g, path[i], path[i+1])\n  {\n    assert false;  // No such i exists since |path| == 1\n  }\n\n  assert isPath(g, path);\n}\n\nlemma DirectEdgeReachable(g: Graph, a: Node, b: Node)\n  requires validGraph(g)\n  requires a in g.nodes && b in g.nodes\n  requires hasEdge(g, a, b)\n  ensures reachable(g, a, b)\n{\n  assert b in neighbors(g, a);\n  if a == b {\n    SelfReachable(g, a);\n  } else {\n    var path := [a, b];\n    assert |path| == 2;\n    assert |path| >= 1;\n    assert path[0] == a;\n    assert path[|path| - 1] == b;\n\n    // Show isPath\n    forall i | 0 <= i < |path|\n      ensures path[i] in g.nodes\n    {\n      if i == 0 { assert path[i] == a; }\n      else { assert path[i] == b; }\n    }\n\n    forall i | 0 <= i < |path| - 1\n      ensures hasEdge(g, path[i], path[i+1])\n    {\n      assert i == 0;\n      assert path[i] == a && path[i+1] == b;\n    }\n\n    assert isPath(g, path);\n  }\n}\n\nlemma PathOfLengthTwo(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n  requires isPath(g, path)\n  requires |path| == 2\n  ensures path[0] in g.nodes && path[1] in g.nodes\n  ensures hasEdge(g, path[0], path[1])\n{\n  \n/*[CODE HERE]*/\n  assert path[0] in g.nodes;\n  assert 0 <= 1 < |path|;\n  assert path[1] in g.nodes;\n  assert 0 <= 0 < |path| - 1;\n  assert hasEdge(g, path[0], path[1]);\n}\n\nlemma TreeNoCycle(g: Graph)\n  requires validGraph(g)\n  requires isTree(g)\n  ensures isAcyclic(g)\n{\n  // By definition of isTree\n}\n\nlemma EmptyGraphAcyclic(g: Graph)\n  requires validGraph(g)\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  if hasCycle(g) {\n    var path :| isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1];\n    assert |path| >= 2;\n    assert hasEdge(g, path[0], path[1]);\n    assert (path[0], path[1]) in g.edges;\n    assert false;\n  }\n}\n\nlemma SingleNodeAcyclic(g: Graph)\n  requires validGraph(g)\n  requires |g.nodes| == 1\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  EmptyGraphAcyclic(g);\n}\n\nlemma ValidGraphSubgraph(g: Graph, removed: Node)\n  requires validGraph(g)\n  requires removed in g.nodes\n  ensures validGraph(Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed))\n{\n  var g' := Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed);\n  forall e | e in g'.edges\n    ensures e.0 in g'.nodes && e.1 in g'.nodes\n  {\n    assert e in g.edges;\n    assert e.0 != removed && e.1 != removed;\n    assert e.0 in g.nodes && e.1 in g.nodes;\n    assert e.0 in g'.nodes && e.1 in g'.nodes;\n  }\n}", "output": "assert 0 <= 0 < |path|;"}, {"id": "example_EmptyGraphAcyclic_0", "type": "assert", "program": "// Graph operations: path, reachable, cycle detection\n\ntype Node = nat\n\ndatatype Graph = Graph(nodes: set<Node>, edges: set<(Node, Node)>)\n\npredicate {:spec} validGraph(g: Graph)\n{\n  forall e :: e in g.edges ==> e.0 in g.nodes && e.1 in g.nodes\n}\n\npredicate {:spec} hasEdge(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n{\n  (from, to) in g.edges\n}\n\nfunction {:spec} neighbors(g: Graph, n: Node): set<Node>\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  set m | m in g.nodes && (n, m) in g.edges\n}\n\npredicate {:spec} isPath(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n{\n  |path| > 0 &&\n  (forall i :: 0 <= i < |path| ==> path[i] in g.nodes) &&\n  (forall i :: 0 <= i < |path| - 1 ==> hasEdge(g, path[i], path[i+1]))\n}\n\nghost predicate {:spec} reachable(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n{\n  exists path :: isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to\n}\n\nghost predicate {:spec} hasCycle(g: Graph)\n  requires validGraph(g)\n{\n  exists path :: isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1]\n}\n\nghost predicate {:spec} isAcyclic(g: Graph)\n  requires validGraph(g)\n{\n  !hasCycle(g)\n}\n\nghost predicate {:spec} isTree(g: Graph)\n  requires validGraph(g)\n{\n  isAcyclic(g) &&\n  |g.edges| == |g.nodes| - 1 &&\n  forall n, m :: n in g.nodes && m in g.nodes && n != m ==> reachable(g, n, m)\n}\n\nfunction {:spec} inDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |set m | m in g.nodes && (m, n) in g.edges|\n}\n\nfunction {:spec} outDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |neighbors(g, n)|\n}\n\nghost predicate {:spec} isConnected(g: Graph)\n  requires validGraph(g)\n{\n  forall n, m :: n in g.nodes && m in g.nodes ==> reachable(g, n, m)\n}\n\n// Simplified version without recursion\nghost function {:spec} graphDistance(g: Graph, from: Node, to: Node): nat\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n  requires reachable(g, from, to)\n{\n  var path :| isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to;\n  |path| - 1\n}\n\nlemma SelfReachable(g: Graph, n: Node)\n  requires validGraph(g)\n  requires n in g.nodes\n  ensures reachable(g, n, n)\n{\n  var path := [n];\n  assert |path| == 1;\n  assert |path| >= 1;\n  assert path[0] == n;\n  assert path[|path| - 1] == n;\n\n  // Show isPath\n  forall i | 0 <= i < |path|\n    ensures path[i] in g.nodes\n  {\n    assert path[i] == n;\n  }\n\n  forall i | 0 <= i < |path| - 1\n    ensures hasEdge(g, path[i], path[i+1])\n  {\n    assert false;  // No such i exists since |path| == 1\n  }\n\n  assert isPath(g, path);\n}\n\nlemma DirectEdgeReachable(g: Graph, a: Node, b: Node)\n  requires validGraph(g)\n  requires a in g.nodes && b in g.nodes\n  requires hasEdge(g, a, b)\n  ensures reachable(g, a, b)\n{\n  assert b in neighbors(g, a);\n  if a == b {\n    SelfReachable(g, a);\n  } else {\n    var path := [a, b];\n    assert |path| == 2;\n    assert |path| >= 1;\n    assert path[0] == a;\n    assert path[|path| - 1] == b;\n\n    // Show isPath\n    forall i | 0 <= i < |path|\n      ensures path[i] in g.nodes\n    {\n      if i == 0 { assert path[i] == a; }\n      else { assert path[i] == b; }\n    }\n\n    forall i | 0 <= i < |path| - 1\n      ensures hasEdge(g, path[i], path[i+1])\n    {\n      assert i == 0;\n      assert path[i] == a && path[i+1] == b;\n    }\n\n    assert isPath(g, path);\n  }\n}\n\nlemma PathOfLengthTwo(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n  requires isPath(g, path)\n  requires |path| == 2\n  ensures path[0] in g.nodes && path[1] in g.nodes\n  ensures hasEdge(g, path[0], path[1])\n{\n  assert 0 <= 0 < |path|;\n  assert path[0] in g.nodes;\n  assert 0 <= 1 < |path|;\n  assert path[1] in g.nodes;\n  assert 0 <= 0 < |path| - 1;\n  assert hasEdge(g, path[0], path[1]);\n}\n\nlemma TreeNoCycle(g: Graph)\n  requires validGraph(g)\n  requires isTree(g)\n  ensures isAcyclic(g)\n{\n  // By definition of isTree\n}\n\nlemma EmptyGraphAcyclic(g: Graph)\n  requires validGraph(g)\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  if hasCycle(g) {\n    var path :| isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1];\n    assert |path| >= 2;\n    assert hasEdge(g, path[0], path[1]);\n    assert (path[0], path[1]) in g.edges;\n    \n/*[CODE HERE]*/\n  }\n}\n\nlemma SingleNodeAcyclic(g: Graph)\n  requires validGraph(g)\n  requires |g.nodes| == 1\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  EmptyGraphAcyclic(g);\n}\n\nlemma ValidGraphSubgraph(g: Graph, removed: Node)\n  requires validGraph(g)\n  requires removed in g.nodes\n  ensures validGraph(Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed))\n{\n  var g' := Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed);\n  forall e | e in g'.edges\n    ensures e.0 in g'.nodes && e.1 in g'.nodes\n  {\n    assert e in g.edges;\n    assert e.0 != removed && e.1 != removed;\n    assert e.0 in g.nodes && e.1 in g.nodes;\n    assert e.0 in g'.nodes && e.1 in g'.nodes;\n  }\n}", "output": "assert false;"}, {"id": "example_EmptyGraphAcyclic_1", "type": "assert", "program": "// Graph operations: path, reachable, cycle detection\n\ntype Node = nat\n\ndatatype Graph = Graph(nodes: set<Node>, edges: set<(Node, Node)>)\n\npredicate {:spec} validGraph(g: Graph)\n{\n  forall e :: e in g.edges ==> e.0 in g.nodes && e.1 in g.nodes\n}\n\npredicate {:spec} hasEdge(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n{\n  (from, to) in g.edges\n}\n\nfunction {:spec} neighbors(g: Graph, n: Node): set<Node>\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  set m | m in g.nodes && (n, m) in g.edges\n}\n\npredicate {:spec} isPath(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n{\n  |path| > 0 &&\n  (forall i :: 0 <= i < |path| ==> path[i] in g.nodes) &&\n  (forall i :: 0 <= i < |path| - 1 ==> hasEdge(g, path[i], path[i+1]))\n}\n\nghost predicate {:spec} reachable(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n{\n  exists path :: isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to\n}\n\nghost predicate {:spec} hasCycle(g: Graph)\n  requires validGraph(g)\n{\n  exists path :: isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1]\n}\n\nghost predicate {:spec} isAcyclic(g: Graph)\n  requires validGraph(g)\n{\n  !hasCycle(g)\n}\n\nghost predicate {:spec} isTree(g: Graph)\n  requires validGraph(g)\n{\n  isAcyclic(g) &&\n  |g.edges| == |g.nodes| - 1 &&\n  forall n, m :: n in g.nodes && m in g.nodes && n != m ==> reachable(g, n, m)\n}\n\nfunction {:spec} inDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |set m | m in g.nodes && (m, n) in g.edges|\n}\n\nfunction {:spec} outDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |neighbors(g, n)|\n}\n\nghost predicate {:spec} isConnected(g: Graph)\n  requires validGraph(g)\n{\n  forall n, m :: n in g.nodes && m in g.nodes ==> reachable(g, n, m)\n}\n\n// Simplified version without recursion\nghost function {:spec} graphDistance(g: Graph, from: Node, to: Node): nat\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n  requires reachable(g, from, to)\n{\n  var path :| isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to;\n  |path| - 1\n}\n\nlemma SelfReachable(g: Graph, n: Node)\n  requires validGraph(g)\n  requires n in g.nodes\n  ensures reachable(g, n, n)\n{\n  var path := [n];\n  assert |path| == 1;\n  assert |path| >= 1;\n  assert path[0] == n;\n  assert path[|path| - 1] == n;\n\n  // Show isPath\n  forall i | 0 <= i < |path|\n    ensures path[i] in g.nodes\n  {\n    assert path[i] == n;\n  }\n\n  forall i | 0 <= i < |path| - 1\n    ensures hasEdge(g, path[i], path[i+1])\n  {\n    assert false;  // No such i exists since |path| == 1\n  }\n\n  assert isPath(g, path);\n}\n\nlemma DirectEdgeReachable(g: Graph, a: Node, b: Node)\n  requires validGraph(g)\n  requires a in g.nodes && b in g.nodes\n  requires hasEdge(g, a, b)\n  ensures reachable(g, a, b)\n{\n  assert b in neighbors(g, a);\n  if a == b {\n    SelfReachable(g, a);\n  } else {\n    var path := [a, b];\n    assert |path| == 2;\n    assert |path| >= 1;\n    assert path[0] == a;\n    assert path[|path| - 1] == b;\n\n    // Show isPath\n    forall i | 0 <= i < |path|\n      ensures path[i] in g.nodes\n    {\n      if i == 0 { assert path[i] == a; }\n      else { assert path[i] == b; }\n    }\n\n    forall i | 0 <= i < |path| - 1\n      ensures hasEdge(g, path[i], path[i+1])\n    {\n      assert i == 0;\n      assert path[i] == a && path[i+1] == b;\n    }\n\n    assert isPath(g, path);\n  }\n}\n\nlemma PathOfLengthTwo(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n  requires isPath(g, path)\n  requires |path| == 2\n  ensures path[0] in g.nodes && path[1] in g.nodes\n  ensures hasEdge(g, path[0], path[1])\n{\n  assert 0 <= 0 < |path|;\n  assert path[0] in g.nodes;\n  assert 0 <= 1 < |path|;\n  assert path[1] in g.nodes;\n  assert 0 <= 0 < |path| - 1;\n  assert hasEdge(g, path[0], path[1]);\n}\n\nlemma TreeNoCycle(g: Graph)\n  requires validGraph(g)\n  requires isTree(g)\n  ensures isAcyclic(g)\n{\n  // By definition of isTree\n}\n\nlemma EmptyGraphAcyclic(g: Graph)\n  requires validGraph(g)\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  if hasCycle(g) {\n    var path :| isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1];\n    assert |path| >= 2;\n    assert hasEdge(g, path[0], path[1]);\n    \n/*[CODE HERE]*/\n    assert false;\n  }\n}\n\nlemma SingleNodeAcyclic(g: Graph)\n  requires validGraph(g)\n  requires |g.nodes| == 1\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  EmptyGraphAcyclic(g);\n}\n\nlemma ValidGraphSubgraph(g: Graph, removed: Node)\n  requires validGraph(g)\n  requires removed in g.nodes\n  ensures validGraph(Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed))\n{\n  var g' := Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed);\n  forall e | e in g'.edges\n    ensures e.0 in g'.nodes && e.1 in g'.nodes\n  {\n    assert e in g.edges;\n    assert e.0 != removed && e.1 != removed;\n    assert e.0 in g.nodes && e.1 in g.nodes;\n    assert e.0 in g'.nodes && e.1 in g'.nodes;\n  }\n}", "output": "assert (path[0], path[1]) in g.edges;"}, {"id": "example_EmptyGraphAcyclic_2", "type": "assert", "program": "// Graph operations: path, reachable, cycle detection\n\ntype Node = nat\n\ndatatype Graph = Graph(nodes: set<Node>, edges: set<(Node, Node)>)\n\npredicate {:spec} validGraph(g: Graph)\n{\n  forall e :: e in g.edges ==> e.0 in g.nodes && e.1 in g.nodes\n}\n\npredicate {:spec} hasEdge(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n{\n  (from, to) in g.edges\n}\n\nfunction {:spec} neighbors(g: Graph, n: Node): set<Node>\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  set m | m in g.nodes && (n, m) in g.edges\n}\n\npredicate {:spec} isPath(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n{\n  |path| > 0 &&\n  (forall i :: 0 <= i < |path| ==> path[i] in g.nodes) &&\n  (forall i :: 0 <= i < |path| - 1 ==> hasEdge(g, path[i], path[i+1]))\n}\n\nghost predicate {:spec} reachable(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n{\n  exists path :: isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to\n}\n\nghost predicate {:spec} hasCycle(g: Graph)\n  requires validGraph(g)\n{\n  exists path :: isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1]\n}\n\nghost predicate {:spec} isAcyclic(g: Graph)\n  requires validGraph(g)\n{\n  !hasCycle(g)\n}\n\nghost predicate {:spec} isTree(g: Graph)\n  requires validGraph(g)\n{\n  isAcyclic(g) &&\n  |g.edges| == |g.nodes| - 1 &&\n  forall n, m :: n in g.nodes && m in g.nodes && n != m ==> reachable(g, n, m)\n}\n\nfunction {:spec} inDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |set m | m in g.nodes && (m, n) in g.edges|\n}\n\nfunction {:spec} outDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |neighbors(g, n)|\n}\n\nghost predicate {:spec} isConnected(g: Graph)\n  requires validGraph(g)\n{\n  forall n, m :: n in g.nodes && m in g.nodes ==> reachable(g, n, m)\n}\n\n// Simplified version without recursion\nghost function {:spec} graphDistance(g: Graph, from: Node, to: Node): nat\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n  requires reachable(g, from, to)\n{\n  var path :| isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to;\n  |path| - 1\n}\n\nlemma SelfReachable(g: Graph, n: Node)\n  requires validGraph(g)\n  requires n in g.nodes\n  ensures reachable(g, n, n)\n{\n  var path := [n];\n  assert |path| == 1;\n  assert |path| >= 1;\n  assert path[0] == n;\n  assert path[|path| - 1] == n;\n\n  // Show isPath\n  forall i | 0 <= i < |path|\n    ensures path[i] in g.nodes\n  {\n    assert path[i] == n;\n  }\n\n  forall i | 0 <= i < |path| - 1\n    ensures hasEdge(g, path[i], path[i+1])\n  {\n    assert false;  // No such i exists since |path| == 1\n  }\n\n  assert isPath(g, path);\n}\n\nlemma DirectEdgeReachable(g: Graph, a: Node, b: Node)\n  requires validGraph(g)\n  requires a in g.nodes && b in g.nodes\n  requires hasEdge(g, a, b)\n  ensures reachable(g, a, b)\n{\n  assert b in neighbors(g, a);\n  if a == b {\n    SelfReachable(g, a);\n  } else {\n    var path := [a, b];\n    assert |path| == 2;\n    assert |path| >= 1;\n    assert path[0] == a;\n    assert path[|path| - 1] == b;\n\n    // Show isPath\n    forall i | 0 <= i < |path|\n      ensures path[i] in g.nodes\n    {\n      if i == 0 { assert path[i] == a; }\n      else { assert path[i] == b; }\n    }\n\n    forall i | 0 <= i < |path| - 1\n      ensures hasEdge(g, path[i], path[i+1])\n    {\n      assert i == 0;\n      assert path[i] == a && path[i+1] == b;\n    }\n\n    assert isPath(g, path);\n  }\n}\n\nlemma PathOfLengthTwo(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n  requires isPath(g, path)\n  requires |path| == 2\n  ensures path[0] in g.nodes && path[1] in g.nodes\n  ensures hasEdge(g, path[0], path[1])\n{\n  assert 0 <= 0 < |path|;\n  assert path[0] in g.nodes;\n  assert 0 <= 1 < |path|;\n  assert path[1] in g.nodes;\n  assert 0 <= 0 < |path| - 1;\n  assert hasEdge(g, path[0], path[1]);\n}\n\nlemma TreeNoCycle(g: Graph)\n  requires validGraph(g)\n  requires isTree(g)\n  ensures isAcyclic(g)\n{\n  // By definition of isTree\n}\n\nlemma EmptyGraphAcyclic(g: Graph)\n  requires validGraph(g)\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  if hasCycle(g) {\n    var path :| isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1];\n    assert |path| >= 2;\n    \n/*[CODE HERE]*/\n    assert (path[0], path[1]) in g.edges;\n    assert false;\n  }\n}\n\nlemma SingleNodeAcyclic(g: Graph)\n  requires validGraph(g)\n  requires |g.nodes| == 1\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  EmptyGraphAcyclic(g);\n}\n\nlemma ValidGraphSubgraph(g: Graph, removed: Node)\n  requires validGraph(g)\n  requires removed in g.nodes\n  ensures validGraph(Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed))\n{\n  var g' := Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed);\n  forall e | e in g'.edges\n    ensures e.0 in g'.nodes && e.1 in g'.nodes\n  {\n    assert e in g.edges;\n    assert e.0 != removed && e.1 != removed;\n    assert e.0 in g.nodes && e.1 in g.nodes;\n    assert e.0 in g'.nodes && e.1 in g'.nodes;\n  }\n}", "output": "assert hasEdge(g, path[0], path[1]);"}, {"id": "example_EmptyGraphAcyclic_3", "type": "assert", "program": "// Graph operations: path, reachable, cycle detection\n\ntype Node = nat\n\ndatatype Graph = Graph(nodes: set<Node>, edges: set<(Node, Node)>)\n\npredicate {:spec} validGraph(g: Graph)\n{\n  forall e :: e in g.edges ==> e.0 in g.nodes && e.1 in g.nodes\n}\n\npredicate {:spec} hasEdge(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n{\n  (from, to) in g.edges\n}\n\nfunction {:spec} neighbors(g: Graph, n: Node): set<Node>\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  set m | m in g.nodes && (n, m) in g.edges\n}\n\npredicate {:spec} isPath(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n{\n  |path| > 0 &&\n  (forall i :: 0 <= i < |path| ==> path[i] in g.nodes) &&\n  (forall i :: 0 <= i < |path| - 1 ==> hasEdge(g, path[i], path[i+1]))\n}\n\nghost predicate {:spec} reachable(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n{\n  exists path :: isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to\n}\n\nghost predicate {:spec} hasCycle(g: Graph)\n  requires validGraph(g)\n{\n  exists path :: isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1]\n}\n\nghost predicate {:spec} isAcyclic(g: Graph)\n  requires validGraph(g)\n{\n  !hasCycle(g)\n}\n\nghost predicate {:spec} isTree(g: Graph)\n  requires validGraph(g)\n{\n  isAcyclic(g) &&\n  |g.edges| == |g.nodes| - 1 &&\n  forall n, m :: n in g.nodes && m in g.nodes && n != m ==> reachable(g, n, m)\n}\n\nfunction {:spec} inDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |set m | m in g.nodes && (m, n) in g.edges|\n}\n\nfunction {:spec} outDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |neighbors(g, n)|\n}\n\nghost predicate {:spec} isConnected(g: Graph)\n  requires validGraph(g)\n{\n  forall n, m :: n in g.nodes && m in g.nodes ==> reachable(g, n, m)\n}\n\n// Simplified version without recursion\nghost function {:spec} graphDistance(g: Graph, from: Node, to: Node): nat\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n  requires reachable(g, from, to)\n{\n  var path :| isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to;\n  |path| - 1\n}\n\nlemma SelfReachable(g: Graph, n: Node)\n  requires validGraph(g)\n  requires n in g.nodes\n  ensures reachable(g, n, n)\n{\n  var path := [n];\n  assert |path| == 1;\n  assert |path| >= 1;\n  assert path[0] == n;\n  assert path[|path| - 1] == n;\n\n  // Show isPath\n  forall i | 0 <= i < |path|\n    ensures path[i] in g.nodes\n  {\n    assert path[i] == n;\n  }\n\n  forall i | 0 <= i < |path| - 1\n    ensures hasEdge(g, path[i], path[i+1])\n  {\n    assert false;  // No such i exists since |path| == 1\n  }\n\n  assert isPath(g, path);\n}\n\nlemma DirectEdgeReachable(g: Graph, a: Node, b: Node)\n  requires validGraph(g)\n  requires a in g.nodes && b in g.nodes\n  requires hasEdge(g, a, b)\n  ensures reachable(g, a, b)\n{\n  assert b in neighbors(g, a);\n  if a == b {\n    SelfReachable(g, a);\n  } else {\n    var path := [a, b];\n    assert |path| == 2;\n    assert |path| >= 1;\n    assert path[0] == a;\n    assert path[|path| - 1] == b;\n\n    // Show isPath\n    forall i | 0 <= i < |path|\n      ensures path[i] in g.nodes\n    {\n      if i == 0 { assert path[i] == a; }\n      else { assert path[i] == b; }\n    }\n\n    forall i | 0 <= i < |path| - 1\n      ensures hasEdge(g, path[i], path[i+1])\n    {\n      assert i == 0;\n      assert path[i] == a && path[i+1] == b;\n    }\n\n    assert isPath(g, path);\n  }\n}\n\nlemma PathOfLengthTwo(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n  requires isPath(g, path)\n  requires |path| == 2\n  ensures path[0] in g.nodes && path[1] in g.nodes\n  ensures hasEdge(g, path[0], path[1])\n{\n  assert 0 <= 0 < |path|;\n  assert path[0] in g.nodes;\n  assert 0 <= 1 < |path|;\n  assert path[1] in g.nodes;\n  assert 0 <= 0 < |path| - 1;\n  assert hasEdge(g, path[0], path[1]);\n}\n\nlemma TreeNoCycle(g: Graph)\n  requires validGraph(g)\n  requires isTree(g)\n  ensures isAcyclic(g)\n{\n  // By definition of isTree\n}\n\nlemma EmptyGraphAcyclic(g: Graph)\n  requires validGraph(g)\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  if hasCycle(g) {\n    var path :| isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1];\n    \n/*[CODE HERE]*/\n    assert hasEdge(g, path[0], path[1]);\n    assert (path[0], path[1]) in g.edges;\n    assert false;\n  }\n}\n\nlemma SingleNodeAcyclic(g: Graph)\n  requires validGraph(g)\n  requires |g.nodes| == 1\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  EmptyGraphAcyclic(g);\n}\n\nlemma ValidGraphSubgraph(g: Graph, removed: Node)\n  requires validGraph(g)\n  requires removed in g.nodes\n  ensures validGraph(Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed))\n{\n  var g' := Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed);\n  forall e | e in g'.edges\n    ensures e.0 in g'.nodes && e.1 in g'.nodes\n  {\n    assert e in g.edges;\n    assert e.0 != removed && e.1 != removed;\n    assert e.0 in g.nodes && e.1 in g.nodes;\n    assert e.0 in g'.nodes && e.1 in g'.nodes;\n  }\n}", "output": "assert |path| >= 2;"}, {"id": "example_SingleNodeAcyclic_0", "type": "call", "program": "// Graph operations: path, reachable, cycle detection\n\ntype Node = nat\n\ndatatype Graph = Graph(nodes: set<Node>, edges: set<(Node, Node)>)\n\npredicate {:spec} validGraph(g: Graph)\n{\n  forall e :: e in g.edges ==> e.0 in g.nodes && e.1 in g.nodes\n}\n\npredicate {:spec} hasEdge(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n{\n  (from, to) in g.edges\n}\n\nfunction {:spec} neighbors(g: Graph, n: Node): set<Node>\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  set m | m in g.nodes && (n, m) in g.edges\n}\n\npredicate {:spec} isPath(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n{\n  |path| > 0 &&\n  (forall i :: 0 <= i < |path| ==> path[i] in g.nodes) &&\n  (forall i :: 0 <= i < |path| - 1 ==> hasEdge(g, path[i], path[i+1]))\n}\n\nghost predicate {:spec} reachable(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n{\n  exists path :: isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to\n}\n\nghost predicate {:spec} hasCycle(g: Graph)\n  requires validGraph(g)\n{\n  exists path :: isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1]\n}\n\nghost predicate {:spec} isAcyclic(g: Graph)\n  requires validGraph(g)\n{\n  !hasCycle(g)\n}\n\nghost predicate {:spec} isTree(g: Graph)\n  requires validGraph(g)\n{\n  isAcyclic(g) &&\n  |g.edges| == |g.nodes| - 1 &&\n  forall n, m :: n in g.nodes && m in g.nodes && n != m ==> reachable(g, n, m)\n}\n\nfunction {:spec} inDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |set m | m in g.nodes && (m, n) in g.edges|\n}\n\nfunction {:spec} outDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |neighbors(g, n)|\n}\n\nghost predicate {:spec} isConnected(g: Graph)\n  requires validGraph(g)\n{\n  forall n, m :: n in g.nodes && m in g.nodes ==> reachable(g, n, m)\n}\n\n// Simplified version without recursion\nghost function {:spec} graphDistance(g: Graph, from: Node, to: Node): nat\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n  requires reachable(g, from, to)\n{\n  var path :| isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to;\n  |path| - 1\n}\n\nlemma SelfReachable(g: Graph, n: Node)\n  requires validGraph(g)\n  requires n in g.nodes\n  ensures reachable(g, n, n)\n{\n  var path := [n];\n  assert |path| == 1;\n  assert |path| >= 1;\n  assert path[0] == n;\n  assert path[|path| - 1] == n;\n\n  // Show isPath\n  forall i | 0 <= i < |path|\n    ensures path[i] in g.nodes\n  {\n    assert path[i] == n;\n  }\n\n  forall i | 0 <= i < |path| - 1\n    ensures hasEdge(g, path[i], path[i+1])\n  {\n    assert false;  // No such i exists since |path| == 1\n  }\n\n  assert isPath(g, path);\n}\n\nlemma DirectEdgeReachable(g: Graph, a: Node, b: Node)\n  requires validGraph(g)\n  requires a in g.nodes && b in g.nodes\n  requires hasEdge(g, a, b)\n  ensures reachable(g, a, b)\n{\n  assert b in neighbors(g, a);\n  if a == b {\n    SelfReachable(g, a);\n  } else {\n    var path := [a, b];\n    assert |path| == 2;\n    assert |path| >= 1;\n    assert path[0] == a;\n    assert path[|path| - 1] == b;\n\n    // Show isPath\n    forall i | 0 <= i < |path|\n      ensures path[i] in g.nodes\n    {\n      if i == 0 { assert path[i] == a; }\n      else { assert path[i] == b; }\n    }\n\n    forall i | 0 <= i < |path| - 1\n      ensures hasEdge(g, path[i], path[i+1])\n    {\n      assert i == 0;\n      assert path[i] == a && path[i+1] == b;\n    }\n\n    assert isPath(g, path);\n  }\n}\n\nlemma PathOfLengthTwo(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n  requires isPath(g, path)\n  requires |path| == 2\n  ensures path[0] in g.nodes && path[1] in g.nodes\n  ensures hasEdge(g, path[0], path[1])\n{\n  assert 0 <= 0 < |path|;\n  assert path[0] in g.nodes;\n  assert 0 <= 1 < |path|;\n  assert path[1] in g.nodes;\n  assert 0 <= 0 < |path| - 1;\n  assert hasEdge(g, path[0], path[1]);\n}\n\nlemma TreeNoCycle(g: Graph)\n  requires validGraph(g)\n  requires isTree(g)\n  ensures isAcyclic(g)\n{\n  // By definition of isTree\n}\n\nlemma EmptyGraphAcyclic(g: Graph)\n  requires validGraph(g)\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  if hasCycle(g) {\n    var path :| isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1];\n    assert |path| >= 2;\n    assert hasEdge(g, path[0], path[1]);\n    assert (path[0], path[1]) in g.edges;\n    assert false;\n  }\n}\n\nlemma SingleNodeAcyclic(g: Graph)\n  requires validGraph(g)\n  requires |g.nodes| == 1\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  \n/*[CODE HERE]*/\n}\n\nlemma ValidGraphSubgraph(g: Graph, removed: Node)\n  requires validGraph(g)\n  requires removed in g.nodes\n  ensures validGraph(Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed))\n{\n  var g' := Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed);\n  forall e | e in g'.edges\n    ensures e.0 in g'.nodes && e.1 in g'.nodes\n  {\n    assert e in g.edges;\n    assert e.0 != removed && e.1 != removed;\n    assert e.0 in g.nodes && e.1 in g.nodes;\n    assert e.0 in g'.nodes && e.1 in g'.nodes;\n  }\n}", "output": "EmptyGraphAcyclic(g);"}, {"id": "example_ValidGraphSubgraph_0", "type": "assert", "program": "// Graph operations: path, reachable, cycle detection\n\ntype Node = nat\n\ndatatype Graph = Graph(nodes: set<Node>, edges: set<(Node, Node)>)\n\npredicate {:spec} validGraph(g: Graph)\n{\n  forall e :: e in g.edges ==> e.0 in g.nodes && e.1 in g.nodes\n}\n\npredicate {:spec} hasEdge(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n{\n  (from, to) in g.edges\n}\n\nfunction {:spec} neighbors(g: Graph, n: Node): set<Node>\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  set m | m in g.nodes && (n, m) in g.edges\n}\n\npredicate {:spec} isPath(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n{\n  |path| > 0 &&\n  (forall i :: 0 <= i < |path| ==> path[i] in g.nodes) &&\n  (forall i :: 0 <= i < |path| - 1 ==> hasEdge(g, path[i], path[i+1]))\n}\n\nghost predicate {:spec} reachable(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n{\n  exists path :: isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to\n}\n\nghost predicate {:spec} hasCycle(g: Graph)\n  requires validGraph(g)\n{\n  exists path :: isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1]\n}\n\nghost predicate {:spec} isAcyclic(g: Graph)\n  requires validGraph(g)\n{\n  !hasCycle(g)\n}\n\nghost predicate {:spec} isTree(g: Graph)\n  requires validGraph(g)\n{\n  isAcyclic(g) &&\n  |g.edges| == |g.nodes| - 1 &&\n  forall n, m :: n in g.nodes && m in g.nodes && n != m ==> reachable(g, n, m)\n}\n\nfunction {:spec} inDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |set m | m in g.nodes && (m, n) in g.edges|\n}\n\nfunction {:spec} outDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |neighbors(g, n)|\n}\n\nghost predicate {:spec} isConnected(g: Graph)\n  requires validGraph(g)\n{\n  forall n, m :: n in g.nodes && m in g.nodes ==> reachable(g, n, m)\n}\n\n// Simplified version without recursion\nghost function {:spec} graphDistance(g: Graph, from: Node, to: Node): nat\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n  requires reachable(g, from, to)\n{\n  var path :| isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to;\n  |path| - 1\n}\n\nlemma SelfReachable(g: Graph, n: Node)\n  requires validGraph(g)\n  requires n in g.nodes\n  ensures reachable(g, n, n)\n{\n  var path := [n];\n  assert |path| == 1;\n  assert |path| >= 1;\n  assert path[0] == n;\n  assert path[|path| - 1] == n;\n\n  // Show isPath\n  forall i | 0 <= i < |path|\n    ensures path[i] in g.nodes\n  {\n    assert path[i] == n;\n  }\n\n  forall i | 0 <= i < |path| - 1\n    ensures hasEdge(g, path[i], path[i+1])\n  {\n    assert false;  // No such i exists since |path| == 1\n  }\n\n  assert isPath(g, path);\n}\n\nlemma DirectEdgeReachable(g: Graph, a: Node, b: Node)\n  requires validGraph(g)\n  requires a in g.nodes && b in g.nodes\n  requires hasEdge(g, a, b)\n  ensures reachable(g, a, b)\n{\n  assert b in neighbors(g, a);\n  if a == b {\n    SelfReachable(g, a);\n  } else {\n    var path := [a, b];\n    assert |path| == 2;\n    assert |path| >= 1;\n    assert path[0] == a;\n    assert path[|path| - 1] == b;\n\n    // Show isPath\n    forall i | 0 <= i < |path|\n      ensures path[i] in g.nodes\n    {\n      if i == 0 { assert path[i] == a; }\n      else { assert path[i] == b; }\n    }\n\n    forall i | 0 <= i < |path| - 1\n      ensures hasEdge(g, path[i], path[i+1])\n    {\n      assert i == 0;\n      assert path[i] == a && path[i+1] == b;\n    }\n\n    assert isPath(g, path);\n  }\n}\n\nlemma PathOfLengthTwo(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n  requires isPath(g, path)\n  requires |path| == 2\n  ensures path[0] in g.nodes && path[1] in g.nodes\n  ensures hasEdge(g, path[0], path[1])\n{\n  assert 0 <= 0 < |path|;\n  assert path[0] in g.nodes;\n  assert 0 <= 1 < |path|;\n  assert path[1] in g.nodes;\n  assert 0 <= 0 < |path| - 1;\n  assert hasEdge(g, path[0], path[1]);\n}\n\nlemma TreeNoCycle(g: Graph)\n  requires validGraph(g)\n  requires isTree(g)\n  ensures isAcyclic(g)\n{\n  // By definition of isTree\n}\n\nlemma EmptyGraphAcyclic(g: Graph)\n  requires validGraph(g)\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  if hasCycle(g) {\n    var path :| isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1];\n    assert |path| >= 2;\n    assert hasEdge(g, path[0], path[1]);\n    assert (path[0], path[1]) in g.edges;\n    assert false;\n  }\n}\n\nlemma SingleNodeAcyclic(g: Graph)\n  requires validGraph(g)\n  requires |g.nodes| == 1\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  EmptyGraphAcyclic(g);\n}\n\nlemma ValidGraphSubgraph(g: Graph, removed: Node)\n  requires validGraph(g)\n  requires removed in g.nodes\n  ensures validGraph(Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed))\n{\n  var g' := Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed);\n  forall e | e in g'.edges\n    ensures e.0 in g'.nodes && e.1 in g'.nodes\n  {\n    assert e in g.edges;\n    assert e.0 != removed && e.1 != removed;\n    assert e.0 in g.nodes && e.1 in g.nodes;\n    \n/*[CODE HERE]*/\n  }\n}", "output": "assert e.0 in g'.nodes && e.1 in g'.nodes;"}, {"id": "example_ValidGraphSubgraph_1", "type": "assert", "program": "// Graph operations: path, reachable, cycle detection\n\ntype Node = nat\n\ndatatype Graph = Graph(nodes: set<Node>, edges: set<(Node, Node)>)\n\npredicate {:spec} validGraph(g: Graph)\n{\n  forall e :: e in g.edges ==> e.0 in g.nodes && e.1 in g.nodes\n}\n\npredicate {:spec} hasEdge(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n{\n  (from, to) in g.edges\n}\n\nfunction {:spec} neighbors(g: Graph, n: Node): set<Node>\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  set m | m in g.nodes && (n, m) in g.edges\n}\n\npredicate {:spec} isPath(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n{\n  |path| > 0 &&\n  (forall i :: 0 <= i < |path| ==> path[i] in g.nodes) &&\n  (forall i :: 0 <= i < |path| - 1 ==> hasEdge(g, path[i], path[i+1]))\n}\n\nghost predicate {:spec} reachable(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n{\n  exists path :: isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to\n}\n\nghost predicate {:spec} hasCycle(g: Graph)\n  requires validGraph(g)\n{\n  exists path :: isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1]\n}\n\nghost predicate {:spec} isAcyclic(g: Graph)\n  requires validGraph(g)\n{\n  !hasCycle(g)\n}\n\nghost predicate {:spec} isTree(g: Graph)\n  requires validGraph(g)\n{\n  isAcyclic(g) &&\n  |g.edges| == |g.nodes| - 1 &&\n  forall n, m :: n in g.nodes && m in g.nodes && n != m ==> reachable(g, n, m)\n}\n\nfunction {:spec} inDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |set m | m in g.nodes && (m, n) in g.edges|\n}\n\nfunction {:spec} outDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |neighbors(g, n)|\n}\n\nghost predicate {:spec} isConnected(g: Graph)\n  requires validGraph(g)\n{\n  forall n, m :: n in g.nodes && m in g.nodes ==> reachable(g, n, m)\n}\n\n// Simplified version without recursion\nghost function {:spec} graphDistance(g: Graph, from: Node, to: Node): nat\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n  requires reachable(g, from, to)\n{\n  var path :| isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to;\n  |path| - 1\n}\n\nlemma SelfReachable(g: Graph, n: Node)\n  requires validGraph(g)\n  requires n in g.nodes\n  ensures reachable(g, n, n)\n{\n  var path := [n];\n  assert |path| == 1;\n  assert |path| >= 1;\n  assert path[0] == n;\n  assert path[|path| - 1] == n;\n\n  // Show isPath\n  forall i | 0 <= i < |path|\n    ensures path[i] in g.nodes\n  {\n    assert path[i] == n;\n  }\n\n  forall i | 0 <= i < |path| - 1\n    ensures hasEdge(g, path[i], path[i+1])\n  {\n    assert false;  // No such i exists since |path| == 1\n  }\n\n  assert isPath(g, path);\n}\n\nlemma DirectEdgeReachable(g: Graph, a: Node, b: Node)\n  requires validGraph(g)\n  requires a in g.nodes && b in g.nodes\n  requires hasEdge(g, a, b)\n  ensures reachable(g, a, b)\n{\n  assert b in neighbors(g, a);\n  if a == b {\n    SelfReachable(g, a);\n  } else {\n    var path := [a, b];\n    assert |path| == 2;\n    assert |path| >= 1;\n    assert path[0] == a;\n    assert path[|path| - 1] == b;\n\n    // Show isPath\n    forall i | 0 <= i < |path|\n      ensures path[i] in g.nodes\n    {\n      if i == 0 { assert path[i] == a; }\n      else { assert path[i] == b; }\n    }\n\n    forall i | 0 <= i < |path| - 1\n      ensures hasEdge(g, path[i], path[i+1])\n    {\n      assert i == 0;\n      assert path[i] == a && path[i+1] == b;\n    }\n\n    assert isPath(g, path);\n  }\n}\n\nlemma PathOfLengthTwo(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n  requires isPath(g, path)\n  requires |path| == 2\n  ensures path[0] in g.nodes && path[1] in g.nodes\n  ensures hasEdge(g, path[0], path[1])\n{\n  assert 0 <= 0 < |path|;\n  assert path[0] in g.nodes;\n  assert 0 <= 1 < |path|;\n  assert path[1] in g.nodes;\n  assert 0 <= 0 < |path| - 1;\n  assert hasEdge(g, path[0], path[1]);\n}\n\nlemma TreeNoCycle(g: Graph)\n  requires validGraph(g)\n  requires isTree(g)\n  ensures isAcyclic(g)\n{\n  // By definition of isTree\n}\n\nlemma EmptyGraphAcyclic(g: Graph)\n  requires validGraph(g)\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  if hasCycle(g) {\n    var path :| isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1];\n    assert |path| >= 2;\n    assert hasEdge(g, path[0], path[1]);\n    assert (path[0], path[1]) in g.edges;\n    assert false;\n  }\n}\n\nlemma SingleNodeAcyclic(g: Graph)\n  requires validGraph(g)\n  requires |g.nodes| == 1\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  EmptyGraphAcyclic(g);\n}\n\nlemma ValidGraphSubgraph(g: Graph, removed: Node)\n  requires validGraph(g)\n  requires removed in g.nodes\n  ensures validGraph(Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed))\n{\n  var g' := Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed);\n  forall e | e in g'.edges\n    ensures e.0 in g'.nodes && e.1 in g'.nodes\n  {\n    assert e in g.edges;\n    assert e.0 != removed && e.1 != removed;\n    \n/*[CODE HERE]*/\n    assert e.0 in g'.nodes && e.1 in g'.nodes;\n  }\n}", "output": "assert e.0 in g.nodes && e.1 in g.nodes;"}, {"id": "example_ValidGraphSubgraph_2", "type": "assert", "program": "// Graph operations: path, reachable, cycle detection\n\ntype Node = nat\n\ndatatype Graph = Graph(nodes: set<Node>, edges: set<(Node, Node)>)\n\npredicate {:spec} validGraph(g: Graph)\n{\n  forall e :: e in g.edges ==> e.0 in g.nodes && e.1 in g.nodes\n}\n\npredicate {:spec} hasEdge(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n{\n  (from, to) in g.edges\n}\n\nfunction {:spec} neighbors(g: Graph, n: Node): set<Node>\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  set m | m in g.nodes && (n, m) in g.edges\n}\n\npredicate {:spec} isPath(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n{\n  |path| > 0 &&\n  (forall i :: 0 <= i < |path| ==> path[i] in g.nodes) &&\n  (forall i :: 0 <= i < |path| - 1 ==> hasEdge(g, path[i], path[i+1]))\n}\n\nghost predicate {:spec} reachable(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n{\n  exists path :: isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to\n}\n\nghost predicate {:spec} hasCycle(g: Graph)\n  requires validGraph(g)\n{\n  exists path :: isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1]\n}\n\nghost predicate {:spec} isAcyclic(g: Graph)\n  requires validGraph(g)\n{\n  !hasCycle(g)\n}\n\nghost predicate {:spec} isTree(g: Graph)\n  requires validGraph(g)\n{\n  isAcyclic(g) &&\n  |g.edges| == |g.nodes| - 1 &&\n  forall n, m :: n in g.nodes && m in g.nodes && n != m ==> reachable(g, n, m)\n}\n\nfunction {:spec} inDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |set m | m in g.nodes && (m, n) in g.edges|\n}\n\nfunction {:spec} outDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |neighbors(g, n)|\n}\n\nghost predicate {:spec} isConnected(g: Graph)\n  requires validGraph(g)\n{\n  forall n, m :: n in g.nodes && m in g.nodes ==> reachable(g, n, m)\n}\n\n// Simplified version without recursion\nghost function {:spec} graphDistance(g: Graph, from: Node, to: Node): nat\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n  requires reachable(g, from, to)\n{\n  var path :| isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to;\n  |path| - 1\n}\n\nlemma SelfReachable(g: Graph, n: Node)\n  requires validGraph(g)\n  requires n in g.nodes\n  ensures reachable(g, n, n)\n{\n  var path := [n];\n  assert |path| == 1;\n  assert |path| >= 1;\n  assert path[0] == n;\n  assert path[|path| - 1] == n;\n\n  // Show isPath\n  forall i | 0 <= i < |path|\n    ensures path[i] in g.nodes\n  {\n    assert path[i] == n;\n  }\n\n  forall i | 0 <= i < |path| - 1\n    ensures hasEdge(g, path[i], path[i+1])\n  {\n    assert false;  // No such i exists since |path| == 1\n  }\n\n  assert isPath(g, path);\n}\n\nlemma DirectEdgeReachable(g: Graph, a: Node, b: Node)\n  requires validGraph(g)\n  requires a in g.nodes && b in g.nodes\n  requires hasEdge(g, a, b)\n  ensures reachable(g, a, b)\n{\n  assert b in neighbors(g, a);\n  if a == b {\n    SelfReachable(g, a);\n  } else {\n    var path := [a, b];\n    assert |path| == 2;\n    assert |path| >= 1;\n    assert path[0] == a;\n    assert path[|path| - 1] == b;\n\n    // Show isPath\n    forall i | 0 <= i < |path|\n      ensures path[i] in g.nodes\n    {\n      if i == 0 { assert path[i] == a; }\n      else { assert path[i] == b; }\n    }\n\n    forall i | 0 <= i < |path| - 1\n      ensures hasEdge(g, path[i], path[i+1])\n    {\n      assert i == 0;\n      assert path[i] == a && path[i+1] == b;\n    }\n\n    assert isPath(g, path);\n  }\n}\n\nlemma PathOfLengthTwo(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n  requires isPath(g, path)\n  requires |path| == 2\n  ensures path[0] in g.nodes && path[1] in g.nodes\n  ensures hasEdge(g, path[0], path[1])\n{\n  assert 0 <= 0 < |path|;\n  assert path[0] in g.nodes;\n  assert 0 <= 1 < |path|;\n  assert path[1] in g.nodes;\n  assert 0 <= 0 < |path| - 1;\n  assert hasEdge(g, path[0], path[1]);\n}\n\nlemma TreeNoCycle(g: Graph)\n  requires validGraph(g)\n  requires isTree(g)\n  ensures isAcyclic(g)\n{\n  // By definition of isTree\n}\n\nlemma EmptyGraphAcyclic(g: Graph)\n  requires validGraph(g)\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  if hasCycle(g) {\n    var path :| isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1];\n    assert |path| >= 2;\n    assert hasEdge(g, path[0], path[1]);\n    assert (path[0], path[1]) in g.edges;\n    assert false;\n  }\n}\n\nlemma SingleNodeAcyclic(g: Graph)\n  requires validGraph(g)\n  requires |g.nodes| == 1\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  EmptyGraphAcyclic(g);\n}\n\nlemma ValidGraphSubgraph(g: Graph, removed: Node)\n  requires validGraph(g)\n  requires removed in g.nodes\n  ensures validGraph(Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed))\n{\n  var g' := Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed);\n  forall e | e in g'.edges\n    ensures e.0 in g'.nodes && e.1 in g'.nodes\n  {\n    assert e in g.edges;\n    \n/*[CODE HERE]*/\n    assert e.0 in g.nodes && e.1 in g.nodes;\n    assert e.0 in g'.nodes && e.1 in g'.nodes;\n  }\n}", "output": "assert e.0 != removed && e.1 != removed;"}, {"id": "example_ValidGraphSubgraph_3", "type": "assert", "program": "// Graph operations: path, reachable, cycle detection\n\ntype Node = nat\n\ndatatype Graph = Graph(nodes: set<Node>, edges: set<(Node, Node)>)\n\npredicate {:spec} validGraph(g: Graph)\n{\n  forall e :: e in g.edges ==> e.0 in g.nodes && e.1 in g.nodes\n}\n\npredicate {:spec} hasEdge(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n{\n  (from, to) in g.edges\n}\n\nfunction {:spec} neighbors(g: Graph, n: Node): set<Node>\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  set m | m in g.nodes && (n, m) in g.edges\n}\n\npredicate {:spec} isPath(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n{\n  |path| > 0 &&\n  (forall i :: 0 <= i < |path| ==> path[i] in g.nodes) &&\n  (forall i :: 0 <= i < |path| - 1 ==> hasEdge(g, path[i], path[i+1]))\n}\n\nghost predicate {:spec} reachable(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n{\n  exists path :: isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to\n}\n\nghost predicate {:spec} hasCycle(g: Graph)\n  requires validGraph(g)\n{\n  exists path :: isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1]\n}\n\nghost predicate {:spec} isAcyclic(g: Graph)\n  requires validGraph(g)\n{\n  !hasCycle(g)\n}\n\nghost predicate {:spec} isTree(g: Graph)\n  requires validGraph(g)\n{\n  isAcyclic(g) &&\n  |g.edges| == |g.nodes| - 1 &&\n  forall n, m :: n in g.nodes && m in g.nodes && n != m ==> reachable(g, n, m)\n}\n\nfunction {:spec} inDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |set m | m in g.nodes && (m, n) in g.edges|\n}\n\nfunction {:spec} outDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |neighbors(g, n)|\n}\n\nghost predicate {:spec} isConnected(g: Graph)\n  requires validGraph(g)\n{\n  forall n, m :: n in g.nodes && m in g.nodes ==> reachable(g, n, m)\n}\n\n// Simplified version without recursion\nghost function {:spec} graphDistance(g: Graph, from: Node, to: Node): nat\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n  requires reachable(g, from, to)\n{\n  var path :| isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to;\n  |path| - 1\n}\n\nlemma SelfReachable(g: Graph, n: Node)\n  requires validGraph(g)\n  requires n in g.nodes\n  ensures reachable(g, n, n)\n{\n  var path := [n];\n  assert |path| == 1;\n  assert |path| >= 1;\n  assert path[0] == n;\n  assert path[|path| - 1] == n;\n\n  // Show isPath\n  forall i | 0 <= i < |path|\n    ensures path[i] in g.nodes\n  {\n    assert path[i] == n;\n  }\n\n  forall i | 0 <= i < |path| - 1\n    ensures hasEdge(g, path[i], path[i+1])\n  {\n    assert false;  // No such i exists since |path| == 1\n  }\n\n  assert isPath(g, path);\n}\n\nlemma DirectEdgeReachable(g: Graph, a: Node, b: Node)\n  requires validGraph(g)\n  requires a in g.nodes && b in g.nodes\n  requires hasEdge(g, a, b)\n  ensures reachable(g, a, b)\n{\n  assert b in neighbors(g, a);\n  if a == b {\n    SelfReachable(g, a);\n  } else {\n    var path := [a, b];\n    assert |path| == 2;\n    assert |path| >= 1;\n    assert path[0] == a;\n    assert path[|path| - 1] == b;\n\n    // Show isPath\n    forall i | 0 <= i < |path|\n      ensures path[i] in g.nodes\n    {\n      if i == 0 { assert path[i] == a; }\n      else { assert path[i] == b; }\n    }\n\n    forall i | 0 <= i < |path| - 1\n      ensures hasEdge(g, path[i], path[i+1])\n    {\n      assert i == 0;\n      assert path[i] == a && path[i+1] == b;\n    }\n\n    assert isPath(g, path);\n  }\n}\n\nlemma PathOfLengthTwo(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n  requires isPath(g, path)\n  requires |path| == 2\n  ensures path[0] in g.nodes && path[1] in g.nodes\n  ensures hasEdge(g, path[0], path[1])\n{\n  assert 0 <= 0 < |path|;\n  assert path[0] in g.nodes;\n  assert 0 <= 1 < |path|;\n  assert path[1] in g.nodes;\n  assert 0 <= 0 < |path| - 1;\n  assert hasEdge(g, path[0], path[1]);\n}\n\nlemma TreeNoCycle(g: Graph)\n  requires validGraph(g)\n  requires isTree(g)\n  ensures isAcyclic(g)\n{\n  // By definition of isTree\n}\n\nlemma EmptyGraphAcyclic(g: Graph)\n  requires validGraph(g)\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  if hasCycle(g) {\n    var path :| isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1];\n    assert |path| >= 2;\n    assert hasEdge(g, path[0], path[1]);\n    assert (path[0], path[1]) in g.edges;\n    assert false;\n  }\n}\n\nlemma SingleNodeAcyclic(g: Graph)\n  requires validGraph(g)\n  requires |g.nodes| == 1\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  EmptyGraphAcyclic(g);\n}\n\nlemma ValidGraphSubgraph(g: Graph, removed: Node)\n  requires validGraph(g)\n  requires removed in g.nodes\n  ensures validGraph(Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed))\n{\n  var g' := Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed);\n  forall e | e in g'.edges\n    ensures e.0 in g'.nodes && e.1 in g'.nodes\n  {\n    \n/*[CODE HERE]*/\n    assert e.0 != removed && e.1 != removed;\n    assert e.0 in g.nodes && e.1 in g.nodes;\n    assert e.0 in g'.nodes && e.1 in g'.nodes;\n  }\n}", "output": "assert e in g.edges;"}, {"id": "example_EmptyHeapIsMinHeap_0", "type": "assert", "program": "// Min-heap operations: insert, extractMin, heapify with heap property\n\ndatatype Heap = Heap(elements: seq<int>)\n\n// Check if heap is empty\npredicate {:spec} heapIsEmpty(h: Heap)\n{\n  |h.elements| == 0\n}\n\n// Get heap size\nfunction {:spec} heapSize(h: Heap): nat\n{\n  |h.elements|\n}\n\n// Parent index in heap\nfunction {:spec} parent(i: nat): nat\n  requires i > 0\n{\n  (i - 1) / 2\n}\n\n// Left child index\nfunction {:spec} leftChild(i: nat): nat\n{\n  2 * i + 1\n}\n\n// Right child index\nfunction {:spec} rightChild(i: nat): nat\n{\n  2 * i + 2\n}\n\n// Check min-heap property\npredicate {:spec} isMinHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] <= h.elements[i]\n}\n\n// Check max-heap property\npredicate {:spec} isMaxHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] >= h.elements[i]\n}\n\n// Get minimum element (root of min-heap)\nfunction {:spec} getMin(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n{\n  h.elements[0]\n}\n\n// Get maximum element (root of max-heap)\nfunction {:spec} getMax(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n{\n  h.elements[0]\n}\n\n// Check if element exists in heap\npredicate {:spec} heapContains(h: Heap, x: int)\n{\n  x in h.elements\n}\n\n// Create empty heap\nfunction {:spec} emptyHeap(): Heap\n{\n  Heap([])\n}\n\n// Create heap from single element\nfunction {:spec} singletonHeap(x: int): Heap\n{\n  Heap([x])\n}\n\n// Swap two elements in sequence\nfunction {:spec} swap(s: seq<int>, i: nat, j: nat): seq<int>\n  requires i < |s| && j < |s|\n{\n  s[i := s[j]][j := s[i]]\n}\n\n// Check if heap is complete binary tree (always true for array representation)\npredicate {:spec} isComplete(h: Heap)\n{\n  true  // Array representation is always complete\n}\n\n// Get height of heap\nfunction {:spec} heapHeight(h: Heap): nat\n{\n  if |h.elements| == 0 then 0\n  else log2Floor(|h.elements|) + 1\n}\n\n// Floor of log base 2\nfunction {:spec} log2Floor(n: nat): nat\n  requires n > 0\n  decreases n\n{\n  if n == 1 then 0\n  else 1 + log2Floor(n / 2)\n}\n\n// Check if index is valid\npredicate {:spec} validIndex(h: Heap, i: nat)\n{\n  i < |h.elements|\n}\n\n// Get all elements at a given level\nfunction {:spec} getLevel(h: Heap, level: nat): seq<int>\n{\n  getLevelHelper(h, level, 0)\n}\n\nfunction getLevelHelper(h: Heap, targetLevel: nat, currentLevel: nat): seq<int>\n  decreases |h.elements| - currentLevel\n{\n  if currentLevel >= |h.elements| || currentLevel >= Power2(targetLevel) then []\n  else if currentLevel >= Power2(targetLevel) - 1 && currentLevel < Power2(targetLevel + 1) - 1 then\n    if currentLevel < |h.elements| then [h.elements[currentLevel]] + getLevelHelper(h, targetLevel, currentLevel + 1)\n    else []\n  else getLevelHelper(h, targetLevel, currentLevel + 1)\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1\n  else 2 * Power2(n - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma EmptyHeapIsMinHeap()\n  ensures isMinHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    \n/*[CODE HERE]*/\n// No such i exists\n  }\n}\n\nlemma EmptyHeapIsMaxHeap()\n  ensures isMaxHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma SingletonIsMinHeap(x: int)\n  ensures isMinHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma SingletonIsMaxHeap(x: int)\n  ensures isMaxHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma MinHeapRootIsMinimum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] <= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MinHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MinHeapPathToRoot(h: Heap, i: nat)\n  requires isMinHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] <= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] <= h.elements[i];\n  } else {\n    assert h.elements[parent(i)] <= h.elements[i];\n    MinHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma MaxHeapRootIsMaximum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] >= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MaxHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MaxHeapPathToRoot(h: Heap, i: nat)\n  requires isMaxHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] >= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] >= h.elements[i];\n  } else {\n    assert h.elements[parent(i)] >= h.elements[i];\n    MaxHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma ParentChildRelation(i: nat)\n  requires i > 0\n  ensures leftChild(parent(i)) == i || rightChild(parent(i)) == i\n  ensures leftChild(parent(i)) == i <==> i % 2 == 1\n  ensures rightChild(parent(i)) == i <==> i % 2 == 0\n{\n  var p := parent(i);\n  assert p == (i - 1) / 2;\n  assert leftChild(p) == 2 * p + 1;\n  assert rightChild(p) == 2 * p + 2;\n\n  if i % 2 == 1 {\n    assert i == 2 * ((i - 1) / 2) + 1;\n    assert leftChild(p) == i;\n  } else {\n    assert i % 2 == 0;\n    assert i == 2 * ((i - 1) / 2) + 2;\n    assert rightChild(p) == i;\n  }\n}\n\nlemma HeapHeightBound(h: Heap)\n  ensures heapHeight(h) <= |h.elements|\n{\n  if |h.elements| == 0 {\n    assert heapHeight(h) == 0;\n  } else {\n    Log2FloorBound(|h.elements|);\n  }\n}\n\nlemma Log2FloorBound(n: nat)\n  requires n > 0\n  ensures log2Floor(n) < n\n  decreases n\n{\n  if n == 1 {\n    assert log2Floor(1) == 0;\n  } else {\n    Log2FloorBound(n / 2);\n    assert log2Floor(n) == 1 + log2Floor(n / 2);\n    assert n / 2 < n;\n  }\n}\n\nlemma SwapPreservesMultiset(s: seq<int>, i: nat, j: nat)\n  requires i < |s| && j < |s|\n  ensures multiset(swap(s, i, j)) == multiset(s)\n{\n  var s' := swap(s, i, j);\n  assert s'[i] == s[j];\n  assert s'[j] == s[i];\n  forall k | 0 <= k < |s| && k != i && k != j\n    ensures s'[k] == s[k]\n  {\n    // Elements other than i and j are unchanged\n  }\n}", "output": "assert false;"}, {"id": "example_EmptyHeapIsMaxHeap_0", "type": "assert", "program": "// Min-heap operations: insert, extractMin, heapify with heap property\n\ndatatype Heap = Heap(elements: seq<int>)\n\n// Check if heap is empty\npredicate {:spec} heapIsEmpty(h: Heap)\n{\n  |h.elements| == 0\n}\n\n// Get heap size\nfunction {:spec} heapSize(h: Heap): nat\n{\n  |h.elements|\n}\n\n// Parent index in heap\nfunction {:spec} parent(i: nat): nat\n  requires i > 0\n{\n  (i - 1) / 2\n}\n\n// Left child index\nfunction {:spec} leftChild(i: nat): nat\n{\n  2 * i + 1\n}\n\n// Right child index\nfunction {:spec} rightChild(i: nat): nat\n{\n  2 * i + 2\n}\n\n// Check min-heap property\npredicate {:spec} isMinHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] <= h.elements[i]\n}\n\n// Check max-heap property\npredicate {:spec} isMaxHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] >= h.elements[i]\n}\n\n// Get minimum element (root of min-heap)\nfunction {:spec} getMin(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n{\n  h.elements[0]\n}\n\n// Get maximum element (root of max-heap)\nfunction {:spec} getMax(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n{\n  h.elements[0]\n}\n\n// Check if element exists in heap\npredicate {:spec} heapContains(h: Heap, x: int)\n{\n  x in h.elements\n}\n\n// Create empty heap\nfunction {:spec} emptyHeap(): Heap\n{\n  Heap([])\n}\n\n// Create heap from single element\nfunction {:spec} singletonHeap(x: int): Heap\n{\n  Heap([x])\n}\n\n// Swap two elements in sequence\nfunction {:spec} swap(s: seq<int>, i: nat, j: nat): seq<int>\n  requires i < |s| && j < |s|\n{\n  s[i := s[j]][j := s[i]]\n}\n\n// Check if heap is complete binary tree (always true for array representation)\npredicate {:spec} isComplete(h: Heap)\n{\n  true  // Array representation is always complete\n}\n\n// Get height of heap\nfunction {:spec} heapHeight(h: Heap): nat\n{\n  if |h.elements| == 0 then 0\n  else log2Floor(|h.elements|) + 1\n}\n\n// Floor of log base 2\nfunction {:spec} log2Floor(n: nat): nat\n  requires n > 0\n  decreases n\n{\n  if n == 1 then 0\n  else 1 + log2Floor(n / 2)\n}\n\n// Check if index is valid\npredicate {:spec} validIndex(h: Heap, i: nat)\n{\n  i < |h.elements|\n}\n\n// Get all elements at a given level\nfunction {:spec} getLevel(h: Heap, level: nat): seq<int>\n{\n  getLevelHelper(h, level, 0)\n}\n\nfunction getLevelHelper(h: Heap, targetLevel: nat, currentLevel: nat): seq<int>\n  decreases |h.elements| - currentLevel\n{\n  if currentLevel >= |h.elements| || currentLevel >= Power2(targetLevel) then []\n  else if currentLevel >= Power2(targetLevel) - 1 && currentLevel < Power2(targetLevel + 1) - 1 then\n    if currentLevel < |h.elements| then [h.elements[currentLevel]] + getLevelHelper(h, targetLevel, currentLevel + 1)\n    else []\n  else getLevelHelper(h, targetLevel, currentLevel + 1)\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1\n  else 2 * Power2(n - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma EmptyHeapIsMinHeap()\n  ensures isMinHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma EmptyHeapIsMaxHeap()\n  ensures isMaxHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    \n/*[CODE HERE]*/\n// No such i exists\n  }\n}\n\nlemma SingletonIsMinHeap(x: int)\n  ensures isMinHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma SingletonIsMaxHeap(x: int)\n  ensures isMaxHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma MinHeapRootIsMinimum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] <= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MinHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MinHeapPathToRoot(h: Heap, i: nat)\n  requires isMinHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] <= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] <= h.elements[i];\n  } else {\n    assert h.elements[parent(i)] <= h.elements[i];\n    MinHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma MaxHeapRootIsMaximum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] >= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MaxHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MaxHeapPathToRoot(h: Heap, i: nat)\n  requires isMaxHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] >= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] >= h.elements[i];\n  } else {\n    assert h.elements[parent(i)] >= h.elements[i];\n    MaxHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma ParentChildRelation(i: nat)\n  requires i > 0\n  ensures leftChild(parent(i)) == i || rightChild(parent(i)) == i\n  ensures leftChild(parent(i)) == i <==> i % 2 == 1\n  ensures rightChild(parent(i)) == i <==> i % 2 == 0\n{\n  var p := parent(i);\n  assert p == (i - 1) / 2;\n  assert leftChild(p) == 2 * p + 1;\n  assert rightChild(p) == 2 * p + 2;\n\n  if i % 2 == 1 {\n    assert i == 2 * ((i - 1) / 2) + 1;\n    assert leftChild(p) == i;\n  } else {\n    assert i % 2 == 0;\n    assert i == 2 * ((i - 1) / 2) + 2;\n    assert rightChild(p) == i;\n  }\n}\n\nlemma HeapHeightBound(h: Heap)\n  ensures heapHeight(h) <= |h.elements|\n{\n  if |h.elements| == 0 {\n    assert heapHeight(h) == 0;\n  } else {\n    Log2FloorBound(|h.elements|);\n  }\n}\n\nlemma Log2FloorBound(n: nat)\n  requires n > 0\n  ensures log2Floor(n) < n\n  decreases n\n{\n  if n == 1 {\n    assert log2Floor(1) == 0;\n  } else {\n    Log2FloorBound(n / 2);\n    assert log2Floor(n) == 1 + log2Floor(n / 2);\n    assert n / 2 < n;\n  }\n}\n\nlemma SwapPreservesMultiset(s: seq<int>, i: nat, j: nat)\n  requires i < |s| && j < |s|\n  ensures multiset(swap(s, i, j)) == multiset(s)\n{\n  var s' := swap(s, i, j);\n  assert s'[i] == s[j];\n  assert s'[j] == s[i];\n  forall k | 0 <= k < |s| && k != i && k != j\n    ensures s'[k] == s[k]\n  {\n    // Elements other than i and j are unchanged\n  }\n}", "output": "assert false;"}, {"id": "example_SingletonIsMinHeap_0", "type": "assert", "program": "// Min-heap operations: insert, extractMin, heapify with heap property\n\ndatatype Heap = Heap(elements: seq<int>)\n\n// Check if heap is empty\npredicate {:spec} heapIsEmpty(h: Heap)\n{\n  |h.elements| == 0\n}\n\n// Get heap size\nfunction {:spec} heapSize(h: Heap): nat\n{\n  |h.elements|\n}\n\n// Parent index in heap\nfunction {:spec} parent(i: nat): nat\n  requires i > 0\n{\n  (i - 1) / 2\n}\n\n// Left child index\nfunction {:spec} leftChild(i: nat): nat\n{\n  2 * i + 1\n}\n\n// Right child index\nfunction {:spec} rightChild(i: nat): nat\n{\n  2 * i + 2\n}\n\n// Check min-heap property\npredicate {:spec} isMinHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] <= h.elements[i]\n}\n\n// Check max-heap property\npredicate {:spec} isMaxHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] >= h.elements[i]\n}\n\n// Get minimum element (root of min-heap)\nfunction {:spec} getMin(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n{\n  h.elements[0]\n}\n\n// Get maximum element (root of max-heap)\nfunction {:spec} getMax(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n{\n  h.elements[0]\n}\n\n// Check if element exists in heap\npredicate {:spec} heapContains(h: Heap, x: int)\n{\n  x in h.elements\n}\n\n// Create empty heap\nfunction {:spec} emptyHeap(): Heap\n{\n  Heap([])\n}\n\n// Create heap from single element\nfunction {:spec} singletonHeap(x: int): Heap\n{\n  Heap([x])\n}\n\n// Swap two elements in sequence\nfunction {:spec} swap(s: seq<int>, i: nat, j: nat): seq<int>\n  requires i < |s| && j < |s|\n{\n  s[i := s[j]][j := s[i]]\n}\n\n// Check if heap is complete binary tree (always true for array representation)\npredicate {:spec} isComplete(h: Heap)\n{\n  true  // Array representation is always complete\n}\n\n// Get height of heap\nfunction {:spec} heapHeight(h: Heap): nat\n{\n  if |h.elements| == 0 then 0\n  else log2Floor(|h.elements|) + 1\n}\n\n// Floor of log base 2\nfunction {:spec} log2Floor(n: nat): nat\n  requires n > 0\n  decreases n\n{\n  if n == 1 then 0\n  else 1 + log2Floor(n / 2)\n}\n\n// Check if index is valid\npredicate {:spec} validIndex(h: Heap, i: nat)\n{\n  i < |h.elements|\n}\n\n// Get all elements at a given level\nfunction {:spec} getLevel(h: Heap, level: nat): seq<int>\n{\n  getLevelHelper(h, level, 0)\n}\n\nfunction getLevelHelper(h: Heap, targetLevel: nat, currentLevel: nat): seq<int>\n  decreases |h.elements| - currentLevel\n{\n  if currentLevel >= |h.elements| || currentLevel >= Power2(targetLevel) then []\n  else if currentLevel >= Power2(targetLevel) - 1 && currentLevel < Power2(targetLevel + 1) - 1 then\n    if currentLevel < |h.elements| then [h.elements[currentLevel]] + getLevelHelper(h, targetLevel, currentLevel + 1)\n    else []\n  else getLevelHelper(h, targetLevel, currentLevel + 1)\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1\n  else 2 * Power2(n - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma EmptyHeapIsMinHeap()\n  ensures isMinHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma EmptyHeapIsMaxHeap()\n  ensures isMaxHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma SingletonIsMinHeap(x: int)\n  ensures isMinHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    \n/*[CODE HERE]*/\n// No such i exists since |h.elements| == 1\n  }\n}\n\nlemma SingletonIsMaxHeap(x: int)\n  ensures isMaxHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma MinHeapRootIsMinimum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] <= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MinHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MinHeapPathToRoot(h: Heap, i: nat)\n  requires isMinHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] <= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] <= h.elements[i];\n  } else {\n    assert h.elements[parent(i)] <= h.elements[i];\n    MinHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma MaxHeapRootIsMaximum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] >= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MaxHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MaxHeapPathToRoot(h: Heap, i: nat)\n  requires isMaxHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] >= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] >= h.elements[i];\n  } else {\n    assert h.elements[parent(i)] >= h.elements[i];\n    MaxHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma ParentChildRelation(i: nat)\n  requires i > 0\n  ensures leftChild(parent(i)) == i || rightChild(parent(i)) == i\n  ensures leftChild(parent(i)) == i <==> i % 2 == 1\n  ensures rightChild(parent(i)) == i <==> i % 2 == 0\n{\n  var p := parent(i);\n  assert p == (i - 1) / 2;\n  assert leftChild(p) == 2 * p + 1;\n  assert rightChild(p) == 2 * p + 2;\n\n  if i % 2 == 1 {\n    assert i == 2 * ((i - 1) / 2) + 1;\n    assert leftChild(p) == i;\n  } else {\n    assert i % 2 == 0;\n    assert i == 2 * ((i - 1) / 2) + 2;\n    assert rightChild(p) == i;\n  }\n}\n\nlemma HeapHeightBound(h: Heap)\n  ensures heapHeight(h) <= |h.elements|\n{\n  if |h.elements| == 0 {\n    assert heapHeight(h) == 0;\n  } else {\n    Log2FloorBound(|h.elements|);\n  }\n}\n\nlemma Log2FloorBound(n: nat)\n  requires n > 0\n  ensures log2Floor(n) < n\n  decreases n\n{\n  if n == 1 {\n    assert log2Floor(1) == 0;\n  } else {\n    Log2FloorBound(n / 2);\n    assert log2Floor(n) == 1 + log2Floor(n / 2);\n    assert n / 2 < n;\n  }\n}\n\nlemma SwapPreservesMultiset(s: seq<int>, i: nat, j: nat)\n  requires i < |s| && j < |s|\n  ensures multiset(swap(s, i, j)) == multiset(s)\n{\n  var s' := swap(s, i, j);\n  assert s'[i] == s[j];\n  assert s'[j] == s[i];\n  forall k | 0 <= k < |s| && k != i && k != j\n    ensures s'[k] == s[k]\n  {\n    // Elements other than i and j are unchanged\n  }\n}", "output": "assert false;"}, {"id": "example_SingletonIsMaxHeap_0", "type": "assert", "program": "// Min-heap operations: insert, extractMin, heapify with heap property\n\ndatatype Heap = Heap(elements: seq<int>)\n\n// Check if heap is empty\npredicate {:spec} heapIsEmpty(h: Heap)\n{\n  |h.elements| == 0\n}\n\n// Get heap size\nfunction {:spec} heapSize(h: Heap): nat\n{\n  |h.elements|\n}\n\n// Parent index in heap\nfunction {:spec} parent(i: nat): nat\n  requires i > 0\n{\n  (i - 1) / 2\n}\n\n// Left child index\nfunction {:spec} leftChild(i: nat): nat\n{\n  2 * i + 1\n}\n\n// Right child index\nfunction {:spec} rightChild(i: nat): nat\n{\n  2 * i + 2\n}\n\n// Check min-heap property\npredicate {:spec} isMinHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] <= h.elements[i]\n}\n\n// Check max-heap property\npredicate {:spec} isMaxHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] >= h.elements[i]\n}\n\n// Get minimum element (root of min-heap)\nfunction {:spec} getMin(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n{\n  h.elements[0]\n}\n\n// Get maximum element (root of max-heap)\nfunction {:spec} getMax(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n{\n  h.elements[0]\n}\n\n// Check if element exists in heap\npredicate {:spec} heapContains(h: Heap, x: int)\n{\n  x in h.elements\n}\n\n// Create empty heap\nfunction {:spec} emptyHeap(): Heap\n{\n  Heap([])\n}\n\n// Create heap from single element\nfunction {:spec} singletonHeap(x: int): Heap\n{\n  Heap([x])\n}\n\n// Swap two elements in sequence\nfunction {:spec} swap(s: seq<int>, i: nat, j: nat): seq<int>\n  requires i < |s| && j < |s|\n{\n  s[i := s[j]][j := s[i]]\n}\n\n// Check if heap is complete binary tree (always true for array representation)\npredicate {:spec} isComplete(h: Heap)\n{\n  true  // Array representation is always complete\n}\n\n// Get height of heap\nfunction {:spec} heapHeight(h: Heap): nat\n{\n  if |h.elements| == 0 then 0\n  else log2Floor(|h.elements|) + 1\n}\n\n// Floor of log base 2\nfunction {:spec} log2Floor(n: nat): nat\n  requires n > 0\n  decreases n\n{\n  if n == 1 then 0\n  else 1 + log2Floor(n / 2)\n}\n\n// Check if index is valid\npredicate {:spec} validIndex(h: Heap, i: nat)\n{\n  i < |h.elements|\n}\n\n// Get all elements at a given level\nfunction {:spec} getLevel(h: Heap, level: nat): seq<int>\n{\n  getLevelHelper(h, level, 0)\n}\n\nfunction getLevelHelper(h: Heap, targetLevel: nat, currentLevel: nat): seq<int>\n  decreases |h.elements| - currentLevel\n{\n  if currentLevel >= |h.elements| || currentLevel >= Power2(targetLevel) then []\n  else if currentLevel >= Power2(targetLevel) - 1 && currentLevel < Power2(targetLevel + 1) - 1 then\n    if currentLevel < |h.elements| then [h.elements[currentLevel]] + getLevelHelper(h, targetLevel, currentLevel + 1)\n    else []\n  else getLevelHelper(h, targetLevel, currentLevel + 1)\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1\n  else 2 * Power2(n - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma EmptyHeapIsMinHeap()\n  ensures isMinHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma EmptyHeapIsMaxHeap()\n  ensures isMaxHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma SingletonIsMinHeap(x: int)\n  ensures isMinHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma SingletonIsMaxHeap(x: int)\n  ensures isMaxHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    \n/*[CODE HERE]*/\n// No such i exists since |h.elements| == 1\n  }\n}\n\nlemma MinHeapRootIsMinimum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] <= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MinHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MinHeapPathToRoot(h: Heap, i: nat)\n  requires isMinHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] <= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] <= h.elements[i];\n  } else {\n    assert h.elements[parent(i)] <= h.elements[i];\n    MinHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma MaxHeapRootIsMaximum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] >= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MaxHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MaxHeapPathToRoot(h: Heap, i: nat)\n  requires isMaxHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] >= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] >= h.elements[i];\n  } else {\n    assert h.elements[parent(i)] >= h.elements[i];\n    MaxHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma ParentChildRelation(i: nat)\n  requires i > 0\n  ensures leftChild(parent(i)) == i || rightChild(parent(i)) == i\n  ensures leftChild(parent(i)) == i <==> i % 2 == 1\n  ensures rightChild(parent(i)) == i <==> i % 2 == 0\n{\n  var p := parent(i);\n  assert p == (i - 1) / 2;\n  assert leftChild(p) == 2 * p + 1;\n  assert rightChild(p) == 2 * p + 2;\n\n  if i % 2 == 1 {\n    assert i == 2 * ((i - 1) / 2) + 1;\n    assert leftChild(p) == i;\n  } else {\n    assert i % 2 == 0;\n    assert i == 2 * ((i - 1) / 2) + 2;\n    assert rightChild(p) == i;\n  }\n}\n\nlemma HeapHeightBound(h: Heap)\n  ensures heapHeight(h) <= |h.elements|\n{\n  if |h.elements| == 0 {\n    assert heapHeight(h) == 0;\n  } else {\n    Log2FloorBound(|h.elements|);\n  }\n}\n\nlemma Log2FloorBound(n: nat)\n  requires n > 0\n  ensures log2Floor(n) < n\n  decreases n\n{\n  if n == 1 {\n    assert log2Floor(1) == 0;\n  } else {\n    Log2FloorBound(n / 2);\n    assert log2Floor(n) == 1 + log2Floor(n / 2);\n    assert n / 2 < n;\n  }\n}\n\nlemma SwapPreservesMultiset(s: seq<int>, i: nat, j: nat)\n  requires i < |s| && j < |s|\n  ensures multiset(swap(s, i, j)) == multiset(s)\n{\n  var s' := swap(s, i, j);\n  assert s'[i] == s[j];\n  assert s'[j] == s[i];\n  forall k | 0 <= k < |s| && k != i && k != j\n    ensures s'[k] == s[k]\n  {\n    // Elements other than i and j are unchanged\n  }\n}", "output": "assert false;"}, {"id": "example_MinHeapRootIsMinimum_0", "type": "call", "program": "// Min-heap operations: insert, extractMin, heapify with heap property\n\ndatatype Heap = Heap(elements: seq<int>)\n\n// Check if heap is empty\npredicate {:spec} heapIsEmpty(h: Heap)\n{\n  |h.elements| == 0\n}\n\n// Get heap size\nfunction {:spec} heapSize(h: Heap): nat\n{\n  |h.elements|\n}\n\n// Parent index in heap\nfunction {:spec} parent(i: nat): nat\n  requires i > 0\n{\n  (i - 1) / 2\n}\n\n// Left child index\nfunction {:spec} leftChild(i: nat): nat\n{\n  2 * i + 1\n}\n\n// Right child index\nfunction {:spec} rightChild(i: nat): nat\n{\n  2 * i + 2\n}\n\n// Check min-heap property\npredicate {:spec} isMinHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] <= h.elements[i]\n}\n\n// Check max-heap property\npredicate {:spec} isMaxHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] >= h.elements[i]\n}\n\n// Get minimum element (root of min-heap)\nfunction {:spec} getMin(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n{\n  h.elements[0]\n}\n\n// Get maximum element (root of max-heap)\nfunction {:spec} getMax(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n{\n  h.elements[0]\n}\n\n// Check if element exists in heap\npredicate {:spec} heapContains(h: Heap, x: int)\n{\n  x in h.elements\n}\n\n// Create empty heap\nfunction {:spec} emptyHeap(): Heap\n{\n  Heap([])\n}\n\n// Create heap from single element\nfunction {:spec} singletonHeap(x: int): Heap\n{\n  Heap([x])\n}\n\n// Swap two elements in sequence\nfunction {:spec} swap(s: seq<int>, i: nat, j: nat): seq<int>\n  requires i < |s| && j < |s|\n{\n  s[i := s[j]][j := s[i]]\n}\n\n// Check if heap is complete binary tree (always true for array representation)\npredicate {:spec} isComplete(h: Heap)\n{\n  true  // Array representation is always complete\n}\n\n// Get height of heap\nfunction {:spec} heapHeight(h: Heap): nat\n{\n  if |h.elements| == 0 then 0\n  else log2Floor(|h.elements|) + 1\n}\n\n// Floor of log base 2\nfunction {:spec} log2Floor(n: nat): nat\n  requires n > 0\n  decreases n\n{\n  if n == 1 then 0\n  else 1 + log2Floor(n / 2)\n}\n\n// Check if index is valid\npredicate {:spec} validIndex(h: Heap, i: nat)\n{\n  i < |h.elements|\n}\n\n// Get all elements at a given level\nfunction {:spec} getLevel(h: Heap, level: nat): seq<int>\n{\n  getLevelHelper(h, level, 0)\n}\n\nfunction getLevelHelper(h: Heap, targetLevel: nat, currentLevel: nat): seq<int>\n  decreases |h.elements| - currentLevel\n{\n  if currentLevel >= |h.elements| || currentLevel >= Power2(targetLevel) then []\n  else if currentLevel >= Power2(targetLevel) - 1 && currentLevel < Power2(targetLevel + 1) - 1 then\n    if currentLevel < |h.elements| then [h.elements[currentLevel]] + getLevelHelper(h, targetLevel, currentLevel + 1)\n    else []\n  else getLevelHelper(h, targetLevel, currentLevel + 1)\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1\n  else 2 * Power2(n - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma EmptyHeapIsMinHeap()\n  ensures isMinHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma EmptyHeapIsMaxHeap()\n  ensures isMaxHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma SingletonIsMinHeap(x: int)\n  ensures isMinHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma SingletonIsMaxHeap(x: int)\n  ensures isMaxHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma MinHeapRootIsMinimum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] <= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        \n/*[CODE HERE]*/\n      }\n    }\n  }\n}\n\nlemma MinHeapPathToRoot(h: Heap, i: nat)\n  requires isMinHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] <= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] <= h.elements[i];\n  } else {\n    assert h.elements[parent(i)] <= h.elements[i];\n    MinHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma MaxHeapRootIsMaximum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] >= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MaxHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MaxHeapPathToRoot(h: Heap, i: nat)\n  requires isMaxHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] >= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] >= h.elements[i];\n  } else {\n    assert h.elements[parent(i)] >= h.elements[i];\n    MaxHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma ParentChildRelation(i: nat)\n  requires i > 0\n  ensures leftChild(parent(i)) == i || rightChild(parent(i)) == i\n  ensures leftChild(parent(i)) == i <==> i % 2 == 1\n  ensures rightChild(parent(i)) == i <==> i % 2 == 0\n{\n  var p := parent(i);\n  assert p == (i - 1) / 2;\n  assert leftChild(p) == 2 * p + 1;\n  assert rightChild(p) == 2 * p + 2;\n\n  if i % 2 == 1 {\n    assert i == 2 * ((i - 1) / 2) + 1;\n    assert leftChild(p) == i;\n  } else {\n    assert i % 2 == 0;\n    assert i == 2 * ((i - 1) / 2) + 2;\n    assert rightChild(p) == i;\n  }\n}\n\nlemma HeapHeightBound(h: Heap)\n  ensures heapHeight(h) <= |h.elements|\n{\n  if |h.elements| == 0 {\n    assert heapHeight(h) == 0;\n  } else {\n    Log2FloorBound(|h.elements|);\n  }\n}\n\nlemma Log2FloorBound(n: nat)\n  requires n > 0\n  ensures log2Floor(n) < n\n  decreases n\n{\n  if n == 1 {\n    assert log2Floor(1) == 0;\n  } else {\n    Log2FloorBound(n / 2);\n    assert log2Floor(n) == 1 + log2Floor(n / 2);\n    assert n / 2 < n;\n  }\n}\n\nlemma SwapPreservesMultiset(s: seq<int>, i: nat, j: nat)\n  requires i < |s| && j < |s|\n  ensures multiset(swap(s, i, j)) == multiset(s)\n{\n  var s' := swap(s, i, j);\n  assert s'[i] == s[j];\n  assert s'[j] == s[i];\n  forall k | 0 <= k < |s| && k != i && k != j\n    ensures s'[k] == s[k]\n  {\n    // Elements other than i and j are unchanged\n  }\n}", "output": "MinHeapPathToRoot(h, i);"}, {"id": "example_MinHeapRootIsMinimum_1", "type": "assert", "program": "// Min-heap operations: insert, extractMin, heapify with heap property\n\ndatatype Heap = Heap(elements: seq<int>)\n\n// Check if heap is empty\npredicate {:spec} heapIsEmpty(h: Heap)\n{\n  |h.elements| == 0\n}\n\n// Get heap size\nfunction {:spec} heapSize(h: Heap): nat\n{\n  |h.elements|\n}\n\n// Parent index in heap\nfunction {:spec} parent(i: nat): nat\n  requires i > 0\n{\n  (i - 1) / 2\n}\n\n// Left child index\nfunction {:spec} leftChild(i: nat): nat\n{\n  2 * i + 1\n}\n\n// Right child index\nfunction {:spec} rightChild(i: nat): nat\n{\n  2 * i + 2\n}\n\n// Check min-heap property\npredicate {:spec} isMinHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] <= h.elements[i]\n}\n\n// Check max-heap property\npredicate {:spec} isMaxHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] >= h.elements[i]\n}\n\n// Get minimum element (root of min-heap)\nfunction {:spec} getMin(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n{\n  h.elements[0]\n}\n\n// Get maximum element (root of max-heap)\nfunction {:spec} getMax(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n{\n  h.elements[0]\n}\n\n// Check if element exists in heap\npredicate {:spec} heapContains(h: Heap, x: int)\n{\n  x in h.elements\n}\n\n// Create empty heap\nfunction {:spec} emptyHeap(): Heap\n{\n  Heap([])\n}\n\n// Create heap from single element\nfunction {:spec} singletonHeap(x: int): Heap\n{\n  Heap([x])\n}\n\n// Swap two elements in sequence\nfunction {:spec} swap(s: seq<int>, i: nat, j: nat): seq<int>\n  requires i < |s| && j < |s|\n{\n  s[i := s[j]][j := s[i]]\n}\n\n// Check if heap is complete binary tree (always true for array representation)\npredicate {:spec} isComplete(h: Heap)\n{\n  true  // Array representation is always complete\n}\n\n// Get height of heap\nfunction {:spec} heapHeight(h: Heap): nat\n{\n  if |h.elements| == 0 then 0\n  else log2Floor(|h.elements|) + 1\n}\n\n// Floor of log base 2\nfunction {:spec} log2Floor(n: nat): nat\n  requires n > 0\n  decreases n\n{\n  if n == 1 then 0\n  else 1 + log2Floor(n / 2)\n}\n\n// Check if index is valid\npredicate {:spec} validIndex(h: Heap, i: nat)\n{\n  i < |h.elements|\n}\n\n// Get all elements at a given level\nfunction {:spec} getLevel(h: Heap, level: nat): seq<int>\n{\n  getLevelHelper(h, level, 0)\n}\n\nfunction getLevelHelper(h: Heap, targetLevel: nat, currentLevel: nat): seq<int>\n  decreases |h.elements| - currentLevel\n{\n  if currentLevel >= |h.elements| || currentLevel >= Power2(targetLevel) then []\n  else if currentLevel >= Power2(targetLevel) - 1 && currentLevel < Power2(targetLevel + 1) - 1 then\n    if currentLevel < |h.elements| then [h.elements[currentLevel]] + getLevelHelper(h, targetLevel, currentLevel + 1)\n    else []\n  else getLevelHelper(h, targetLevel, currentLevel + 1)\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1\n  else 2 * Power2(n - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma EmptyHeapIsMinHeap()\n  ensures isMinHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma EmptyHeapIsMaxHeap()\n  ensures isMaxHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma SingletonIsMinHeap(x: int)\n  ensures isMinHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma SingletonIsMaxHeap(x: int)\n  ensures isMaxHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma MinHeapRootIsMinimum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] <= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      \n/*[CODE HERE]*/\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MinHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MinHeapPathToRoot(h: Heap, i: nat)\n  requires isMinHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] <= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] <= h.elements[i];\n  } else {\n    assert h.elements[parent(i)] <= h.elements[i];\n    MinHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma MaxHeapRootIsMaximum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] >= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MaxHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MaxHeapPathToRoot(h: Heap, i: nat)\n  requires isMaxHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] >= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] >= h.elements[i];\n  } else {\n    assert h.elements[parent(i)] >= h.elements[i];\n    MaxHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma ParentChildRelation(i: nat)\n  requires i > 0\n  ensures leftChild(parent(i)) == i || rightChild(parent(i)) == i\n  ensures leftChild(parent(i)) == i <==> i % 2 == 1\n  ensures rightChild(parent(i)) == i <==> i % 2 == 0\n{\n  var p := parent(i);\n  assert p == (i - 1) / 2;\n  assert leftChild(p) == 2 * p + 1;\n  assert rightChild(p) == 2 * p + 2;\n\n  if i % 2 == 1 {\n    assert i == 2 * ((i - 1) / 2) + 1;\n    assert leftChild(p) == i;\n  } else {\n    assert i % 2 == 0;\n    assert i == 2 * ((i - 1) / 2) + 2;\n    assert rightChild(p) == i;\n  }\n}\n\nlemma HeapHeightBound(h: Heap)\n  ensures heapHeight(h) <= |h.elements|\n{\n  if |h.elements| == 0 {\n    assert heapHeight(h) == 0;\n  } else {\n    Log2FloorBound(|h.elements|);\n  }\n}\n\nlemma Log2FloorBound(n: nat)\n  requires n > 0\n  ensures log2Floor(n) < n\n  decreases n\n{\n  if n == 1 {\n    assert log2Floor(1) == 0;\n  } else {\n    Log2FloorBound(n / 2);\n    assert log2Floor(n) == 1 + log2Floor(n / 2);\n    assert n / 2 < n;\n  }\n}\n\nlemma SwapPreservesMultiset(s: seq<int>, i: nat, j: nat)\n  requires i < |s| && j < |s|\n  ensures multiset(swap(s, i, j)) == multiset(s)\n{\n  var s' := swap(s, i, j);\n  assert s'[i] == s[j];\n  assert s'[j] == s[i];\n  forall k | 0 <= k < |s| && k != i && k != j\n    ensures s'[k] == s[k]\n  {\n    // Elements other than i and j are unchanged\n  }\n}", "output": "assert i == 0;"}, {"id": "example_MinHeapPathToRoot_0", "type": "call", "program": "// Min-heap operations: insert, extractMin, heapify with heap property\n\ndatatype Heap = Heap(elements: seq<int>)\n\n// Check if heap is empty\npredicate {:spec} heapIsEmpty(h: Heap)\n{\n  |h.elements| == 0\n}\n\n// Get heap size\nfunction {:spec} heapSize(h: Heap): nat\n{\n  |h.elements|\n}\n\n// Parent index in heap\nfunction {:spec} parent(i: nat): nat\n  requires i > 0\n{\n  (i - 1) / 2\n}\n\n// Left child index\nfunction {:spec} leftChild(i: nat): nat\n{\n  2 * i + 1\n}\n\n// Right child index\nfunction {:spec} rightChild(i: nat): nat\n{\n  2 * i + 2\n}\n\n// Check min-heap property\npredicate {:spec} isMinHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] <= h.elements[i]\n}\n\n// Check max-heap property\npredicate {:spec} isMaxHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] >= h.elements[i]\n}\n\n// Get minimum element (root of min-heap)\nfunction {:spec} getMin(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n{\n  h.elements[0]\n}\n\n// Get maximum element (root of max-heap)\nfunction {:spec} getMax(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n{\n  h.elements[0]\n}\n\n// Check if element exists in heap\npredicate {:spec} heapContains(h: Heap, x: int)\n{\n  x in h.elements\n}\n\n// Create empty heap\nfunction {:spec} emptyHeap(): Heap\n{\n  Heap([])\n}\n\n// Create heap from single element\nfunction {:spec} singletonHeap(x: int): Heap\n{\n  Heap([x])\n}\n\n// Swap two elements in sequence\nfunction {:spec} swap(s: seq<int>, i: nat, j: nat): seq<int>\n  requires i < |s| && j < |s|\n{\n  s[i := s[j]][j := s[i]]\n}\n\n// Check if heap is complete binary tree (always true for array representation)\npredicate {:spec} isComplete(h: Heap)\n{\n  true  // Array representation is always complete\n}\n\n// Get height of heap\nfunction {:spec} heapHeight(h: Heap): nat\n{\n  if |h.elements| == 0 then 0\n  else log2Floor(|h.elements|) + 1\n}\n\n// Floor of log base 2\nfunction {:spec} log2Floor(n: nat): nat\n  requires n > 0\n  decreases n\n{\n  if n == 1 then 0\n  else 1 + log2Floor(n / 2)\n}\n\n// Check if index is valid\npredicate {:spec} validIndex(h: Heap, i: nat)\n{\n  i < |h.elements|\n}\n\n// Get all elements at a given level\nfunction {:spec} getLevel(h: Heap, level: nat): seq<int>\n{\n  getLevelHelper(h, level, 0)\n}\n\nfunction getLevelHelper(h: Heap, targetLevel: nat, currentLevel: nat): seq<int>\n  decreases |h.elements| - currentLevel\n{\n  if currentLevel >= |h.elements| || currentLevel >= Power2(targetLevel) then []\n  else if currentLevel >= Power2(targetLevel) - 1 && currentLevel < Power2(targetLevel + 1) - 1 then\n    if currentLevel < |h.elements| then [h.elements[currentLevel]] + getLevelHelper(h, targetLevel, currentLevel + 1)\n    else []\n  else getLevelHelper(h, targetLevel, currentLevel + 1)\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1\n  else 2 * Power2(n - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma EmptyHeapIsMinHeap()\n  ensures isMinHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma EmptyHeapIsMaxHeap()\n  ensures isMaxHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma SingletonIsMinHeap(x: int)\n  ensures isMinHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma SingletonIsMaxHeap(x: int)\n  ensures isMaxHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma MinHeapRootIsMinimum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] <= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MinHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MinHeapPathToRoot(h: Heap, i: nat)\n  requires isMinHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] <= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] <= h.elements[i];\n  } else {\n    assert h.elements[parent(i)] <= h.elements[i];\n    \n/*[CODE HERE]*/\n  }\n}\n\nlemma MaxHeapRootIsMaximum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] >= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MaxHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MaxHeapPathToRoot(h: Heap, i: nat)\n  requires isMaxHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] >= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] >= h.elements[i];\n  } else {\n    assert h.elements[parent(i)] >= h.elements[i];\n    MaxHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma ParentChildRelation(i: nat)\n  requires i > 0\n  ensures leftChild(parent(i)) == i || rightChild(parent(i)) == i\n  ensures leftChild(parent(i)) == i <==> i % 2 == 1\n  ensures rightChild(parent(i)) == i <==> i % 2 == 0\n{\n  var p := parent(i);\n  assert p == (i - 1) / 2;\n  assert leftChild(p) == 2 * p + 1;\n  assert rightChild(p) == 2 * p + 2;\n\n  if i % 2 == 1 {\n    assert i == 2 * ((i - 1) / 2) + 1;\n    assert leftChild(p) == i;\n  } else {\n    assert i % 2 == 0;\n    assert i == 2 * ((i - 1) / 2) + 2;\n    assert rightChild(p) == i;\n  }\n}\n\nlemma HeapHeightBound(h: Heap)\n  ensures heapHeight(h) <= |h.elements|\n{\n  if |h.elements| == 0 {\n    assert heapHeight(h) == 0;\n  } else {\n    Log2FloorBound(|h.elements|);\n  }\n}\n\nlemma Log2FloorBound(n: nat)\n  requires n > 0\n  ensures log2Floor(n) < n\n  decreases n\n{\n  if n == 1 {\n    assert log2Floor(1) == 0;\n  } else {\n    Log2FloorBound(n / 2);\n    assert log2Floor(n) == 1 + log2Floor(n / 2);\n    assert n / 2 < n;\n  }\n}\n\nlemma SwapPreservesMultiset(s: seq<int>, i: nat, j: nat)\n  requires i < |s| && j < |s|\n  ensures multiset(swap(s, i, j)) == multiset(s)\n{\n  var s' := swap(s, i, j);\n  assert s'[i] == s[j];\n  assert s'[j] == s[i];\n  forall k | 0 <= k < |s| && k != i && k != j\n    ensures s'[k] == s[k]\n  {\n    // Elements other than i and j are unchanged\n  }\n}", "output": "MinHeapPathToRoot(h, parent(i));"}, {"id": "example_MinHeapPathToRoot_1", "type": "assert", "program": "// Min-heap operations: insert, extractMin, heapify with heap property\n\ndatatype Heap = Heap(elements: seq<int>)\n\n// Check if heap is empty\npredicate {:spec} heapIsEmpty(h: Heap)\n{\n  |h.elements| == 0\n}\n\n// Get heap size\nfunction {:spec} heapSize(h: Heap): nat\n{\n  |h.elements|\n}\n\n// Parent index in heap\nfunction {:spec} parent(i: nat): nat\n  requires i > 0\n{\n  (i - 1) / 2\n}\n\n// Left child index\nfunction {:spec} leftChild(i: nat): nat\n{\n  2 * i + 1\n}\n\n// Right child index\nfunction {:spec} rightChild(i: nat): nat\n{\n  2 * i + 2\n}\n\n// Check min-heap property\npredicate {:spec} isMinHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] <= h.elements[i]\n}\n\n// Check max-heap property\npredicate {:spec} isMaxHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] >= h.elements[i]\n}\n\n// Get minimum element (root of min-heap)\nfunction {:spec} getMin(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n{\n  h.elements[0]\n}\n\n// Get maximum element (root of max-heap)\nfunction {:spec} getMax(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n{\n  h.elements[0]\n}\n\n// Check if element exists in heap\npredicate {:spec} heapContains(h: Heap, x: int)\n{\n  x in h.elements\n}\n\n// Create empty heap\nfunction {:spec} emptyHeap(): Heap\n{\n  Heap([])\n}\n\n// Create heap from single element\nfunction {:spec} singletonHeap(x: int): Heap\n{\n  Heap([x])\n}\n\n// Swap two elements in sequence\nfunction {:spec} swap(s: seq<int>, i: nat, j: nat): seq<int>\n  requires i < |s| && j < |s|\n{\n  s[i := s[j]][j := s[i]]\n}\n\n// Check if heap is complete binary tree (always true for array representation)\npredicate {:spec} isComplete(h: Heap)\n{\n  true  // Array representation is always complete\n}\n\n// Get height of heap\nfunction {:spec} heapHeight(h: Heap): nat\n{\n  if |h.elements| == 0 then 0\n  else log2Floor(|h.elements|) + 1\n}\n\n// Floor of log base 2\nfunction {:spec} log2Floor(n: nat): nat\n  requires n > 0\n  decreases n\n{\n  if n == 1 then 0\n  else 1 + log2Floor(n / 2)\n}\n\n// Check if index is valid\npredicate {:spec} validIndex(h: Heap, i: nat)\n{\n  i < |h.elements|\n}\n\n// Get all elements at a given level\nfunction {:spec} getLevel(h: Heap, level: nat): seq<int>\n{\n  getLevelHelper(h, level, 0)\n}\n\nfunction getLevelHelper(h: Heap, targetLevel: nat, currentLevel: nat): seq<int>\n  decreases |h.elements| - currentLevel\n{\n  if currentLevel >= |h.elements| || currentLevel >= Power2(targetLevel) then []\n  else if currentLevel >= Power2(targetLevel) - 1 && currentLevel < Power2(targetLevel + 1) - 1 then\n    if currentLevel < |h.elements| then [h.elements[currentLevel]] + getLevelHelper(h, targetLevel, currentLevel + 1)\n    else []\n  else getLevelHelper(h, targetLevel, currentLevel + 1)\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1\n  else 2 * Power2(n - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma EmptyHeapIsMinHeap()\n  ensures isMinHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma EmptyHeapIsMaxHeap()\n  ensures isMaxHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma SingletonIsMinHeap(x: int)\n  ensures isMinHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma SingletonIsMaxHeap(x: int)\n  ensures isMaxHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma MinHeapRootIsMinimum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] <= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MinHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MinHeapPathToRoot(h: Heap, i: nat)\n  requires isMinHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] <= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] <= h.elements[i];\n  } else {\n    \n/*[CODE HERE]*/\n    MinHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma MaxHeapRootIsMaximum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] >= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MaxHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MaxHeapPathToRoot(h: Heap, i: nat)\n  requires isMaxHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] >= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] >= h.elements[i];\n  } else {\n    assert h.elements[parent(i)] >= h.elements[i];\n    MaxHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma ParentChildRelation(i: nat)\n  requires i > 0\n  ensures leftChild(parent(i)) == i || rightChild(parent(i)) == i\n  ensures leftChild(parent(i)) == i <==> i % 2 == 1\n  ensures rightChild(parent(i)) == i <==> i % 2 == 0\n{\n  var p := parent(i);\n  assert p == (i - 1) / 2;\n  assert leftChild(p) == 2 * p + 1;\n  assert rightChild(p) == 2 * p + 2;\n\n  if i % 2 == 1 {\n    assert i == 2 * ((i - 1) / 2) + 1;\n    assert leftChild(p) == i;\n  } else {\n    assert i % 2 == 0;\n    assert i == 2 * ((i - 1) / 2) + 2;\n    assert rightChild(p) == i;\n  }\n}\n\nlemma HeapHeightBound(h: Heap)\n  ensures heapHeight(h) <= |h.elements|\n{\n  if |h.elements| == 0 {\n    assert heapHeight(h) == 0;\n  } else {\n    Log2FloorBound(|h.elements|);\n  }\n}\n\nlemma Log2FloorBound(n: nat)\n  requires n > 0\n  ensures log2Floor(n) < n\n  decreases n\n{\n  if n == 1 {\n    assert log2Floor(1) == 0;\n  } else {\n    Log2FloorBound(n / 2);\n    assert log2Floor(n) == 1 + log2Floor(n / 2);\n    assert n / 2 < n;\n  }\n}\n\nlemma SwapPreservesMultiset(s: seq<int>, i: nat, j: nat)\n  requires i < |s| && j < |s|\n  ensures multiset(swap(s, i, j)) == multiset(s)\n{\n  var s' := swap(s, i, j);\n  assert s'[i] == s[j];\n  assert s'[j] == s[i];\n  forall k | 0 <= k < |s| && k != i && k != j\n    ensures s'[k] == s[k]\n  {\n    // Elements other than i and j are unchanged\n  }\n}", "output": "assert h.elements[parent(i)] <= h.elements[i];"}, {"id": "example_MinHeapPathToRoot_2", "type": "assert", "program": "// Min-heap operations: insert, extractMin, heapify with heap property\n\ndatatype Heap = Heap(elements: seq<int>)\n\n// Check if heap is empty\npredicate {:spec} heapIsEmpty(h: Heap)\n{\n  |h.elements| == 0\n}\n\n// Get heap size\nfunction {:spec} heapSize(h: Heap): nat\n{\n  |h.elements|\n}\n\n// Parent index in heap\nfunction {:spec} parent(i: nat): nat\n  requires i > 0\n{\n  (i - 1) / 2\n}\n\n// Left child index\nfunction {:spec} leftChild(i: nat): nat\n{\n  2 * i + 1\n}\n\n// Right child index\nfunction {:spec} rightChild(i: nat): nat\n{\n  2 * i + 2\n}\n\n// Check min-heap property\npredicate {:spec} isMinHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] <= h.elements[i]\n}\n\n// Check max-heap property\npredicate {:spec} isMaxHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] >= h.elements[i]\n}\n\n// Get minimum element (root of min-heap)\nfunction {:spec} getMin(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n{\n  h.elements[0]\n}\n\n// Get maximum element (root of max-heap)\nfunction {:spec} getMax(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n{\n  h.elements[0]\n}\n\n// Check if element exists in heap\npredicate {:spec} heapContains(h: Heap, x: int)\n{\n  x in h.elements\n}\n\n// Create empty heap\nfunction {:spec} emptyHeap(): Heap\n{\n  Heap([])\n}\n\n// Create heap from single element\nfunction {:spec} singletonHeap(x: int): Heap\n{\n  Heap([x])\n}\n\n// Swap two elements in sequence\nfunction {:spec} swap(s: seq<int>, i: nat, j: nat): seq<int>\n  requires i < |s| && j < |s|\n{\n  s[i := s[j]][j := s[i]]\n}\n\n// Check if heap is complete binary tree (always true for array representation)\npredicate {:spec} isComplete(h: Heap)\n{\n  true  // Array representation is always complete\n}\n\n// Get height of heap\nfunction {:spec} heapHeight(h: Heap): nat\n{\n  if |h.elements| == 0 then 0\n  else log2Floor(|h.elements|) + 1\n}\n\n// Floor of log base 2\nfunction {:spec} log2Floor(n: nat): nat\n  requires n > 0\n  decreases n\n{\n  if n == 1 then 0\n  else 1 + log2Floor(n / 2)\n}\n\n// Check if index is valid\npredicate {:spec} validIndex(h: Heap, i: nat)\n{\n  i < |h.elements|\n}\n\n// Get all elements at a given level\nfunction {:spec} getLevel(h: Heap, level: nat): seq<int>\n{\n  getLevelHelper(h, level, 0)\n}\n\nfunction getLevelHelper(h: Heap, targetLevel: nat, currentLevel: nat): seq<int>\n  decreases |h.elements| - currentLevel\n{\n  if currentLevel >= |h.elements| || currentLevel >= Power2(targetLevel) then []\n  else if currentLevel >= Power2(targetLevel) - 1 && currentLevel < Power2(targetLevel + 1) - 1 then\n    if currentLevel < |h.elements| then [h.elements[currentLevel]] + getLevelHelper(h, targetLevel, currentLevel + 1)\n    else []\n  else getLevelHelper(h, targetLevel, currentLevel + 1)\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1\n  else 2 * Power2(n - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma EmptyHeapIsMinHeap()\n  ensures isMinHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma EmptyHeapIsMaxHeap()\n  ensures isMaxHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma SingletonIsMinHeap(x: int)\n  ensures isMinHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma SingletonIsMaxHeap(x: int)\n  ensures isMaxHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma MinHeapRootIsMinimum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] <= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MinHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MinHeapPathToRoot(h: Heap, i: nat)\n  requires isMinHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] <= h.elements[i]\n{\n  if parent(i) == 0 {\n    \n/*[CODE HERE]*/\n  } else {\n    assert h.elements[parent(i)] <= h.elements[i];\n    MinHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma MaxHeapRootIsMaximum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] >= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MaxHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MaxHeapPathToRoot(h: Heap, i: nat)\n  requires isMaxHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] >= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] >= h.elements[i];\n  } else {\n    assert h.elements[parent(i)] >= h.elements[i];\n    MaxHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma ParentChildRelation(i: nat)\n  requires i > 0\n  ensures leftChild(parent(i)) == i || rightChild(parent(i)) == i\n  ensures leftChild(parent(i)) == i <==> i % 2 == 1\n  ensures rightChild(parent(i)) == i <==> i % 2 == 0\n{\n  var p := parent(i);\n  assert p == (i - 1) / 2;\n  assert leftChild(p) == 2 * p + 1;\n  assert rightChild(p) == 2 * p + 2;\n\n  if i % 2 == 1 {\n    assert i == 2 * ((i - 1) / 2) + 1;\n    assert leftChild(p) == i;\n  } else {\n    assert i % 2 == 0;\n    assert i == 2 * ((i - 1) / 2) + 2;\n    assert rightChild(p) == i;\n  }\n}\n\nlemma HeapHeightBound(h: Heap)\n  ensures heapHeight(h) <= |h.elements|\n{\n  if |h.elements| == 0 {\n    assert heapHeight(h) == 0;\n  } else {\n    Log2FloorBound(|h.elements|);\n  }\n}\n\nlemma Log2FloorBound(n: nat)\n  requires n > 0\n  ensures log2Floor(n) < n\n  decreases n\n{\n  if n == 1 {\n    assert log2Floor(1) == 0;\n  } else {\n    Log2FloorBound(n / 2);\n    assert log2Floor(n) == 1 + log2Floor(n / 2);\n    assert n / 2 < n;\n  }\n}\n\nlemma SwapPreservesMultiset(s: seq<int>, i: nat, j: nat)\n  requires i < |s| && j < |s|\n  ensures multiset(swap(s, i, j)) == multiset(s)\n{\n  var s' := swap(s, i, j);\n  assert s'[i] == s[j];\n  assert s'[j] == s[i];\n  forall k | 0 <= k < |s| && k != i && k != j\n    ensures s'[k] == s[k]\n  {\n    // Elements other than i and j are unchanged\n  }\n}", "output": "assert h.elements[0] <= h.elements[i];"}, {"id": "example_MaxHeapRootIsMaximum_0", "type": "call", "program": "// Min-heap operations: insert, extractMin, heapify with heap property\n\ndatatype Heap = Heap(elements: seq<int>)\n\n// Check if heap is empty\npredicate {:spec} heapIsEmpty(h: Heap)\n{\n  |h.elements| == 0\n}\n\n// Get heap size\nfunction {:spec} heapSize(h: Heap): nat\n{\n  |h.elements|\n}\n\n// Parent index in heap\nfunction {:spec} parent(i: nat): nat\n  requires i > 0\n{\n  (i - 1) / 2\n}\n\n// Left child index\nfunction {:spec} leftChild(i: nat): nat\n{\n  2 * i + 1\n}\n\n// Right child index\nfunction {:spec} rightChild(i: nat): nat\n{\n  2 * i + 2\n}\n\n// Check min-heap property\npredicate {:spec} isMinHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] <= h.elements[i]\n}\n\n// Check max-heap property\npredicate {:spec} isMaxHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] >= h.elements[i]\n}\n\n// Get minimum element (root of min-heap)\nfunction {:spec} getMin(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n{\n  h.elements[0]\n}\n\n// Get maximum element (root of max-heap)\nfunction {:spec} getMax(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n{\n  h.elements[0]\n}\n\n// Check if element exists in heap\npredicate {:spec} heapContains(h: Heap, x: int)\n{\n  x in h.elements\n}\n\n// Create empty heap\nfunction {:spec} emptyHeap(): Heap\n{\n  Heap([])\n}\n\n// Create heap from single element\nfunction {:spec} singletonHeap(x: int): Heap\n{\n  Heap([x])\n}\n\n// Swap two elements in sequence\nfunction {:spec} swap(s: seq<int>, i: nat, j: nat): seq<int>\n  requires i < |s| && j < |s|\n{\n  s[i := s[j]][j := s[i]]\n}\n\n// Check if heap is complete binary tree (always true for array representation)\npredicate {:spec} isComplete(h: Heap)\n{\n  true  // Array representation is always complete\n}\n\n// Get height of heap\nfunction {:spec} heapHeight(h: Heap): nat\n{\n  if |h.elements| == 0 then 0\n  else log2Floor(|h.elements|) + 1\n}\n\n// Floor of log base 2\nfunction {:spec} log2Floor(n: nat): nat\n  requires n > 0\n  decreases n\n{\n  if n == 1 then 0\n  else 1 + log2Floor(n / 2)\n}\n\n// Check if index is valid\npredicate {:spec} validIndex(h: Heap, i: nat)\n{\n  i < |h.elements|\n}\n\n// Get all elements at a given level\nfunction {:spec} getLevel(h: Heap, level: nat): seq<int>\n{\n  getLevelHelper(h, level, 0)\n}\n\nfunction getLevelHelper(h: Heap, targetLevel: nat, currentLevel: nat): seq<int>\n  decreases |h.elements| - currentLevel\n{\n  if currentLevel >= |h.elements| || currentLevel >= Power2(targetLevel) then []\n  else if currentLevel >= Power2(targetLevel) - 1 && currentLevel < Power2(targetLevel + 1) - 1 then\n    if currentLevel < |h.elements| then [h.elements[currentLevel]] + getLevelHelper(h, targetLevel, currentLevel + 1)\n    else []\n  else getLevelHelper(h, targetLevel, currentLevel + 1)\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1\n  else 2 * Power2(n - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma EmptyHeapIsMinHeap()\n  ensures isMinHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma EmptyHeapIsMaxHeap()\n  ensures isMaxHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma SingletonIsMinHeap(x: int)\n  ensures isMinHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma SingletonIsMaxHeap(x: int)\n  ensures isMaxHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma MinHeapRootIsMinimum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] <= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MinHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MinHeapPathToRoot(h: Heap, i: nat)\n  requires isMinHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] <= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] <= h.elements[i];\n  } else {\n    assert h.elements[parent(i)] <= h.elements[i];\n    MinHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma MaxHeapRootIsMaximum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] >= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        \n/*[CODE HERE]*/\n      }\n    }\n  }\n}\n\nlemma MaxHeapPathToRoot(h: Heap, i: nat)\n  requires isMaxHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] >= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] >= h.elements[i];\n  } else {\n    assert h.elements[parent(i)] >= h.elements[i];\n    MaxHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma ParentChildRelation(i: nat)\n  requires i > 0\n  ensures leftChild(parent(i)) == i || rightChild(parent(i)) == i\n  ensures leftChild(parent(i)) == i <==> i % 2 == 1\n  ensures rightChild(parent(i)) == i <==> i % 2 == 0\n{\n  var p := parent(i);\n  assert p == (i - 1) / 2;\n  assert leftChild(p) == 2 * p + 1;\n  assert rightChild(p) == 2 * p + 2;\n\n  if i % 2 == 1 {\n    assert i == 2 * ((i - 1) / 2) + 1;\n    assert leftChild(p) == i;\n  } else {\n    assert i % 2 == 0;\n    assert i == 2 * ((i - 1) / 2) + 2;\n    assert rightChild(p) == i;\n  }\n}\n\nlemma HeapHeightBound(h: Heap)\n  ensures heapHeight(h) <= |h.elements|\n{\n  if |h.elements| == 0 {\n    assert heapHeight(h) == 0;\n  } else {\n    Log2FloorBound(|h.elements|);\n  }\n}\n\nlemma Log2FloorBound(n: nat)\n  requires n > 0\n  ensures log2Floor(n) < n\n  decreases n\n{\n  if n == 1 {\n    assert log2Floor(1) == 0;\n  } else {\n    Log2FloorBound(n / 2);\n    assert log2Floor(n) == 1 + log2Floor(n / 2);\n    assert n / 2 < n;\n  }\n}\n\nlemma SwapPreservesMultiset(s: seq<int>, i: nat, j: nat)\n  requires i < |s| && j < |s|\n  ensures multiset(swap(s, i, j)) == multiset(s)\n{\n  var s' := swap(s, i, j);\n  assert s'[i] == s[j];\n  assert s'[j] == s[i];\n  forall k | 0 <= k < |s| && k != i && k != j\n    ensures s'[k] == s[k]\n  {\n    // Elements other than i and j are unchanged\n  }\n}", "output": "MaxHeapPathToRoot(h, i);"}, {"id": "example_MaxHeapRootIsMaximum_1", "type": "assert", "program": "// Min-heap operations: insert, extractMin, heapify with heap property\n\ndatatype Heap = Heap(elements: seq<int>)\n\n// Check if heap is empty\npredicate {:spec} heapIsEmpty(h: Heap)\n{\n  |h.elements| == 0\n}\n\n// Get heap size\nfunction {:spec} heapSize(h: Heap): nat\n{\n  |h.elements|\n}\n\n// Parent index in heap\nfunction {:spec} parent(i: nat): nat\n  requires i > 0\n{\n  (i - 1) / 2\n}\n\n// Left child index\nfunction {:spec} leftChild(i: nat): nat\n{\n  2 * i + 1\n}\n\n// Right child index\nfunction {:spec} rightChild(i: nat): nat\n{\n  2 * i + 2\n}\n\n// Check min-heap property\npredicate {:spec} isMinHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] <= h.elements[i]\n}\n\n// Check max-heap property\npredicate {:spec} isMaxHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] >= h.elements[i]\n}\n\n// Get minimum element (root of min-heap)\nfunction {:spec} getMin(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n{\n  h.elements[0]\n}\n\n// Get maximum element (root of max-heap)\nfunction {:spec} getMax(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n{\n  h.elements[0]\n}\n\n// Check if element exists in heap\npredicate {:spec} heapContains(h: Heap, x: int)\n{\n  x in h.elements\n}\n\n// Create empty heap\nfunction {:spec} emptyHeap(): Heap\n{\n  Heap([])\n}\n\n// Create heap from single element\nfunction {:spec} singletonHeap(x: int): Heap\n{\n  Heap([x])\n}\n\n// Swap two elements in sequence\nfunction {:spec} swap(s: seq<int>, i: nat, j: nat): seq<int>\n  requires i < |s| && j < |s|\n{\n  s[i := s[j]][j := s[i]]\n}\n\n// Check if heap is complete binary tree (always true for array representation)\npredicate {:spec} isComplete(h: Heap)\n{\n  true  // Array representation is always complete\n}\n\n// Get height of heap\nfunction {:spec} heapHeight(h: Heap): nat\n{\n  if |h.elements| == 0 then 0\n  else log2Floor(|h.elements|) + 1\n}\n\n// Floor of log base 2\nfunction {:spec} log2Floor(n: nat): nat\n  requires n > 0\n  decreases n\n{\n  if n == 1 then 0\n  else 1 + log2Floor(n / 2)\n}\n\n// Check if index is valid\npredicate {:spec} validIndex(h: Heap, i: nat)\n{\n  i < |h.elements|\n}\n\n// Get all elements at a given level\nfunction {:spec} getLevel(h: Heap, level: nat): seq<int>\n{\n  getLevelHelper(h, level, 0)\n}\n\nfunction getLevelHelper(h: Heap, targetLevel: nat, currentLevel: nat): seq<int>\n  decreases |h.elements| - currentLevel\n{\n  if currentLevel >= |h.elements| || currentLevel >= Power2(targetLevel) then []\n  else if currentLevel >= Power2(targetLevel) - 1 && currentLevel < Power2(targetLevel + 1) - 1 then\n    if currentLevel < |h.elements| then [h.elements[currentLevel]] + getLevelHelper(h, targetLevel, currentLevel + 1)\n    else []\n  else getLevelHelper(h, targetLevel, currentLevel + 1)\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1\n  else 2 * Power2(n - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma EmptyHeapIsMinHeap()\n  ensures isMinHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma EmptyHeapIsMaxHeap()\n  ensures isMaxHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma SingletonIsMinHeap(x: int)\n  ensures isMinHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma SingletonIsMaxHeap(x: int)\n  ensures isMaxHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma MinHeapRootIsMinimum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] <= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MinHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MinHeapPathToRoot(h: Heap, i: nat)\n  requires isMinHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] <= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] <= h.elements[i];\n  } else {\n    assert h.elements[parent(i)] <= h.elements[i];\n    MinHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma MaxHeapRootIsMaximum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] >= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      \n/*[CODE HERE]*/\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MaxHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MaxHeapPathToRoot(h: Heap, i: nat)\n  requires isMaxHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] >= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] >= h.elements[i];\n  } else {\n    assert h.elements[parent(i)] >= h.elements[i];\n    MaxHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma ParentChildRelation(i: nat)\n  requires i > 0\n  ensures leftChild(parent(i)) == i || rightChild(parent(i)) == i\n  ensures leftChild(parent(i)) == i <==> i % 2 == 1\n  ensures rightChild(parent(i)) == i <==> i % 2 == 0\n{\n  var p := parent(i);\n  assert p == (i - 1) / 2;\n  assert leftChild(p) == 2 * p + 1;\n  assert rightChild(p) == 2 * p + 2;\n\n  if i % 2 == 1 {\n    assert i == 2 * ((i - 1) / 2) + 1;\n    assert leftChild(p) == i;\n  } else {\n    assert i % 2 == 0;\n    assert i == 2 * ((i - 1) / 2) + 2;\n    assert rightChild(p) == i;\n  }\n}\n\nlemma HeapHeightBound(h: Heap)\n  ensures heapHeight(h) <= |h.elements|\n{\n  if |h.elements| == 0 {\n    assert heapHeight(h) == 0;\n  } else {\n    Log2FloorBound(|h.elements|);\n  }\n}\n\nlemma Log2FloorBound(n: nat)\n  requires n > 0\n  ensures log2Floor(n) < n\n  decreases n\n{\n  if n == 1 {\n    assert log2Floor(1) == 0;\n  } else {\n    Log2FloorBound(n / 2);\n    assert log2Floor(n) == 1 + log2Floor(n / 2);\n    assert n / 2 < n;\n  }\n}\n\nlemma SwapPreservesMultiset(s: seq<int>, i: nat, j: nat)\n  requires i < |s| && j < |s|\n  ensures multiset(swap(s, i, j)) == multiset(s)\n{\n  var s' := swap(s, i, j);\n  assert s'[i] == s[j];\n  assert s'[j] == s[i];\n  forall k | 0 <= k < |s| && k != i && k != j\n    ensures s'[k] == s[k]\n  {\n    // Elements other than i and j are unchanged\n  }\n}", "output": "assert i == 0;"}, {"id": "example_MaxHeapPathToRoot_0", "type": "call", "program": "// Min-heap operations: insert, extractMin, heapify with heap property\n\ndatatype Heap = Heap(elements: seq<int>)\n\n// Check if heap is empty\npredicate {:spec} heapIsEmpty(h: Heap)\n{\n  |h.elements| == 0\n}\n\n// Get heap size\nfunction {:spec} heapSize(h: Heap): nat\n{\n  |h.elements|\n}\n\n// Parent index in heap\nfunction {:spec} parent(i: nat): nat\n  requires i > 0\n{\n  (i - 1) / 2\n}\n\n// Left child index\nfunction {:spec} leftChild(i: nat): nat\n{\n  2 * i + 1\n}\n\n// Right child index\nfunction {:spec} rightChild(i: nat): nat\n{\n  2 * i + 2\n}\n\n// Check min-heap property\npredicate {:spec} isMinHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] <= h.elements[i]\n}\n\n// Check max-heap property\npredicate {:spec} isMaxHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] >= h.elements[i]\n}\n\n// Get minimum element (root of min-heap)\nfunction {:spec} getMin(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n{\n  h.elements[0]\n}\n\n// Get maximum element (root of max-heap)\nfunction {:spec} getMax(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n{\n  h.elements[0]\n}\n\n// Check if element exists in heap\npredicate {:spec} heapContains(h: Heap, x: int)\n{\n  x in h.elements\n}\n\n// Create empty heap\nfunction {:spec} emptyHeap(): Heap\n{\n  Heap([])\n}\n\n// Create heap from single element\nfunction {:spec} singletonHeap(x: int): Heap\n{\n  Heap([x])\n}\n\n// Swap two elements in sequence\nfunction {:spec} swap(s: seq<int>, i: nat, j: nat): seq<int>\n  requires i < |s| && j < |s|\n{\n  s[i := s[j]][j := s[i]]\n}\n\n// Check if heap is complete binary tree (always true for array representation)\npredicate {:spec} isComplete(h: Heap)\n{\n  true  // Array representation is always complete\n}\n\n// Get height of heap\nfunction {:spec} heapHeight(h: Heap): nat\n{\n  if |h.elements| == 0 then 0\n  else log2Floor(|h.elements|) + 1\n}\n\n// Floor of log base 2\nfunction {:spec} log2Floor(n: nat): nat\n  requires n > 0\n  decreases n\n{\n  if n == 1 then 0\n  else 1 + log2Floor(n / 2)\n}\n\n// Check if index is valid\npredicate {:spec} validIndex(h: Heap, i: nat)\n{\n  i < |h.elements|\n}\n\n// Get all elements at a given level\nfunction {:spec} getLevel(h: Heap, level: nat): seq<int>\n{\n  getLevelHelper(h, level, 0)\n}\n\nfunction getLevelHelper(h: Heap, targetLevel: nat, currentLevel: nat): seq<int>\n  decreases |h.elements| - currentLevel\n{\n  if currentLevel >= |h.elements| || currentLevel >= Power2(targetLevel) then []\n  else if currentLevel >= Power2(targetLevel) - 1 && currentLevel < Power2(targetLevel + 1) - 1 then\n    if currentLevel < |h.elements| then [h.elements[currentLevel]] + getLevelHelper(h, targetLevel, currentLevel + 1)\n    else []\n  else getLevelHelper(h, targetLevel, currentLevel + 1)\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1\n  else 2 * Power2(n - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma EmptyHeapIsMinHeap()\n  ensures isMinHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma EmptyHeapIsMaxHeap()\n  ensures isMaxHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma SingletonIsMinHeap(x: int)\n  ensures isMinHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma SingletonIsMaxHeap(x: int)\n  ensures isMaxHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma MinHeapRootIsMinimum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] <= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MinHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MinHeapPathToRoot(h: Heap, i: nat)\n  requires isMinHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] <= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] <= h.elements[i];\n  } else {\n    assert h.elements[parent(i)] <= h.elements[i];\n    MinHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma MaxHeapRootIsMaximum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] >= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MaxHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MaxHeapPathToRoot(h: Heap, i: nat)\n  requires isMaxHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] >= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] >= h.elements[i];\n  } else {\n    assert h.elements[parent(i)] >= h.elements[i];\n    \n/*[CODE HERE]*/\n  }\n}\n\nlemma ParentChildRelation(i: nat)\n  requires i > 0\n  ensures leftChild(parent(i)) == i || rightChild(parent(i)) == i\n  ensures leftChild(parent(i)) == i <==> i % 2 == 1\n  ensures rightChild(parent(i)) == i <==> i % 2 == 0\n{\n  var p := parent(i);\n  assert p == (i - 1) / 2;\n  assert leftChild(p) == 2 * p + 1;\n  assert rightChild(p) == 2 * p + 2;\n\n  if i % 2 == 1 {\n    assert i == 2 * ((i - 1) / 2) + 1;\n    assert leftChild(p) == i;\n  } else {\n    assert i % 2 == 0;\n    assert i == 2 * ((i - 1) / 2) + 2;\n    assert rightChild(p) == i;\n  }\n}\n\nlemma HeapHeightBound(h: Heap)\n  ensures heapHeight(h) <= |h.elements|\n{\n  if |h.elements| == 0 {\n    assert heapHeight(h) == 0;\n  } else {\n    Log2FloorBound(|h.elements|);\n  }\n}\n\nlemma Log2FloorBound(n: nat)\n  requires n > 0\n  ensures log2Floor(n) < n\n  decreases n\n{\n  if n == 1 {\n    assert log2Floor(1) == 0;\n  } else {\n    Log2FloorBound(n / 2);\n    assert log2Floor(n) == 1 + log2Floor(n / 2);\n    assert n / 2 < n;\n  }\n}\n\nlemma SwapPreservesMultiset(s: seq<int>, i: nat, j: nat)\n  requires i < |s| && j < |s|\n  ensures multiset(swap(s, i, j)) == multiset(s)\n{\n  var s' := swap(s, i, j);\n  assert s'[i] == s[j];\n  assert s'[j] == s[i];\n  forall k | 0 <= k < |s| && k != i && k != j\n    ensures s'[k] == s[k]\n  {\n    // Elements other than i and j are unchanged\n  }\n}", "output": "MaxHeapPathToRoot(h, parent(i));"}, {"id": "example_MaxHeapPathToRoot_1", "type": "assert", "program": "// Min-heap operations: insert, extractMin, heapify with heap property\n\ndatatype Heap = Heap(elements: seq<int>)\n\n// Check if heap is empty\npredicate {:spec} heapIsEmpty(h: Heap)\n{\n  |h.elements| == 0\n}\n\n// Get heap size\nfunction {:spec} heapSize(h: Heap): nat\n{\n  |h.elements|\n}\n\n// Parent index in heap\nfunction {:spec} parent(i: nat): nat\n  requires i > 0\n{\n  (i - 1) / 2\n}\n\n// Left child index\nfunction {:spec} leftChild(i: nat): nat\n{\n  2 * i + 1\n}\n\n// Right child index\nfunction {:spec} rightChild(i: nat): nat\n{\n  2 * i + 2\n}\n\n// Check min-heap property\npredicate {:spec} isMinHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] <= h.elements[i]\n}\n\n// Check max-heap property\npredicate {:spec} isMaxHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] >= h.elements[i]\n}\n\n// Get minimum element (root of min-heap)\nfunction {:spec} getMin(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n{\n  h.elements[0]\n}\n\n// Get maximum element (root of max-heap)\nfunction {:spec} getMax(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n{\n  h.elements[0]\n}\n\n// Check if element exists in heap\npredicate {:spec} heapContains(h: Heap, x: int)\n{\n  x in h.elements\n}\n\n// Create empty heap\nfunction {:spec} emptyHeap(): Heap\n{\n  Heap([])\n}\n\n// Create heap from single element\nfunction {:spec} singletonHeap(x: int): Heap\n{\n  Heap([x])\n}\n\n// Swap two elements in sequence\nfunction {:spec} swap(s: seq<int>, i: nat, j: nat): seq<int>\n  requires i < |s| && j < |s|\n{\n  s[i := s[j]][j := s[i]]\n}\n\n// Check if heap is complete binary tree (always true for array representation)\npredicate {:spec} isComplete(h: Heap)\n{\n  true  // Array representation is always complete\n}\n\n// Get height of heap\nfunction {:spec} heapHeight(h: Heap): nat\n{\n  if |h.elements| == 0 then 0\n  else log2Floor(|h.elements|) + 1\n}\n\n// Floor of log base 2\nfunction {:spec} log2Floor(n: nat): nat\n  requires n > 0\n  decreases n\n{\n  if n == 1 then 0\n  else 1 + log2Floor(n / 2)\n}\n\n// Check if index is valid\npredicate {:spec} validIndex(h: Heap, i: nat)\n{\n  i < |h.elements|\n}\n\n// Get all elements at a given level\nfunction {:spec} getLevel(h: Heap, level: nat): seq<int>\n{\n  getLevelHelper(h, level, 0)\n}\n\nfunction getLevelHelper(h: Heap, targetLevel: nat, currentLevel: nat): seq<int>\n  decreases |h.elements| - currentLevel\n{\n  if currentLevel >= |h.elements| || currentLevel >= Power2(targetLevel) then []\n  else if currentLevel >= Power2(targetLevel) - 1 && currentLevel < Power2(targetLevel + 1) - 1 then\n    if currentLevel < |h.elements| then [h.elements[currentLevel]] + getLevelHelper(h, targetLevel, currentLevel + 1)\n    else []\n  else getLevelHelper(h, targetLevel, currentLevel + 1)\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1\n  else 2 * Power2(n - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma EmptyHeapIsMinHeap()\n  ensures isMinHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma EmptyHeapIsMaxHeap()\n  ensures isMaxHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma SingletonIsMinHeap(x: int)\n  ensures isMinHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma SingletonIsMaxHeap(x: int)\n  ensures isMaxHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma MinHeapRootIsMinimum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] <= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MinHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MinHeapPathToRoot(h: Heap, i: nat)\n  requires isMinHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] <= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] <= h.elements[i];\n  } else {\n    assert h.elements[parent(i)] <= h.elements[i];\n    MinHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma MaxHeapRootIsMaximum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] >= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MaxHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MaxHeapPathToRoot(h: Heap, i: nat)\n  requires isMaxHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] >= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] >= h.elements[i];\n  } else {\n    \n/*[CODE HERE]*/\n    MaxHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma ParentChildRelation(i: nat)\n  requires i > 0\n  ensures leftChild(parent(i)) == i || rightChild(parent(i)) == i\n  ensures leftChild(parent(i)) == i <==> i % 2 == 1\n  ensures rightChild(parent(i)) == i <==> i % 2 == 0\n{\n  var p := parent(i);\n  assert p == (i - 1) / 2;\n  assert leftChild(p) == 2 * p + 1;\n  assert rightChild(p) == 2 * p + 2;\n\n  if i % 2 == 1 {\n    assert i == 2 * ((i - 1) / 2) + 1;\n    assert leftChild(p) == i;\n  } else {\n    assert i % 2 == 0;\n    assert i == 2 * ((i - 1) / 2) + 2;\n    assert rightChild(p) == i;\n  }\n}\n\nlemma HeapHeightBound(h: Heap)\n  ensures heapHeight(h) <= |h.elements|\n{\n  if |h.elements| == 0 {\n    assert heapHeight(h) == 0;\n  } else {\n    Log2FloorBound(|h.elements|);\n  }\n}\n\nlemma Log2FloorBound(n: nat)\n  requires n > 0\n  ensures log2Floor(n) < n\n  decreases n\n{\n  if n == 1 {\n    assert log2Floor(1) == 0;\n  } else {\n    Log2FloorBound(n / 2);\n    assert log2Floor(n) == 1 + log2Floor(n / 2);\n    assert n / 2 < n;\n  }\n}\n\nlemma SwapPreservesMultiset(s: seq<int>, i: nat, j: nat)\n  requires i < |s| && j < |s|\n  ensures multiset(swap(s, i, j)) == multiset(s)\n{\n  var s' := swap(s, i, j);\n  assert s'[i] == s[j];\n  assert s'[j] == s[i];\n  forall k | 0 <= k < |s| && k != i && k != j\n    ensures s'[k] == s[k]\n  {\n    // Elements other than i and j are unchanged\n  }\n}", "output": "assert h.elements[parent(i)] >= h.elements[i];"}, {"id": "example_MaxHeapPathToRoot_2", "type": "assert", "program": "// Min-heap operations: insert, extractMin, heapify with heap property\n\ndatatype Heap = Heap(elements: seq<int>)\n\n// Check if heap is empty\npredicate {:spec} heapIsEmpty(h: Heap)\n{\n  |h.elements| == 0\n}\n\n// Get heap size\nfunction {:spec} heapSize(h: Heap): nat\n{\n  |h.elements|\n}\n\n// Parent index in heap\nfunction {:spec} parent(i: nat): nat\n  requires i > 0\n{\n  (i - 1) / 2\n}\n\n// Left child index\nfunction {:spec} leftChild(i: nat): nat\n{\n  2 * i + 1\n}\n\n// Right child index\nfunction {:spec} rightChild(i: nat): nat\n{\n  2 * i + 2\n}\n\n// Check min-heap property\npredicate {:spec} isMinHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] <= h.elements[i]\n}\n\n// Check max-heap property\npredicate {:spec} isMaxHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] >= h.elements[i]\n}\n\n// Get minimum element (root of min-heap)\nfunction {:spec} getMin(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n{\n  h.elements[0]\n}\n\n// Get maximum element (root of max-heap)\nfunction {:spec} getMax(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n{\n  h.elements[0]\n}\n\n// Check if element exists in heap\npredicate {:spec} heapContains(h: Heap, x: int)\n{\n  x in h.elements\n}\n\n// Create empty heap\nfunction {:spec} emptyHeap(): Heap\n{\n  Heap([])\n}\n\n// Create heap from single element\nfunction {:spec} singletonHeap(x: int): Heap\n{\n  Heap([x])\n}\n\n// Swap two elements in sequence\nfunction {:spec} swap(s: seq<int>, i: nat, j: nat): seq<int>\n  requires i < |s| && j < |s|\n{\n  s[i := s[j]][j := s[i]]\n}\n\n// Check if heap is complete binary tree (always true for array representation)\npredicate {:spec} isComplete(h: Heap)\n{\n  true  // Array representation is always complete\n}\n\n// Get height of heap\nfunction {:spec} heapHeight(h: Heap): nat\n{\n  if |h.elements| == 0 then 0\n  else log2Floor(|h.elements|) + 1\n}\n\n// Floor of log base 2\nfunction {:spec} log2Floor(n: nat): nat\n  requires n > 0\n  decreases n\n{\n  if n == 1 then 0\n  else 1 + log2Floor(n / 2)\n}\n\n// Check if index is valid\npredicate {:spec} validIndex(h: Heap, i: nat)\n{\n  i < |h.elements|\n}\n\n// Get all elements at a given level\nfunction {:spec} getLevel(h: Heap, level: nat): seq<int>\n{\n  getLevelHelper(h, level, 0)\n}\n\nfunction getLevelHelper(h: Heap, targetLevel: nat, currentLevel: nat): seq<int>\n  decreases |h.elements| - currentLevel\n{\n  if currentLevel >= |h.elements| || currentLevel >= Power2(targetLevel) then []\n  else if currentLevel >= Power2(targetLevel) - 1 && currentLevel < Power2(targetLevel + 1) - 1 then\n    if currentLevel < |h.elements| then [h.elements[currentLevel]] + getLevelHelper(h, targetLevel, currentLevel + 1)\n    else []\n  else getLevelHelper(h, targetLevel, currentLevel + 1)\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1\n  else 2 * Power2(n - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma EmptyHeapIsMinHeap()\n  ensures isMinHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma EmptyHeapIsMaxHeap()\n  ensures isMaxHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma SingletonIsMinHeap(x: int)\n  ensures isMinHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma SingletonIsMaxHeap(x: int)\n  ensures isMaxHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma MinHeapRootIsMinimum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] <= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MinHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MinHeapPathToRoot(h: Heap, i: nat)\n  requires isMinHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] <= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] <= h.elements[i];\n  } else {\n    assert h.elements[parent(i)] <= h.elements[i];\n    MinHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma MaxHeapRootIsMaximum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] >= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MaxHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MaxHeapPathToRoot(h: Heap, i: nat)\n  requires isMaxHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] >= h.elements[i]\n{\n  if parent(i) == 0 {\n    \n/*[CODE HERE]*/\n  } else {\n    assert h.elements[parent(i)] >= h.elements[i];\n    MaxHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma ParentChildRelation(i: nat)\n  requires i > 0\n  ensures leftChild(parent(i)) == i || rightChild(parent(i)) == i\n  ensures leftChild(parent(i)) == i <==> i % 2 == 1\n  ensures rightChild(parent(i)) == i <==> i % 2 == 0\n{\n  var p := parent(i);\n  assert p == (i - 1) / 2;\n  assert leftChild(p) == 2 * p + 1;\n  assert rightChild(p) == 2 * p + 2;\n\n  if i % 2 == 1 {\n    assert i == 2 * ((i - 1) / 2) + 1;\n    assert leftChild(p) == i;\n  } else {\n    assert i % 2 == 0;\n    assert i == 2 * ((i - 1) / 2) + 2;\n    assert rightChild(p) == i;\n  }\n}\n\nlemma HeapHeightBound(h: Heap)\n  ensures heapHeight(h) <= |h.elements|\n{\n  if |h.elements| == 0 {\n    assert heapHeight(h) == 0;\n  } else {\n    Log2FloorBound(|h.elements|);\n  }\n}\n\nlemma Log2FloorBound(n: nat)\n  requires n > 0\n  ensures log2Floor(n) < n\n  decreases n\n{\n  if n == 1 {\n    assert log2Floor(1) == 0;\n  } else {\n    Log2FloorBound(n / 2);\n    assert log2Floor(n) == 1 + log2Floor(n / 2);\n    assert n / 2 < n;\n  }\n}\n\nlemma SwapPreservesMultiset(s: seq<int>, i: nat, j: nat)\n  requires i < |s| && j < |s|\n  ensures multiset(swap(s, i, j)) == multiset(s)\n{\n  var s' := swap(s, i, j);\n  assert s'[i] == s[j];\n  assert s'[j] == s[i];\n  forall k | 0 <= k < |s| && k != i && k != j\n    ensures s'[k] == s[k]\n  {\n    // Elements other than i and j are unchanged\n  }\n}", "output": "assert h.elements[0] >= h.elements[i];"}, {"id": "example_ParentChildRelation_0", "type": "assert", "program": "// Min-heap operations: insert, extractMin, heapify with heap property\n\ndatatype Heap = Heap(elements: seq<int>)\n\n// Check if heap is empty\npredicate {:spec} heapIsEmpty(h: Heap)\n{\n  |h.elements| == 0\n}\n\n// Get heap size\nfunction {:spec} heapSize(h: Heap): nat\n{\n  |h.elements|\n}\n\n// Parent index in heap\nfunction {:spec} parent(i: nat): nat\n  requires i > 0\n{\n  (i - 1) / 2\n}\n\n// Left child index\nfunction {:spec} leftChild(i: nat): nat\n{\n  2 * i + 1\n}\n\n// Right child index\nfunction {:spec} rightChild(i: nat): nat\n{\n  2 * i + 2\n}\n\n// Check min-heap property\npredicate {:spec} isMinHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] <= h.elements[i]\n}\n\n// Check max-heap property\npredicate {:spec} isMaxHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] >= h.elements[i]\n}\n\n// Get minimum element (root of min-heap)\nfunction {:spec} getMin(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n{\n  h.elements[0]\n}\n\n// Get maximum element (root of max-heap)\nfunction {:spec} getMax(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n{\n  h.elements[0]\n}\n\n// Check if element exists in heap\npredicate {:spec} heapContains(h: Heap, x: int)\n{\n  x in h.elements\n}\n\n// Create empty heap\nfunction {:spec} emptyHeap(): Heap\n{\n  Heap([])\n}\n\n// Create heap from single element\nfunction {:spec} singletonHeap(x: int): Heap\n{\n  Heap([x])\n}\n\n// Swap two elements in sequence\nfunction {:spec} swap(s: seq<int>, i: nat, j: nat): seq<int>\n  requires i < |s| && j < |s|\n{\n  s[i := s[j]][j := s[i]]\n}\n\n// Check if heap is complete binary tree (always true for array representation)\npredicate {:spec} isComplete(h: Heap)\n{\n  true  // Array representation is always complete\n}\n\n// Get height of heap\nfunction {:spec} heapHeight(h: Heap): nat\n{\n  if |h.elements| == 0 then 0\n  else log2Floor(|h.elements|) + 1\n}\n\n// Floor of log base 2\nfunction {:spec} log2Floor(n: nat): nat\n  requires n > 0\n  decreases n\n{\n  if n == 1 then 0\n  else 1 + log2Floor(n / 2)\n}\n\n// Check if index is valid\npredicate {:spec} validIndex(h: Heap, i: nat)\n{\n  i < |h.elements|\n}\n\n// Get all elements at a given level\nfunction {:spec} getLevel(h: Heap, level: nat): seq<int>\n{\n  getLevelHelper(h, level, 0)\n}\n\nfunction getLevelHelper(h: Heap, targetLevel: nat, currentLevel: nat): seq<int>\n  decreases |h.elements| - currentLevel\n{\n  if currentLevel >= |h.elements| || currentLevel >= Power2(targetLevel) then []\n  else if currentLevel >= Power2(targetLevel) - 1 && currentLevel < Power2(targetLevel + 1) - 1 then\n    if currentLevel < |h.elements| then [h.elements[currentLevel]] + getLevelHelper(h, targetLevel, currentLevel + 1)\n    else []\n  else getLevelHelper(h, targetLevel, currentLevel + 1)\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1\n  else 2 * Power2(n - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma EmptyHeapIsMinHeap()\n  ensures isMinHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma EmptyHeapIsMaxHeap()\n  ensures isMaxHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma SingletonIsMinHeap(x: int)\n  ensures isMinHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma SingletonIsMaxHeap(x: int)\n  ensures isMaxHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma MinHeapRootIsMinimum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] <= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MinHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MinHeapPathToRoot(h: Heap, i: nat)\n  requires isMinHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] <= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] <= h.elements[i];\n  } else {\n    assert h.elements[parent(i)] <= h.elements[i];\n    MinHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma MaxHeapRootIsMaximum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] >= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MaxHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MaxHeapPathToRoot(h: Heap, i: nat)\n  requires isMaxHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] >= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] >= h.elements[i];\n  } else {\n    assert h.elements[parent(i)] >= h.elements[i];\n    MaxHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma ParentChildRelation(i: nat)\n  requires i > 0\n  ensures leftChild(parent(i)) == i || rightChild(parent(i)) == i\n  ensures leftChild(parent(i)) == i <==> i % 2 == 1\n  ensures rightChild(parent(i)) == i <==> i % 2 == 0\n{\n  var p := parent(i);\n  assert p == (i - 1) / 2;\n  assert leftChild(p) == 2 * p + 1;\n  assert rightChild(p) == 2 * p + 2;\n\n  if i % 2 == 1 {\n    assert i == 2 * ((i - 1) / 2) + 1;\n    assert leftChild(p) == i;\n  } else {\n    assert i % 2 == 0;\n    assert i == 2 * ((i - 1) / 2) + 2;\n    \n/*[CODE HERE]*/\n  }\n}\n\nlemma HeapHeightBound(h: Heap)\n  ensures heapHeight(h) <= |h.elements|\n{\n  if |h.elements| == 0 {\n    assert heapHeight(h) == 0;\n  } else {\n    Log2FloorBound(|h.elements|);\n  }\n}\n\nlemma Log2FloorBound(n: nat)\n  requires n > 0\n  ensures log2Floor(n) < n\n  decreases n\n{\n  if n == 1 {\n    assert log2Floor(1) == 0;\n  } else {\n    Log2FloorBound(n / 2);\n    assert log2Floor(n) == 1 + log2Floor(n / 2);\n    assert n / 2 < n;\n  }\n}\n\nlemma SwapPreservesMultiset(s: seq<int>, i: nat, j: nat)\n  requires i < |s| && j < |s|\n  ensures multiset(swap(s, i, j)) == multiset(s)\n{\n  var s' := swap(s, i, j);\n  assert s'[i] == s[j];\n  assert s'[j] == s[i];\n  forall k | 0 <= k < |s| && k != i && k != j\n    ensures s'[k] == s[k]\n  {\n    // Elements other than i and j are unchanged\n  }\n}", "output": "assert rightChild(p) == i;"}, {"id": "example_ParentChildRelation_1", "type": "assert", "program": "// Min-heap operations: insert, extractMin, heapify with heap property\n\ndatatype Heap = Heap(elements: seq<int>)\n\n// Check if heap is empty\npredicate {:spec} heapIsEmpty(h: Heap)\n{\n  |h.elements| == 0\n}\n\n// Get heap size\nfunction {:spec} heapSize(h: Heap): nat\n{\n  |h.elements|\n}\n\n// Parent index in heap\nfunction {:spec} parent(i: nat): nat\n  requires i > 0\n{\n  (i - 1) / 2\n}\n\n// Left child index\nfunction {:spec} leftChild(i: nat): nat\n{\n  2 * i + 1\n}\n\n// Right child index\nfunction {:spec} rightChild(i: nat): nat\n{\n  2 * i + 2\n}\n\n// Check min-heap property\npredicate {:spec} isMinHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] <= h.elements[i]\n}\n\n// Check max-heap property\npredicate {:spec} isMaxHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] >= h.elements[i]\n}\n\n// Get minimum element (root of min-heap)\nfunction {:spec} getMin(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n{\n  h.elements[0]\n}\n\n// Get maximum element (root of max-heap)\nfunction {:spec} getMax(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n{\n  h.elements[0]\n}\n\n// Check if element exists in heap\npredicate {:spec} heapContains(h: Heap, x: int)\n{\n  x in h.elements\n}\n\n// Create empty heap\nfunction {:spec} emptyHeap(): Heap\n{\n  Heap([])\n}\n\n// Create heap from single element\nfunction {:spec} singletonHeap(x: int): Heap\n{\n  Heap([x])\n}\n\n// Swap two elements in sequence\nfunction {:spec} swap(s: seq<int>, i: nat, j: nat): seq<int>\n  requires i < |s| && j < |s|\n{\n  s[i := s[j]][j := s[i]]\n}\n\n// Check if heap is complete binary tree (always true for array representation)\npredicate {:spec} isComplete(h: Heap)\n{\n  true  // Array representation is always complete\n}\n\n// Get height of heap\nfunction {:spec} heapHeight(h: Heap): nat\n{\n  if |h.elements| == 0 then 0\n  else log2Floor(|h.elements|) + 1\n}\n\n// Floor of log base 2\nfunction {:spec} log2Floor(n: nat): nat\n  requires n > 0\n  decreases n\n{\n  if n == 1 then 0\n  else 1 + log2Floor(n / 2)\n}\n\n// Check if index is valid\npredicate {:spec} validIndex(h: Heap, i: nat)\n{\n  i < |h.elements|\n}\n\n// Get all elements at a given level\nfunction {:spec} getLevel(h: Heap, level: nat): seq<int>\n{\n  getLevelHelper(h, level, 0)\n}\n\nfunction getLevelHelper(h: Heap, targetLevel: nat, currentLevel: nat): seq<int>\n  decreases |h.elements| - currentLevel\n{\n  if currentLevel >= |h.elements| || currentLevel >= Power2(targetLevel) then []\n  else if currentLevel >= Power2(targetLevel) - 1 && currentLevel < Power2(targetLevel + 1) - 1 then\n    if currentLevel < |h.elements| then [h.elements[currentLevel]] + getLevelHelper(h, targetLevel, currentLevel + 1)\n    else []\n  else getLevelHelper(h, targetLevel, currentLevel + 1)\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1\n  else 2 * Power2(n - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma EmptyHeapIsMinHeap()\n  ensures isMinHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma EmptyHeapIsMaxHeap()\n  ensures isMaxHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma SingletonIsMinHeap(x: int)\n  ensures isMinHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma SingletonIsMaxHeap(x: int)\n  ensures isMaxHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma MinHeapRootIsMinimum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] <= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MinHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MinHeapPathToRoot(h: Heap, i: nat)\n  requires isMinHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] <= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] <= h.elements[i];\n  } else {\n    assert h.elements[parent(i)] <= h.elements[i];\n    MinHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma MaxHeapRootIsMaximum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] >= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MaxHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MaxHeapPathToRoot(h: Heap, i: nat)\n  requires isMaxHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] >= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] >= h.elements[i];\n  } else {\n    assert h.elements[parent(i)] >= h.elements[i];\n    MaxHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma ParentChildRelation(i: nat)\n  requires i > 0\n  ensures leftChild(parent(i)) == i || rightChild(parent(i)) == i\n  ensures leftChild(parent(i)) == i <==> i % 2 == 1\n  ensures rightChild(parent(i)) == i <==> i % 2 == 0\n{\n  var p := parent(i);\n  assert p == (i - 1) / 2;\n  assert leftChild(p) == 2 * p + 1;\n  assert rightChild(p) == 2 * p + 2;\n\n  if i % 2 == 1 {\n    assert i == 2 * ((i - 1) / 2) + 1;\n    assert leftChild(p) == i;\n  } else {\n    assert i % 2 == 0;\n    \n/*[CODE HERE]*/\n    assert rightChild(p) == i;\n  }\n}\n\nlemma HeapHeightBound(h: Heap)\n  ensures heapHeight(h) <= |h.elements|\n{\n  if |h.elements| == 0 {\n    assert heapHeight(h) == 0;\n  } else {\n    Log2FloorBound(|h.elements|);\n  }\n}\n\nlemma Log2FloorBound(n: nat)\n  requires n > 0\n  ensures log2Floor(n) < n\n  decreases n\n{\n  if n == 1 {\n    assert log2Floor(1) == 0;\n  } else {\n    Log2FloorBound(n / 2);\n    assert log2Floor(n) == 1 + log2Floor(n / 2);\n    assert n / 2 < n;\n  }\n}\n\nlemma SwapPreservesMultiset(s: seq<int>, i: nat, j: nat)\n  requires i < |s| && j < |s|\n  ensures multiset(swap(s, i, j)) == multiset(s)\n{\n  var s' := swap(s, i, j);\n  assert s'[i] == s[j];\n  assert s'[j] == s[i];\n  forall k | 0 <= k < |s| && k != i && k != j\n    ensures s'[k] == s[k]\n  {\n    // Elements other than i and j are unchanged\n  }\n}", "output": "assert i == 2 * ((i - 1) / 2) + 2;"}, {"id": "example_ParentChildRelation_2", "type": "assert", "program": "// Min-heap operations: insert, extractMin, heapify with heap property\n\ndatatype Heap = Heap(elements: seq<int>)\n\n// Check if heap is empty\npredicate {:spec} heapIsEmpty(h: Heap)\n{\n  |h.elements| == 0\n}\n\n// Get heap size\nfunction {:spec} heapSize(h: Heap): nat\n{\n  |h.elements|\n}\n\n// Parent index in heap\nfunction {:spec} parent(i: nat): nat\n  requires i > 0\n{\n  (i - 1) / 2\n}\n\n// Left child index\nfunction {:spec} leftChild(i: nat): nat\n{\n  2 * i + 1\n}\n\n// Right child index\nfunction {:spec} rightChild(i: nat): nat\n{\n  2 * i + 2\n}\n\n// Check min-heap property\npredicate {:spec} isMinHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] <= h.elements[i]\n}\n\n// Check max-heap property\npredicate {:spec} isMaxHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] >= h.elements[i]\n}\n\n// Get minimum element (root of min-heap)\nfunction {:spec} getMin(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n{\n  h.elements[0]\n}\n\n// Get maximum element (root of max-heap)\nfunction {:spec} getMax(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n{\n  h.elements[0]\n}\n\n// Check if element exists in heap\npredicate {:spec} heapContains(h: Heap, x: int)\n{\n  x in h.elements\n}\n\n// Create empty heap\nfunction {:spec} emptyHeap(): Heap\n{\n  Heap([])\n}\n\n// Create heap from single element\nfunction {:spec} singletonHeap(x: int): Heap\n{\n  Heap([x])\n}\n\n// Swap two elements in sequence\nfunction {:spec} swap(s: seq<int>, i: nat, j: nat): seq<int>\n  requires i < |s| && j < |s|\n{\n  s[i := s[j]][j := s[i]]\n}\n\n// Check if heap is complete binary tree (always true for array representation)\npredicate {:spec} isComplete(h: Heap)\n{\n  true  // Array representation is always complete\n}\n\n// Get height of heap\nfunction {:spec} heapHeight(h: Heap): nat\n{\n  if |h.elements| == 0 then 0\n  else log2Floor(|h.elements|) + 1\n}\n\n// Floor of log base 2\nfunction {:spec} log2Floor(n: nat): nat\n  requires n > 0\n  decreases n\n{\n  if n == 1 then 0\n  else 1 + log2Floor(n / 2)\n}\n\n// Check if index is valid\npredicate {:spec} validIndex(h: Heap, i: nat)\n{\n  i < |h.elements|\n}\n\n// Get all elements at a given level\nfunction {:spec} getLevel(h: Heap, level: nat): seq<int>\n{\n  getLevelHelper(h, level, 0)\n}\n\nfunction getLevelHelper(h: Heap, targetLevel: nat, currentLevel: nat): seq<int>\n  decreases |h.elements| - currentLevel\n{\n  if currentLevel >= |h.elements| || currentLevel >= Power2(targetLevel) then []\n  else if currentLevel >= Power2(targetLevel) - 1 && currentLevel < Power2(targetLevel + 1) - 1 then\n    if currentLevel < |h.elements| then [h.elements[currentLevel]] + getLevelHelper(h, targetLevel, currentLevel + 1)\n    else []\n  else getLevelHelper(h, targetLevel, currentLevel + 1)\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1\n  else 2 * Power2(n - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma EmptyHeapIsMinHeap()\n  ensures isMinHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma EmptyHeapIsMaxHeap()\n  ensures isMaxHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma SingletonIsMinHeap(x: int)\n  ensures isMinHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma SingletonIsMaxHeap(x: int)\n  ensures isMaxHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma MinHeapRootIsMinimum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] <= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MinHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MinHeapPathToRoot(h: Heap, i: nat)\n  requires isMinHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] <= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] <= h.elements[i];\n  } else {\n    assert h.elements[parent(i)] <= h.elements[i];\n    MinHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma MaxHeapRootIsMaximum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] >= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MaxHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MaxHeapPathToRoot(h: Heap, i: nat)\n  requires isMaxHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] >= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] >= h.elements[i];\n  } else {\n    assert h.elements[parent(i)] >= h.elements[i];\n    MaxHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma ParentChildRelation(i: nat)\n  requires i > 0\n  ensures leftChild(parent(i)) == i || rightChild(parent(i)) == i\n  ensures leftChild(parent(i)) == i <==> i % 2 == 1\n  ensures rightChild(parent(i)) == i <==> i % 2 == 0\n{\n  var p := parent(i);\n  assert p == (i - 1) / 2;\n  assert leftChild(p) == 2 * p + 1;\n  assert rightChild(p) == 2 * p + 2;\n\n  if i % 2 == 1 {\n    assert i == 2 * ((i - 1) / 2) + 1;\n    assert leftChild(p) == i;\n  } else {\n    \n/*[CODE HERE]*/\n    assert i == 2 * ((i - 1) / 2) + 2;\n    assert rightChild(p) == i;\n  }\n}\n\nlemma HeapHeightBound(h: Heap)\n  ensures heapHeight(h) <= |h.elements|\n{\n  if |h.elements| == 0 {\n    assert heapHeight(h) == 0;\n  } else {\n    Log2FloorBound(|h.elements|);\n  }\n}\n\nlemma Log2FloorBound(n: nat)\n  requires n > 0\n  ensures log2Floor(n) < n\n  decreases n\n{\n  if n == 1 {\n    assert log2Floor(1) == 0;\n  } else {\n    Log2FloorBound(n / 2);\n    assert log2Floor(n) == 1 + log2Floor(n / 2);\n    assert n / 2 < n;\n  }\n}\n\nlemma SwapPreservesMultiset(s: seq<int>, i: nat, j: nat)\n  requires i < |s| && j < |s|\n  ensures multiset(swap(s, i, j)) == multiset(s)\n{\n  var s' := swap(s, i, j);\n  assert s'[i] == s[j];\n  assert s'[j] == s[i];\n  forall k | 0 <= k < |s| && k != i && k != j\n    ensures s'[k] == s[k]\n  {\n    // Elements other than i and j are unchanged\n  }\n}", "output": "assert i % 2 == 0;"}, {"id": "example_ParentChildRelation_3", "type": "assert", "program": "// Min-heap operations: insert, extractMin, heapify with heap property\n\ndatatype Heap = Heap(elements: seq<int>)\n\n// Check if heap is empty\npredicate {:spec} heapIsEmpty(h: Heap)\n{\n  |h.elements| == 0\n}\n\n// Get heap size\nfunction {:spec} heapSize(h: Heap): nat\n{\n  |h.elements|\n}\n\n// Parent index in heap\nfunction {:spec} parent(i: nat): nat\n  requires i > 0\n{\n  (i - 1) / 2\n}\n\n// Left child index\nfunction {:spec} leftChild(i: nat): nat\n{\n  2 * i + 1\n}\n\n// Right child index\nfunction {:spec} rightChild(i: nat): nat\n{\n  2 * i + 2\n}\n\n// Check min-heap property\npredicate {:spec} isMinHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] <= h.elements[i]\n}\n\n// Check max-heap property\npredicate {:spec} isMaxHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] >= h.elements[i]\n}\n\n// Get minimum element (root of min-heap)\nfunction {:spec} getMin(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n{\n  h.elements[0]\n}\n\n// Get maximum element (root of max-heap)\nfunction {:spec} getMax(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n{\n  h.elements[0]\n}\n\n// Check if element exists in heap\npredicate {:spec} heapContains(h: Heap, x: int)\n{\n  x in h.elements\n}\n\n// Create empty heap\nfunction {:spec} emptyHeap(): Heap\n{\n  Heap([])\n}\n\n// Create heap from single element\nfunction {:spec} singletonHeap(x: int): Heap\n{\n  Heap([x])\n}\n\n// Swap two elements in sequence\nfunction {:spec} swap(s: seq<int>, i: nat, j: nat): seq<int>\n  requires i < |s| && j < |s|\n{\n  s[i := s[j]][j := s[i]]\n}\n\n// Check if heap is complete binary tree (always true for array representation)\npredicate {:spec} isComplete(h: Heap)\n{\n  true  // Array representation is always complete\n}\n\n// Get height of heap\nfunction {:spec} heapHeight(h: Heap): nat\n{\n  if |h.elements| == 0 then 0\n  else log2Floor(|h.elements|) + 1\n}\n\n// Floor of log base 2\nfunction {:spec} log2Floor(n: nat): nat\n  requires n > 0\n  decreases n\n{\n  if n == 1 then 0\n  else 1 + log2Floor(n / 2)\n}\n\n// Check if index is valid\npredicate {:spec} validIndex(h: Heap, i: nat)\n{\n  i < |h.elements|\n}\n\n// Get all elements at a given level\nfunction {:spec} getLevel(h: Heap, level: nat): seq<int>\n{\n  getLevelHelper(h, level, 0)\n}\n\nfunction getLevelHelper(h: Heap, targetLevel: nat, currentLevel: nat): seq<int>\n  decreases |h.elements| - currentLevel\n{\n  if currentLevel >= |h.elements| || currentLevel >= Power2(targetLevel) then []\n  else if currentLevel >= Power2(targetLevel) - 1 && currentLevel < Power2(targetLevel + 1) - 1 then\n    if currentLevel < |h.elements| then [h.elements[currentLevel]] + getLevelHelper(h, targetLevel, currentLevel + 1)\n    else []\n  else getLevelHelper(h, targetLevel, currentLevel + 1)\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1\n  else 2 * Power2(n - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma EmptyHeapIsMinHeap()\n  ensures isMinHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma EmptyHeapIsMaxHeap()\n  ensures isMaxHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma SingletonIsMinHeap(x: int)\n  ensures isMinHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma SingletonIsMaxHeap(x: int)\n  ensures isMaxHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma MinHeapRootIsMinimum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] <= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MinHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MinHeapPathToRoot(h: Heap, i: nat)\n  requires isMinHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] <= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] <= h.elements[i];\n  } else {\n    assert h.elements[parent(i)] <= h.elements[i];\n    MinHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma MaxHeapRootIsMaximum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] >= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MaxHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MaxHeapPathToRoot(h: Heap, i: nat)\n  requires isMaxHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] >= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] >= h.elements[i];\n  } else {\n    assert h.elements[parent(i)] >= h.elements[i];\n    MaxHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma ParentChildRelation(i: nat)\n  requires i > 0\n  ensures leftChild(parent(i)) == i || rightChild(parent(i)) == i\n  ensures leftChild(parent(i)) == i <==> i % 2 == 1\n  ensures rightChild(parent(i)) == i <==> i % 2 == 0\n{\n  var p := parent(i);\n  assert p == (i - 1) / 2;\n  assert leftChild(p) == 2 * p + 1;\n  assert rightChild(p) == 2 * p + 2;\n\n  if i % 2 == 1 {\n    assert i == 2 * ((i - 1) / 2) + 1;\n    \n/*[CODE HERE]*/\n  } else {\n    assert i % 2 == 0;\n    assert i == 2 * ((i - 1) / 2) + 2;\n    assert rightChild(p) == i;\n  }\n}\n\nlemma HeapHeightBound(h: Heap)\n  ensures heapHeight(h) <= |h.elements|\n{\n  if |h.elements| == 0 {\n    assert heapHeight(h) == 0;\n  } else {\n    Log2FloorBound(|h.elements|);\n  }\n}\n\nlemma Log2FloorBound(n: nat)\n  requires n > 0\n  ensures log2Floor(n) < n\n  decreases n\n{\n  if n == 1 {\n    assert log2Floor(1) == 0;\n  } else {\n    Log2FloorBound(n / 2);\n    assert log2Floor(n) == 1 + log2Floor(n / 2);\n    assert n / 2 < n;\n  }\n}\n\nlemma SwapPreservesMultiset(s: seq<int>, i: nat, j: nat)\n  requires i < |s| && j < |s|\n  ensures multiset(swap(s, i, j)) == multiset(s)\n{\n  var s' := swap(s, i, j);\n  assert s'[i] == s[j];\n  assert s'[j] == s[i];\n  forall k | 0 <= k < |s| && k != i && k != j\n    ensures s'[k] == s[k]\n  {\n    // Elements other than i and j are unchanged\n  }\n}", "output": "assert leftChild(p) == i;"}, {"id": "example_ParentChildRelation_4", "type": "assert", "program": "// Min-heap operations: insert, extractMin, heapify with heap property\n\ndatatype Heap = Heap(elements: seq<int>)\n\n// Check if heap is empty\npredicate {:spec} heapIsEmpty(h: Heap)\n{\n  |h.elements| == 0\n}\n\n// Get heap size\nfunction {:spec} heapSize(h: Heap): nat\n{\n  |h.elements|\n}\n\n// Parent index in heap\nfunction {:spec} parent(i: nat): nat\n  requires i > 0\n{\n  (i - 1) / 2\n}\n\n// Left child index\nfunction {:spec} leftChild(i: nat): nat\n{\n  2 * i + 1\n}\n\n// Right child index\nfunction {:spec} rightChild(i: nat): nat\n{\n  2 * i + 2\n}\n\n// Check min-heap property\npredicate {:spec} isMinHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] <= h.elements[i]\n}\n\n// Check max-heap property\npredicate {:spec} isMaxHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] >= h.elements[i]\n}\n\n// Get minimum element (root of min-heap)\nfunction {:spec} getMin(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n{\n  h.elements[0]\n}\n\n// Get maximum element (root of max-heap)\nfunction {:spec} getMax(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n{\n  h.elements[0]\n}\n\n// Check if element exists in heap\npredicate {:spec} heapContains(h: Heap, x: int)\n{\n  x in h.elements\n}\n\n// Create empty heap\nfunction {:spec} emptyHeap(): Heap\n{\n  Heap([])\n}\n\n// Create heap from single element\nfunction {:spec} singletonHeap(x: int): Heap\n{\n  Heap([x])\n}\n\n// Swap two elements in sequence\nfunction {:spec} swap(s: seq<int>, i: nat, j: nat): seq<int>\n  requires i < |s| && j < |s|\n{\n  s[i := s[j]][j := s[i]]\n}\n\n// Check if heap is complete binary tree (always true for array representation)\npredicate {:spec} isComplete(h: Heap)\n{\n  true  // Array representation is always complete\n}\n\n// Get height of heap\nfunction {:spec} heapHeight(h: Heap): nat\n{\n  if |h.elements| == 0 then 0\n  else log2Floor(|h.elements|) + 1\n}\n\n// Floor of log base 2\nfunction {:spec} log2Floor(n: nat): nat\n  requires n > 0\n  decreases n\n{\n  if n == 1 then 0\n  else 1 + log2Floor(n / 2)\n}\n\n// Check if index is valid\npredicate {:spec} validIndex(h: Heap, i: nat)\n{\n  i < |h.elements|\n}\n\n// Get all elements at a given level\nfunction {:spec} getLevel(h: Heap, level: nat): seq<int>\n{\n  getLevelHelper(h, level, 0)\n}\n\nfunction getLevelHelper(h: Heap, targetLevel: nat, currentLevel: nat): seq<int>\n  decreases |h.elements| - currentLevel\n{\n  if currentLevel >= |h.elements| || currentLevel >= Power2(targetLevel) then []\n  else if currentLevel >= Power2(targetLevel) - 1 && currentLevel < Power2(targetLevel + 1) - 1 then\n    if currentLevel < |h.elements| then [h.elements[currentLevel]] + getLevelHelper(h, targetLevel, currentLevel + 1)\n    else []\n  else getLevelHelper(h, targetLevel, currentLevel + 1)\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1\n  else 2 * Power2(n - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma EmptyHeapIsMinHeap()\n  ensures isMinHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma EmptyHeapIsMaxHeap()\n  ensures isMaxHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma SingletonIsMinHeap(x: int)\n  ensures isMinHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma SingletonIsMaxHeap(x: int)\n  ensures isMaxHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma MinHeapRootIsMinimum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] <= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MinHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MinHeapPathToRoot(h: Heap, i: nat)\n  requires isMinHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] <= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] <= h.elements[i];\n  } else {\n    assert h.elements[parent(i)] <= h.elements[i];\n    MinHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma MaxHeapRootIsMaximum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] >= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MaxHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MaxHeapPathToRoot(h: Heap, i: nat)\n  requires isMaxHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] >= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] >= h.elements[i];\n  } else {\n    assert h.elements[parent(i)] >= h.elements[i];\n    MaxHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma ParentChildRelation(i: nat)\n  requires i > 0\n  ensures leftChild(parent(i)) == i || rightChild(parent(i)) == i\n  ensures leftChild(parent(i)) == i <==> i % 2 == 1\n  ensures rightChild(parent(i)) == i <==> i % 2 == 0\n{\n  var p := parent(i);\n  assert p == (i - 1) / 2;\n  assert leftChild(p) == 2 * p + 1;\n  assert rightChild(p) == 2 * p + 2;\n\n  if i % 2 == 1 {\n    \n/*[CODE HERE]*/\n    assert leftChild(p) == i;\n  } else {\n    assert i % 2 == 0;\n    assert i == 2 * ((i - 1) / 2) + 2;\n    assert rightChild(p) == i;\n  }\n}\n\nlemma HeapHeightBound(h: Heap)\n  ensures heapHeight(h) <= |h.elements|\n{\n  if |h.elements| == 0 {\n    assert heapHeight(h) == 0;\n  } else {\n    Log2FloorBound(|h.elements|);\n  }\n}\n\nlemma Log2FloorBound(n: nat)\n  requires n > 0\n  ensures log2Floor(n) < n\n  decreases n\n{\n  if n == 1 {\n    assert log2Floor(1) == 0;\n  } else {\n    Log2FloorBound(n / 2);\n    assert log2Floor(n) == 1 + log2Floor(n / 2);\n    assert n / 2 < n;\n  }\n}\n\nlemma SwapPreservesMultiset(s: seq<int>, i: nat, j: nat)\n  requires i < |s| && j < |s|\n  ensures multiset(swap(s, i, j)) == multiset(s)\n{\n  var s' := swap(s, i, j);\n  assert s'[i] == s[j];\n  assert s'[j] == s[i];\n  forall k | 0 <= k < |s| && k != i && k != j\n    ensures s'[k] == s[k]\n  {\n    // Elements other than i and j are unchanged\n  }\n}", "output": "assert i == 2 * ((i - 1) / 2) + 1;"}, {"id": "example_ParentChildRelation_5", "type": "assert", "program": "// Min-heap operations: insert, extractMin, heapify with heap property\n\ndatatype Heap = Heap(elements: seq<int>)\n\n// Check if heap is empty\npredicate {:spec} heapIsEmpty(h: Heap)\n{\n  |h.elements| == 0\n}\n\n// Get heap size\nfunction {:spec} heapSize(h: Heap): nat\n{\n  |h.elements|\n}\n\n// Parent index in heap\nfunction {:spec} parent(i: nat): nat\n  requires i > 0\n{\n  (i - 1) / 2\n}\n\n// Left child index\nfunction {:spec} leftChild(i: nat): nat\n{\n  2 * i + 1\n}\n\n// Right child index\nfunction {:spec} rightChild(i: nat): nat\n{\n  2 * i + 2\n}\n\n// Check min-heap property\npredicate {:spec} isMinHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] <= h.elements[i]\n}\n\n// Check max-heap property\npredicate {:spec} isMaxHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] >= h.elements[i]\n}\n\n// Get minimum element (root of min-heap)\nfunction {:spec} getMin(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n{\n  h.elements[0]\n}\n\n// Get maximum element (root of max-heap)\nfunction {:spec} getMax(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n{\n  h.elements[0]\n}\n\n// Check if element exists in heap\npredicate {:spec} heapContains(h: Heap, x: int)\n{\n  x in h.elements\n}\n\n// Create empty heap\nfunction {:spec} emptyHeap(): Heap\n{\n  Heap([])\n}\n\n// Create heap from single element\nfunction {:spec} singletonHeap(x: int): Heap\n{\n  Heap([x])\n}\n\n// Swap two elements in sequence\nfunction {:spec} swap(s: seq<int>, i: nat, j: nat): seq<int>\n  requires i < |s| && j < |s|\n{\n  s[i := s[j]][j := s[i]]\n}\n\n// Check if heap is complete binary tree (always true for array representation)\npredicate {:spec} isComplete(h: Heap)\n{\n  true  // Array representation is always complete\n}\n\n// Get height of heap\nfunction {:spec} heapHeight(h: Heap): nat\n{\n  if |h.elements| == 0 then 0\n  else log2Floor(|h.elements|) + 1\n}\n\n// Floor of log base 2\nfunction {:spec} log2Floor(n: nat): nat\n  requires n > 0\n  decreases n\n{\n  if n == 1 then 0\n  else 1 + log2Floor(n / 2)\n}\n\n// Check if index is valid\npredicate {:spec} validIndex(h: Heap, i: nat)\n{\n  i < |h.elements|\n}\n\n// Get all elements at a given level\nfunction {:spec} getLevel(h: Heap, level: nat): seq<int>\n{\n  getLevelHelper(h, level, 0)\n}\n\nfunction getLevelHelper(h: Heap, targetLevel: nat, currentLevel: nat): seq<int>\n  decreases |h.elements| - currentLevel\n{\n  if currentLevel >= |h.elements| || currentLevel >= Power2(targetLevel) then []\n  else if currentLevel >= Power2(targetLevel) - 1 && currentLevel < Power2(targetLevel + 1) - 1 then\n    if currentLevel < |h.elements| then [h.elements[currentLevel]] + getLevelHelper(h, targetLevel, currentLevel + 1)\n    else []\n  else getLevelHelper(h, targetLevel, currentLevel + 1)\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1\n  else 2 * Power2(n - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma EmptyHeapIsMinHeap()\n  ensures isMinHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma EmptyHeapIsMaxHeap()\n  ensures isMaxHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma SingletonIsMinHeap(x: int)\n  ensures isMinHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma SingletonIsMaxHeap(x: int)\n  ensures isMaxHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma MinHeapRootIsMinimum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] <= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MinHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MinHeapPathToRoot(h: Heap, i: nat)\n  requires isMinHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] <= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] <= h.elements[i];\n  } else {\n    assert h.elements[parent(i)] <= h.elements[i];\n    MinHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma MaxHeapRootIsMaximum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] >= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MaxHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MaxHeapPathToRoot(h: Heap, i: nat)\n  requires isMaxHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] >= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] >= h.elements[i];\n  } else {\n    assert h.elements[parent(i)] >= h.elements[i];\n    MaxHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma ParentChildRelation(i: nat)\n  requires i > 0\n  ensures leftChild(parent(i)) == i || rightChild(parent(i)) == i\n  ensures leftChild(parent(i)) == i <==> i % 2 == 1\n  ensures rightChild(parent(i)) == i <==> i % 2 == 0\n{\n  var p := parent(i);\n  assert p == (i - 1) / 2;\n  assert leftChild(p) == 2 * p + 1;\n  \n/*[CODE HERE]*/\n\n  if i % 2 == 1 {\n    assert i == 2 * ((i - 1) / 2) + 1;\n    assert leftChild(p) == i;\n  } else {\n    assert i % 2 == 0;\n    assert i == 2 * ((i - 1) / 2) + 2;\n    assert rightChild(p) == i;\n  }\n}\n\nlemma HeapHeightBound(h: Heap)\n  ensures heapHeight(h) <= |h.elements|\n{\n  if |h.elements| == 0 {\n    assert heapHeight(h) == 0;\n  } else {\n    Log2FloorBound(|h.elements|);\n  }\n}\n\nlemma Log2FloorBound(n: nat)\n  requires n > 0\n  ensures log2Floor(n) < n\n  decreases n\n{\n  if n == 1 {\n    assert log2Floor(1) == 0;\n  } else {\n    Log2FloorBound(n / 2);\n    assert log2Floor(n) == 1 + log2Floor(n / 2);\n    assert n / 2 < n;\n  }\n}\n\nlemma SwapPreservesMultiset(s: seq<int>, i: nat, j: nat)\n  requires i < |s| && j < |s|\n  ensures multiset(swap(s, i, j)) == multiset(s)\n{\n  var s' := swap(s, i, j);\n  assert s'[i] == s[j];\n  assert s'[j] == s[i];\n  forall k | 0 <= k < |s| && k != i && k != j\n    ensures s'[k] == s[k]\n  {\n    // Elements other than i and j are unchanged\n  }\n}", "output": "assert rightChild(p) == 2 * p + 2;"}, {"id": "example_ParentChildRelation_6", "type": "assert", "program": "// Min-heap operations: insert, extractMin, heapify with heap property\n\ndatatype Heap = Heap(elements: seq<int>)\n\n// Check if heap is empty\npredicate {:spec} heapIsEmpty(h: Heap)\n{\n  |h.elements| == 0\n}\n\n// Get heap size\nfunction {:spec} heapSize(h: Heap): nat\n{\n  |h.elements|\n}\n\n// Parent index in heap\nfunction {:spec} parent(i: nat): nat\n  requires i > 0\n{\n  (i - 1) / 2\n}\n\n// Left child index\nfunction {:spec} leftChild(i: nat): nat\n{\n  2 * i + 1\n}\n\n// Right child index\nfunction {:spec} rightChild(i: nat): nat\n{\n  2 * i + 2\n}\n\n// Check min-heap property\npredicate {:spec} isMinHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] <= h.elements[i]\n}\n\n// Check max-heap property\npredicate {:spec} isMaxHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] >= h.elements[i]\n}\n\n// Get minimum element (root of min-heap)\nfunction {:spec} getMin(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n{\n  h.elements[0]\n}\n\n// Get maximum element (root of max-heap)\nfunction {:spec} getMax(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n{\n  h.elements[0]\n}\n\n// Check if element exists in heap\npredicate {:spec} heapContains(h: Heap, x: int)\n{\n  x in h.elements\n}\n\n// Create empty heap\nfunction {:spec} emptyHeap(): Heap\n{\n  Heap([])\n}\n\n// Create heap from single element\nfunction {:spec} singletonHeap(x: int): Heap\n{\n  Heap([x])\n}\n\n// Swap two elements in sequence\nfunction {:spec} swap(s: seq<int>, i: nat, j: nat): seq<int>\n  requires i < |s| && j < |s|\n{\n  s[i := s[j]][j := s[i]]\n}\n\n// Check if heap is complete binary tree (always true for array representation)\npredicate {:spec} isComplete(h: Heap)\n{\n  true  // Array representation is always complete\n}\n\n// Get height of heap\nfunction {:spec} heapHeight(h: Heap): nat\n{\n  if |h.elements| == 0 then 0\n  else log2Floor(|h.elements|) + 1\n}\n\n// Floor of log base 2\nfunction {:spec} log2Floor(n: nat): nat\n  requires n > 0\n  decreases n\n{\n  if n == 1 then 0\n  else 1 + log2Floor(n / 2)\n}\n\n// Check if index is valid\npredicate {:spec} validIndex(h: Heap, i: nat)\n{\n  i < |h.elements|\n}\n\n// Get all elements at a given level\nfunction {:spec} getLevel(h: Heap, level: nat): seq<int>\n{\n  getLevelHelper(h, level, 0)\n}\n\nfunction getLevelHelper(h: Heap, targetLevel: nat, currentLevel: nat): seq<int>\n  decreases |h.elements| - currentLevel\n{\n  if currentLevel >= |h.elements| || currentLevel >= Power2(targetLevel) then []\n  else if currentLevel >= Power2(targetLevel) - 1 && currentLevel < Power2(targetLevel + 1) - 1 then\n    if currentLevel < |h.elements| then [h.elements[currentLevel]] + getLevelHelper(h, targetLevel, currentLevel + 1)\n    else []\n  else getLevelHelper(h, targetLevel, currentLevel + 1)\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1\n  else 2 * Power2(n - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma EmptyHeapIsMinHeap()\n  ensures isMinHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma EmptyHeapIsMaxHeap()\n  ensures isMaxHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma SingletonIsMinHeap(x: int)\n  ensures isMinHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma SingletonIsMaxHeap(x: int)\n  ensures isMaxHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma MinHeapRootIsMinimum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] <= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MinHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MinHeapPathToRoot(h: Heap, i: nat)\n  requires isMinHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] <= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] <= h.elements[i];\n  } else {\n    assert h.elements[parent(i)] <= h.elements[i];\n    MinHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma MaxHeapRootIsMaximum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] >= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MaxHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MaxHeapPathToRoot(h: Heap, i: nat)\n  requires isMaxHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] >= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] >= h.elements[i];\n  } else {\n    assert h.elements[parent(i)] >= h.elements[i];\n    MaxHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma ParentChildRelation(i: nat)\n  requires i > 0\n  ensures leftChild(parent(i)) == i || rightChild(parent(i)) == i\n  ensures leftChild(parent(i)) == i <==> i % 2 == 1\n  ensures rightChild(parent(i)) == i <==> i % 2 == 0\n{\n  var p := parent(i);\n  assert p == (i - 1) / 2;\n  \n/*[CODE HERE]*/\n  assert rightChild(p) == 2 * p + 2;\n\n  if i % 2 == 1 {\n    assert i == 2 * ((i - 1) / 2) + 1;\n    assert leftChild(p) == i;\n  } else {\n    assert i % 2 == 0;\n    assert i == 2 * ((i - 1) / 2) + 2;\n    assert rightChild(p) == i;\n  }\n}\n\nlemma HeapHeightBound(h: Heap)\n  ensures heapHeight(h) <= |h.elements|\n{\n  if |h.elements| == 0 {\n    assert heapHeight(h) == 0;\n  } else {\n    Log2FloorBound(|h.elements|);\n  }\n}\n\nlemma Log2FloorBound(n: nat)\n  requires n > 0\n  ensures log2Floor(n) < n\n  decreases n\n{\n  if n == 1 {\n    assert log2Floor(1) == 0;\n  } else {\n    Log2FloorBound(n / 2);\n    assert log2Floor(n) == 1 + log2Floor(n / 2);\n    assert n / 2 < n;\n  }\n}\n\nlemma SwapPreservesMultiset(s: seq<int>, i: nat, j: nat)\n  requires i < |s| && j < |s|\n  ensures multiset(swap(s, i, j)) == multiset(s)\n{\n  var s' := swap(s, i, j);\n  assert s'[i] == s[j];\n  assert s'[j] == s[i];\n  forall k | 0 <= k < |s| && k != i && k != j\n    ensures s'[k] == s[k]\n  {\n    // Elements other than i and j are unchanged\n  }\n}", "output": "assert leftChild(p) == 2 * p + 1;"}, {"id": "example_ParentChildRelation_7", "type": "assert", "program": "// Min-heap operations: insert, extractMin, heapify with heap property\n\ndatatype Heap = Heap(elements: seq<int>)\n\n// Check if heap is empty\npredicate {:spec} heapIsEmpty(h: Heap)\n{\n  |h.elements| == 0\n}\n\n// Get heap size\nfunction {:spec} heapSize(h: Heap): nat\n{\n  |h.elements|\n}\n\n// Parent index in heap\nfunction {:spec} parent(i: nat): nat\n  requires i > 0\n{\n  (i - 1) / 2\n}\n\n// Left child index\nfunction {:spec} leftChild(i: nat): nat\n{\n  2 * i + 1\n}\n\n// Right child index\nfunction {:spec} rightChild(i: nat): nat\n{\n  2 * i + 2\n}\n\n// Check min-heap property\npredicate {:spec} isMinHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] <= h.elements[i]\n}\n\n// Check max-heap property\npredicate {:spec} isMaxHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] >= h.elements[i]\n}\n\n// Get minimum element (root of min-heap)\nfunction {:spec} getMin(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n{\n  h.elements[0]\n}\n\n// Get maximum element (root of max-heap)\nfunction {:spec} getMax(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n{\n  h.elements[0]\n}\n\n// Check if element exists in heap\npredicate {:spec} heapContains(h: Heap, x: int)\n{\n  x in h.elements\n}\n\n// Create empty heap\nfunction {:spec} emptyHeap(): Heap\n{\n  Heap([])\n}\n\n// Create heap from single element\nfunction {:spec} singletonHeap(x: int): Heap\n{\n  Heap([x])\n}\n\n// Swap two elements in sequence\nfunction {:spec} swap(s: seq<int>, i: nat, j: nat): seq<int>\n  requires i < |s| && j < |s|\n{\n  s[i := s[j]][j := s[i]]\n}\n\n// Check if heap is complete binary tree (always true for array representation)\npredicate {:spec} isComplete(h: Heap)\n{\n  true  // Array representation is always complete\n}\n\n// Get height of heap\nfunction {:spec} heapHeight(h: Heap): nat\n{\n  if |h.elements| == 0 then 0\n  else log2Floor(|h.elements|) + 1\n}\n\n// Floor of log base 2\nfunction {:spec} log2Floor(n: nat): nat\n  requires n > 0\n  decreases n\n{\n  if n == 1 then 0\n  else 1 + log2Floor(n / 2)\n}\n\n// Check if index is valid\npredicate {:spec} validIndex(h: Heap, i: nat)\n{\n  i < |h.elements|\n}\n\n// Get all elements at a given level\nfunction {:spec} getLevel(h: Heap, level: nat): seq<int>\n{\n  getLevelHelper(h, level, 0)\n}\n\nfunction getLevelHelper(h: Heap, targetLevel: nat, currentLevel: nat): seq<int>\n  decreases |h.elements| - currentLevel\n{\n  if currentLevel >= |h.elements| || currentLevel >= Power2(targetLevel) then []\n  else if currentLevel >= Power2(targetLevel) - 1 && currentLevel < Power2(targetLevel + 1) - 1 then\n    if currentLevel < |h.elements| then [h.elements[currentLevel]] + getLevelHelper(h, targetLevel, currentLevel + 1)\n    else []\n  else getLevelHelper(h, targetLevel, currentLevel + 1)\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1\n  else 2 * Power2(n - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma EmptyHeapIsMinHeap()\n  ensures isMinHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma EmptyHeapIsMaxHeap()\n  ensures isMaxHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma SingletonIsMinHeap(x: int)\n  ensures isMinHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma SingletonIsMaxHeap(x: int)\n  ensures isMaxHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma MinHeapRootIsMinimum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] <= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MinHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MinHeapPathToRoot(h: Heap, i: nat)\n  requires isMinHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] <= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] <= h.elements[i];\n  } else {\n    assert h.elements[parent(i)] <= h.elements[i];\n    MinHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma MaxHeapRootIsMaximum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] >= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MaxHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MaxHeapPathToRoot(h: Heap, i: nat)\n  requires isMaxHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] >= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] >= h.elements[i];\n  } else {\n    assert h.elements[parent(i)] >= h.elements[i];\n    MaxHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma ParentChildRelation(i: nat)\n  requires i > 0\n  ensures leftChild(parent(i)) == i || rightChild(parent(i)) == i\n  ensures leftChild(parent(i)) == i <==> i % 2 == 1\n  ensures rightChild(parent(i)) == i <==> i % 2 == 0\n{\n  var p := parent(i);\n  \n/*[CODE HERE]*/\n  assert leftChild(p) == 2 * p + 1;\n  assert rightChild(p) == 2 * p + 2;\n\n  if i % 2 == 1 {\n    assert i == 2 * ((i - 1) / 2) + 1;\n    assert leftChild(p) == i;\n  } else {\n    assert i % 2 == 0;\n    assert i == 2 * ((i - 1) / 2) + 2;\n    assert rightChild(p) == i;\n  }\n}\n\nlemma HeapHeightBound(h: Heap)\n  ensures heapHeight(h) <= |h.elements|\n{\n  if |h.elements| == 0 {\n    assert heapHeight(h) == 0;\n  } else {\n    Log2FloorBound(|h.elements|);\n  }\n}\n\nlemma Log2FloorBound(n: nat)\n  requires n > 0\n  ensures log2Floor(n) < n\n  decreases n\n{\n  if n == 1 {\n    assert log2Floor(1) == 0;\n  } else {\n    Log2FloorBound(n / 2);\n    assert log2Floor(n) == 1 + log2Floor(n / 2);\n    assert n / 2 < n;\n  }\n}\n\nlemma SwapPreservesMultiset(s: seq<int>, i: nat, j: nat)\n  requires i < |s| && j < |s|\n  ensures multiset(swap(s, i, j)) == multiset(s)\n{\n  var s' := swap(s, i, j);\n  assert s'[i] == s[j];\n  assert s'[j] == s[i];\n  forall k | 0 <= k < |s| && k != i && k != j\n    ensures s'[k] == s[k]\n  {\n    // Elements other than i and j are unchanged\n  }\n}", "output": "assert p == (i - 1) / 2;"}, {"id": "example_HeapHeightBound_0", "type": "call", "program": "// Min-heap operations: insert, extractMin, heapify with heap property\n\ndatatype Heap = Heap(elements: seq<int>)\n\n// Check if heap is empty\npredicate {:spec} heapIsEmpty(h: Heap)\n{\n  |h.elements| == 0\n}\n\n// Get heap size\nfunction {:spec} heapSize(h: Heap): nat\n{\n  |h.elements|\n}\n\n// Parent index in heap\nfunction {:spec} parent(i: nat): nat\n  requires i > 0\n{\n  (i - 1) / 2\n}\n\n// Left child index\nfunction {:spec} leftChild(i: nat): nat\n{\n  2 * i + 1\n}\n\n// Right child index\nfunction {:spec} rightChild(i: nat): nat\n{\n  2 * i + 2\n}\n\n// Check min-heap property\npredicate {:spec} isMinHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] <= h.elements[i]\n}\n\n// Check max-heap property\npredicate {:spec} isMaxHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] >= h.elements[i]\n}\n\n// Get minimum element (root of min-heap)\nfunction {:spec} getMin(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n{\n  h.elements[0]\n}\n\n// Get maximum element (root of max-heap)\nfunction {:spec} getMax(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n{\n  h.elements[0]\n}\n\n// Check if element exists in heap\npredicate {:spec} heapContains(h: Heap, x: int)\n{\n  x in h.elements\n}\n\n// Create empty heap\nfunction {:spec} emptyHeap(): Heap\n{\n  Heap([])\n}\n\n// Create heap from single element\nfunction {:spec} singletonHeap(x: int): Heap\n{\n  Heap([x])\n}\n\n// Swap two elements in sequence\nfunction {:spec} swap(s: seq<int>, i: nat, j: nat): seq<int>\n  requires i < |s| && j < |s|\n{\n  s[i := s[j]][j := s[i]]\n}\n\n// Check if heap is complete binary tree (always true for array representation)\npredicate {:spec} isComplete(h: Heap)\n{\n  true  // Array representation is always complete\n}\n\n// Get height of heap\nfunction {:spec} heapHeight(h: Heap): nat\n{\n  if |h.elements| == 0 then 0\n  else log2Floor(|h.elements|) + 1\n}\n\n// Floor of log base 2\nfunction {:spec} log2Floor(n: nat): nat\n  requires n > 0\n  decreases n\n{\n  if n == 1 then 0\n  else 1 + log2Floor(n / 2)\n}\n\n// Check if index is valid\npredicate {:spec} validIndex(h: Heap, i: nat)\n{\n  i < |h.elements|\n}\n\n// Get all elements at a given level\nfunction {:spec} getLevel(h: Heap, level: nat): seq<int>\n{\n  getLevelHelper(h, level, 0)\n}\n\nfunction getLevelHelper(h: Heap, targetLevel: nat, currentLevel: nat): seq<int>\n  decreases |h.elements| - currentLevel\n{\n  if currentLevel >= |h.elements| || currentLevel >= Power2(targetLevel) then []\n  else if currentLevel >= Power2(targetLevel) - 1 && currentLevel < Power2(targetLevel + 1) - 1 then\n    if currentLevel < |h.elements| then [h.elements[currentLevel]] + getLevelHelper(h, targetLevel, currentLevel + 1)\n    else []\n  else getLevelHelper(h, targetLevel, currentLevel + 1)\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1\n  else 2 * Power2(n - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma EmptyHeapIsMinHeap()\n  ensures isMinHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma EmptyHeapIsMaxHeap()\n  ensures isMaxHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma SingletonIsMinHeap(x: int)\n  ensures isMinHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma SingletonIsMaxHeap(x: int)\n  ensures isMaxHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma MinHeapRootIsMinimum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] <= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MinHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MinHeapPathToRoot(h: Heap, i: nat)\n  requires isMinHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] <= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] <= h.elements[i];\n  } else {\n    assert h.elements[parent(i)] <= h.elements[i];\n    MinHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma MaxHeapRootIsMaximum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] >= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MaxHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MaxHeapPathToRoot(h: Heap, i: nat)\n  requires isMaxHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] >= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] >= h.elements[i];\n  } else {\n    assert h.elements[parent(i)] >= h.elements[i];\n    MaxHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma ParentChildRelation(i: nat)\n  requires i > 0\n  ensures leftChild(parent(i)) == i || rightChild(parent(i)) == i\n  ensures leftChild(parent(i)) == i <==> i % 2 == 1\n  ensures rightChild(parent(i)) == i <==> i % 2 == 0\n{\n  var p := parent(i);\n  assert p == (i - 1) / 2;\n  assert leftChild(p) == 2 * p + 1;\n  assert rightChild(p) == 2 * p + 2;\n\n  if i % 2 == 1 {\n    assert i == 2 * ((i - 1) / 2) + 1;\n    assert leftChild(p) == i;\n  } else {\n    assert i % 2 == 0;\n    assert i == 2 * ((i - 1) / 2) + 2;\n    assert rightChild(p) == i;\n  }\n}\n\nlemma HeapHeightBound(h: Heap)\n  ensures heapHeight(h) <= |h.elements|\n{\n  if |h.elements| == 0 {\n    assert heapHeight(h) == 0;\n  } else {\n    \n/*[CODE HERE]*/\n  }\n}\n\nlemma Log2FloorBound(n: nat)\n  requires n > 0\n  ensures log2Floor(n) < n\n  decreases n\n{\n  if n == 1 {\n    assert log2Floor(1) == 0;\n  } else {\n    Log2FloorBound(n / 2);\n    assert log2Floor(n) == 1 + log2Floor(n / 2);\n    assert n / 2 < n;\n  }\n}\n\nlemma SwapPreservesMultiset(s: seq<int>, i: nat, j: nat)\n  requires i < |s| && j < |s|\n  ensures multiset(swap(s, i, j)) == multiset(s)\n{\n  var s' := swap(s, i, j);\n  assert s'[i] == s[j];\n  assert s'[j] == s[i];\n  forall k | 0 <= k < |s| && k != i && k != j\n    ensures s'[k] == s[k]\n  {\n    // Elements other than i and j are unchanged\n  }\n}", "output": "Log2FloorBound(|h.elements|);"}, {"id": "example_HeapHeightBound_1", "type": "assert", "program": "// Min-heap operations: insert, extractMin, heapify with heap property\n\ndatatype Heap = Heap(elements: seq<int>)\n\n// Check if heap is empty\npredicate {:spec} heapIsEmpty(h: Heap)\n{\n  |h.elements| == 0\n}\n\n// Get heap size\nfunction {:spec} heapSize(h: Heap): nat\n{\n  |h.elements|\n}\n\n// Parent index in heap\nfunction {:spec} parent(i: nat): nat\n  requires i > 0\n{\n  (i - 1) / 2\n}\n\n// Left child index\nfunction {:spec} leftChild(i: nat): nat\n{\n  2 * i + 1\n}\n\n// Right child index\nfunction {:spec} rightChild(i: nat): nat\n{\n  2 * i + 2\n}\n\n// Check min-heap property\npredicate {:spec} isMinHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] <= h.elements[i]\n}\n\n// Check max-heap property\npredicate {:spec} isMaxHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] >= h.elements[i]\n}\n\n// Get minimum element (root of min-heap)\nfunction {:spec} getMin(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n{\n  h.elements[0]\n}\n\n// Get maximum element (root of max-heap)\nfunction {:spec} getMax(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n{\n  h.elements[0]\n}\n\n// Check if element exists in heap\npredicate {:spec} heapContains(h: Heap, x: int)\n{\n  x in h.elements\n}\n\n// Create empty heap\nfunction {:spec} emptyHeap(): Heap\n{\n  Heap([])\n}\n\n// Create heap from single element\nfunction {:spec} singletonHeap(x: int): Heap\n{\n  Heap([x])\n}\n\n// Swap two elements in sequence\nfunction {:spec} swap(s: seq<int>, i: nat, j: nat): seq<int>\n  requires i < |s| && j < |s|\n{\n  s[i := s[j]][j := s[i]]\n}\n\n// Check if heap is complete binary tree (always true for array representation)\npredicate {:spec} isComplete(h: Heap)\n{\n  true  // Array representation is always complete\n}\n\n// Get height of heap\nfunction {:spec} heapHeight(h: Heap): nat\n{\n  if |h.elements| == 0 then 0\n  else log2Floor(|h.elements|) + 1\n}\n\n// Floor of log base 2\nfunction {:spec} log2Floor(n: nat): nat\n  requires n > 0\n  decreases n\n{\n  if n == 1 then 0\n  else 1 + log2Floor(n / 2)\n}\n\n// Check if index is valid\npredicate {:spec} validIndex(h: Heap, i: nat)\n{\n  i < |h.elements|\n}\n\n// Get all elements at a given level\nfunction {:spec} getLevel(h: Heap, level: nat): seq<int>\n{\n  getLevelHelper(h, level, 0)\n}\n\nfunction getLevelHelper(h: Heap, targetLevel: nat, currentLevel: nat): seq<int>\n  decreases |h.elements| - currentLevel\n{\n  if currentLevel >= |h.elements| || currentLevel >= Power2(targetLevel) then []\n  else if currentLevel >= Power2(targetLevel) - 1 && currentLevel < Power2(targetLevel + 1) - 1 then\n    if currentLevel < |h.elements| then [h.elements[currentLevel]] + getLevelHelper(h, targetLevel, currentLevel + 1)\n    else []\n  else getLevelHelper(h, targetLevel, currentLevel + 1)\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1\n  else 2 * Power2(n - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma EmptyHeapIsMinHeap()\n  ensures isMinHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma EmptyHeapIsMaxHeap()\n  ensures isMaxHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma SingletonIsMinHeap(x: int)\n  ensures isMinHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma SingletonIsMaxHeap(x: int)\n  ensures isMaxHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma MinHeapRootIsMinimum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] <= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MinHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MinHeapPathToRoot(h: Heap, i: nat)\n  requires isMinHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] <= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] <= h.elements[i];\n  } else {\n    assert h.elements[parent(i)] <= h.elements[i];\n    MinHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma MaxHeapRootIsMaximum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] >= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MaxHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MaxHeapPathToRoot(h: Heap, i: nat)\n  requires isMaxHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] >= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] >= h.elements[i];\n  } else {\n    assert h.elements[parent(i)] >= h.elements[i];\n    MaxHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma ParentChildRelation(i: nat)\n  requires i > 0\n  ensures leftChild(parent(i)) == i || rightChild(parent(i)) == i\n  ensures leftChild(parent(i)) == i <==> i % 2 == 1\n  ensures rightChild(parent(i)) == i <==> i % 2 == 0\n{\n  var p := parent(i);\n  assert p == (i - 1) / 2;\n  assert leftChild(p) == 2 * p + 1;\n  assert rightChild(p) == 2 * p + 2;\n\n  if i % 2 == 1 {\n    assert i == 2 * ((i - 1) / 2) + 1;\n    assert leftChild(p) == i;\n  } else {\n    assert i % 2 == 0;\n    assert i == 2 * ((i - 1) / 2) + 2;\n    assert rightChild(p) == i;\n  }\n}\n\nlemma HeapHeightBound(h: Heap)\n  ensures heapHeight(h) <= |h.elements|\n{\n  if |h.elements| == 0 {\n    \n/*[CODE HERE]*/\n  } else {\n    Log2FloorBound(|h.elements|);\n  }\n}\n\nlemma Log2FloorBound(n: nat)\n  requires n > 0\n  ensures log2Floor(n) < n\n  decreases n\n{\n  if n == 1 {\n    assert log2Floor(1) == 0;\n  } else {\n    Log2FloorBound(n / 2);\n    assert log2Floor(n) == 1 + log2Floor(n / 2);\n    assert n / 2 < n;\n  }\n}\n\nlemma SwapPreservesMultiset(s: seq<int>, i: nat, j: nat)\n  requires i < |s| && j < |s|\n  ensures multiset(swap(s, i, j)) == multiset(s)\n{\n  var s' := swap(s, i, j);\n  assert s'[i] == s[j];\n  assert s'[j] == s[i];\n  forall k | 0 <= k < |s| && k != i && k != j\n    ensures s'[k] == s[k]\n  {\n    // Elements other than i and j are unchanged\n  }\n}", "output": "assert heapHeight(h) == 0;"}, {"id": "example_Log2FloorBound_0", "type": "assert", "program": "// Min-heap operations: insert, extractMin, heapify with heap property\n\ndatatype Heap = Heap(elements: seq<int>)\n\n// Check if heap is empty\npredicate {:spec} heapIsEmpty(h: Heap)\n{\n  |h.elements| == 0\n}\n\n// Get heap size\nfunction {:spec} heapSize(h: Heap): nat\n{\n  |h.elements|\n}\n\n// Parent index in heap\nfunction {:spec} parent(i: nat): nat\n  requires i > 0\n{\n  (i - 1) / 2\n}\n\n// Left child index\nfunction {:spec} leftChild(i: nat): nat\n{\n  2 * i + 1\n}\n\n// Right child index\nfunction {:spec} rightChild(i: nat): nat\n{\n  2 * i + 2\n}\n\n// Check min-heap property\npredicate {:spec} isMinHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] <= h.elements[i]\n}\n\n// Check max-heap property\npredicate {:spec} isMaxHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] >= h.elements[i]\n}\n\n// Get minimum element (root of min-heap)\nfunction {:spec} getMin(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n{\n  h.elements[0]\n}\n\n// Get maximum element (root of max-heap)\nfunction {:spec} getMax(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n{\n  h.elements[0]\n}\n\n// Check if element exists in heap\npredicate {:spec} heapContains(h: Heap, x: int)\n{\n  x in h.elements\n}\n\n// Create empty heap\nfunction {:spec} emptyHeap(): Heap\n{\n  Heap([])\n}\n\n// Create heap from single element\nfunction {:spec} singletonHeap(x: int): Heap\n{\n  Heap([x])\n}\n\n// Swap two elements in sequence\nfunction {:spec} swap(s: seq<int>, i: nat, j: nat): seq<int>\n  requires i < |s| && j < |s|\n{\n  s[i := s[j]][j := s[i]]\n}\n\n// Check if heap is complete binary tree (always true for array representation)\npredicate {:spec} isComplete(h: Heap)\n{\n  true  // Array representation is always complete\n}\n\n// Get height of heap\nfunction {:spec} heapHeight(h: Heap): nat\n{\n  if |h.elements| == 0 then 0\n  else log2Floor(|h.elements|) + 1\n}\n\n// Floor of log base 2\nfunction {:spec} log2Floor(n: nat): nat\n  requires n > 0\n  decreases n\n{\n  if n == 1 then 0\n  else 1 + log2Floor(n / 2)\n}\n\n// Check if index is valid\npredicate {:spec} validIndex(h: Heap, i: nat)\n{\n  i < |h.elements|\n}\n\n// Get all elements at a given level\nfunction {:spec} getLevel(h: Heap, level: nat): seq<int>\n{\n  getLevelHelper(h, level, 0)\n}\n\nfunction getLevelHelper(h: Heap, targetLevel: nat, currentLevel: nat): seq<int>\n  decreases |h.elements| - currentLevel\n{\n  if currentLevel >= |h.elements| || currentLevel >= Power2(targetLevel) then []\n  else if currentLevel >= Power2(targetLevel) - 1 && currentLevel < Power2(targetLevel + 1) - 1 then\n    if currentLevel < |h.elements| then [h.elements[currentLevel]] + getLevelHelper(h, targetLevel, currentLevel + 1)\n    else []\n  else getLevelHelper(h, targetLevel, currentLevel + 1)\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1\n  else 2 * Power2(n - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma EmptyHeapIsMinHeap()\n  ensures isMinHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma EmptyHeapIsMaxHeap()\n  ensures isMaxHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma SingletonIsMinHeap(x: int)\n  ensures isMinHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma SingletonIsMaxHeap(x: int)\n  ensures isMaxHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma MinHeapRootIsMinimum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] <= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MinHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MinHeapPathToRoot(h: Heap, i: nat)\n  requires isMinHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] <= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] <= h.elements[i];\n  } else {\n    assert h.elements[parent(i)] <= h.elements[i];\n    MinHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma MaxHeapRootIsMaximum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] >= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MaxHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MaxHeapPathToRoot(h: Heap, i: nat)\n  requires isMaxHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] >= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] >= h.elements[i];\n  } else {\n    assert h.elements[parent(i)] >= h.elements[i];\n    MaxHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma ParentChildRelation(i: nat)\n  requires i > 0\n  ensures leftChild(parent(i)) == i || rightChild(parent(i)) == i\n  ensures leftChild(parent(i)) == i <==> i % 2 == 1\n  ensures rightChild(parent(i)) == i <==> i % 2 == 0\n{\n  var p := parent(i);\n  assert p == (i - 1) / 2;\n  assert leftChild(p) == 2 * p + 1;\n  assert rightChild(p) == 2 * p + 2;\n\n  if i % 2 == 1 {\n    assert i == 2 * ((i - 1) / 2) + 1;\n    assert leftChild(p) == i;\n  } else {\n    assert i % 2 == 0;\n    assert i == 2 * ((i - 1) / 2) + 2;\n    assert rightChild(p) == i;\n  }\n}\n\nlemma HeapHeightBound(h: Heap)\n  ensures heapHeight(h) <= |h.elements|\n{\n  if |h.elements| == 0 {\n    assert heapHeight(h) == 0;\n  } else {\n    Log2FloorBound(|h.elements|);\n  }\n}\n\nlemma Log2FloorBound(n: nat)\n  requires n > 0\n  ensures log2Floor(n) < n\n  decreases n\n{\n  if n == 1 {\n    assert log2Floor(1) == 0;\n  } else {\n    Log2FloorBound(n / 2);\n    assert log2Floor(n) == 1 + log2Floor(n / 2);\n    \n/*[CODE HERE]*/\n  }\n}\n\nlemma SwapPreservesMultiset(s: seq<int>, i: nat, j: nat)\n  requires i < |s| && j < |s|\n  ensures multiset(swap(s, i, j)) == multiset(s)\n{\n  var s' := swap(s, i, j);\n  assert s'[i] == s[j];\n  assert s'[j] == s[i];\n  forall k | 0 <= k < |s| && k != i && k != j\n    ensures s'[k] == s[k]\n  {\n    // Elements other than i and j are unchanged\n  }\n}", "output": "assert n / 2 < n;"}, {"id": "example_Log2FloorBound_1", "type": "assert", "program": "// Min-heap operations: insert, extractMin, heapify with heap property\n\ndatatype Heap = Heap(elements: seq<int>)\n\n// Check if heap is empty\npredicate {:spec} heapIsEmpty(h: Heap)\n{\n  |h.elements| == 0\n}\n\n// Get heap size\nfunction {:spec} heapSize(h: Heap): nat\n{\n  |h.elements|\n}\n\n// Parent index in heap\nfunction {:spec} parent(i: nat): nat\n  requires i > 0\n{\n  (i - 1) / 2\n}\n\n// Left child index\nfunction {:spec} leftChild(i: nat): nat\n{\n  2 * i + 1\n}\n\n// Right child index\nfunction {:spec} rightChild(i: nat): nat\n{\n  2 * i + 2\n}\n\n// Check min-heap property\npredicate {:spec} isMinHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] <= h.elements[i]\n}\n\n// Check max-heap property\npredicate {:spec} isMaxHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] >= h.elements[i]\n}\n\n// Get minimum element (root of min-heap)\nfunction {:spec} getMin(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n{\n  h.elements[0]\n}\n\n// Get maximum element (root of max-heap)\nfunction {:spec} getMax(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n{\n  h.elements[0]\n}\n\n// Check if element exists in heap\npredicate {:spec} heapContains(h: Heap, x: int)\n{\n  x in h.elements\n}\n\n// Create empty heap\nfunction {:spec} emptyHeap(): Heap\n{\n  Heap([])\n}\n\n// Create heap from single element\nfunction {:spec} singletonHeap(x: int): Heap\n{\n  Heap([x])\n}\n\n// Swap two elements in sequence\nfunction {:spec} swap(s: seq<int>, i: nat, j: nat): seq<int>\n  requires i < |s| && j < |s|\n{\n  s[i := s[j]][j := s[i]]\n}\n\n// Check if heap is complete binary tree (always true for array representation)\npredicate {:spec} isComplete(h: Heap)\n{\n  true  // Array representation is always complete\n}\n\n// Get height of heap\nfunction {:spec} heapHeight(h: Heap): nat\n{\n  if |h.elements| == 0 then 0\n  else log2Floor(|h.elements|) + 1\n}\n\n// Floor of log base 2\nfunction {:spec} log2Floor(n: nat): nat\n  requires n > 0\n  decreases n\n{\n  if n == 1 then 0\n  else 1 + log2Floor(n / 2)\n}\n\n// Check if index is valid\npredicate {:spec} validIndex(h: Heap, i: nat)\n{\n  i < |h.elements|\n}\n\n// Get all elements at a given level\nfunction {:spec} getLevel(h: Heap, level: nat): seq<int>\n{\n  getLevelHelper(h, level, 0)\n}\n\nfunction getLevelHelper(h: Heap, targetLevel: nat, currentLevel: nat): seq<int>\n  decreases |h.elements| - currentLevel\n{\n  if currentLevel >= |h.elements| || currentLevel >= Power2(targetLevel) then []\n  else if currentLevel >= Power2(targetLevel) - 1 && currentLevel < Power2(targetLevel + 1) - 1 then\n    if currentLevel < |h.elements| then [h.elements[currentLevel]] + getLevelHelper(h, targetLevel, currentLevel + 1)\n    else []\n  else getLevelHelper(h, targetLevel, currentLevel + 1)\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1\n  else 2 * Power2(n - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma EmptyHeapIsMinHeap()\n  ensures isMinHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma EmptyHeapIsMaxHeap()\n  ensures isMaxHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma SingletonIsMinHeap(x: int)\n  ensures isMinHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma SingletonIsMaxHeap(x: int)\n  ensures isMaxHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma MinHeapRootIsMinimum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] <= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MinHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MinHeapPathToRoot(h: Heap, i: nat)\n  requires isMinHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] <= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] <= h.elements[i];\n  } else {\n    assert h.elements[parent(i)] <= h.elements[i];\n    MinHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma MaxHeapRootIsMaximum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] >= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MaxHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MaxHeapPathToRoot(h: Heap, i: nat)\n  requires isMaxHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] >= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] >= h.elements[i];\n  } else {\n    assert h.elements[parent(i)] >= h.elements[i];\n    MaxHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma ParentChildRelation(i: nat)\n  requires i > 0\n  ensures leftChild(parent(i)) == i || rightChild(parent(i)) == i\n  ensures leftChild(parent(i)) == i <==> i % 2 == 1\n  ensures rightChild(parent(i)) == i <==> i % 2 == 0\n{\n  var p := parent(i);\n  assert p == (i - 1) / 2;\n  assert leftChild(p) == 2 * p + 1;\n  assert rightChild(p) == 2 * p + 2;\n\n  if i % 2 == 1 {\n    assert i == 2 * ((i - 1) / 2) + 1;\n    assert leftChild(p) == i;\n  } else {\n    assert i % 2 == 0;\n    assert i == 2 * ((i - 1) / 2) + 2;\n    assert rightChild(p) == i;\n  }\n}\n\nlemma HeapHeightBound(h: Heap)\n  ensures heapHeight(h) <= |h.elements|\n{\n  if |h.elements| == 0 {\n    assert heapHeight(h) == 0;\n  } else {\n    Log2FloorBound(|h.elements|);\n  }\n}\n\nlemma Log2FloorBound(n: nat)\n  requires n > 0\n  ensures log2Floor(n) < n\n  decreases n\n{\n  if n == 1 {\n    assert log2Floor(1) == 0;\n  } else {\n    Log2FloorBound(n / 2);\n    \n/*[CODE HERE]*/\n    assert n / 2 < n;\n  }\n}\n\nlemma SwapPreservesMultiset(s: seq<int>, i: nat, j: nat)\n  requires i < |s| && j < |s|\n  ensures multiset(swap(s, i, j)) == multiset(s)\n{\n  var s' := swap(s, i, j);\n  assert s'[i] == s[j];\n  assert s'[j] == s[i];\n  forall k | 0 <= k < |s| && k != i && k != j\n    ensures s'[k] == s[k]\n  {\n    // Elements other than i and j are unchanged\n  }\n}", "output": "assert log2Floor(n) == 1 + log2Floor(n / 2);"}, {"id": "example_Log2FloorBound_2", "type": "call", "program": "// Min-heap operations: insert, extractMin, heapify with heap property\n\ndatatype Heap = Heap(elements: seq<int>)\n\n// Check if heap is empty\npredicate {:spec} heapIsEmpty(h: Heap)\n{\n  |h.elements| == 0\n}\n\n// Get heap size\nfunction {:spec} heapSize(h: Heap): nat\n{\n  |h.elements|\n}\n\n// Parent index in heap\nfunction {:spec} parent(i: nat): nat\n  requires i > 0\n{\n  (i - 1) / 2\n}\n\n// Left child index\nfunction {:spec} leftChild(i: nat): nat\n{\n  2 * i + 1\n}\n\n// Right child index\nfunction {:spec} rightChild(i: nat): nat\n{\n  2 * i + 2\n}\n\n// Check min-heap property\npredicate {:spec} isMinHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] <= h.elements[i]\n}\n\n// Check max-heap property\npredicate {:spec} isMaxHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] >= h.elements[i]\n}\n\n// Get minimum element (root of min-heap)\nfunction {:spec} getMin(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n{\n  h.elements[0]\n}\n\n// Get maximum element (root of max-heap)\nfunction {:spec} getMax(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n{\n  h.elements[0]\n}\n\n// Check if element exists in heap\npredicate {:spec} heapContains(h: Heap, x: int)\n{\n  x in h.elements\n}\n\n// Create empty heap\nfunction {:spec} emptyHeap(): Heap\n{\n  Heap([])\n}\n\n// Create heap from single element\nfunction {:spec} singletonHeap(x: int): Heap\n{\n  Heap([x])\n}\n\n// Swap two elements in sequence\nfunction {:spec} swap(s: seq<int>, i: nat, j: nat): seq<int>\n  requires i < |s| && j < |s|\n{\n  s[i := s[j]][j := s[i]]\n}\n\n// Check if heap is complete binary tree (always true for array representation)\npredicate {:spec} isComplete(h: Heap)\n{\n  true  // Array representation is always complete\n}\n\n// Get height of heap\nfunction {:spec} heapHeight(h: Heap): nat\n{\n  if |h.elements| == 0 then 0\n  else log2Floor(|h.elements|) + 1\n}\n\n// Floor of log base 2\nfunction {:spec} log2Floor(n: nat): nat\n  requires n > 0\n  decreases n\n{\n  if n == 1 then 0\n  else 1 + log2Floor(n / 2)\n}\n\n// Check if index is valid\npredicate {:spec} validIndex(h: Heap, i: nat)\n{\n  i < |h.elements|\n}\n\n// Get all elements at a given level\nfunction {:spec} getLevel(h: Heap, level: nat): seq<int>\n{\n  getLevelHelper(h, level, 0)\n}\n\nfunction getLevelHelper(h: Heap, targetLevel: nat, currentLevel: nat): seq<int>\n  decreases |h.elements| - currentLevel\n{\n  if currentLevel >= |h.elements| || currentLevel >= Power2(targetLevel) then []\n  else if currentLevel >= Power2(targetLevel) - 1 && currentLevel < Power2(targetLevel + 1) - 1 then\n    if currentLevel < |h.elements| then [h.elements[currentLevel]] + getLevelHelper(h, targetLevel, currentLevel + 1)\n    else []\n  else getLevelHelper(h, targetLevel, currentLevel + 1)\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1\n  else 2 * Power2(n - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma EmptyHeapIsMinHeap()\n  ensures isMinHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma EmptyHeapIsMaxHeap()\n  ensures isMaxHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma SingletonIsMinHeap(x: int)\n  ensures isMinHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma SingletonIsMaxHeap(x: int)\n  ensures isMaxHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma MinHeapRootIsMinimum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] <= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MinHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MinHeapPathToRoot(h: Heap, i: nat)\n  requires isMinHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] <= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] <= h.elements[i];\n  } else {\n    assert h.elements[parent(i)] <= h.elements[i];\n    MinHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma MaxHeapRootIsMaximum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] >= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MaxHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MaxHeapPathToRoot(h: Heap, i: nat)\n  requires isMaxHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] >= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] >= h.elements[i];\n  } else {\n    assert h.elements[parent(i)] >= h.elements[i];\n    MaxHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma ParentChildRelation(i: nat)\n  requires i > 0\n  ensures leftChild(parent(i)) == i || rightChild(parent(i)) == i\n  ensures leftChild(parent(i)) == i <==> i % 2 == 1\n  ensures rightChild(parent(i)) == i <==> i % 2 == 0\n{\n  var p := parent(i);\n  assert p == (i - 1) / 2;\n  assert leftChild(p) == 2 * p + 1;\n  assert rightChild(p) == 2 * p + 2;\n\n  if i % 2 == 1 {\n    assert i == 2 * ((i - 1) / 2) + 1;\n    assert leftChild(p) == i;\n  } else {\n    assert i % 2 == 0;\n    assert i == 2 * ((i - 1) / 2) + 2;\n    assert rightChild(p) == i;\n  }\n}\n\nlemma HeapHeightBound(h: Heap)\n  ensures heapHeight(h) <= |h.elements|\n{\n  if |h.elements| == 0 {\n    assert heapHeight(h) == 0;\n  } else {\n    Log2FloorBound(|h.elements|);\n  }\n}\n\nlemma Log2FloorBound(n: nat)\n  requires n > 0\n  ensures log2Floor(n) < n\n  decreases n\n{\n  if n == 1 {\n    assert log2Floor(1) == 0;\n  } else {\n    \n/*[CODE HERE]*/\n    assert log2Floor(n) == 1 + log2Floor(n / 2);\n    assert n / 2 < n;\n  }\n}\n\nlemma SwapPreservesMultiset(s: seq<int>, i: nat, j: nat)\n  requires i < |s| && j < |s|\n  ensures multiset(swap(s, i, j)) == multiset(s)\n{\n  var s' := swap(s, i, j);\n  assert s'[i] == s[j];\n  assert s'[j] == s[i];\n  forall k | 0 <= k < |s| && k != i && k != j\n    ensures s'[k] == s[k]\n  {\n    // Elements other than i and j are unchanged\n  }\n}", "output": "Log2FloorBound(n / 2);"}, {"id": "example_Log2FloorBound_3", "type": "assert", "program": "// Min-heap operations: insert, extractMin, heapify with heap property\n\ndatatype Heap = Heap(elements: seq<int>)\n\n// Check if heap is empty\npredicate {:spec} heapIsEmpty(h: Heap)\n{\n  |h.elements| == 0\n}\n\n// Get heap size\nfunction {:spec} heapSize(h: Heap): nat\n{\n  |h.elements|\n}\n\n// Parent index in heap\nfunction {:spec} parent(i: nat): nat\n  requires i > 0\n{\n  (i - 1) / 2\n}\n\n// Left child index\nfunction {:spec} leftChild(i: nat): nat\n{\n  2 * i + 1\n}\n\n// Right child index\nfunction {:spec} rightChild(i: nat): nat\n{\n  2 * i + 2\n}\n\n// Check min-heap property\npredicate {:spec} isMinHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] <= h.elements[i]\n}\n\n// Check max-heap property\npredicate {:spec} isMaxHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] >= h.elements[i]\n}\n\n// Get minimum element (root of min-heap)\nfunction {:spec} getMin(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n{\n  h.elements[0]\n}\n\n// Get maximum element (root of max-heap)\nfunction {:spec} getMax(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n{\n  h.elements[0]\n}\n\n// Check if element exists in heap\npredicate {:spec} heapContains(h: Heap, x: int)\n{\n  x in h.elements\n}\n\n// Create empty heap\nfunction {:spec} emptyHeap(): Heap\n{\n  Heap([])\n}\n\n// Create heap from single element\nfunction {:spec} singletonHeap(x: int): Heap\n{\n  Heap([x])\n}\n\n// Swap two elements in sequence\nfunction {:spec} swap(s: seq<int>, i: nat, j: nat): seq<int>\n  requires i < |s| && j < |s|\n{\n  s[i := s[j]][j := s[i]]\n}\n\n// Check if heap is complete binary tree (always true for array representation)\npredicate {:spec} isComplete(h: Heap)\n{\n  true  // Array representation is always complete\n}\n\n// Get height of heap\nfunction {:spec} heapHeight(h: Heap): nat\n{\n  if |h.elements| == 0 then 0\n  else log2Floor(|h.elements|) + 1\n}\n\n// Floor of log base 2\nfunction {:spec} log2Floor(n: nat): nat\n  requires n > 0\n  decreases n\n{\n  if n == 1 then 0\n  else 1 + log2Floor(n / 2)\n}\n\n// Check if index is valid\npredicate {:spec} validIndex(h: Heap, i: nat)\n{\n  i < |h.elements|\n}\n\n// Get all elements at a given level\nfunction {:spec} getLevel(h: Heap, level: nat): seq<int>\n{\n  getLevelHelper(h, level, 0)\n}\n\nfunction getLevelHelper(h: Heap, targetLevel: nat, currentLevel: nat): seq<int>\n  decreases |h.elements| - currentLevel\n{\n  if currentLevel >= |h.elements| || currentLevel >= Power2(targetLevel) then []\n  else if currentLevel >= Power2(targetLevel) - 1 && currentLevel < Power2(targetLevel + 1) - 1 then\n    if currentLevel < |h.elements| then [h.elements[currentLevel]] + getLevelHelper(h, targetLevel, currentLevel + 1)\n    else []\n  else getLevelHelper(h, targetLevel, currentLevel + 1)\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1\n  else 2 * Power2(n - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma EmptyHeapIsMinHeap()\n  ensures isMinHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma EmptyHeapIsMaxHeap()\n  ensures isMaxHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma SingletonIsMinHeap(x: int)\n  ensures isMinHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma SingletonIsMaxHeap(x: int)\n  ensures isMaxHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma MinHeapRootIsMinimum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] <= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MinHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MinHeapPathToRoot(h: Heap, i: nat)\n  requires isMinHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] <= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] <= h.elements[i];\n  } else {\n    assert h.elements[parent(i)] <= h.elements[i];\n    MinHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma MaxHeapRootIsMaximum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] >= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MaxHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MaxHeapPathToRoot(h: Heap, i: nat)\n  requires isMaxHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] >= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] >= h.elements[i];\n  } else {\n    assert h.elements[parent(i)] >= h.elements[i];\n    MaxHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma ParentChildRelation(i: nat)\n  requires i > 0\n  ensures leftChild(parent(i)) == i || rightChild(parent(i)) == i\n  ensures leftChild(parent(i)) == i <==> i % 2 == 1\n  ensures rightChild(parent(i)) == i <==> i % 2 == 0\n{\n  var p := parent(i);\n  assert p == (i - 1) / 2;\n  assert leftChild(p) == 2 * p + 1;\n  assert rightChild(p) == 2 * p + 2;\n\n  if i % 2 == 1 {\n    assert i == 2 * ((i - 1) / 2) + 1;\n    assert leftChild(p) == i;\n  } else {\n    assert i % 2 == 0;\n    assert i == 2 * ((i - 1) / 2) + 2;\n    assert rightChild(p) == i;\n  }\n}\n\nlemma HeapHeightBound(h: Heap)\n  ensures heapHeight(h) <= |h.elements|\n{\n  if |h.elements| == 0 {\n    assert heapHeight(h) == 0;\n  } else {\n    Log2FloorBound(|h.elements|);\n  }\n}\n\nlemma Log2FloorBound(n: nat)\n  requires n > 0\n  ensures log2Floor(n) < n\n  decreases n\n{\n  if n == 1 {\n    \n/*[CODE HERE]*/\n  } else {\n    Log2FloorBound(n / 2);\n    assert log2Floor(n) == 1 + log2Floor(n / 2);\n    assert n / 2 < n;\n  }\n}\n\nlemma SwapPreservesMultiset(s: seq<int>, i: nat, j: nat)\n  requires i < |s| && j < |s|\n  ensures multiset(swap(s, i, j)) == multiset(s)\n{\n  var s' := swap(s, i, j);\n  assert s'[i] == s[j];\n  assert s'[j] == s[i];\n  forall k | 0 <= k < |s| && k != i && k != j\n    ensures s'[k] == s[k]\n  {\n    // Elements other than i and j are unchanged\n  }\n}", "output": "assert log2Floor(1) == 0;"}, {"id": "example_SwapPreservesMultiset_0", "type": "assert", "program": "// Min-heap operations: insert, extractMin, heapify with heap property\n\ndatatype Heap = Heap(elements: seq<int>)\n\n// Check if heap is empty\npredicate {:spec} heapIsEmpty(h: Heap)\n{\n  |h.elements| == 0\n}\n\n// Get heap size\nfunction {:spec} heapSize(h: Heap): nat\n{\n  |h.elements|\n}\n\n// Parent index in heap\nfunction {:spec} parent(i: nat): nat\n  requires i > 0\n{\n  (i - 1) / 2\n}\n\n// Left child index\nfunction {:spec} leftChild(i: nat): nat\n{\n  2 * i + 1\n}\n\n// Right child index\nfunction {:spec} rightChild(i: nat): nat\n{\n  2 * i + 2\n}\n\n// Check min-heap property\npredicate {:spec} isMinHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] <= h.elements[i]\n}\n\n// Check max-heap property\npredicate {:spec} isMaxHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] >= h.elements[i]\n}\n\n// Get minimum element (root of min-heap)\nfunction {:spec} getMin(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n{\n  h.elements[0]\n}\n\n// Get maximum element (root of max-heap)\nfunction {:spec} getMax(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n{\n  h.elements[0]\n}\n\n// Check if element exists in heap\npredicate {:spec} heapContains(h: Heap, x: int)\n{\n  x in h.elements\n}\n\n// Create empty heap\nfunction {:spec} emptyHeap(): Heap\n{\n  Heap([])\n}\n\n// Create heap from single element\nfunction {:spec} singletonHeap(x: int): Heap\n{\n  Heap([x])\n}\n\n// Swap two elements in sequence\nfunction {:spec} swap(s: seq<int>, i: nat, j: nat): seq<int>\n  requires i < |s| && j < |s|\n{\n  s[i := s[j]][j := s[i]]\n}\n\n// Check if heap is complete binary tree (always true for array representation)\npredicate {:spec} isComplete(h: Heap)\n{\n  true  // Array representation is always complete\n}\n\n// Get height of heap\nfunction {:spec} heapHeight(h: Heap): nat\n{\n  if |h.elements| == 0 then 0\n  else log2Floor(|h.elements|) + 1\n}\n\n// Floor of log base 2\nfunction {:spec} log2Floor(n: nat): nat\n  requires n > 0\n  decreases n\n{\n  if n == 1 then 0\n  else 1 + log2Floor(n / 2)\n}\n\n// Check if index is valid\npredicate {:spec} validIndex(h: Heap, i: nat)\n{\n  i < |h.elements|\n}\n\n// Get all elements at a given level\nfunction {:spec} getLevel(h: Heap, level: nat): seq<int>\n{\n  getLevelHelper(h, level, 0)\n}\n\nfunction getLevelHelper(h: Heap, targetLevel: nat, currentLevel: nat): seq<int>\n  decreases |h.elements| - currentLevel\n{\n  if currentLevel >= |h.elements| || currentLevel >= Power2(targetLevel) then []\n  else if currentLevel >= Power2(targetLevel) - 1 && currentLevel < Power2(targetLevel + 1) - 1 then\n    if currentLevel < |h.elements| then [h.elements[currentLevel]] + getLevelHelper(h, targetLevel, currentLevel + 1)\n    else []\n  else getLevelHelper(h, targetLevel, currentLevel + 1)\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1\n  else 2 * Power2(n - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma EmptyHeapIsMinHeap()\n  ensures isMinHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma EmptyHeapIsMaxHeap()\n  ensures isMaxHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma SingletonIsMinHeap(x: int)\n  ensures isMinHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma SingletonIsMaxHeap(x: int)\n  ensures isMaxHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma MinHeapRootIsMinimum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] <= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MinHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MinHeapPathToRoot(h: Heap, i: nat)\n  requires isMinHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] <= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] <= h.elements[i];\n  } else {\n    assert h.elements[parent(i)] <= h.elements[i];\n    MinHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma MaxHeapRootIsMaximum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] >= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MaxHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MaxHeapPathToRoot(h: Heap, i: nat)\n  requires isMaxHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] >= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] >= h.elements[i];\n  } else {\n    assert h.elements[parent(i)] >= h.elements[i];\n    MaxHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma ParentChildRelation(i: nat)\n  requires i > 0\n  ensures leftChild(parent(i)) == i || rightChild(parent(i)) == i\n  ensures leftChild(parent(i)) == i <==> i % 2 == 1\n  ensures rightChild(parent(i)) == i <==> i % 2 == 0\n{\n  var p := parent(i);\n  assert p == (i - 1) / 2;\n  assert leftChild(p) == 2 * p + 1;\n  assert rightChild(p) == 2 * p + 2;\n\n  if i % 2 == 1 {\n    assert i == 2 * ((i - 1) / 2) + 1;\n    assert leftChild(p) == i;\n  } else {\n    assert i % 2 == 0;\n    assert i == 2 * ((i - 1) / 2) + 2;\n    assert rightChild(p) == i;\n  }\n}\n\nlemma HeapHeightBound(h: Heap)\n  ensures heapHeight(h) <= |h.elements|\n{\n  if |h.elements| == 0 {\n    assert heapHeight(h) == 0;\n  } else {\n    Log2FloorBound(|h.elements|);\n  }\n}\n\nlemma Log2FloorBound(n: nat)\n  requires n > 0\n  ensures log2Floor(n) < n\n  decreases n\n{\n  if n == 1 {\n    assert log2Floor(1) == 0;\n  } else {\n    Log2FloorBound(n / 2);\n    assert log2Floor(n) == 1 + log2Floor(n / 2);\n    assert n / 2 < n;\n  }\n}\n\nlemma SwapPreservesMultiset(s: seq<int>, i: nat, j: nat)\n  requires i < |s| && j < |s|\n  ensures multiset(swap(s, i, j)) == multiset(s)\n{\n  var s' := swap(s, i, j);\n  assert s'[i] == s[j];\n  \n/*[CODE HERE]*/\n  forall k | 0 <= k < |s| && k != i && k != j\n    ensures s'[k] == s[k]\n  {\n    // Elements other than i and j are unchanged\n  }\n}", "output": "assert s'[j] == s[i];"}, {"id": "example_SwapPreservesMultiset_1", "type": "assert", "program": "// Min-heap operations: insert, extractMin, heapify with heap property\n\ndatatype Heap = Heap(elements: seq<int>)\n\n// Check if heap is empty\npredicate {:spec} heapIsEmpty(h: Heap)\n{\n  |h.elements| == 0\n}\n\n// Get heap size\nfunction {:spec} heapSize(h: Heap): nat\n{\n  |h.elements|\n}\n\n// Parent index in heap\nfunction {:spec} parent(i: nat): nat\n  requires i > 0\n{\n  (i - 1) / 2\n}\n\n// Left child index\nfunction {:spec} leftChild(i: nat): nat\n{\n  2 * i + 1\n}\n\n// Right child index\nfunction {:spec} rightChild(i: nat): nat\n{\n  2 * i + 2\n}\n\n// Check min-heap property\npredicate {:spec} isMinHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] <= h.elements[i]\n}\n\n// Check max-heap property\npredicate {:spec} isMaxHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] >= h.elements[i]\n}\n\n// Get minimum element (root of min-heap)\nfunction {:spec} getMin(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n{\n  h.elements[0]\n}\n\n// Get maximum element (root of max-heap)\nfunction {:spec} getMax(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n{\n  h.elements[0]\n}\n\n// Check if element exists in heap\npredicate {:spec} heapContains(h: Heap, x: int)\n{\n  x in h.elements\n}\n\n// Create empty heap\nfunction {:spec} emptyHeap(): Heap\n{\n  Heap([])\n}\n\n// Create heap from single element\nfunction {:spec} singletonHeap(x: int): Heap\n{\n  Heap([x])\n}\n\n// Swap two elements in sequence\nfunction {:spec} swap(s: seq<int>, i: nat, j: nat): seq<int>\n  requires i < |s| && j < |s|\n{\n  s[i := s[j]][j := s[i]]\n}\n\n// Check if heap is complete binary tree (always true for array representation)\npredicate {:spec} isComplete(h: Heap)\n{\n  true  // Array representation is always complete\n}\n\n// Get height of heap\nfunction {:spec} heapHeight(h: Heap): nat\n{\n  if |h.elements| == 0 then 0\n  else log2Floor(|h.elements|) + 1\n}\n\n// Floor of log base 2\nfunction {:spec} log2Floor(n: nat): nat\n  requires n > 0\n  decreases n\n{\n  if n == 1 then 0\n  else 1 + log2Floor(n / 2)\n}\n\n// Check if index is valid\npredicate {:spec} validIndex(h: Heap, i: nat)\n{\n  i < |h.elements|\n}\n\n// Get all elements at a given level\nfunction {:spec} getLevel(h: Heap, level: nat): seq<int>\n{\n  getLevelHelper(h, level, 0)\n}\n\nfunction getLevelHelper(h: Heap, targetLevel: nat, currentLevel: nat): seq<int>\n  decreases |h.elements| - currentLevel\n{\n  if currentLevel >= |h.elements| || currentLevel >= Power2(targetLevel) then []\n  else if currentLevel >= Power2(targetLevel) - 1 && currentLevel < Power2(targetLevel + 1) - 1 then\n    if currentLevel < |h.elements| then [h.elements[currentLevel]] + getLevelHelper(h, targetLevel, currentLevel + 1)\n    else []\n  else getLevelHelper(h, targetLevel, currentLevel + 1)\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1\n  else 2 * Power2(n - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma EmptyHeapIsMinHeap()\n  ensures isMinHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma EmptyHeapIsMaxHeap()\n  ensures isMaxHeap(emptyHeap())\n{\n  var h := emptyHeap();\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists\n  }\n}\n\nlemma SingletonIsMinHeap(x: int)\n  ensures isMinHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] <= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma SingletonIsMaxHeap(x: int)\n  ensures isMaxHeap(singletonHeap(x))\n{\n  var h := singletonHeap(x);\n  forall i | 0 < i < |h.elements|\n    ensures h.elements[parent(i)] >= h.elements[i]\n  {\n    assert false;  // No such i exists since |h.elements| == 1\n  }\n}\n\nlemma MinHeapRootIsMinimum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] <= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MinHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MinHeapPathToRoot(h: Heap, i: nat)\n  requires isMinHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] <= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] <= h.elements[i];\n  } else {\n    assert h.elements[parent(i)] <= h.elements[i];\n    MinHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma MaxHeapRootIsMaximum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] >= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      assert i == 0;\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MaxHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MaxHeapPathToRoot(h: Heap, i: nat)\n  requires isMaxHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] >= h.elements[i]\n{\n  if parent(i) == 0 {\n    assert h.elements[0] >= h.elements[i];\n  } else {\n    assert h.elements[parent(i)] >= h.elements[i];\n    MaxHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma ParentChildRelation(i: nat)\n  requires i > 0\n  ensures leftChild(parent(i)) == i || rightChild(parent(i)) == i\n  ensures leftChild(parent(i)) == i <==> i % 2 == 1\n  ensures rightChild(parent(i)) == i <==> i % 2 == 0\n{\n  var p := parent(i);\n  assert p == (i - 1) / 2;\n  assert leftChild(p) == 2 * p + 1;\n  assert rightChild(p) == 2 * p + 2;\n\n  if i % 2 == 1 {\n    assert i == 2 * ((i - 1) / 2) + 1;\n    assert leftChild(p) == i;\n  } else {\n    assert i % 2 == 0;\n    assert i == 2 * ((i - 1) / 2) + 2;\n    assert rightChild(p) == i;\n  }\n}\n\nlemma HeapHeightBound(h: Heap)\n  ensures heapHeight(h) <= |h.elements|\n{\n  if |h.elements| == 0 {\n    assert heapHeight(h) == 0;\n  } else {\n    Log2FloorBound(|h.elements|);\n  }\n}\n\nlemma Log2FloorBound(n: nat)\n  requires n > 0\n  ensures log2Floor(n) < n\n  decreases n\n{\n  if n == 1 {\n    assert log2Floor(1) == 0;\n  } else {\n    Log2FloorBound(n / 2);\n    assert log2Floor(n) == 1 + log2Floor(n / 2);\n    assert n / 2 < n;\n  }\n}\n\nlemma SwapPreservesMultiset(s: seq<int>, i: nat, j: nat)\n  requires i < |s| && j < |s|\n  ensures multiset(swap(s, i, j)) == multiset(s)\n{\n  var s' := swap(s, i, j);\n  \n/*[CODE HERE]*/\n  assert s'[j] == s[i];\n  forall k | 0 <= k < |s| && k != i && k != j\n    ensures s'[k] == s[k]\n  {\n    // Elements other than i and j are unchanged\n  }\n}", "output": "assert s'[i] == s[j];"}, {"id": "example_SumToFormula_0", "type": "assert", "program": "// Induction proofs with detailed reasoning steps\n\n// Sum of first n natural numbers\nfunction {:spec} sumTo(n: nat): nat\n{\n  if n == 0 then 0 else n + sumTo(n - 1)\n}\n\n// Sum of first n odd numbers\nfunction {:spec} sumOdds(n: nat): nat\n{\n  if n == 0 then 0 else (2 * n - 1) + sumOdds(n - 1)\n}\n\n// Sum of first n squares\nfunction {:spec} sumSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + sumSquares(n - 1)\n}\n\n// Power function\nfunction {:spec} power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\n// Fibonacci\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// --- Detailed Inductive Proofs ---\n\nlemma SumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    // Base case\n    assert sumTo(0) == 0;\n    assert 0 * (0 + 1) / 2 == 0;\n  } else {\n    // Inductive step\n    SumToFormula(n - 1);\n\n    calc == {\n      sumTo(n);\n      n + sumTo(n - 1);\n      { // Induction hypothesis\n        assert sumTo(n - 1) == (n - 1) * n / 2;\n      }\n      n + (n - 1) * n / 2;\n      { // Algebra\n        \n/*[CODE HERE]*/\n      }\n      2 * n / 2 + (n - 1) * n / 2;\n      (2 * n + (n - 1) * n) / 2;\n      (2 * n + n * n - n) / 2;\n      (n + n * n) / 2;\n      n * (1 + n) / 2;\n      n * (n + 1) / 2;\n    }\n  }\n}\n\nlemma SumOddsIsSquare(n: nat)\n  ensures sumOdds(n) == n * n\n{\n  if n == 0 {\n    // Base case\n    assert sumOdds(0) == 0;\n    assert 0 * 0 == 0;\n  } else {\n    // Inductive step\n    SumOddsIsSquare(n - 1);\n\n    calc == {\n      sumOdds(n);\n      (2 * n - 1) + sumOdds(n - 1);\n      { // Induction hypothesis\n        assert sumOdds(n - 1) == (n - 1) * (n - 1);\n      }\n      (2 * n - 1) + (n - 1) * (n - 1);\n      { // Expand (n-1)\u00b2\n        assert (n - 1) * (n - 1) == n * n - 2 * n + 1;\n      }\n      (2 * n - 1) + (n * n - 2 * n + 1);\n      2 * n - 1 + n * n - 2 * n + 1;\n      n * n;\n    }\n  }\n}\n\nlemma SumSquaresFormula(n: nat)\n  ensures sumSquares(n) == n * (n + 1) * (2 * n + 1) / 6\n{\n  if n == 0 {\n    // Base case\n    assert sumSquares(0) == 0;\n    assert 0 * (0 + 1) * (2 * 0 + 1) / 6 == 0;\n  } else {\n    // Inductive step\n    SumSquaresFormula(n - 1);\n\n    calc == {\n      sumSquares(n);\n      n * n + sumSquares(n - 1);\n      { // Induction hypothesis\n        assert sumSquares(n - 1) == (n - 1) * n * (2 * n - 1) / 6;\n      }\n      n * n + (n - 1) * n * (2 * n - 1) / 6;\n      { // Factor out common terms\n        assert n * n == 6 * n * n / 6;\n      }\n      6 * n * n / 6 + (n - 1) * n * (2 * n - 1) / 6;\n      (6 * n * n + (n - 1) * n * (2 * n - 1)) / 6;\n      { // Expand\n        assert (n - 1) * n * (2 * n - 1) == n * (n - 1) * (2 * n - 1);\n        assert n * (n - 1) * (2 * n - 1) == n * (2 * n * n - 3 * n + 1);\n        assert n * (2 * n * n - 3 * n + 1) == 2 * n * n * n - 3 * n * n + n;\n      }\n      (6 * n * n + 2 * n * n * n - 3 * n * n + n) / 6;\n      (2 * n * n * n + 3 * n * n + n) / 6;\n      n * (2 * n * n + 3 * n + 1) / 6;\n      { // Factor\n        assert 2 * n * n + 3 * n + 1 == (n + 1) * (2 * n + 1);\n      }\n      n * (n + 1) * (2 * n + 1) / 6;\n    }\n  }\n}\n\nlemma PowerOfTwo(n: nat)\n  ensures power(2, n) >= n + 1\n{\n  if n == 0 {\n    // Base case\n    assert power(2, 0) == 1;\n    assert 1 >= 0 + 1;\n  } else {\n    // Inductive step\n    PowerOfTwo(n - 1);\n\n    calc >= {\n      power(2, n);\n      2 * power(2, n - 1);\n      { // Induction hypothesis\n        assert power(2, n - 1) >= n;\n      }\n      2 * n;\n      { // Since n >= 1\n        assert n >= 1;\n        assert 2 * n >= n + 1;\n      }\n      n + 1;\n    }\n  }\n}\n\nlemma PowerMonotonic(base: nat, exp1: nat, exp2: nat)\n  requires base > 1\n  requires exp1 <= exp2\n  ensures power(base, exp1) <= power(base, exp2)\n{\n  if exp1 == exp2 {\n    // Equal case\n    assert power(base, exp1) == power(base, exp2);\n  } else {\n    // exp1 < exp2\n    assert exp1 < exp2;\n\n    if exp1 == 0 {\n      assert power(base, exp1) == 1;\n      PowerPositive(base, exp2);\n      assert power(base, exp2) >= 1;\n    } else {\n      // Both exp1 and exp2 are positive\n      PowerMonotonic(base, exp1 - 1, exp2 - 1);\n\n      calc <= {\n        power(base, exp1);\n        base * power(base, exp1 - 1);\n        { // Induction hypothesis\n          assert power(base, exp1 - 1) <= power(base, exp2 - 1);\n        }\n        base * power(base, exp2 - 1);\n        power(base, exp2);\n      }\n    }\n  }\n}\n\nlemma PowerPositive(base: nat, exp: nat)\n  requires base > 0\n  ensures power(base, exp) > 0\n{\n  if exp == 0 {\n    assert power(base, 0) == 1;\n  } else {\n    PowerPositive(base, exp - 1);\n    assert power(base, exp) == base * power(base, exp - 1);\n    assert base > 0 && power(base, exp - 1) > 0;\n  }\n}\n\nlemma FibonacciInequality(n: nat)\n  requires n >= 1\n  ensures fib(n) <= power(2, n - 1)\n{\n  if n == 1 {\n    // Base case\n    assert fib(1) == 1;\n    assert power(2, 0) == 1;\n  } else if n == 2 {\n    // Base case\n    assert fib(2) == 1;\n    assert power(2, 1) == 2;\n    assert 1 <= 2;\n  } else {\n    // Inductive step (n >= 3)\n    assert n >= 3;\n    FibonacciInequality(n - 1);\n    FibonacciInequality(n - 2);\n\n    calc <= {\n      fib(n);\n      fib(n - 1) + fib(n - 2);\n      { // Induction hypotheses\n        assert fib(n - 1) <= power(2, n - 2);\n        assert fib(n - 2) <= power(2, n - 3);\n      }\n      power(2, n - 2) + power(2, n - 3);\n      { // Factor out power(2, n - 3)\n        assert power(2, n - 2) == 2 * power(2, n - 3);\n      }\n      2 * power(2, n - 3) + power(2, n - 3);\n      3 * power(2, n - 3);\n      { // 3 * 2^(n-3) <= 4 * 2^(n-3) = 2^(n-1)\n        assert 3 <= 4;\n        assert power(2, n - 1) == 4 * power(2, n - 3);\n      }\n      power(2, n - 1);\n    }\n  }\n}\n\nlemma StrongInduction(n: nat, P: nat -> bool)\n  requires forall k :: 0 <= k < n ==> P(k)\n  requires forall m :: m >= n && (forall j :: n <= j < m ==> P(j)) ==> P(m)\n  ensures P(n)\n{\n  // This demonstrates the strong induction principle\n  // Base case: all k < n satisfy P(k) by hypothesis\n  // Inductive case: if all j in [n, m) satisfy P, then P(m) holds\n\n  // The proof would proceed by showing P(n) directly\n  // using the second hypothesis with m = n\n  assert forall j :: n <= j < n ==> P(j); // Vacuously true\n}\n\nlemma CompleteInduction(n: nat, P: nat -> bool)\n  requires P(0)\n  requires forall k: nat :: k > 0 && (forall j: nat :: j < k ==> P(j)) ==> P(k)\n  ensures P(n)\n{\n  if n == 0 {\n    // Base case\n    assert P(0);\n  } else {\n    // Need to show all j < n satisfy P(j)\n    forall j: nat | j < n\n      ensures P(j)\n    {\n      if j == 0 {\n        assert P(0);\n      } else {\n        CompleteInduction(j, P);\n      }\n    }\n\n    // Now apply the inductive hypothesis\n    assert forall j: nat :: j < n ==> P(j);\n    assert P(n);\n  }\n}", "output": "assert n == 2 * n / 2;"}, {"id": "example_SumToFormula_1", "type": "assert", "program": "// Induction proofs with detailed reasoning steps\n\n// Sum of first n natural numbers\nfunction {:spec} sumTo(n: nat): nat\n{\n  if n == 0 then 0 else n + sumTo(n - 1)\n}\n\n// Sum of first n odd numbers\nfunction {:spec} sumOdds(n: nat): nat\n{\n  if n == 0 then 0 else (2 * n - 1) + sumOdds(n - 1)\n}\n\n// Sum of first n squares\nfunction {:spec} sumSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + sumSquares(n - 1)\n}\n\n// Power function\nfunction {:spec} power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\n// Fibonacci\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// --- Detailed Inductive Proofs ---\n\nlemma SumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    // Base case\n    assert sumTo(0) == 0;\n    assert 0 * (0 + 1) / 2 == 0;\n  } else {\n    // Inductive step\n    SumToFormula(n - 1);\n\n    calc == {\n      sumTo(n);\n      n + sumTo(n - 1);\n      { // Induction hypothesis\n        \n/*[CODE HERE]*/\n      }\n      n + (n - 1) * n / 2;\n      { // Algebra\n        assert n == 2 * n / 2;\n      }\n      2 * n / 2 + (n - 1) * n / 2;\n      (2 * n + (n - 1) * n) / 2;\n      (2 * n + n * n - n) / 2;\n      (n + n * n) / 2;\n      n * (1 + n) / 2;\n      n * (n + 1) / 2;\n    }\n  }\n}\n\nlemma SumOddsIsSquare(n: nat)\n  ensures sumOdds(n) == n * n\n{\n  if n == 0 {\n    // Base case\n    assert sumOdds(0) == 0;\n    assert 0 * 0 == 0;\n  } else {\n    // Inductive step\n    SumOddsIsSquare(n - 1);\n\n    calc == {\n      sumOdds(n);\n      (2 * n - 1) + sumOdds(n - 1);\n      { // Induction hypothesis\n        assert sumOdds(n - 1) == (n - 1) * (n - 1);\n      }\n      (2 * n - 1) + (n - 1) * (n - 1);\n      { // Expand (n-1)\u00b2\n        assert (n - 1) * (n - 1) == n * n - 2 * n + 1;\n      }\n      (2 * n - 1) + (n * n - 2 * n + 1);\n      2 * n - 1 + n * n - 2 * n + 1;\n      n * n;\n    }\n  }\n}\n\nlemma SumSquaresFormula(n: nat)\n  ensures sumSquares(n) == n * (n + 1) * (2 * n + 1) / 6\n{\n  if n == 0 {\n    // Base case\n    assert sumSquares(0) == 0;\n    assert 0 * (0 + 1) * (2 * 0 + 1) / 6 == 0;\n  } else {\n    // Inductive step\n    SumSquaresFormula(n - 1);\n\n    calc == {\n      sumSquares(n);\n      n * n + sumSquares(n - 1);\n      { // Induction hypothesis\n        assert sumSquares(n - 1) == (n - 1) * n * (2 * n - 1) / 6;\n      }\n      n * n + (n - 1) * n * (2 * n - 1) / 6;\n      { // Factor out common terms\n        assert n * n == 6 * n * n / 6;\n      }\n      6 * n * n / 6 + (n - 1) * n * (2 * n - 1) / 6;\n      (6 * n * n + (n - 1) * n * (2 * n - 1)) / 6;\n      { // Expand\n        assert (n - 1) * n * (2 * n - 1) == n * (n - 1) * (2 * n - 1);\n        assert n * (n - 1) * (2 * n - 1) == n * (2 * n * n - 3 * n + 1);\n        assert n * (2 * n * n - 3 * n + 1) == 2 * n * n * n - 3 * n * n + n;\n      }\n      (6 * n * n + 2 * n * n * n - 3 * n * n + n) / 6;\n      (2 * n * n * n + 3 * n * n + n) / 6;\n      n * (2 * n * n + 3 * n + 1) / 6;\n      { // Factor\n        assert 2 * n * n + 3 * n + 1 == (n + 1) * (2 * n + 1);\n      }\n      n * (n + 1) * (2 * n + 1) / 6;\n    }\n  }\n}\n\nlemma PowerOfTwo(n: nat)\n  ensures power(2, n) >= n + 1\n{\n  if n == 0 {\n    // Base case\n    assert power(2, 0) == 1;\n    assert 1 >= 0 + 1;\n  } else {\n    // Inductive step\n    PowerOfTwo(n - 1);\n\n    calc >= {\n      power(2, n);\n      2 * power(2, n - 1);\n      { // Induction hypothesis\n        assert power(2, n - 1) >= n;\n      }\n      2 * n;\n      { // Since n >= 1\n        assert n >= 1;\n        assert 2 * n >= n + 1;\n      }\n      n + 1;\n    }\n  }\n}\n\nlemma PowerMonotonic(base: nat, exp1: nat, exp2: nat)\n  requires base > 1\n  requires exp1 <= exp2\n  ensures power(base, exp1) <= power(base, exp2)\n{\n  if exp1 == exp2 {\n    // Equal case\n    assert power(base, exp1) == power(base, exp2);\n  } else {\n    // exp1 < exp2\n    assert exp1 < exp2;\n\n    if exp1 == 0 {\n      assert power(base, exp1) == 1;\n      PowerPositive(base, exp2);\n      assert power(base, exp2) >= 1;\n    } else {\n      // Both exp1 and exp2 are positive\n      PowerMonotonic(base, exp1 - 1, exp2 - 1);\n\n      calc <= {\n        power(base, exp1);\n        base * power(base, exp1 - 1);\n        { // Induction hypothesis\n          assert power(base, exp1 - 1) <= power(base, exp2 - 1);\n        }\n        base * power(base, exp2 - 1);\n        power(base, exp2);\n      }\n    }\n  }\n}\n\nlemma PowerPositive(base: nat, exp: nat)\n  requires base > 0\n  ensures power(base, exp) > 0\n{\n  if exp == 0 {\n    assert power(base, 0) == 1;\n  } else {\n    PowerPositive(base, exp - 1);\n    assert power(base, exp) == base * power(base, exp - 1);\n    assert base > 0 && power(base, exp - 1) > 0;\n  }\n}\n\nlemma FibonacciInequality(n: nat)\n  requires n >= 1\n  ensures fib(n) <= power(2, n - 1)\n{\n  if n == 1 {\n    // Base case\n    assert fib(1) == 1;\n    assert power(2, 0) == 1;\n  } else if n == 2 {\n    // Base case\n    assert fib(2) == 1;\n    assert power(2, 1) == 2;\n    assert 1 <= 2;\n  } else {\n    // Inductive step (n >= 3)\n    assert n >= 3;\n    FibonacciInequality(n - 1);\n    FibonacciInequality(n - 2);\n\n    calc <= {\n      fib(n);\n      fib(n - 1) + fib(n - 2);\n      { // Induction hypotheses\n        assert fib(n - 1) <= power(2, n - 2);\n        assert fib(n - 2) <= power(2, n - 3);\n      }\n      power(2, n - 2) + power(2, n - 3);\n      { // Factor out power(2, n - 3)\n        assert power(2, n - 2) == 2 * power(2, n - 3);\n      }\n      2 * power(2, n - 3) + power(2, n - 3);\n      3 * power(2, n - 3);\n      { // 3 * 2^(n-3) <= 4 * 2^(n-3) = 2^(n-1)\n        assert 3 <= 4;\n        assert power(2, n - 1) == 4 * power(2, n - 3);\n      }\n      power(2, n - 1);\n    }\n  }\n}\n\nlemma StrongInduction(n: nat, P: nat -> bool)\n  requires forall k :: 0 <= k < n ==> P(k)\n  requires forall m :: m >= n && (forall j :: n <= j < m ==> P(j)) ==> P(m)\n  ensures P(n)\n{\n  // This demonstrates the strong induction principle\n  // Base case: all k < n satisfy P(k) by hypothesis\n  // Inductive case: if all j in [n, m) satisfy P, then P(m) holds\n\n  // The proof would proceed by showing P(n) directly\n  // using the second hypothesis with m = n\n  assert forall j :: n <= j < n ==> P(j); // Vacuously true\n}\n\nlemma CompleteInduction(n: nat, P: nat -> bool)\n  requires P(0)\n  requires forall k: nat :: k > 0 && (forall j: nat :: j < k ==> P(j)) ==> P(k)\n  ensures P(n)\n{\n  if n == 0 {\n    // Base case\n    assert P(0);\n  } else {\n    // Need to show all j < n satisfy P(j)\n    forall j: nat | j < n\n      ensures P(j)\n    {\n      if j == 0 {\n        assert P(0);\n      } else {\n        CompleteInduction(j, P);\n      }\n    }\n\n    // Now apply the inductive hypothesis\n    assert forall j: nat :: j < n ==> P(j);\n    assert P(n);\n  }\n}", "output": "assert sumTo(n - 1) == (n - 1) * n / 2;"}, {"id": "example_SumToFormula_2", "type": "call", "program": "// Induction proofs with detailed reasoning steps\n\n// Sum of first n natural numbers\nfunction {:spec} sumTo(n: nat): nat\n{\n  if n == 0 then 0 else n + sumTo(n - 1)\n}\n\n// Sum of first n odd numbers\nfunction {:spec} sumOdds(n: nat): nat\n{\n  if n == 0 then 0 else (2 * n - 1) + sumOdds(n - 1)\n}\n\n// Sum of first n squares\nfunction {:spec} sumSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + sumSquares(n - 1)\n}\n\n// Power function\nfunction {:spec} power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\n// Fibonacci\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// --- Detailed Inductive Proofs ---\n\nlemma SumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    // Base case\n    assert sumTo(0) == 0;\n    assert 0 * (0 + 1) / 2 == 0;\n  } else {\n    // Inductive step\n    \n/*[CODE HERE]*/\n\n    calc == {\n      sumTo(n);\n      n + sumTo(n - 1);\n      { // Induction hypothesis\n        assert sumTo(n - 1) == (n - 1) * n / 2;\n      }\n      n + (n - 1) * n / 2;\n      { // Algebra\n        assert n == 2 * n / 2;\n      }\n      2 * n / 2 + (n - 1) * n / 2;\n      (2 * n + (n - 1) * n) / 2;\n      (2 * n + n * n - n) / 2;\n      (n + n * n) / 2;\n      n * (1 + n) / 2;\n      n * (n + 1) / 2;\n    }\n  }\n}\n\nlemma SumOddsIsSquare(n: nat)\n  ensures sumOdds(n) == n * n\n{\n  if n == 0 {\n    // Base case\n    assert sumOdds(0) == 0;\n    assert 0 * 0 == 0;\n  } else {\n    // Inductive step\n    SumOddsIsSquare(n - 1);\n\n    calc == {\n      sumOdds(n);\n      (2 * n - 1) + sumOdds(n - 1);\n      { // Induction hypothesis\n        assert sumOdds(n - 1) == (n - 1) * (n - 1);\n      }\n      (2 * n - 1) + (n - 1) * (n - 1);\n      { // Expand (n-1)\u00b2\n        assert (n - 1) * (n - 1) == n * n - 2 * n + 1;\n      }\n      (2 * n - 1) + (n * n - 2 * n + 1);\n      2 * n - 1 + n * n - 2 * n + 1;\n      n * n;\n    }\n  }\n}\n\nlemma SumSquaresFormula(n: nat)\n  ensures sumSquares(n) == n * (n + 1) * (2 * n + 1) / 6\n{\n  if n == 0 {\n    // Base case\n    assert sumSquares(0) == 0;\n    assert 0 * (0 + 1) * (2 * 0 + 1) / 6 == 0;\n  } else {\n    // Inductive step\n    SumSquaresFormula(n - 1);\n\n    calc == {\n      sumSquares(n);\n      n * n + sumSquares(n - 1);\n      { // Induction hypothesis\n        assert sumSquares(n - 1) == (n - 1) * n * (2 * n - 1) / 6;\n      }\n      n * n + (n - 1) * n * (2 * n - 1) / 6;\n      { // Factor out common terms\n        assert n * n == 6 * n * n / 6;\n      }\n      6 * n * n / 6 + (n - 1) * n * (2 * n - 1) / 6;\n      (6 * n * n + (n - 1) * n * (2 * n - 1)) / 6;\n      { // Expand\n        assert (n - 1) * n * (2 * n - 1) == n * (n - 1) * (2 * n - 1);\n        assert n * (n - 1) * (2 * n - 1) == n * (2 * n * n - 3 * n + 1);\n        assert n * (2 * n * n - 3 * n + 1) == 2 * n * n * n - 3 * n * n + n;\n      }\n      (6 * n * n + 2 * n * n * n - 3 * n * n + n) / 6;\n      (2 * n * n * n + 3 * n * n + n) / 6;\n      n * (2 * n * n + 3 * n + 1) / 6;\n      { // Factor\n        assert 2 * n * n + 3 * n + 1 == (n + 1) * (2 * n + 1);\n      }\n      n * (n + 1) * (2 * n + 1) / 6;\n    }\n  }\n}\n\nlemma PowerOfTwo(n: nat)\n  ensures power(2, n) >= n + 1\n{\n  if n == 0 {\n    // Base case\n    assert power(2, 0) == 1;\n    assert 1 >= 0 + 1;\n  } else {\n    // Inductive step\n    PowerOfTwo(n - 1);\n\n    calc >= {\n      power(2, n);\n      2 * power(2, n - 1);\n      { // Induction hypothesis\n        assert power(2, n - 1) >= n;\n      }\n      2 * n;\n      { // Since n >= 1\n        assert n >= 1;\n        assert 2 * n >= n + 1;\n      }\n      n + 1;\n    }\n  }\n}\n\nlemma PowerMonotonic(base: nat, exp1: nat, exp2: nat)\n  requires base > 1\n  requires exp1 <= exp2\n  ensures power(base, exp1) <= power(base, exp2)\n{\n  if exp1 == exp2 {\n    // Equal case\n    assert power(base, exp1) == power(base, exp2);\n  } else {\n    // exp1 < exp2\n    assert exp1 < exp2;\n\n    if exp1 == 0 {\n      assert power(base, exp1) == 1;\n      PowerPositive(base, exp2);\n      assert power(base, exp2) >= 1;\n    } else {\n      // Both exp1 and exp2 are positive\n      PowerMonotonic(base, exp1 - 1, exp2 - 1);\n\n      calc <= {\n        power(base, exp1);\n        base * power(base, exp1 - 1);\n        { // Induction hypothesis\n          assert power(base, exp1 - 1) <= power(base, exp2 - 1);\n        }\n        base * power(base, exp2 - 1);\n        power(base, exp2);\n      }\n    }\n  }\n}\n\nlemma PowerPositive(base: nat, exp: nat)\n  requires base > 0\n  ensures power(base, exp) > 0\n{\n  if exp == 0 {\n    assert power(base, 0) == 1;\n  } else {\n    PowerPositive(base, exp - 1);\n    assert power(base, exp) == base * power(base, exp - 1);\n    assert base > 0 && power(base, exp - 1) > 0;\n  }\n}\n\nlemma FibonacciInequality(n: nat)\n  requires n >= 1\n  ensures fib(n) <= power(2, n - 1)\n{\n  if n == 1 {\n    // Base case\n    assert fib(1) == 1;\n    assert power(2, 0) == 1;\n  } else if n == 2 {\n    // Base case\n    assert fib(2) == 1;\n    assert power(2, 1) == 2;\n    assert 1 <= 2;\n  } else {\n    // Inductive step (n >= 3)\n    assert n >= 3;\n    FibonacciInequality(n - 1);\n    FibonacciInequality(n - 2);\n\n    calc <= {\n      fib(n);\n      fib(n - 1) + fib(n - 2);\n      { // Induction hypotheses\n        assert fib(n - 1) <= power(2, n - 2);\n        assert fib(n - 2) <= power(2, n - 3);\n      }\n      power(2, n - 2) + power(2, n - 3);\n      { // Factor out power(2, n - 3)\n        assert power(2, n - 2) == 2 * power(2, n - 3);\n      }\n      2 * power(2, n - 3) + power(2, n - 3);\n      3 * power(2, n - 3);\n      { // 3 * 2^(n-3) <= 4 * 2^(n-3) = 2^(n-1)\n        assert 3 <= 4;\n        assert power(2, n - 1) == 4 * power(2, n - 3);\n      }\n      power(2, n - 1);\n    }\n  }\n}\n\nlemma StrongInduction(n: nat, P: nat -> bool)\n  requires forall k :: 0 <= k < n ==> P(k)\n  requires forall m :: m >= n && (forall j :: n <= j < m ==> P(j)) ==> P(m)\n  ensures P(n)\n{\n  // This demonstrates the strong induction principle\n  // Base case: all k < n satisfy P(k) by hypothesis\n  // Inductive case: if all j in [n, m) satisfy P, then P(m) holds\n\n  // The proof would proceed by showing P(n) directly\n  // using the second hypothesis with m = n\n  assert forall j :: n <= j < n ==> P(j); // Vacuously true\n}\n\nlemma CompleteInduction(n: nat, P: nat -> bool)\n  requires P(0)\n  requires forall k: nat :: k > 0 && (forall j: nat :: j < k ==> P(j)) ==> P(k)\n  ensures P(n)\n{\n  if n == 0 {\n    // Base case\n    assert P(0);\n  } else {\n    // Need to show all j < n satisfy P(j)\n    forall j: nat | j < n\n      ensures P(j)\n    {\n      if j == 0 {\n        assert P(0);\n      } else {\n        CompleteInduction(j, P);\n      }\n    }\n\n    // Now apply the inductive hypothesis\n    assert forall j: nat :: j < n ==> P(j);\n    assert P(n);\n  }\n}", "output": "SumToFormula(n - 1);"}, {"id": "example_SumToFormula_3", "type": "assert", "program": "// Induction proofs with detailed reasoning steps\n\n// Sum of first n natural numbers\nfunction {:spec} sumTo(n: nat): nat\n{\n  if n == 0 then 0 else n + sumTo(n - 1)\n}\n\n// Sum of first n odd numbers\nfunction {:spec} sumOdds(n: nat): nat\n{\n  if n == 0 then 0 else (2 * n - 1) + sumOdds(n - 1)\n}\n\n// Sum of first n squares\nfunction {:spec} sumSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + sumSquares(n - 1)\n}\n\n// Power function\nfunction {:spec} power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\n// Fibonacci\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// --- Detailed Inductive Proofs ---\n\nlemma SumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    // Base case\n    assert sumTo(0) == 0;\n    \n/*[CODE HERE]*/\n  } else {\n    // Inductive step\n    SumToFormula(n - 1);\n\n    calc == {\n      sumTo(n);\n      n + sumTo(n - 1);\n      { // Induction hypothesis\n        assert sumTo(n - 1) == (n - 1) * n / 2;\n      }\n      n + (n - 1) * n / 2;\n      { // Algebra\n        assert n == 2 * n / 2;\n      }\n      2 * n / 2 + (n - 1) * n / 2;\n      (2 * n + (n - 1) * n) / 2;\n      (2 * n + n * n - n) / 2;\n      (n + n * n) / 2;\n      n * (1 + n) / 2;\n      n * (n + 1) / 2;\n    }\n  }\n}\n\nlemma SumOddsIsSquare(n: nat)\n  ensures sumOdds(n) == n * n\n{\n  if n == 0 {\n    // Base case\n    assert sumOdds(0) == 0;\n    assert 0 * 0 == 0;\n  } else {\n    // Inductive step\n    SumOddsIsSquare(n - 1);\n\n    calc == {\n      sumOdds(n);\n      (2 * n - 1) + sumOdds(n - 1);\n      { // Induction hypothesis\n        assert sumOdds(n - 1) == (n - 1) * (n - 1);\n      }\n      (2 * n - 1) + (n - 1) * (n - 1);\n      { // Expand (n-1)\u00b2\n        assert (n - 1) * (n - 1) == n * n - 2 * n + 1;\n      }\n      (2 * n - 1) + (n * n - 2 * n + 1);\n      2 * n - 1 + n * n - 2 * n + 1;\n      n * n;\n    }\n  }\n}\n\nlemma SumSquaresFormula(n: nat)\n  ensures sumSquares(n) == n * (n + 1) * (2 * n + 1) / 6\n{\n  if n == 0 {\n    // Base case\n    assert sumSquares(0) == 0;\n    assert 0 * (0 + 1) * (2 * 0 + 1) / 6 == 0;\n  } else {\n    // Inductive step\n    SumSquaresFormula(n - 1);\n\n    calc == {\n      sumSquares(n);\n      n * n + sumSquares(n - 1);\n      { // Induction hypothesis\n        assert sumSquares(n - 1) == (n - 1) * n * (2 * n - 1) / 6;\n      }\n      n * n + (n - 1) * n * (2 * n - 1) / 6;\n      { // Factor out common terms\n        assert n * n == 6 * n * n / 6;\n      }\n      6 * n * n / 6 + (n - 1) * n * (2 * n - 1) / 6;\n      (6 * n * n + (n - 1) * n * (2 * n - 1)) / 6;\n      { // Expand\n        assert (n - 1) * n * (2 * n - 1) == n * (n - 1) * (2 * n - 1);\n        assert n * (n - 1) * (2 * n - 1) == n * (2 * n * n - 3 * n + 1);\n        assert n * (2 * n * n - 3 * n + 1) == 2 * n * n * n - 3 * n * n + n;\n      }\n      (6 * n * n + 2 * n * n * n - 3 * n * n + n) / 6;\n      (2 * n * n * n + 3 * n * n + n) / 6;\n      n * (2 * n * n + 3 * n + 1) / 6;\n      { // Factor\n        assert 2 * n * n + 3 * n + 1 == (n + 1) * (2 * n + 1);\n      }\n      n * (n + 1) * (2 * n + 1) / 6;\n    }\n  }\n}\n\nlemma PowerOfTwo(n: nat)\n  ensures power(2, n) >= n + 1\n{\n  if n == 0 {\n    // Base case\n    assert power(2, 0) == 1;\n    assert 1 >= 0 + 1;\n  } else {\n    // Inductive step\n    PowerOfTwo(n - 1);\n\n    calc >= {\n      power(2, n);\n      2 * power(2, n - 1);\n      { // Induction hypothesis\n        assert power(2, n - 1) >= n;\n      }\n      2 * n;\n      { // Since n >= 1\n        assert n >= 1;\n        assert 2 * n >= n + 1;\n      }\n      n + 1;\n    }\n  }\n}\n\nlemma PowerMonotonic(base: nat, exp1: nat, exp2: nat)\n  requires base > 1\n  requires exp1 <= exp2\n  ensures power(base, exp1) <= power(base, exp2)\n{\n  if exp1 == exp2 {\n    // Equal case\n    assert power(base, exp1) == power(base, exp2);\n  } else {\n    // exp1 < exp2\n    assert exp1 < exp2;\n\n    if exp1 == 0 {\n      assert power(base, exp1) == 1;\n      PowerPositive(base, exp2);\n      assert power(base, exp2) >= 1;\n    } else {\n      // Both exp1 and exp2 are positive\n      PowerMonotonic(base, exp1 - 1, exp2 - 1);\n\n      calc <= {\n        power(base, exp1);\n        base * power(base, exp1 - 1);\n        { // Induction hypothesis\n          assert power(base, exp1 - 1) <= power(base, exp2 - 1);\n        }\n        base * power(base, exp2 - 1);\n        power(base, exp2);\n      }\n    }\n  }\n}\n\nlemma PowerPositive(base: nat, exp: nat)\n  requires base > 0\n  ensures power(base, exp) > 0\n{\n  if exp == 0 {\n    assert power(base, 0) == 1;\n  } else {\n    PowerPositive(base, exp - 1);\n    assert power(base, exp) == base * power(base, exp - 1);\n    assert base > 0 && power(base, exp - 1) > 0;\n  }\n}\n\nlemma FibonacciInequality(n: nat)\n  requires n >= 1\n  ensures fib(n) <= power(2, n - 1)\n{\n  if n == 1 {\n    // Base case\n    assert fib(1) == 1;\n    assert power(2, 0) == 1;\n  } else if n == 2 {\n    // Base case\n    assert fib(2) == 1;\n    assert power(2, 1) == 2;\n    assert 1 <= 2;\n  } else {\n    // Inductive step (n >= 3)\n    assert n >= 3;\n    FibonacciInequality(n - 1);\n    FibonacciInequality(n - 2);\n\n    calc <= {\n      fib(n);\n      fib(n - 1) + fib(n - 2);\n      { // Induction hypotheses\n        assert fib(n - 1) <= power(2, n - 2);\n        assert fib(n - 2) <= power(2, n - 3);\n      }\n      power(2, n - 2) + power(2, n - 3);\n      { // Factor out power(2, n - 3)\n        assert power(2, n - 2) == 2 * power(2, n - 3);\n      }\n      2 * power(2, n - 3) + power(2, n - 3);\n      3 * power(2, n - 3);\n      { // 3 * 2^(n-3) <= 4 * 2^(n-3) = 2^(n-1)\n        assert 3 <= 4;\n        assert power(2, n - 1) == 4 * power(2, n - 3);\n      }\n      power(2, n - 1);\n    }\n  }\n}\n\nlemma StrongInduction(n: nat, P: nat -> bool)\n  requires forall k :: 0 <= k < n ==> P(k)\n  requires forall m :: m >= n && (forall j :: n <= j < m ==> P(j)) ==> P(m)\n  ensures P(n)\n{\n  // This demonstrates the strong induction principle\n  // Base case: all k < n satisfy P(k) by hypothesis\n  // Inductive case: if all j in [n, m) satisfy P, then P(m) holds\n\n  // The proof would proceed by showing P(n) directly\n  // using the second hypothesis with m = n\n  assert forall j :: n <= j < n ==> P(j); // Vacuously true\n}\n\nlemma CompleteInduction(n: nat, P: nat -> bool)\n  requires P(0)\n  requires forall k: nat :: k > 0 && (forall j: nat :: j < k ==> P(j)) ==> P(k)\n  ensures P(n)\n{\n  if n == 0 {\n    // Base case\n    assert P(0);\n  } else {\n    // Need to show all j < n satisfy P(j)\n    forall j: nat | j < n\n      ensures P(j)\n    {\n      if j == 0 {\n        assert P(0);\n      } else {\n        CompleteInduction(j, P);\n      }\n    }\n\n    // Now apply the inductive hypothesis\n    assert forall j: nat :: j < n ==> P(j);\n    assert P(n);\n  }\n}", "output": "assert 0 * (0 + 1) / 2 == 0;"}, {"id": "example_SumToFormula_4", "type": "assert", "program": "// Induction proofs with detailed reasoning steps\n\n// Sum of first n natural numbers\nfunction {:spec} sumTo(n: nat): nat\n{\n  if n == 0 then 0 else n + sumTo(n - 1)\n}\n\n// Sum of first n odd numbers\nfunction {:spec} sumOdds(n: nat): nat\n{\n  if n == 0 then 0 else (2 * n - 1) + sumOdds(n - 1)\n}\n\n// Sum of first n squares\nfunction {:spec} sumSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + sumSquares(n - 1)\n}\n\n// Power function\nfunction {:spec} power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\n// Fibonacci\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// --- Detailed Inductive Proofs ---\n\nlemma SumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    // Base case\n    \n/*[CODE HERE]*/\n    assert 0 * (0 + 1) / 2 == 0;\n  } else {\n    // Inductive step\n    SumToFormula(n - 1);\n\n    calc == {\n      sumTo(n);\n      n + sumTo(n - 1);\n      { // Induction hypothesis\n        assert sumTo(n - 1) == (n - 1) * n / 2;\n      }\n      n + (n - 1) * n / 2;\n      { // Algebra\n        assert n == 2 * n / 2;\n      }\n      2 * n / 2 + (n - 1) * n / 2;\n      (2 * n + (n - 1) * n) / 2;\n      (2 * n + n * n - n) / 2;\n      (n + n * n) / 2;\n      n * (1 + n) / 2;\n      n * (n + 1) / 2;\n    }\n  }\n}\n\nlemma SumOddsIsSquare(n: nat)\n  ensures sumOdds(n) == n * n\n{\n  if n == 0 {\n    // Base case\n    assert sumOdds(0) == 0;\n    assert 0 * 0 == 0;\n  } else {\n    // Inductive step\n    SumOddsIsSquare(n - 1);\n\n    calc == {\n      sumOdds(n);\n      (2 * n - 1) + sumOdds(n - 1);\n      { // Induction hypothesis\n        assert sumOdds(n - 1) == (n - 1) * (n - 1);\n      }\n      (2 * n - 1) + (n - 1) * (n - 1);\n      { // Expand (n-1)\u00b2\n        assert (n - 1) * (n - 1) == n * n - 2 * n + 1;\n      }\n      (2 * n - 1) + (n * n - 2 * n + 1);\n      2 * n - 1 + n * n - 2 * n + 1;\n      n * n;\n    }\n  }\n}\n\nlemma SumSquaresFormula(n: nat)\n  ensures sumSquares(n) == n * (n + 1) * (2 * n + 1) / 6\n{\n  if n == 0 {\n    // Base case\n    assert sumSquares(0) == 0;\n    assert 0 * (0 + 1) * (2 * 0 + 1) / 6 == 0;\n  } else {\n    // Inductive step\n    SumSquaresFormula(n - 1);\n\n    calc == {\n      sumSquares(n);\n      n * n + sumSquares(n - 1);\n      { // Induction hypothesis\n        assert sumSquares(n - 1) == (n - 1) * n * (2 * n - 1) / 6;\n      }\n      n * n + (n - 1) * n * (2 * n - 1) / 6;\n      { // Factor out common terms\n        assert n * n == 6 * n * n / 6;\n      }\n      6 * n * n / 6 + (n - 1) * n * (2 * n - 1) / 6;\n      (6 * n * n + (n - 1) * n * (2 * n - 1)) / 6;\n      { // Expand\n        assert (n - 1) * n * (2 * n - 1) == n * (n - 1) * (2 * n - 1);\n        assert n * (n - 1) * (2 * n - 1) == n * (2 * n * n - 3 * n + 1);\n        assert n * (2 * n * n - 3 * n + 1) == 2 * n * n * n - 3 * n * n + n;\n      }\n      (6 * n * n + 2 * n * n * n - 3 * n * n + n) / 6;\n      (2 * n * n * n + 3 * n * n + n) / 6;\n      n * (2 * n * n + 3 * n + 1) / 6;\n      { // Factor\n        assert 2 * n * n + 3 * n + 1 == (n + 1) * (2 * n + 1);\n      }\n      n * (n + 1) * (2 * n + 1) / 6;\n    }\n  }\n}\n\nlemma PowerOfTwo(n: nat)\n  ensures power(2, n) >= n + 1\n{\n  if n == 0 {\n    // Base case\n    assert power(2, 0) == 1;\n    assert 1 >= 0 + 1;\n  } else {\n    // Inductive step\n    PowerOfTwo(n - 1);\n\n    calc >= {\n      power(2, n);\n      2 * power(2, n - 1);\n      { // Induction hypothesis\n        assert power(2, n - 1) >= n;\n      }\n      2 * n;\n      { // Since n >= 1\n        assert n >= 1;\n        assert 2 * n >= n + 1;\n      }\n      n + 1;\n    }\n  }\n}\n\nlemma PowerMonotonic(base: nat, exp1: nat, exp2: nat)\n  requires base > 1\n  requires exp1 <= exp2\n  ensures power(base, exp1) <= power(base, exp2)\n{\n  if exp1 == exp2 {\n    // Equal case\n    assert power(base, exp1) == power(base, exp2);\n  } else {\n    // exp1 < exp2\n    assert exp1 < exp2;\n\n    if exp1 == 0 {\n      assert power(base, exp1) == 1;\n      PowerPositive(base, exp2);\n      assert power(base, exp2) >= 1;\n    } else {\n      // Both exp1 and exp2 are positive\n      PowerMonotonic(base, exp1 - 1, exp2 - 1);\n\n      calc <= {\n        power(base, exp1);\n        base * power(base, exp1 - 1);\n        { // Induction hypothesis\n          assert power(base, exp1 - 1) <= power(base, exp2 - 1);\n        }\n        base * power(base, exp2 - 1);\n        power(base, exp2);\n      }\n    }\n  }\n}\n\nlemma PowerPositive(base: nat, exp: nat)\n  requires base > 0\n  ensures power(base, exp) > 0\n{\n  if exp == 0 {\n    assert power(base, 0) == 1;\n  } else {\n    PowerPositive(base, exp - 1);\n    assert power(base, exp) == base * power(base, exp - 1);\n    assert base > 0 && power(base, exp - 1) > 0;\n  }\n}\n\nlemma FibonacciInequality(n: nat)\n  requires n >= 1\n  ensures fib(n) <= power(2, n - 1)\n{\n  if n == 1 {\n    // Base case\n    assert fib(1) == 1;\n    assert power(2, 0) == 1;\n  } else if n == 2 {\n    // Base case\n    assert fib(2) == 1;\n    assert power(2, 1) == 2;\n    assert 1 <= 2;\n  } else {\n    // Inductive step (n >= 3)\n    assert n >= 3;\n    FibonacciInequality(n - 1);\n    FibonacciInequality(n - 2);\n\n    calc <= {\n      fib(n);\n      fib(n - 1) + fib(n - 2);\n      { // Induction hypotheses\n        assert fib(n - 1) <= power(2, n - 2);\n        assert fib(n - 2) <= power(2, n - 3);\n      }\n      power(2, n - 2) + power(2, n - 3);\n      { // Factor out power(2, n - 3)\n        assert power(2, n - 2) == 2 * power(2, n - 3);\n      }\n      2 * power(2, n - 3) + power(2, n - 3);\n      3 * power(2, n - 3);\n      { // 3 * 2^(n-3) <= 4 * 2^(n-3) = 2^(n-1)\n        assert 3 <= 4;\n        assert power(2, n - 1) == 4 * power(2, n - 3);\n      }\n      power(2, n - 1);\n    }\n  }\n}\n\nlemma StrongInduction(n: nat, P: nat -> bool)\n  requires forall k :: 0 <= k < n ==> P(k)\n  requires forall m :: m >= n && (forall j :: n <= j < m ==> P(j)) ==> P(m)\n  ensures P(n)\n{\n  // This demonstrates the strong induction principle\n  // Base case: all k < n satisfy P(k) by hypothesis\n  // Inductive case: if all j in [n, m) satisfy P, then P(m) holds\n\n  // The proof would proceed by showing P(n) directly\n  // using the second hypothesis with m = n\n  assert forall j :: n <= j < n ==> P(j); // Vacuously true\n}\n\nlemma CompleteInduction(n: nat, P: nat -> bool)\n  requires P(0)\n  requires forall k: nat :: k > 0 && (forall j: nat :: j < k ==> P(j)) ==> P(k)\n  ensures P(n)\n{\n  if n == 0 {\n    // Base case\n    assert P(0);\n  } else {\n    // Need to show all j < n satisfy P(j)\n    forall j: nat | j < n\n      ensures P(j)\n    {\n      if j == 0 {\n        assert P(0);\n      } else {\n        CompleteInduction(j, P);\n      }\n    }\n\n    // Now apply the inductive hypothesis\n    assert forall j: nat :: j < n ==> P(j);\n    assert P(n);\n  }\n}", "output": "assert sumTo(0) == 0;"}, {"id": "example_SumOddsIsSquare_0", "type": "assert", "program": "// Induction proofs with detailed reasoning steps\n\n// Sum of first n natural numbers\nfunction {:spec} sumTo(n: nat): nat\n{\n  if n == 0 then 0 else n + sumTo(n - 1)\n}\n\n// Sum of first n odd numbers\nfunction {:spec} sumOdds(n: nat): nat\n{\n  if n == 0 then 0 else (2 * n - 1) + sumOdds(n - 1)\n}\n\n// Sum of first n squares\nfunction {:spec} sumSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + sumSquares(n - 1)\n}\n\n// Power function\nfunction {:spec} power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\n// Fibonacci\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// --- Detailed Inductive Proofs ---\n\nlemma SumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    // Base case\n    assert sumTo(0) == 0;\n    assert 0 * (0 + 1) / 2 == 0;\n  } else {\n    // Inductive step\n    SumToFormula(n - 1);\n\n    calc == {\n      sumTo(n);\n      n + sumTo(n - 1);\n      { // Induction hypothesis\n        assert sumTo(n - 1) == (n - 1) * n / 2;\n      }\n      n + (n - 1) * n / 2;\n      { // Algebra\n        assert n == 2 * n / 2;\n      }\n      2 * n / 2 + (n - 1) * n / 2;\n      (2 * n + (n - 1) * n) / 2;\n      (2 * n + n * n - n) / 2;\n      (n + n * n) / 2;\n      n * (1 + n) / 2;\n      n * (n + 1) / 2;\n    }\n  }\n}\n\nlemma SumOddsIsSquare(n: nat)\n  ensures sumOdds(n) == n * n\n{\n  if n == 0 {\n    // Base case\n    assert sumOdds(0) == 0;\n    assert 0 * 0 == 0;\n  } else {\n    // Inductive step\n    SumOddsIsSquare(n - 1);\n\n    calc == {\n      sumOdds(n);\n      (2 * n - 1) + sumOdds(n - 1);\n      { // Induction hypothesis\n        assert sumOdds(n - 1) == (n - 1) * (n - 1);\n      }\n      (2 * n - 1) + (n - 1) * (n - 1);\n      { // Expand (n-1)\u00b2\n        \n/*[CODE HERE]*/\n      }\n      (2 * n - 1) + (n * n - 2 * n + 1);\n      2 * n - 1 + n * n - 2 * n + 1;\n      n * n;\n    }\n  }\n}\n\nlemma SumSquaresFormula(n: nat)\n  ensures sumSquares(n) == n * (n + 1) * (2 * n + 1) / 6\n{\n  if n == 0 {\n    // Base case\n    assert sumSquares(0) == 0;\n    assert 0 * (0 + 1) * (2 * 0 + 1) / 6 == 0;\n  } else {\n    // Inductive step\n    SumSquaresFormula(n - 1);\n\n    calc == {\n      sumSquares(n);\n      n * n + sumSquares(n - 1);\n      { // Induction hypothesis\n        assert sumSquares(n - 1) == (n - 1) * n * (2 * n - 1) / 6;\n      }\n      n * n + (n - 1) * n * (2 * n - 1) / 6;\n      { // Factor out common terms\n        assert n * n == 6 * n * n / 6;\n      }\n      6 * n * n / 6 + (n - 1) * n * (2 * n - 1) / 6;\n      (6 * n * n + (n - 1) * n * (2 * n - 1)) / 6;\n      { // Expand\n        assert (n - 1) * n * (2 * n - 1) == n * (n - 1) * (2 * n - 1);\n        assert n * (n - 1) * (2 * n - 1) == n * (2 * n * n - 3 * n + 1);\n        assert n * (2 * n * n - 3 * n + 1) == 2 * n * n * n - 3 * n * n + n;\n      }\n      (6 * n * n + 2 * n * n * n - 3 * n * n + n) / 6;\n      (2 * n * n * n + 3 * n * n + n) / 6;\n      n * (2 * n * n + 3 * n + 1) / 6;\n      { // Factor\n        assert 2 * n * n + 3 * n + 1 == (n + 1) * (2 * n + 1);\n      }\n      n * (n + 1) * (2 * n + 1) / 6;\n    }\n  }\n}\n\nlemma PowerOfTwo(n: nat)\n  ensures power(2, n) >= n + 1\n{\n  if n == 0 {\n    // Base case\n    assert power(2, 0) == 1;\n    assert 1 >= 0 + 1;\n  } else {\n    // Inductive step\n    PowerOfTwo(n - 1);\n\n    calc >= {\n      power(2, n);\n      2 * power(2, n - 1);\n      { // Induction hypothesis\n        assert power(2, n - 1) >= n;\n      }\n      2 * n;\n      { // Since n >= 1\n        assert n >= 1;\n        assert 2 * n >= n + 1;\n      }\n      n + 1;\n    }\n  }\n}\n\nlemma PowerMonotonic(base: nat, exp1: nat, exp2: nat)\n  requires base > 1\n  requires exp1 <= exp2\n  ensures power(base, exp1) <= power(base, exp2)\n{\n  if exp1 == exp2 {\n    // Equal case\n    assert power(base, exp1) == power(base, exp2);\n  } else {\n    // exp1 < exp2\n    assert exp1 < exp2;\n\n    if exp1 == 0 {\n      assert power(base, exp1) == 1;\n      PowerPositive(base, exp2);\n      assert power(base, exp2) >= 1;\n    } else {\n      // Both exp1 and exp2 are positive\n      PowerMonotonic(base, exp1 - 1, exp2 - 1);\n\n      calc <= {\n        power(base, exp1);\n        base * power(base, exp1 - 1);\n        { // Induction hypothesis\n          assert power(base, exp1 - 1) <= power(base, exp2 - 1);\n        }\n        base * power(base, exp2 - 1);\n        power(base, exp2);\n      }\n    }\n  }\n}\n\nlemma PowerPositive(base: nat, exp: nat)\n  requires base > 0\n  ensures power(base, exp) > 0\n{\n  if exp == 0 {\n    assert power(base, 0) == 1;\n  } else {\n    PowerPositive(base, exp - 1);\n    assert power(base, exp) == base * power(base, exp - 1);\n    assert base > 0 && power(base, exp - 1) > 0;\n  }\n}\n\nlemma FibonacciInequality(n: nat)\n  requires n >= 1\n  ensures fib(n) <= power(2, n - 1)\n{\n  if n == 1 {\n    // Base case\n    assert fib(1) == 1;\n    assert power(2, 0) == 1;\n  } else if n == 2 {\n    // Base case\n    assert fib(2) == 1;\n    assert power(2, 1) == 2;\n    assert 1 <= 2;\n  } else {\n    // Inductive step (n >= 3)\n    assert n >= 3;\n    FibonacciInequality(n - 1);\n    FibonacciInequality(n - 2);\n\n    calc <= {\n      fib(n);\n      fib(n - 1) + fib(n - 2);\n      { // Induction hypotheses\n        assert fib(n - 1) <= power(2, n - 2);\n        assert fib(n - 2) <= power(2, n - 3);\n      }\n      power(2, n - 2) + power(2, n - 3);\n      { // Factor out power(2, n - 3)\n        assert power(2, n - 2) == 2 * power(2, n - 3);\n      }\n      2 * power(2, n - 3) + power(2, n - 3);\n      3 * power(2, n - 3);\n      { // 3 * 2^(n-3) <= 4 * 2^(n-3) = 2^(n-1)\n        assert 3 <= 4;\n        assert power(2, n - 1) == 4 * power(2, n - 3);\n      }\n      power(2, n - 1);\n    }\n  }\n}\n\nlemma StrongInduction(n: nat, P: nat -> bool)\n  requires forall k :: 0 <= k < n ==> P(k)\n  requires forall m :: m >= n && (forall j :: n <= j < m ==> P(j)) ==> P(m)\n  ensures P(n)\n{\n  // This demonstrates the strong induction principle\n  // Base case: all k < n satisfy P(k) by hypothesis\n  // Inductive case: if all j in [n, m) satisfy P, then P(m) holds\n\n  // The proof would proceed by showing P(n) directly\n  // using the second hypothesis with m = n\n  assert forall j :: n <= j < n ==> P(j); // Vacuously true\n}\n\nlemma CompleteInduction(n: nat, P: nat -> bool)\n  requires P(0)\n  requires forall k: nat :: k > 0 && (forall j: nat :: j < k ==> P(j)) ==> P(k)\n  ensures P(n)\n{\n  if n == 0 {\n    // Base case\n    assert P(0);\n  } else {\n    // Need to show all j < n satisfy P(j)\n    forall j: nat | j < n\n      ensures P(j)\n    {\n      if j == 0 {\n        assert P(0);\n      } else {\n        CompleteInduction(j, P);\n      }\n    }\n\n    // Now apply the inductive hypothesis\n    assert forall j: nat :: j < n ==> P(j);\n    assert P(n);\n  }\n}", "output": "assert (n - 1) * (n - 1) == n * n - 2 * n + 1;"}, {"id": "example_SumOddsIsSquare_1", "type": "assert", "program": "// Induction proofs with detailed reasoning steps\n\n// Sum of first n natural numbers\nfunction {:spec} sumTo(n: nat): nat\n{\n  if n == 0 then 0 else n + sumTo(n - 1)\n}\n\n// Sum of first n odd numbers\nfunction {:spec} sumOdds(n: nat): nat\n{\n  if n == 0 then 0 else (2 * n - 1) + sumOdds(n - 1)\n}\n\n// Sum of first n squares\nfunction {:spec} sumSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + sumSquares(n - 1)\n}\n\n// Power function\nfunction {:spec} power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\n// Fibonacci\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// --- Detailed Inductive Proofs ---\n\nlemma SumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    // Base case\n    assert sumTo(0) == 0;\n    assert 0 * (0 + 1) / 2 == 0;\n  } else {\n    // Inductive step\n    SumToFormula(n - 1);\n\n    calc == {\n      sumTo(n);\n      n + sumTo(n - 1);\n      { // Induction hypothesis\n        assert sumTo(n - 1) == (n - 1) * n / 2;\n      }\n      n + (n - 1) * n / 2;\n      { // Algebra\n        assert n == 2 * n / 2;\n      }\n      2 * n / 2 + (n - 1) * n / 2;\n      (2 * n + (n - 1) * n) / 2;\n      (2 * n + n * n - n) / 2;\n      (n + n * n) / 2;\n      n * (1 + n) / 2;\n      n * (n + 1) / 2;\n    }\n  }\n}\n\nlemma SumOddsIsSquare(n: nat)\n  ensures sumOdds(n) == n * n\n{\n  if n == 0 {\n    // Base case\n    assert sumOdds(0) == 0;\n    assert 0 * 0 == 0;\n  } else {\n    // Inductive step\n    SumOddsIsSquare(n - 1);\n\n    calc == {\n      sumOdds(n);\n      (2 * n - 1) + sumOdds(n - 1);\n      { // Induction hypothesis\n        \n/*[CODE HERE]*/\n      }\n      (2 * n - 1) + (n - 1) * (n - 1);\n      { // Expand (n-1)\u00b2\n        assert (n - 1) * (n - 1) == n * n - 2 * n + 1;\n      }\n      (2 * n - 1) + (n * n - 2 * n + 1);\n      2 * n - 1 + n * n - 2 * n + 1;\n      n * n;\n    }\n  }\n}\n\nlemma SumSquaresFormula(n: nat)\n  ensures sumSquares(n) == n * (n + 1) * (2 * n + 1) / 6\n{\n  if n == 0 {\n    // Base case\n    assert sumSquares(0) == 0;\n    assert 0 * (0 + 1) * (2 * 0 + 1) / 6 == 0;\n  } else {\n    // Inductive step\n    SumSquaresFormula(n - 1);\n\n    calc == {\n      sumSquares(n);\n      n * n + sumSquares(n - 1);\n      { // Induction hypothesis\n        assert sumSquares(n - 1) == (n - 1) * n * (2 * n - 1) / 6;\n      }\n      n * n + (n - 1) * n * (2 * n - 1) / 6;\n      { // Factor out common terms\n        assert n * n == 6 * n * n / 6;\n      }\n      6 * n * n / 6 + (n - 1) * n * (2 * n - 1) / 6;\n      (6 * n * n + (n - 1) * n * (2 * n - 1)) / 6;\n      { // Expand\n        assert (n - 1) * n * (2 * n - 1) == n * (n - 1) * (2 * n - 1);\n        assert n * (n - 1) * (2 * n - 1) == n * (2 * n * n - 3 * n + 1);\n        assert n * (2 * n * n - 3 * n + 1) == 2 * n * n * n - 3 * n * n + n;\n      }\n      (6 * n * n + 2 * n * n * n - 3 * n * n + n) / 6;\n      (2 * n * n * n + 3 * n * n + n) / 6;\n      n * (2 * n * n + 3 * n + 1) / 6;\n      { // Factor\n        assert 2 * n * n + 3 * n + 1 == (n + 1) * (2 * n + 1);\n      }\n      n * (n + 1) * (2 * n + 1) / 6;\n    }\n  }\n}\n\nlemma PowerOfTwo(n: nat)\n  ensures power(2, n) >= n + 1\n{\n  if n == 0 {\n    // Base case\n    assert power(2, 0) == 1;\n    assert 1 >= 0 + 1;\n  } else {\n    // Inductive step\n    PowerOfTwo(n - 1);\n\n    calc >= {\n      power(2, n);\n      2 * power(2, n - 1);\n      { // Induction hypothesis\n        assert power(2, n - 1) >= n;\n      }\n      2 * n;\n      { // Since n >= 1\n        assert n >= 1;\n        assert 2 * n >= n + 1;\n      }\n      n + 1;\n    }\n  }\n}\n\nlemma PowerMonotonic(base: nat, exp1: nat, exp2: nat)\n  requires base > 1\n  requires exp1 <= exp2\n  ensures power(base, exp1) <= power(base, exp2)\n{\n  if exp1 == exp2 {\n    // Equal case\n    assert power(base, exp1) == power(base, exp2);\n  } else {\n    // exp1 < exp2\n    assert exp1 < exp2;\n\n    if exp1 == 0 {\n      assert power(base, exp1) == 1;\n      PowerPositive(base, exp2);\n      assert power(base, exp2) >= 1;\n    } else {\n      // Both exp1 and exp2 are positive\n      PowerMonotonic(base, exp1 - 1, exp2 - 1);\n\n      calc <= {\n        power(base, exp1);\n        base * power(base, exp1 - 1);\n        { // Induction hypothesis\n          assert power(base, exp1 - 1) <= power(base, exp2 - 1);\n        }\n        base * power(base, exp2 - 1);\n        power(base, exp2);\n      }\n    }\n  }\n}\n\nlemma PowerPositive(base: nat, exp: nat)\n  requires base > 0\n  ensures power(base, exp) > 0\n{\n  if exp == 0 {\n    assert power(base, 0) == 1;\n  } else {\n    PowerPositive(base, exp - 1);\n    assert power(base, exp) == base * power(base, exp - 1);\n    assert base > 0 && power(base, exp - 1) > 0;\n  }\n}\n\nlemma FibonacciInequality(n: nat)\n  requires n >= 1\n  ensures fib(n) <= power(2, n - 1)\n{\n  if n == 1 {\n    // Base case\n    assert fib(1) == 1;\n    assert power(2, 0) == 1;\n  } else if n == 2 {\n    // Base case\n    assert fib(2) == 1;\n    assert power(2, 1) == 2;\n    assert 1 <= 2;\n  } else {\n    // Inductive step (n >= 3)\n    assert n >= 3;\n    FibonacciInequality(n - 1);\n    FibonacciInequality(n - 2);\n\n    calc <= {\n      fib(n);\n      fib(n - 1) + fib(n - 2);\n      { // Induction hypotheses\n        assert fib(n - 1) <= power(2, n - 2);\n        assert fib(n - 2) <= power(2, n - 3);\n      }\n      power(2, n - 2) + power(2, n - 3);\n      { // Factor out power(2, n - 3)\n        assert power(2, n - 2) == 2 * power(2, n - 3);\n      }\n      2 * power(2, n - 3) + power(2, n - 3);\n      3 * power(2, n - 3);\n      { // 3 * 2^(n-3) <= 4 * 2^(n-3) = 2^(n-1)\n        assert 3 <= 4;\n        assert power(2, n - 1) == 4 * power(2, n - 3);\n      }\n      power(2, n - 1);\n    }\n  }\n}\n\nlemma StrongInduction(n: nat, P: nat -> bool)\n  requires forall k :: 0 <= k < n ==> P(k)\n  requires forall m :: m >= n && (forall j :: n <= j < m ==> P(j)) ==> P(m)\n  ensures P(n)\n{\n  // This demonstrates the strong induction principle\n  // Base case: all k < n satisfy P(k) by hypothesis\n  // Inductive case: if all j in [n, m) satisfy P, then P(m) holds\n\n  // The proof would proceed by showing P(n) directly\n  // using the second hypothesis with m = n\n  assert forall j :: n <= j < n ==> P(j); // Vacuously true\n}\n\nlemma CompleteInduction(n: nat, P: nat -> bool)\n  requires P(0)\n  requires forall k: nat :: k > 0 && (forall j: nat :: j < k ==> P(j)) ==> P(k)\n  ensures P(n)\n{\n  if n == 0 {\n    // Base case\n    assert P(0);\n  } else {\n    // Need to show all j < n satisfy P(j)\n    forall j: nat | j < n\n      ensures P(j)\n    {\n      if j == 0 {\n        assert P(0);\n      } else {\n        CompleteInduction(j, P);\n      }\n    }\n\n    // Now apply the inductive hypothesis\n    assert forall j: nat :: j < n ==> P(j);\n    assert P(n);\n  }\n}", "output": "assert sumOdds(n - 1) == (n - 1) * (n - 1);"}, {"id": "example_SumOddsIsSquare_2", "type": "call", "program": "// Induction proofs with detailed reasoning steps\n\n// Sum of first n natural numbers\nfunction {:spec} sumTo(n: nat): nat\n{\n  if n == 0 then 0 else n + sumTo(n - 1)\n}\n\n// Sum of first n odd numbers\nfunction {:spec} sumOdds(n: nat): nat\n{\n  if n == 0 then 0 else (2 * n - 1) + sumOdds(n - 1)\n}\n\n// Sum of first n squares\nfunction {:spec} sumSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + sumSquares(n - 1)\n}\n\n// Power function\nfunction {:spec} power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\n// Fibonacci\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// --- Detailed Inductive Proofs ---\n\nlemma SumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    // Base case\n    assert sumTo(0) == 0;\n    assert 0 * (0 + 1) / 2 == 0;\n  } else {\n    // Inductive step\n    SumToFormula(n - 1);\n\n    calc == {\n      sumTo(n);\n      n + sumTo(n - 1);\n      { // Induction hypothesis\n        assert sumTo(n - 1) == (n - 1) * n / 2;\n      }\n      n + (n - 1) * n / 2;\n      { // Algebra\n        assert n == 2 * n / 2;\n      }\n      2 * n / 2 + (n - 1) * n / 2;\n      (2 * n + (n - 1) * n) / 2;\n      (2 * n + n * n - n) / 2;\n      (n + n * n) / 2;\n      n * (1 + n) / 2;\n      n * (n + 1) / 2;\n    }\n  }\n}\n\nlemma SumOddsIsSquare(n: nat)\n  ensures sumOdds(n) == n * n\n{\n  if n == 0 {\n    // Base case\n    assert sumOdds(0) == 0;\n    assert 0 * 0 == 0;\n  } else {\n    // Inductive step\n    \n/*[CODE HERE]*/\n\n    calc == {\n      sumOdds(n);\n      (2 * n - 1) + sumOdds(n - 1);\n      { // Induction hypothesis\n        assert sumOdds(n - 1) == (n - 1) * (n - 1);\n      }\n      (2 * n - 1) + (n - 1) * (n - 1);\n      { // Expand (n-1)\u00b2\n        assert (n - 1) * (n - 1) == n * n - 2 * n + 1;\n      }\n      (2 * n - 1) + (n * n - 2 * n + 1);\n      2 * n - 1 + n * n - 2 * n + 1;\n      n * n;\n    }\n  }\n}\n\nlemma SumSquaresFormula(n: nat)\n  ensures sumSquares(n) == n * (n + 1) * (2 * n + 1) / 6\n{\n  if n == 0 {\n    // Base case\n    assert sumSquares(0) == 0;\n    assert 0 * (0 + 1) * (2 * 0 + 1) / 6 == 0;\n  } else {\n    // Inductive step\n    SumSquaresFormula(n - 1);\n\n    calc == {\n      sumSquares(n);\n      n * n + sumSquares(n - 1);\n      { // Induction hypothesis\n        assert sumSquares(n - 1) == (n - 1) * n * (2 * n - 1) / 6;\n      }\n      n * n + (n - 1) * n * (2 * n - 1) / 6;\n      { // Factor out common terms\n        assert n * n == 6 * n * n / 6;\n      }\n      6 * n * n / 6 + (n - 1) * n * (2 * n - 1) / 6;\n      (6 * n * n + (n - 1) * n * (2 * n - 1)) / 6;\n      { // Expand\n        assert (n - 1) * n * (2 * n - 1) == n * (n - 1) * (2 * n - 1);\n        assert n * (n - 1) * (2 * n - 1) == n * (2 * n * n - 3 * n + 1);\n        assert n * (2 * n * n - 3 * n + 1) == 2 * n * n * n - 3 * n * n + n;\n      }\n      (6 * n * n + 2 * n * n * n - 3 * n * n + n) / 6;\n      (2 * n * n * n + 3 * n * n + n) / 6;\n      n * (2 * n * n + 3 * n + 1) / 6;\n      { // Factor\n        assert 2 * n * n + 3 * n + 1 == (n + 1) * (2 * n + 1);\n      }\n      n * (n + 1) * (2 * n + 1) / 6;\n    }\n  }\n}\n\nlemma PowerOfTwo(n: nat)\n  ensures power(2, n) >= n + 1\n{\n  if n == 0 {\n    // Base case\n    assert power(2, 0) == 1;\n    assert 1 >= 0 + 1;\n  } else {\n    // Inductive step\n    PowerOfTwo(n - 1);\n\n    calc >= {\n      power(2, n);\n      2 * power(2, n - 1);\n      { // Induction hypothesis\n        assert power(2, n - 1) >= n;\n      }\n      2 * n;\n      { // Since n >= 1\n        assert n >= 1;\n        assert 2 * n >= n + 1;\n      }\n      n + 1;\n    }\n  }\n}\n\nlemma PowerMonotonic(base: nat, exp1: nat, exp2: nat)\n  requires base > 1\n  requires exp1 <= exp2\n  ensures power(base, exp1) <= power(base, exp2)\n{\n  if exp1 == exp2 {\n    // Equal case\n    assert power(base, exp1) == power(base, exp2);\n  } else {\n    // exp1 < exp2\n    assert exp1 < exp2;\n\n    if exp1 == 0 {\n      assert power(base, exp1) == 1;\n      PowerPositive(base, exp2);\n      assert power(base, exp2) >= 1;\n    } else {\n      // Both exp1 and exp2 are positive\n      PowerMonotonic(base, exp1 - 1, exp2 - 1);\n\n      calc <= {\n        power(base, exp1);\n        base * power(base, exp1 - 1);\n        { // Induction hypothesis\n          assert power(base, exp1 - 1) <= power(base, exp2 - 1);\n        }\n        base * power(base, exp2 - 1);\n        power(base, exp2);\n      }\n    }\n  }\n}\n\nlemma PowerPositive(base: nat, exp: nat)\n  requires base > 0\n  ensures power(base, exp) > 0\n{\n  if exp == 0 {\n    assert power(base, 0) == 1;\n  } else {\n    PowerPositive(base, exp - 1);\n    assert power(base, exp) == base * power(base, exp - 1);\n    assert base > 0 && power(base, exp - 1) > 0;\n  }\n}\n\nlemma FibonacciInequality(n: nat)\n  requires n >= 1\n  ensures fib(n) <= power(2, n - 1)\n{\n  if n == 1 {\n    // Base case\n    assert fib(1) == 1;\n    assert power(2, 0) == 1;\n  } else if n == 2 {\n    // Base case\n    assert fib(2) == 1;\n    assert power(2, 1) == 2;\n    assert 1 <= 2;\n  } else {\n    // Inductive step (n >= 3)\n    assert n >= 3;\n    FibonacciInequality(n - 1);\n    FibonacciInequality(n - 2);\n\n    calc <= {\n      fib(n);\n      fib(n - 1) + fib(n - 2);\n      { // Induction hypotheses\n        assert fib(n - 1) <= power(2, n - 2);\n        assert fib(n - 2) <= power(2, n - 3);\n      }\n      power(2, n - 2) + power(2, n - 3);\n      { // Factor out power(2, n - 3)\n        assert power(2, n - 2) == 2 * power(2, n - 3);\n      }\n      2 * power(2, n - 3) + power(2, n - 3);\n      3 * power(2, n - 3);\n      { // 3 * 2^(n-3) <= 4 * 2^(n-3) = 2^(n-1)\n        assert 3 <= 4;\n        assert power(2, n - 1) == 4 * power(2, n - 3);\n      }\n      power(2, n - 1);\n    }\n  }\n}\n\nlemma StrongInduction(n: nat, P: nat -> bool)\n  requires forall k :: 0 <= k < n ==> P(k)\n  requires forall m :: m >= n && (forall j :: n <= j < m ==> P(j)) ==> P(m)\n  ensures P(n)\n{\n  // This demonstrates the strong induction principle\n  // Base case: all k < n satisfy P(k) by hypothesis\n  // Inductive case: if all j in [n, m) satisfy P, then P(m) holds\n\n  // The proof would proceed by showing P(n) directly\n  // using the second hypothesis with m = n\n  assert forall j :: n <= j < n ==> P(j); // Vacuously true\n}\n\nlemma CompleteInduction(n: nat, P: nat -> bool)\n  requires P(0)\n  requires forall k: nat :: k > 0 && (forall j: nat :: j < k ==> P(j)) ==> P(k)\n  ensures P(n)\n{\n  if n == 0 {\n    // Base case\n    assert P(0);\n  } else {\n    // Need to show all j < n satisfy P(j)\n    forall j: nat | j < n\n      ensures P(j)\n    {\n      if j == 0 {\n        assert P(0);\n      } else {\n        CompleteInduction(j, P);\n      }\n    }\n\n    // Now apply the inductive hypothesis\n    assert forall j: nat :: j < n ==> P(j);\n    assert P(n);\n  }\n}", "output": "SumOddsIsSquare(n - 1);"}, {"id": "example_SumOddsIsSquare_3", "type": "assert", "program": "// Induction proofs with detailed reasoning steps\n\n// Sum of first n natural numbers\nfunction {:spec} sumTo(n: nat): nat\n{\n  if n == 0 then 0 else n + sumTo(n - 1)\n}\n\n// Sum of first n odd numbers\nfunction {:spec} sumOdds(n: nat): nat\n{\n  if n == 0 then 0 else (2 * n - 1) + sumOdds(n - 1)\n}\n\n// Sum of first n squares\nfunction {:spec} sumSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + sumSquares(n - 1)\n}\n\n// Power function\nfunction {:spec} power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\n// Fibonacci\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// --- Detailed Inductive Proofs ---\n\nlemma SumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    // Base case\n    assert sumTo(0) == 0;\n    assert 0 * (0 + 1) / 2 == 0;\n  } else {\n    // Inductive step\n    SumToFormula(n - 1);\n\n    calc == {\n      sumTo(n);\n      n + sumTo(n - 1);\n      { // Induction hypothesis\n        assert sumTo(n - 1) == (n - 1) * n / 2;\n      }\n      n + (n - 1) * n / 2;\n      { // Algebra\n        assert n == 2 * n / 2;\n      }\n      2 * n / 2 + (n - 1) * n / 2;\n      (2 * n + (n - 1) * n) / 2;\n      (2 * n + n * n - n) / 2;\n      (n + n * n) / 2;\n      n * (1 + n) / 2;\n      n * (n + 1) / 2;\n    }\n  }\n}\n\nlemma SumOddsIsSquare(n: nat)\n  ensures sumOdds(n) == n * n\n{\n  if n == 0 {\n    // Base case\n    assert sumOdds(0) == 0;\n    \n/*[CODE HERE]*/\n  } else {\n    // Inductive step\n    SumOddsIsSquare(n - 1);\n\n    calc == {\n      sumOdds(n);\n      (2 * n - 1) + sumOdds(n - 1);\n      { // Induction hypothesis\n        assert sumOdds(n - 1) == (n - 1) * (n - 1);\n      }\n      (2 * n - 1) + (n - 1) * (n - 1);\n      { // Expand (n-1)\u00b2\n        assert (n - 1) * (n - 1) == n * n - 2 * n + 1;\n      }\n      (2 * n - 1) + (n * n - 2 * n + 1);\n      2 * n - 1 + n * n - 2 * n + 1;\n      n * n;\n    }\n  }\n}\n\nlemma SumSquaresFormula(n: nat)\n  ensures sumSquares(n) == n * (n + 1) * (2 * n + 1) / 6\n{\n  if n == 0 {\n    // Base case\n    assert sumSquares(0) == 0;\n    assert 0 * (0 + 1) * (2 * 0 + 1) / 6 == 0;\n  } else {\n    // Inductive step\n    SumSquaresFormula(n - 1);\n\n    calc == {\n      sumSquares(n);\n      n * n + sumSquares(n - 1);\n      { // Induction hypothesis\n        assert sumSquares(n - 1) == (n - 1) * n * (2 * n - 1) / 6;\n      }\n      n * n + (n - 1) * n * (2 * n - 1) / 6;\n      { // Factor out common terms\n        assert n * n == 6 * n * n / 6;\n      }\n      6 * n * n / 6 + (n - 1) * n * (2 * n - 1) / 6;\n      (6 * n * n + (n - 1) * n * (2 * n - 1)) / 6;\n      { // Expand\n        assert (n - 1) * n * (2 * n - 1) == n * (n - 1) * (2 * n - 1);\n        assert n * (n - 1) * (2 * n - 1) == n * (2 * n * n - 3 * n + 1);\n        assert n * (2 * n * n - 3 * n + 1) == 2 * n * n * n - 3 * n * n + n;\n      }\n      (6 * n * n + 2 * n * n * n - 3 * n * n + n) / 6;\n      (2 * n * n * n + 3 * n * n + n) / 6;\n      n * (2 * n * n + 3 * n + 1) / 6;\n      { // Factor\n        assert 2 * n * n + 3 * n + 1 == (n + 1) * (2 * n + 1);\n      }\n      n * (n + 1) * (2 * n + 1) / 6;\n    }\n  }\n}\n\nlemma PowerOfTwo(n: nat)\n  ensures power(2, n) >= n + 1\n{\n  if n == 0 {\n    // Base case\n    assert power(2, 0) == 1;\n    assert 1 >= 0 + 1;\n  } else {\n    // Inductive step\n    PowerOfTwo(n - 1);\n\n    calc >= {\n      power(2, n);\n      2 * power(2, n - 1);\n      { // Induction hypothesis\n        assert power(2, n - 1) >= n;\n      }\n      2 * n;\n      { // Since n >= 1\n        assert n >= 1;\n        assert 2 * n >= n + 1;\n      }\n      n + 1;\n    }\n  }\n}\n\nlemma PowerMonotonic(base: nat, exp1: nat, exp2: nat)\n  requires base > 1\n  requires exp1 <= exp2\n  ensures power(base, exp1) <= power(base, exp2)\n{\n  if exp1 == exp2 {\n    // Equal case\n    assert power(base, exp1) == power(base, exp2);\n  } else {\n    // exp1 < exp2\n    assert exp1 < exp2;\n\n    if exp1 == 0 {\n      assert power(base, exp1) == 1;\n      PowerPositive(base, exp2);\n      assert power(base, exp2) >= 1;\n    } else {\n      // Both exp1 and exp2 are positive\n      PowerMonotonic(base, exp1 - 1, exp2 - 1);\n\n      calc <= {\n        power(base, exp1);\n        base * power(base, exp1 - 1);\n        { // Induction hypothesis\n          assert power(base, exp1 - 1) <= power(base, exp2 - 1);\n        }\n        base * power(base, exp2 - 1);\n        power(base, exp2);\n      }\n    }\n  }\n}\n\nlemma PowerPositive(base: nat, exp: nat)\n  requires base > 0\n  ensures power(base, exp) > 0\n{\n  if exp == 0 {\n    assert power(base, 0) == 1;\n  } else {\n    PowerPositive(base, exp - 1);\n    assert power(base, exp) == base * power(base, exp - 1);\n    assert base > 0 && power(base, exp - 1) > 0;\n  }\n}\n\nlemma FibonacciInequality(n: nat)\n  requires n >= 1\n  ensures fib(n) <= power(2, n - 1)\n{\n  if n == 1 {\n    // Base case\n    assert fib(1) == 1;\n    assert power(2, 0) == 1;\n  } else if n == 2 {\n    // Base case\n    assert fib(2) == 1;\n    assert power(2, 1) == 2;\n    assert 1 <= 2;\n  } else {\n    // Inductive step (n >= 3)\n    assert n >= 3;\n    FibonacciInequality(n - 1);\n    FibonacciInequality(n - 2);\n\n    calc <= {\n      fib(n);\n      fib(n - 1) + fib(n - 2);\n      { // Induction hypotheses\n        assert fib(n - 1) <= power(2, n - 2);\n        assert fib(n - 2) <= power(2, n - 3);\n      }\n      power(2, n - 2) + power(2, n - 3);\n      { // Factor out power(2, n - 3)\n        assert power(2, n - 2) == 2 * power(2, n - 3);\n      }\n      2 * power(2, n - 3) + power(2, n - 3);\n      3 * power(2, n - 3);\n      { // 3 * 2^(n-3) <= 4 * 2^(n-3) = 2^(n-1)\n        assert 3 <= 4;\n        assert power(2, n - 1) == 4 * power(2, n - 3);\n      }\n      power(2, n - 1);\n    }\n  }\n}\n\nlemma StrongInduction(n: nat, P: nat -> bool)\n  requires forall k :: 0 <= k < n ==> P(k)\n  requires forall m :: m >= n && (forall j :: n <= j < m ==> P(j)) ==> P(m)\n  ensures P(n)\n{\n  // This demonstrates the strong induction principle\n  // Base case: all k < n satisfy P(k) by hypothesis\n  // Inductive case: if all j in [n, m) satisfy P, then P(m) holds\n\n  // The proof would proceed by showing P(n) directly\n  // using the second hypothesis with m = n\n  assert forall j :: n <= j < n ==> P(j); // Vacuously true\n}\n\nlemma CompleteInduction(n: nat, P: nat -> bool)\n  requires P(0)\n  requires forall k: nat :: k > 0 && (forall j: nat :: j < k ==> P(j)) ==> P(k)\n  ensures P(n)\n{\n  if n == 0 {\n    // Base case\n    assert P(0);\n  } else {\n    // Need to show all j < n satisfy P(j)\n    forall j: nat | j < n\n      ensures P(j)\n    {\n      if j == 0 {\n        assert P(0);\n      } else {\n        CompleteInduction(j, P);\n      }\n    }\n\n    // Now apply the inductive hypothesis\n    assert forall j: nat :: j < n ==> P(j);\n    assert P(n);\n  }\n}", "output": "assert 0 * 0 == 0;"}, {"id": "example_SumOddsIsSquare_4", "type": "assert", "program": "// Induction proofs with detailed reasoning steps\n\n// Sum of first n natural numbers\nfunction {:spec} sumTo(n: nat): nat\n{\n  if n == 0 then 0 else n + sumTo(n - 1)\n}\n\n// Sum of first n odd numbers\nfunction {:spec} sumOdds(n: nat): nat\n{\n  if n == 0 then 0 else (2 * n - 1) + sumOdds(n - 1)\n}\n\n// Sum of first n squares\nfunction {:spec} sumSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + sumSquares(n - 1)\n}\n\n// Power function\nfunction {:spec} power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\n// Fibonacci\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// --- Detailed Inductive Proofs ---\n\nlemma SumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    // Base case\n    assert sumTo(0) == 0;\n    assert 0 * (0 + 1) / 2 == 0;\n  } else {\n    // Inductive step\n    SumToFormula(n - 1);\n\n    calc == {\n      sumTo(n);\n      n + sumTo(n - 1);\n      { // Induction hypothesis\n        assert sumTo(n - 1) == (n - 1) * n / 2;\n      }\n      n + (n - 1) * n / 2;\n      { // Algebra\n        assert n == 2 * n / 2;\n      }\n      2 * n / 2 + (n - 1) * n / 2;\n      (2 * n + (n - 1) * n) / 2;\n      (2 * n + n * n - n) / 2;\n      (n + n * n) / 2;\n      n * (1 + n) / 2;\n      n * (n + 1) / 2;\n    }\n  }\n}\n\nlemma SumOddsIsSquare(n: nat)\n  ensures sumOdds(n) == n * n\n{\n  if n == 0 {\n    // Base case\n    \n/*[CODE HERE]*/\n    assert 0 * 0 == 0;\n  } else {\n    // Inductive step\n    SumOddsIsSquare(n - 1);\n\n    calc == {\n      sumOdds(n);\n      (2 * n - 1) + sumOdds(n - 1);\n      { // Induction hypothesis\n        assert sumOdds(n - 1) == (n - 1) * (n - 1);\n      }\n      (2 * n - 1) + (n - 1) * (n - 1);\n      { // Expand (n-1)\u00b2\n        assert (n - 1) * (n - 1) == n * n - 2 * n + 1;\n      }\n      (2 * n - 1) + (n * n - 2 * n + 1);\n      2 * n - 1 + n * n - 2 * n + 1;\n      n * n;\n    }\n  }\n}\n\nlemma SumSquaresFormula(n: nat)\n  ensures sumSquares(n) == n * (n + 1) * (2 * n + 1) / 6\n{\n  if n == 0 {\n    // Base case\n    assert sumSquares(0) == 0;\n    assert 0 * (0 + 1) * (2 * 0 + 1) / 6 == 0;\n  } else {\n    // Inductive step\n    SumSquaresFormula(n - 1);\n\n    calc == {\n      sumSquares(n);\n      n * n + sumSquares(n - 1);\n      { // Induction hypothesis\n        assert sumSquares(n - 1) == (n - 1) * n * (2 * n - 1) / 6;\n      }\n      n * n + (n - 1) * n * (2 * n - 1) / 6;\n      { // Factor out common terms\n        assert n * n == 6 * n * n / 6;\n      }\n      6 * n * n / 6 + (n - 1) * n * (2 * n - 1) / 6;\n      (6 * n * n + (n - 1) * n * (2 * n - 1)) / 6;\n      { // Expand\n        assert (n - 1) * n * (2 * n - 1) == n * (n - 1) * (2 * n - 1);\n        assert n * (n - 1) * (2 * n - 1) == n * (2 * n * n - 3 * n + 1);\n        assert n * (2 * n * n - 3 * n + 1) == 2 * n * n * n - 3 * n * n + n;\n      }\n      (6 * n * n + 2 * n * n * n - 3 * n * n + n) / 6;\n      (2 * n * n * n + 3 * n * n + n) / 6;\n      n * (2 * n * n + 3 * n + 1) / 6;\n      { // Factor\n        assert 2 * n * n + 3 * n + 1 == (n + 1) * (2 * n + 1);\n      }\n      n * (n + 1) * (2 * n + 1) / 6;\n    }\n  }\n}\n\nlemma PowerOfTwo(n: nat)\n  ensures power(2, n) >= n + 1\n{\n  if n == 0 {\n    // Base case\n    assert power(2, 0) == 1;\n    assert 1 >= 0 + 1;\n  } else {\n    // Inductive step\n    PowerOfTwo(n - 1);\n\n    calc >= {\n      power(2, n);\n      2 * power(2, n - 1);\n      { // Induction hypothesis\n        assert power(2, n - 1) >= n;\n      }\n      2 * n;\n      { // Since n >= 1\n        assert n >= 1;\n        assert 2 * n >= n + 1;\n      }\n      n + 1;\n    }\n  }\n}\n\nlemma PowerMonotonic(base: nat, exp1: nat, exp2: nat)\n  requires base > 1\n  requires exp1 <= exp2\n  ensures power(base, exp1) <= power(base, exp2)\n{\n  if exp1 == exp2 {\n    // Equal case\n    assert power(base, exp1) == power(base, exp2);\n  } else {\n    // exp1 < exp2\n    assert exp1 < exp2;\n\n    if exp1 == 0 {\n      assert power(base, exp1) == 1;\n      PowerPositive(base, exp2);\n      assert power(base, exp2) >= 1;\n    } else {\n      // Both exp1 and exp2 are positive\n      PowerMonotonic(base, exp1 - 1, exp2 - 1);\n\n      calc <= {\n        power(base, exp1);\n        base * power(base, exp1 - 1);\n        { // Induction hypothesis\n          assert power(base, exp1 - 1) <= power(base, exp2 - 1);\n        }\n        base * power(base, exp2 - 1);\n        power(base, exp2);\n      }\n    }\n  }\n}\n\nlemma PowerPositive(base: nat, exp: nat)\n  requires base > 0\n  ensures power(base, exp) > 0\n{\n  if exp == 0 {\n    assert power(base, 0) == 1;\n  } else {\n    PowerPositive(base, exp - 1);\n    assert power(base, exp) == base * power(base, exp - 1);\n    assert base > 0 && power(base, exp - 1) > 0;\n  }\n}\n\nlemma FibonacciInequality(n: nat)\n  requires n >= 1\n  ensures fib(n) <= power(2, n - 1)\n{\n  if n == 1 {\n    // Base case\n    assert fib(1) == 1;\n    assert power(2, 0) == 1;\n  } else if n == 2 {\n    // Base case\n    assert fib(2) == 1;\n    assert power(2, 1) == 2;\n    assert 1 <= 2;\n  } else {\n    // Inductive step (n >= 3)\n    assert n >= 3;\n    FibonacciInequality(n - 1);\n    FibonacciInequality(n - 2);\n\n    calc <= {\n      fib(n);\n      fib(n - 1) + fib(n - 2);\n      { // Induction hypotheses\n        assert fib(n - 1) <= power(2, n - 2);\n        assert fib(n - 2) <= power(2, n - 3);\n      }\n      power(2, n - 2) + power(2, n - 3);\n      { // Factor out power(2, n - 3)\n        assert power(2, n - 2) == 2 * power(2, n - 3);\n      }\n      2 * power(2, n - 3) + power(2, n - 3);\n      3 * power(2, n - 3);\n      { // 3 * 2^(n-3) <= 4 * 2^(n-3) = 2^(n-1)\n        assert 3 <= 4;\n        assert power(2, n - 1) == 4 * power(2, n - 3);\n      }\n      power(2, n - 1);\n    }\n  }\n}\n\nlemma StrongInduction(n: nat, P: nat -> bool)\n  requires forall k :: 0 <= k < n ==> P(k)\n  requires forall m :: m >= n && (forall j :: n <= j < m ==> P(j)) ==> P(m)\n  ensures P(n)\n{\n  // This demonstrates the strong induction principle\n  // Base case: all k < n satisfy P(k) by hypothesis\n  // Inductive case: if all j in [n, m) satisfy P, then P(m) holds\n\n  // The proof would proceed by showing P(n) directly\n  // using the second hypothesis with m = n\n  assert forall j :: n <= j < n ==> P(j); // Vacuously true\n}\n\nlemma CompleteInduction(n: nat, P: nat -> bool)\n  requires P(0)\n  requires forall k: nat :: k > 0 && (forall j: nat :: j < k ==> P(j)) ==> P(k)\n  ensures P(n)\n{\n  if n == 0 {\n    // Base case\n    assert P(0);\n  } else {\n    // Need to show all j < n satisfy P(j)\n    forall j: nat | j < n\n      ensures P(j)\n    {\n      if j == 0 {\n        assert P(0);\n      } else {\n        CompleteInduction(j, P);\n      }\n    }\n\n    // Now apply the inductive hypothesis\n    assert forall j: nat :: j < n ==> P(j);\n    assert P(n);\n  }\n}", "output": "assert sumOdds(0) == 0;"}, {"id": "example_SumSquaresFormula_0", "type": "assert", "program": "// Induction proofs with detailed reasoning steps\n\n// Sum of first n natural numbers\nfunction {:spec} sumTo(n: nat): nat\n{\n  if n == 0 then 0 else n + sumTo(n - 1)\n}\n\n// Sum of first n odd numbers\nfunction {:spec} sumOdds(n: nat): nat\n{\n  if n == 0 then 0 else (2 * n - 1) + sumOdds(n - 1)\n}\n\n// Sum of first n squares\nfunction {:spec} sumSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + sumSquares(n - 1)\n}\n\n// Power function\nfunction {:spec} power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\n// Fibonacci\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// --- Detailed Inductive Proofs ---\n\nlemma SumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    // Base case\n    assert sumTo(0) == 0;\n    assert 0 * (0 + 1) / 2 == 0;\n  } else {\n    // Inductive step\n    SumToFormula(n - 1);\n\n    calc == {\n      sumTo(n);\n      n + sumTo(n - 1);\n      { // Induction hypothesis\n        assert sumTo(n - 1) == (n - 1) * n / 2;\n      }\n      n + (n - 1) * n / 2;\n      { // Algebra\n        assert n == 2 * n / 2;\n      }\n      2 * n / 2 + (n - 1) * n / 2;\n      (2 * n + (n - 1) * n) / 2;\n      (2 * n + n * n - n) / 2;\n      (n + n * n) / 2;\n      n * (1 + n) / 2;\n      n * (n + 1) / 2;\n    }\n  }\n}\n\nlemma SumOddsIsSquare(n: nat)\n  ensures sumOdds(n) == n * n\n{\n  if n == 0 {\n    // Base case\n    assert sumOdds(0) == 0;\n    assert 0 * 0 == 0;\n  } else {\n    // Inductive step\n    SumOddsIsSquare(n - 1);\n\n    calc == {\n      sumOdds(n);\n      (2 * n - 1) + sumOdds(n - 1);\n      { // Induction hypothesis\n        assert sumOdds(n - 1) == (n - 1) * (n - 1);\n      }\n      (2 * n - 1) + (n - 1) * (n - 1);\n      { // Expand (n-1)\u00b2\n        assert (n - 1) * (n - 1) == n * n - 2 * n + 1;\n      }\n      (2 * n - 1) + (n * n - 2 * n + 1);\n      2 * n - 1 + n * n - 2 * n + 1;\n      n * n;\n    }\n  }\n}\n\nlemma SumSquaresFormula(n: nat)\n  ensures sumSquares(n) == n * (n + 1) * (2 * n + 1) / 6\n{\n  if n == 0 {\n    // Base case\n    assert sumSquares(0) == 0;\n    assert 0 * (0 + 1) * (2 * 0 + 1) / 6 == 0;\n  } else {\n    // Inductive step\n    SumSquaresFormula(n - 1);\n\n    calc == {\n      sumSquares(n);\n      n * n + sumSquares(n - 1);\n      { // Induction hypothesis\n        assert sumSquares(n - 1) == (n - 1) * n * (2 * n - 1) / 6;\n      }\n      n * n + (n - 1) * n * (2 * n - 1) / 6;\n      { // Factor out common terms\n        assert n * n == 6 * n * n / 6;\n      }\n      6 * n * n / 6 + (n - 1) * n * (2 * n - 1) / 6;\n      (6 * n * n + (n - 1) * n * (2 * n - 1)) / 6;\n      { // Expand\n        assert (n - 1) * n * (2 * n - 1) == n * (n - 1) * (2 * n - 1);\n        assert n * (n - 1) * (2 * n - 1) == n * (2 * n * n - 3 * n + 1);\n        assert n * (2 * n * n - 3 * n + 1) == 2 * n * n * n - 3 * n * n + n;\n      }\n      (6 * n * n + 2 * n * n * n - 3 * n * n + n) / 6;\n      (2 * n * n * n + 3 * n * n + n) / 6;\n      n * (2 * n * n + 3 * n + 1) / 6;\n      { // Factor\n        \n/*[CODE HERE]*/\n      }\n      n * (n + 1) * (2 * n + 1) / 6;\n    }\n  }\n}\n\nlemma PowerOfTwo(n: nat)\n  ensures power(2, n) >= n + 1\n{\n  if n == 0 {\n    // Base case\n    assert power(2, 0) == 1;\n    assert 1 >= 0 + 1;\n  } else {\n    // Inductive step\n    PowerOfTwo(n - 1);\n\n    calc >= {\n      power(2, n);\n      2 * power(2, n - 1);\n      { // Induction hypothesis\n        assert power(2, n - 1) >= n;\n      }\n      2 * n;\n      { // Since n >= 1\n        assert n >= 1;\n        assert 2 * n >= n + 1;\n      }\n      n + 1;\n    }\n  }\n}\n\nlemma PowerMonotonic(base: nat, exp1: nat, exp2: nat)\n  requires base > 1\n  requires exp1 <= exp2\n  ensures power(base, exp1) <= power(base, exp2)\n{\n  if exp1 == exp2 {\n    // Equal case\n    assert power(base, exp1) == power(base, exp2);\n  } else {\n    // exp1 < exp2\n    assert exp1 < exp2;\n\n    if exp1 == 0 {\n      assert power(base, exp1) == 1;\n      PowerPositive(base, exp2);\n      assert power(base, exp2) >= 1;\n    } else {\n      // Both exp1 and exp2 are positive\n      PowerMonotonic(base, exp1 - 1, exp2 - 1);\n\n      calc <= {\n        power(base, exp1);\n        base * power(base, exp1 - 1);\n        { // Induction hypothesis\n          assert power(base, exp1 - 1) <= power(base, exp2 - 1);\n        }\n        base * power(base, exp2 - 1);\n        power(base, exp2);\n      }\n    }\n  }\n}\n\nlemma PowerPositive(base: nat, exp: nat)\n  requires base > 0\n  ensures power(base, exp) > 0\n{\n  if exp == 0 {\n    assert power(base, 0) == 1;\n  } else {\n    PowerPositive(base, exp - 1);\n    assert power(base, exp) == base * power(base, exp - 1);\n    assert base > 0 && power(base, exp - 1) > 0;\n  }\n}\n\nlemma FibonacciInequality(n: nat)\n  requires n >= 1\n  ensures fib(n) <= power(2, n - 1)\n{\n  if n == 1 {\n    // Base case\n    assert fib(1) == 1;\n    assert power(2, 0) == 1;\n  } else if n == 2 {\n    // Base case\n    assert fib(2) == 1;\n    assert power(2, 1) == 2;\n    assert 1 <= 2;\n  } else {\n    // Inductive step (n >= 3)\n    assert n >= 3;\n    FibonacciInequality(n - 1);\n    FibonacciInequality(n - 2);\n\n    calc <= {\n      fib(n);\n      fib(n - 1) + fib(n - 2);\n      { // Induction hypotheses\n        assert fib(n - 1) <= power(2, n - 2);\n        assert fib(n - 2) <= power(2, n - 3);\n      }\n      power(2, n - 2) + power(2, n - 3);\n      { // Factor out power(2, n - 3)\n        assert power(2, n - 2) == 2 * power(2, n - 3);\n      }\n      2 * power(2, n - 3) + power(2, n - 3);\n      3 * power(2, n - 3);\n      { // 3 * 2^(n-3) <= 4 * 2^(n-3) = 2^(n-1)\n        assert 3 <= 4;\n        assert power(2, n - 1) == 4 * power(2, n - 3);\n      }\n      power(2, n - 1);\n    }\n  }\n}\n\nlemma StrongInduction(n: nat, P: nat -> bool)\n  requires forall k :: 0 <= k < n ==> P(k)\n  requires forall m :: m >= n && (forall j :: n <= j < m ==> P(j)) ==> P(m)\n  ensures P(n)\n{\n  // This demonstrates the strong induction principle\n  // Base case: all k < n satisfy P(k) by hypothesis\n  // Inductive case: if all j in [n, m) satisfy P, then P(m) holds\n\n  // The proof would proceed by showing P(n) directly\n  // using the second hypothesis with m = n\n  assert forall j :: n <= j < n ==> P(j); // Vacuously true\n}\n\nlemma CompleteInduction(n: nat, P: nat -> bool)\n  requires P(0)\n  requires forall k: nat :: k > 0 && (forall j: nat :: j < k ==> P(j)) ==> P(k)\n  ensures P(n)\n{\n  if n == 0 {\n    // Base case\n    assert P(0);\n  } else {\n    // Need to show all j < n satisfy P(j)\n    forall j: nat | j < n\n      ensures P(j)\n    {\n      if j == 0 {\n        assert P(0);\n      } else {\n        CompleteInduction(j, P);\n      }\n    }\n\n    // Now apply the inductive hypothesis\n    assert forall j: nat :: j < n ==> P(j);\n    assert P(n);\n  }\n}", "output": "assert 2 * n * n + 3 * n + 1 == (n + 1) * (2 * n + 1);"}, {"id": "example_SumSquaresFormula_1", "type": "assert", "program": "// Induction proofs with detailed reasoning steps\n\n// Sum of first n natural numbers\nfunction {:spec} sumTo(n: nat): nat\n{\n  if n == 0 then 0 else n + sumTo(n - 1)\n}\n\n// Sum of first n odd numbers\nfunction {:spec} sumOdds(n: nat): nat\n{\n  if n == 0 then 0 else (2 * n - 1) + sumOdds(n - 1)\n}\n\n// Sum of first n squares\nfunction {:spec} sumSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + sumSquares(n - 1)\n}\n\n// Power function\nfunction {:spec} power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\n// Fibonacci\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// --- Detailed Inductive Proofs ---\n\nlemma SumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    // Base case\n    assert sumTo(0) == 0;\n    assert 0 * (0 + 1) / 2 == 0;\n  } else {\n    // Inductive step\n    SumToFormula(n - 1);\n\n    calc == {\n      sumTo(n);\n      n + sumTo(n - 1);\n      { // Induction hypothesis\n        assert sumTo(n - 1) == (n - 1) * n / 2;\n      }\n      n + (n - 1) * n / 2;\n      { // Algebra\n        assert n == 2 * n / 2;\n      }\n      2 * n / 2 + (n - 1) * n / 2;\n      (2 * n + (n - 1) * n) / 2;\n      (2 * n + n * n - n) / 2;\n      (n + n * n) / 2;\n      n * (1 + n) / 2;\n      n * (n + 1) / 2;\n    }\n  }\n}\n\nlemma SumOddsIsSquare(n: nat)\n  ensures sumOdds(n) == n * n\n{\n  if n == 0 {\n    // Base case\n    assert sumOdds(0) == 0;\n    assert 0 * 0 == 0;\n  } else {\n    // Inductive step\n    SumOddsIsSquare(n - 1);\n\n    calc == {\n      sumOdds(n);\n      (2 * n - 1) + sumOdds(n - 1);\n      { // Induction hypothesis\n        assert sumOdds(n - 1) == (n - 1) * (n - 1);\n      }\n      (2 * n - 1) + (n - 1) * (n - 1);\n      { // Expand (n-1)\u00b2\n        assert (n - 1) * (n - 1) == n * n - 2 * n + 1;\n      }\n      (2 * n - 1) + (n * n - 2 * n + 1);\n      2 * n - 1 + n * n - 2 * n + 1;\n      n * n;\n    }\n  }\n}\n\nlemma SumSquaresFormula(n: nat)\n  ensures sumSquares(n) == n * (n + 1) * (2 * n + 1) / 6\n{\n  if n == 0 {\n    // Base case\n    assert sumSquares(0) == 0;\n    assert 0 * (0 + 1) * (2 * 0 + 1) / 6 == 0;\n  } else {\n    // Inductive step\n    SumSquaresFormula(n - 1);\n\n    calc == {\n      sumSquares(n);\n      n * n + sumSquares(n - 1);\n      { // Induction hypothesis\n        assert sumSquares(n - 1) == (n - 1) * n * (2 * n - 1) / 6;\n      }\n      n * n + (n - 1) * n * (2 * n - 1) / 6;\n      { // Factor out common terms\n        assert n * n == 6 * n * n / 6;\n      }\n      6 * n * n / 6 + (n - 1) * n * (2 * n - 1) / 6;\n      (6 * n * n + (n - 1) * n * (2 * n - 1)) / 6;\n      { // Expand\n        assert (n - 1) * n * (2 * n - 1) == n * (n - 1) * (2 * n - 1);\n        assert n * (n - 1) * (2 * n - 1) == n * (2 * n * n - 3 * n + 1);\n        \n/*[CODE HERE]*/\n      }\n      (6 * n * n + 2 * n * n * n - 3 * n * n + n) / 6;\n      (2 * n * n * n + 3 * n * n + n) / 6;\n      n * (2 * n * n + 3 * n + 1) / 6;\n      { // Factor\n        assert 2 * n * n + 3 * n + 1 == (n + 1) * (2 * n + 1);\n      }\n      n * (n + 1) * (2 * n + 1) / 6;\n    }\n  }\n}\n\nlemma PowerOfTwo(n: nat)\n  ensures power(2, n) >= n + 1\n{\n  if n == 0 {\n    // Base case\n    assert power(2, 0) == 1;\n    assert 1 >= 0 + 1;\n  } else {\n    // Inductive step\n    PowerOfTwo(n - 1);\n\n    calc >= {\n      power(2, n);\n      2 * power(2, n - 1);\n      { // Induction hypothesis\n        assert power(2, n - 1) >= n;\n      }\n      2 * n;\n      { // Since n >= 1\n        assert n >= 1;\n        assert 2 * n >= n + 1;\n      }\n      n + 1;\n    }\n  }\n}\n\nlemma PowerMonotonic(base: nat, exp1: nat, exp2: nat)\n  requires base > 1\n  requires exp1 <= exp2\n  ensures power(base, exp1) <= power(base, exp2)\n{\n  if exp1 == exp2 {\n    // Equal case\n    assert power(base, exp1) == power(base, exp2);\n  } else {\n    // exp1 < exp2\n    assert exp1 < exp2;\n\n    if exp1 == 0 {\n      assert power(base, exp1) == 1;\n      PowerPositive(base, exp2);\n      assert power(base, exp2) >= 1;\n    } else {\n      // Both exp1 and exp2 are positive\n      PowerMonotonic(base, exp1 - 1, exp2 - 1);\n\n      calc <= {\n        power(base, exp1);\n        base * power(base, exp1 - 1);\n        { // Induction hypothesis\n          assert power(base, exp1 - 1) <= power(base, exp2 - 1);\n        }\n        base * power(base, exp2 - 1);\n        power(base, exp2);\n      }\n    }\n  }\n}\n\nlemma PowerPositive(base: nat, exp: nat)\n  requires base > 0\n  ensures power(base, exp) > 0\n{\n  if exp == 0 {\n    assert power(base, 0) == 1;\n  } else {\n    PowerPositive(base, exp - 1);\n    assert power(base, exp) == base * power(base, exp - 1);\n    assert base > 0 && power(base, exp - 1) > 0;\n  }\n}\n\nlemma FibonacciInequality(n: nat)\n  requires n >= 1\n  ensures fib(n) <= power(2, n - 1)\n{\n  if n == 1 {\n    // Base case\n    assert fib(1) == 1;\n    assert power(2, 0) == 1;\n  } else if n == 2 {\n    // Base case\n    assert fib(2) == 1;\n    assert power(2, 1) == 2;\n    assert 1 <= 2;\n  } else {\n    // Inductive step (n >= 3)\n    assert n >= 3;\n    FibonacciInequality(n - 1);\n    FibonacciInequality(n - 2);\n\n    calc <= {\n      fib(n);\n      fib(n - 1) + fib(n - 2);\n      { // Induction hypotheses\n        assert fib(n - 1) <= power(2, n - 2);\n        assert fib(n - 2) <= power(2, n - 3);\n      }\n      power(2, n - 2) + power(2, n - 3);\n      { // Factor out power(2, n - 3)\n        assert power(2, n - 2) == 2 * power(2, n - 3);\n      }\n      2 * power(2, n - 3) + power(2, n - 3);\n      3 * power(2, n - 3);\n      { // 3 * 2^(n-3) <= 4 * 2^(n-3) = 2^(n-1)\n        assert 3 <= 4;\n        assert power(2, n - 1) == 4 * power(2, n - 3);\n      }\n      power(2, n - 1);\n    }\n  }\n}\n\nlemma StrongInduction(n: nat, P: nat -> bool)\n  requires forall k :: 0 <= k < n ==> P(k)\n  requires forall m :: m >= n && (forall j :: n <= j < m ==> P(j)) ==> P(m)\n  ensures P(n)\n{\n  // This demonstrates the strong induction principle\n  // Base case: all k < n satisfy P(k) by hypothesis\n  // Inductive case: if all j in [n, m) satisfy P, then P(m) holds\n\n  // The proof would proceed by showing P(n) directly\n  // using the second hypothesis with m = n\n  assert forall j :: n <= j < n ==> P(j); // Vacuously true\n}\n\nlemma CompleteInduction(n: nat, P: nat -> bool)\n  requires P(0)\n  requires forall k: nat :: k > 0 && (forall j: nat :: j < k ==> P(j)) ==> P(k)\n  ensures P(n)\n{\n  if n == 0 {\n    // Base case\n    assert P(0);\n  } else {\n    // Need to show all j < n satisfy P(j)\n    forall j: nat | j < n\n      ensures P(j)\n    {\n      if j == 0 {\n        assert P(0);\n      } else {\n        CompleteInduction(j, P);\n      }\n    }\n\n    // Now apply the inductive hypothesis\n    assert forall j: nat :: j < n ==> P(j);\n    assert P(n);\n  }\n}", "output": "assert n * (2 * n * n - 3 * n + 1) == 2 * n * n * n - 3 * n * n + n;"}, {"id": "example_SumSquaresFormula_2", "type": "assert", "program": "// Induction proofs with detailed reasoning steps\n\n// Sum of first n natural numbers\nfunction {:spec} sumTo(n: nat): nat\n{\n  if n == 0 then 0 else n + sumTo(n - 1)\n}\n\n// Sum of first n odd numbers\nfunction {:spec} sumOdds(n: nat): nat\n{\n  if n == 0 then 0 else (2 * n - 1) + sumOdds(n - 1)\n}\n\n// Sum of first n squares\nfunction {:spec} sumSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + sumSquares(n - 1)\n}\n\n// Power function\nfunction {:spec} power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\n// Fibonacci\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// --- Detailed Inductive Proofs ---\n\nlemma SumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    // Base case\n    assert sumTo(0) == 0;\n    assert 0 * (0 + 1) / 2 == 0;\n  } else {\n    // Inductive step\n    SumToFormula(n - 1);\n\n    calc == {\n      sumTo(n);\n      n + sumTo(n - 1);\n      { // Induction hypothesis\n        assert sumTo(n - 1) == (n - 1) * n / 2;\n      }\n      n + (n - 1) * n / 2;\n      { // Algebra\n        assert n == 2 * n / 2;\n      }\n      2 * n / 2 + (n - 1) * n / 2;\n      (2 * n + (n - 1) * n) / 2;\n      (2 * n + n * n - n) / 2;\n      (n + n * n) / 2;\n      n * (1 + n) / 2;\n      n * (n + 1) / 2;\n    }\n  }\n}\n\nlemma SumOddsIsSquare(n: nat)\n  ensures sumOdds(n) == n * n\n{\n  if n == 0 {\n    // Base case\n    assert sumOdds(0) == 0;\n    assert 0 * 0 == 0;\n  } else {\n    // Inductive step\n    SumOddsIsSquare(n - 1);\n\n    calc == {\n      sumOdds(n);\n      (2 * n - 1) + sumOdds(n - 1);\n      { // Induction hypothesis\n        assert sumOdds(n - 1) == (n - 1) * (n - 1);\n      }\n      (2 * n - 1) + (n - 1) * (n - 1);\n      { // Expand (n-1)\u00b2\n        assert (n - 1) * (n - 1) == n * n - 2 * n + 1;\n      }\n      (2 * n - 1) + (n * n - 2 * n + 1);\n      2 * n - 1 + n * n - 2 * n + 1;\n      n * n;\n    }\n  }\n}\n\nlemma SumSquaresFormula(n: nat)\n  ensures sumSquares(n) == n * (n + 1) * (2 * n + 1) / 6\n{\n  if n == 0 {\n    // Base case\n    assert sumSquares(0) == 0;\n    assert 0 * (0 + 1) * (2 * 0 + 1) / 6 == 0;\n  } else {\n    // Inductive step\n    SumSquaresFormula(n - 1);\n\n    calc == {\n      sumSquares(n);\n      n * n + sumSquares(n - 1);\n      { // Induction hypothesis\n        assert sumSquares(n - 1) == (n - 1) * n * (2 * n - 1) / 6;\n      }\n      n * n + (n - 1) * n * (2 * n - 1) / 6;\n      { // Factor out common terms\n        assert n * n == 6 * n * n / 6;\n      }\n      6 * n * n / 6 + (n - 1) * n * (2 * n - 1) / 6;\n      (6 * n * n + (n - 1) * n * (2 * n - 1)) / 6;\n      { // Expand\n        assert (n - 1) * n * (2 * n - 1) == n * (n - 1) * (2 * n - 1);\n        \n/*[CODE HERE]*/\n        assert n * (2 * n * n - 3 * n + 1) == 2 * n * n * n - 3 * n * n + n;\n      }\n      (6 * n * n + 2 * n * n * n - 3 * n * n + n) / 6;\n      (2 * n * n * n + 3 * n * n + n) / 6;\n      n * (2 * n * n + 3 * n + 1) / 6;\n      { // Factor\n        assert 2 * n * n + 3 * n + 1 == (n + 1) * (2 * n + 1);\n      }\n      n * (n + 1) * (2 * n + 1) / 6;\n    }\n  }\n}\n\nlemma PowerOfTwo(n: nat)\n  ensures power(2, n) >= n + 1\n{\n  if n == 0 {\n    // Base case\n    assert power(2, 0) == 1;\n    assert 1 >= 0 + 1;\n  } else {\n    // Inductive step\n    PowerOfTwo(n - 1);\n\n    calc >= {\n      power(2, n);\n      2 * power(2, n - 1);\n      { // Induction hypothesis\n        assert power(2, n - 1) >= n;\n      }\n      2 * n;\n      { // Since n >= 1\n        assert n >= 1;\n        assert 2 * n >= n + 1;\n      }\n      n + 1;\n    }\n  }\n}\n\nlemma PowerMonotonic(base: nat, exp1: nat, exp2: nat)\n  requires base > 1\n  requires exp1 <= exp2\n  ensures power(base, exp1) <= power(base, exp2)\n{\n  if exp1 == exp2 {\n    // Equal case\n    assert power(base, exp1) == power(base, exp2);\n  } else {\n    // exp1 < exp2\n    assert exp1 < exp2;\n\n    if exp1 == 0 {\n      assert power(base, exp1) == 1;\n      PowerPositive(base, exp2);\n      assert power(base, exp2) >= 1;\n    } else {\n      // Both exp1 and exp2 are positive\n      PowerMonotonic(base, exp1 - 1, exp2 - 1);\n\n      calc <= {\n        power(base, exp1);\n        base * power(base, exp1 - 1);\n        { // Induction hypothesis\n          assert power(base, exp1 - 1) <= power(base, exp2 - 1);\n        }\n        base * power(base, exp2 - 1);\n        power(base, exp2);\n      }\n    }\n  }\n}\n\nlemma PowerPositive(base: nat, exp: nat)\n  requires base > 0\n  ensures power(base, exp) > 0\n{\n  if exp == 0 {\n    assert power(base, 0) == 1;\n  } else {\n    PowerPositive(base, exp - 1);\n    assert power(base, exp) == base * power(base, exp - 1);\n    assert base > 0 && power(base, exp - 1) > 0;\n  }\n}\n\nlemma FibonacciInequality(n: nat)\n  requires n >= 1\n  ensures fib(n) <= power(2, n - 1)\n{\n  if n == 1 {\n    // Base case\n    assert fib(1) == 1;\n    assert power(2, 0) == 1;\n  } else if n == 2 {\n    // Base case\n    assert fib(2) == 1;\n    assert power(2, 1) == 2;\n    assert 1 <= 2;\n  } else {\n    // Inductive step (n >= 3)\n    assert n >= 3;\n    FibonacciInequality(n - 1);\n    FibonacciInequality(n - 2);\n\n    calc <= {\n      fib(n);\n      fib(n - 1) + fib(n - 2);\n      { // Induction hypotheses\n        assert fib(n - 1) <= power(2, n - 2);\n        assert fib(n - 2) <= power(2, n - 3);\n      }\n      power(2, n - 2) + power(2, n - 3);\n      { // Factor out power(2, n - 3)\n        assert power(2, n - 2) == 2 * power(2, n - 3);\n      }\n      2 * power(2, n - 3) + power(2, n - 3);\n      3 * power(2, n - 3);\n      { // 3 * 2^(n-3) <= 4 * 2^(n-3) = 2^(n-1)\n        assert 3 <= 4;\n        assert power(2, n - 1) == 4 * power(2, n - 3);\n      }\n      power(2, n - 1);\n    }\n  }\n}\n\nlemma StrongInduction(n: nat, P: nat -> bool)\n  requires forall k :: 0 <= k < n ==> P(k)\n  requires forall m :: m >= n && (forall j :: n <= j < m ==> P(j)) ==> P(m)\n  ensures P(n)\n{\n  // This demonstrates the strong induction principle\n  // Base case: all k < n satisfy P(k) by hypothesis\n  // Inductive case: if all j in [n, m) satisfy P, then P(m) holds\n\n  // The proof would proceed by showing P(n) directly\n  // using the second hypothesis with m = n\n  assert forall j :: n <= j < n ==> P(j); // Vacuously true\n}\n\nlemma CompleteInduction(n: nat, P: nat -> bool)\n  requires P(0)\n  requires forall k: nat :: k > 0 && (forall j: nat :: j < k ==> P(j)) ==> P(k)\n  ensures P(n)\n{\n  if n == 0 {\n    // Base case\n    assert P(0);\n  } else {\n    // Need to show all j < n satisfy P(j)\n    forall j: nat | j < n\n      ensures P(j)\n    {\n      if j == 0 {\n        assert P(0);\n      } else {\n        CompleteInduction(j, P);\n      }\n    }\n\n    // Now apply the inductive hypothesis\n    assert forall j: nat :: j < n ==> P(j);\n    assert P(n);\n  }\n}", "output": "assert n * (n - 1) * (2 * n - 1) == n * (2 * n * n - 3 * n + 1);"}, {"id": "example_SumSquaresFormula_3", "type": "assert", "program": "// Induction proofs with detailed reasoning steps\n\n// Sum of first n natural numbers\nfunction {:spec} sumTo(n: nat): nat\n{\n  if n == 0 then 0 else n + sumTo(n - 1)\n}\n\n// Sum of first n odd numbers\nfunction {:spec} sumOdds(n: nat): nat\n{\n  if n == 0 then 0 else (2 * n - 1) + sumOdds(n - 1)\n}\n\n// Sum of first n squares\nfunction {:spec} sumSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + sumSquares(n - 1)\n}\n\n// Power function\nfunction {:spec} power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\n// Fibonacci\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// --- Detailed Inductive Proofs ---\n\nlemma SumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    // Base case\n    assert sumTo(0) == 0;\n    assert 0 * (0 + 1) / 2 == 0;\n  } else {\n    // Inductive step\n    SumToFormula(n - 1);\n\n    calc == {\n      sumTo(n);\n      n + sumTo(n - 1);\n      { // Induction hypothesis\n        assert sumTo(n - 1) == (n - 1) * n / 2;\n      }\n      n + (n - 1) * n / 2;\n      { // Algebra\n        assert n == 2 * n / 2;\n      }\n      2 * n / 2 + (n - 1) * n / 2;\n      (2 * n + (n - 1) * n) / 2;\n      (2 * n + n * n - n) / 2;\n      (n + n * n) / 2;\n      n * (1 + n) / 2;\n      n * (n + 1) / 2;\n    }\n  }\n}\n\nlemma SumOddsIsSquare(n: nat)\n  ensures sumOdds(n) == n * n\n{\n  if n == 0 {\n    // Base case\n    assert sumOdds(0) == 0;\n    assert 0 * 0 == 0;\n  } else {\n    // Inductive step\n    SumOddsIsSquare(n - 1);\n\n    calc == {\n      sumOdds(n);\n      (2 * n - 1) + sumOdds(n - 1);\n      { // Induction hypothesis\n        assert sumOdds(n - 1) == (n - 1) * (n - 1);\n      }\n      (2 * n - 1) + (n - 1) * (n - 1);\n      { // Expand (n-1)\u00b2\n        assert (n - 1) * (n - 1) == n * n - 2 * n + 1;\n      }\n      (2 * n - 1) + (n * n - 2 * n + 1);\n      2 * n - 1 + n * n - 2 * n + 1;\n      n * n;\n    }\n  }\n}\n\nlemma SumSquaresFormula(n: nat)\n  ensures sumSquares(n) == n * (n + 1) * (2 * n + 1) / 6\n{\n  if n == 0 {\n    // Base case\n    assert sumSquares(0) == 0;\n    assert 0 * (0 + 1) * (2 * 0 + 1) / 6 == 0;\n  } else {\n    // Inductive step\n    SumSquaresFormula(n - 1);\n\n    calc == {\n      sumSquares(n);\n      n * n + sumSquares(n - 1);\n      { // Induction hypothesis\n        assert sumSquares(n - 1) == (n - 1) * n * (2 * n - 1) / 6;\n      }\n      n * n + (n - 1) * n * (2 * n - 1) / 6;\n      { // Factor out common terms\n        assert n * n == 6 * n * n / 6;\n      }\n      6 * n * n / 6 + (n - 1) * n * (2 * n - 1) / 6;\n      (6 * n * n + (n - 1) * n * (2 * n - 1)) / 6;\n      { // Expand\n        \n/*[CODE HERE]*/\n        assert n * (n - 1) * (2 * n - 1) == n * (2 * n * n - 3 * n + 1);\n        assert n * (2 * n * n - 3 * n + 1) == 2 * n * n * n - 3 * n * n + n;\n      }\n      (6 * n * n + 2 * n * n * n - 3 * n * n + n) / 6;\n      (2 * n * n * n + 3 * n * n + n) / 6;\n      n * (2 * n * n + 3 * n + 1) / 6;\n      { // Factor\n        assert 2 * n * n + 3 * n + 1 == (n + 1) * (2 * n + 1);\n      }\n      n * (n + 1) * (2 * n + 1) / 6;\n    }\n  }\n}\n\nlemma PowerOfTwo(n: nat)\n  ensures power(2, n) >= n + 1\n{\n  if n == 0 {\n    // Base case\n    assert power(2, 0) == 1;\n    assert 1 >= 0 + 1;\n  } else {\n    // Inductive step\n    PowerOfTwo(n - 1);\n\n    calc >= {\n      power(2, n);\n      2 * power(2, n - 1);\n      { // Induction hypothesis\n        assert power(2, n - 1) >= n;\n      }\n      2 * n;\n      { // Since n >= 1\n        assert n >= 1;\n        assert 2 * n >= n + 1;\n      }\n      n + 1;\n    }\n  }\n}\n\nlemma PowerMonotonic(base: nat, exp1: nat, exp2: nat)\n  requires base > 1\n  requires exp1 <= exp2\n  ensures power(base, exp1) <= power(base, exp2)\n{\n  if exp1 == exp2 {\n    // Equal case\n    assert power(base, exp1) == power(base, exp2);\n  } else {\n    // exp1 < exp2\n    assert exp1 < exp2;\n\n    if exp1 == 0 {\n      assert power(base, exp1) == 1;\n      PowerPositive(base, exp2);\n      assert power(base, exp2) >= 1;\n    } else {\n      // Both exp1 and exp2 are positive\n      PowerMonotonic(base, exp1 - 1, exp2 - 1);\n\n      calc <= {\n        power(base, exp1);\n        base * power(base, exp1 - 1);\n        { // Induction hypothesis\n          assert power(base, exp1 - 1) <= power(base, exp2 - 1);\n        }\n        base * power(base, exp2 - 1);\n        power(base, exp2);\n      }\n    }\n  }\n}\n\nlemma PowerPositive(base: nat, exp: nat)\n  requires base > 0\n  ensures power(base, exp) > 0\n{\n  if exp == 0 {\n    assert power(base, 0) == 1;\n  } else {\n    PowerPositive(base, exp - 1);\n    assert power(base, exp) == base * power(base, exp - 1);\n    assert base > 0 && power(base, exp - 1) > 0;\n  }\n}\n\nlemma FibonacciInequality(n: nat)\n  requires n >= 1\n  ensures fib(n) <= power(2, n - 1)\n{\n  if n == 1 {\n    // Base case\n    assert fib(1) == 1;\n    assert power(2, 0) == 1;\n  } else if n == 2 {\n    // Base case\n    assert fib(2) == 1;\n    assert power(2, 1) == 2;\n    assert 1 <= 2;\n  } else {\n    // Inductive step (n >= 3)\n    assert n >= 3;\n    FibonacciInequality(n - 1);\n    FibonacciInequality(n - 2);\n\n    calc <= {\n      fib(n);\n      fib(n - 1) + fib(n - 2);\n      { // Induction hypotheses\n        assert fib(n - 1) <= power(2, n - 2);\n        assert fib(n - 2) <= power(2, n - 3);\n      }\n      power(2, n - 2) + power(2, n - 3);\n      { // Factor out power(2, n - 3)\n        assert power(2, n - 2) == 2 * power(2, n - 3);\n      }\n      2 * power(2, n - 3) + power(2, n - 3);\n      3 * power(2, n - 3);\n      { // 3 * 2^(n-3) <= 4 * 2^(n-3) = 2^(n-1)\n        assert 3 <= 4;\n        assert power(2, n - 1) == 4 * power(2, n - 3);\n      }\n      power(2, n - 1);\n    }\n  }\n}\n\nlemma StrongInduction(n: nat, P: nat -> bool)\n  requires forall k :: 0 <= k < n ==> P(k)\n  requires forall m :: m >= n && (forall j :: n <= j < m ==> P(j)) ==> P(m)\n  ensures P(n)\n{\n  // This demonstrates the strong induction principle\n  // Base case: all k < n satisfy P(k) by hypothesis\n  // Inductive case: if all j in [n, m) satisfy P, then P(m) holds\n\n  // The proof would proceed by showing P(n) directly\n  // using the second hypothesis with m = n\n  assert forall j :: n <= j < n ==> P(j); // Vacuously true\n}\n\nlemma CompleteInduction(n: nat, P: nat -> bool)\n  requires P(0)\n  requires forall k: nat :: k > 0 && (forall j: nat :: j < k ==> P(j)) ==> P(k)\n  ensures P(n)\n{\n  if n == 0 {\n    // Base case\n    assert P(0);\n  } else {\n    // Need to show all j < n satisfy P(j)\n    forall j: nat | j < n\n      ensures P(j)\n    {\n      if j == 0 {\n        assert P(0);\n      } else {\n        CompleteInduction(j, P);\n      }\n    }\n\n    // Now apply the inductive hypothesis\n    assert forall j: nat :: j < n ==> P(j);\n    assert P(n);\n  }\n}", "output": "assert (n - 1) * n * (2 * n - 1) == n * (n - 1) * (2 * n - 1);"}, {"id": "example_SumSquaresFormula_4", "type": "assert", "program": "// Induction proofs with detailed reasoning steps\n\n// Sum of first n natural numbers\nfunction {:spec} sumTo(n: nat): nat\n{\n  if n == 0 then 0 else n + sumTo(n - 1)\n}\n\n// Sum of first n odd numbers\nfunction {:spec} sumOdds(n: nat): nat\n{\n  if n == 0 then 0 else (2 * n - 1) + sumOdds(n - 1)\n}\n\n// Sum of first n squares\nfunction {:spec} sumSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + sumSquares(n - 1)\n}\n\n// Power function\nfunction {:spec} power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\n// Fibonacci\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// --- Detailed Inductive Proofs ---\n\nlemma SumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    // Base case\n    assert sumTo(0) == 0;\n    assert 0 * (0 + 1) / 2 == 0;\n  } else {\n    // Inductive step\n    SumToFormula(n - 1);\n\n    calc == {\n      sumTo(n);\n      n + sumTo(n - 1);\n      { // Induction hypothesis\n        assert sumTo(n - 1) == (n - 1) * n / 2;\n      }\n      n + (n - 1) * n / 2;\n      { // Algebra\n        assert n == 2 * n / 2;\n      }\n      2 * n / 2 + (n - 1) * n / 2;\n      (2 * n + (n - 1) * n) / 2;\n      (2 * n + n * n - n) / 2;\n      (n + n * n) / 2;\n      n * (1 + n) / 2;\n      n * (n + 1) / 2;\n    }\n  }\n}\n\nlemma SumOddsIsSquare(n: nat)\n  ensures sumOdds(n) == n * n\n{\n  if n == 0 {\n    // Base case\n    assert sumOdds(0) == 0;\n    assert 0 * 0 == 0;\n  } else {\n    // Inductive step\n    SumOddsIsSquare(n - 1);\n\n    calc == {\n      sumOdds(n);\n      (2 * n - 1) + sumOdds(n - 1);\n      { // Induction hypothesis\n        assert sumOdds(n - 1) == (n - 1) * (n - 1);\n      }\n      (2 * n - 1) + (n - 1) * (n - 1);\n      { // Expand (n-1)\u00b2\n        assert (n - 1) * (n - 1) == n * n - 2 * n + 1;\n      }\n      (2 * n - 1) + (n * n - 2 * n + 1);\n      2 * n - 1 + n * n - 2 * n + 1;\n      n * n;\n    }\n  }\n}\n\nlemma SumSquaresFormula(n: nat)\n  ensures sumSquares(n) == n * (n + 1) * (2 * n + 1) / 6\n{\n  if n == 0 {\n    // Base case\n    assert sumSquares(0) == 0;\n    assert 0 * (0 + 1) * (2 * 0 + 1) / 6 == 0;\n  } else {\n    // Inductive step\n    SumSquaresFormula(n - 1);\n\n    calc == {\n      sumSquares(n);\n      n * n + sumSquares(n - 1);\n      { // Induction hypothesis\n        assert sumSquares(n - 1) == (n - 1) * n * (2 * n - 1) / 6;\n      }\n      n * n + (n - 1) * n * (2 * n - 1) / 6;\n      { // Factor out common terms\n        \n/*[CODE HERE]*/\n      }\n      6 * n * n / 6 + (n - 1) * n * (2 * n - 1) / 6;\n      (6 * n * n + (n - 1) * n * (2 * n - 1)) / 6;\n      { // Expand\n        assert (n - 1) * n * (2 * n - 1) == n * (n - 1) * (2 * n - 1);\n        assert n * (n - 1) * (2 * n - 1) == n * (2 * n * n - 3 * n + 1);\n        assert n * (2 * n * n - 3 * n + 1) == 2 * n * n * n - 3 * n * n + n;\n      }\n      (6 * n * n + 2 * n * n * n - 3 * n * n + n) / 6;\n      (2 * n * n * n + 3 * n * n + n) / 6;\n      n * (2 * n * n + 3 * n + 1) / 6;\n      { // Factor\n        assert 2 * n * n + 3 * n + 1 == (n + 1) * (2 * n + 1);\n      }\n      n * (n + 1) * (2 * n + 1) / 6;\n    }\n  }\n}\n\nlemma PowerOfTwo(n: nat)\n  ensures power(2, n) >= n + 1\n{\n  if n == 0 {\n    // Base case\n    assert power(2, 0) == 1;\n    assert 1 >= 0 + 1;\n  } else {\n    // Inductive step\n    PowerOfTwo(n - 1);\n\n    calc >= {\n      power(2, n);\n      2 * power(2, n - 1);\n      { // Induction hypothesis\n        assert power(2, n - 1) >= n;\n      }\n      2 * n;\n      { // Since n >= 1\n        assert n >= 1;\n        assert 2 * n >= n + 1;\n      }\n      n + 1;\n    }\n  }\n}\n\nlemma PowerMonotonic(base: nat, exp1: nat, exp2: nat)\n  requires base > 1\n  requires exp1 <= exp2\n  ensures power(base, exp1) <= power(base, exp2)\n{\n  if exp1 == exp2 {\n    // Equal case\n    assert power(base, exp1) == power(base, exp2);\n  } else {\n    // exp1 < exp2\n    assert exp1 < exp2;\n\n    if exp1 == 0 {\n      assert power(base, exp1) == 1;\n      PowerPositive(base, exp2);\n      assert power(base, exp2) >= 1;\n    } else {\n      // Both exp1 and exp2 are positive\n      PowerMonotonic(base, exp1 - 1, exp2 - 1);\n\n      calc <= {\n        power(base, exp1);\n        base * power(base, exp1 - 1);\n        { // Induction hypothesis\n          assert power(base, exp1 - 1) <= power(base, exp2 - 1);\n        }\n        base * power(base, exp2 - 1);\n        power(base, exp2);\n      }\n    }\n  }\n}\n\nlemma PowerPositive(base: nat, exp: nat)\n  requires base > 0\n  ensures power(base, exp) > 0\n{\n  if exp == 0 {\n    assert power(base, 0) == 1;\n  } else {\n    PowerPositive(base, exp - 1);\n    assert power(base, exp) == base * power(base, exp - 1);\n    assert base > 0 && power(base, exp - 1) > 0;\n  }\n}\n\nlemma FibonacciInequality(n: nat)\n  requires n >= 1\n  ensures fib(n) <= power(2, n - 1)\n{\n  if n == 1 {\n    // Base case\n    assert fib(1) == 1;\n    assert power(2, 0) == 1;\n  } else if n == 2 {\n    // Base case\n    assert fib(2) == 1;\n    assert power(2, 1) == 2;\n    assert 1 <= 2;\n  } else {\n    // Inductive step (n >= 3)\n    assert n >= 3;\n    FibonacciInequality(n - 1);\n    FibonacciInequality(n - 2);\n\n    calc <= {\n      fib(n);\n      fib(n - 1) + fib(n - 2);\n      { // Induction hypotheses\n        assert fib(n - 1) <= power(2, n - 2);\n        assert fib(n - 2) <= power(2, n - 3);\n      }\n      power(2, n - 2) + power(2, n - 3);\n      { // Factor out power(2, n - 3)\n        assert power(2, n - 2) == 2 * power(2, n - 3);\n      }\n      2 * power(2, n - 3) + power(2, n - 3);\n      3 * power(2, n - 3);\n      { // 3 * 2^(n-3) <= 4 * 2^(n-3) = 2^(n-1)\n        assert 3 <= 4;\n        assert power(2, n - 1) == 4 * power(2, n - 3);\n      }\n      power(2, n - 1);\n    }\n  }\n}\n\nlemma StrongInduction(n: nat, P: nat -> bool)\n  requires forall k :: 0 <= k < n ==> P(k)\n  requires forall m :: m >= n && (forall j :: n <= j < m ==> P(j)) ==> P(m)\n  ensures P(n)\n{\n  // This demonstrates the strong induction principle\n  // Base case: all k < n satisfy P(k) by hypothesis\n  // Inductive case: if all j in [n, m) satisfy P, then P(m) holds\n\n  // The proof would proceed by showing P(n) directly\n  // using the second hypothesis with m = n\n  assert forall j :: n <= j < n ==> P(j); // Vacuously true\n}\n\nlemma CompleteInduction(n: nat, P: nat -> bool)\n  requires P(0)\n  requires forall k: nat :: k > 0 && (forall j: nat :: j < k ==> P(j)) ==> P(k)\n  ensures P(n)\n{\n  if n == 0 {\n    // Base case\n    assert P(0);\n  } else {\n    // Need to show all j < n satisfy P(j)\n    forall j: nat | j < n\n      ensures P(j)\n    {\n      if j == 0 {\n        assert P(0);\n      } else {\n        CompleteInduction(j, P);\n      }\n    }\n\n    // Now apply the inductive hypothesis\n    assert forall j: nat :: j < n ==> P(j);\n    assert P(n);\n  }\n}", "output": "assert n * n == 6 * n * n / 6;"}, {"id": "example_SumSquaresFormula_5", "type": "assert", "program": "// Induction proofs with detailed reasoning steps\n\n// Sum of first n natural numbers\nfunction {:spec} sumTo(n: nat): nat\n{\n  if n == 0 then 0 else n + sumTo(n - 1)\n}\n\n// Sum of first n odd numbers\nfunction {:spec} sumOdds(n: nat): nat\n{\n  if n == 0 then 0 else (2 * n - 1) + sumOdds(n - 1)\n}\n\n// Sum of first n squares\nfunction {:spec} sumSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + sumSquares(n - 1)\n}\n\n// Power function\nfunction {:spec} power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\n// Fibonacci\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// --- Detailed Inductive Proofs ---\n\nlemma SumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    // Base case\n    assert sumTo(0) == 0;\n    assert 0 * (0 + 1) / 2 == 0;\n  } else {\n    // Inductive step\n    SumToFormula(n - 1);\n\n    calc == {\n      sumTo(n);\n      n + sumTo(n - 1);\n      { // Induction hypothesis\n        assert sumTo(n - 1) == (n - 1) * n / 2;\n      }\n      n + (n - 1) * n / 2;\n      { // Algebra\n        assert n == 2 * n / 2;\n      }\n      2 * n / 2 + (n - 1) * n / 2;\n      (2 * n + (n - 1) * n) / 2;\n      (2 * n + n * n - n) / 2;\n      (n + n * n) / 2;\n      n * (1 + n) / 2;\n      n * (n + 1) / 2;\n    }\n  }\n}\n\nlemma SumOddsIsSquare(n: nat)\n  ensures sumOdds(n) == n * n\n{\n  if n == 0 {\n    // Base case\n    assert sumOdds(0) == 0;\n    assert 0 * 0 == 0;\n  } else {\n    // Inductive step\n    SumOddsIsSquare(n - 1);\n\n    calc == {\n      sumOdds(n);\n      (2 * n - 1) + sumOdds(n - 1);\n      { // Induction hypothesis\n        assert sumOdds(n - 1) == (n - 1) * (n - 1);\n      }\n      (2 * n - 1) + (n - 1) * (n - 1);\n      { // Expand (n-1)\u00b2\n        assert (n - 1) * (n - 1) == n * n - 2 * n + 1;\n      }\n      (2 * n - 1) + (n * n - 2 * n + 1);\n      2 * n - 1 + n * n - 2 * n + 1;\n      n * n;\n    }\n  }\n}\n\nlemma SumSquaresFormula(n: nat)\n  ensures sumSquares(n) == n * (n + 1) * (2 * n + 1) / 6\n{\n  if n == 0 {\n    // Base case\n    assert sumSquares(0) == 0;\n    assert 0 * (0 + 1) * (2 * 0 + 1) / 6 == 0;\n  } else {\n    // Inductive step\n    SumSquaresFormula(n - 1);\n\n    calc == {\n      sumSquares(n);\n      n * n + sumSquares(n - 1);\n      { // Induction hypothesis\n        \n/*[CODE HERE]*/\n      }\n      n * n + (n - 1) * n * (2 * n - 1) / 6;\n      { // Factor out common terms\n        assert n * n == 6 * n * n / 6;\n      }\n      6 * n * n / 6 + (n - 1) * n * (2 * n - 1) / 6;\n      (6 * n * n + (n - 1) * n * (2 * n - 1)) / 6;\n      { // Expand\n        assert (n - 1) * n * (2 * n - 1) == n * (n - 1) * (2 * n - 1);\n        assert n * (n - 1) * (2 * n - 1) == n * (2 * n * n - 3 * n + 1);\n        assert n * (2 * n * n - 3 * n + 1) == 2 * n * n * n - 3 * n * n + n;\n      }\n      (6 * n * n + 2 * n * n * n - 3 * n * n + n) / 6;\n      (2 * n * n * n + 3 * n * n + n) / 6;\n      n * (2 * n * n + 3 * n + 1) / 6;\n      { // Factor\n        assert 2 * n * n + 3 * n + 1 == (n + 1) * (2 * n + 1);\n      }\n      n * (n + 1) * (2 * n + 1) / 6;\n    }\n  }\n}\n\nlemma PowerOfTwo(n: nat)\n  ensures power(2, n) >= n + 1\n{\n  if n == 0 {\n    // Base case\n    assert power(2, 0) == 1;\n    assert 1 >= 0 + 1;\n  } else {\n    // Inductive step\n    PowerOfTwo(n - 1);\n\n    calc >= {\n      power(2, n);\n      2 * power(2, n - 1);\n      { // Induction hypothesis\n        assert power(2, n - 1) >= n;\n      }\n      2 * n;\n      { // Since n >= 1\n        assert n >= 1;\n        assert 2 * n >= n + 1;\n      }\n      n + 1;\n    }\n  }\n}\n\nlemma PowerMonotonic(base: nat, exp1: nat, exp2: nat)\n  requires base > 1\n  requires exp1 <= exp2\n  ensures power(base, exp1) <= power(base, exp2)\n{\n  if exp1 == exp2 {\n    // Equal case\n    assert power(base, exp1) == power(base, exp2);\n  } else {\n    // exp1 < exp2\n    assert exp1 < exp2;\n\n    if exp1 == 0 {\n      assert power(base, exp1) == 1;\n      PowerPositive(base, exp2);\n      assert power(base, exp2) >= 1;\n    } else {\n      // Both exp1 and exp2 are positive\n      PowerMonotonic(base, exp1 - 1, exp2 - 1);\n\n      calc <= {\n        power(base, exp1);\n        base * power(base, exp1 - 1);\n        { // Induction hypothesis\n          assert power(base, exp1 - 1) <= power(base, exp2 - 1);\n        }\n        base * power(base, exp2 - 1);\n        power(base, exp2);\n      }\n    }\n  }\n}\n\nlemma PowerPositive(base: nat, exp: nat)\n  requires base > 0\n  ensures power(base, exp) > 0\n{\n  if exp == 0 {\n    assert power(base, 0) == 1;\n  } else {\n    PowerPositive(base, exp - 1);\n    assert power(base, exp) == base * power(base, exp - 1);\n    assert base > 0 && power(base, exp - 1) > 0;\n  }\n}\n\nlemma FibonacciInequality(n: nat)\n  requires n >= 1\n  ensures fib(n) <= power(2, n - 1)\n{\n  if n == 1 {\n    // Base case\n    assert fib(1) == 1;\n    assert power(2, 0) == 1;\n  } else if n == 2 {\n    // Base case\n    assert fib(2) == 1;\n    assert power(2, 1) == 2;\n    assert 1 <= 2;\n  } else {\n    // Inductive step (n >= 3)\n    assert n >= 3;\n    FibonacciInequality(n - 1);\n    FibonacciInequality(n - 2);\n\n    calc <= {\n      fib(n);\n      fib(n - 1) + fib(n - 2);\n      { // Induction hypotheses\n        assert fib(n - 1) <= power(2, n - 2);\n        assert fib(n - 2) <= power(2, n - 3);\n      }\n      power(2, n - 2) + power(2, n - 3);\n      { // Factor out power(2, n - 3)\n        assert power(2, n - 2) == 2 * power(2, n - 3);\n      }\n      2 * power(2, n - 3) + power(2, n - 3);\n      3 * power(2, n - 3);\n      { // 3 * 2^(n-3) <= 4 * 2^(n-3) = 2^(n-1)\n        assert 3 <= 4;\n        assert power(2, n - 1) == 4 * power(2, n - 3);\n      }\n      power(2, n - 1);\n    }\n  }\n}\n\nlemma StrongInduction(n: nat, P: nat -> bool)\n  requires forall k :: 0 <= k < n ==> P(k)\n  requires forall m :: m >= n && (forall j :: n <= j < m ==> P(j)) ==> P(m)\n  ensures P(n)\n{\n  // This demonstrates the strong induction principle\n  // Base case: all k < n satisfy P(k) by hypothesis\n  // Inductive case: if all j in [n, m) satisfy P, then P(m) holds\n\n  // The proof would proceed by showing P(n) directly\n  // using the second hypothesis with m = n\n  assert forall j :: n <= j < n ==> P(j); // Vacuously true\n}\n\nlemma CompleteInduction(n: nat, P: nat -> bool)\n  requires P(0)\n  requires forall k: nat :: k > 0 && (forall j: nat :: j < k ==> P(j)) ==> P(k)\n  ensures P(n)\n{\n  if n == 0 {\n    // Base case\n    assert P(0);\n  } else {\n    // Need to show all j < n satisfy P(j)\n    forall j: nat | j < n\n      ensures P(j)\n    {\n      if j == 0 {\n        assert P(0);\n      } else {\n        CompleteInduction(j, P);\n      }\n    }\n\n    // Now apply the inductive hypothesis\n    assert forall j: nat :: j < n ==> P(j);\n    assert P(n);\n  }\n}", "output": "assert sumSquares(n - 1) == (n - 1) * n * (2 * n - 1) / 6;"}, {"id": "example_SumSquaresFormula_6", "type": "call", "program": "// Induction proofs with detailed reasoning steps\n\n// Sum of first n natural numbers\nfunction {:spec} sumTo(n: nat): nat\n{\n  if n == 0 then 0 else n + sumTo(n - 1)\n}\n\n// Sum of first n odd numbers\nfunction {:spec} sumOdds(n: nat): nat\n{\n  if n == 0 then 0 else (2 * n - 1) + sumOdds(n - 1)\n}\n\n// Sum of first n squares\nfunction {:spec} sumSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + sumSquares(n - 1)\n}\n\n// Power function\nfunction {:spec} power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\n// Fibonacci\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// --- Detailed Inductive Proofs ---\n\nlemma SumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    // Base case\n    assert sumTo(0) == 0;\n    assert 0 * (0 + 1) / 2 == 0;\n  } else {\n    // Inductive step\n    SumToFormula(n - 1);\n\n    calc == {\n      sumTo(n);\n      n + sumTo(n - 1);\n      { // Induction hypothesis\n        assert sumTo(n - 1) == (n - 1) * n / 2;\n      }\n      n + (n - 1) * n / 2;\n      { // Algebra\n        assert n == 2 * n / 2;\n      }\n      2 * n / 2 + (n - 1) * n / 2;\n      (2 * n + (n - 1) * n) / 2;\n      (2 * n + n * n - n) / 2;\n      (n + n * n) / 2;\n      n * (1 + n) / 2;\n      n * (n + 1) / 2;\n    }\n  }\n}\n\nlemma SumOddsIsSquare(n: nat)\n  ensures sumOdds(n) == n * n\n{\n  if n == 0 {\n    // Base case\n    assert sumOdds(0) == 0;\n    assert 0 * 0 == 0;\n  } else {\n    // Inductive step\n    SumOddsIsSquare(n - 1);\n\n    calc == {\n      sumOdds(n);\n      (2 * n - 1) + sumOdds(n - 1);\n      { // Induction hypothesis\n        assert sumOdds(n - 1) == (n - 1) * (n - 1);\n      }\n      (2 * n - 1) + (n - 1) * (n - 1);\n      { // Expand (n-1)\u00b2\n        assert (n - 1) * (n - 1) == n * n - 2 * n + 1;\n      }\n      (2 * n - 1) + (n * n - 2 * n + 1);\n      2 * n - 1 + n * n - 2 * n + 1;\n      n * n;\n    }\n  }\n}\n\nlemma SumSquaresFormula(n: nat)\n  ensures sumSquares(n) == n * (n + 1) * (2 * n + 1) / 6\n{\n  if n == 0 {\n    // Base case\n    assert sumSquares(0) == 0;\n    assert 0 * (0 + 1) * (2 * 0 + 1) / 6 == 0;\n  } else {\n    // Inductive step\n    \n/*[CODE HERE]*/\n\n    calc == {\n      sumSquares(n);\n      n * n + sumSquares(n - 1);\n      { // Induction hypothesis\n        assert sumSquares(n - 1) == (n - 1) * n * (2 * n - 1) / 6;\n      }\n      n * n + (n - 1) * n * (2 * n - 1) / 6;\n      { // Factor out common terms\n        assert n * n == 6 * n * n / 6;\n      }\n      6 * n * n / 6 + (n - 1) * n * (2 * n - 1) / 6;\n      (6 * n * n + (n - 1) * n * (2 * n - 1)) / 6;\n      { // Expand\n        assert (n - 1) * n * (2 * n - 1) == n * (n - 1) * (2 * n - 1);\n        assert n * (n - 1) * (2 * n - 1) == n * (2 * n * n - 3 * n + 1);\n        assert n * (2 * n * n - 3 * n + 1) == 2 * n * n * n - 3 * n * n + n;\n      }\n      (6 * n * n + 2 * n * n * n - 3 * n * n + n) / 6;\n      (2 * n * n * n + 3 * n * n + n) / 6;\n      n * (2 * n * n + 3 * n + 1) / 6;\n      { // Factor\n        assert 2 * n * n + 3 * n + 1 == (n + 1) * (2 * n + 1);\n      }\n      n * (n + 1) * (2 * n + 1) / 6;\n    }\n  }\n}\n\nlemma PowerOfTwo(n: nat)\n  ensures power(2, n) >= n + 1\n{\n  if n == 0 {\n    // Base case\n    assert power(2, 0) == 1;\n    assert 1 >= 0 + 1;\n  } else {\n    // Inductive step\n    PowerOfTwo(n - 1);\n\n    calc >= {\n      power(2, n);\n      2 * power(2, n - 1);\n      { // Induction hypothesis\n        assert power(2, n - 1) >= n;\n      }\n      2 * n;\n      { // Since n >= 1\n        assert n >= 1;\n        assert 2 * n >= n + 1;\n      }\n      n + 1;\n    }\n  }\n}\n\nlemma PowerMonotonic(base: nat, exp1: nat, exp2: nat)\n  requires base > 1\n  requires exp1 <= exp2\n  ensures power(base, exp1) <= power(base, exp2)\n{\n  if exp1 == exp2 {\n    // Equal case\n    assert power(base, exp1) == power(base, exp2);\n  } else {\n    // exp1 < exp2\n    assert exp1 < exp2;\n\n    if exp1 == 0 {\n      assert power(base, exp1) == 1;\n      PowerPositive(base, exp2);\n      assert power(base, exp2) >= 1;\n    } else {\n      // Both exp1 and exp2 are positive\n      PowerMonotonic(base, exp1 - 1, exp2 - 1);\n\n      calc <= {\n        power(base, exp1);\n        base * power(base, exp1 - 1);\n        { // Induction hypothesis\n          assert power(base, exp1 - 1) <= power(base, exp2 - 1);\n        }\n        base * power(base, exp2 - 1);\n        power(base, exp2);\n      }\n    }\n  }\n}\n\nlemma PowerPositive(base: nat, exp: nat)\n  requires base > 0\n  ensures power(base, exp) > 0\n{\n  if exp == 0 {\n    assert power(base, 0) == 1;\n  } else {\n    PowerPositive(base, exp - 1);\n    assert power(base, exp) == base * power(base, exp - 1);\n    assert base > 0 && power(base, exp - 1) > 0;\n  }\n}\n\nlemma FibonacciInequality(n: nat)\n  requires n >= 1\n  ensures fib(n) <= power(2, n - 1)\n{\n  if n == 1 {\n    // Base case\n    assert fib(1) == 1;\n    assert power(2, 0) == 1;\n  } else if n == 2 {\n    // Base case\n    assert fib(2) == 1;\n    assert power(2, 1) == 2;\n    assert 1 <= 2;\n  } else {\n    // Inductive step (n >= 3)\n    assert n >= 3;\n    FibonacciInequality(n - 1);\n    FibonacciInequality(n - 2);\n\n    calc <= {\n      fib(n);\n      fib(n - 1) + fib(n - 2);\n      { // Induction hypotheses\n        assert fib(n - 1) <= power(2, n - 2);\n        assert fib(n - 2) <= power(2, n - 3);\n      }\n      power(2, n - 2) + power(2, n - 3);\n      { // Factor out power(2, n - 3)\n        assert power(2, n - 2) == 2 * power(2, n - 3);\n      }\n      2 * power(2, n - 3) + power(2, n - 3);\n      3 * power(2, n - 3);\n      { // 3 * 2^(n-3) <= 4 * 2^(n-3) = 2^(n-1)\n        assert 3 <= 4;\n        assert power(2, n - 1) == 4 * power(2, n - 3);\n      }\n      power(2, n - 1);\n    }\n  }\n}\n\nlemma StrongInduction(n: nat, P: nat -> bool)\n  requires forall k :: 0 <= k < n ==> P(k)\n  requires forall m :: m >= n && (forall j :: n <= j < m ==> P(j)) ==> P(m)\n  ensures P(n)\n{\n  // This demonstrates the strong induction principle\n  // Base case: all k < n satisfy P(k) by hypothesis\n  // Inductive case: if all j in [n, m) satisfy P, then P(m) holds\n\n  // The proof would proceed by showing P(n) directly\n  // using the second hypothesis with m = n\n  assert forall j :: n <= j < n ==> P(j); // Vacuously true\n}\n\nlemma CompleteInduction(n: nat, P: nat -> bool)\n  requires P(0)\n  requires forall k: nat :: k > 0 && (forall j: nat :: j < k ==> P(j)) ==> P(k)\n  ensures P(n)\n{\n  if n == 0 {\n    // Base case\n    assert P(0);\n  } else {\n    // Need to show all j < n satisfy P(j)\n    forall j: nat | j < n\n      ensures P(j)\n    {\n      if j == 0 {\n        assert P(0);\n      } else {\n        CompleteInduction(j, P);\n      }\n    }\n\n    // Now apply the inductive hypothesis\n    assert forall j: nat :: j < n ==> P(j);\n    assert P(n);\n  }\n}", "output": "SumSquaresFormula(n - 1);"}, {"id": "example_SumSquaresFormula_7", "type": "assert", "program": "// Induction proofs with detailed reasoning steps\n\n// Sum of first n natural numbers\nfunction {:spec} sumTo(n: nat): nat\n{\n  if n == 0 then 0 else n + sumTo(n - 1)\n}\n\n// Sum of first n odd numbers\nfunction {:spec} sumOdds(n: nat): nat\n{\n  if n == 0 then 0 else (2 * n - 1) + sumOdds(n - 1)\n}\n\n// Sum of first n squares\nfunction {:spec} sumSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + sumSquares(n - 1)\n}\n\n// Power function\nfunction {:spec} power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\n// Fibonacci\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// --- Detailed Inductive Proofs ---\n\nlemma SumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    // Base case\n    assert sumTo(0) == 0;\n    assert 0 * (0 + 1) / 2 == 0;\n  } else {\n    // Inductive step\n    SumToFormula(n - 1);\n\n    calc == {\n      sumTo(n);\n      n + sumTo(n - 1);\n      { // Induction hypothesis\n        assert sumTo(n - 1) == (n - 1) * n / 2;\n      }\n      n + (n - 1) * n / 2;\n      { // Algebra\n        assert n == 2 * n / 2;\n      }\n      2 * n / 2 + (n - 1) * n / 2;\n      (2 * n + (n - 1) * n) / 2;\n      (2 * n + n * n - n) / 2;\n      (n + n * n) / 2;\n      n * (1 + n) / 2;\n      n * (n + 1) / 2;\n    }\n  }\n}\n\nlemma SumOddsIsSquare(n: nat)\n  ensures sumOdds(n) == n * n\n{\n  if n == 0 {\n    // Base case\n    assert sumOdds(0) == 0;\n    assert 0 * 0 == 0;\n  } else {\n    // Inductive step\n    SumOddsIsSquare(n - 1);\n\n    calc == {\n      sumOdds(n);\n      (2 * n - 1) + sumOdds(n - 1);\n      { // Induction hypothesis\n        assert sumOdds(n - 1) == (n - 1) * (n - 1);\n      }\n      (2 * n - 1) + (n - 1) * (n - 1);\n      { // Expand (n-1)\u00b2\n        assert (n - 1) * (n - 1) == n * n - 2 * n + 1;\n      }\n      (2 * n - 1) + (n * n - 2 * n + 1);\n      2 * n - 1 + n * n - 2 * n + 1;\n      n * n;\n    }\n  }\n}\n\nlemma SumSquaresFormula(n: nat)\n  ensures sumSquares(n) == n * (n + 1) * (2 * n + 1) / 6\n{\n  if n == 0 {\n    // Base case\n    assert sumSquares(0) == 0;\n    \n/*[CODE HERE]*/\n  } else {\n    // Inductive step\n    SumSquaresFormula(n - 1);\n\n    calc == {\n      sumSquares(n);\n      n * n + sumSquares(n - 1);\n      { // Induction hypothesis\n        assert sumSquares(n - 1) == (n - 1) * n * (2 * n - 1) / 6;\n      }\n      n * n + (n - 1) * n * (2 * n - 1) / 6;\n      { // Factor out common terms\n        assert n * n == 6 * n * n / 6;\n      }\n      6 * n * n / 6 + (n - 1) * n * (2 * n - 1) / 6;\n      (6 * n * n + (n - 1) * n * (2 * n - 1)) / 6;\n      { // Expand\n        assert (n - 1) * n * (2 * n - 1) == n * (n - 1) * (2 * n - 1);\n        assert n * (n - 1) * (2 * n - 1) == n * (2 * n * n - 3 * n + 1);\n        assert n * (2 * n * n - 3 * n + 1) == 2 * n * n * n - 3 * n * n + n;\n      }\n      (6 * n * n + 2 * n * n * n - 3 * n * n + n) / 6;\n      (2 * n * n * n + 3 * n * n + n) / 6;\n      n * (2 * n * n + 3 * n + 1) / 6;\n      { // Factor\n        assert 2 * n * n + 3 * n + 1 == (n + 1) * (2 * n + 1);\n      }\n      n * (n + 1) * (2 * n + 1) / 6;\n    }\n  }\n}\n\nlemma PowerOfTwo(n: nat)\n  ensures power(2, n) >= n + 1\n{\n  if n == 0 {\n    // Base case\n    assert power(2, 0) == 1;\n    assert 1 >= 0 + 1;\n  } else {\n    // Inductive step\n    PowerOfTwo(n - 1);\n\n    calc >= {\n      power(2, n);\n      2 * power(2, n - 1);\n      { // Induction hypothesis\n        assert power(2, n - 1) >= n;\n      }\n      2 * n;\n      { // Since n >= 1\n        assert n >= 1;\n        assert 2 * n >= n + 1;\n      }\n      n + 1;\n    }\n  }\n}\n\nlemma PowerMonotonic(base: nat, exp1: nat, exp2: nat)\n  requires base > 1\n  requires exp1 <= exp2\n  ensures power(base, exp1) <= power(base, exp2)\n{\n  if exp1 == exp2 {\n    // Equal case\n    assert power(base, exp1) == power(base, exp2);\n  } else {\n    // exp1 < exp2\n    assert exp1 < exp2;\n\n    if exp1 == 0 {\n      assert power(base, exp1) == 1;\n      PowerPositive(base, exp2);\n      assert power(base, exp2) >= 1;\n    } else {\n      // Both exp1 and exp2 are positive\n      PowerMonotonic(base, exp1 - 1, exp2 - 1);\n\n      calc <= {\n        power(base, exp1);\n        base * power(base, exp1 - 1);\n        { // Induction hypothesis\n          assert power(base, exp1 - 1) <= power(base, exp2 - 1);\n        }\n        base * power(base, exp2 - 1);\n        power(base, exp2);\n      }\n    }\n  }\n}\n\nlemma PowerPositive(base: nat, exp: nat)\n  requires base > 0\n  ensures power(base, exp) > 0\n{\n  if exp == 0 {\n    assert power(base, 0) == 1;\n  } else {\n    PowerPositive(base, exp - 1);\n    assert power(base, exp) == base * power(base, exp - 1);\n    assert base > 0 && power(base, exp - 1) > 0;\n  }\n}\n\nlemma FibonacciInequality(n: nat)\n  requires n >= 1\n  ensures fib(n) <= power(2, n - 1)\n{\n  if n == 1 {\n    // Base case\n    assert fib(1) == 1;\n    assert power(2, 0) == 1;\n  } else if n == 2 {\n    // Base case\n    assert fib(2) == 1;\n    assert power(2, 1) == 2;\n    assert 1 <= 2;\n  } else {\n    // Inductive step (n >= 3)\n    assert n >= 3;\n    FibonacciInequality(n - 1);\n    FibonacciInequality(n - 2);\n\n    calc <= {\n      fib(n);\n      fib(n - 1) + fib(n - 2);\n      { // Induction hypotheses\n        assert fib(n - 1) <= power(2, n - 2);\n        assert fib(n - 2) <= power(2, n - 3);\n      }\n      power(2, n - 2) + power(2, n - 3);\n      { // Factor out power(2, n - 3)\n        assert power(2, n - 2) == 2 * power(2, n - 3);\n      }\n      2 * power(2, n - 3) + power(2, n - 3);\n      3 * power(2, n - 3);\n      { // 3 * 2^(n-3) <= 4 * 2^(n-3) = 2^(n-1)\n        assert 3 <= 4;\n        assert power(2, n - 1) == 4 * power(2, n - 3);\n      }\n      power(2, n - 1);\n    }\n  }\n}\n\nlemma StrongInduction(n: nat, P: nat -> bool)\n  requires forall k :: 0 <= k < n ==> P(k)\n  requires forall m :: m >= n && (forall j :: n <= j < m ==> P(j)) ==> P(m)\n  ensures P(n)\n{\n  // This demonstrates the strong induction principle\n  // Base case: all k < n satisfy P(k) by hypothesis\n  // Inductive case: if all j in [n, m) satisfy P, then P(m) holds\n\n  // The proof would proceed by showing P(n) directly\n  // using the second hypothesis with m = n\n  assert forall j :: n <= j < n ==> P(j); // Vacuously true\n}\n\nlemma CompleteInduction(n: nat, P: nat -> bool)\n  requires P(0)\n  requires forall k: nat :: k > 0 && (forall j: nat :: j < k ==> P(j)) ==> P(k)\n  ensures P(n)\n{\n  if n == 0 {\n    // Base case\n    assert P(0);\n  } else {\n    // Need to show all j < n satisfy P(j)\n    forall j: nat | j < n\n      ensures P(j)\n    {\n      if j == 0 {\n        assert P(0);\n      } else {\n        CompleteInduction(j, P);\n      }\n    }\n\n    // Now apply the inductive hypothesis\n    assert forall j: nat :: j < n ==> P(j);\n    assert P(n);\n  }\n}", "output": "assert 0 * (0 + 1) * (2 * 0 + 1) / 6 == 0;"}, {"id": "example_SumSquaresFormula_8", "type": "assert", "program": "// Induction proofs with detailed reasoning steps\n\n// Sum of first n natural numbers\nfunction {:spec} sumTo(n: nat): nat\n{\n  if n == 0 then 0 else n + sumTo(n - 1)\n}\n\n// Sum of first n odd numbers\nfunction {:spec} sumOdds(n: nat): nat\n{\n  if n == 0 then 0 else (2 * n - 1) + sumOdds(n - 1)\n}\n\n// Sum of first n squares\nfunction {:spec} sumSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + sumSquares(n - 1)\n}\n\n// Power function\nfunction {:spec} power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\n// Fibonacci\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// --- Detailed Inductive Proofs ---\n\nlemma SumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    // Base case\n    assert sumTo(0) == 0;\n    assert 0 * (0 + 1) / 2 == 0;\n  } else {\n    // Inductive step\n    SumToFormula(n - 1);\n\n    calc == {\n      sumTo(n);\n      n + sumTo(n - 1);\n      { // Induction hypothesis\n        assert sumTo(n - 1) == (n - 1) * n / 2;\n      }\n      n + (n - 1) * n / 2;\n      { // Algebra\n        assert n == 2 * n / 2;\n      }\n      2 * n / 2 + (n - 1) * n / 2;\n      (2 * n + (n - 1) * n) / 2;\n      (2 * n + n * n - n) / 2;\n      (n + n * n) / 2;\n      n * (1 + n) / 2;\n      n * (n + 1) / 2;\n    }\n  }\n}\n\nlemma SumOddsIsSquare(n: nat)\n  ensures sumOdds(n) == n * n\n{\n  if n == 0 {\n    // Base case\n    assert sumOdds(0) == 0;\n    assert 0 * 0 == 0;\n  } else {\n    // Inductive step\n    SumOddsIsSquare(n - 1);\n\n    calc == {\n      sumOdds(n);\n      (2 * n - 1) + sumOdds(n - 1);\n      { // Induction hypothesis\n        assert sumOdds(n - 1) == (n - 1) * (n - 1);\n      }\n      (2 * n - 1) + (n - 1) * (n - 1);\n      { // Expand (n-1)\u00b2\n        assert (n - 1) * (n - 1) == n * n - 2 * n + 1;\n      }\n      (2 * n - 1) + (n * n - 2 * n + 1);\n      2 * n - 1 + n * n - 2 * n + 1;\n      n * n;\n    }\n  }\n}\n\nlemma SumSquaresFormula(n: nat)\n  ensures sumSquares(n) == n * (n + 1) * (2 * n + 1) / 6\n{\n  if n == 0 {\n    // Base case\n    \n/*[CODE HERE]*/\n    assert 0 * (0 + 1) * (2 * 0 + 1) / 6 == 0;\n  } else {\n    // Inductive step\n    SumSquaresFormula(n - 1);\n\n    calc == {\n      sumSquares(n);\n      n * n + sumSquares(n - 1);\n      { // Induction hypothesis\n        assert sumSquares(n - 1) == (n - 1) * n * (2 * n - 1) / 6;\n      }\n      n * n + (n - 1) * n * (2 * n - 1) / 6;\n      { // Factor out common terms\n        assert n * n == 6 * n * n / 6;\n      }\n      6 * n * n / 6 + (n - 1) * n * (2 * n - 1) / 6;\n      (6 * n * n + (n - 1) * n * (2 * n - 1)) / 6;\n      { // Expand\n        assert (n - 1) * n * (2 * n - 1) == n * (n - 1) * (2 * n - 1);\n        assert n * (n - 1) * (2 * n - 1) == n * (2 * n * n - 3 * n + 1);\n        assert n * (2 * n * n - 3 * n + 1) == 2 * n * n * n - 3 * n * n + n;\n      }\n      (6 * n * n + 2 * n * n * n - 3 * n * n + n) / 6;\n      (2 * n * n * n + 3 * n * n + n) / 6;\n      n * (2 * n * n + 3 * n + 1) / 6;\n      { // Factor\n        assert 2 * n * n + 3 * n + 1 == (n + 1) * (2 * n + 1);\n      }\n      n * (n + 1) * (2 * n + 1) / 6;\n    }\n  }\n}\n\nlemma PowerOfTwo(n: nat)\n  ensures power(2, n) >= n + 1\n{\n  if n == 0 {\n    // Base case\n    assert power(2, 0) == 1;\n    assert 1 >= 0 + 1;\n  } else {\n    // Inductive step\n    PowerOfTwo(n - 1);\n\n    calc >= {\n      power(2, n);\n      2 * power(2, n - 1);\n      { // Induction hypothesis\n        assert power(2, n - 1) >= n;\n      }\n      2 * n;\n      { // Since n >= 1\n        assert n >= 1;\n        assert 2 * n >= n + 1;\n      }\n      n + 1;\n    }\n  }\n}\n\nlemma PowerMonotonic(base: nat, exp1: nat, exp2: nat)\n  requires base > 1\n  requires exp1 <= exp2\n  ensures power(base, exp1) <= power(base, exp2)\n{\n  if exp1 == exp2 {\n    // Equal case\n    assert power(base, exp1) == power(base, exp2);\n  } else {\n    // exp1 < exp2\n    assert exp1 < exp2;\n\n    if exp1 == 0 {\n      assert power(base, exp1) == 1;\n      PowerPositive(base, exp2);\n      assert power(base, exp2) >= 1;\n    } else {\n      // Both exp1 and exp2 are positive\n      PowerMonotonic(base, exp1 - 1, exp2 - 1);\n\n      calc <= {\n        power(base, exp1);\n        base * power(base, exp1 - 1);\n        { // Induction hypothesis\n          assert power(base, exp1 - 1) <= power(base, exp2 - 1);\n        }\n        base * power(base, exp2 - 1);\n        power(base, exp2);\n      }\n    }\n  }\n}\n\nlemma PowerPositive(base: nat, exp: nat)\n  requires base > 0\n  ensures power(base, exp) > 0\n{\n  if exp == 0 {\n    assert power(base, 0) == 1;\n  } else {\n    PowerPositive(base, exp - 1);\n    assert power(base, exp) == base * power(base, exp - 1);\n    assert base > 0 && power(base, exp - 1) > 0;\n  }\n}\n\nlemma FibonacciInequality(n: nat)\n  requires n >= 1\n  ensures fib(n) <= power(2, n - 1)\n{\n  if n == 1 {\n    // Base case\n    assert fib(1) == 1;\n    assert power(2, 0) == 1;\n  } else if n == 2 {\n    // Base case\n    assert fib(2) == 1;\n    assert power(2, 1) == 2;\n    assert 1 <= 2;\n  } else {\n    // Inductive step (n >= 3)\n    assert n >= 3;\n    FibonacciInequality(n - 1);\n    FibonacciInequality(n - 2);\n\n    calc <= {\n      fib(n);\n      fib(n - 1) + fib(n - 2);\n      { // Induction hypotheses\n        assert fib(n - 1) <= power(2, n - 2);\n        assert fib(n - 2) <= power(2, n - 3);\n      }\n      power(2, n - 2) + power(2, n - 3);\n      { // Factor out power(2, n - 3)\n        assert power(2, n - 2) == 2 * power(2, n - 3);\n      }\n      2 * power(2, n - 3) + power(2, n - 3);\n      3 * power(2, n - 3);\n      { // 3 * 2^(n-3) <= 4 * 2^(n-3) = 2^(n-1)\n        assert 3 <= 4;\n        assert power(2, n - 1) == 4 * power(2, n - 3);\n      }\n      power(2, n - 1);\n    }\n  }\n}\n\nlemma StrongInduction(n: nat, P: nat -> bool)\n  requires forall k :: 0 <= k < n ==> P(k)\n  requires forall m :: m >= n && (forall j :: n <= j < m ==> P(j)) ==> P(m)\n  ensures P(n)\n{\n  // This demonstrates the strong induction principle\n  // Base case: all k < n satisfy P(k) by hypothesis\n  // Inductive case: if all j in [n, m) satisfy P, then P(m) holds\n\n  // The proof would proceed by showing P(n) directly\n  // using the second hypothesis with m = n\n  assert forall j :: n <= j < n ==> P(j); // Vacuously true\n}\n\nlemma CompleteInduction(n: nat, P: nat -> bool)\n  requires P(0)\n  requires forall k: nat :: k > 0 && (forall j: nat :: j < k ==> P(j)) ==> P(k)\n  ensures P(n)\n{\n  if n == 0 {\n    // Base case\n    assert P(0);\n  } else {\n    // Need to show all j < n satisfy P(j)\n    forall j: nat | j < n\n      ensures P(j)\n    {\n      if j == 0 {\n        assert P(0);\n      } else {\n        CompleteInduction(j, P);\n      }\n    }\n\n    // Now apply the inductive hypothesis\n    assert forall j: nat :: j < n ==> P(j);\n    assert P(n);\n  }\n}", "output": "assert sumSquares(0) == 0;"}, {"id": "example_PowerOfTwo_0", "type": "assert", "program": "// Induction proofs with detailed reasoning steps\n\n// Sum of first n natural numbers\nfunction {:spec} sumTo(n: nat): nat\n{\n  if n == 0 then 0 else n + sumTo(n - 1)\n}\n\n// Sum of first n odd numbers\nfunction {:spec} sumOdds(n: nat): nat\n{\n  if n == 0 then 0 else (2 * n - 1) + sumOdds(n - 1)\n}\n\n// Sum of first n squares\nfunction {:spec} sumSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + sumSquares(n - 1)\n}\n\n// Power function\nfunction {:spec} power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\n// Fibonacci\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// --- Detailed Inductive Proofs ---\n\nlemma SumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    // Base case\n    assert sumTo(0) == 0;\n    assert 0 * (0 + 1) / 2 == 0;\n  } else {\n    // Inductive step\n    SumToFormula(n - 1);\n\n    calc == {\n      sumTo(n);\n      n + sumTo(n - 1);\n      { // Induction hypothesis\n        assert sumTo(n - 1) == (n - 1) * n / 2;\n      }\n      n + (n - 1) * n / 2;\n      { // Algebra\n        assert n == 2 * n / 2;\n      }\n      2 * n / 2 + (n - 1) * n / 2;\n      (2 * n + (n - 1) * n) / 2;\n      (2 * n + n * n - n) / 2;\n      (n + n * n) / 2;\n      n * (1 + n) / 2;\n      n * (n + 1) / 2;\n    }\n  }\n}\n\nlemma SumOddsIsSquare(n: nat)\n  ensures sumOdds(n) == n * n\n{\n  if n == 0 {\n    // Base case\n    assert sumOdds(0) == 0;\n    assert 0 * 0 == 0;\n  } else {\n    // Inductive step\n    SumOddsIsSquare(n - 1);\n\n    calc == {\n      sumOdds(n);\n      (2 * n - 1) + sumOdds(n - 1);\n      { // Induction hypothesis\n        assert sumOdds(n - 1) == (n - 1) * (n - 1);\n      }\n      (2 * n - 1) + (n - 1) * (n - 1);\n      { // Expand (n-1)\u00b2\n        assert (n - 1) * (n - 1) == n * n - 2 * n + 1;\n      }\n      (2 * n - 1) + (n * n - 2 * n + 1);\n      2 * n - 1 + n * n - 2 * n + 1;\n      n * n;\n    }\n  }\n}\n\nlemma SumSquaresFormula(n: nat)\n  ensures sumSquares(n) == n * (n + 1) * (2 * n + 1) / 6\n{\n  if n == 0 {\n    // Base case\n    assert sumSquares(0) == 0;\n    assert 0 * (0 + 1) * (2 * 0 + 1) / 6 == 0;\n  } else {\n    // Inductive step\n    SumSquaresFormula(n - 1);\n\n    calc == {\n      sumSquares(n);\n      n * n + sumSquares(n - 1);\n      { // Induction hypothesis\n        assert sumSquares(n - 1) == (n - 1) * n * (2 * n - 1) / 6;\n      }\n      n * n + (n - 1) * n * (2 * n - 1) / 6;\n      { // Factor out common terms\n        assert n * n == 6 * n * n / 6;\n      }\n      6 * n * n / 6 + (n - 1) * n * (2 * n - 1) / 6;\n      (6 * n * n + (n - 1) * n * (2 * n - 1)) / 6;\n      { // Expand\n        assert (n - 1) * n * (2 * n - 1) == n * (n - 1) * (2 * n - 1);\n        assert n * (n - 1) * (2 * n - 1) == n * (2 * n * n - 3 * n + 1);\n        assert n * (2 * n * n - 3 * n + 1) == 2 * n * n * n - 3 * n * n + n;\n      }\n      (6 * n * n + 2 * n * n * n - 3 * n * n + n) / 6;\n      (2 * n * n * n + 3 * n * n + n) / 6;\n      n * (2 * n * n + 3 * n + 1) / 6;\n      { // Factor\n        assert 2 * n * n + 3 * n + 1 == (n + 1) * (2 * n + 1);\n      }\n      n * (n + 1) * (2 * n + 1) / 6;\n    }\n  }\n}\n\nlemma PowerOfTwo(n: nat)\n  ensures power(2, n) >= n + 1\n{\n  if n == 0 {\n    // Base case\n    assert power(2, 0) == 1;\n    assert 1 >= 0 + 1;\n  } else {\n    // Inductive step\n    PowerOfTwo(n - 1);\n\n    calc >= {\n      power(2, n);\n      2 * power(2, n - 1);\n      { // Induction hypothesis\n        assert power(2, n - 1) >= n;\n      }\n      2 * n;\n      { // Since n >= 1\n        assert n >= 1;\n        \n/*[CODE HERE]*/\n      }\n      n + 1;\n    }\n  }\n}\n\nlemma PowerMonotonic(base: nat, exp1: nat, exp2: nat)\n  requires base > 1\n  requires exp1 <= exp2\n  ensures power(base, exp1) <= power(base, exp2)\n{\n  if exp1 == exp2 {\n    // Equal case\n    assert power(base, exp1) == power(base, exp2);\n  } else {\n    // exp1 < exp2\n    assert exp1 < exp2;\n\n    if exp1 == 0 {\n      assert power(base, exp1) == 1;\n      PowerPositive(base, exp2);\n      assert power(base, exp2) >= 1;\n    } else {\n      // Both exp1 and exp2 are positive\n      PowerMonotonic(base, exp1 - 1, exp2 - 1);\n\n      calc <= {\n        power(base, exp1);\n        base * power(base, exp1 - 1);\n        { // Induction hypothesis\n          assert power(base, exp1 - 1) <= power(base, exp2 - 1);\n        }\n        base * power(base, exp2 - 1);\n        power(base, exp2);\n      }\n    }\n  }\n}\n\nlemma PowerPositive(base: nat, exp: nat)\n  requires base > 0\n  ensures power(base, exp) > 0\n{\n  if exp == 0 {\n    assert power(base, 0) == 1;\n  } else {\n    PowerPositive(base, exp - 1);\n    assert power(base, exp) == base * power(base, exp - 1);\n    assert base > 0 && power(base, exp - 1) > 0;\n  }\n}\n\nlemma FibonacciInequality(n: nat)\n  requires n >= 1\n  ensures fib(n) <= power(2, n - 1)\n{\n  if n == 1 {\n    // Base case\n    assert fib(1) == 1;\n    assert power(2, 0) == 1;\n  } else if n == 2 {\n    // Base case\n    assert fib(2) == 1;\n    assert power(2, 1) == 2;\n    assert 1 <= 2;\n  } else {\n    // Inductive step (n >= 3)\n    assert n >= 3;\n    FibonacciInequality(n - 1);\n    FibonacciInequality(n - 2);\n\n    calc <= {\n      fib(n);\n      fib(n - 1) + fib(n - 2);\n      { // Induction hypotheses\n        assert fib(n - 1) <= power(2, n - 2);\n        assert fib(n - 2) <= power(2, n - 3);\n      }\n      power(2, n - 2) + power(2, n - 3);\n      { // Factor out power(2, n - 3)\n        assert power(2, n - 2) == 2 * power(2, n - 3);\n      }\n      2 * power(2, n - 3) + power(2, n - 3);\n      3 * power(2, n - 3);\n      { // 3 * 2^(n-3) <= 4 * 2^(n-3) = 2^(n-1)\n        assert 3 <= 4;\n        assert power(2, n - 1) == 4 * power(2, n - 3);\n      }\n      power(2, n - 1);\n    }\n  }\n}\n\nlemma StrongInduction(n: nat, P: nat -> bool)\n  requires forall k :: 0 <= k < n ==> P(k)\n  requires forall m :: m >= n && (forall j :: n <= j < m ==> P(j)) ==> P(m)\n  ensures P(n)\n{\n  // This demonstrates the strong induction principle\n  // Base case: all k < n satisfy P(k) by hypothesis\n  // Inductive case: if all j in [n, m) satisfy P, then P(m) holds\n\n  // The proof would proceed by showing P(n) directly\n  // using the second hypothesis with m = n\n  assert forall j :: n <= j < n ==> P(j); // Vacuously true\n}\n\nlemma CompleteInduction(n: nat, P: nat -> bool)\n  requires P(0)\n  requires forall k: nat :: k > 0 && (forall j: nat :: j < k ==> P(j)) ==> P(k)\n  ensures P(n)\n{\n  if n == 0 {\n    // Base case\n    assert P(0);\n  } else {\n    // Need to show all j < n satisfy P(j)\n    forall j: nat | j < n\n      ensures P(j)\n    {\n      if j == 0 {\n        assert P(0);\n      } else {\n        CompleteInduction(j, P);\n      }\n    }\n\n    // Now apply the inductive hypothesis\n    assert forall j: nat :: j < n ==> P(j);\n    assert P(n);\n  }\n}", "output": "assert 2 * n >= n + 1;"}, {"id": "example_PowerOfTwo_1", "type": "assert", "program": "// Induction proofs with detailed reasoning steps\n\n// Sum of first n natural numbers\nfunction {:spec} sumTo(n: nat): nat\n{\n  if n == 0 then 0 else n + sumTo(n - 1)\n}\n\n// Sum of first n odd numbers\nfunction {:spec} sumOdds(n: nat): nat\n{\n  if n == 0 then 0 else (2 * n - 1) + sumOdds(n - 1)\n}\n\n// Sum of first n squares\nfunction {:spec} sumSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + sumSquares(n - 1)\n}\n\n// Power function\nfunction {:spec} power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\n// Fibonacci\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// --- Detailed Inductive Proofs ---\n\nlemma SumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    // Base case\n    assert sumTo(0) == 0;\n    assert 0 * (0 + 1) / 2 == 0;\n  } else {\n    // Inductive step\n    SumToFormula(n - 1);\n\n    calc == {\n      sumTo(n);\n      n + sumTo(n - 1);\n      { // Induction hypothesis\n        assert sumTo(n - 1) == (n - 1) * n / 2;\n      }\n      n + (n - 1) * n / 2;\n      { // Algebra\n        assert n == 2 * n / 2;\n      }\n      2 * n / 2 + (n - 1) * n / 2;\n      (2 * n + (n - 1) * n) / 2;\n      (2 * n + n * n - n) / 2;\n      (n + n * n) / 2;\n      n * (1 + n) / 2;\n      n * (n + 1) / 2;\n    }\n  }\n}\n\nlemma SumOddsIsSquare(n: nat)\n  ensures sumOdds(n) == n * n\n{\n  if n == 0 {\n    // Base case\n    assert sumOdds(0) == 0;\n    assert 0 * 0 == 0;\n  } else {\n    // Inductive step\n    SumOddsIsSquare(n - 1);\n\n    calc == {\n      sumOdds(n);\n      (2 * n - 1) + sumOdds(n - 1);\n      { // Induction hypothesis\n        assert sumOdds(n - 1) == (n - 1) * (n - 1);\n      }\n      (2 * n - 1) + (n - 1) * (n - 1);\n      { // Expand (n-1)\u00b2\n        assert (n - 1) * (n - 1) == n * n - 2 * n + 1;\n      }\n      (2 * n - 1) + (n * n - 2 * n + 1);\n      2 * n - 1 + n * n - 2 * n + 1;\n      n * n;\n    }\n  }\n}\n\nlemma SumSquaresFormula(n: nat)\n  ensures sumSquares(n) == n * (n + 1) * (2 * n + 1) / 6\n{\n  if n == 0 {\n    // Base case\n    assert sumSquares(0) == 0;\n    assert 0 * (0 + 1) * (2 * 0 + 1) / 6 == 0;\n  } else {\n    // Inductive step\n    SumSquaresFormula(n - 1);\n\n    calc == {\n      sumSquares(n);\n      n * n + sumSquares(n - 1);\n      { // Induction hypothesis\n        assert sumSquares(n - 1) == (n - 1) * n * (2 * n - 1) / 6;\n      }\n      n * n + (n - 1) * n * (2 * n - 1) / 6;\n      { // Factor out common terms\n        assert n * n == 6 * n * n / 6;\n      }\n      6 * n * n / 6 + (n - 1) * n * (2 * n - 1) / 6;\n      (6 * n * n + (n - 1) * n * (2 * n - 1)) / 6;\n      { // Expand\n        assert (n - 1) * n * (2 * n - 1) == n * (n - 1) * (2 * n - 1);\n        assert n * (n - 1) * (2 * n - 1) == n * (2 * n * n - 3 * n + 1);\n        assert n * (2 * n * n - 3 * n + 1) == 2 * n * n * n - 3 * n * n + n;\n      }\n      (6 * n * n + 2 * n * n * n - 3 * n * n + n) / 6;\n      (2 * n * n * n + 3 * n * n + n) / 6;\n      n * (2 * n * n + 3 * n + 1) / 6;\n      { // Factor\n        assert 2 * n * n + 3 * n + 1 == (n + 1) * (2 * n + 1);\n      }\n      n * (n + 1) * (2 * n + 1) / 6;\n    }\n  }\n}\n\nlemma PowerOfTwo(n: nat)\n  ensures power(2, n) >= n + 1\n{\n  if n == 0 {\n    // Base case\n    assert power(2, 0) == 1;\n    assert 1 >= 0 + 1;\n  } else {\n    // Inductive step\n    PowerOfTwo(n - 1);\n\n    calc >= {\n      power(2, n);\n      2 * power(2, n - 1);\n      { // Induction hypothesis\n        assert power(2, n - 1) >= n;\n      }\n      2 * n;\n      { // Since n >= 1\n        \n/*[CODE HERE]*/\n        assert 2 * n >= n + 1;\n      }\n      n + 1;\n    }\n  }\n}\n\nlemma PowerMonotonic(base: nat, exp1: nat, exp2: nat)\n  requires base > 1\n  requires exp1 <= exp2\n  ensures power(base, exp1) <= power(base, exp2)\n{\n  if exp1 == exp2 {\n    // Equal case\n    assert power(base, exp1) == power(base, exp2);\n  } else {\n    // exp1 < exp2\n    assert exp1 < exp2;\n\n    if exp1 == 0 {\n      assert power(base, exp1) == 1;\n      PowerPositive(base, exp2);\n      assert power(base, exp2) >= 1;\n    } else {\n      // Both exp1 and exp2 are positive\n      PowerMonotonic(base, exp1 - 1, exp2 - 1);\n\n      calc <= {\n        power(base, exp1);\n        base * power(base, exp1 - 1);\n        { // Induction hypothesis\n          assert power(base, exp1 - 1) <= power(base, exp2 - 1);\n        }\n        base * power(base, exp2 - 1);\n        power(base, exp2);\n      }\n    }\n  }\n}\n\nlemma PowerPositive(base: nat, exp: nat)\n  requires base > 0\n  ensures power(base, exp) > 0\n{\n  if exp == 0 {\n    assert power(base, 0) == 1;\n  } else {\n    PowerPositive(base, exp - 1);\n    assert power(base, exp) == base * power(base, exp - 1);\n    assert base > 0 && power(base, exp - 1) > 0;\n  }\n}\n\nlemma FibonacciInequality(n: nat)\n  requires n >= 1\n  ensures fib(n) <= power(2, n - 1)\n{\n  if n == 1 {\n    // Base case\n    assert fib(1) == 1;\n    assert power(2, 0) == 1;\n  } else if n == 2 {\n    // Base case\n    assert fib(2) == 1;\n    assert power(2, 1) == 2;\n    assert 1 <= 2;\n  } else {\n    // Inductive step (n >= 3)\n    assert n >= 3;\n    FibonacciInequality(n - 1);\n    FibonacciInequality(n - 2);\n\n    calc <= {\n      fib(n);\n      fib(n - 1) + fib(n - 2);\n      { // Induction hypotheses\n        assert fib(n - 1) <= power(2, n - 2);\n        assert fib(n - 2) <= power(2, n - 3);\n      }\n      power(2, n - 2) + power(2, n - 3);\n      { // Factor out power(2, n - 3)\n        assert power(2, n - 2) == 2 * power(2, n - 3);\n      }\n      2 * power(2, n - 3) + power(2, n - 3);\n      3 * power(2, n - 3);\n      { // 3 * 2^(n-3) <= 4 * 2^(n-3) = 2^(n-1)\n        assert 3 <= 4;\n        assert power(2, n - 1) == 4 * power(2, n - 3);\n      }\n      power(2, n - 1);\n    }\n  }\n}\n\nlemma StrongInduction(n: nat, P: nat -> bool)\n  requires forall k :: 0 <= k < n ==> P(k)\n  requires forall m :: m >= n && (forall j :: n <= j < m ==> P(j)) ==> P(m)\n  ensures P(n)\n{\n  // This demonstrates the strong induction principle\n  // Base case: all k < n satisfy P(k) by hypothesis\n  // Inductive case: if all j in [n, m) satisfy P, then P(m) holds\n\n  // The proof would proceed by showing P(n) directly\n  // using the second hypothesis with m = n\n  assert forall j :: n <= j < n ==> P(j); // Vacuously true\n}\n\nlemma CompleteInduction(n: nat, P: nat -> bool)\n  requires P(0)\n  requires forall k: nat :: k > 0 && (forall j: nat :: j < k ==> P(j)) ==> P(k)\n  ensures P(n)\n{\n  if n == 0 {\n    // Base case\n    assert P(0);\n  } else {\n    // Need to show all j < n satisfy P(j)\n    forall j: nat | j < n\n      ensures P(j)\n    {\n      if j == 0 {\n        assert P(0);\n      } else {\n        CompleteInduction(j, P);\n      }\n    }\n\n    // Now apply the inductive hypothesis\n    assert forall j: nat :: j < n ==> P(j);\n    assert P(n);\n  }\n}", "output": "assert n >= 1;"}, {"id": "example_PowerOfTwo_2", "type": "assert", "program": "// Induction proofs with detailed reasoning steps\n\n// Sum of first n natural numbers\nfunction {:spec} sumTo(n: nat): nat\n{\n  if n == 0 then 0 else n + sumTo(n - 1)\n}\n\n// Sum of first n odd numbers\nfunction {:spec} sumOdds(n: nat): nat\n{\n  if n == 0 then 0 else (2 * n - 1) + sumOdds(n - 1)\n}\n\n// Sum of first n squares\nfunction {:spec} sumSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + sumSquares(n - 1)\n}\n\n// Power function\nfunction {:spec} power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\n// Fibonacci\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// --- Detailed Inductive Proofs ---\n\nlemma SumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    // Base case\n    assert sumTo(0) == 0;\n    assert 0 * (0 + 1) / 2 == 0;\n  } else {\n    // Inductive step\n    SumToFormula(n - 1);\n\n    calc == {\n      sumTo(n);\n      n + sumTo(n - 1);\n      { // Induction hypothesis\n        assert sumTo(n - 1) == (n - 1) * n / 2;\n      }\n      n + (n - 1) * n / 2;\n      { // Algebra\n        assert n == 2 * n / 2;\n      }\n      2 * n / 2 + (n - 1) * n / 2;\n      (2 * n + (n - 1) * n) / 2;\n      (2 * n + n * n - n) / 2;\n      (n + n * n) / 2;\n      n * (1 + n) / 2;\n      n * (n + 1) / 2;\n    }\n  }\n}\n\nlemma SumOddsIsSquare(n: nat)\n  ensures sumOdds(n) == n * n\n{\n  if n == 0 {\n    // Base case\n    assert sumOdds(0) == 0;\n    assert 0 * 0 == 0;\n  } else {\n    // Inductive step\n    SumOddsIsSquare(n - 1);\n\n    calc == {\n      sumOdds(n);\n      (2 * n - 1) + sumOdds(n - 1);\n      { // Induction hypothesis\n        assert sumOdds(n - 1) == (n - 1) * (n - 1);\n      }\n      (2 * n - 1) + (n - 1) * (n - 1);\n      { // Expand (n-1)\u00b2\n        assert (n - 1) * (n - 1) == n * n - 2 * n + 1;\n      }\n      (2 * n - 1) + (n * n - 2 * n + 1);\n      2 * n - 1 + n * n - 2 * n + 1;\n      n * n;\n    }\n  }\n}\n\nlemma SumSquaresFormula(n: nat)\n  ensures sumSquares(n) == n * (n + 1) * (2 * n + 1) / 6\n{\n  if n == 0 {\n    // Base case\n    assert sumSquares(0) == 0;\n    assert 0 * (0 + 1) * (2 * 0 + 1) / 6 == 0;\n  } else {\n    // Inductive step\n    SumSquaresFormula(n - 1);\n\n    calc == {\n      sumSquares(n);\n      n * n + sumSquares(n - 1);\n      { // Induction hypothesis\n        assert sumSquares(n - 1) == (n - 1) * n * (2 * n - 1) / 6;\n      }\n      n * n + (n - 1) * n * (2 * n - 1) / 6;\n      { // Factor out common terms\n        assert n * n == 6 * n * n / 6;\n      }\n      6 * n * n / 6 + (n - 1) * n * (2 * n - 1) / 6;\n      (6 * n * n + (n - 1) * n * (2 * n - 1)) / 6;\n      { // Expand\n        assert (n - 1) * n * (2 * n - 1) == n * (n - 1) * (2 * n - 1);\n        assert n * (n - 1) * (2 * n - 1) == n * (2 * n * n - 3 * n + 1);\n        assert n * (2 * n * n - 3 * n + 1) == 2 * n * n * n - 3 * n * n + n;\n      }\n      (6 * n * n + 2 * n * n * n - 3 * n * n + n) / 6;\n      (2 * n * n * n + 3 * n * n + n) / 6;\n      n * (2 * n * n + 3 * n + 1) / 6;\n      { // Factor\n        assert 2 * n * n + 3 * n + 1 == (n + 1) * (2 * n + 1);\n      }\n      n * (n + 1) * (2 * n + 1) / 6;\n    }\n  }\n}\n\nlemma PowerOfTwo(n: nat)\n  ensures power(2, n) >= n + 1\n{\n  if n == 0 {\n    // Base case\n    assert power(2, 0) == 1;\n    assert 1 >= 0 + 1;\n  } else {\n    // Inductive step\n    PowerOfTwo(n - 1);\n\n    calc >= {\n      power(2, n);\n      2 * power(2, n - 1);\n      { // Induction hypothesis\n        \n/*[CODE HERE]*/\n      }\n      2 * n;\n      { // Since n >= 1\n        assert n >= 1;\n        assert 2 * n >= n + 1;\n      }\n      n + 1;\n    }\n  }\n}\n\nlemma PowerMonotonic(base: nat, exp1: nat, exp2: nat)\n  requires base > 1\n  requires exp1 <= exp2\n  ensures power(base, exp1) <= power(base, exp2)\n{\n  if exp1 == exp2 {\n    // Equal case\n    assert power(base, exp1) == power(base, exp2);\n  } else {\n    // exp1 < exp2\n    assert exp1 < exp2;\n\n    if exp1 == 0 {\n      assert power(base, exp1) == 1;\n      PowerPositive(base, exp2);\n      assert power(base, exp2) >= 1;\n    } else {\n      // Both exp1 and exp2 are positive\n      PowerMonotonic(base, exp1 - 1, exp2 - 1);\n\n      calc <= {\n        power(base, exp1);\n        base * power(base, exp1 - 1);\n        { // Induction hypothesis\n          assert power(base, exp1 - 1) <= power(base, exp2 - 1);\n        }\n        base * power(base, exp2 - 1);\n        power(base, exp2);\n      }\n    }\n  }\n}\n\nlemma PowerPositive(base: nat, exp: nat)\n  requires base > 0\n  ensures power(base, exp) > 0\n{\n  if exp == 0 {\n    assert power(base, 0) == 1;\n  } else {\n    PowerPositive(base, exp - 1);\n    assert power(base, exp) == base * power(base, exp - 1);\n    assert base > 0 && power(base, exp - 1) > 0;\n  }\n}\n\nlemma FibonacciInequality(n: nat)\n  requires n >= 1\n  ensures fib(n) <= power(2, n - 1)\n{\n  if n == 1 {\n    // Base case\n    assert fib(1) == 1;\n    assert power(2, 0) == 1;\n  } else if n == 2 {\n    // Base case\n    assert fib(2) == 1;\n    assert power(2, 1) == 2;\n    assert 1 <= 2;\n  } else {\n    // Inductive step (n >= 3)\n    assert n >= 3;\n    FibonacciInequality(n - 1);\n    FibonacciInequality(n - 2);\n\n    calc <= {\n      fib(n);\n      fib(n - 1) + fib(n - 2);\n      { // Induction hypotheses\n        assert fib(n - 1) <= power(2, n - 2);\n        assert fib(n - 2) <= power(2, n - 3);\n      }\n      power(2, n - 2) + power(2, n - 3);\n      { // Factor out power(2, n - 3)\n        assert power(2, n - 2) == 2 * power(2, n - 3);\n      }\n      2 * power(2, n - 3) + power(2, n - 3);\n      3 * power(2, n - 3);\n      { // 3 * 2^(n-3) <= 4 * 2^(n-3) = 2^(n-1)\n        assert 3 <= 4;\n        assert power(2, n - 1) == 4 * power(2, n - 3);\n      }\n      power(2, n - 1);\n    }\n  }\n}\n\nlemma StrongInduction(n: nat, P: nat -> bool)\n  requires forall k :: 0 <= k < n ==> P(k)\n  requires forall m :: m >= n && (forall j :: n <= j < m ==> P(j)) ==> P(m)\n  ensures P(n)\n{\n  // This demonstrates the strong induction principle\n  // Base case: all k < n satisfy P(k) by hypothesis\n  // Inductive case: if all j in [n, m) satisfy P, then P(m) holds\n\n  // The proof would proceed by showing P(n) directly\n  // using the second hypothesis with m = n\n  assert forall j :: n <= j < n ==> P(j); // Vacuously true\n}\n\nlemma CompleteInduction(n: nat, P: nat -> bool)\n  requires P(0)\n  requires forall k: nat :: k > 0 && (forall j: nat :: j < k ==> P(j)) ==> P(k)\n  ensures P(n)\n{\n  if n == 0 {\n    // Base case\n    assert P(0);\n  } else {\n    // Need to show all j < n satisfy P(j)\n    forall j: nat | j < n\n      ensures P(j)\n    {\n      if j == 0 {\n        assert P(0);\n      } else {\n        CompleteInduction(j, P);\n      }\n    }\n\n    // Now apply the inductive hypothesis\n    assert forall j: nat :: j < n ==> P(j);\n    assert P(n);\n  }\n}", "output": "assert power(2, n - 1) >= n;"}, {"id": "example_PowerOfTwo_3", "type": "call", "program": "// Induction proofs with detailed reasoning steps\n\n// Sum of first n natural numbers\nfunction {:spec} sumTo(n: nat): nat\n{\n  if n == 0 then 0 else n + sumTo(n - 1)\n}\n\n// Sum of first n odd numbers\nfunction {:spec} sumOdds(n: nat): nat\n{\n  if n == 0 then 0 else (2 * n - 1) + sumOdds(n - 1)\n}\n\n// Sum of first n squares\nfunction {:spec} sumSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + sumSquares(n - 1)\n}\n\n// Power function\nfunction {:spec} power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\n// Fibonacci\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// --- Detailed Inductive Proofs ---\n\nlemma SumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    // Base case\n    assert sumTo(0) == 0;\n    assert 0 * (0 + 1) / 2 == 0;\n  } else {\n    // Inductive step\n    SumToFormula(n - 1);\n\n    calc == {\n      sumTo(n);\n      n + sumTo(n - 1);\n      { // Induction hypothesis\n        assert sumTo(n - 1) == (n - 1) * n / 2;\n      }\n      n + (n - 1) * n / 2;\n      { // Algebra\n        assert n == 2 * n / 2;\n      }\n      2 * n / 2 + (n - 1) * n / 2;\n      (2 * n + (n - 1) * n) / 2;\n      (2 * n + n * n - n) / 2;\n      (n + n * n) / 2;\n      n * (1 + n) / 2;\n      n * (n + 1) / 2;\n    }\n  }\n}\n\nlemma SumOddsIsSquare(n: nat)\n  ensures sumOdds(n) == n * n\n{\n  if n == 0 {\n    // Base case\n    assert sumOdds(0) == 0;\n    assert 0 * 0 == 0;\n  } else {\n    // Inductive step\n    SumOddsIsSquare(n - 1);\n\n    calc == {\n      sumOdds(n);\n      (2 * n - 1) + sumOdds(n - 1);\n      { // Induction hypothesis\n        assert sumOdds(n - 1) == (n - 1) * (n - 1);\n      }\n      (2 * n - 1) + (n - 1) * (n - 1);\n      { // Expand (n-1)\u00b2\n        assert (n - 1) * (n - 1) == n * n - 2 * n + 1;\n      }\n      (2 * n - 1) + (n * n - 2 * n + 1);\n      2 * n - 1 + n * n - 2 * n + 1;\n      n * n;\n    }\n  }\n}\n\nlemma SumSquaresFormula(n: nat)\n  ensures sumSquares(n) == n * (n + 1) * (2 * n + 1) / 6\n{\n  if n == 0 {\n    // Base case\n    assert sumSquares(0) == 0;\n    assert 0 * (0 + 1) * (2 * 0 + 1) / 6 == 0;\n  } else {\n    // Inductive step\n    SumSquaresFormula(n - 1);\n\n    calc == {\n      sumSquares(n);\n      n * n + sumSquares(n - 1);\n      { // Induction hypothesis\n        assert sumSquares(n - 1) == (n - 1) * n * (2 * n - 1) / 6;\n      }\n      n * n + (n - 1) * n * (2 * n - 1) / 6;\n      { // Factor out common terms\n        assert n * n == 6 * n * n / 6;\n      }\n      6 * n * n / 6 + (n - 1) * n * (2 * n - 1) / 6;\n      (6 * n * n + (n - 1) * n * (2 * n - 1)) / 6;\n      { // Expand\n        assert (n - 1) * n * (2 * n - 1) == n * (n - 1) * (2 * n - 1);\n        assert n * (n - 1) * (2 * n - 1) == n * (2 * n * n - 3 * n + 1);\n        assert n * (2 * n * n - 3 * n + 1) == 2 * n * n * n - 3 * n * n + n;\n      }\n      (6 * n * n + 2 * n * n * n - 3 * n * n + n) / 6;\n      (2 * n * n * n + 3 * n * n + n) / 6;\n      n * (2 * n * n + 3 * n + 1) / 6;\n      { // Factor\n        assert 2 * n * n + 3 * n + 1 == (n + 1) * (2 * n + 1);\n      }\n      n * (n + 1) * (2 * n + 1) / 6;\n    }\n  }\n}\n\nlemma PowerOfTwo(n: nat)\n  ensures power(2, n) >= n + 1\n{\n  if n == 0 {\n    // Base case\n    assert power(2, 0) == 1;\n    assert 1 >= 0 + 1;\n  } else {\n    // Inductive step\n    \n/*[CODE HERE]*/\n\n    calc >= {\n      power(2, n);\n      2 * power(2, n - 1);\n      { // Induction hypothesis\n        assert power(2, n - 1) >= n;\n      }\n      2 * n;\n      { // Since n >= 1\n        assert n >= 1;\n        assert 2 * n >= n + 1;\n      }\n      n + 1;\n    }\n  }\n}\n\nlemma PowerMonotonic(base: nat, exp1: nat, exp2: nat)\n  requires base > 1\n  requires exp1 <= exp2\n  ensures power(base, exp1) <= power(base, exp2)\n{\n  if exp1 == exp2 {\n    // Equal case\n    assert power(base, exp1) == power(base, exp2);\n  } else {\n    // exp1 < exp2\n    assert exp1 < exp2;\n\n    if exp1 == 0 {\n      assert power(base, exp1) == 1;\n      PowerPositive(base, exp2);\n      assert power(base, exp2) >= 1;\n    } else {\n      // Both exp1 and exp2 are positive\n      PowerMonotonic(base, exp1 - 1, exp2 - 1);\n\n      calc <= {\n        power(base, exp1);\n        base * power(base, exp1 - 1);\n        { // Induction hypothesis\n          assert power(base, exp1 - 1) <= power(base, exp2 - 1);\n        }\n        base * power(base, exp2 - 1);\n        power(base, exp2);\n      }\n    }\n  }\n}\n\nlemma PowerPositive(base: nat, exp: nat)\n  requires base > 0\n  ensures power(base, exp) > 0\n{\n  if exp == 0 {\n    assert power(base, 0) == 1;\n  } else {\n    PowerPositive(base, exp - 1);\n    assert power(base, exp) == base * power(base, exp - 1);\n    assert base > 0 && power(base, exp - 1) > 0;\n  }\n}\n\nlemma FibonacciInequality(n: nat)\n  requires n >= 1\n  ensures fib(n) <= power(2, n - 1)\n{\n  if n == 1 {\n    // Base case\n    assert fib(1) == 1;\n    assert power(2, 0) == 1;\n  } else if n == 2 {\n    // Base case\n    assert fib(2) == 1;\n    assert power(2, 1) == 2;\n    assert 1 <= 2;\n  } else {\n    // Inductive step (n >= 3)\n    assert n >= 3;\n    FibonacciInequality(n - 1);\n    FibonacciInequality(n - 2);\n\n    calc <= {\n      fib(n);\n      fib(n - 1) + fib(n - 2);\n      { // Induction hypotheses\n        assert fib(n - 1) <= power(2, n - 2);\n        assert fib(n - 2) <= power(2, n - 3);\n      }\n      power(2, n - 2) + power(2, n - 3);\n      { // Factor out power(2, n - 3)\n        assert power(2, n - 2) == 2 * power(2, n - 3);\n      }\n      2 * power(2, n - 3) + power(2, n - 3);\n      3 * power(2, n - 3);\n      { // 3 * 2^(n-3) <= 4 * 2^(n-3) = 2^(n-1)\n        assert 3 <= 4;\n        assert power(2, n - 1) == 4 * power(2, n - 3);\n      }\n      power(2, n - 1);\n    }\n  }\n}\n\nlemma StrongInduction(n: nat, P: nat -> bool)\n  requires forall k :: 0 <= k < n ==> P(k)\n  requires forall m :: m >= n && (forall j :: n <= j < m ==> P(j)) ==> P(m)\n  ensures P(n)\n{\n  // This demonstrates the strong induction principle\n  // Base case: all k < n satisfy P(k) by hypothesis\n  // Inductive case: if all j in [n, m) satisfy P, then P(m) holds\n\n  // The proof would proceed by showing P(n) directly\n  // using the second hypothesis with m = n\n  assert forall j :: n <= j < n ==> P(j); // Vacuously true\n}\n\nlemma CompleteInduction(n: nat, P: nat -> bool)\n  requires P(0)\n  requires forall k: nat :: k > 0 && (forall j: nat :: j < k ==> P(j)) ==> P(k)\n  ensures P(n)\n{\n  if n == 0 {\n    // Base case\n    assert P(0);\n  } else {\n    // Need to show all j < n satisfy P(j)\n    forall j: nat | j < n\n      ensures P(j)\n    {\n      if j == 0 {\n        assert P(0);\n      } else {\n        CompleteInduction(j, P);\n      }\n    }\n\n    // Now apply the inductive hypothesis\n    assert forall j: nat :: j < n ==> P(j);\n    assert P(n);\n  }\n}", "output": "PowerOfTwo(n - 1);"}, {"id": "example_PowerOfTwo_4", "type": "assert", "program": "// Induction proofs with detailed reasoning steps\n\n// Sum of first n natural numbers\nfunction {:spec} sumTo(n: nat): nat\n{\n  if n == 0 then 0 else n + sumTo(n - 1)\n}\n\n// Sum of first n odd numbers\nfunction {:spec} sumOdds(n: nat): nat\n{\n  if n == 0 then 0 else (2 * n - 1) + sumOdds(n - 1)\n}\n\n// Sum of first n squares\nfunction {:spec} sumSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + sumSquares(n - 1)\n}\n\n// Power function\nfunction {:spec} power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\n// Fibonacci\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// --- Detailed Inductive Proofs ---\n\nlemma SumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    // Base case\n    assert sumTo(0) == 0;\n    assert 0 * (0 + 1) / 2 == 0;\n  } else {\n    // Inductive step\n    SumToFormula(n - 1);\n\n    calc == {\n      sumTo(n);\n      n + sumTo(n - 1);\n      { // Induction hypothesis\n        assert sumTo(n - 1) == (n - 1) * n / 2;\n      }\n      n + (n - 1) * n / 2;\n      { // Algebra\n        assert n == 2 * n / 2;\n      }\n      2 * n / 2 + (n - 1) * n / 2;\n      (2 * n + (n - 1) * n) / 2;\n      (2 * n + n * n - n) / 2;\n      (n + n * n) / 2;\n      n * (1 + n) / 2;\n      n * (n + 1) / 2;\n    }\n  }\n}\n\nlemma SumOddsIsSquare(n: nat)\n  ensures sumOdds(n) == n * n\n{\n  if n == 0 {\n    // Base case\n    assert sumOdds(0) == 0;\n    assert 0 * 0 == 0;\n  } else {\n    // Inductive step\n    SumOddsIsSquare(n - 1);\n\n    calc == {\n      sumOdds(n);\n      (2 * n - 1) + sumOdds(n - 1);\n      { // Induction hypothesis\n        assert sumOdds(n - 1) == (n - 1) * (n - 1);\n      }\n      (2 * n - 1) + (n - 1) * (n - 1);\n      { // Expand (n-1)\u00b2\n        assert (n - 1) * (n - 1) == n * n - 2 * n + 1;\n      }\n      (2 * n - 1) + (n * n - 2 * n + 1);\n      2 * n - 1 + n * n - 2 * n + 1;\n      n * n;\n    }\n  }\n}\n\nlemma SumSquaresFormula(n: nat)\n  ensures sumSquares(n) == n * (n + 1) * (2 * n + 1) / 6\n{\n  if n == 0 {\n    // Base case\n    assert sumSquares(0) == 0;\n    assert 0 * (0 + 1) * (2 * 0 + 1) / 6 == 0;\n  } else {\n    // Inductive step\n    SumSquaresFormula(n - 1);\n\n    calc == {\n      sumSquares(n);\n      n * n + sumSquares(n - 1);\n      { // Induction hypothesis\n        assert sumSquares(n - 1) == (n - 1) * n * (2 * n - 1) / 6;\n      }\n      n * n + (n - 1) * n * (2 * n - 1) / 6;\n      { // Factor out common terms\n        assert n * n == 6 * n * n / 6;\n      }\n      6 * n * n / 6 + (n - 1) * n * (2 * n - 1) / 6;\n      (6 * n * n + (n - 1) * n * (2 * n - 1)) / 6;\n      { // Expand\n        assert (n - 1) * n * (2 * n - 1) == n * (n - 1) * (2 * n - 1);\n        assert n * (n - 1) * (2 * n - 1) == n * (2 * n * n - 3 * n + 1);\n        assert n * (2 * n * n - 3 * n + 1) == 2 * n * n * n - 3 * n * n + n;\n      }\n      (6 * n * n + 2 * n * n * n - 3 * n * n + n) / 6;\n      (2 * n * n * n + 3 * n * n + n) / 6;\n      n * (2 * n * n + 3 * n + 1) / 6;\n      { // Factor\n        assert 2 * n * n + 3 * n + 1 == (n + 1) * (2 * n + 1);\n      }\n      n * (n + 1) * (2 * n + 1) / 6;\n    }\n  }\n}\n\nlemma PowerOfTwo(n: nat)\n  ensures power(2, n) >= n + 1\n{\n  if n == 0 {\n    // Base case\n    assert power(2, 0) == 1;\n    \n/*[CODE HERE]*/\n  } else {\n    // Inductive step\n    PowerOfTwo(n - 1);\n\n    calc >= {\n      power(2, n);\n      2 * power(2, n - 1);\n      { // Induction hypothesis\n        assert power(2, n - 1) >= n;\n      }\n      2 * n;\n      { // Since n >= 1\n        assert n >= 1;\n        assert 2 * n >= n + 1;\n      }\n      n + 1;\n    }\n  }\n}\n\nlemma PowerMonotonic(base: nat, exp1: nat, exp2: nat)\n  requires base > 1\n  requires exp1 <= exp2\n  ensures power(base, exp1) <= power(base, exp2)\n{\n  if exp1 == exp2 {\n    // Equal case\n    assert power(base, exp1) == power(base, exp2);\n  } else {\n    // exp1 < exp2\n    assert exp1 < exp2;\n\n    if exp1 == 0 {\n      assert power(base, exp1) == 1;\n      PowerPositive(base, exp2);\n      assert power(base, exp2) >= 1;\n    } else {\n      // Both exp1 and exp2 are positive\n      PowerMonotonic(base, exp1 - 1, exp2 - 1);\n\n      calc <= {\n        power(base, exp1);\n        base * power(base, exp1 - 1);\n        { // Induction hypothesis\n          assert power(base, exp1 - 1) <= power(base, exp2 - 1);\n        }\n        base * power(base, exp2 - 1);\n        power(base, exp2);\n      }\n    }\n  }\n}\n\nlemma PowerPositive(base: nat, exp: nat)\n  requires base > 0\n  ensures power(base, exp) > 0\n{\n  if exp == 0 {\n    assert power(base, 0) == 1;\n  } else {\n    PowerPositive(base, exp - 1);\n    assert power(base, exp) == base * power(base, exp - 1);\n    assert base > 0 && power(base, exp - 1) > 0;\n  }\n}\n\nlemma FibonacciInequality(n: nat)\n  requires n >= 1\n  ensures fib(n) <= power(2, n - 1)\n{\n  if n == 1 {\n    // Base case\n    assert fib(1) == 1;\n    assert power(2, 0) == 1;\n  } else if n == 2 {\n    // Base case\n    assert fib(2) == 1;\n    assert power(2, 1) == 2;\n    assert 1 <= 2;\n  } else {\n    // Inductive step (n >= 3)\n    assert n >= 3;\n    FibonacciInequality(n - 1);\n    FibonacciInequality(n - 2);\n\n    calc <= {\n      fib(n);\n      fib(n - 1) + fib(n - 2);\n      { // Induction hypotheses\n        assert fib(n - 1) <= power(2, n - 2);\n        assert fib(n - 2) <= power(2, n - 3);\n      }\n      power(2, n - 2) + power(2, n - 3);\n      { // Factor out power(2, n - 3)\n        assert power(2, n - 2) == 2 * power(2, n - 3);\n      }\n      2 * power(2, n - 3) + power(2, n - 3);\n      3 * power(2, n - 3);\n      { // 3 * 2^(n-3) <= 4 * 2^(n-3) = 2^(n-1)\n        assert 3 <= 4;\n        assert power(2, n - 1) == 4 * power(2, n - 3);\n      }\n      power(2, n - 1);\n    }\n  }\n}\n\nlemma StrongInduction(n: nat, P: nat -> bool)\n  requires forall k :: 0 <= k < n ==> P(k)\n  requires forall m :: m >= n && (forall j :: n <= j < m ==> P(j)) ==> P(m)\n  ensures P(n)\n{\n  // This demonstrates the strong induction principle\n  // Base case: all k < n satisfy P(k) by hypothesis\n  // Inductive case: if all j in [n, m) satisfy P, then P(m) holds\n\n  // The proof would proceed by showing P(n) directly\n  // using the second hypothesis with m = n\n  assert forall j :: n <= j < n ==> P(j); // Vacuously true\n}\n\nlemma CompleteInduction(n: nat, P: nat -> bool)\n  requires P(0)\n  requires forall k: nat :: k > 0 && (forall j: nat :: j < k ==> P(j)) ==> P(k)\n  ensures P(n)\n{\n  if n == 0 {\n    // Base case\n    assert P(0);\n  } else {\n    // Need to show all j < n satisfy P(j)\n    forall j: nat | j < n\n      ensures P(j)\n    {\n      if j == 0 {\n        assert P(0);\n      } else {\n        CompleteInduction(j, P);\n      }\n    }\n\n    // Now apply the inductive hypothesis\n    assert forall j: nat :: j < n ==> P(j);\n    assert P(n);\n  }\n}", "output": "assert 1 >= 0 + 1;"}, {"id": "example_PowerOfTwo_5", "type": "assert", "program": "// Induction proofs with detailed reasoning steps\n\n// Sum of first n natural numbers\nfunction {:spec} sumTo(n: nat): nat\n{\n  if n == 0 then 0 else n + sumTo(n - 1)\n}\n\n// Sum of first n odd numbers\nfunction {:spec} sumOdds(n: nat): nat\n{\n  if n == 0 then 0 else (2 * n - 1) + sumOdds(n - 1)\n}\n\n// Sum of first n squares\nfunction {:spec} sumSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + sumSquares(n - 1)\n}\n\n// Power function\nfunction {:spec} power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\n// Fibonacci\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// --- Detailed Inductive Proofs ---\n\nlemma SumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    // Base case\n    assert sumTo(0) == 0;\n    assert 0 * (0 + 1) / 2 == 0;\n  } else {\n    // Inductive step\n    SumToFormula(n - 1);\n\n    calc == {\n      sumTo(n);\n      n + sumTo(n - 1);\n      { // Induction hypothesis\n        assert sumTo(n - 1) == (n - 1) * n / 2;\n      }\n      n + (n - 1) * n / 2;\n      { // Algebra\n        assert n == 2 * n / 2;\n      }\n      2 * n / 2 + (n - 1) * n / 2;\n      (2 * n + (n - 1) * n) / 2;\n      (2 * n + n * n - n) / 2;\n      (n + n * n) / 2;\n      n * (1 + n) / 2;\n      n * (n + 1) / 2;\n    }\n  }\n}\n\nlemma SumOddsIsSquare(n: nat)\n  ensures sumOdds(n) == n * n\n{\n  if n == 0 {\n    // Base case\n    assert sumOdds(0) == 0;\n    assert 0 * 0 == 0;\n  } else {\n    // Inductive step\n    SumOddsIsSquare(n - 1);\n\n    calc == {\n      sumOdds(n);\n      (2 * n - 1) + sumOdds(n - 1);\n      { // Induction hypothesis\n        assert sumOdds(n - 1) == (n - 1) * (n - 1);\n      }\n      (2 * n - 1) + (n - 1) * (n - 1);\n      { // Expand (n-1)\u00b2\n        assert (n - 1) * (n - 1) == n * n - 2 * n + 1;\n      }\n      (2 * n - 1) + (n * n - 2 * n + 1);\n      2 * n - 1 + n * n - 2 * n + 1;\n      n * n;\n    }\n  }\n}\n\nlemma SumSquaresFormula(n: nat)\n  ensures sumSquares(n) == n * (n + 1) * (2 * n + 1) / 6\n{\n  if n == 0 {\n    // Base case\n    assert sumSquares(0) == 0;\n    assert 0 * (0 + 1) * (2 * 0 + 1) / 6 == 0;\n  } else {\n    // Inductive step\n    SumSquaresFormula(n - 1);\n\n    calc == {\n      sumSquares(n);\n      n * n + sumSquares(n - 1);\n      { // Induction hypothesis\n        assert sumSquares(n - 1) == (n - 1) * n * (2 * n - 1) / 6;\n      }\n      n * n + (n - 1) * n * (2 * n - 1) / 6;\n      { // Factor out common terms\n        assert n * n == 6 * n * n / 6;\n      }\n      6 * n * n / 6 + (n - 1) * n * (2 * n - 1) / 6;\n      (6 * n * n + (n - 1) * n * (2 * n - 1)) / 6;\n      { // Expand\n        assert (n - 1) * n * (2 * n - 1) == n * (n - 1) * (2 * n - 1);\n        assert n * (n - 1) * (2 * n - 1) == n * (2 * n * n - 3 * n + 1);\n        assert n * (2 * n * n - 3 * n + 1) == 2 * n * n * n - 3 * n * n + n;\n      }\n      (6 * n * n + 2 * n * n * n - 3 * n * n + n) / 6;\n      (2 * n * n * n + 3 * n * n + n) / 6;\n      n * (2 * n * n + 3 * n + 1) / 6;\n      { // Factor\n        assert 2 * n * n + 3 * n + 1 == (n + 1) * (2 * n + 1);\n      }\n      n * (n + 1) * (2 * n + 1) / 6;\n    }\n  }\n}\n\nlemma PowerOfTwo(n: nat)\n  ensures power(2, n) >= n + 1\n{\n  if n == 0 {\n    // Base case\n    \n/*[CODE HERE]*/\n    assert 1 >= 0 + 1;\n  } else {\n    // Inductive step\n    PowerOfTwo(n - 1);\n\n    calc >= {\n      power(2, n);\n      2 * power(2, n - 1);\n      { // Induction hypothesis\n        assert power(2, n - 1) >= n;\n      }\n      2 * n;\n      { // Since n >= 1\n        assert n >= 1;\n        assert 2 * n >= n + 1;\n      }\n      n + 1;\n    }\n  }\n}\n\nlemma PowerMonotonic(base: nat, exp1: nat, exp2: nat)\n  requires base > 1\n  requires exp1 <= exp2\n  ensures power(base, exp1) <= power(base, exp2)\n{\n  if exp1 == exp2 {\n    // Equal case\n    assert power(base, exp1) == power(base, exp2);\n  } else {\n    // exp1 < exp2\n    assert exp1 < exp2;\n\n    if exp1 == 0 {\n      assert power(base, exp1) == 1;\n      PowerPositive(base, exp2);\n      assert power(base, exp2) >= 1;\n    } else {\n      // Both exp1 and exp2 are positive\n      PowerMonotonic(base, exp1 - 1, exp2 - 1);\n\n      calc <= {\n        power(base, exp1);\n        base * power(base, exp1 - 1);\n        { // Induction hypothesis\n          assert power(base, exp1 - 1) <= power(base, exp2 - 1);\n        }\n        base * power(base, exp2 - 1);\n        power(base, exp2);\n      }\n    }\n  }\n}\n\nlemma PowerPositive(base: nat, exp: nat)\n  requires base > 0\n  ensures power(base, exp) > 0\n{\n  if exp == 0 {\n    assert power(base, 0) == 1;\n  } else {\n    PowerPositive(base, exp - 1);\n    assert power(base, exp) == base * power(base, exp - 1);\n    assert base > 0 && power(base, exp - 1) > 0;\n  }\n}\n\nlemma FibonacciInequality(n: nat)\n  requires n >= 1\n  ensures fib(n) <= power(2, n - 1)\n{\n  if n == 1 {\n    // Base case\n    assert fib(1) == 1;\n    assert power(2, 0) == 1;\n  } else if n == 2 {\n    // Base case\n    assert fib(2) == 1;\n    assert power(2, 1) == 2;\n    assert 1 <= 2;\n  } else {\n    // Inductive step (n >= 3)\n    assert n >= 3;\n    FibonacciInequality(n - 1);\n    FibonacciInequality(n - 2);\n\n    calc <= {\n      fib(n);\n      fib(n - 1) + fib(n - 2);\n      { // Induction hypotheses\n        assert fib(n - 1) <= power(2, n - 2);\n        assert fib(n - 2) <= power(2, n - 3);\n      }\n      power(2, n - 2) + power(2, n - 3);\n      { // Factor out power(2, n - 3)\n        assert power(2, n - 2) == 2 * power(2, n - 3);\n      }\n      2 * power(2, n - 3) + power(2, n - 3);\n      3 * power(2, n - 3);\n      { // 3 * 2^(n-3) <= 4 * 2^(n-3) = 2^(n-1)\n        assert 3 <= 4;\n        assert power(2, n - 1) == 4 * power(2, n - 3);\n      }\n      power(2, n - 1);\n    }\n  }\n}\n\nlemma StrongInduction(n: nat, P: nat -> bool)\n  requires forall k :: 0 <= k < n ==> P(k)\n  requires forall m :: m >= n && (forall j :: n <= j < m ==> P(j)) ==> P(m)\n  ensures P(n)\n{\n  // This demonstrates the strong induction principle\n  // Base case: all k < n satisfy P(k) by hypothesis\n  // Inductive case: if all j in [n, m) satisfy P, then P(m) holds\n\n  // The proof would proceed by showing P(n) directly\n  // using the second hypothesis with m = n\n  assert forall j :: n <= j < n ==> P(j); // Vacuously true\n}\n\nlemma CompleteInduction(n: nat, P: nat -> bool)\n  requires P(0)\n  requires forall k: nat :: k > 0 && (forall j: nat :: j < k ==> P(j)) ==> P(k)\n  ensures P(n)\n{\n  if n == 0 {\n    // Base case\n    assert P(0);\n  } else {\n    // Need to show all j < n satisfy P(j)\n    forall j: nat | j < n\n      ensures P(j)\n    {\n      if j == 0 {\n        assert P(0);\n      } else {\n        CompleteInduction(j, P);\n      }\n    }\n\n    // Now apply the inductive hypothesis\n    assert forall j: nat :: j < n ==> P(j);\n    assert P(n);\n  }\n}", "output": "assert power(2, 0) == 1;"}, {"id": "example_PowerMonotonic_0", "type": "assert", "program": "// Induction proofs with detailed reasoning steps\n\n// Sum of first n natural numbers\nfunction {:spec} sumTo(n: nat): nat\n{\n  if n == 0 then 0 else n + sumTo(n - 1)\n}\n\n// Sum of first n odd numbers\nfunction {:spec} sumOdds(n: nat): nat\n{\n  if n == 0 then 0 else (2 * n - 1) + sumOdds(n - 1)\n}\n\n// Sum of first n squares\nfunction {:spec} sumSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + sumSquares(n - 1)\n}\n\n// Power function\nfunction {:spec} power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\n// Fibonacci\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// --- Detailed Inductive Proofs ---\n\nlemma SumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    // Base case\n    assert sumTo(0) == 0;\n    assert 0 * (0 + 1) / 2 == 0;\n  } else {\n    // Inductive step\n    SumToFormula(n - 1);\n\n    calc == {\n      sumTo(n);\n      n + sumTo(n - 1);\n      { // Induction hypothesis\n        assert sumTo(n - 1) == (n - 1) * n / 2;\n      }\n      n + (n - 1) * n / 2;\n      { // Algebra\n        assert n == 2 * n / 2;\n      }\n      2 * n / 2 + (n - 1) * n / 2;\n      (2 * n + (n - 1) * n) / 2;\n      (2 * n + n * n - n) / 2;\n      (n + n * n) / 2;\n      n * (1 + n) / 2;\n      n * (n + 1) / 2;\n    }\n  }\n}\n\nlemma SumOddsIsSquare(n: nat)\n  ensures sumOdds(n) == n * n\n{\n  if n == 0 {\n    // Base case\n    assert sumOdds(0) == 0;\n    assert 0 * 0 == 0;\n  } else {\n    // Inductive step\n    SumOddsIsSquare(n - 1);\n\n    calc == {\n      sumOdds(n);\n      (2 * n - 1) + sumOdds(n - 1);\n      { // Induction hypothesis\n        assert sumOdds(n - 1) == (n - 1) * (n - 1);\n      }\n      (2 * n - 1) + (n - 1) * (n - 1);\n      { // Expand (n-1)\u00b2\n        assert (n - 1) * (n - 1) == n * n - 2 * n + 1;\n      }\n      (2 * n - 1) + (n * n - 2 * n + 1);\n      2 * n - 1 + n * n - 2 * n + 1;\n      n * n;\n    }\n  }\n}\n\nlemma SumSquaresFormula(n: nat)\n  ensures sumSquares(n) == n * (n + 1) * (2 * n + 1) / 6\n{\n  if n == 0 {\n    // Base case\n    assert sumSquares(0) == 0;\n    assert 0 * (0 + 1) * (2 * 0 + 1) / 6 == 0;\n  } else {\n    // Inductive step\n    SumSquaresFormula(n - 1);\n\n    calc == {\n      sumSquares(n);\n      n * n + sumSquares(n - 1);\n      { // Induction hypothesis\n        assert sumSquares(n - 1) == (n - 1) * n * (2 * n - 1) / 6;\n      }\n      n * n + (n - 1) * n * (2 * n - 1) / 6;\n      { // Factor out common terms\n        assert n * n == 6 * n * n / 6;\n      }\n      6 * n * n / 6 + (n - 1) * n * (2 * n - 1) / 6;\n      (6 * n * n + (n - 1) * n * (2 * n - 1)) / 6;\n      { // Expand\n        assert (n - 1) * n * (2 * n - 1) == n * (n - 1) * (2 * n - 1);\n        assert n * (n - 1) * (2 * n - 1) == n * (2 * n * n - 3 * n + 1);\n        assert n * (2 * n * n - 3 * n + 1) == 2 * n * n * n - 3 * n * n + n;\n      }\n      (6 * n * n + 2 * n * n * n - 3 * n * n + n) / 6;\n      (2 * n * n * n + 3 * n * n + n) / 6;\n      n * (2 * n * n + 3 * n + 1) / 6;\n      { // Factor\n        assert 2 * n * n + 3 * n + 1 == (n + 1) * (2 * n + 1);\n      }\n      n * (n + 1) * (2 * n + 1) / 6;\n    }\n  }\n}\n\nlemma PowerOfTwo(n: nat)\n  ensures power(2, n) >= n + 1\n{\n  if n == 0 {\n    // Base case\n    assert power(2, 0) == 1;\n    assert 1 >= 0 + 1;\n  } else {\n    // Inductive step\n    PowerOfTwo(n - 1);\n\n    calc >= {\n      power(2, n);\n      2 * power(2, n - 1);\n      { // Induction hypothesis\n        assert power(2, n - 1) >= n;\n      }\n      2 * n;\n      { // Since n >= 1\n        assert n >= 1;\n        assert 2 * n >= n + 1;\n      }\n      n + 1;\n    }\n  }\n}\n\nlemma PowerMonotonic(base: nat, exp1: nat, exp2: nat)\n  requires base > 1\n  requires exp1 <= exp2\n  ensures power(base, exp1) <= power(base, exp2)\n{\n  if exp1 == exp2 {\n    // Equal case\n    assert power(base, exp1) == power(base, exp2);\n  } else {\n    // exp1 < exp2\n    assert exp1 < exp2;\n\n    if exp1 == 0 {\n      assert power(base, exp1) == 1;\n      PowerPositive(base, exp2);\n      assert power(base, exp2) >= 1;\n    } else {\n      // Both exp1 and exp2 are positive\n      PowerMonotonic(base, exp1 - 1, exp2 - 1);\n\n      calc <= {\n        power(base, exp1);\n        base * power(base, exp1 - 1);\n        { // Induction hypothesis\n          \n/*[CODE HERE]*/\n        }\n        base * power(base, exp2 - 1);\n        power(base, exp2);\n      }\n    }\n  }\n}\n\nlemma PowerPositive(base: nat, exp: nat)\n  requires base > 0\n  ensures power(base, exp) > 0\n{\n  if exp == 0 {\n    assert power(base, 0) == 1;\n  } else {\n    PowerPositive(base, exp - 1);\n    assert power(base, exp) == base * power(base, exp - 1);\n    assert base > 0 && power(base, exp - 1) > 0;\n  }\n}\n\nlemma FibonacciInequality(n: nat)\n  requires n >= 1\n  ensures fib(n) <= power(2, n - 1)\n{\n  if n == 1 {\n    // Base case\n    assert fib(1) == 1;\n    assert power(2, 0) == 1;\n  } else if n == 2 {\n    // Base case\n    assert fib(2) == 1;\n    assert power(2, 1) == 2;\n    assert 1 <= 2;\n  } else {\n    // Inductive step (n >= 3)\n    assert n >= 3;\n    FibonacciInequality(n - 1);\n    FibonacciInequality(n - 2);\n\n    calc <= {\n      fib(n);\n      fib(n - 1) + fib(n - 2);\n      { // Induction hypotheses\n        assert fib(n - 1) <= power(2, n - 2);\n        assert fib(n - 2) <= power(2, n - 3);\n      }\n      power(2, n - 2) + power(2, n - 3);\n      { // Factor out power(2, n - 3)\n        assert power(2, n - 2) == 2 * power(2, n - 3);\n      }\n      2 * power(2, n - 3) + power(2, n - 3);\n      3 * power(2, n - 3);\n      { // 3 * 2^(n-3) <= 4 * 2^(n-3) = 2^(n-1)\n        assert 3 <= 4;\n        assert power(2, n - 1) == 4 * power(2, n - 3);\n      }\n      power(2, n - 1);\n    }\n  }\n}\n\nlemma StrongInduction(n: nat, P: nat -> bool)\n  requires forall k :: 0 <= k < n ==> P(k)\n  requires forall m :: m >= n && (forall j :: n <= j < m ==> P(j)) ==> P(m)\n  ensures P(n)\n{\n  // This demonstrates the strong induction principle\n  // Base case: all k < n satisfy P(k) by hypothesis\n  // Inductive case: if all j in [n, m) satisfy P, then P(m) holds\n\n  // The proof would proceed by showing P(n) directly\n  // using the second hypothesis with m = n\n  assert forall j :: n <= j < n ==> P(j); // Vacuously true\n}\n\nlemma CompleteInduction(n: nat, P: nat -> bool)\n  requires P(0)\n  requires forall k: nat :: k > 0 && (forall j: nat :: j < k ==> P(j)) ==> P(k)\n  ensures P(n)\n{\n  if n == 0 {\n    // Base case\n    assert P(0);\n  } else {\n    // Need to show all j < n satisfy P(j)\n    forall j: nat | j < n\n      ensures P(j)\n    {\n      if j == 0 {\n        assert P(0);\n      } else {\n        CompleteInduction(j, P);\n      }\n    }\n\n    // Now apply the inductive hypothesis\n    assert forall j: nat :: j < n ==> P(j);\n    assert P(n);\n  }\n}", "output": "assert power(base, exp1 - 1) <= power(base, exp2 - 1);"}, {"id": "example_PowerMonotonic_1", "type": "call", "program": "// Induction proofs with detailed reasoning steps\n\n// Sum of first n natural numbers\nfunction {:spec} sumTo(n: nat): nat\n{\n  if n == 0 then 0 else n + sumTo(n - 1)\n}\n\n// Sum of first n odd numbers\nfunction {:spec} sumOdds(n: nat): nat\n{\n  if n == 0 then 0 else (2 * n - 1) + sumOdds(n - 1)\n}\n\n// Sum of first n squares\nfunction {:spec} sumSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + sumSquares(n - 1)\n}\n\n// Power function\nfunction {:spec} power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\n// Fibonacci\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// --- Detailed Inductive Proofs ---\n\nlemma SumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    // Base case\n    assert sumTo(0) == 0;\n    assert 0 * (0 + 1) / 2 == 0;\n  } else {\n    // Inductive step\n    SumToFormula(n - 1);\n\n    calc == {\n      sumTo(n);\n      n + sumTo(n - 1);\n      { // Induction hypothesis\n        assert sumTo(n - 1) == (n - 1) * n / 2;\n      }\n      n + (n - 1) * n / 2;\n      { // Algebra\n        assert n == 2 * n / 2;\n      }\n      2 * n / 2 + (n - 1) * n / 2;\n      (2 * n + (n - 1) * n) / 2;\n      (2 * n + n * n - n) / 2;\n      (n + n * n) / 2;\n      n * (1 + n) / 2;\n      n * (n + 1) / 2;\n    }\n  }\n}\n\nlemma SumOddsIsSquare(n: nat)\n  ensures sumOdds(n) == n * n\n{\n  if n == 0 {\n    // Base case\n    assert sumOdds(0) == 0;\n    assert 0 * 0 == 0;\n  } else {\n    // Inductive step\n    SumOddsIsSquare(n - 1);\n\n    calc == {\n      sumOdds(n);\n      (2 * n - 1) + sumOdds(n - 1);\n      { // Induction hypothesis\n        assert sumOdds(n - 1) == (n - 1) * (n - 1);\n      }\n      (2 * n - 1) + (n - 1) * (n - 1);\n      { // Expand (n-1)\u00b2\n        assert (n - 1) * (n - 1) == n * n - 2 * n + 1;\n      }\n      (2 * n - 1) + (n * n - 2 * n + 1);\n      2 * n - 1 + n * n - 2 * n + 1;\n      n * n;\n    }\n  }\n}\n\nlemma SumSquaresFormula(n: nat)\n  ensures sumSquares(n) == n * (n + 1) * (2 * n + 1) / 6\n{\n  if n == 0 {\n    // Base case\n    assert sumSquares(0) == 0;\n    assert 0 * (0 + 1) * (2 * 0 + 1) / 6 == 0;\n  } else {\n    // Inductive step\n    SumSquaresFormula(n - 1);\n\n    calc == {\n      sumSquares(n);\n      n * n + sumSquares(n - 1);\n      { // Induction hypothesis\n        assert sumSquares(n - 1) == (n - 1) * n * (2 * n - 1) / 6;\n      }\n      n * n + (n - 1) * n * (2 * n - 1) / 6;\n      { // Factor out common terms\n        assert n * n == 6 * n * n / 6;\n      }\n      6 * n * n / 6 + (n - 1) * n * (2 * n - 1) / 6;\n      (6 * n * n + (n - 1) * n * (2 * n - 1)) / 6;\n      { // Expand\n        assert (n - 1) * n * (2 * n - 1) == n * (n - 1) * (2 * n - 1);\n        assert n * (n - 1) * (2 * n - 1) == n * (2 * n * n - 3 * n + 1);\n        assert n * (2 * n * n - 3 * n + 1) == 2 * n * n * n - 3 * n * n + n;\n      }\n      (6 * n * n + 2 * n * n * n - 3 * n * n + n) / 6;\n      (2 * n * n * n + 3 * n * n + n) / 6;\n      n * (2 * n * n + 3 * n + 1) / 6;\n      { // Factor\n        assert 2 * n * n + 3 * n + 1 == (n + 1) * (2 * n + 1);\n      }\n      n * (n + 1) * (2 * n + 1) / 6;\n    }\n  }\n}\n\nlemma PowerOfTwo(n: nat)\n  ensures power(2, n) >= n + 1\n{\n  if n == 0 {\n    // Base case\n    assert power(2, 0) == 1;\n    assert 1 >= 0 + 1;\n  } else {\n    // Inductive step\n    PowerOfTwo(n - 1);\n\n    calc >= {\n      power(2, n);\n      2 * power(2, n - 1);\n      { // Induction hypothesis\n        assert power(2, n - 1) >= n;\n      }\n      2 * n;\n      { // Since n >= 1\n        assert n >= 1;\n        assert 2 * n >= n + 1;\n      }\n      n + 1;\n    }\n  }\n}\n\nlemma PowerMonotonic(base: nat, exp1: nat, exp2: nat)\n  requires base > 1\n  requires exp1 <= exp2\n  ensures power(base, exp1) <= power(base, exp2)\n{\n  if exp1 == exp2 {\n    // Equal case\n    assert power(base, exp1) == power(base, exp2);\n  } else {\n    // exp1 < exp2\n    assert exp1 < exp2;\n\n    if exp1 == 0 {\n      assert power(base, exp1) == 1;\n      PowerPositive(base, exp2);\n      assert power(base, exp2) >= 1;\n    } else {\n      // Both exp1 and exp2 are positive\n      \n/*[CODE HERE]*/\n\n      calc <= {\n        power(base, exp1);\n        base * power(base, exp1 - 1);\n        { // Induction hypothesis\n          assert power(base, exp1 - 1) <= power(base, exp2 - 1);\n        }\n        base * power(base, exp2 - 1);\n        power(base, exp2);\n      }\n    }\n  }\n}\n\nlemma PowerPositive(base: nat, exp: nat)\n  requires base > 0\n  ensures power(base, exp) > 0\n{\n  if exp == 0 {\n    assert power(base, 0) == 1;\n  } else {\n    PowerPositive(base, exp - 1);\n    assert power(base, exp) == base * power(base, exp - 1);\n    assert base > 0 && power(base, exp - 1) > 0;\n  }\n}\n\nlemma FibonacciInequality(n: nat)\n  requires n >= 1\n  ensures fib(n) <= power(2, n - 1)\n{\n  if n == 1 {\n    // Base case\n    assert fib(1) == 1;\n    assert power(2, 0) == 1;\n  } else if n == 2 {\n    // Base case\n    assert fib(2) == 1;\n    assert power(2, 1) == 2;\n    assert 1 <= 2;\n  } else {\n    // Inductive step (n >= 3)\n    assert n >= 3;\n    FibonacciInequality(n - 1);\n    FibonacciInequality(n - 2);\n\n    calc <= {\n      fib(n);\n      fib(n - 1) + fib(n - 2);\n      { // Induction hypotheses\n        assert fib(n - 1) <= power(2, n - 2);\n        assert fib(n - 2) <= power(2, n - 3);\n      }\n      power(2, n - 2) + power(2, n - 3);\n      { // Factor out power(2, n - 3)\n        assert power(2, n - 2) == 2 * power(2, n - 3);\n      }\n      2 * power(2, n - 3) + power(2, n - 3);\n      3 * power(2, n - 3);\n      { // 3 * 2^(n-3) <= 4 * 2^(n-3) = 2^(n-1)\n        assert 3 <= 4;\n        assert power(2, n - 1) == 4 * power(2, n - 3);\n      }\n      power(2, n - 1);\n    }\n  }\n}\n\nlemma StrongInduction(n: nat, P: nat -> bool)\n  requires forall k :: 0 <= k < n ==> P(k)\n  requires forall m :: m >= n && (forall j :: n <= j < m ==> P(j)) ==> P(m)\n  ensures P(n)\n{\n  // This demonstrates the strong induction principle\n  // Base case: all k < n satisfy P(k) by hypothesis\n  // Inductive case: if all j in [n, m) satisfy P, then P(m) holds\n\n  // The proof would proceed by showing P(n) directly\n  // using the second hypothesis with m = n\n  assert forall j :: n <= j < n ==> P(j); // Vacuously true\n}\n\nlemma CompleteInduction(n: nat, P: nat -> bool)\n  requires P(0)\n  requires forall k: nat :: k > 0 && (forall j: nat :: j < k ==> P(j)) ==> P(k)\n  ensures P(n)\n{\n  if n == 0 {\n    // Base case\n    assert P(0);\n  } else {\n    // Need to show all j < n satisfy P(j)\n    forall j: nat | j < n\n      ensures P(j)\n    {\n      if j == 0 {\n        assert P(0);\n      } else {\n        CompleteInduction(j, P);\n      }\n    }\n\n    // Now apply the inductive hypothesis\n    assert forall j: nat :: j < n ==> P(j);\n    assert P(n);\n  }\n}", "output": "PowerMonotonic(base, exp1 - 1, exp2 - 1);"}, {"id": "example_PowerMonotonic_2", "type": "assert", "program": "// Induction proofs with detailed reasoning steps\n\n// Sum of first n natural numbers\nfunction {:spec} sumTo(n: nat): nat\n{\n  if n == 0 then 0 else n + sumTo(n - 1)\n}\n\n// Sum of first n odd numbers\nfunction {:spec} sumOdds(n: nat): nat\n{\n  if n == 0 then 0 else (2 * n - 1) + sumOdds(n - 1)\n}\n\n// Sum of first n squares\nfunction {:spec} sumSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + sumSquares(n - 1)\n}\n\n// Power function\nfunction {:spec} power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\n// Fibonacci\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// --- Detailed Inductive Proofs ---\n\nlemma SumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    // Base case\n    assert sumTo(0) == 0;\n    assert 0 * (0 + 1) / 2 == 0;\n  } else {\n    // Inductive step\n    SumToFormula(n - 1);\n\n    calc == {\n      sumTo(n);\n      n + sumTo(n - 1);\n      { // Induction hypothesis\n        assert sumTo(n - 1) == (n - 1) * n / 2;\n      }\n      n + (n - 1) * n / 2;\n      { // Algebra\n        assert n == 2 * n / 2;\n      }\n      2 * n / 2 + (n - 1) * n / 2;\n      (2 * n + (n - 1) * n) / 2;\n      (2 * n + n * n - n) / 2;\n      (n + n * n) / 2;\n      n * (1 + n) / 2;\n      n * (n + 1) / 2;\n    }\n  }\n}\n\nlemma SumOddsIsSquare(n: nat)\n  ensures sumOdds(n) == n * n\n{\n  if n == 0 {\n    // Base case\n    assert sumOdds(0) == 0;\n    assert 0 * 0 == 0;\n  } else {\n    // Inductive step\n    SumOddsIsSquare(n - 1);\n\n    calc == {\n      sumOdds(n);\n      (2 * n - 1) + sumOdds(n - 1);\n      { // Induction hypothesis\n        assert sumOdds(n - 1) == (n - 1) * (n - 1);\n      }\n      (2 * n - 1) + (n - 1) * (n - 1);\n      { // Expand (n-1)\u00b2\n        assert (n - 1) * (n - 1) == n * n - 2 * n + 1;\n      }\n      (2 * n - 1) + (n * n - 2 * n + 1);\n      2 * n - 1 + n * n - 2 * n + 1;\n      n * n;\n    }\n  }\n}\n\nlemma SumSquaresFormula(n: nat)\n  ensures sumSquares(n) == n * (n + 1) * (2 * n + 1) / 6\n{\n  if n == 0 {\n    // Base case\n    assert sumSquares(0) == 0;\n    assert 0 * (0 + 1) * (2 * 0 + 1) / 6 == 0;\n  } else {\n    // Inductive step\n    SumSquaresFormula(n - 1);\n\n    calc == {\n      sumSquares(n);\n      n * n + sumSquares(n - 1);\n      { // Induction hypothesis\n        assert sumSquares(n - 1) == (n - 1) * n * (2 * n - 1) / 6;\n      }\n      n * n + (n - 1) * n * (2 * n - 1) / 6;\n      { // Factor out common terms\n        assert n * n == 6 * n * n / 6;\n      }\n      6 * n * n / 6 + (n - 1) * n * (2 * n - 1) / 6;\n      (6 * n * n + (n - 1) * n * (2 * n - 1)) / 6;\n      { // Expand\n        assert (n - 1) * n * (2 * n - 1) == n * (n - 1) * (2 * n - 1);\n        assert n * (n - 1) * (2 * n - 1) == n * (2 * n * n - 3 * n + 1);\n        assert n * (2 * n * n - 3 * n + 1) == 2 * n * n * n - 3 * n * n + n;\n      }\n      (6 * n * n + 2 * n * n * n - 3 * n * n + n) / 6;\n      (2 * n * n * n + 3 * n * n + n) / 6;\n      n * (2 * n * n + 3 * n + 1) / 6;\n      { // Factor\n        assert 2 * n * n + 3 * n + 1 == (n + 1) * (2 * n + 1);\n      }\n      n * (n + 1) * (2 * n + 1) / 6;\n    }\n  }\n}\n\nlemma PowerOfTwo(n: nat)\n  ensures power(2, n) >= n + 1\n{\n  if n == 0 {\n    // Base case\n    assert power(2, 0) == 1;\n    assert 1 >= 0 + 1;\n  } else {\n    // Inductive step\n    PowerOfTwo(n - 1);\n\n    calc >= {\n      power(2, n);\n      2 * power(2, n - 1);\n      { // Induction hypothesis\n        assert power(2, n - 1) >= n;\n      }\n      2 * n;\n      { // Since n >= 1\n        assert n >= 1;\n        assert 2 * n >= n + 1;\n      }\n      n + 1;\n    }\n  }\n}\n\nlemma PowerMonotonic(base: nat, exp1: nat, exp2: nat)\n  requires base > 1\n  requires exp1 <= exp2\n  ensures power(base, exp1) <= power(base, exp2)\n{\n  if exp1 == exp2 {\n    // Equal case\n    assert power(base, exp1) == power(base, exp2);\n  } else {\n    // exp1 < exp2\n    assert exp1 < exp2;\n\n    if exp1 == 0 {\n      assert power(base, exp1) == 1;\n      PowerPositive(base, exp2);\n      \n/*[CODE HERE]*/\n    } else {\n      // Both exp1 and exp2 are positive\n      PowerMonotonic(base, exp1 - 1, exp2 - 1);\n\n      calc <= {\n        power(base, exp1);\n        base * power(base, exp1 - 1);\n        { // Induction hypothesis\n          assert power(base, exp1 - 1) <= power(base, exp2 - 1);\n        }\n        base * power(base, exp2 - 1);\n        power(base, exp2);\n      }\n    }\n  }\n}\n\nlemma PowerPositive(base: nat, exp: nat)\n  requires base > 0\n  ensures power(base, exp) > 0\n{\n  if exp == 0 {\n    assert power(base, 0) == 1;\n  } else {\n    PowerPositive(base, exp - 1);\n    assert power(base, exp) == base * power(base, exp - 1);\n    assert base > 0 && power(base, exp - 1) > 0;\n  }\n}\n\nlemma FibonacciInequality(n: nat)\n  requires n >= 1\n  ensures fib(n) <= power(2, n - 1)\n{\n  if n == 1 {\n    // Base case\n    assert fib(1) == 1;\n    assert power(2, 0) == 1;\n  } else if n == 2 {\n    // Base case\n    assert fib(2) == 1;\n    assert power(2, 1) == 2;\n    assert 1 <= 2;\n  } else {\n    // Inductive step (n >= 3)\n    assert n >= 3;\n    FibonacciInequality(n - 1);\n    FibonacciInequality(n - 2);\n\n    calc <= {\n      fib(n);\n      fib(n - 1) + fib(n - 2);\n      { // Induction hypotheses\n        assert fib(n - 1) <= power(2, n - 2);\n        assert fib(n - 2) <= power(2, n - 3);\n      }\n      power(2, n - 2) + power(2, n - 3);\n      { // Factor out power(2, n - 3)\n        assert power(2, n - 2) == 2 * power(2, n - 3);\n      }\n      2 * power(2, n - 3) + power(2, n - 3);\n      3 * power(2, n - 3);\n      { // 3 * 2^(n-3) <= 4 * 2^(n-3) = 2^(n-1)\n        assert 3 <= 4;\n        assert power(2, n - 1) == 4 * power(2, n - 3);\n      }\n      power(2, n - 1);\n    }\n  }\n}\n\nlemma StrongInduction(n: nat, P: nat -> bool)\n  requires forall k :: 0 <= k < n ==> P(k)\n  requires forall m :: m >= n && (forall j :: n <= j < m ==> P(j)) ==> P(m)\n  ensures P(n)\n{\n  // This demonstrates the strong induction principle\n  // Base case: all k < n satisfy P(k) by hypothesis\n  // Inductive case: if all j in [n, m) satisfy P, then P(m) holds\n\n  // The proof would proceed by showing P(n) directly\n  // using the second hypothesis with m = n\n  assert forall j :: n <= j < n ==> P(j); // Vacuously true\n}\n\nlemma CompleteInduction(n: nat, P: nat -> bool)\n  requires P(0)\n  requires forall k: nat :: k > 0 && (forall j: nat :: j < k ==> P(j)) ==> P(k)\n  ensures P(n)\n{\n  if n == 0 {\n    // Base case\n    assert P(0);\n  } else {\n    // Need to show all j < n satisfy P(j)\n    forall j: nat | j < n\n      ensures P(j)\n    {\n      if j == 0 {\n        assert P(0);\n      } else {\n        CompleteInduction(j, P);\n      }\n    }\n\n    // Now apply the inductive hypothesis\n    assert forall j: nat :: j < n ==> P(j);\n    assert P(n);\n  }\n}", "output": "assert power(base, exp2) >= 1;"}, {"id": "example_PowerMonotonic_3", "type": "call", "program": "// Induction proofs with detailed reasoning steps\n\n// Sum of first n natural numbers\nfunction {:spec} sumTo(n: nat): nat\n{\n  if n == 0 then 0 else n + sumTo(n - 1)\n}\n\n// Sum of first n odd numbers\nfunction {:spec} sumOdds(n: nat): nat\n{\n  if n == 0 then 0 else (2 * n - 1) + sumOdds(n - 1)\n}\n\n// Sum of first n squares\nfunction {:spec} sumSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + sumSquares(n - 1)\n}\n\n// Power function\nfunction {:spec} power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\n// Fibonacci\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// --- Detailed Inductive Proofs ---\n\nlemma SumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    // Base case\n    assert sumTo(0) == 0;\n    assert 0 * (0 + 1) / 2 == 0;\n  } else {\n    // Inductive step\n    SumToFormula(n - 1);\n\n    calc == {\n      sumTo(n);\n      n + sumTo(n - 1);\n      { // Induction hypothesis\n        assert sumTo(n - 1) == (n - 1) * n / 2;\n      }\n      n + (n - 1) * n / 2;\n      { // Algebra\n        assert n == 2 * n / 2;\n      }\n      2 * n / 2 + (n - 1) * n / 2;\n      (2 * n + (n - 1) * n) / 2;\n      (2 * n + n * n - n) / 2;\n      (n + n * n) / 2;\n      n * (1 + n) / 2;\n      n * (n + 1) / 2;\n    }\n  }\n}\n\nlemma SumOddsIsSquare(n: nat)\n  ensures sumOdds(n) == n * n\n{\n  if n == 0 {\n    // Base case\n    assert sumOdds(0) == 0;\n    assert 0 * 0 == 0;\n  } else {\n    // Inductive step\n    SumOddsIsSquare(n - 1);\n\n    calc == {\n      sumOdds(n);\n      (2 * n - 1) + sumOdds(n - 1);\n      { // Induction hypothesis\n        assert sumOdds(n - 1) == (n - 1) * (n - 1);\n      }\n      (2 * n - 1) + (n - 1) * (n - 1);\n      { // Expand (n-1)\u00b2\n        assert (n - 1) * (n - 1) == n * n - 2 * n + 1;\n      }\n      (2 * n - 1) + (n * n - 2 * n + 1);\n      2 * n - 1 + n * n - 2 * n + 1;\n      n * n;\n    }\n  }\n}\n\nlemma SumSquaresFormula(n: nat)\n  ensures sumSquares(n) == n * (n + 1) * (2 * n + 1) / 6\n{\n  if n == 0 {\n    // Base case\n    assert sumSquares(0) == 0;\n    assert 0 * (0 + 1) * (2 * 0 + 1) / 6 == 0;\n  } else {\n    // Inductive step\n    SumSquaresFormula(n - 1);\n\n    calc == {\n      sumSquares(n);\n      n * n + sumSquares(n - 1);\n      { // Induction hypothesis\n        assert sumSquares(n - 1) == (n - 1) * n * (2 * n - 1) / 6;\n      }\n      n * n + (n - 1) * n * (2 * n - 1) / 6;\n      { // Factor out common terms\n        assert n * n == 6 * n * n / 6;\n      }\n      6 * n * n / 6 + (n - 1) * n * (2 * n - 1) / 6;\n      (6 * n * n + (n - 1) * n * (2 * n - 1)) / 6;\n      { // Expand\n        assert (n - 1) * n * (2 * n - 1) == n * (n - 1) * (2 * n - 1);\n        assert n * (n - 1) * (2 * n - 1) == n * (2 * n * n - 3 * n + 1);\n        assert n * (2 * n * n - 3 * n + 1) == 2 * n * n * n - 3 * n * n + n;\n      }\n      (6 * n * n + 2 * n * n * n - 3 * n * n + n) / 6;\n      (2 * n * n * n + 3 * n * n + n) / 6;\n      n * (2 * n * n + 3 * n + 1) / 6;\n      { // Factor\n        assert 2 * n * n + 3 * n + 1 == (n + 1) * (2 * n + 1);\n      }\n      n * (n + 1) * (2 * n + 1) / 6;\n    }\n  }\n}\n\nlemma PowerOfTwo(n: nat)\n  ensures power(2, n) >= n + 1\n{\n  if n == 0 {\n    // Base case\n    assert power(2, 0) == 1;\n    assert 1 >= 0 + 1;\n  } else {\n    // Inductive step\n    PowerOfTwo(n - 1);\n\n    calc >= {\n      power(2, n);\n      2 * power(2, n - 1);\n      { // Induction hypothesis\n        assert power(2, n - 1) >= n;\n      }\n      2 * n;\n      { // Since n >= 1\n        assert n >= 1;\n        assert 2 * n >= n + 1;\n      }\n      n + 1;\n    }\n  }\n}\n\nlemma PowerMonotonic(base: nat, exp1: nat, exp2: nat)\n  requires base > 1\n  requires exp1 <= exp2\n  ensures power(base, exp1) <= power(base, exp2)\n{\n  if exp1 == exp2 {\n    // Equal case\n    assert power(base, exp1) == power(base, exp2);\n  } else {\n    // exp1 < exp2\n    assert exp1 < exp2;\n\n    if exp1 == 0 {\n      assert power(base, exp1) == 1;\n      \n/*[CODE HERE]*/\n      assert power(base, exp2) >= 1;\n    } else {\n      // Both exp1 and exp2 are positive\n      PowerMonotonic(base, exp1 - 1, exp2 - 1);\n\n      calc <= {\n        power(base, exp1);\n        base * power(base, exp1 - 1);\n        { // Induction hypothesis\n          assert power(base, exp1 - 1) <= power(base, exp2 - 1);\n        }\n        base * power(base, exp2 - 1);\n        power(base, exp2);\n      }\n    }\n  }\n}\n\nlemma PowerPositive(base: nat, exp: nat)\n  requires base > 0\n  ensures power(base, exp) > 0\n{\n  if exp == 0 {\n    assert power(base, 0) == 1;\n  } else {\n    PowerPositive(base, exp - 1);\n    assert power(base, exp) == base * power(base, exp - 1);\n    assert base > 0 && power(base, exp - 1) > 0;\n  }\n}\n\nlemma FibonacciInequality(n: nat)\n  requires n >= 1\n  ensures fib(n) <= power(2, n - 1)\n{\n  if n == 1 {\n    // Base case\n    assert fib(1) == 1;\n    assert power(2, 0) == 1;\n  } else if n == 2 {\n    // Base case\n    assert fib(2) == 1;\n    assert power(2, 1) == 2;\n    assert 1 <= 2;\n  } else {\n    // Inductive step (n >= 3)\n    assert n >= 3;\n    FibonacciInequality(n - 1);\n    FibonacciInequality(n - 2);\n\n    calc <= {\n      fib(n);\n      fib(n - 1) + fib(n - 2);\n      { // Induction hypotheses\n        assert fib(n - 1) <= power(2, n - 2);\n        assert fib(n - 2) <= power(2, n - 3);\n      }\n      power(2, n - 2) + power(2, n - 3);\n      { // Factor out power(2, n - 3)\n        assert power(2, n - 2) == 2 * power(2, n - 3);\n      }\n      2 * power(2, n - 3) + power(2, n - 3);\n      3 * power(2, n - 3);\n      { // 3 * 2^(n-3) <= 4 * 2^(n-3) = 2^(n-1)\n        assert 3 <= 4;\n        assert power(2, n - 1) == 4 * power(2, n - 3);\n      }\n      power(2, n - 1);\n    }\n  }\n}\n\nlemma StrongInduction(n: nat, P: nat -> bool)\n  requires forall k :: 0 <= k < n ==> P(k)\n  requires forall m :: m >= n && (forall j :: n <= j < m ==> P(j)) ==> P(m)\n  ensures P(n)\n{\n  // This demonstrates the strong induction principle\n  // Base case: all k < n satisfy P(k) by hypothesis\n  // Inductive case: if all j in [n, m) satisfy P, then P(m) holds\n\n  // The proof would proceed by showing P(n) directly\n  // using the second hypothesis with m = n\n  assert forall j :: n <= j < n ==> P(j); // Vacuously true\n}\n\nlemma CompleteInduction(n: nat, P: nat -> bool)\n  requires P(0)\n  requires forall k: nat :: k > 0 && (forall j: nat :: j < k ==> P(j)) ==> P(k)\n  ensures P(n)\n{\n  if n == 0 {\n    // Base case\n    assert P(0);\n  } else {\n    // Need to show all j < n satisfy P(j)\n    forall j: nat | j < n\n      ensures P(j)\n    {\n      if j == 0 {\n        assert P(0);\n      } else {\n        CompleteInduction(j, P);\n      }\n    }\n\n    // Now apply the inductive hypothesis\n    assert forall j: nat :: j < n ==> P(j);\n    assert P(n);\n  }\n}", "output": "PowerPositive(base, exp2);"}, {"id": "example_PowerMonotonic_4", "type": "assert", "program": "// Induction proofs with detailed reasoning steps\n\n// Sum of first n natural numbers\nfunction {:spec} sumTo(n: nat): nat\n{\n  if n == 0 then 0 else n + sumTo(n - 1)\n}\n\n// Sum of first n odd numbers\nfunction {:spec} sumOdds(n: nat): nat\n{\n  if n == 0 then 0 else (2 * n - 1) + sumOdds(n - 1)\n}\n\n// Sum of first n squares\nfunction {:spec} sumSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + sumSquares(n - 1)\n}\n\n// Power function\nfunction {:spec} power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\n// Fibonacci\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// --- Detailed Inductive Proofs ---\n\nlemma SumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    // Base case\n    assert sumTo(0) == 0;\n    assert 0 * (0 + 1) / 2 == 0;\n  } else {\n    // Inductive step\n    SumToFormula(n - 1);\n\n    calc == {\n      sumTo(n);\n      n + sumTo(n - 1);\n      { // Induction hypothesis\n        assert sumTo(n - 1) == (n - 1) * n / 2;\n      }\n      n + (n - 1) * n / 2;\n      { // Algebra\n        assert n == 2 * n / 2;\n      }\n      2 * n / 2 + (n - 1) * n / 2;\n      (2 * n + (n - 1) * n) / 2;\n      (2 * n + n * n - n) / 2;\n      (n + n * n) / 2;\n      n * (1 + n) / 2;\n      n * (n + 1) / 2;\n    }\n  }\n}\n\nlemma SumOddsIsSquare(n: nat)\n  ensures sumOdds(n) == n * n\n{\n  if n == 0 {\n    // Base case\n    assert sumOdds(0) == 0;\n    assert 0 * 0 == 0;\n  } else {\n    // Inductive step\n    SumOddsIsSquare(n - 1);\n\n    calc == {\n      sumOdds(n);\n      (2 * n - 1) + sumOdds(n - 1);\n      { // Induction hypothesis\n        assert sumOdds(n - 1) == (n - 1) * (n - 1);\n      }\n      (2 * n - 1) + (n - 1) * (n - 1);\n      { // Expand (n-1)\u00b2\n        assert (n - 1) * (n - 1) == n * n - 2 * n + 1;\n      }\n      (2 * n - 1) + (n * n - 2 * n + 1);\n      2 * n - 1 + n * n - 2 * n + 1;\n      n * n;\n    }\n  }\n}\n\nlemma SumSquaresFormula(n: nat)\n  ensures sumSquares(n) == n * (n + 1) * (2 * n + 1) / 6\n{\n  if n == 0 {\n    // Base case\n    assert sumSquares(0) == 0;\n    assert 0 * (0 + 1) * (2 * 0 + 1) / 6 == 0;\n  } else {\n    // Inductive step\n    SumSquaresFormula(n - 1);\n\n    calc == {\n      sumSquares(n);\n      n * n + sumSquares(n - 1);\n      { // Induction hypothesis\n        assert sumSquares(n - 1) == (n - 1) * n * (2 * n - 1) / 6;\n      }\n      n * n + (n - 1) * n * (2 * n - 1) / 6;\n      { // Factor out common terms\n        assert n * n == 6 * n * n / 6;\n      }\n      6 * n * n / 6 + (n - 1) * n * (2 * n - 1) / 6;\n      (6 * n * n + (n - 1) * n * (2 * n - 1)) / 6;\n      { // Expand\n        assert (n - 1) * n * (2 * n - 1) == n * (n - 1) * (2 * n - 1);\n        assert n * (n - 1) * (2 * n - 1) == n * (2 * n * n - 3 * n + 1);\n        assert n * (2 * n * n - 3 * n + 1) == 2 * n * n * n - 3 * n * n + n;\n      }\n      (6 * n * n + 2 * n * n * n - 3 * n * n + n) / 6;\n      (2 * n * n * n + 3 * n * n + n) / 6;\n      n * (2 * n * n + 3 * n + 1) / 6;\n      { // Factor\n        assert 2 * n * n + 3 * n + 1 == (n + 1) * (2 * n + 1);\n      }\n      n * (n + 1) * (2 * n + 1) / 6;\n    }\n  }\n}\n\nlemma PowerOfTwo(n: nat)\n  ensures power(2, n) >= n + 1\n{\n  if n == 0 {\n    // Base case\n    assert power(2, 0) == 1;\n    assert 1 >= 0 + 1;\n  } else {\n    // Inductive step\n    PowerOfTwo(n - 1);\n\n    calc >= {\n      power(2, n);\n      2 * power(2, n - 1);\n      { // Induction hypothesis\n        assert power(2, n - 1) >= n;\n      }\n      2 * n;\n      { // Since n >= 1\n        assert n >= 1;\n        assert 2 * n >= n + 1;\n      }\n      n + 1;\n    }\n  }\n}\n\nlemma PowerMonotonic(base: nat, exp1: nat, exp2: nat)\n  requires base > 1\n  requires exp1 <= exp2\n  ensures power(base, exp1) <= power(base, exp2)\n{\n  if exp1 == exp2 {\n    // Equal case\n    assert power(base, exp1) == power(base, exp2);\n  } else {\n    // exp1 < exp2\n    assert exp1 < exp2;\n\n    if exp1 == 0 {\n      \n/*[CODE HERE]*/\n      PowerPositive(base, exp2);\n      assert power(base, exp2) >= 1;\n    } else {\n      // Both exp1 and exp2 are positive\n      PowerMonotonic(base, exp1 - 1, exp2 - 1);\n\n      calc <= {\n        power(base, exp1);\n        base * power(base, exp1 - 1);\n        { // Induction hypothesis\n          assert power(base, exp1 - 1) <= power(base, exp2 - 1);\n        }\n        base * power(base, exp2 - 1);\n        power(base, exp2);\n      }\n    }\n  }\n}\n\nlemma PowerPositive(base: nat, exp: nat)\n  requires base > 0\n  ensures power(base, exp) > 0\n{\n  if exp == 0 {\n    assert power(base, 0) == 1;\n  } else {\n    PowerPositive(base, exp - 1);\n    assert power(base, exp) == base * power(base, exp - 1);\n    assert base > 0 && power(base, exp - 1) > 0;\n  }\n}\n\nlemma FibonacciInequality(n: nat)\n  requires n >= 1\n  ensures fib(n) <= power(2, n - 1)\n{\n  if n == 1 {\n    // Base case\n    assert fib(1) == 1;\n    assert power(2, 0) == 1;\n  } else if n == 2 {\n    // Base case\n    assert fib(2) == 1;\n    assert power(2, 1) == 2;\n    assert 1 <= 2;\n  } else {\n    // Inductive step (n >= 3)\n    assert n >= 3;\n    FibonacciInequality(n - 1);\n    FibonacciInequality(n - 2);\n\n    calc <= {\n      fib(n);\n      fib(n - 1) + fib(n - 2);\n      { // Induction hypotheses\n        assert fib(n - 1) <= power(2, n - 2);\n        assert fib(n - 2) <= power(2, n - 3);\n      }\n      power(2, n - 2) + power(2, n - 3);\n      { // Factor out power(2, n - 3)\n        assert power(2, n - 2) == 2 * power(2, n - 3);\n      }\n      2 * power(2, n - 3) + power(2, n - 3);\n      3 * power(2, n - 3);\n      { // 3 * 2^(n-3) <= 4 * 2^(n-3) = 2^(n-1)\n        assert 3 <= 4;\n        assert power(2, n - 1) == 4 * power(2, n - 3);\n      }\n      power(2, n - 1);\n    }\n  }\n}\n\nlemma StrongInduction(n: nat, P: nat -> bool)\n  requires forall k :: 0 <= k < n ==> P(k)\n  requires forall m :: m >= n && (forall j :: n <= j < m ==> P(j)) ==> P(m)\n  ensures P(n)\n{\n  // This demonstrates the strong induction principle\n  // Base case: all k < n satisfy P(k) by hypothesis\n  // Inductive case: if all j in [n, m) satisfy P, then P(m) holds\n\n  // The proof would proceed by showing P(n) directly\n  // using the second hypothesis with m = n\n  assert forall j :: n <= j < n ==> P(j); // Vacuously true\n}\n\nlemma CompleteInduction(n: nat, P: nat -> bool)\n  requires P(0)\n  requires forall k: nat :: k > 0 && (forall j: nat :: j < k ==> P(j)) ==> P(k)\n  ensures P(n)\n{\n  if n == 0 {\n    // Base case\n    assert P(0);\n  } else {\n    // Need to show all j < n satisfy P(j)\n    forall j: nat | j < n\n      ensures P(j)\n    {\n      if j == 0 {\n        assert P(0);\n      } else {\n        CompleteInduction(j, P);\n      }\n    }\n\n    // Now apply the inductive hypothesis\n    assert forall j: nat :: j < n ==> P(j);\n    assert P(n);\n  }\n}", "output": "assert power(base, exp1) == 1;"}, {"id": "example_PowerMonotonic_5", "type": "assert", "program": "// Induction proofs with detailed reasoning steps\n\n// Sum of first n natural numbers\nfunction {:spec} sumTo(n: nat): nat\n{\n  if n == 0 then 0 else n + sumTo(n - 1)\n}\n\n// Sum of first n odd numbers\nfunction {:spec} sumOdds(n: nat): nat\n{\n  if n == 0 then 0 else (2 * n - 1) + sumOdds(n - 1)\n}\n\n// Sum of first n squares\nfunction {:spec} sumSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + sumSquares(n - 1)\n}\n\n// Power function\nfunction {:spec} power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\n// Fibonacci\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// --- Detailed Inductive Proofs ---\n\nlemma SumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    // Base case\n    assert sumTo(0) == 0;\n    assert 0 * (0 + 1) / 2 == 0;\n  } else {\n    // Inductive step\n    SumToFormula(n - 1);\n\n    calc == {\n      sumTo(n);\n      n + sumTo(n - 1);\n      { // Induction hypothesis\n        assert sumTo(n - 1) == (n - 1) * n / 2;\n      }\n      n + (n - 1) * n / 2;\n      { // Algebra\n        assert n == 2 * n / 2;\n      }\n      2 * n / 2 + (n - 1) * n / 2;\n      (2 * n + (n - 1) * n) / 2;\n      (2 * n + n * n - n) / 2;\n      (n + n * n) / 2;\n      n * (1 + n) / 2;\n      n * (n + 1) / 2;\n    }\n  }\n}\n\nlemma SumOddsIsSquare(n: nat)\n  ensures sumOdds(n) == n * n\n{\n  if n == 0 {\n    // Base case\n    assert sumOdds(0) == 0;\n    assert 0 * 0 == 0;\n  } else {\n    // Inductive step\n    SumOddsIsSquare(n - 1);\n\n    calc == {\n      sumOdds(n);\n      (2 * n - 1) + sumOdds(n - 1);\n      { // Induction hypothesis\n        assert sumOdds(n - 1) == (n - 1) * (n - 1);\n      }\n      (2 * n - 1) + (n - 1) * (n - 1);\n      { // Expand (n-1)\u00b2\n        assert (n - 1) * (n - 1) == n * n - 2 * n + 1;\n      }\n      (2 * n - 1) + (n * n - 2 * n + 1);\n      2 * n - 1 + n * n - 2 * n + 1;\n      n * n;\n    }\n  }\n}\n\nlemma SumSquaresFormula(n: nat)\n  ensures sumSquares(n) == n * (n + 1) * (2 * n + 1) / 6\n{\n  if n == 0 {\n    // Base case\n    assert sumSquares(0) == 0;\n    assert 0 * (0 + 1) * (2 * 0 + 1) / 6 == 0;\n  } else {\n    // Inductive step\n    SumSquaresFormula(n - 1);\n\n    calc == {\n      sumSquares(n);\n      n * n + sumSquares(n - 1);\n      { // Induction hypothesis\n        assert sumSquares(n - 1) == (n - 1) * n * (2 * n - 1) / 6;\n      }\n      n * n + (n - 1) * n * (2 * n - 1) / 6;\n      { // Factor out common terms\n        assert n * n == 6 * n * n / 6;\n      }\n      6 * n * n / 6 + (n - 1) * n * (2 * n - 1) / 6;\n      (6 * n * n + (n - 1) * n * (2 * n - 1)) / 6;\n      { // Expand\n        assert (n - 1) * n * (2 * n - 1) == n * (n - 1) * (2 * n - 1);\n        assert n * (n - 1) * (2 * n - 1) == n * (2 * n * n - 3 * n + 1);\n        assert n * (2 * n * n - 3 * n + 1) == 2 * n * n * n - 3 * n * n + n;\n      }\n      (6 * n * n + 2 * n * n * n - 3 * n * n + n) / 6;\n      (2 * n * n * n + 3 * n * n + n) / 6;\n      n * (2 * n * n + 3 * n + 1) / 6;\n      { // Factor\n        assert 2 * n * n + 3 * n + 1 == (n + 1) * (2 * n + 1);\n      }\n      n * (n + 1) * (2 * n + 1) / 6;\n    }\n  }\n}\n\nlemma PowerOfTwo(n: nat)\n  ensures power(2, n) >= n + 1\n{\n  if n == 0 {\n    // Base case\n    assert power(2, 0) == 1;\n    assert 1 >= 0 + 1;\n  } else {\n    // Inductive step\n    PowerOfTwo(n - 1);\n\n    calc >= {\n      power(2, n);\n      2 * power(2, n - 1);\n      { // Induction hypothesis\n        assert power(2, n - 1) >= n;\n      }\n      2 * n;\n      { // Since n >= 1\n        assert n >= 1;\n        assert 2 * n >= n + 1;\n      }\n      n + 1;\n    }\n  }\n}\n\nlemma PowerMonotonic(base: nat, exp1: nat, exp2: nat)\n  requires base > 1\n  requires exp1 <= exp2\n  ensures power(base, exp1) <= power(base, exp2)\n{\n  if exp1 == exp2 {\n    // Equal case\n    assert power(base, exp1) == power(base, exp2);\n  } else {\n    // exp1 < exp2\n    \n/*[CODE HERE]*/\n\n    if exp1 == 0 {\n      assert power(base, exp1) == 1;\n      PowerPositive(base, exp2);\n      assert power(base, exp2) >= 1;\n    } else {\n      // Both exp1 and exp2 are positive\n      PowerMonotonic(base, exp1 - 1, exp2 - 1);\n\n      calc <= {\n        power(base, exp1);\n        base * power(base, exp1 - 1);\n        { // Induction hypothesis\n          assert power(base, exp1 - 1) <= power(base, exp2 - 1);\n        }\n        base * power(base, exp2 - 1);\n        power(base, exp2);\n      }\n    }\n  }\n}\n\nlemma PowerPositive(base: nat, exp: nat)\n  requires base > 0\n  ensures power(base, exp) > 0\n{\n  if exp == 0 {\n    assert power(base, 0) == 1;\n  } else {\n    PowerPositive(base, exp - 1);\n    assert power(base, exp) == base * power(base, exp - 1);\n    assert base > 0 && power(base, exp - 1) > 0;\n  }\n}\n\nlemma FibonacciInequality(n: nat)\n  requires n >= 1\n  ensures fib(n) <= power(2, n - 1)\n{\n  if n == 1 {\n    // Base case\n    assert fib(1) == 1;\n    assert power(2, 0) == 1;\n  } else if n == 2 {\n    // Base case\n    assert fib(2) == 1;\n    assert power(2, 1) == 2;\n    assert 1 <= 2;\n  } else {\n    // Inductive step (n >= 3)\n    assert n >= 3;\n    FibonacciInequality(n - 1);\n    FibonacciInequality(n - 2);\n\n    calc <= {\n      fib(n);\n      fib(n - 1) + fib(n - 2);\n      { // Induction hypotheses\n        assert fib(n - 1) <= power(2, n - 2);\n        assert fib(n - 2) <= power(2, n - 3);\n      }\n      power(2, n - 2) + power(2, n - 3);\n      { // Factor out power(2, n - 3)\n        assert power(2, n - 2) == 2 * power(2, n - 3);\n      }\n      2 * power(2, n - 3) + power(2, n - 3);\n      3 * power(2, n - 3);\n      { // 3 * 2^(n-3) <= 4 * 2^(n-3) = 2^(n-1)\n        assert 3 <= 4;\n        assert power(2, n - 1) == 4 * power(2, n - 3);\n      }\n      power(2, n - 1);\n    }\n  }\n}\n\nlemma StrongInduction(n: nat, P: nat -> bool)\n  requires forall k :: 0 <= k < n ==> P(k)\n  requires forall m :: m >= n && (forall j :: n <= j < m ==> P(j)) ==> P(m)\n  ensures P(n)\n{\n  // This demonstrates the strong induction principle\n  // Base case: all k < n satisfy P(k) by hypothesis\n  // Inductive case: if all j in [n, m) satisfy P, then P(m) holds\n\n  // The proof would proceed by showing P(n) directly\n  // using the second hypothesis with m = n\n  assert forall j :: n <= j < n ==> P(j); // Vacuously true\n}\n\nlemma CompleteInduction(n: nat, P: nat -> bool)\n  requires P(0)\n  requires forall k: nat :: k > 0 && (forall j: nat :: j < k ==> P(j)) ==> P(k)\n  ensures P(n)\n{\n  if n == 0 {\n    // Base case\n    assert P(0);\n  } else {\n    // Need to show all j < n satisfy P(j)\n    forall j: nat | j < n\n      ensures P(j)\n    {\n      if j == 0 {\n        assert P(0);\n      } else {\n        CompleteInduction(j, P);\n      }\n    }\n\n    // Now apply the inductive hypothesis\n    assert forall j: nat :: j < n ==> P(j);\n    assert P(n);\n  }\n}", "output": "assert exp1 < exp2;"}, {"id": "example_PowerMonotonic_6", "type": "assert", "program": "// Induction proofs with detailed reasoning steps\n\n// Sum of first n natural numbers\nfunction {:spec} sumTo(n: nat): nat\n{\n  if n == 0 then 0 else n + sumTo(n - 1)\n}\n\n// Sum of first n odd numbers\nfunction {:spec} sumOdds(n: nat): nat\n{\n  if n == 0 then 0 else (2 * n - 1) + sumOdds(n - 1)\n}\n\n// Sum of first n squares\nfunction {:spec} sumSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + sumSquares(n - 1)\n}\n\n// Power function\nfunction {:spec} power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\n// Fibonacci\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// --- Detailed Inductive Proofs ---\n\nlemma SumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    // Base case\n    assert sumTo(0) == 0;\n    assert 0 * (0 + 1) / 2 == 0;\n  } else {\n    // Inductive step\n    SumToFormula(n - 1);\n\n    calc == {\n      sumTo(n);\n      n + sumTo(n - 1);\n      { // Induction hypothesis\n        assert sumTo(n - 1) == (n - 1) * n / 2;\n      }\n      n + (n - 1) * n / 2;\n      { // Algebra\n        assert n == 2 * n / 2;\n      }\n      2 * n / 2 + (n - 1) * n / 2;\n      (2 * n + (n - 1) * n) / 2;\n      (2 * n + n * n - n) / 2;\n      (n + n * n) / 2;\n      n * (1 + n) / 2;\n      n * (n + 1) / 2;\n    }\n  }\n}\n\nlemma SumOddsIsSquare(n: nat)\n  ensures sumOdds(n) == n * n\n{\n  if n == 0 {\n    // Base case\n    assert sumOdds(0) == 0;\n    assert 0 * 0 == 0;\n  } else {\n    // Inductive step\n    SumOddsIsSquare(n - 1);\n\n    calc == {\n      sumOdds(n);\n      (2 * n - 1) + sumOdds(n - 1);\n      { // Induction hypothesis\n        assert sumOdds(n - 1) == (n - 1) * (n - 1);\n      }\n      (2 * n - 1) + (n - 1) * (n - 1);\n      { // Expand (n-1)\u00b2\n        assert (n - 1) * (n - 1) == n * n - 2 * n + 1;\n      }\n      (2 * n - 1) + (n * n - 2 * n + 1);\n      2 * n - 1 + n * n - 2 * n + 1;\n      n * n;\n    }\n  }\n}\n\nlemma SumSquaresFormula(n: nat)\n  ensures sumSquares(n) == n * (n + 1) * (2 * n + 1) / 6\n{\n  if n == 0 {\n    // Base case\n    assert sumSquares(0) == 0;\n    assert 0 * (0 + 1) * (2 * 0 + 1) / 6 == 0;\n  } else {\n    // Inductive step\n    SumSquaresFormula(n - 1);\n\n    calc == {\n      sumSquares(n);\n      n * n + sumSquares(n - 1);\n      { // Induction hypothesis\n        assert sumSquares(n - 1) == (n - 1) * n * (2 * n - 1) / 6;\n      }\n      n * n + (n - 1) * n * (2 * n - 1) / 6;\n      { // Factor out common terms\n        assert n * n == 6 * n * n / 6;\n      }\n      6 * n * n / 6 + (n - 1) * n * (2 * n - 1) / 6;\n      (6 * n * n + (n - 1) * n * (2 * n - 1)) / 6;\n      { // Expand\n        assert (n - 1) * n * (2 * n - 1) == n * (n - 1) * (2 * n - 1);\n        assert n * (n - 1) * (2 * n - 1) == n * (2 * n * n - 3 * n + 1);\n        assert n * (2 * n * n - 3 * n + 1) == 2 * n * n * n - 3 * n * n + n;\n      }\n      (6 * n * n + 2 * n * n * n - 3 * n * n + n) / 6;\n      (2 * n * n * n + 3 * n * n + n) / 6;\n      n * (2 * n * n + 3 * n + 1) / 6;\n      { // Factor\n        assert 2 * n * n + 3 * n + 1 == (n + 1) * (2 * n + 1);\n      }\n      n * (n + 1) * (2 * n + 1) / 6;\n    }\n  }\n}\n\nlemma PowerOfTwo(n: nat)\n  ensures power(2, n) >= n + 1\n{\n  if n == 0 {\n    // Base case\n    assert power(2, 0) == 1;\n    assert 1 >= 0 + 1;\n  } else {\n    // Inductive step\n    PowerOfTwo(n - 1);\n\n    calc >= {\n      power(2, n);\n      2 * power(2, n - 1);\n      { // Induction hypothesis\n        assert power(2, n - 1) >= n;\n      }\n      2 * n;\n      { // Since n >= 1\n        assert n >= 1;\n        assert 2 * n >= n + 1;\n      }\n      n + 1;\n    }\n  }\n}\n\nlemma PowerMonotonic(base: nat, exp1: nat, exp2: nat)\n  requires base > 1\n  requires exp1 <= exp2\n  ensures power(base, exp1) <= power(base, exp2)\n{\n  if exp1 == exp2 {\n    // Equal case\n    \n/*[CODE HERE]*/\n  } else {\n    // exp1 < exp2\n    assert exp1 < exp2;\n\n    if exp1 == 0 {\n      assert power(base, exp1) == 1;\n      PowerPositive(base, exp2);\n      assert power(base, exp2) >= 1;\n    } else {\n      // Both exp1 and exp2 are positive\n      PowerMonotonic(base, exp1 - 1, exp2 - 1);\n\n      calc <= {\n        power(base, exp1);\n        base * power(base, exp1 - 1);\n        { // Induction hypothesis\n          assert power(base, exp1 - 1) <= power(base, exp2 - 1);\n        }\n        base * power(base, exp2 - 1);\n        power(base, exp2);\n      }\n    }\n  }\n}\n\nlemma PowerPositive(base: nat, exp: nat)\n  requires base > 0\n  ensures power(base, exp) > 0\n{\n  if exp == 0 {\n    assert power(base, 0) == 1;\n  } else {\n    PowerPositive(base, exp - 1);\n    assert power(base, exp) == base * power(base, exp - 1);\n    assert base > 0 && power(base, exp - 1) > 0;\n  }\n}\n\nlemma FibonacciInequality(n: nat)\n  requires n >= 1\n  ensures fib(n) <= power(2, n - 1)\n{\n  if n == 1 {\n    // Base case\n    assert fib(1) == 1;\n    assert power(2, 0) == 1;\n  } else if n == 2 {\n    // Base case\n    assert fib(2) == 1;\n    assert power(2, 1) == 2;\n    assert 1 <= 2;\n  } else {\n    // Inductive step (n >= 3)\n    assert n >= 3;\n    FibonacciInequality(n - 1);\n    FibonacciInequality(n - 2);\n\n    calc <= {\n      fib(n);\n      fib(n - 1) + fib(n - 2);\n      { // Induction hypotheses\n        assert fib(n - 1) <= power(2, n - 2);\n        assert fib(n - 2) <= power(2, n - 3);\n      }\n      power(2, n - 2) + power(2, n - 3);\n      { // Factor out power(2, n - 3)\n        assert power(2, n - 2) == 2 * power(2, n - 3);\n      }\n      2 * power(2, n - 3) + power(2, n - 3);\n      3 * power(2, n - 3);\n      { // 3 * 2^(n-3) <= 4 * 2^(n-3) = 2^(n-1)\n        assert 3 <= 4;\n        assert power(2, n - 1) == 4 * power(2, n - 3);\n      }\n      power(2, n - 1);\n    }\n  }\n}\n\nlemma StrongInduction(n: nat, P: nat -> bool)\n  requires forall k :: 0 <= k < n ==> P(k)\n  requires forall m :: m >= n && (forall j :: n <= j < m ==> P(j)) ==> P(m)\n  ensures P(n)\n{\n  // This demonstrates the strong induction principle\n  // Base case: all k < n satisfy P(k) by hypothesis\n  // Inductive case: if all j in [n, m) satisfy P, then P(m) holds\n\n  // The proof would proceed by showing P(n) directly\n  // using the second hypothesis with m = n\n  assert forall j :: n <= j < n ==> P(j); // Vacuously true\n}\n\nlemma CompleteInduction(n: nat, P: nat -> bool)\n  requires P(0)\n  requires forall k: nat :: k > 0 && (forall j: nat :: j < k ==> P(j)) ==> P(k)\n  ensures P(n)\n{\n  if n == 0 {\n    // Base case\n    assert P(0);\n  } else {\n    // Need to show all j < n satisfy P(j)\n    forall j: nat | j < n\n      ensures P(j)\n    {\n      if j == 0 {\n        assert P(0);\n      } else {\n        CompleteInduction(j, P);\n      }\n    }\n\n    // Now apply the inductive hypothesis\n    assert forall j: nat :: j < n ==> P(j);\n    assert P(n);\n  }\n}", "output": "assert power(base, exp1) == power(base, exp2);"}, {"id": "example_PowerPositive_0", "type": "assert", "program": "// Induction proofs with detailed reasoning steps\n\n// Sum of first n natural numbers\nfunction {:spec} sumTo(n: nat): nat\n{\n  if n == 0 then 0 else n + sumTo(n - 1)\n}\n\n// Sum of first n odd numbers\nfunction {:spec} sumOdds(n: nat): nat\n{\n  if n == 0 then 0 else (2 * n - 1) + sumOdds(n - 1)\n}\n\n// Sum of first n squares\nfunction {:spec} sumSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + sumSquares(n - 1)\n}\n\n// Power function\nfunction {:spec} power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\n// Fibonacci\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// --- Detailed Inductive Proofs ---\n\nlemma SumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    // Base case\n    assert sumTo(0) == 0;\n    assert 0 * (0 + 1) / 2 == 0;\n  } else {\n    // Inductive step\n    SumToFormula(n - 1);\n\n    calc == {\n      sumTo(n);\n      n + sumTo(n - 1);\n      { // Induction hypothesis\n        assert sumTo(n - 1) == (n - 1) * n / 2;\n      }\n      n + (n - 1) * n / 2;\n      { // Algebra\n        assert n == 2 * n / 2;\n      }\n      2 * n / 2 + (n - 1) * n / 2;\n      (2 * n + (n - 1) * n) / 2;\n      (2 * n + n * n - n) / 2;\n      (n + n * n) / 2;\n      n * (1 + n) / 2;\n      n * (n + 1) / 2;\n    }\n  }\n}\n\nlemma SumOddsIsSquare(n: nat)\n  ensures sumOdds(n) == n * n\n{\n  if n == 0 {\n    // Base case\n    assert sumOdds(0) == 0;\n    assert 0 * 0 == 0;\n  } else {\n    // Inductive step\n    SumOddsIsSquare(n - 1);\n\n    calc == {\n      sumOdds(n);\n      (2 * n - 1) + sumOdds(n - 1);\n      { // Induction hypothesis\n        assert sumOdds(n - 1) == (n - 1) * (n - 1);\n      }\n      (2 * n - 1) + (n - 1) * (n - 1);\n      { // Expand (n-1)\u00b2\n        assert (n - 1) * (n - 1) == n * n - 2 * n + 1;\n      }\n      (2 * n - 1) + (n * n - 2 * n + 1);\n      2 * n - 1 + n * n - 2 * n + 1;\n      n * n;\n    }\n  }\n}\n\nlemma SumSquaresFormula(n: nat)\n  ensures sumSquares(n) == n * (n + 1) * (2 * n + 1) / 6\n{\n  if n == 0 {\n    // Base case\n    assert sumSquares(0) == 0;\n    assert 0 * (0 + 1) * (2 * 0 + 1) / 6 == 0;\n  } else {\n    // Inductive step\n    SumSquaresFormula(n - 1);\n\n    calc == {\n      sumSquares(n);\n      n * n + sumSquares(n - 1);\n      { // Induction hypothesis\n        assert sumSquares(n - 1) == (n - 1) * n * (2 * n - 1) / 6;\n      }\n      n * n + (n - 1) * n * (2 * n - 1) / 6;\n      { // Factor out common terms\n        assert n * n == 6 * n * n / 6;\n      }\n      6 * n * n / 6 + (n - 1) * n * (2 * n - 1) / 6;\n      (6 * n * n + (n - 1) * n * (2 * n - 1)) / 6;\n      { // Expand\n        assert (n - 1) * n * (2 * n - 1) == n * (n - 1) * (2 * n - 1);\n        assert n * (n - 1) * (2 * n - 1) == n * (2 * n * n - 3 * n + 1);\n        assert n * (2 * n * n - 3 * n + 1) == 2 * n * n * n - 3 * n * n + n;\n      }\n      (6 * n * n + 2 * n * n * n - 3 * n * n + n) / 6;\n      (2 * n * n * n + 3 * n * n + n) / 6;\n      n * (2 * n * n + 3 * n + 1) / 6;\n      { // Factor\n        assert 2 * n * n + 3 * n + 1 == (n + 1) * (2 * n + 1);\n      }\n      n * (n + 1) * (2 * n + 1) / 6;\n    }\n  }\n}\n\nlemma PowerOfTwo(n: nat)\n  ensures power(2, n) >= n + 1\n{\n  if n == 0 {\n    // Base case\n    assert power(2, 0) == 1;\n    assert 1 >= 0 + 1;\n  } else {\n    // Inductive step\n    PowerOfTwo(n - 1);\n\n    calc >= {\n      power(2, n);\n      2 * power(2, n - 1);\n      { // Induction hypothesis\n        assert power(2, n - 1) >= n;\n      }\n      2 * n;\n      { // Since n >= 1\n        assert n >= 1;\n        assert 2 * n >= n + 1;\n      }\n      n + 1;\n    }\n  }\n}\n\nlemma PowerMonotonic(base: nat, exp1: nat, exp2: nat)\n  requires base > 1\n  requires exp1 <= exp2\n  ensures power(base, exp1) <= power(base, exp2)\n{\n  if exp1 == exp2 {\n    // Equal case\n    assert power(base, exp1) == power(base, exp2);\n  } else {\n    // exp1 < exp2\n    assert exp1 < exp2;\n\n    if exp1 == 0 {\n      assert power(base, exp1) == 1;\n      PowerPositive(base, exp2);\n      assert power(base, exp2) >= 1;\n    } else {\n      // Both exp1 and exp2 are positive\n      PowerMonotonic(base, exp1 - 1, exp2 - 1);\n\n      calc <= {\n        power(base, exp1);\n        base * power(base, exp1 - 1);\n        { // Induction hypothesis\n          assert power(base, exp1 - 1) <= power(base, exp2 - 1);\n        }\n        base * power(base, exp2 - 1);\n        power(base, exp2);\n      }\n    }\n  }\n}\n\nlemma PowerPositive(base: nat, exp: nat)\n  requires base > 0\n  ensures power(base, exp) > 0\n{\n  if exp == 0 {\n    assert power(base, 0) == 1;\n  } else {\n    PowerPositive(base, exp - 1);\n    assert power(base, exp) == base * power(base, exp - 1);\n    \n/*[CODE HERE]*/\n  }\n}\n\nlemma FibonacciInequality(n: nat)\n  requires n >= 1\n  ensures fib(n) <= power(2, n - 1)\n{\n  if n == 1 {\n    // Base case\n    assert fib(1) == 1;\n    assert power(2, 0) == 1;\n  } else if n == 2 {\n    // Base case\n    assert fib(2) == 1;\n    assert power(2, 1) == 2;\n    assert 1 <= 2;\n  } else {\n    // Inductive step (n >= 3)\n    assert n >= 3;\n    FibonacciInequality(n - 1);\n    FibonacciInequality(n - 2);\n\n    calc <= {\n      fib(n);\n      fib(n - 1) + fib(n - 2);\n      { // Induction hypotheses\n        assert fib(n - 1) <= power(2, n - 2);\n        assert fib(n - 2) <= power(2, n - 3);\n      }\n      power(2, n - 2) + power(2, n - 3);\n      { // Factor out power(2, n - 3)\n        assert power(2, n - 2) == 2 * power(2, n - 3);\n      }\n      2 * power(2, n - 3) + power(2, n - 3);\n      3 * power(2, n - 3);\n      { // 3 * 2^(n-3) <= 4 * 2^(n-3) = 2^(n-1)\n        assert 3 <= 4;\n        assert power(2, n - 1) == 4 * power(2, n - 3);\n      }\n      power(2, n - 1);\n    }\n  }\n}\n\nlemma StrongInduction(n: nat, P: nat -> bool)\n  requires forall k :: 0 <= k < n ==> P(k)\n  requires forall m :: m >= n && (forall j :: n <= j < m ==> P(j)) ==> P(m)\n  ensures P(n)\n{\n  // This demonstrates the strong induction principle\n  // Base case: all k < n satisfy P(k) by hypothesis\n  // Inductive case: if all j in [n, m) satisfy P, then P(m) holds\n\n  // The proof would proceed by showing P(n) directly\n  // using the second hypothesis with m = n\n  assert forall j :: n <= j < n ==> P(j); // Vacuously true\n}\n\nlemma CompleteInduction(n: nat, P: nat -> bool)\n  requires P(0)\n  requires forall k: nat :: k > 0 && (forall j: nat :: j < k ==> P(j)) ==> P(k)\n  ensures P(n)\n{\n  if n == 0 {\n    // Base case\n    assert P(0);\n  } else {\n    // Need to show all j < n satisfy P(j)\n    forall j: nat | j < n\n      ensures P(j)\n    {\n      if j == 0 {\n        assert P(0);\n      } else {\n        CompleteInduction(j, P);\n      }\n    }\n\n    // Now apply the inductive hypothesis\n    assert forall j: nat :: j < n ==> P(j);\n    assert P(n);\n  }\n}", "output": "assert base > 0 && power(base, exp - 1) > 0;"}, {"id": "example_PowerPositive_1", "type": "assert", "program": "// Induction proofs with detailed reasoning steps\n\n// Sum of first n natural numbers\nfunction {:spec} sumTo(n: nat): nat\n{\n  if n == 0 then 0 else n + sumTo(n - 1)\n}\n\n// Sum of first n odd numbers\nfunction {:spec} sumOdds(n: nat): nat\n{\n  if n == 0 then 0 else (2 * n - 1) + sumOdds(n - 1)\n}\n\n// Sum of first n squares\nfunction {:spec} sumSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + sumSquares(n - 1)\n}\n\n// Power function\nfunction {:spec} power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\n// Fibonacci\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// --- Detailed Inductive Proofs ---\n\nlemma SumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    // Base case\n    assert sumTo(0) == 0;\n    assert 0 * (0 + 1) / 2 == 0;\n  } else {\n    // Inductive step\n    SumToFormula(n - 1);\n\n    calc == {\n      sumTo(n);\n      n + sumTo(n - 1);\n      { // Induction hypothesis\n        assert sumTo(n - 1) == (n - 1) * n / 2;\n      }\n      n + (n - 1) * n / 2;\n      { // Algebra\n        assert n == 2 * n / 2;\n      }\n      2 * n / 2 + (n - 1) * n / 2;\n      (2 * n + (n - 1) * n) / 2;\n      (2 * n + n * n - n) / 2;\n      (n + n * n) / 2;\n      n * (1 + n) / 2;\n      n * (n + 1) / 2;\n    }\n  }\n}\n\nlemma SumOddsIsSquare(n: nat)\n  ensures sumOdds(n) == n * n\n{\n  if n == 0 {\n    // Base case\n    assert sumOdds(0) == 0;\n    assert 0 * 0 == 0;\n  } else {\n    // Inductive step\n    SumOddsIsSquare(n - 1);\n\n    calc == {\n      sumOdds(n);\n      (2 * n - 1) + sumOdds(n - 1);\n      { // Induction hypothesis\n        assert sumOdds(n - 1) == (n - 1) * (n - 1);\n      }\n      (2 * n - 1) + (n - 1) * (n - 1);\n      { // Expand (n-1)\u00b2\n        assert (n - 1) * (n - 1) == n * n - 2 * n + 1;\n      }\n      (2 * n - 1) + (n * n - 2 * n + 1);\n      2 * n - 1 + n * n - 2 * n + 1;\n      n * n;\n    }\n  }\n}\n\nlemma SumSquaresFormula(n: nat)\n  ensures sumSquares(n) == n * (n + 1) * (2 * n + 1) / 6\n{\n  if n == 0 {\n    // Base case\n    assert sumSquares(0) == 0;\n    assert 0 * (0 + 1) * (2 * 0 + 1) / 6 == 0;\n  } else {\n    // Inductive step\n    SumSquaresFormula(n - 1);\n\n    calc == {\n      sumSquares(n);\n      n * n + sumSquares(n - 1);\n      { // Induction hypothesis\n        assert sumSquares(n - 1) == (n - 1) * n * (2 * n - 1) / 6;\n      }\n      n * n + (n - 1) * n * (2 * n - 1) / 6;\n      { // Factor out common terms\n        assert n * n == 6 * n * n / 6;\n      }\n      6 * n * n / 6 + (n - 1) * n * (2 * n - 1) / 6;\n      (6 * n * n + (n - 1) * n * (2 * n - 1)) / 6;\n      { // Expand\n        assert (n - 1) * n * (2 * n - 1) == n * (n - 1) * (2 * n - 1);\n        assert n * (n - 1) * (2 * n - 1) == n * (2 * n * n - 3 * n + 1);\n        assert n * (2 * n * n - 3 * n + 1) == 2 * n * n * n - 3 * n * n + n;\n      }\n      (6 * n * n + 2 * n * n * n - 3 * n * n + n) / 6;\n      (2 * n * n * n + 3 * n * n + n) / 6;\n      n * (2 * n * n + 3 * n + 1) / 6;\n      { // Factor\n        assert 2 * n * n + 3 * n + 1 == (n + 1) * (2 * n + 1);\n      }\n      n * (n + 1) * (2 * n + 1) / 6;\n    }\n  }\n}\n\nlemma PowerOfTwo(n: nat)\n  ensures power(2, n) >= n + 1\n{\n  if n == 0 {\n    // Base case\n    assert power(2, 0) == 1;\n    assert 1 >= 0 + 1;\n  } else {\n    // Inductive step\n    PowerOfTwo(n - 1);\n\n    calc >= {\n      power(2, n);\n      2 * power(2, n - 1);\n      { // Induction hypothesis\n        assert power(2, n - 1) >= n;\n      }\n      2 * n;\n      { // Since n >= 1\n        assert n >= 1;\n        assert 2 * n >= n + 1;\n      }\n      n + 1;\n    }\n  }\n}\n\nlemma PowerMonotonic(base: nat, exp1: nat, exp2: nat)\n  requires base > 1\n  requires exp1 <= exp2\n  ensures power(base, exp1) <= power(base, exp2)\n{\n  if exp1 == exp2 {\n    // Equal case\n    assert power(base, exp1) == power(base, exp2);\n  } else {\n    // exp1 < exp2\n    assert exp1 < exp2;\n\n    if exp1 == 0 {\n      assert power(base, exp1) == 1;\n      PowerPositive(base, exp2);\n      assert power(base, exp2) >= 1;\n    } else {\n      // Both exp1 and exp2 are positive\n      PowerMonotonic(base, exp1 - 1, exp2 - 1);\n\n      calc <= {\n        power(base, exp1);\n        base * power(base, exp1 - 1);\n        { // Induction hypothesis\n          assert power(base, exp1 - 1) <= power(base, exp2 - 1);\n        }\n        base * power(base, exp2 - 1);\n        power(base, exp2);\n      }\n    }\n  }\n}\n\nlemma PowerPositive(base: nat, exp: nat)\n  requires base > 0\n  ensures power(base, exp) > 0\n{\n  if exp == 0 {\n    assert power(base, 0) == 1;\n  } else {\n    PowerPositive(base, exp - 1);\n    \n/*[CODE HERE]*/\n    assert base > 0 && power(base, exp - 1) > 0;\n  }\n}\n\nlemma FibonacciInequality(n: nat)\n  requires n >= 1\n  ensures fib(n) <= power(2, n - 1)\n{\n  if n == 1 {\n    // Base case\n    assert fib(1) == 1;\n    assert power(2, 0) == 1;\n  } else if n == 2 {\n    // Base case\n    assert fib(2) == 1;\n    assert power(2, 1) == 2;\n    assert 1 <= 2;\n  } else {\n    // Inductive step (n >= 3)\n    assert n >= 3;\n    FibonacciInequality(n - 1);\n    FibonacciInequality(n - 2);\n\n    calc <= {\n      fib(n);\n      fib(n - 1) + fib(n - 2);\n      { // Induction hypotheses\n        assert fib(n - 1) <= power(2, n - 2);\n        assert fib(n - 2) <= power(2, n - 3);\n      }\n      power(2, n - 2) + power(2, n - 3);\n      { // Factor out power(2, n - 3)\n        assert power(2, n - 2) == 2 * power(2, n - 3);\n      }\n      2 * power(2, n - 3) + power(2, n - 3);\n      3 * power(2, n - 3);\n      { // 3 * 2^(n-3) <= 4 * 2^(n-3) = 2^(n-1)\n        assert 3 <= 4;\n        assert power(2, n - 1) == 4 * power(2, n - 3);\n      }\n      power(2, n - 1);\n    }\n  }\n}\n\nlemma StrongInduction(n: nat, P: nat -> bool)\n  requires forall k :: 0 <= k < n ==> P(k)\n  requires forall m :: m >= n && (forall j :: n <= j < m ==> P(j)) ==> P(m)\n  ensures P(n)\n{\n  // This demonstrates the strong induction principle\n  // Base case: all k < n satisfy P(k) by hypothesis\n  // Inductive case: if all j in [n, m) satisfy P, then P(m) holds\n\n  // The proof would proceed by showing P(n) directly\n  // using the second hypothesis with m = n\n  assert forall j :: n <= j < n ==> P(j); // Vacuously true\n}\n\nlemma CompleteInduction(n: nat, P: nat -> bool)\n  requires P(0)\n  requires forall k: nat :: k > 0 && (forall j: nat :: j < k ==> P(j)) ==> P(k)\n  ensures P(n)\n{\n  if n == 0 {\n    // Base case\n    assert P(0);\n  } else {\n    // Need to show all j < n satisfy P(j)\n    forall j: nat | j < n\n      ensures P(j)\n    {\n      if j == 0 {\n        assert P(0);\n      } else {\n        CompleteInduction(j, P);\n      }\n    }\n\n    // Now apply the inductive hypothesis\n    assert forall j: nat :: j < n ==> P(j);\n    assert P(n);\n  }\n}", "output": "assert power(base, exp) == base * power(base, exp - 1);"}, {"id": "example_PowerPositive_2", "type": "call", "program": "// Induction proofs with detailed reasoning steps\n\n// Sum of first n natural numbers\nfunction {:spec} sumTo(n: nat): nat\n{\n  if n == 0 then 0 else n + sumTo(n - 1)\n}\n\n// Sum of first n odd numbers\nfunction {:spec} sumOdds(n: nat): nat\n{\n  if n == 0 then 0 else (2 * n - 1) + sumOdds(n - 1)\n}\n\n// Sum of first n squares\nfunction {:spec} sumSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + sumSquares(n - 1)\n}\n\n// Power function\nfunction {:spec} power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\n// Fibonacci\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// --- Detailed Inductive Proofs ---\n\nlemma SumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    // Base case\n    assert sumTo(0) == 0;\n    assert 0 * (0 + 1) / 2 == 0;\n  } else {\n    // Inductive step\n    SumToFormula(n - 1);\n\n    calc == {\n      sumTo(n);\n      n + sumTo(n - 1);\n      { // Induction hypothesis\n        assert sumTo(n - 1) == (n - 1) * n / 2;\n      }\n      n + (n - 1) * n / 2;\n      { // Algebra\n        assert n == 2 * n / 2;\n      }\n      2 * n / 2 + (n - 1) * n / 2;\n      (2 * n + (n - 1) * n) / 2;\n      (2 * n + n * n - n) / 2;\n      (n + n * n) / 2;\n      n * (1 + n) / 2;\n      n * (n + 1) / 2;\n    }\n  }\n}\n\nlemma SumOddsIsSquare(n: nat)\n  ensures sumOdds(n) == n * n\n{\n  if n == 0 {\n    // Base case\n    assert sumOdds(0) == 0;\n    assert 0 * 0 == 0;\n  } else {\n    // Inductive step\n    SumOddsIsSquare(n - 1);\n\n    calc == {\n      sumOdds(n);\n      (2 * n - 1) + sumOdds(n - 1);\n      { // Induction hypothesis\n        assert sumOdds(n - 1) == (n - 1) * (n - 1);\n      }\n      (2 * n - 1) + (n - 1) * (n - 1);\n      { // Expand (n-1)\u00b2\n        assert (n - 1) * (n - 1) == n * n - 2 * n + 1;\n      }\n      (2 * n - 1) + (n * n - 2 * n + 1);\n      2 * n - 1 + n * n - 2 * n + 1;\n      n * n;\n    }\n  }\n}\n\nlemma SumSquaresFormula(n: nat)\n  ensures sumSquares(n) == n * (n + 1) * (2 * n + 1) / 6\n{\n  if n == 0 {\n    // Base case\n    assert sumSquares(0) == 0;\n    assert 0 * (0 + 1) * (2 * 0 + 1) / 6 == 0;\n  } else {\n    // Inductive step\n    SumSquaresFormula(n - 1);\n\n    calc == {\n      sumSquares(n);\n      n * n + sumSquares(n - 1);\n      { // Induction hypothesis\n        assert sumSquares(n - 1) == (n - 1) * n * (2 * n - 1) / 6;\n      }\n      n * n + (n - 1) * n * (2 * n - 1) / 6;\n      { // Factor out common terms\n        assert n * n == 6 * n * n / 6;\n      }\n      6 * n * n / 6 + (n - 1) * n * (2 * n - 1) / 6;\n      (6 * n * n + (n - 1) * n * (2 * n - 1)) / 6;\n      { // Expand\n        assert (n - 1) * n * (2 * n - 1) == n * (n - 1) * (2 * n - 1);\n        assert n * (n - 1) * (2 * n - 1) == n * (2 * n * n - 3 * n + 1);\n        assert n * (2 * n * n - 3 * n + 1) == 2 * n * n * n - 3 * n * n + n;\n      }\n      (6 * n * n + 2 * n * n * n - 3 * n * n + n) / 6;\n      (2 * n * n * n + 3 * n * n + n) / 6;\n      n * (2 * n * n + 3 * n + 1) / 6;\n      { // Factor\n        assert 2 * n * n + 3 * n + 1 == (n + 1) * (2 * n + 1);\n      }\n      n * (n + 1) * (2 * n + 1) / 6;\n    }\n  }\n}\n\nlemma PowerOfTwo(n: nat)\n  ensures power(2, n) >= n + 1\n{\n  if n == 0 {\n    // Base case\n    assert power(2, 0) == 1;\n    assert 1 >= 0 + 1;\n  } else {\n    // Inductive step\n    PowerOfTwo(n - 1);\n\n    calc >= {\n      power(2, n);\n      2 * power(2, n - 1);\n      { // Induction hypothesis\n        assert power(2, n - 1) >= n;\n      }\n      2 * n;\n      { // Since n >= 1\n        assert n >= 1;\n        assert 2 * n >= n + 1;\n      }\n      n + 1;\n    }\n  }\n}\n\nlemma PowerMonotonic(base: nat, exp1: nat, exp2: nat)\n  requires base > 1\n  requires exp1 <= exp2\n  ensures power(base, exp1) <= power(base, exp2)\n{\n  if exp1 == exp2 {\n    // Equal case\n    assert power(base, exp1) == power(base, exp2);\n  } else {\n    // exp1 < exp2\n    assert exp1 < exp2;\n\n    if exp1 == 0 {\n      assert power(base, exp1) == 1;\n      PowerPositive(base, exp2);\n      assert power(base, exp2) >= 1;\n    } else {\n      // Both exp1 and exp2 are positive\n      PowerMonotonic(base, exp1 - 1, exp2 - 1);\n\n      calc <= {\n        power(base, exp1);\n        base * power(base, exp1 - 1);\n        { // Induction hypothesis\n          assert power(base, exp1 - 1) <= power(base, exp2 - 1);\n        }\n        base * power(base, exp2 - 1);\n        power(base, exp2);\n      }\n    }\n  }\n}\n\nlemma PowerPositive(base: nat, exp: nat)\n  requires base > 0\n  ensures power(base, exp) > 0\n{\n  if exp == 0 {\n    assert power(base, 0) == 1;\n  } else {\n    \n/*[CODE HERE]*/\n    assert power(base, exp) == base * power(base, exp - 1);\n    assert base > 0 && power(base, exp - 1) > 0;\n  }\n}\n\nlemma FibonacciInequality(n: nat)\n  requires n >= 1\n  ensures fib(n) <= power(2, n - 1)\n{\n  if n == 1 {\n    // Base case\n    assert fib(1) == 1;\n    assert power(2, 0) == 1;\n  } else if n == 2 {\n    // Base case\n    assert fib(2) == 1;\n    assert power(2, 1) == 2;\n    assert 1 <= 2;\n  } else {\n    // Inductive step (n >= 3)\n    assert n >= 3;\n    FibonacciInequality(n - 1);\n    FibonacciInequality(n - 2);\n\n    calc <= {\n      fib(n);\n      fib(n - 1) + fib(n - 2);\n      { // Induction hypotheses\n        assert fib(n - 1) <= power(2, n - 2);\n        assert fib(n - 2) <= power(2, n - 3);\n      }\n      power(2, n - 2) + power(2, n - 3);\n      { // Factor out power(2, n - 3)\n        assert power(2, n - 2) == 2 * power(2, n - 3);\n      }\n      2 * power(2, n - 3) + power(2, n - 3);\n      3 * power(2, n - 3);\n      { // 3 * 2^(n-3) <= 4 * 2^(n-3) = 2^(n-1)\n        assert 3 <= 4;\n        assert power(2, n - 1) == 4 * power(2, n - 3);\n      }\n      power(2, n - 1);\n    }\n  }\n}\n\nlemma StrongInduction(n: nat, P: nat -> bool)\n  requires forall k :: 0 <= k < n ==> P(k)\n  requires forall m :: m >= n && (forall j :: n <= j < m ==> P(j)) ==> P(m)\n  ensures P(n)\n{\n  // This demonstrates the strong induction principle\n  // Base case: all k < n satisfy P(k) by hypothesis\n  // Inductive case: if all j in [n, m) satisfy P, then P(m) holds\n\n  // The proof would proceed by showing P(n) directly\n  // using the second hypothesis with m = n\n  assert forall j :: n <= j < n ==> P(j); // Vacuously true\n}\n\nlemma CompleteInduction(n: nat, P: nat -> bool)\n  requires P(0)\n  requires forall k: nat :: k > 0 && (forall j: nat :: j < k ==> P(j)) ==> P(k)\n  ensures P(n)\n{\n  if n == 0 {\n    // Base case\n    assert P(0);\n  } else {\n    // Need to show all j < n satisfy P(j)\n    forall j: nat | j < n\n      ensures P(j)\n    {\n      if j == 0 {\n        assert P(0);\n      } else {\n        CompleteInduction(j, P);\n      }\n    }\n\n    // Now apply the inductive hypothesis\n    assert forall j: nat :: j < n ==> P(j);\n    assert P(n);\n  }\n}", "output": "PowerPositive(base, exp - 1);"}, {"id": "example_PowerPositive_3", "type": "assert", "program": "// Induction proofs with detailed reasoning steps\n\n// Sum of first n natural numbers\nfunction {:spec} sumTo(n: nat): nat\n{\n  if n == 0 then 0 else n + sumTo(n - 1)\n}\n\n// Sum of first n odd numbers\nfunction {:spec} sumOdds(n: nat): nat\n{\n  if n == 0 then 0 else (2 * n - 1) + sumOdds(n - 1)\n}\n\n// Sum of first n squares\nfunction {:spec} sumSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + sumSquares(n - 1)\n}\n\n// Power function\nfunction {:spec} power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\n// Fibonacci\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// --- Detailed Inductive Proofs ---\n\nlemma SumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    // Base case\n    assert sumTo(0) == 0;\n    assert 0 * (0 + 1) / 2 == 0;\n  } else {\n    // Inductive step\n    SumToFormula(n - 1);\n\n    calc == {\n      sumTo(n);\n      n + sumTo(n - 1);\n      { // Induction hypothesis\n        assert sumTo(n - 1) == (n - 1) * n / 2;\n      }\n      n + (n - 1) * n / 2;\n      { // Algebra\n        assert n == 2 * n / 2;\n      }\n      2 * n / 2 + (n - 1) * n / 2;\n      (2 * n + (n - 1) * n) / 2;\n      (2 * n + n * n - n) / 2;\n      (n + n * n) / 2;\n      n * (1 + n) / 2;\n      n * (n + 1) / 2;\n    }\n  }\n}\n\nlemma SumOddsIsSquare(n: nat)\n  ensures sumOdds(n) == n * n\n{\n  if n == 0 {\n    // Base case\n    assert sumOdds(0) == 0;\n    assert 0 * 0 == 0;\n  } else {\n    // Inductive step\n    SumOddsIsSquare(n - 1);\n\n    calc == {\n      sumOdds(n);\n      (2 * n - 1) + sumOdds(n - 1);\n      { // Induction hypothesis\n        assert sumOdds(n - 1) == (n - 1) * (n - 1);\n      }\n      (2 * n - 1) + (n - 1) * (n - 1);\n      { // Expand (n-1)\u00b2\n        assert (n - 1) * (n - 1) == n * n - 2 * n + 1;\n      }\n      (2 * n - 1) + (n * n - 2 * n + 1);\n      2 * n - 1 + n * n - 2 * n + 1;\n      n * n;\n    }\n  }\n}\n\nlemma SumSquaresFormula(n: nat)\n  ensures sumSquares(n) == n * (n + 1) * (2 * n + 1) / 6\n{\n  if n == 0 {\n    // Base case\n    assert sumSquares(0) == 0;\n    assert 0 * (0 + 1) * (2 * 0 + 1) / 6 == 0;\n  } else {\n    // Inductive step\n    SumSquaresFormula(n - 1);\n\n    calc == {\n      sumSquares(n);\n      n * n + sumSquares(n - 1);\n      { // Induction hypothesis\n        assert sumSquares(n - 1) == (n - 1) * n * (2 * n - 1) / 6;\n      }\n      n * n + (n - 1) * n * (2 * n - 1) / 6;\n      { // Factor out common terms\n        assert n * n == 6 * n * n / 6;\n      }\n      6 * n * n / 6 + (n - 1) * n * (2 * n - 1) / 6;\n      (6 * n * n + (n - 1) * n * (2 * n - 1)) / 6;\n      { // Expand\n        assert (n - 1) * n * (2 * n - 1) == n * (n - 1) * (2 * n - 1);\n        assert n * (n - 1) * (2 * n - 1) == n * (2 * n * n - 3 * n + 1);\n        assert n * (2 * n * n - 3 * n + 1) == 2 * n * n * n - 3 * n * n + n;\n      }\n      (6 * n * n + 2 * n * n * n - 3 * n * n + n) / 6;\n      (2 * n * n * n + 3 * n * n + n) / 6;\n      n * (2 * n * n + 3 * n + 1) / 6;\n      { // Factor\n        assert 2 * n * n + 3 * n + 1 == (n + 1) * (2 * n + 1);\n      }\n      n * (n + 1) * (2 * n + 1) / 6;\n    }\n  }\n}\n\nlemma PowerOfTwo(n: nat)\n  ensures power(2, n) >= n + 1\n{\n  if n == 0 {\n    // Base case\n    assert power(2, 0) == 1;\n    assert 1 >= 0 + 1;\n  } else {\n    // Inductive step\n    PowerOfTwo(n - 1);\n\n    calc >= {\n      power(2, n);\n      2 * power(2, n - 1);\n      { // Induction hypothesis\n        assert power(2, n - 1) >= n;\n      }\n      2 * n;\n      { // Since n >= 1\n        assert n >= 1;\n        assert 2 * n >= n + 1;\n      }\n      n + 1;\n    }\n  }\n}\n\nlemma PowerMonotonic(base: nat, exp1: nat, exp2: nat)\n  requires base > 1\n  requires exp1 <= exp2\n  ensures power(base, exp1) <= power(base, exp2)\n{\n  if exp1 == exp2 {\n    // Equal case\n    assert power(base, exp1) == power(base, exp2);\n  } else {\n    // exp1 < exp2\n    assert exp1 < exp2;\n\n    if exp1 == 0 {\n      assert power(base, exp1) == 1;\n      PowerPositive(base, exp2);\n      assert power(base, exp2) >= 1;\n    } else {\n      // Both exp1 and exp2 are positive\n      PowerMonotonic(base, exp1 - 1, exp2 - 1);\n\n      calc <= {\n        power(base, exp1);\n        base * power(base, exp1 - 1);\n        { // Induction hypothesis\n          assert power(base, exp1 - 1) <= power(base, exp2 - 1);\n        }\n        base * power(base, exp2 - 1);\n        power(base, exp2);\n      }\n    }\n  }\n}\n\nlemma PowerPositive(base: nat, exp: nat)\n  requires base > 0\n  ensures power(base, exp) > 0\n{\n  if exp == 0 {\n    \n/*[CODE HERE]*/\n  } else {\n    PowerPositive(base, exp - 1);\n    assert power(base, exp) == base * power(base, exp - 1);\n    assert base > 0 && power(base, exp - 1) > 0;\n  }\n}\n\nlemma FibonacciInequality(n: nat)\n  requires n >= 1\n  ensures fib(n) <= power(2, n - 1)\n{\n  if n == 1 {\n    // Base case\n    assert fib(1) == 1;\n    assert power(2, 0) == 1;\n  } else if n == 2 {\n    // Base case\n    assert fib(2) == 1;\n    assert power(2, 1) == 2;\n    assert 1 <= 2;\n  } else {\n    // Inductive step (n >= 3)\n    assert n >= 3;\n    FibonacciInequality(n - 1);\n    FibonacciInequality(n - 2);\n\n    calc <= {\n      fib(n);\n      fib(n - 1) + fib(n - 2);\n      { // Induction hypotheses\n        assert fib(n - 1) <= power(2, n - 2);\n        assert fib(n - 2) <= power(2, n - 3);\n      }\n      power(2, n - 2) + power(2, n - 3);\n      { // Factor out power(2, n - 3)\n        assert power(2, n - 2) == 2 * power(2, n - 3);\n      }\n      2 * power(2, n - 3) + power(2, n - 3);\n      3 * power(2, n - 3);\n      { // 3 * 2^(n-3) <= 4 * 2^(n-3) = 2^(n-1)\n        assert 3 <= 4;\n        assert power(2, n - 1) == 4 * power(2, n - 3);\n      }\n      power(2, n - 1);\n    }\n  }\n}\n\nlemma StrongInduction(n: nat, P: nat -> bool)\n  requires forall k :: 0 <= k < n ==> P(k)\n  requires forall m :: m >= n && (forall j :: n <= j < m ==> P(j)) ==> P(m)\n  ensures P(n)\n{\n  // This demonstrates the strong induction principle\n  // Base case: all k < n satisfy P(k) by hypothesis\n  // Inductive case: if all j in [n, m) satisfy P, then P(m) holds\n\n  // The proof would proceed by showing P(n) directly\n  // using the second hypothesis with m = n\n  assert forall j :: n <= j < n ==> P(j); // Vacuously true\n}\n\nlemma CompleteInduction(n: nat, P: nat -> bool)\n  requires P(0)\n  requires forall k: nat :: k > 0 && (forall j: nat :: j < k ==> P(j)) ==> P(k)\n  ensures P(n)\n{\n  if n == 0 {\n    // Base case\n    assert P(0);\n  } else {\n    // Need to show all j < n satisfy P(j)\n    forall j: nat | j < n\n      ensures P(j)\n    {\n      if j == 0 {\n        assert P(0);\n      } else {\n        CompleteInduction(j, P);\n      }\n    }\n\n    // Now apply the inductive hypothesis\n    assert forall j: nat :: j < n ==> P(j);\n    assert P(n);\n  }\n}", "output": "assert power(base, 0) == 1;"}, {"id": "example_FibonacciInequality_0", "type": "assert", "program": "// Induction proofs with detailed reasoning steps\n\n// Sum of first n natural numbers\nfunction {:spec} sumTo(n: nat): nat\n{\n  if n == 0 then 0 else n + sumTo(n - 1)\n}\n\n// Sum of first n odd numbers\nfunction {:spec} sumOdds(n: nat): nat\n{\n  if n == 0 then 0 else (2 * n - 1) + sumOdds(n - 1)\n}\n\n// Sum of first n squares\nfunction {:spec} sumSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + sumSquares(n - 1)\n}\n\n// Power function\nfunction {:spec} power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\n// Fibonacci\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// --- Detailed Inductive Proofs ---\n\nlemma SumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    // Base case\n    assert sumTo(0) == 0;\n    assert 0 * (0 + 1) / 2 == 0;\n  } else {\n    // Inductive step\n    SumToFormula(n - 1);\n\n    calc == {\n      sumTo(n);\n      n + sumTo(n - 1);\n      { // Induction hypothesis\n        assert sumTo(n - 1) == (n - 1) * n / 2;\n      }\n      n + (n - 1) * n / 2;\n      { // Algebra\n        assert n == 2 * n / 2;\n      }\n      2 * n / 2 + (n - 1) * n / 2;\n      (2 * n + (n - 1) * n) / 2;\n      (2 * n + n * n - n) / 2;\n      (n + n * n) / 2;\n      n * (1 + n) / 2;\n      n * (n + 1) / 2;\n    }\n  }\n}\n\nlemma SumOddsIsSquare(n: nat)\n  ensures sumOdds(n) == n * n\n{\n  if n == 0 {\n    // Base case\n    assert sumOdds(0) == 0;\n    assert 0 * 0 == 0;\n  } else {\n    // Inductive step\n    SumOddsIsSquare(n - 1);\n\n    calc == {\n      sumOdds(n);\n      (2 * n - 1) + sumOdds(n - 1);\n      { // Induction hypothesis\n        assert sumOdds(n - 1) == (n - 1) * (n - 1);\n      }\n      (2 * n - 1) + (n - 1) * (n - 1);\n      { // Expand (n-1)\u00b2\n        assert (n - 1) * (n - 1) == n * n - 2 * n + 1;\n      }\n      (2 * n - 1) + (n * n - 2 * n + 1);\n      2 * n - 1 + n * n - 2 * n + 1;\n      n * n;\n    }\n  }\n}\n\nlemma SumSquaresFormula(n: nat)\n  ensures sumSquares(n) == n * (n + 1) * (2 * n + 1) / 6\n{\n  if n == 0 {\n    // Base case\n    assert sumSquares(0) == 0;\n    assert 0 * (0 + 1) * (2 * 0 + 1) / 6 == 0;\n  } else {\n    // Inductive step\n    SumSquaresFormula(n - 1);\n\n    calc == {\n      sumSquares(n);\n      n * n + sumSquares(n - 1);\n      { // Induction hypothesis\n        assert sumSquares(n - 1) == (n - 1) * n * (2 * n - 1) / 6;\n      }\n      n * n + (n - 1) * n * (2 * n - 1) / 6;\n      { // Factor out common terms\n        assert n * n == 6 * n * n / 6;\n      }\n      6 * n * n / 6 + (n - 1) * n * (2 * n - 1) / 6;\n      (6 * n * n + (n - 1) * n * (2 * n - 1)) / 6;\n      { // Expand\n        assert (n - 1) * n * (2 * n - 1) == n * (n - 1) * (2 * n - 1);\n        assert n * (n - 1) * (2 * n - 1) == n * (2 * n * n - 3 * n + 1);\n        assert n * (2 * n * n - 3 * n + 1) == 2 * n * n * n - 3 * n * n + n;\n      }\n      (6 * n * n + 2 * n * n * n - 3 * n * n + n) / 6;\n      (2 * n * n * n + 3 * n * n + n) / 6;\n      n * (2 * n * n + 3 * n + 1) / 6;\n      { // Factor\n        assert 2 * n * n + 3 * n + 1 == (n + 1) * (2 * n + 1);\n      }\n      n * (n + 1) * (2 * n + 1) / 6;\n    }\n  }\n}\n\nlemma PowerOfTwo(n: nat)\n  ensures power(2, n) >= n + 1\n{\n  if n == 0 {\n    // Base case\n    assert power(2, 0) == 1;\n    assert 1 >= 0 + 1;\n  } else {\n    // Inductive step\n    PowerOfTwo(n - 1);\n\n    calc >= {\n      power(2, n);\n      2 * power(2, n - 1);\n      { // Induction hypothesis\n        assert power(2, n - 1) >= n;\n      }\n      2 * n;\n      { // Since n >= 1\n        assert n >= 1;\n        assert 2 * n >= n + 1;\n      }\n      n + 1;\n    }\n  }\n}\n\nlemma PowerMonotonic(base: nat, exp1: nat, exp2: nat)\n  requires base > 1\n  requires exp1 <= exp2\n  ensures power(base, exp1) <= power(base, exp2)\n{\n  if exp1 == exp2 {\n    // Equal case\n    assert power(base, exp1) == power(base, exp2);\n  } else {\n    // exp1 < exp2\n    assert exp1 < exp2;\n\n    if exp1 == 0 {\n      assert power(base, exp1) == 1;\n      PowerPositive(base, exp2);\n      assert power(base, exp2) >= 1;\n    } else {\n      // Both exp1 and exp2 are positive\n      PowerMonotonic(base, exp1 - 1, exp2 - 1);\n\n      calc <= {\n        power(base, exp1);\n        base * power(base, exp1 - 1);\n        { // Induction hypothesis\n          assert power(base, exp1 - 1) <= power(base, exp2 - 1);\n        }\n        base * power(base, exp2 - 1);\n        power(base, exp2);\n      }\n    }\n  }\n}\n\nlemma PowerPositive(base: nat, exp: nat)\n  requires base > 0\n  ensures power(base, exp) > 0\n{\n  if exp == 0 {\n    assert power(base, 0) == 1;\n  } else {\n    PowerPositive(base, exp - 1);\n    assert power(base, exp) == base * power(base, exp - 1);\n    assert base > 0 && power(base, exp - 1) > 0;\n  }\n}\n\nlemma FibonacciInequality(n: nat)\n  requires n >= 1\n  ensures fib(n) <= power(2, n - 1)\n{\n  if n == 1 {\n    // Base case\n    assert fib(1) == 1;\n    assert power(2, 0) == 1;\n  } else if n == 2 {\n    // Base case\n    assert fib(2) == 1;\n    assert power(2, 1) == 2;\n    assert 1 <= 2;\n  } else {\n    // Inductive step (n >= 3)\n    assert n >= 3;\n    FibonacciInequality(n - 1);\n    FibonacciInequality(n - 2);\n\n    calc <= {\n      fib(n);\n      fib(n - 1) + fib(n - 2);\n      { // Induction hypotheses\n        assert fib(n - 1) <= power(2, n - 2);\n        assert fib(n - 2) <= power(2, n - 3);\n      }\n      power(2, n - 2) + power(2, n - 3);\n      { // Factor out power(2, n - 3)\n        assert power(2, n - 2) == 2 * power(2, n - 3);\n      }\n      2 * power(2, n - 3) + power(2, n - 3);\n      3 * power(2, n - 3);\n      { // 3 * 2^(n-3) <= 4 * 2^(n-3) = 2^(n-1)\n        assert 3 <= 4;\n        \n/*[CODE HERE]*/\n      }\n      power(2, n - 1);\n    }\n  }\n}\n\nlemma StrongInduction(n: nat, P: nat -> bool)\n  requires forall k :: 0 <= k < n ==> P(k)\n  requires forall m :: m >= n && (forall j :: n <= j < m ==> P(j)) ==> P(m)\n  ensures P(n)\n{\n  // This demonstrates the strong induction principle\n  // Base case: all k < n satisfy P(k) by hypothesis\n  // Inductive case: if all j in [n, m) satisfy P, then P(m) holds\n\n  // The proof would proceed by showing P(n) directly\n  // using the second hypothesis with m = n\n  assert forall j :: n <= j < n ==> P(j); // Vacuously true\n}\n\nlemma CompleteInduction(n: nat, P: nat -> bool)\n  requires P(0)\n  requires forall k: nat :: k > 0 && (forall j: nat :: j < k ==> P(j)) ==> P(k)\n  ensures P(n)\n{\n  if n == 0 {\n    // Base case\n    assert P(0);\n  } else {\n    // Need to show all j < n satisfy P(j)\n    forall j: nat | j < n\n      ensures P(j)\n    {\n      if j == 0 {\n        assert P(0);\n      } else {\n        CompleteInduction(j, P);\n      }\n    }\n\n    // Now apply the inductive hypothesis\n    assert forall j: nat :: j < n ==> P(j);\n    assert P(n);\n  }\n}", "output": "assert power(2, n - 1) == 4 * power(2, n - 3);"}, {"id": "example_FibonacciInequality_1", "type": "assert", "program": "// Induction proofs with detailed reasoning steps\n\n// Sum of first n natural numbers\nfunction {:spec} sumTo(n: nat): nat\n{\n  if n == 0 then 0 else n + sumTo(n - 1)\n}\n\n// Sum of first n odd numbers\nfunction {:spec} sumOdds(n: nat): nat\n{\n  if n == 0 then 0 else (2 * n - 1) + sumOdds(n - 1)\n}\n\n// Sum of first n squares\nfunction {:spec} sumSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + sumSquares(n - 1)\n}\n\n// Power function\nfunction {:spec} power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\n// Fibonacci\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// --- Detailed Inductive Proofs ---\n\nlemma SumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    // Base case\n    assert sumTo(0) == 0;\n    assert 0 * (0 + 1) / 2 == 0;\n  } else {\n    // Inductive step\n    SumToFormula(n - 1);\n\n    calc == {\n      sumTo(n);\n      n + sumTo(n - 1);\n      { // Induction hypothesis\n        assert sumTo(n - 1) == (n - 1) * n / 2;\n      }\n      n + (n - 1) * n / 2;\n      { // Algebra\n        assert n == 2 * n / 2;\n      }\n      2 * n / 2 + (n - 1) * n / 2;\n      (2 * n + (n - 1) * n) / 2;\n      (2 * n + n * n - n) / 2;\n      (n + n * n) / 2;\n      n * (1 + n) / 2;\n      n * (n + 1) / 2;\n    }\n  }\n}\n\nlemma SumOddsIsSquare(n: nat)\n  ensures sumOdds(n) == n * n\n{\n  if n == 0 {\n    // Base case\n    assert sumOdds(0) == 0;\n    assert 0 * 0 == 0;\n  } else {\n    // Inductive step\n    SumOddsIsSquare(n - 1);\n\n    calc == {\n      sumOdds(n);\n      (2 * n - 1) + sumOdds(n - 1);\n      { // Induction hypothesis\n        assert sumOdds(n - 1) == (n - 1) * (n - 1);\n      }\n      (2 * n - 1) + (n - 1) * (n - 1);\n      { // Expand (n-1)\u00b2\n        assert (n - 1) * (n - 1) == n * n - 2 * n + 1;\n      }\n      (2 * n - 1) + (n * n - 2 * n + 1);\n      2 * n - 1 + n * n - 2 * n + 1;\n      n * n;\n    }\n  }\n}\n\nlemma SumSquaresFormula(n: nat)\n  ensures sumSquares(n) == n * (n + 1) * (2 * n + 1) / 6\n{\n  if n == 0 {\n    // Base case\n    assert sumSquares(0) == 0;\n    assert 0 * (0 + 1) * (2 * 0 + 1) / 6 == 0;\n  } else {\n    // Inductive step\n    SumSquaresFormula(n - 1);\n\n    calc == {\n      sumSquares(n);\n      n * n + sumSquares(n - 1);\n      { // Induction hypothesis\n        assert sumSquares(n - 1) == (n - 1) * n * (2 * n - 1) / 6;\n      }\n      n * n + (n - 1) * n * (2 * n - 1) / 6;\n      { // Factor out common terms\n        assert n * n == 6 * n * n / 6;\n      }\n      6 * n * n / 6 + (n - 1) * n * (2 * n - 1) / 6;\n      (6 * n * n + (n - 1) * n * (2 * n - 1)) / 6;\n      { // Expand\n        assert (n - 1) * n * (2 * n - 1) == n * (n - 1) * (2 * n - 1);\n        assert n * (n - 1) * (2 * n - 1) == n * (2 * n * n - 3 * n + 1);\n        assert n * (2 * n * n - 3 * n + 1) == 2 * n * n * n - 3 * n * n + n;\n      }\n      (6 * n * n + 2 * n * n * n - 3 * n * n + n) / 6;\n      (2 * n * n * n + 3 * n * n + n) / 6;\n      n * (2 * n * n + 3 * n + 1) / 6;\n      { // Factor\n        assert 2 * n * n + 3 * n + 1 == (n + 1) * (2 * n + 1);\n      }\n      n * (n + 1) * (2 * n + 1) / 6;\n    }\n  }\n}\n\nlemma PowerOfTwo(n: nat)\n  ensures power(2, n) >= n + 1\n{\n  if n == 0 {\n    // Base case\n    assert power(2, 0) == 1;\n    assert 1 >= 0 + 1;\n  } else {\n    // Inductive step\n    PowerOfTwo(n - 1);\n\n    calc >= {\n      power(2, n);\n      2 * power(2, n - 1);\n      { // Induction hypothesis\n        assert power(2, n - 1) >= n;\n      }\n      2 * n;\n      { // Since n >= 1\n        assert n >= 1;\n        assert 2 * n >= n + 1;\n      }\n      n + 1;\n    }\n  }\n}\n\nlemma PowerMonotonic(base: nat, exp1: nat, exp2: nat)\n  requires base > 1\n  requires exp1 <= exp2\n  ensures power(base, exp1) <= power(base, exp2)\n{\n  if exp1 == exp2 {\n    // Equal case\n    assert power(base, exp1) == power(base, exp2);\n  } else {\n    // exp1 < exp2\n    assert exp1 < exp2;\n\n    if exp1 == 0 {\n      assert power(base, exp1) == 1;\n      PowerPositive(base, exp2);\n      assert power(base, exp2) >= 1;\n    } else {\n      // Both exp1 and exp2 are positive\n      PowerMonotonic(base, exp1 - 1, exp2 - 1);\n\n      calc <= {\n        power(base, exp1);\n        base * power(base, exp1 - 1);\n        { // Induction hypothesis\n          assert power(base, exp1 - 1) <= power(base, exp2 - 1);\n        }\n        base * power(base, exp2 - 1);\n        power(base, exp2);\n      }\n    }\n  }\n}\n\nlemma PowerPositive(base: nat, exp: nat)\n  requires base > 0\n  ensures power(base, exp) > 0\n{\n  if exp == 0 {\n    assert power(base, 0) == 1;\n  } else {\n    PowerPositive(base, exp - 1);\n    assert power(base, exp) == base * power(base, exp - 1);\n    assert base > 0 && power(base, exp - 1) > 0;\n  }\n}\n\nlemma FibonacciInequality(n: nat)\n  requires n >= 1\n  ensures fib(n) <= power(2, n - 1)\n{\n  if n == 1 {\n    // Base case\n    assert fib(1) == 1;\n    assert power(2, 0) == 1;\n  } else if n == 2 {\n    // Base case\n    assert fib(2) == 1;\n    assert power(2, 1) == 2;\n    assert 1 <= 2;\n  } else {\n    // Inductive step (n >= 3)\n    assert n >= 3;\n    FibonacciInequality(n - 1);\n    FibonacciInequality(n - 2);\n\n    calc <= {\n      fib(n);\n      fib(n - 1) + fib(n - 2);\n      { // Induction hypotheses\n        assert fib(n - 1) <= power(2, n - 2);\n        assert fib(n - 2) <= power(2, n - 3);\n      }\n      power(2, n - 2) + power(2, n - 3);\n      { // Factor out power(2, n - 3)\n        assert power(2, n - 2) == 2 * power(2, n - 3);\n      }\n      2 * power(2, n - 3) + power(2, n - 3);\n      3 * power(2, n - 3);\n      { // 3 * 2^(n-3) <= 4 * 2^(n-3) = 2^(n-1)\n        \n/*[CODE HERE]*/\n        assert power(2, n - 1) == 4 * power(2, n - 3);\n      }\n      power(2, n - 1);\n    }\n  }\n}\n\nlemma StrongInduction(n: nat, P: nat -> bool)\n  requires forall k :: 0 <= k < n ==> P(k)\n  requires forall m :: m >= n && (forall j :: n <= j < m ==> P(j)) ==> P(m)\n  ensures P(n)\n{\n  // This demonstrates the strong induction principle\n  // Base case: all k < n satisfy P(k) by hypothesis\n  // Inductive case: if all j in [n, m) satisfy P, then P(m) holds\n\n  // The proof would proceed by showing P(n) directly\n  // using the second hypothesis with m = n\n  assert forall j :: n <= j < n ==> P(j); // Vacuously true\n}\n\nlemma CompleteInduction(n: nat, P: nat -> bool)\n  requires P(0)\n  requires forall k: nat :: k > 0 && (forall j: nat :: j < k ==> P(j)) ==> P(k)\n  ensures P(n)\n{\n  if n == 0 {\n    // Base case\n    assert P(0);\n  } else {\n    // Need to show all j < n satisfy P(j)\n    forall j: nat | j < n\n      ensures P(j)\n    {\n      if j == 0 {\n        assert P(0);\n      } else {\n        CompleteInduction(j, P);\n      }\n    }\n\n    // Now apply the inductive hypothesis\n    assert forall j: nat :: j < n ==> P(j);\n    assert P(n);\n  }\n}", "output": "assert 3 <= 4;"}, {"id": "example_FibonacciInequality_2", "type": "assert", "program": "// Induction proofs with detailed reasoning steps\n\n// Sum of first n natural numbers\nfunction {:spec} sumTo(n: nat): nat\n{\n  if n == 0 then 0 else n + sumTo(n - 1)\n}\n\n// Sum of first n odd numbers\nfunction {:spec} sumOdds(n: nat): nat\n{\n  if n == 0 then 0 else (2 * n - 1) + sumOdds(n - 1)\n}\n\n// Sum of first n squares\nfunction {:spec} sumSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + sumSquares(n - 1)\n}\n\n// Power function\nfunction {:spec} power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\n// Fibonacci\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// --- Detailed Inductive Proofs ---\n\nlemma SumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    // Base case\n    assert sumTo(0) == 0;\n    assert 0 * (0 + 1) / 2 == 0;\n  } else {\n    // Inductive step\n    SumToFormula(n - 1);\n\n    calc == {\n      sumTo(n);\n      n + sumTo(n - 1);\n      { // Induction hypothesis\n        assert sumTo(n - 1) == (n - 1) * n / 2;\n      }\n      n + (n - 1) * n / 2;\n      { // Algebra\n        assert n == 2 * n / 2;\n      }\n      2 * n / 2 + (n - 1) * n / 2;\n      (2 * n + (n - 1) * n) / 2;\n      (2 * n + n * n - n) / 2;\n      (n + n * n) / 2;\n      n * (1 + n) / 2;\n      n * (n + 1) / 2;\n    }\n  }\n}\n\nlemma SumOddsIsSquare(n: nat)\n  ensures sumOdds(n) == n * n\n{\n  if n == 0 {\n    // Base case\n    assert sumOdds(0) == 0;\n    assert 0 * 0 == 0;\n  } else {\n    // Inductive step\n    SumOddsIsSquare(n - 1);\n\n    calc == {\n      sumOdds(n);\n      (2 * n - 1) + sumOdds(n - 1);\n      { // Induction hypothesis\n        assert sumOdds(n - 1) == (n - 1) * (n - 1);\n      }\n      (2 * n - 1) + (n - 1) * (n - 1);\n      { // Expand (n-1)\u00b2\n        assert (n - 1) * (n - 1) == n * n - 2 * n + 1;\n      }\n      (2 * n - 1) + (n * n - 2 * n + 1);\n      2 * n - 1 + n * n - 2 * n + 1;\n      n * n;\n    }\n  }\n}\n\nlemma SumSquaresFormula(n: nat)\n  ensures sumSquares(n) == n * (n + 1) * (2 * n + 1) / 6\n{\n  if n == 0 {\n    // Base case\n    assert sumSquares(0) == 0;\n    assert 0 * (0 + 1) * (2 * 0 + 1) / 6 == 0;\n  } else {\n    // Inductive step\n    SumSquaresFormula(n - 1);\n\n    calc == {\n      sumSquares(n);\n      n * n + sumSquares(n - 1);\n      { // Induction hypothesis\n        assert sumSquares(n - 1) == (n - 1) * n * (2 * n - 1) / 6;\n      }\n      n * n + (n - 1) * n * (2 * n - 1) / 6;\n      { // Factor out common terms\n        assert n * n == 6 * n * n / 6;\n      }\n      6 * n * n / 6 + (n - 1) * n * (2 * n - 1) / 6;\n      (6 * n * n + (n - 1) * n * (2 * n - 1)) / 6;\n      { // Expand\n        assert (n - 1) * n * (2 * n - 1) == n * (n - 1) * (2 * n - 1);\n        assert n * (n - 1) * (2 * n - 1) == n * (2 * n * n - 3 * n + 1);\n        assert n * (2 * n * n - 3 * n + 1) == 2 * n * n * n - 3 * n * n + n;\n      }\n      (6 * n * n + 2 * n * n * n - 3 * n * n + n) / 6;\n      (2 * n * n * n + 3 * n * n + n) / 6;\n      n * (2 * n * n + 3 * n + 1) / 6;\n      { // Factor\n        assert 2 * n * n + 3 * n + 1 == (n + 1) * (2 * n + 1);\n      }\n      n * (n + 1) * (2 * n + 1) / 6;\n    }\n  }\n}\n\nlemma PowerOfTwo(n: nat)\n  ensures power(2, n) >= n + 1\n{\n  if n == 0 {\n    // Base case\n    assert power(2, 0) == 1;\n    assert 1 >= 0 + 1;\n  } else {\n    // Inductive step\n    PowerOfTwo(n - 1);\n\n    calc >= {\n      power(2, n);\n      2 * power(2, n - 1);\n      { // Induction hypothesis\n        assert power(2, n - 1) >= n;\n      }\n      2 * n;\n      { // Since n >= 1\n        assert n >= 1;\n        assert 2 * n >= n + 1;\n      }\n      n + 1;\n    }\n  }\n}\n\nlemma PowerMonotonic(base: nat, exp1: nat, exp2: nat)\n  requires base > 1\n  requires exp1 <= exp2\n  ensures power(base, exp1) <= power(base, exp2)\n{\n  if exp1 == exp2 {\n    // Equal case\n    assert power(base, exp1) == power(base, exp2);\n  } else {\n    // exp1 < exp2\n    assert exp1 < exp2;\n\n    if exp1 == 0 {\n      assert power(base, exp1) == 1;\n      PowerPositive(base, exp2);\n      assert power(base, exp2) >= 1;\n    } else {\n      // Both exp1 and exp2 are positive\n      PowerMonotonic(base, exp1 - 1, exp2 - 1);\n\n      calc <= {\n        power(base, exp1);\n        base * power(base, exp1 - 1);\n        { // Induction hypothesis\n          assert power(base, exp1 - 1) <= power(base, exp2 - 1);\n        }\n        base * power(base, exp2 - 1);\n        power(base, exp2);\n      }\n    }\n  }\n}\n\nlemma PowerPositive(base: nat, exp: nat)\n  requires base > 0\n  ensures power(base, exp) > 0\n{\n  if exp == 0 {\n    assert power(base, 0) == 1;\n  } else {\n    PowerPositive(base, exp - 1);\n    assert power(base, exp) == base * power(base, exp - 1);\n    assert base > 0 && power(base, exp - 1) > 0;\n  }\n}\n\nlemma FibonacciInequality(n: nat)\n  requires n >= 1\n  ensures fib(n) <= power(2, n - 1)\n{\n  if n == 1 {\n    // Base case\n    assert fib(1) == 1;\n    assert power(2, 0) == 1;\n  } else if n == 2 {\n    // Base case\n    assert fib(2) == 1;\n    assert power(2, 1) == 2;\n    assert 1 <= 2;\n  } else {\n    // Inductive step (n >= 3)\n    assert n >= 3;\n    FibonacciInequality(n - 1);\n    FibonacciInequality(n - 2);\n\n    calc <= {\n      fib(n);\n      fib(n - 1) + fib(n - 2);\n      { // Induction hypotheses\n        assert fib(n - 1) <= power(2, n - 2);\n        assert fib(n - 2) <= power(2, n - 3);\n      }\n      power(2, n - 2) + power(2, n - 3);\n      { // Factor out power(2, n - 3)\n        \n/*[CODE HERE]*/\n      }\n      2 * power(2, n - 3) + power(2, n - 3);\n      3 * power(2, n - 3);\n      { // 3 * 2^(n-3) <= 4 * 2^(n-3) = 2^(n-1)\n        assert 3 <= 4;\n        assert power(2, n - 1) == 4 * power(2, n - 3);\n      }\n      power(2, n - 1);\n    }\n  }\n}\n\nlemma StrongInduction(n: nat, P: nat -> bool)\n  requires forall k :: 0 <= k < n ==> P(k)\n  requires forall m :: m >= n && (forall j :: n <= j < m ==> P(j)) ==> P(m)\n  ensures P(n)\n{\n  // This demonstrates the strong induction principle\n  // Base case: all k < n satisfy P(k) by hypothesis\n  // Inductive case: if all j in [n, m) satisfy P, then P(m) holds\n\n  // The proof would proceed by showing P(n) directly\n  // using the second hypothesis with m = n\n  assert forall j :: n <= j < n ==> P(j); // Vacuously true\n}\n\nlemma CompleteInduction(n: nat, P: nat -> bool)\n  requires P(0)\n  requires forall k: nat :: k > 0 && (forall j: nat :: j < k ==> P(j)) ==> P(k)\n  ensures P(n)\n{\n  if n == 0 {\n    // Base case\n    assert P(0);\n  } else {\n    // Need to show all j < n satisfy P(j)\n    forall j: nat | j < n\n      ensures P(j)\n    {\n      if j == 0 {\n        assert P(0);\n      } else {\n        CompleteInduction(j, P);\n      }\n    }\n\n    // Now apply the inductive hypothesis\n    assert forall j: nat :: j < n ==> P(j);\n    assert P(n);\n  }\n}", "output": "assert power(2, n - 2) == 2 * power(2, n - 3);"}, {"id": "example_FibonacciInequality_3", "type": "assert", "program": "// Induction proofs with detailed reasoning steps\n\n// Sum of first n natural numbers\nfunction {:spec} sumTo(n: nat): nat\n{\n  if n == 0 then 0 else n + sumTo(n - 1)\n}\n\n// Sum of first n odd numbers\nfunction {:spec} sumOdds(n: nat): nat\n{\n  if n == 0 then 0 else (2 * n - 1) + sumOdds(n - 1)\n}\n\n// Sum of first n squares\nfunction {:spec} sumSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + sumSquares(n - 1)\n}\n\n// Power function\nfunction {:spec} power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\n// Fibonacci\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// --- Detailed Inductive Proofs ---\n\nlemma SumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    // Base case\n    assert sumTo(0) == 0;\n    assert 0 * (0 + 1) / 2 == 0;\n  } else {\n    // Inductive step\n    SumToFormula(n - 1);\n\n    calc == {\n      sumTo(n);\n      n + sumTo(n - 1);\n      { // Induction hypothesis\n        assert sumTo(n - 1) == (n - 1) * n / 2;\n      }\n      n + (n - 1) * n / 2;\n      { // Algebra\n        assert n == 2 * n / 2;\n      }\n      2 * n / 2 + (n - 1) * n / 2;\n      (2 * n + (n - 1) * n) / 2;\n      (2 * n + n * n - n) / 2;\n      (n + n * n) / 2;\n      n * (1 + n) / 2;\n      n * (n + 1) / 2;\n    }\n  }\n}\n\nlemma SumOddsIsSquare(n: nat)\n  ensures sumOdds(n) == n * n\n{\n  if n == 0 {\n    // Base case\n    assert sumOdds(0) == 0;\n    assert 0 * 0 == 0;\n  } else {\n    // Inductive step\n    SumOddsIsSquare(n - 1);\n\n    calc == {\n      sumOdds(n);\n      (2 * n - 1) + sumOdds(n - 1);\n      { // Induction hypothesis\n        assert sumOdds(n - 1) == (n - 1) * (n - 1);\n      }\n      (2 * n - 1) + (n - 1) * (n - 1);\n      { // Expand (n-1)\u00b2\n        assert (n - 1) * (n - 1) == n * n - 2 * n + 1;\n      }\n      (2 * n - 1) + (n * n - 2 * n + 1);\n      2 * n - 1 + n * n - 2 * n + 1;\n      n * n;\n    }\n  }\n}\n\nlemma SumSquaresFormula(n: nat)\n  ensures sumSquares(n) == n * (n + 1) * (2 * n + 1) / 6\n{\n  if n == 0 {\n    // Base case\n    assert sumSquares(0) == 0;\n    assert 0 * (0 + 1) * (2 * 0 + 1) / 6 == 0;\n  } else {\n    // Inductive step\n    SumSquaresFormula(n - 1);\n\n    calc == {\n      sumSquares(n);\n      n * n + sumSquares(n - 1);\n      { // Induction hypothesis\n        assert sumSquares(n - 1) == (n - 1) * n * (2 * n - 1) / 6;\n      }\n      n * n + (n - 1) * n * (2 * n - 1) / 6;\n      { // Factor out common terms\n        assert n * n == 6 * n * n / 6;\n      }\n      6 * n * n / 6 + (n - 1) * n * (2 * n - 1) / 6;\n      (6 * n * n + (n - 1) * n * (2 * n - 1)) / 6;\n      { // Expand\n        assert (n - 1) * n * (2 * n - 1) == n * (n - 1) * (2 * n - 1);\n        assert n * (n - 1) * (2 * n - 1) == n * (2 * n * n - 3 * n + 1);\n        assert n * (2 * n * n - 3 * n + 1) == 2 * n * n * n - 3 * n * n + n;\n      }\n      (6 * n * n + 2 * n * n * n - 3 * n * n + n) / 6;\n      (2 * n * n * n + 3 * n * n + n) / 6;\n      n * (2 * n * n + 3 * n + 1) / 6;\n      { // Factor\n        assert 2 * n * n + 3 * n + 1 == (n + 1) * (2 * n + 1);\n      }\n      n * (n + 1) * (2 * n + 1) / 6;\n    }\n  }\n}\n\nlemma PowerOfTwo(n: nat)\n  ensures power(2, n) >= n + 1\n{\n  if n == 0 {\n    // Base case\n    assert power(2, 0) == 1;\n    assert 1 >= 0 + 1;\n  } else {\n    // Inductive step\n    PowerOfTwo(n - 1);\n\n    calc >= {\n      power(2, n);\n      2 * power(2, n - 1);\n      { // Induction hypothesis\n        assert power(2, n - 1) >= n;\n      }\n      2 * n;\n      { // Since n >= 1\n        assert n >= 1;\n        assert 2 * n >= n + 1;\n      }\n      n + 1;\n    }\n  }\n}\n\nlemma PowerMonotonic(base: nat, exp1: nat, exp2: nat)\n  requires base > 1\n  requires exp1 <= exp2\n  ensures power(base, exp1) <= power(base, exp2)\n{\n  if exp1 == exp2 {\n    // Equal case\n    assert power(base, exp1) == power(base, exp2);\n  } else {\n    // exp1 < exp2\n    assert exp1 < exp2;\n\n    if exp1 == 0 {\n      assert power(base, exp1) == 1;\n      PowerPositive(base, exp2);\n      assert power(base, exp2) >= 1;\n    } else {\n      // Both exp1 and exp2 are positive\n      PowerMonotonic(base, exp1 - 1, exp2 - 1);\n\n      calc <= {\n        power(base, exp1);\n        base * power(base, exp1 - 1);\n        { // Induction hypothesis\n          assert power(base, exp1 - 1) <= power(base, exp2 - 1);\n        }\n        base * power(base, exp2 - 1);\n        power(base, exp2);\n      }\n    }\n  }\n}\n\nlemma PowerPositive(base: nat, exp: nat)\n  requires base > 0\n  ensures power(base, exp) > 0\n{\n  if exp == 0 {\n    assert power(base, 0) == 1;\n  } else {\n    PowerPositive(base, exp - 1);\n    assert power(base, exp) == base * power(base, exp - 1);\n    assert base > 0 && power(base, exp - 1) > 0;\n  }\n}\n\nlemma FibonacciInequality(n: nat)\n  requires n >= 1\n  ensures fib(n) <= power(2, n - 1)\n{\n  if n == 1 {\n    // Base case\n    assert fib(1) == 1;\n    assert power(2, 0) == 1;\n  } else if n == 2 {\n    // Base case\n    assert fib(2) == 1;\n    assert power(2, 1) == 2;\n    assert 1 <= 2;\n  } else {\n    // Inductive step (n >= 3)\n    assert n >= 3;\n    FibonacciInequality(n - 1);\n    FibonacciInequality(n - 2);\n\n    calc <= {\n      fib(n);\n      fib(n - 1) + fib(n - 2);\n      { // Induction hypotheses\n        assert fib(n - 1) <= power(2, n - 2);\n        \n/*[CODE HERE]*/\n      }\n      power(2, n - 2) + power(2, n - 3);\n      { // Factor out power(2, n - 3)\n        assert power(2, n - 2) == 2 * power(2, n - 3);\n      }\n      2 * power(2, n - 3) + power(2, n - 3);\n      3 * power(2, n - 3);\n      { // 3 * 2^(n-3) <= 4 * 2^(n-3) = 2^(n-1)\n        assert 3 <= 4;\n        assert power(2, n - 1) == 4 * power(2, n - 3);\n      }\n      power(2, n - 1);\n    }\n  }\n}\n\nlemma StrongInduction(n: nat, P: nat -> bool)\n  requires forall k :: 0 <= k < n ==> P(k)\n  requires forall m :: m >= n && (forall j :: n <= j < m ==> P(j)) ==> P(m)\n  ensures P(n)\n{\n  // This demonstrates the strong induction principle\n  // Base case: all k < n satisfy P(k) by hypothesis\n  // Inductive case: if all j in [n, m) satisfy P, then P(m) holds\n\n  // The proof would proceed by showing P(n) directly\n  // using the second hypothesis with m = n\n  assert forall j :: n <= j < n ==> P(j); // Vacuously true\n}\n\nlemma CompleteInduction(n: nat, P: nat -> bool)\n  requires P(0)\n  requires forall k: nat :: k > 0 && (forall j: nat :: j < k ==> P(j)) ==> P(k)\n  ensures P(n)\n{\n  if n == 0 {\n    // Base case\n    assert P(0);\n  } else {\n    // Need to show all j < n satisfy P(j)\n    forall j: nat | j < n\n      ensures P(j)\n    {\n      if j == 0 {\n        assert P(0);\n      } else {\n        CompleteInduction(j, P);\n      }\n    }\n\n    // Now apply the inductive hypothesis\n    assert forall j: nat :: j < n ==> P(j);\n    assert P(n);\n  }\n}", "output": "assert fib(n - 2) <= power(2, n - 3);"}, {"id": "example_FibonacciInequality_4", "type": "assert", "program": "// Induction proofs with detailed reasoning steps\n\n// Sum of first n natural numbers\nfunction {:spec} sumTo(n: nat): nat\n{\n  if n == 0 then 0 else n + sumTo(n - 1)\n}\n\n// Sum of first n odd numbers\nfunction {:spec} sumOdds(n: nat): nat\n{\n  if n == 0 then 0 else (2 * n - 1) + sumOdds(n - 1)\n}\n\n// Sum of first n squares\nfunction {:spec} sumSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + sumSquares(n - 1)\n}\n\n// Power function\nfunction {:spec} power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\n// Fibonacci\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// --- Detailed Inductive Proofs ---\n\nlemma SumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    // Base case\n    assert sumTo(0) == 0;\n    assert 0 * (0 + 1) / 2 == 0;\n  } else {\n    // Inductive step\n    SumToFormula(n - 1);\n\n    calc == {\n      sumTo(n);\n      n + sumTo(n - 1);\n      { // Induction hypothesis\n        assert sumTo(n - 1) == (n - 1) * n / 2;\n      }\n      n + (n - 1) * n / 2;\n      { // Algebra\n        assert n == 2 * n / 2;\n      }\n      2 * n / 2 + (n - 1) * n / 2;\n      (2 * n + (n - 1) * n) / 2;\n      (2 * n + n * n - n) / 2;\n      (n + n * n) / 2;\n      n * (1 + n) / 2;\n      n * (n + 1) / 2;\n    }\n  }\n}\n\nlemma SumOddsIsSquare(n: nat)\n  ensures sumOdds(n) == n * n\n{\n  if n == 0 {\n    // Base case\n    assert sumOdds(0) == 0;\n    assert 0 * 0 == 0;\n  } else {\n    // Inductive step\n    SumOddsIsSquare(n - 1);\n\n    calc == {\n      sumOdds(n);\n      (2 * n - 1) + sumOdds(n - 1);\n      { // Induction hypothesis\n        assert sumOdds(n - 1) == (n - 1) * (n - 1);\n      }\n      (2 * n - 1) + (n - 1) * (n - 1);\n      { // Expand (n-1)\u00b2\n        assert (n - 1) * (n - 1) == n * n - 2 * n + 1;\n      }\n      (2 * n - 1) + (n * n - 2 * n + 1);\n      2 * n - 1 + n * n - 2 * n + 1;\n      n * n;\n    }\n  }\n}\n\nlemma SumSquaresFormula(n: nat)\n  ensures sumSquares(n) == n * (n + 1) * (2 * n + 1) / 6\n{\n  if n == 0 {\n    // Base case\n    assert sumSquares(0) == 0;\n    assert 0 * (0 + 1) * (2 * 0 + 1) / 6 == 0;\n  } else {\n    // Inductive step\n    SumSquaresFormula(n - 1);\n\n    calc == {\n      sumSquares(n);\n      n * n + sumSquares(n - 1);\n      { // Induction hypothesis\n        assert sumSquares(n - 1) == (n - 1) * n * (2 * n - 1) / 6;\n      }\n      n * n + (n - 1) * n * (2 * n - 1) / 6;\n      { // Factor out common terms\n        assert n * n == 6 * n * n / 6;\n      }\n      6 * n * n / 6 + (n - 1) * n * (2 * n - 1) / 6;\n      (6 * n * n + (n - 1) * n * (2 * n - 1)) / 6;\n      { // Expand\n        assert (n - 1) * n * (2 * n - 1) == n * (n - 1) * (2 * n - 1);\n        assert n * (n - 1) * (2 * n - 1) == n * (2 * n * n - 3 * n + 1);\n        assert n * (2 * n * n - 3 * n + 1) == 2 * n * n * n - 3 * n * n + n;\n      }\n      (6 * n * n + 2 * n * n * n - 3 * n * n + n) / 6;\n      (2 * n * n * n + 3 * n * n + n) / 6;\n      n * (2 * n * n + 3 * n + 1) / 6;\n      { // Factor\n        assert 2 * n * n + 3 * n + 1 == (n + 1) * (2 * n + 1);\n      }\n      n * (n + 1) * (2 * n + 1) / 6;\n    }\n  }\n}\n\nlemma PowerOfTwo(n: nat)\n  ensures power(2, n) >= n + 1\n{\n  if n == 0 {\n    // Base case\n    assert power(2, 0) == 1;\n    assert 1 >= 0 + 1;\n  } else {\n    // Inductive step\n    PowerOfTwo(n - 1);\n\n    calc >= {\n      power(2, n);\n      2 * power(2, n - 1);\n      { // Induction hypothesis\n        assert power(2, n - 1) >= n;\n      }\n      2 * n;\n      { // Since n >= 1\n        assert n >= 1;\n        assert 2 * n >= n + 1;\n      }\n      n + 1;\n    }\n  }\n}\n\nlemma PowerMonotonic(base: nat, exp1: nat, exp2: nat)\n  requires base > 1\n  requires exp1 <= exp2\n  ensures power(base, exp1) <= power(base, exp2)\n{\n  if exp1 == exp2 {\n    // Equal case\n    assert power(base, exp1) == power(base, exp2);\n  } else {\n    // exp1 < exp2\n    assert exp1 < exp2;\n\n    if exp1 == 0 {\n      assert power(base, exp1) == 1;\n      PowerPositive(base, exp2);\n      assert power(base, exp2) >= 1;\n    } else {\n      // Both exp1 and exp2 are positive\n      PowerMonotonic(base, exp1 - 1, exp2 - 1);\n\n      calc <= {\n        power(base, exp1);\n        base * power(base, exp1 - 1);\n        { // Induction hypothesis\n          assert power(base, exp1 - 1) <= power(base, exp2 - 1);\n        }\n        base * power(base, exp2 - 1);\n        power(base, exp2);\n      }\n    }\n  }\n}\n\nlemma PowerPositive(base: nat, exp: nat)\n  requires base > 0\n  ensures power(base, exp) > 0\n{\n  if exp == 0 {\n    assert power(base, 0) == 1;\n  } else {\n    PowerPositive(base, exp - 1);\n    assert power(base, exp) == base * power(base, exp - 1);\n    assert base > 0 && power(base, exp - 1) > 0;\n  }\n}\n\nlemma FibonacciInequality(n: nat)\n  requires n >= 1\n  ensures fib(n) <= power(2, n - 1)\n{\n  if n == 1 {\n    // Base case\n    assert fib(1) == 1;\n    assert power(2, 0) == 1;\n  } else if n == 2 {\n    // Base case\n    assert fib(2) == 1;\n    assert power(2, 1) == 2;\n    assert 1 <= 2;\n  } else {\n    // Inductive step (n >= 3)\n    assert n >= 3;\n    FibonacciInequality(n - 1);\n    FibonacciInequality(n - 2);\n\n    calc <= {\n      fib(n);\n      fib(n - 1) + fib(n - 2);\n      { // Induction hypotheses\n        \n/*[CODE HERE]*/\n        assert fib(n - 2) <= power(2, n - 3);\n      }\n      power(2, n - 2) + power(2, n - 3);\n      { // Factor out power(2, n - 3)\n        assert power(2, n - 2) == 2 * power(2, n - 3);\n      }\n      2 * power(2, n - 3) + power(2, n - 3);\n      3 * power(2, n - 3);\n      { // 3 * 2^(n-3) <= 4 * 2^(n-3) = 2^(n-1)\n        assert 3 <= 4;\n        assert power(2, n - 1) == 4 * power(2, n - 3);\n      }\n      power(2, n - 1);\n    }\n  }\n}\n\nlemma StrongInduction(n: nat, P: nat -> bool)\n  requires forall k :: 0 <= k < n ==> P(k)\n  requires forall m :: m >= n && (forall j :: n <= j < m ==> P(j)) ==> P(m)\n  ensures P(n)\n{\n  // This demonstrates the strong induction principle\n  // Base case: all k < n satisfy P(k) by hypothesis\n  // Inductive case: if all j in [n, m) satisfy P, then P(m) holds\n\n  // The proof would proceed by showing P(n) directly\n  // using the second hypothesis with m = n\n  assert forall j :: n <= j < n ==> P(j); // Vacuously true\n}\n\nlemma CompleteInduction(n: nat, P: nat -> bool)\n  requires P(0)\n  requires forall k: nat :: k > 0 && (forall j: nat :: j < k ==> P(j)) ==> P(k)\n  ensures P(n)\n{\n  if n == 0 {\n    // Base case\n    assert P(0);\n  } else {\n    // Need to show all j < n satisfy P(j)\n    forall j: nat | j < n\n      ensures P(j)\n    {\n      if j == 0 {\n        assert P(0);\n      } else {\n        CompleteInduction(j, P);\n      }\n    }\n\n    // Now apply the inductive hypothesis\n    assert forall j: nat :: j < n ==> P(j);\n    assert P(n);\n  }\n}", "output": "assert fib(n - 1) <= power(2, n - 2);"}, {"id": "example_FibonacciInequality_5", "type": "call", "program": "// Induction proofs with detailed reasoning steps\n\n// Sum of first n natural numbers\nfunction {:spec} sumTo(n: nat): nat\n{\n  if n == 0 then 0 else n + sumTo(n - 1)\n}\n\n// Sum of first n odd numbers\nfunction {:spec} sumOdds(n: nat): nat\n{\n  if n == 0 then 0 else (2 * n - 1) + sumOdds(n - 1)\n}\n\n// Sum of first n squares\nfunction {:spec} sumSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + sumSquares(n - 1)\n}\n\n// Power function\nfunction {:spec} power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\n// Fibonacci\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// --- Detailed Inductive Proofs ---\n\nlemma SumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    // Base case\n    assert sumTo(0) == 0;\n    assert 0 * (0 + 1) / 2 == 0;\n  } else {\n    // Inductive step\n    SumToFormula(n - 1);\n\n    calc == {\n      sumTo(n);\n      n + sumTo(n - 1);\n      { // Induction hypothesis\n        assert sumTo(n - 1) == (n - 1) * n / 2;\n      }\n      n + (n - 1) * n / 2;\n      { // Algebra\n        assert n == 2 * n / 2;\n      }\n      2 * n / 2 + (n - 1) * n / 2;\n      (2 * n + (n - 1) * n) / 2;\n      (2 * n + n * n - n) / 2;\n      (n + n * n) / 2;\n      n * (1 + n) / 2;\n      n * (n + 1) / 2;\n    }\n  }\n}\n\nlemma SumOddsIsSquare(n: nat)\n  ensures sumOdds(n) == n * n\n{\n  if n == 0 {\n    // Base case\n    assert sumOdds(0) == 0;\n    assert 0 * 0 == 0;\n  } else {\n    // Inductive step\n    SumOddsIsSquare(n - 1);\n\n    calc == {\n      sumOdds(n);\n      (2 * n - 1) + sumOdds(n - 1);\n      { // Induction hypothesis\n        assert sumOdds(n - 1) == (n - 1) * (n - 1);\n      }\n      (2 * n - 1) + (n - 1) * (n - 1);\n      { // Expand (n-1)\u00b2\n        assert (n - 1) * (n - 1) == n * n - 2 * n + 1;\n      }\n      (2 * n - 1) + (n * n - 2 * n + 1);\n      2 * n - 1 + n * n - 2 * n + 1;\n      n * n;\n    }\n  }\n}\n\nlemma SumSquaresFormula(n: nat)\n  ensures sumSquares(n) == n * (n + 1) * (2 * n + 1) / 6\n{\n  if n == 0 {\n    // Base case\n    assert sumSquares(0) == 0;\n    assert 0 * (0 + 1) * (2 * 0 + 1) / 6 == 0;\n  } else {\n    // Inductive step\n    SumSquaresFormula(n - 1);\n\n    calc == {\n      sumSquares(n);\n      n * n + sumSquares(n - 1);\n      { // Induction hypothesis\n        assert sumSquares(n - 1) == (n - 1) * n * (2 * n - 1) / 6;\n      }\n      n * n + (n - 1) * n * (2 * n - 1) / 6;\n      { // Factor out common terms\n        assert n * n == 6 * n * n / 6;\n      }\n      6 * n * n / 6 + (n - 1) * n * (2 * n - 1) / 6;\n      (6 * n * n + (n - 1) * n * (2 * n - 1)) / 6;\n      { // Expand\n        assert (n - 1) * n * (2 * n - 1) == n * (n - 1) * (2 * n - 1);\n        assert n * (n - 1) * (2 * n - 1) == n * (2 * n * n - 3 * n + 1);\n        assert n * (2 * n * n - 3 * n + 1) == 2 * n * n * n - 3 * n * n + n;\n      }\n      (6 * n * n + 2 * n * n * n - 3 * n * n + n) / 6;\n      (2 * n * n * n + 3 * n * n + n) / 6;\n      n * (2 * n * n + 3 * n + 1) / 6;\n      { // Factor\n        assert 2 * n * n + 3 * n + 1 == (n + 1) * (2 * n + 1);\n      }\n      n * (n + 1) * (2 * n + 1) / 6;\n    }\n  }\n}\n\nlemma PowerOfTwo(n: nat)\n  ensures power(2, n) >= n + 1\n{\n  if n == 0 {\n    // Base case\n    assert power(2, 0) == 1;\n    assert 1 >= 0 + 1;\n  } else {\n    // Inductive step\n    PowerOfTwo(n - 1);\n\n    calc >= {\n      power(2, n);\n      2 * power(2, n - 1);\n      { // Induction hypothesis\n        assert power(2, n - 1) >= n;\n      }\n      2 * n;\n      { // Since n >= 1\n        assert n >= 1;\n        assert 2 * n >= n + 1;\n      }\n      n + 1;\n    }\n  }\n}\n\nlemma PowerMonotonic(base: nat, exp1: nat, exp2: nat)\n  requires base > 1\n  requires exp1 <= exp2\n  ensures power(base, exp1) <= power(base, exp2)\n{\n  if exp1 == exp2 {\n    // Equal case\n    assert power(base, exp1) == power(base, exp2);\n  } else {\n    // exp1 < exp2\n    assert exp1 < exp2;\n\n    if exp1 == 0 {\n      assert power(base, exp1) == 1;\n      PowerPositive(base, exp2);\n      assert power(base, exp2) >= 1;\n    } else {\n      // Both exp1 and exp2 are positive\n      PowerMonotonic(base, exp1 - 1, exp2 - 1);\n\n      calc <= {\n        power(base, exp1);\n        base * power(base, exp1 - 1);\n        { // Induction hypothesis\n          assert power(base, exp1 - 1) <= power(base, exp2 - 1);\n        }\n        base * power(base, exp2 - 1);\n        power(base, exp2);\n      }\n    }\n  }\n}\n\nlemma PowerPositive(base: nat, exp: nat)\n  requires base > 0\n  ensures power(base, exp) > 0\n{\n  if exp == 0 {\n    assert power(base, 0) == 1;\n  } else {\n    PowerPositive(base, exp - 1);\n    assert power(base, exp) == base * power(base, exp - 1);\n    assert base > 0 && power(base, exp - 1) > 0;\n  }\n}\n\nlemma FibonacciInequality(n: nat)\n  requires n >= 1\n  ensures fib(n) <= power(2, n - 1)\n{\n  if n == 1 {\n    // Base case\n    assert fib(1) == 1;\n    assert power(2, 0) == 1;\n  } else if n == 2 {\n    // Base case\n    assert fib(2) == 1;\n    assert power(2, 1) == 2;\n    assert 1 <= 2;\n  } else {\n    // Inductive step (n >= 3)\n    assert n >= 3;\n    FibonacciInequality(n - 1);\n    \n/*[CODE HERE]*/\n\n    calc <= {\n      fib(n);\n      fib(n - 1) + fib(n - 2);\n      { // Induction hypotheses\n        assert fib(n - 1) <= power(2, n - 2);\n        assert fib(n - 2) <= power(2, n - 3);\n      }\n      power(2, n - 2) + power(2, n - 3);\n      { // Factor out power(2, n - 3)\n        assert power(2, n - 2) == 2 * power(2, n - 3);\n      }\n      2 * power(2, n - 3) + power(2, n - 3);\n      3 * power(2, n - 3);\n      { // 3 * 2^(n-3) <= 4 * 2^(n-3) = 2^(n-1)\n        assert 3 <= 4;\n        assert power(2, n - 1) == 4 * power(2, n - 3);\n      }\n      power(2, n - 1);\n    }\n  }\n}\n\nlemma StrongInduction(n: nat, P: nat -> bool)\n  requires forall k :: 0 <= k < n ==> P(k)\n  requires forall m :: m >= n && (forall j :: n <= j < m ==> P(j)) ==> P(m)\n  ensures P(n)\n{\n  // This demonstrates the strong induction principle\n  // Base case: all k < n satisfy P(k) by hypothesis\n  // Inductive case: if all j in [n, m) satisfy P, then P(m) holds\n\n  // The proof would proceed by showing P(n) directly\n  // using the second hypothesis with m = n\n  assert forall j :: n <= j < n ==> P(j); // Vacuously true\n}\n\nlemma CompleteInduction(n: nat, P: nat -> bool)\n  requires P(0)\n  requires forall k: nat :: k > 0 && (forall j: nat :: j < k ==> P(j)) ==> P(k)\n  ensures P(n)\n{\n  if n == 0 {\n    // Base case\n    assert P(0);\n  } else {\n    // Need to show all j < n satisfy P(j)\n    forall j: nat | j < n\n      ensures P(j)\n    {\n      if j == 0 {\n        assert P(0);\n      } else {\n        CompleteInduction(j, P);\n      }\n    }\n\n    // Now apply the inductive hypothesis\n    assert forall j: nat :: j < n ==> P(j);\n    assert P(n);\n  }\n}", "output": "FibonacciInequality(n - 2);"}, {"id": "example_FibonacciInequality_6", "type": "call", "program": "// Induction proofs with detailed reasoning steps\n\n// Sum of first n natural numbers\nfunction {:spec} sumTo(n: nat): nat\n{\n  if n == 0 then 0 else n + sumTo(n - 1)\n}\n\n// Sum of first n odd numbers\nfunction {:spec} sumOdds(n: nat): nat\n{\n  if n == 0 then 0 else (2 * n - 1) + sumOdds(n - 1)\n}\n\n// Sum of first n squares\nfunction {:spec} sumSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + sumSquares(n - 1)\n}\n\n// Power function\nfunction {:spec} power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\n// Fibonacci\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// --- Detailed Inductive Proofs ---\n\nlemma SumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    // Base case\n    assert sumTo(0) == 0;\n    assert 0 * (0 + 1) / 2 == 0;\n  } else {\n    // Inductive step\n    SumToFormula(n - 1);\n\n    calc == {\n      sumTo(n);\n      n + sumTo(n - 1);\n      { // Induction hypothesis\n        assert sumTo(n - 1) == (n - 1) * n / 2;\n      }\n      n + (n - 1) * n / 2;\n      { // Algebra\n        assert n == 2 * n / 2;\n      }\n      2 * n / 2 + (n - 1) * n / 2;\n      (2 * n + (n - 1) * n) / 2;\n      (2 * n + n * n - n) / 2;\n      (n + n * n) / 2;\n      n * (1 + n) / 2;\n      n * (n + 1) / 2;\n    }\n  }\n}\n\nlemma SumOddsIsSquare(n: nat)\n  ensures sumOdds(n) == n * n\n{\n  if n == 0 {\n    // Base case\n    assert sumOdds(0) == 0;\n    assert 0 * 0 == 0;\n  } else {\n    // Inductive step\n    SumOddsIsSquare(n - 1);\n\n    calc == {\n      sumOdds(n);\n      (2 * n - 1) + sumOdds(n - 1);\n      { // Induction hypothesis\n        assert sumOdds(n - 1) == (n - 1) * (n - 1);\n      }\n      (2 * n - 1) + (n - 1) * (n - 1);\n      { // Expand (n-1)\u00b2\n        assert (n - 1) * (n - 1) == n * n - 2 * n + 1;\n      }\n      (2 * n - 1) + (n * n - 2 * n + 1);\n      2 * n - 1 + n * n - 2 * n + 1;\n      n * n;\n    }\n  }\n}\n\nlemma SumSquaresFormula(n: nat)\n  ensures sumSquares(n) == n * (n + 1) * (2 * n + 1) / 6\n{\n  if n == 0 {\n    // Base case\n    assert sumSquares(0) == 0;\n    assert 0 * (0 + 1) * (2 * 0 + 1) / 6 == 0;\n  } else {\n    // Inductive step\n    SumSquaresFormula(n - 1);\n\n    calc == {\n      sumSquares(n);\n      n * n + sumSquares(n - 1);\n      { // Induction hypothesis\n        assert sumSquares(n - 1) == (n - 1) * n * (2 * n - 1) / 6;\n      }\n      n * n + (n - 1) * n * (2 * n - 1) / 6;\n      { // Factor out common terms\n        assert n * n == 6 * n * n / 6;\n      }\n      6 * n * n / 6 + (n - 1) * n * (2 * n - 1) / 6;\n      (6 * n * n + (n - 1) * n * (2 * n - 1)) / 6;\n      { // Expand\n        assert (n - 1) * n * (2 * n - 1) == n * (n - 1) * (2 * n - 1);\n        assert n * (n - 1) * (2 * n - 1) == n * (2 * n * n - 3 * n + 1);\n        assert n * (2 * n * n - 3 * n + 1) == 2 * n * n * n - 3 * n * n + n;\n      }\n      (6 * n * n + 2 * n * n * n - 3 * n * n + n) / 6;\n      (2 * n * n * n + 3 * n * n + n) / 6;\n      n * (2 * n * n + 3 * n + 1) / 6;\n      { // Factor\n        assert 2 * n * n + 3 * n + 1 == (n + 1) * (2 * n + 1);\n      }\n      n * (n + 1) * (2 * n + 1) / 6;\n    }\n  }\n}\n\nlemma PowerOfTwo(n: nat)\n  ensures power(2, n) >= n + 1\n{\n  if n == 0 {\n    // Base case\n    assert power(2, 0) == 1;\n    assert 1 >= 0 + 1;\n  } else {\n    // Inductive step\n    PowerOfTwo(n - 1);\n\n    calc >= {\n      power(2, n);\n      2 * power(2, n - 1);\n      { // Induction hypothesis\n        assert power(2, n - 1) >= n;\n      }\n      2 * n;\n      { // Since n >= 1\n        assert n >= 1;\n        assert 2 * n >= n + 1;\n      }\n      n + 1;\n    }\n  }\n}\n\nlemma PowerMonotonic(base: nat, exp1: nat, exp2: nat)\n  requires base > 1\n  requires exp1 <= exp2\n  ensures power(base, exp1) <= power(base, exp2)\n{\n  if exp1 == exp2 {\n    // Equal case\n    assert power(base, exp1) == power(base, exp2);\n  } else {\n    // exp1 < exp2\n    assert exp1 < exp2;\n\n    if exp1 == 0 {\n      assert power(base, exp1) == 1;\n      PowerPositive(base, exp2);\n      assert power(base, exp2) >= 1;\n    } else {\n      // Both exp1 and exp2 are positive\n      PowerMonotonic(base, exp1 - 1, exp2 - 1);\n\n      calc <= {\n        power(base, exp1);\n        base * power(base, exp1 - 1);\n        { // Induction hypothesis\n          assert power(base, exp1 - 1) <= power(base, exp2 - 1);\n        }\n        base * power(base, exp2 - 1);\n        power(base, exp2);\n      }\n    }\n  }\n}\n\nlemma PowerPositive(base: nat, exp: nat)\n  requires base > 0\n  ensures power(base, exp) > 0\n{\n  if exp == 0 {\n    assert power(base, 0) == 1;\n  } else {\n    PowerPositive(base, exp - 1);\n    assert power(base, exp) == base * power(base, exp - 1);\n    assert base > 0 && power(base, exp - 1) > 0;\n  }\n}\n\nlemma FibonacciInequality(n: nat)\n  requires n >= 1\n  ensures fib(n) <= power(2, n - 1)\n{\n  if n == 1 {\n    // Base case\n    assert fib(1) == 1;\n    assert power(2, 0) == 1;\n  } else if n == 2 {\n    // Base case\n    assert fib(2) == 1;\n    assert power(2, 1) == 2;\n    assert 1 <= 2;\n  } else {\n    // Inductive step (n >= 3)\n    assert n >= 3;\n    \n/*[CODE HERE]*/\n    FibonacciInequality(n - 2);\n\n    calc <= {\n      fib(n);\n      fib(n - 1) + fib(n - 2);\n      { // Induction hypotheses\n        assert fib(n - 1) <= power(2, n - 2);\n        assert fib(n - 2) <= power(2, n - 3);\n      }\n      power(2, n - 2) + power(2, n - 3);\n      { // Factor out power(2, n - 3)\n        assert power(2, n - 2) == 2 * power(2, n - 3);\n      }\n      2 * power(2, n - 3) + power(2, n - 3);\n      3 * power(2, n - 3);\n      { // 3 * 2^(n-3) <= 4 * 2^(n-3) = 2^(n-1)\n        assert 3 <= 4;\n        assert power(2, n - 1) == 4 * power(2, n - 3);\n      }\n      power(2, n - 1);\n    }\n  }\n}\n\nlemma StrongInduction(n: nat, P: nat -> bool)\n  requires forall k :: 0 <= k < n ==> P(k)\n  requires forall m :: m >= n && (forall j :: n <= j < m ==> P(j)) ==> P(m)\n  ensures P(n)\n{\n  // This demonstrates the strong induction principle\n  // Base case: all k < n satisfy P(k) by hypothesis\n  // Inductive case: if all j in [n, m) satisfy P, then P(m) holds\n\n  // The proof would proceed by showing P(n) directly\n  // using the second hypothesis with m = n\n  assert forall j :: n <= j < n ==> P(j); // Vacuously true\n}\n\nlemma CompleteInduction(n: nat, P: nat -> bool)\n  requires P(0)\n  requires forall k: nat :: k > 0 && (forall j: nat :: j < k ==> P(j)) ==> P(k)\n  ensures P(n)\n{\n  if n == 0 {\n    // Base case\n    assert P(0);\n  } else {\n    // Need to show all j < n satisfy P(j)\n    forall j: nat | j < n\n      ensures P(j)\n    {\n      if j == 0 {\n        assert P(0);\n      } else {\n        CompleteInduction(j, P);\n      }\n    }\n\n    // Now apply the inductive hypothesis\n    assert forall j: nat :: j < n ==> P(j);\n    assert P(n);\n  }\n}", "output": "FibonacciInequality(n - 1);"}, {"id": "example_FibonacciInequality_7", "type": "assert", "program": "// Induction proofs with detailed reasoning steps\n\n// Sum of first n natural numbers\nfunction {:spec} sumTo(n: nat): nat\n{\n  if n == 0 then 0 else n + sumTo(n - 1)\n}\n\n// Sum of first n odd numbers\nfunction {:spec} sumOdds(n: nat): nat\n{\n  if n == 0 then 0 else (2 * n - 1) + sumOdds(n - 1)\n}\n\n// Sum of first n squares\nfunction {:spec} sumSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + sumSquares(n - 1)\n}\n\n// Power function\nfunction {:spec} power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\n// Fibonacci\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// --- Detailed Inductive Proofs ---\n\nlemma SumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    // Base case\n    assert sumTo(0) == 0;\n    assert 0 * (0 + 1) / 2 == 0;\n  } else {\n    // Inductive step\n    SumToFormula(n - 1);\n\n    calc == {\n      sumTo(n);\n      n + sumTo(n - 1);\n      { // Induction hypothesis\n        assert sumTo(n - 1) == (n - 1) * n / 2;\n      }\n      n + (n - 1) * n / 2;\n      { // Algebra\n        assert n == 2 * n / 2;\n      }\n      2 * n / 2 + (n - 1) * n / 2;\n      (2 * n + (n - 1) * n) / 2;\n      (2 * n + n * n - n) / 2;\n      (n + n * n) / 2;\n      n * (1 + n) / 2;\n      n * (n + 1) / 2;\n    }\n  }\n}\n\nlemma SumOddsIsSquare(n: nat)\n  ensures sumOdds(n) == n * n\n{\n  if n == 0 {\n    // Base case\n    assert sumOdds(0) == 0;\n    assert 0 * 0 == 0;\n  } else {\n    // Inductive step\n    SumOddsIsSquare(n - 1);\n\n    calc == {\n      sumOdds(n);\n      (2 * n - 1) + sumOdds(n - 1);\n      { // Induction hypothesis\n        assert sumOdds(n - 1) == (n - 1) * (n - 1);\n      }\n      (2 * n - 1) + (n - 1) * (n - 1);\n      { // Expand (n-1)\u00b2\n        assert (n - 1) * (n - 1) == n * n - 2 * n + 1;\n      }\n      (2 * n - 1) + (n * n - 2 * n + 1);\n      2 * n - 1 + n * n - 2 * n + 1;\n      n * n;\n    }\n  }\n}\n\nlemma SumSquaresFormula(n: nat)\n  ensures sumSquares(n) == n * (n + 1) * (2 * n + 1) / 6\n{\n  if n == 0 {\n    // Base case\n    assert sumSquares(0) == 0;\n    assert 0 * (0 + 1) * (2 * 0 + 1) / 6 == 0;\n  } else {\n    // Inductive step\n    SumSquaresFormula(n - 1);\n\n    calc == {\n      sumSquares(n);\n      n * n + sumSquares(n - 1);\n      { // Induction hypothesis\n        assert sumSquares(n - 1) == (n - 1) * n * (2 * n - 1) / 6;\n      }\n      n * n + (n - 1) * n * (2 * n - 1) / 6;\n      { // Factor out common terms\n        assert n * n == 6 * n * n / 6;\n      }\n      6 * n * n / 6 + (n - 1) * n * (2 * n - 1) / 6;\n      (6 * n * n + (n - 1) * n * (2 * n - 1)) / 6;\n      { // Expand\n        assert (n - 1) * n * (2 * n - 1) == n * (n - 1) * (2 * n - 1);\n        assert n * (n - 1) * (2 * n - 1) == n * (2 * n * n - 3 * n + 1);\n        assert n * (2 * n * n - 3 * n + 1) == 2 * n * n * n - 3 * n * n + n;\n      }\n      (6 * n * n + 2 * n * n * n - 3 * n * n + n) / 6;\n      (2 * n * n * n + 3 * n * n + n) / 6;\n      n * (2 * n * n + 3 * n + 1) / 6;\n      { // Factor\n        assert 2 * n * n + 3 * n + 1 == (n + 1) * (2 * n + 1);\n      }\n      n * (n + 1) * (2 * n + 1) / 6;\n    }\n  }\n}\n\nlemma PowerOfTwo(n: nat)\n  ensures power(2, n) >= n + 1\n{\n  if n == 0 {\n    // Base case\n    assert power(2, 0) == 1;\n    assert 1 >= 0 + 1;\n  } else {\n    // Inductive step\n    PowerOfTwo(n - 1);\n\n    calc >= {\n      power(2, n);\n      2 * power(2, n - 1);\n      { // Induction hypothesis\n        assert power(2, n - 1) >= n;\n      }\n      2 * n;\n      { // Since n >= 1\n        assert n >= 1;\n        assert 2 * n >= n + 1;\n      }\n      n + 1;\n    }\n  }\n}\n\nlemma PowerMonotonic(base: nat, exp1: nat, exp2: nat)\n  requires base > 1\n  requires exp1 <= exp2\n  ensures power(base, exp1) <= power(base, exp2)\n{\n  if exp1 == exp2 {\n    // Equal case\n    assert power(base, exp1) == power(base, exp2);\n  } else {\n    // exp1 < exp2\n    assert exp1 < exp2;\n\n    if exp1 == 0 {\n      assert power(base, exp1) == 1;\n      PowerPositive(base, exp2);\n      assert power(base, exp2) >= 1;\n    } else {\n      // Both exp1 and exp2 are positive\n      PowerMonotonic(base, exp1 - 1, exp2 - 1);\n\n      calc <= {\n        power(base, exp1);\n        base * power(base, exp1 - 1);\n        { // Induction hypothesis\n          assert power(base, exp1 - 1) <= power(base, exp2 - 1);\n        }\n        base * power(base, exp2 - 1);\n        power(base, exp2);\n      }\n    }\n  }\n}\n\nlemma PowerPositive(base: nat, exp: nat)\n  requires base > 0\n  ensures power(base, exp) > 0\n{\n  if exp == 0 {\n    assert power(base, 0) == 1;\n  } else {\n    PowerPositive(base, exp - 1);\n    assert power(base, exp) == base * power(base, exp - 1);\n    assert base > 0 && power(base, exp - 1) > 0;\n  }\n}\n\nlemma FibonacciInequality(n: nat)\n  requires n >= 1\n  ensures fib(n) <= power(2, n - 1)\n{\n  if n == 1 {\n    // Base case\n    assert fib(1) == 1;\n    assert power(2, 0) == 1;\n  } else if n == 2 {\n    // Base case\n    assert fib(2) == 1;\n    assert power(2, 1) == 2;\n    assert 1 <= 2;\n  } else {\n    // Inductive step (n >= 3)\n    \n/*[CODE HERE]*/\n    FibonacciInequality(n - 1);\n    FibonacciInequality(n - 2);\n\n    calc <= {\n      fib(n);\n      fib(n - 1) + fib(n - 2);\n      { // Induction hypotheses\n        assert fib(n - 1) <= power(2, n - 2);\n        assert fib(n - 2) <= power(2, n - 3);\n      }\n      power(2, n - 2) + power(2, n - 3);\n      { // Factor out power(2, n - 3)\n        assert power(2, n - 2) == 2 * power(2, n - 3);\n      }\n      2 * power(2, n - 3) + power(2, n - 3);\n      3 * power(2, n - 3);\n      { // 3 * 2^(n-3) <= 4 * 2^(n-3) = 2^(n-1)\n        assert 3 <= 4;\n        assert power(2, n - 1) == 4 * power(2, n - 3);\n      }\n      power(2, n - 1);\n    }\n  }\n}\n\nlemma StrongInduction(n: nat, P: nat -> bool)\n  requires forall k :: 0 <= k < n ==> P(k)\n  requires forall m :: m >= n && (forall j :: n <= j < m ==> P(j)) ==> P(m)\n  ensures P(n)\n{\n  // This demonstrates the strong induction principle\n  // Base case: all k < n satisfy P(k) by hypothesis\n  // Inductive case: if all j in [n, m) satisfy P, then P(m) holds\n\n  // The proof would proceed by showing P(n) directly\n  // using the second hypothesis with m = n\n  assert forall j :: n <= j < n ==> P(j); // Vacuously true\n}\n\nlemma CompleteInduction(n: nat, P: nat -> bool)\n  requires P(0)\n  requires forall k: nat :: k > 0 && (forall j: nat :: j < k ==> P(j)) ==> P(k)\n  ensures P(n)\n{\n  if n == 0 {\n    // Base case\n    assert P(0);\n  } else {\n    // Need to show all j < n satisfy P(j)\n    forall j: nat | j < n\n      ensures P(j)\n    {\n      if j == 0 {\n        assert P(0);\n      } else {\n        CompleteInduction(j, P);\n      }\n    }\n\n    // Now apply the inductive hypothesis\n    assert forall j: nat :: j < n ==> P(j);\n    assert P(n);\n  }\n}", "output": "assert n >= 3;"}, {"id": "example_FibonacciInequality_8", "type": "assert", "program": "// Induction proofs with detailed reasoning steps\n\n// Sum of first n natural numbers\nfunction {:spec} sumTo(n: nat): nat\n{\n  if n == 0 then 0 else n + sumTo(n - 1)\n}\n\n// Sum of first n odd numbers\nfunction {:spec} sumOdds(n: nat): nat\n{\n  if n == 0 then 0 else (2 * n - 1) + sumOdds(n - 1)\n}\n\n// Sum of first n squares\nfunction {:spec} sumSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + sumSquares(n - 1)\n}\n\n// Power function\nfunction {:spec} power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\n// Fibonacci\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// --- Detailed Inductive Proofs ---\n\nlemma SumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    // Base case\n    assert sumTo(0) == 0;\n    assert 0 * (0 + 1) / 2 == 0;\n  } else {\n    // Inductive step\n    SumToFormula(n - 1);\n\n    calc == {\n      sumTo(n);\n      n + sumTo(n - 1);\n      { // Induction hypothesis\n        assert sumTo(n - 1) == (n - 1) * n / 2;\n      }\n      n + (n - 1) * n / 2;\n      { // Algebra\n        assert n == 2 * n / 2;\n      }\n      2 * n / 2 + (n - 1) * n / 2;\n      (2 * n + (n - 1) * n) / 2;\n      (2 * n + n * n - n) / 2;\n      (n + n * n) / 2;\n      n * (1 + n) / 2;\n      n * (n + 1) / 2;\n    }\n  }\n}\n\nlemma SumOddsIsSquare(n: nat)\n  ensures sumOdds(n) == n * n\n{\n  if n == 0 {\n    // Base case\n    assert sumOdds(0) == 0;\n    assert 0 * 0 == 0;\n  } else {\n    // Inductive step\n    SumOddsIsSquare(n - 1);\n\n    calc == {\n      sumOdds(n);\n      (2 * n - 1) + sumOdds(n - 1);\n      { // Induction hypothesis\n        assert sumOdds(n - 1) == (n - 1) * (n - 1);\n      }\n      (2 * n - 1) + (n - 1) * (n - 1);\n      { // Expand (n-1)\u00b2\n        assert (n - 1) * (n - 1) == n * n - 2 * n + 1;\n      }\n      (2 * n - 1) + (n * n - 2 * n + 1);\n      2 * n - 1 + n * n - 2 * n + 1;\n      n * n;\n    }\n  }\n}\n\nlemma SumSquaresFormula(n: nat)\n  ensures sumSquares(n) == n * (n + 1) * (2 * n + 1) / 6\n{\n  if n == 0 {\n    // Base case\n    assert sumSquares(0) == 0;\n    assert 0 * (0 + 1) * (2 * 0 + 1) / 6 == 0;\n  } else {\n    // Inductive step\n    SumSquaresFormula(n - 1);\n\n    calc == {\n      sumSquares(n);\n      n * n + sumSquares(n - 1);\n      { // Induction hypothesis\n        assert sumSquares(n - 1) == (n - 1) * n * (2 * n - 1) / 6;\n      }\n      n * n + (n - 1) * n * (2 * n - 1) / 6;\n      { // Factor out common terms\n        assert n * n == 6 * n * n / 6;\n      }\n      6 * n * n / 6 + (n - 1) * n * (2 * n - 1) / 6;\n      (6 * n * n + (n - 1) * n * (2 * n - 1)) / 6;\n      { // Expand\n        assert (n - 1) * n * (2 * n - 1) == n * (n - 1) * (2 * n - 1);\n        assert n * (n - 1) * (2 * n - 1) == n * (2 * n * n - 3 * n + 1);\n        assert n * (2 * n * n - 3 * n + 1) == 2 * n * n * n - 3 * n * n + n;\n      }\n      (6 * n * n + 2 * n * n * n - 3 * n * n + n) / 6;\n      (2 * n * n * n + 3 * n * n + n) / 6;\n      n * (2 * n * n + 3 * n + 1) / 6;\n      { // Factor\n        assert 2 * n * n + 3 * n + 1 == (n + 1) * (2 * n + 1);\n      }\n      n * (n + 1) * (2 * n + 1) / 6;\n    }\n  }\n}\n\nlemma PowerOfTwo(n: nat)\n  ensures power(2, n) >= n + 1\n{\n  if n == 0 {\n    // Base case\n    assert power(2, 0) == 1;\n    assert 1 >= 0 + 1;\n  } else {\n    // Inductive step\n    PowerOfTwo(n - 1);\n\n    calc >= {\n      power(2, n);\n      2 * power(2, n - 1);\n      { // Induction hypothesis\n        assert power(2, n - 1) >= n;\n      }\n      2 * n;\n      { // Since n >= 1\n        assert n >= 1;\n        assert 2 * n >= n + 1;\n      }\n      n + 1;\n    }\n  }\n}\n\nlemma PowerMonotonic(base: nat, exp1: nat, exp2: nat)\n  requires base > 1\n  requires exp1 <= exp2\n  ensures power(base, exp1) <= power(base, exp2)\n{\n  if exp1 == exp2 {\n    // Equal case\n    assert power(base, exp1) == power(base, exp2);\n  } else {\n    // exp1 < exp2\n    assert exp1 < exp2;\n\n    if exp1 == 0 {\n      assert power(base, exp1) == 1;\n      PowerPositive(base, exp2);\n      assert power(base, exp2) >= 1;\n    } else {\n      // Both exp1 and exp2 are positive\n      PowerMonotonic(base, exp1 - 1, exp2 - 1);\n\n      calc <= {\n        power(base, exp1);\n        base * power(base, exp1 - 1);\n        { // Induction hypothesis\n          assert power(base, exp1 - 1) <= power(base, exp2 - 1);\n        }\n        base * power(base, exp2 - 1);\n        power(base, exp2);\n      }\n    }\n  }\n}\n\nlemma PowerPositive(base: nat, exp: nat)\n  requires base > 0\n  ensures power(base, exp) > 0\n{\n  if exp == 0 {\n    assert power(base, 0) == 1;\n  } else {\n    PowerPositive(base, exp - 1);\n    assert power(base, exp) == base * power(base, exp - 1);\n    assert base > 0 && power(base, exp - 1) > 0;\n  }\n}\n\nlemma FibonacciInequality(n: nat)\n  requires n >= 1\n  ensures fib(n) <= power(2, n - 1)\n{\n  if n == 1 {\n    // Base case\n    assert fib(1) == 1;\n    assert power(2, 0) == 1;\n  } else if n == 2 {\n    // Base case\n    assert fib(2) == 1;\n    assert power(2, 1) == 2;\n    \n/*[CODE HERE]*/\n  } else {\n    // Inductive step (n >= 3)\n    assert n >= 3;\n    FibonacciInequality(n - 1);\n    FibonacciInequality(n - 2);\n\n    calc <= {\n      fib(n);\n      fib(n - 1) + fib(n - 2);\n      { // Induction hypotheses\n        assert fib(n - 1) <= power(2, n - 2);\n        assert fib(n - 2) <= power(2, n - 3);\n      }\n      power(2, n - 2) + power(2, n - 3);\n      { // Factor out power(2, n - 3)\n        assert power(2, n - 2) == 2 * power(2, n - 3);\n      }\n      2 * power(2, n - 3) + power(2, n - 3);\n      3 * power(2, n - 3);\n      { // 3 * 2^(n-3) <= 4 * 2^(n-3) = 2^(n-1)\n        assert 3 <= 4;\n        assert power(2, n - 1) == 4 * power(2, n - 3);\n      }\n      power(2, n - 1);\n    }\n  }\n}\n\nlemma StrongInduction(n: nat, P: nat -> bool)\n  requires forall k :: 0 <= k < n ==> P(k)\n  requires forall m :: m >= n && (forall j :: n <= j < m ==> P(j)) ==> P(m)\n  ensures P(n)\n{\n  // This demonstrates the strong induction principle\n  // Base case: all k < n satisfy P(k) by hypothesis\n  // Inductive case: if all j in [n, m) satisfy P, then P(m) holds\n\n  // The proof would proceed by showing P(n) directly\n  // using the second hypothesis with m = n\n  assert forall j :: n <= j < n ==> P(j); // Vacuously true\n}\n\nlemma CompleteInduction(n: nat, P: nat -> bool)\n  requires P(0)\n  requires forall k: nat :: k > 0 && (forall j: nat :: j < k ==> P(j)) ==> P(k)\n  ensures P(n)\n{\n  if n == 0 {\n    // Base case\n    assert P(0);\n  } else {\n    // Need to show all j < n satisfy P(j)\n    forall j: nat | j < n\n      ensures P(j)\n    {\n      if j == 0 {\n        assert P(0);\n      } else {\n        CompleteInduction(j, P);\n      }\n    }\n\n    // Now apply the inductive hypothesis\n    assert forall j: nat :: j < n ==> P(j);\n    assert P(n);\n  }\n}", "output": "assert 1 <= 2;"}, {"id": "example_FibonacciInequality_9", "type": "assert", "program": "// Induction proofs with detailed reasoning steps\n\n// Sum of first n natural numbers\nfunction {:spec} sumTo(n: nat): nat\n{\n  if n == 0 then 0 else n + sumTo(n - 1)\n}\n\n// Sum of first n odd numbers\nfunction {:spec} sumOdds(n: nat): nat\n{\n  if n == 0 then 0 else (2 * n - 1) + sumOdds(n - 1)\n}\n\n// Sum of first n squares\nfunction {:spec} sumSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + sumSquares(n - 1)\n}\n\n// Power function\nfunction {:spec} power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\n// Fibonacci\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// --- Detailed Inductive Proofs ---\n\nlemma SumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    // Base case\n    assert sumTo(0) == 0;\n    assert 0 * (0 + 1) / 2 == 0;\n  } else {\n    // Inductive step\n    SumToFormula(n - 1);\n\n    calc == {\n      sumTo(n);\n      n + sumTo(n - 1);\n      { // Induction hypothesis\n        assert sumTo(n - 1) == (n - 1) * n / 2;\n      }\n      n + (n - 1) * n / 2;\n      { // Algebra\n        assert n == 2 * n / 2;\n      }\n      2 * n / 2 + (n - 1) * n / 2;\n      (2 * n + (n - 1) * n) / 2;\n      (2 * n + n * n - n) / 2;\n      (n + n * n) / 2;\n      n * (1 + n) / 2;\n      n * (n + 1) / 2;\n    }\n  }\n}\n\nlemma SumOddsIsSquare(n: nat)\n  ensures sumOdds(n) == n * n\n{\n  if n == 0 {\n    // Base case\n    assert sumOdds(0) == 0;\n    assert 0 * 0 == 0;\n  } else {\n    // Inductive step\n    SumOddsIsSquare(n - 1);\n\n    calc == {\n      sumOdds(n);\n      (2 * n - 1) + sumOdds(n - 1);\n      { // Induction hypothesis\n        assert sumOdds(n - 1) == (n - 1) * (n - 1);\n      }\n      (2 * n - 1) + (n - 1) * (n - 1);\n      { // Expand (n-1)\u00b2\n        assert (n - 1) * (n - 1) == n * n - 2 * n + 1;\n      }\n      (2 * n - 1) + (n * n - 2 * n + 1);\n      2 * n - 1 + n * n - 2 * n + 1;\n      n * n;\n    }\n  }\n}\n\nlemma SumSquaresFormula(n: nat)\n  ensures sumSquares(n) == n * (n + 1) * (2 * n + 1) / 6\n{\n  if n == 0 {\n    // Base case\n    assert sumSquares(0) == 0;\n    assert 0 * (0 + 1) * (2 * 0 + 1) / 6 == 0;\n  } else {\n    // Inductive step\n    SumSquaresFormula(n - 1);\n\n    calc == {\n      sumSquares(n);\n      n * n + sumSquares(n - 1);\n      { // Induction hypothesis\n        assert sumSquares(n - 1) == (n - 1) * n * (2 * n - 1) / 6;\n      }\n      n * n + (n - 1) * n * (2 * n - 1) / 6;\n      { // Factor out common terms\n        assert n * n == 6 * n * n / 6;\n      }\n      6 * n * n / 6 + (n - 1) * n * (2 * n - 1) / 6;\n      (6 * n * n + (n - 1) * n * (2 * n - 1)) / 6;\n      { // Expand\n        assert (n - 1) * n * (2 * n - 1) == n * (n - 1) * (2 * n - 1);\n        assert n * (n - 1) * (2 * n - 1) == n * (2 * n * n - 3 * n + 1);\n        assert n * (2 * n * n - 3 * n + 1) == 2 * n * n * n - 3 * n * n + n;\n      }\n      (6 * n * n + 2 * n * n * n - 3 * n * n + n) / 6;\n      (2 * n * n * n + 3 * n * n + n) / 6;\n      n * (2 * n * n + 3 * n + 1) / 6;\n      { // Factor\n        assert 2 * n * n + 3 * n + 1 == (n + 1) * (2 * n + 1);\n      }\n      n * (n + 1) * (2 * n + 1) / 6;\n    }\n  }\n}\n\nlemma PowerOfTwo(n: nat)\n  ensures power(2, n) >= n + 1\n{\n  if n == 0 {\n    // Base case\n    assert power(2, 0) == 1;\n    assert 1 >= 0 + 1;\n  } else {\n    // Inductive step\n    PowerOfTwo(n - 1);\n\n    calc >= {\n      power(2, n);\n      2 * power(2, n - 1);\n      { // Induction hypothesis\n        assert power(2, n - 1) >= n;\n      }\n      2 * n;\n      { // Since n >= 1\n        assert n >= 1;\n        assert 2 * n >= n + 1;\n      }\n      n + 1;\n    }\n  }\n}\n\nlemma PowerMonotonic(base: nat, exp1: nat, exp2: nat)\n  requires base > 1\n  requires exp1 <= exp2\n  ensures power(base, exp1) <= power(base, exp2)\n{\n  if exp1 == exp2 {\n    // Equal case\n    assert power(base, exp1) == power(base, exp2);\n  } else {\n    // exp1 < exp2\n    assert exp1 < exp2;\n\n    if exp1 == 0 {\n      assert power(base, exp1) == 1;\n      PowerPositive(base, exp2);\n      assert power(base, exp2) >= 1;\n    } else {\n      // Both exp1 and exp2 are positive\n      PowerMonotonic(base, exp1 - 1, exp2 - 1);\n\n      calc <= {\n        power(base, exp1);\n        base * power(base, exp1 - 1);\n        { // Induction hypothesis\n          assert power(base, exp1 - 1) <= power(base, exp2 - 1);\n        }\n        base * power(base, exp2 - 1);\n        power(base, exp2);\n      }\n    }\n  }\n}\n\nlemma PowerPositive(base: nat, exp: nat)\n  requires base > 0\n  ensures power(base, exp) > 0\n{\n  if exp == 0 {\n    assert power(base, 0) == 1;\n  } else {\n    PowerPositive(base, exp - 1);\n    assert power(base, exp) == base * power(base, exp - 1);\n    assert base > 0 && power(base, exp - 1) > 0;\n  }\n}\n\nlemma FibonacciInequality(n: nat)\n  requires n >= 1\n  ensures fib(n) <= power(2, n - 1)\n{\n  if n == 1 {\n    // Base case\n    assert fib(1) == 1;\n    assert power(2, 0) == 1;\n  } else if n == 2 {\n    // Base case\n    assert fib(2) == 1;\n    \n/*[CODE HERE]*/\n    assert 1 <= 2;\n  } else {\n    // Inductive step (n >= 3)\n    assert n >= 3;\n    FibonacciInequality(n - 1);\n    FibonacciInequality(n - 2);\n\n    calc <= {\n      fib(n);\n      fib(n - 1) + fib(n - 2);\n      { // Induction hypotheses\n        assert fib(n - 1) <= power(2, n - 2);\n        assert fib(n - 2) <= power(2, n - 3);\n      }\n      power(2, n - 2) + power(2, n - 3);\n      { // Factor out power(2, n - 3)\n        assert power(2, n - 2) == 2 * power(2, n - 3);\n      }\n      2 * power(2, n - 3) + power(2, n - 3);\n      3 * power(2, n - 3);\n      { // 3 * 2^(n-3) <= 4 * 2^(n-3) = 2^(n-1)\n        assert 3 <= 4;\n        assert power(2, n - 1) == 4 * power(2, n - 3);\n      }\n      power(2, n - 1);\n    }\n  }\n}\n\nlemma StrongInduction(n: nat, P: nat -> bool)\n  requires forall k :: 0 <= k < n ==> P(k)\n  requires forall m :: m >= n && (forall j :: n <= j < m ==> P(j)) ==> P(m)\n  ensures P(n)\n{\n  // This demonstrates the strong induction principle\n  // Base case: all k < n satisfy P(k) by hypothesis\n  // Inductive case: if all j in [n, m) satisfy P, then P(m) holds\n\n  // The proof would proceed by showing P(n) directly\n  // using the second hypothesis with m = n\n  assert forall j :: n <= j < n ==> P(j); // Vacuously true\n}\n\nlemma CompleteInduction(n: nat, P: nat -> bool)\n  requires P(0)\n  requires forall k: nat :: k > 0 && (forall j: nat :: j < k ==> P(j)) ==> P(k)\n  ensures P(n)\n{\n  if n == 0 {\n    // Base case\n    assert P(0);\n  } else {\n    // Need to show all j < n satisfy P(j)\n    forall j: nat | j < n\n      ensures P(j)\n    {\n      if j == 0 {\n        assert P(0);\n      } else {\n        CompleteInduction(j, P);\n      }\n    }\n\n    // Now apply the inductive hypothesis\n    assert forall j: nat :: j < n ==> P(j);\n    assert P(n);\n  }\n}", "output": "assert power(2, 1) == 2;"}, {"id": "example_FibonacciInequality_10", "type": "assert", "program": "// Induction proofs with detailed reasoning steps\n\n// Sum of first n natural numbers\nfunction {:spec} sumTo(n: nat): nat\n{\n  if n == 0 then 0 else n + sumTo(n - 1)\n}\n\n// Sum of first n odd numbers\nfunction {:spec} sumOdds(n: nat): nat\n{\n  if n == 0 then 0 else (2 * n - 1) + sumOdds(n - 1)\n}\n\n// Sum of first n squares\nfunction {:spec} sumSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + sumSquares(n - 1)\n}\n\n// Power function\nfunction {:spec} power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\n// Fibonacci\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// --- Detailed Inductive Proofs ---\n\nlemma SumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    // Base case\n    assert sumTo(0) == 0;\n    assert 0 * (0 + 1) / 2 == 0;\n  } else {\n    // Inductive step\n    SumToFormula(n - 1);\n\n    calc == {\n      sumTo(n);\n      n + sumTo(n - 1);\n      { // Induction hypothesis\n        assert sumTo(n - 1) == (n - 1) * n / 2;\n      }\n      n + (n - 1) * n / 2;\n      { // Algebra\n        assert n == 2 * n / 2;\n      }\n      2 * n / 2 + (n - 1) * n / 2;\n      (2 * n + (n - 1) * n) / 2;\n      (2 * n + n * n - n) / 2;\n      (n + n * n) / 2;\n      n * (1 + n) / 2;\n      n * (n + 1) / 2;\n    }\n  }\n}\n\nlemma SumOddsIsSquare(n: nat)\n  ensures sumOdds(n) == n * n\n{\n  if n == 0 {\n    // Base case\n    assert sumOdds(0) == 0;\n    assert 0 * 0 == 0;\n  } else {\n    // Inductive step\n    SumOddsIsSquare(n - 1);\n\n    calc == {\n      sumOdds(n);\n      (2 * n - 1) + sumOdds(n - 1);\n      { // Induction hypothesis\n        assert sumOdds(n - 1) == (n - 1) * (n - 1);\n      }\n      (2 * n - 1) + (n - 1) * (n - 1);\n      { // Expand (n-1)\u00b2\n        assert (n - 1) * (n - 1) == n * n - 2 * n + 1;\n      }\n      (2 * n - 1) + (n * n - 2 * n + 1);\n      2 * n - 1 + n * n - 2 * n + 1;\n      n * n;\n    }\n  }\n}\n\nlemma SumSquaresFormula(n: nat)\n  ensures sumSquares(n) == n * (n + 1) * (2 * n + 1) / 6\n{\n  if n == 0 {\n    // Base case\n    assert sumSquares(0) == 0;\n    assert 0 * (0 + 1) * (2 * 0 + 1) / 6 == 0;\n  } else {\n    // Inductive step\n    SumSquaresFormula(n - 1);\n\n    calc == {\n      sumSquares(n);\n      n * n + sumSquares(n - 1);\n      { // Induction hypothesis\n        assert sumSquares(n - 1) == (n - 1) * n * (2 * n - 1) / 6;\n      }\n      n * n + (n - 1) * n * (2 * n - 1) / 6;\n      { // Factor out common terms\n        assert n * n == 6 * n * n / 6;\n      }\n      6 * n * n / 6 + (n - 1) * n * (2 * n - 1) / 6;\n      (6 * n * n + (n - 1) * n * (2 * n - 1)) / 6;\n      { // Expand\n        assert (n - 1) * n * (2 * n - 1) == n * (n - 1) * (2 * n - 1);\n        assert n * (n - 1) * (2 * n - 1) == n * (2 * n * n - 3 * n + 1);\n        assert n * (2 * n * n - 3 * n + 1) == 2 * n * n * n - 3 * n * n + n;\n      }\n      (6 * n * n + 2 * n * n * n - 3 * n * n + n) / 6;\n      (2 * n * n * n + 3 * n * n + n) / 6;\n      n * (2 * n * n + 3 * n + 1) / 6;\n      { // Factor\n        assert 2 * n * n + 3 * n + 1 == (n + 1) * (2 * n + 1);\n      }\n      n * (n + 1) * (2 * n + 1) / 6;\n    }\n  }\n}\n\nlemma PowerOfTwo(n: nat)\n  ensures power(2, n) >= n + 1\n{\n  if n == 0 {\n    // Base case\n    assert power(2, 0) == 1;\n    assert 1 >= 0 + 1;\n  } else {\n    // Inductive step\n    PowerOfTwo(n - 1);\n\n    calc >= {\n      power(2, n);\n      2 * power(2, n - 1);\n      { // Induction hypothesis\n        assert power(2, n - 1) >= n;\n      }\n      2 * n;\n      { // Since n >= 1\n        assert n >= 1;\n        assert 2 * n >= n + 1;\n      }\n      n + 1;\n    }\n  }\n}\n\nlemma PowerMonotonic(base: nat, exp1: nat, exp2: nat)\n  requires base > 1\n  requires exp1 <= exp2\n  ensures power(base, exp1) <= power(base, exp2)\n{\n  if exp1 == exp2 {\n    // Equal case\n    assert power(base, exp1) == power(base, exp2);\n  } else {\n    // exp1 < exp2\n    assert exp1 < exp2;\n\n    if exp1 == 0 {\n      assert power(base, exp1) == 1;\n      PowerPositive(base, exp2);\n      assert power(base, exp2) >= 1;\n    } else {\n      // Both exp1 and exp2 are positive\n      PowerMonotonic(base, exp1 - 1, exp2 - 1);\n\n      calc <= {\n        power(base, exp1);\n        base * power(base, exp1 - 1);\n        { // Induction hypothesis\n          assert power(base, exp1 - 1) <= power(base, exp2 - 1);\n        }\n        base * power(base, exp2 - 1);\n        power(base, exp2);\n      }\n    }\n  }\n}\n\nlemma PowerPositive(base: nat, exp: nat)\n  requires base > 0\n  ensures power(base, exp) > 0\n{\n  if exp == 0 {\n    assert power(base, 0) == 1;\n  } else {\n    PowerPositive(base, exp - 1);\n    assert power(base, exp) == base * power(base, exp - 1);\n    assert base > 0 && power(base, exp - 1) > 0;\n  }\n}\n\nlemma FibonacciInequality(n: nat)\n  requires n >= 1\n  ensures fib(n) <= power(2, n - 1)\n{\n  if n == 1 {\n    // Base case\n    assert fib(1) == 1;\n    assert power(2, 0) == 1;\n  } else if n == 2 {\n    // Base case\n    \n/*[CODE HERE]*/\n    assert power(2, 1) == 2;\n    assert 1 <= 2;\n  } else {\n    // Inductive step (n >= 3)\n    assert n >= 3;\n    FibonacciInequality(n - 1);\n    FibonacciInequality(n - 2);\n\n    calc <= {\n      fib(n);\n      fib(n - 1) + fib(n - 2);\n      { // Induction hypotheses\n        assert fib(n - 1) <= power(2, n - 2);\n        assert fib(n - 2) <= power(2, n - 3);\n      }\n      power(2, n - 2) + power(2, n - 3);\n      { // Factor out power(2, n - 3)\n        assert power(2, n - 2) == 2 * power(2, n - 3);\n      }\n      2 * power(2, n - 3) + power(2, n - 3);\n      3 * power(2, n - 3);\n      { // 3 * 2^(n-3) <= 4 * 2^(n-3) = 2^(n-1)\n        assert 3 <= 4;\n        assert power(2, n - 1) == 4 * power(2, n - 3);\n      }\n      power(2, n - 1);\n    }\n  }\n}\n\nlemma StrongInduction(n: nat, P: nat -> bool)\n  requires forall k :: 0 <= k < n ==> P(k)\n  requires forall m :: m >= n && (forall j :: n <= j < m ==> P(j)) ==> P(m)\n  ensures P(n)\n{\n  // This demonstrates the strong induction principle\n  // Base case: all k < n satisfy P(k) by hypothesis\n  // Inductive case: if all j in [n, m) satisfy P, then P(m) holds\n\n  // The proof would proceed by showing P(n) directly\n  // using the second hypothesis with m = n\n  assert forall j :: n <= j < n ==> P(j); // Vacuously true\n}\n\nlemma CompleteInduction(n: nat, P: nat -> bool)\n  requires P(0)\n  requires forall k: nat :: k > 0 && (forall j: nat :: j < k ==> P(j)) ==> P(k)\n  ensures P(n)\n{\n  if n == 0 {\n    // Base case\n    assert P(0);\n  } else {\n    // Need to show all j < n satisfy P(j)\n    forall j: nat | j < n\n      ensures P(j)\n    {\n      if j == 0 {\n        assert P(0);\n      } else {\n        CompleteInduction(j, P);\n      }\n    }\n\n    // Now apply the inductive hypothesis\n    assert forall j: nat :: j < n ==> P(j);\n    assert P(n);\n  }\n}", "output": "assert fib(2) == 1;"}, {"id": "example_FibonacciInequality_11", "type": "assert", "program": "// Induction proofs with detailed reasoning steps\n\n// Sum of first n natural numbers\nfunction {:spec} sumTo(n: nat): nat\n{\n  if n == 0 then 0 else n + sumTo(n - 1)\n}\n\n// Sum of first n odd numbers\nfunction {:spec} sumOdds(n: nat): nat\n{\n  if n == 0 then 0 else (2 * n - 1) + sumOdds(n - 1)\n}\n\n// Sum of first n squares\nfunction {:spec} sumSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + sumSquares(n - 1)\n}\n\n// Power function\nfunction {:spec} power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\n// Fibonacci\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// --- Detailed Inductive Proofs ---\n\nlemma SumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    // Base case\n    assert sumTo(0) == 0;\n    assert 0 * (0 + 1) / 2 == 0;\n  } else {\n    // Inductive step\n    SumToFormula(n - 1);\n\n    calc == {\n      sumTo(n);\n      n + sumTo(n - 1);\n      { // Induction hypothesis\n        assert sumTo(n - 1) == (n - 1) * n / 2;\n      }\n      n + (n - 1) * n / 2;\n      { // Algebra\n        assert n == 2 * n / 2;\n      }\n      2 * n / 2 + (n - 1) * n / 2;\n      (2 * n + (n - 1) * n) / 2;\n      (2 * n + n * n - n) / 2;\n      (n + n * n) / 2;\n      n * (1 + n) / 2;\n      n * (n + 1) / 2;\n    }\n  }\n}\n\nlemma SumOddsIsSquare(n: nat)\n  ensures sumOdds(n) == n * n\n{\n  if n == 0 {\n    // Base case\n    assert sumOdds(0) == 0;\n    assert 0 * 0 == 0;\n  } else {\n    // Inductive step\n    SumOddsIsSquare(n - 1);\n\n    calc == {\n      sumOdds(n);\n      (2 * n - 1) + sumOdds(n - 1);\n      { // Induction hypothesis\n        assert sumOdds(n - 1) == (n - 1) * (n - 1);\n      }\n      (2 * n - 1) + (n - 1) * (n - 1);\n      { // Expand (n-1)\u00b2\n        assert (n - 1) * (n - 1) == n * n - 2 * n + 1;\n      }\n      (2 * n - 1) + (n * n - 2 * n + 1);\n      2 * n - 1 + n * n - 2 * n + 1;\n      n * n;\n    }\n  }\n}\n\nlemma SumSquaresFormula(n: nat)\n  ensures sumSquares(n) == n * (n + 1) * (2 * n + 1) / 6\n{\n  if n == 0 {\n    // Base case\n    assert sumSquares(0) == 0;\n    assert 0 * (0 + 1) * (2 * 0 + 1) / 6 == 0;\n  } else {\n    // Inductive step\n    SumSquaresFormula(n - 1);\n\n    calc == {\n      sumSquares(n);\n      n * n + sumSquares(n - 1);\n      { // Induction hypothesis\n        assert sumSquares(n - 1) == (n - 1) * n * (2 * n - 1) / 6;\n      }\n      n * n + (n - 1) * n * (2 * n - 1) / 6;\n      { // Factor out common terms\n        assert n * n == 6 * n * n / 6;\n      }\n      6 * n * n / 6 + (n - 1) * n * (2 * n - 1) / 6;\n      (6 * n * n + (n - 1) * n * (2 * n - 1)) / 6;\n      { // Expand\n        assert (n - 1) * n * (2 * n - 1) == n * (n - 1) * (2 * n - 1);\n        assert n * (n - 1) * (2 * n - 1) == n * (2 * n * n - 3 * n + 1);\n        assert n * (2 * n * n - 3 * n + 1) == 2 * n * n * n - 3 * n * n + n;\n      }\n      (6 * n * n + 2 * n * n * n - 3 * n * n + n) / 6;\n      (2 * n * n * n + 3 * n * n + n) / 6;\n      n * (2 * n * n + 3 * n + 1) / 6;\n      { // Factor\n        assert 2 * n * n + 3 * n + 1 == (n + 1) * (2 * n + 1);\n      }\n      n * (n + 1) * (2 * n + 1) / 6;\n    }\n  }\n}\n\nlemma PowerOfTwo(n: nat)\n  ensures power(2, n) >= n + 1\n{\n  if n == 0 {\n    // Base case\n    assert power(2, 0) == 1;\n    assert 1 >= 0 + 1;\n  } else {\n    // Inductive step\n    PowerOfTwo(n - 1);\n\n    calc >= {\n      power(2, n);\n      2 * power(2, n - 1);\n      { // Induction hypothesis\n        assert power(2, n - 1) >= n;\n      }\n      2 * n;\n      { // Since n >= 1\n        assert n >= 1;\n        assert 2 * n >= n + 1;\n      }\n      n + 1;\n    }\n  }\n}\n\nlemma PowerMonotonic(base: nat, exp1: nat, exp2: nat)\n  requires base > 1\n  requires exp1 <= exp2\n  ensures power(base, exp1) <= power(base, exp2)\n{\n  if exp1 == exp2 {\n    // Equal case\n    assert power(base, exp1) == power(base, exp2);\n  } else {\n    // exp1 < exp2\n    assert exp1 < exp2;\n\n    if exp1 == 0 {\n      assert power(base, exp1) == 1;\n      PowerPositive(base, exp2);\n      assert power(base, exp2) >= 1;\n    } else {\n      // Both exp1 and exp2 are positive\n      PowerMonotonic(base, exp1 - 1, exp2 - 1);\n\n      calc <= {\n        power(base, exp1);\n        base * power(base, exp1 - 1);\n        { // Induction hypothesis\n          assert power(base, exp1 - 1) <= power(base, exp2 - 1);\n        }\n        base * power(base, exp2 - 1);\n        power(base, exp2);\n      }\n    }\n  }\n}\n\nlemma PowerPositive(base: nat, exp: nat)\n  requires base > 0\n  ensures power(base, exp) > 0\n{\n  if exp == 0 {\n    assert power(base, 0) == 1;\n  } else {\n    PowerPositive(base, exp - 1);\n    assert power(base, exp) == base * power(base, exp - 1);\n    assert base > 0 && power(base, exp - 1) > 0;\n  }\n}\n\nlemma FibonacciInequality(n: nat)\n  requires n >= 1\n  ensures fib(n) <= power(2, n - 1)\n{\n  if n == 1 {\n    // Base case\n    assert fib(1) == 1;\n    \n/*[CODE HERE]*/\n  } else if n == 2 {\n    // Base case\n    assert fib(2) == 1;\n    assert power(2, 1) == 2;\n    assert 1 <= 2;\n  } else {\n    // Inductive step (n >= 3)\n    assert n >= 3;\n    FibonacciInequality(n - 1);\n    FibonacciInequality(n - 2);\n\n    calc <= {\n      fib(n);\n      fib(n - 1) + fib(n - 2);\n      { // Induction hypotheses\n        assert fib(n - 1) <= power(2, n - 2);\n        assert fib(n - 2) <= power(2, n - 3);\n      }\n      power(2, n - 2) + power(2, n - 3);\n      { // Factor out power(2, n - 3)\n        assert power(2, n - 2) == 2 * power(2, n - 3);\n      }\n      2 * power(2, n - 3) + power(2, n - 3);\n      3 * power(2, n - 3);\n      { // 3 * 2^(n-3) <= 4 * 2^(n-3) = 2^(n-1)\n        assert 3 <= 4;\n        assert power(2, n - 1) == 4 * power(2, n - 3);\n      }\n      power(2, n - 1);\n    }\n  }\n}\n\nlemma StrongInduction(n: nat, P: nat -> bool)\n  requires forall k :: 0 <= k < n ==> P(k)\n  requires forall m :: m >= n && (forall j :: n <= j < m ==> P(j)) ==> P(m)\n  ensures P(n)\n{\n  // This demonstrates the strong induction principle\n  // Base case: all k < n satisfy P(k) by hypothesis\n  // Inductive case: if all j in [n, m) satisfy P, then P(m) holds\n\n  // The proof would proceed by showing P(n) directly\n  // using the second hypothesis with m = n\n  assert forall j :: n <= j < n ==> P(j); // Vacuously true\n}\n\nlemma CompleteInduction(n: nat, P: nat -> bool)\n  requires P(0)\n  requires forall k: nat :: k > 0 && (forall j: nat :: j < k ==> P(j)) ==> P(k)\n  ensures P(n)\n{\n  if n == 0 {\n    // Base case\n    assert P(0);\n  } else {\n    // Need to show all j < n satisfy P(j)\n    forall j: nat | j < n\n      ensures P(j)\n    {\n      if j == 0 {\n        assert P(0);\n      } else {\n        CompleteInduction(j, P);\n      }\n    }\n\n    // Now apply the inductive hypothesis\n    assert forall j: nat :: j < n ==> P(j);\n    assert P(n);\n  }\n}", "output": "assert power(2, 0) == 1;"}, {"id": "example_FibonacciInequality_12", "type": "assert", "program": "// Induction proofs with detailed reasoning steps\n\n// Sum of first n natural numbers\nfunction {:spec} sumTo(n: nat): nat\n{\n  if n == 0 then 0 else n + sumTo(n - 1)\n}\n\n// Sum of first n odd numbers\nfunction {:spec} sumOdds(n: nat): nat\n{\n  if n == 0 then 0 else (2 * n - 1) + sumOdds(n - 1)\n}\n\n// Sum of first n squares\nfunction {:spec} sumSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + sumSquares(n - 1)\n}\n\n// Power function\nfunction {:spec} power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\n// Fibonacci\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// --- Detailed Inductive Proofs ---\n\nlemma SumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    // Base case\n    assert sumTo(0) == 0;\n    assert 0 * (0 + 1) / 2 == 0;\n  } else {\n    // Inductive step\n    SumToFormula(n - 1);\n\n    calc == {\n      sumTo(n);\n      n + sumTo(n - 1);\n      { // Induction hypothesis\n        assert sumTo(n - 1) == (n - 1) * n / 2;\n      }\n      n + (n - 1) * n / 2;\n      { // Algebra\n        assert n == 2 * n / 2;\n      }\n      2 * n / 2 + (n - 1) * n / 2;\n      (2 * n + (n - 1) * n) / 2;\n      (2 * n + n * n - n) / 2;\n      (n + n * n) / 2;\n      n * (1 + n) / 2;\n      n * (n + 1) / 2;\n    }\n  }\n}\n\nlemma SumOddsIsSquare(n: nat)\n  ensures sumOdds(n) == n * n\n{\n  if n == 0 {\n    // Base case\n    assert sumOdds(0) == 0;\n    assert 0 * 0 == 0;\n  } else {\n    // Inductive step\n    SumOddsIsSquare(n - 1);\n\n    calc == {\n      sumOdds(n);\n      (2 * n - 1) + sumOdds(n - 1);\n      { // Induction hypothesis\n        assert sumOdds(n - 1) == (n - 1) * (n - 1);\n      }\n      (2 * n - 1) + (n - 1) * (n - 1);\n      { // Expand (n-1)\u00b2\n        assert (n - 1) * (n - 1) == n * n - 2 * n + 1;\n      }\n      (2 * n - 1) + (n * n - 2 * n + 1);\n      2 * n - 1 + n * n - 2 * n + 1;\n      n * n;\n    }\n  }\n}\n\nlemma SumSquaresFormula(n: nat)\n  ensures sumSquares(n) == n * (n + 1) * (2 * n + 1) / 6\n{\n  if n == 0 {\n    // Base case\n    assert sumSquares(0) == 0;\n    assert 0 * (0 + 1) * (2 * 0 + 1) / 6 == 0;\n  } else {\n    // Inductive step\n    SumSquaresFormula(n - 1);\n\n    calc == {\n      sumSquares(n);\n      n * n + sumSquares(n - 1);\n      { // Induction hypothesis\n        assert sumSquares(n - 1) == (n - 1) * n * (2 * n - 1) / 6;\n      }\n      n * n + (n - 1) * n * (2 * n - 1) / 6;\n      { // Factor out common terms\n        assert n * n == 6 * n * n / 6;\n      }\n      6 * n * n / 6 + (n - 1) * n * (2 * n - 1) / 6;\n      (6 * n * n + (n - 1) * n * (2 * n - 1)) / 6;\n      { // Expand\n        assert (n - 1) * n * (2 * n - 1) == n * (n - 1) * (2 * n - 1);\n        assert n * (n - 1) * (2 * n - 1) == n * (2 * n * n - 3 * n + 1);\n        assert n * (2 * n * n - 3 * n + 1) == 2 * n * n * n - 3 * n * n + n;\n      }\n      (6 * n * n + 2 * n * n * n - 3 * n * n + n) / 6;\n      (2 * n * n * n + 3 * n * n + n) / 6;\n      n * (2 * n * n + 3 * n + 1) / 6;\n      { // Factor\n        assert 2 * n * n + 3 * n + 1 == (n + 1) * (2 * n + 1);\n      }\n      n * (n + 1) * (2 * n + 1) / 6;\n    }\n  }\n}\n\nlemma PowerOfTwo(n: nat)\n  ensures power(2, n) >= n + 1\n{\n  if n == 0 {\n    // Base case\n    assert power(2, 0) == 1;\n    assert 1 >= 0 + 1;\n  } else {\n    // Inductive step\n    PowerOfTwo(n - 1);\n\n    calc >= {\n      power(2, n);\n      2 * power(2, n - 1);\n      { // Induction hypothesis\n        assert power(2, n - 1) >= n;\n      }\n      2 * n;\n      { // Since n >= 1\n        assert n >= 1;\n        assert 2 * n >= n + 1;\n      }\n      n + 1;\n    }\n  }\n}\n\nlemma PowerMonotonic(base: nat, exp1: nat, exp2: nat)\n  requires base > 1\n  requires exp1 <= exp2\n  ensures power(base, exp1) <= power(base, exp2)\n{\n  if exp1 == exp2 {\n    // Equal case\n    assert power(base, exp1) == power(base, exp2);\n  } else {\n    // exp1 < exp2\n    assert exp1 < exp2;\n\n    if exp1 == 0 {\n      assert power(base, exp1) == 1;\n      PowerPositive(base, exp2);\n      assert power(base, exp2) >= 1;\n    } else {\n      // Both exp1 and exp2 are positive\n      PowerMonotonic(base, exp1 - 1, exp2 - 1);\n\n      calc <= {\n        power(base, exp1);\n        base * power(base, exp1 - 1);\n        { // Induction hypothesis\n          assert power(base, exp1 - 1) <= power(base, exp2 - 1);\n        }\n        base * power(base, exp2 - 1);\n        power(base, exp2);\n      }\n    }\n  }\n}\n\nlemma PowerPositive(base: nat, exp: nat)\n  requires base > 0\n  ensures power(base, exp) > 0\n{\n  if exp == 0 {\n    assert power(base, 0) == 1;\n  } else {\n    PowerPositive(base, exp - 1);\n    assert power(base, exp) == base * power(base, exp - 1);\n    assert base > 0 && power(base, exp - 1) > 0;\n  }\n}\n\nlemma FibonacciInequality(n: nat)\n  requires n >= 1\n  ensures fib(n) <= power(2, n - 1)\n{\n  if n == 1 {\n    // Base case\n    \n/*[CODE HERE]*/\n    assert power(2, 0) == 1;\n  } else if n == 2 {\n    // Base case\n    assert fib(2) == 1;\n    assert power(2, 1) == 2;\n    assert 1 <= 2;\n  } else {\n    // Inductive step (n >= 3)\n    assert n >= 3;\n    FibonacciInequality(n - 1);\n    FibonacciInequality(n - 2);\n\n    calc <= {\n      fib(n);\n      fib(n - 1) + fib(n - 2);\n      { // Induction hypotheses\n        assert fib(n - 1) <= power(2, n - 2);\n        assert fib(n - 2) <= power(2, n - 3);\n      }\n      power(2, n - 2) + power(2, n - 3);\n      { // Factor out power(2, n - 3)\n        assert power(2, n - 2) == 2 * power(2, n - 3);\n      }\n      2 * power(2, n - 3) + power(2, n - 3);\n      3 * power(2, n - 3);\n      { // 3 * 2^(n-3) <= 4 * 2^(n-3) = 2^(n-1)\n        assert 3 <= 4;\n        assert power(2, n - 1) == 4 * power(2, n - 3);\n      }\n      power(2, n - 1);\n    }\n  }\n}\n\nlemma StrongInduction(n: nat, P: nat -> bool)\n  requires forall k :: 0 <= k < n ==> P(k)\n  requires forall m :: m >= n && (forall j :: n <= j < m ==> P(j)) ==> P(m)\n  ensures P(n)\n{\n  // This demonstrates the strong induction principle\n  // Base case: all k < n satisfy P(k) by hypothesis\n  // Inductive case: if all j in [n, m) satisfy P, then P(m) holds\n\n  // The proof would proceed by showing P(n) directly\n  // using the second hypothesis with m = n\n  assert forall j :: n <= j < n ==> P(j); // Vacuously true\n}\n\nlemma CompleteInduction(n: nat, P: nat -> bool)\n  requires P(0)\n  requires forall k: nat :: k > 0 && (forall j: nat :: j < k ==> P(j)) ==> P(k)\n  ensures P(n)\n{\n  if n == 0 {\n    // Base case\n    assert P(0);\n  } else {\n    // Need to show all j < n satisfy P(j)\n    forall j: nat | j < n\n      ensures P(j)\n    {\n      if j == 0 {\n        assert P(0);\n      } else {\n        CompleteInduction(j, P);\n      }\n    }\n\n    // Now apply the inductive hypothesis\n    assert forall j: nat :: j < n ==> P(j);\n    assert P(n);\n  }\n}", "output": "assert fib(1) == 1;"}, {"id": "example_StrongInduction_0", "type": "assert", "program": "// Induction proofs with detailed reasoning steps\n\n// Sum of first n natural numbers\nfunction {:spec} sumTo(n: nat): nat\n{\n  if n == 0 then 0 else n + sumTo(n - 1)\n}\n\n// Sum of first n odd numbers\nfunction {:spec} sumOdds(n: nat): nat\n{\n  if n == 0 then 0 else (2 * n - 1) + sumOdds(n - 1)\n}\n\n// Sum of first n squares\nfunction {:spec} sumSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + sumSquares(n - 1)\n}\n\n// Power function\nfunction {:spec} power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\n// Fibonacci\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// --- Detailed Inductive Proofs ---\n\nlemma SumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    // Base case\n    assert sumTo(0) == 0;\n    assert 0 * (0 + 1) / 2 == 0;\n  } else {\n    // Inductive step\n    SumToFormula(n - 1);\n\n    calc == {\n      sumTo(n);\n      n + sumTo(n - 1);\n      { // Induction hypothesis\n        assert sumTo(n - 1) == (n - 1) * n / 2;\n      }\n      n + (n - 1) * n / 2;\n      { // Algebra\n        assert n == 2 * n / 2;\n      }\n      2 * n / 2 + (n - 1) * n / 2;\n      (2 * n + (n - 1) * n) / 2;\n      (2 * n + n * n - n) / 2;\n      (n + n * n) / 2;\n      n * (1 + n) / 2;\n      n * (n + 1) / 2;\n    }\n  }\n}\n\nlemma SumOddsIsSquare(n: nat)\n  ensures sumOdds(n) == n * n\n{\n  if n == 0 {\n    // Base case\n    assert sumOdds(0) == 0;\n    assert 0 * 0 == 0;\n  } else {\n    // Inductive step\n    SumOddsIsSquare(n - 1);\n\n    calc == {\n      sumOdds(n);\n      (2 * n - 1) + sumOdds(n - 1);\n      { // Induction hypothesis\n        assert sumOdds(n - 1) == (n - 1) * (n - 1);\n      }\n      (2 * n - 1) + (n - 1) * (n - 1);\n      { // Expand (n-1)\u00b2\n        assert (n - 1) * (n - 1) == n * n - 2 * n + 1;\n      }\n      (2 * n - 1) + (n * n - 2 * n + 1);\n      2 * n - 1 + n * n - 2 * n + 1;\n      n * n;\n    }\n  }\n}\n\nlemma SumSquaresFormula(n: nat)\n  ensures sumSquares(n) == n * (n + 1) * (2 * n + 1) / 6\n{\n  if n == 0 {\n    // Base case\n    assert sumSquares(0) == 0;\n    assert 0 * (0 + 1) * (2 * 0 + 1) / 6 == 0;\n  } else {\n    // Inductive step\n    SumSquaresFormula(n - 1);\n\n    calc == {\n      sumSquares(n);\n      n * n + sumSquares(n - 1);\n      { // Induction hypothesis\n        assert sumSquares(n - 1) == (n - 1) * n * (2 * n - 1) / 6;\n      }\n      n * n + (n - 1) * n * (2 * n - 1) / 6;\n      { // Factor out common terms\n        assert n * n == 6 * n * n / 6;\n      }\n      6 * n * n / 6 + (n - 1) * n * (2 * n - 1) / 6;\n      (6 * n * n + (n - 1) * n * (2 * n - 1)) / 6;\n      { // Expand\n        assert (n - 1) * n * (2 * n - 1) == n * (n - 1) * (2 * n - 1);\n        assert n * (n - 1) * (2 * n - 1) == n * (2 * n * n - 3 * n + 1);\n        assert n * (2 * n * n - 3 * n + 1) == 2 * n * n * n - 3 * n * n + n;\n      }\n      (6 * n * n + 2 * n * n * n - 3 * n * n + n) / 6;\n      (2 * n * n * n + 3 * n * n + n) / 6;\n      n * (2 * n * n + 3 * n + 1) / 6;\n      { // Factor\n        assert 2 * n * n + 3 * n + 1 == (n + 1) * (2 * n + 1);\n      }\n      n * (n + 1) * (2 * n + 1) / 6;\n    }\n  }\n}\n\nlemma PowerOfTwo(n: nat)\n  ensures power(2, n) >= n + 1\n{\n  if n == 0 {\n    // Base case\n    assert power(2, 0) == 1;\n    assert 1 >= 0 + 1;\n  } else {\n    // Inductive step\n    PowerOfTwo(n - 1);\n\n    calc >= {\n      power(2, n);\n      2 * power(2, n - 1);\n      { // Induction hypothesis\n        assert power(2, n - 1) >= n;\n      }\n      2 * n;\n      { // Since n >= 1\n        assert n >= 1;\n        assert 2 * n >= n + 1;\n      }\n      n + 1;\n    }\n  }\n}\n\nlemma PowerMonotonic(base: nat, exp1: nat, exp2: nat)\n  requires base > 1\n  requires exp1 <= exp2\n  ensures power(base, exp1) <= power(base, exp2)\n{\n  if exp1 == exp2 {\n    // Equal case\n    assert power(base, exp1) == power(base, exp2);\n  } else {\n    // exp1 < exp2\n    assert exp1 < exp2;\n\n    if exp1 == 0 {\n      assert power(base, exp1) == 1;\n      PowerPositive(base, exp2);\n      assert power(base, exp2) >= 1;\n    } else {\n      // Both exp1 and exp2 are positive\n      PowerMonotonic(base, exp1 - 1, exp2 - 1);\n\n      calc <= {\n        power(base, exp1);\n        base * power(base, exp1 - 1);\n        { // Induction hypothesis\n          assert power(base, exp1 - 1) <= power(base, exp2 - 1);\n        }\n        base * power(base, exp2 - 1);\n        power(base, exp2);\n      }\n    }\n  }\n}\n\nlemma PowerPositive(base: nat, exp: nat)\n  requires base > 0\n  ensures power(base, exp) > 0\n{\n  if exp == 0 {\n    assert power(base, 0) == 1;\n  } else {\n    PowerPositive(base, exp - 1);\n    assert power(base, exp) == base * power(base, exp - 1);\n    assert base > 0 && power(base, exp - 1) > 0;\n  }\n}\n\nlemma FibonacciInequality(n: nat)\n  requires n >= 1\n  ensures fib(n) <= power(2, n - 1)\n{\n  if n == 1 {\n    // Base case\n    assert fib(1) == 1;\n    assert power(2, 0) == 1;\n  } else if n == 2 {\n    // Base case\n    assert fib(2) == 1;\n    assert power(2, 1) == 2;\n    assert 1 <= 2;\n  } else {\n    // Inductive step (n >= 3)\n    assert n >= 3;\n    FibonacciInequality(n - 1);\n    FibonacciInequality(n - 2);\n\n    calc <= {\n      fib(n);\n      fib(n - 1) + fib(n - 2);\n      { // Induction hypotheses\n        assert fib(n - 1) <= power(2, n - 2);\n        assert fib(n - 2) <= power(2, n - 3);\n      }\n      power(2, n - 2) + power(2, n - 3);\n      { // Factor out power(2, n - 3)\n        assert power(2, n - 2) == 2 * power(2, n - 3);\n      }\n      2 * power(2, n - 3) + power(2, n - 3);\n      3 * power(2, n - 3);\n      { // 3 * 2^(n-3) <= 4 * 2^(n-3) = 2^(n-1)\n        assert 3 <= 4;\n        assert power(2, n - 1) == 4 * power(2, n - 3);\n      }\n      power(2, n - 1);\n    }\n  }\n}\n\nlemma StrongInduction(n: nat, P: nat -> bool)\n  requires forall k :: 0 <= k < n ==> P(k)\n  requires forall m :: m >= n && (forall j :: n <= j < m ==> P(j)) ==> P(m)\n  ensures P(n)\n{\n  // This demonstrates the strong induction principle\n  // Base case: all k < n satisfy P(k) by hypothesis\n  // Inductive case: if all j in [n, m) satisfy P, then P(m) holds\n\n  // The proof would proceed by showing P(n) directly\n  // using the second hypothesis with m = n\n  \n/*[CODE HERE]*/\n// Vacuously true\n}\n\nlemma CompleteInduction(n: nat, P: nat -> bool)\n  requires P(0)\n  requires forall k: nat :: k > 0 && (forall j: nat :: j < k ==> P(j)) ==> P(k)\n  ensures P(n)\n{\n  if n == 0 {\n    // Base case\n    assert P(0);\n  } else {\n    // Need to show all j < n satisfy P(j)\n    forall j: nat | j < n\n      ensures P(j)\n    {\n      if j == 0 {\n        assert P(0);\n      } else {\n        CompleteInduction(j, P);\n      }\n    }\n\n    // Now apply the inductive hypothesis\n    assert forall j: nat :: j < n ==> P(j);\n    assert P(n);\n  }\n}", "output": "assert forall j :: n <= j < n ==> P(j);"}, {"id": "example_CompleteInduction_0", "type": "assert", "program": "// Induction proofs with detailed reasoning steps\n\n// Sum of first n natural numbers\nfunction {:spec} sumTo(n: nat): nat\n{\n  if n == 0 then 0 else n + sumTo(n - 1)\n}\n\n// Sum of first n odd numbers\nfunction {:spec} sumOdds(n: nat): nat\n{\n  if n == 0 then 0 else (2 * n - 1) + sumOdds(n - 1)\n}\n\n// Sum of first n squares\nfunction {:spec} sumSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + sumSquares(n - 1)\n}\n\n// Power function\nfunction {:spec} power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\n// Fibonacci\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// --- Detailed Inductive Proofs ---\n\nlemma SumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    // Base case\n    assert sumTo(0) == 0;\n    assert 0 * (0 + 1) / 2 == 0;\n  } else {\n    // Inductive step\n    SumToFormula(n - 1);\n\n    calc == {\n      sumTo(n);\n      n + sumTo(n - 1);\n      { // Induction hypothesis\n        assert sumTo(n - 1) == (n - 1) * n / 2;\n      }\n      n + (n - 1) * n / 2;\n      { // Algebra\n        assert n == 2 * n / 2;\n      }\n      2 * n / 2 + (n - 1) * n / 2;\n      (2 * n + (n - 1) * n) / 2;\n      (2 * n + n * n - n) / 2;\n      (n + n * n) / 2;\n      n * (1 + n) / 2;\n      n * (n + 1) / 2;\n    }\n  }\n}\n\nlemma SumOddsIsSquare(n: nat)\n  ensures sumOdds(n) == n * n\n{\n  if n == 0 {\n    // Base case\n    assert sumOdds(0) == 0;\n    assert 0 * 0 == 0;\n  } else {\n    // Inductive step\n    SumOddsIsSquare(n - 1);\n\n    calc == {\n      sumOdds(n);\n      (2 * n - 1) + sumOdds(n - 1);\n      { // Induction hypothesis\n        assert sumOdds(n - 1) == (n - 1) * (n - 1);\n      }\n      (2 * n - 1) + (n - 1) * (n - 1);\n      { // Expand (n-1)\u00b2\n        assert (n - 1) * (n - 1) == n * n - 2 * n + 1;\n      }\n      (2 * n - 1) + (n * n - 2 * n + 1);\n      2 * n - 1 + n * n - 2 * n + 1;\n      n * n;\n    }\n  }\n}\n\nlemma SumSquaresFormula(n: nat)\n  ensures sumSquares(n) == n * (n + 1) * (2 * n + 1) / 6\n{\n  if n == 0 {\n    // Base case\n    assert sumSquares(0) == 0;\n    assert 0 * (0 + 1) * (2 * 0 + 1) / 6 == 0;\n  } else {\n    // Inductive step\n    SumSquaresFormula(n - 1);\n\n    calc == {\n      sumSquares(n);\n      n * n + sumSquares(n - 1);\n      { // Induction hypothesis\n        assert sumSquares(n - 1) == (n - 1) * n * (2 * n - 1) / 6;\n      }\n      n * n + (n - 1) * n * (2 * n - 1) / 6;\n      { // Factor out common terms\n        assert n * n == 6 * n * n / 6;\n      }\n      6 * n * n / 6 + (n - 1) * n * (2 * n - 1) / 6;\n      (6 * n * n + (n - 1) * n * (2 * n - 1)) / 6;\n      { // Expand\n        assert (n - 1) * n * (2 * n - 1) == n * (n - 1) * (2 * n - 1);\n        assert n * (n - 1) * (2 * n - 1) == n * (2 * n * n - 3 * n + 1);\n        assert n * (2 * n * n - 3 * n + 1) == 2 * n * n * n - 3 * n * n + n;\n      }\n      (6 * n * n + 2 * n * n * n - 3 * n * n + n) / 6;\n      (2 * n * n * n + 3 * n * n + n) / 6;\n      n * (2 * n * n + 3 * n + 1) / 6;\n      { // Factor\n        assert 2 * n * n + 3 * n + 1 == (n + 1) * (2 * n + 1);\n      }\n      n * (n + 1) * (2 * n + 1) / 6;\n    }\n  }\n}\n\nlemma PowerOfTwo(n: nat)\n  ensures power(2, n) >= n + 1\n{\n  if n == 0 {\n    // Base case\n    assert power(2, 0) == 1;\n    assert 1 >= 0 + 1;\n  } else {\n    // Inductive step\n    PowerOfTwo(n - 1);\n\n    calc >= {\n      power(2, n);\n      2 * power(2, n - 1);\n      { // Induction hypothesis\n        assert power(2, n - 1) >= n;\n      }\n      2 * n;\n      { // Since n >= 1\n        assert n >= 1;\n        assert 2 * n >= n + 1;\n      }\n      n + 1;\n    }\n  }\n}\n\nlemma PowerMonotonic(base: nat, exp1: nat, exp2: nat)\n  requires base > 1\n  requires exp1 <= exp2\n  ensures power(base, exp1) <= power(base, exp2)\n{\n  if exp1 == exp2 {\n    // Equal case\n    assert power(base, exp1) == power(base, exp2);\n  } else {\n    // exp1 < exp2\n    assert exp1 < exp2;\n\n    if exp1 == 0 {\n      assert power(base, exp1) == 1;\n      PowerPositive(base, exp2);\n      assert power(base, exp2) >= 1;\n    } else {\n      // Both exp1 and exp2 are positive\n      PowerMonotonic(base, exp1 - 1, exp2 - 1);\n\n      calc <= {\n        power(base, exp1);\n        base * power(base, exp1 - 1);\n        { // Induction hypothesis\n          assert power(base, exp1 - 1) <= power(base, exp2 - 1);\n        }\n        base * power(base, exp2 - 1);\n        power(base, exp2);\n      }\n    }\n  }\n}\n\nlemma PowerPositive(base: nat, exp: nat)\n  requires base > 0\n  ensures power(base, exp) > 0\n{\n  if exp == 0 {\n    assert power(base, 0) == 1;\n  } else {\n    PowerPositive(base, exp - 1);\n    assert power(base, exp) == base * power(base, exp - 1);\n    assert base > 0 && power(base, exp - 1) > 0;\n  }\n}\n\nlemma FibonacciInequality(n: nat)\n  requires n >= 1\n  ensures fib(n) <= power(2, n - 1)\n{\n  if n == 1 {\n    // Base case\n    assert fib(1) == 1;\n    assert power(2, 0) == 1;\n  } else if n == 2 {\n    // Base case\n    assert fib(2) == 1;\n    assert power(2, 1) == 2;\n    assert 1 <= 2;\n  } else {\n    // Inductive step (n >= 3)\n    assert n >= 3;\n    FibonacciInequality(n - 1);\n    FibonacciInequality(n - 2);\n\n    calc <= {\n      fib(n);\n      fib(n - 1) + fib(n - 2);\n      { // Induction hypotheses\n        assert fib(n - 1) <= power(2, n - 2);\n        assert fib(n - 2) <= power(2, n - 3);\n      }\n      power(2, n - 2) + power(2, n - 3);\n      { // Factor out power(2, n - 3)\n        assert power(2, n - 2) == 2 * power(2, n - 3);\n      }\n      2 * power(2, n - 3) + power(2, n - 3);\n      3 * power(2, n - 3);\n      { // 3 * 2^(n-3) <= 4 * 2^(n-3) = 2^(n-1)\n        assert 3 <= 4;\n        assert power(2, n - 1) == 4 * power(2, n - 3);\n      }\n      power(2, n - 1);\n    }\n  }\n}\n\nlemma StrongInduction(n: nat, P: nat -> bool)\n  requires forall k :: 0 <= k < n ==> P(k)\n  requires forall m :: m >= n && (forall j :: n <= j < m ==> P(j)) ==> P(m)\n  ensures P(n)\n{\n  // This demonstrates the strong induction principle\n  // Base case: all k < n satisfy P(k) by hypothesis\n  // Inductive case: if all j in [n, m) satisfy P, then P(m) holds\n\n  // The proof would proceed by showing P(n) directly\n  // using the second hypothesis with m = n\n  assert forall j :: n <= j < n ==> P(j); // Vacuously true\n}\n\nlemma CompleteInduction(n: nat, P: nat -> bool)\n  requires P(0)\n  requires forall k: nat :: k > 0 && (forall j: nat :: j < k ==> P(j)) ==> P(k)\n  ensures P(n)\n{\n  if n == 0 {\n    // Base case\n    assert P(0);\n  } else {\n    // Need to show all j < n satisfy P(j)\n    forall j: nat | j < n\n      ensures P(j)\n    {\n      if j == 0 {\n        assert P(0);\n      } else {\n        CompleteInduction(j, P);\n      }\n    }\n\n    // Now apply the inductive hypothesis\n    assert forall j: nat :: j < n ==> P(j);\n    \n/*[CODE HERE]*/\n  }\n}", "output": "assert P(n);"}, {"id": "example_CompleteInduction_1", "type": "assert", "program": "// Induction proofs with detailed reasoning steps\n\n// Sum of first n natural numbers\nfunction {:spec} sumTo(n: nat): nat\n{\n  if n == 0 then 0 else n + sumTo(n - 1)\n}\n\n// Sum of first n odd numbers\nfunction {:spec} sumOdds(n: nat): nat\n{\n  if n == 0 then 0 else (2 * n - 1) + sumOdds(n - 1)\n}\n\n// Sum of first n squares\nfunction {:spec} sumSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + sumSquares(n - 1)\n}\n\n// Power function\nfunction {:spec} power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\n// Fibonacci\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// --- Detailed Inductive Proofs ---\n\nlemma SumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    // Base case\n    assert sumTo(0) == 0;\n    assert 0 * (0 + 1) / 2 == 0;\n  } else {\n    // Inductive step\n    SumToFormula(n - 1);\n\n    calc == {\n      sumTo(n);\n      n + sumTo(n - 1);\n      { // Induction hypothesis\n        assert sumTo(n - 1) == (n - 1) * n / 2;\n      }\n      n + (n - 1) * n / 2;\n      { // Algebra\n        assert n == 2 * n / 2;\n      }\n      2 * n / 2 + (n - 1) * n / 2;\n      (2 * n + (n - 1) * n) / 2;\n      (2 * n + n * n - n) / 2;\n      (n + n * n) / 2;\n      n * (1 + n) / 2;\n      n * (n + 1) / 2;\n    }\n  }\n}\n\nlemma SumOddsIsSquare(n: nat)\n  ensures sumOdds(n) == n * n\n{\n  if n == 0 {\n    // Base case\n    assert sumOdds(0) == 0;\n    assert 0 * 0 == 0;\n  } else {\n    // Inductive step\n    SumOddsIsSquare(n - 1);\n\n    calc == {\n      sumOdds(n);\n      (2 * n - 1) + sumOdds(n - 1);\n      { // Induction hypothesis\n        assert sumOdds(n - 1) == (n - 1) * (n - 1);\n      }\n      (2 * n - 1) + (n - 1) * (n - 1);\n      { // Expand (n-1)\u00b2\n        assert (n - 1) * (n - 1) == n * n - 2 * n + 1;\n      }\n      (2 * n - 1) + (n * n - 2 * n + 1);\n      2 * n - 1 + n * n - 2 * n + 1;\n      n * n;\n    }\n  }\n}\n\nlemma SumSquaresFormula(n: nat)\n  ensures sumSquares(n) == n * (n + 1) * (2 * n + 1) / 6\n{\n  if n == 0 {\n    // Base case\n    assert sumSquares(0) == 0;\n    assert 0 * (0 + 1) * (2 * 0 + 1) / 6 == 0;\n  } else {\n    // Inductive step\n    SumSquaresFormula(n - 1);\n\n    calc == {\n      sumSquares(n);\n      n * n + sumSquares(n - 1);\n      { // Induction hypothesis\n        assert sumSquares(n - 1) == (n - 1) * n * (2 * n - 1) / 6;\n      }\n      n * n + (n - 1) * n * (2 * n - 1) / 6;\n      { // Factor out common terms\n        assert n * n == 6 * n * n / 6;\n      }\n      6 * n * n / 6 + (n - 1) * n * (2 * n - 1) / 6;\n      (6 * n * n + (n - 1) * n * (2 * n - 1)) / 6;\n      { // Expand\n        assert (n - 1) * n * (2 * n - 1) == n * (n - 1) * (2 * n - 1);\n        assert n * (n - 1) * (2 * n - 1) == n * (2 * n * n - 3 * n + 1);\n        assert n * (2 * n * n - 3 * n + 1) == 2 * n * n * n - 3 * n * n + n;\n      }\n      (6 * n * n + 2 * n * n * n - 3 * n * n + n) / 6;\n      (2 * n * n * n + 3 * n * n + n) / 6;\n      n * (2 * n * n + 3 * n + 1) / 6;\n      { // Factor\n        assert 2 * n * n + 3 * n + 1 == (n + 1) * (2 * n + 1);\n      }\n      n * (n + 1) * (2 * n + 1) / 6;\n    }\n  }\n}\n\nlemma PowerOfTwo(n: nat)\n  ensures power(2, n) >= n + 1\n{\n  if n == 0 {\n    // Base case\n    assert power(2, 0) == 1;\n    assert 1 >= 0 + 1;\n  } else {\n    // Inductive step\n    PowerOfTwo(n - 1);\n\n    calc >= {\n      power(2, n);\n      2 * power(2, n - 1);\n      { // Induction hypothesis\n        assert power(2, n - 1) >= n;\n      }\n      2 * n;\n      { // Since n >= 1\n        assert n >= 1;\n        assert 2 * n >= n + 1;\n      }\n      n + 1;\n    }\n  }\n}\n\nlemma PowerMonotonic(base: nat, exp1: nat, exp2: nat)\n  requires base > 1\n  requires exp1 <= exp2\n  ensures power(base, exp1) <= power(base, exp2)\n{\n  if exp1 == exp2 {\n    // Equal case\n    assert power(base, exp1) == power(base, exp2);\n  } else {\n    // exp1 < exp2\n    assert exp1 < exp2;\n\n    if exp1 == 0 {\n      assert power(base, exp1) == 1;\n      PowerPositive(base, exp2);\n      assert power(base, exp2) >= 1;\n    } else {\n      // Both exp1 and exp2 are positive\n      PowerMonotonic(base, exp1 - 1, exp2 - 1);\n\n      calc <= {\n        power(base, exp1);\n        base * power(base, exp1 - 1);\n        { // Induction hypothesis\n          assert power(base, exp1 - 1) <= power(base, exp2 - 1);\n        }\n        base * power(base, exp2 - 1);\n        power(base, exp2);\n      }\n    }\n  }\n}\n\nlemma PowerPositive(base: nat, exp: nat)\n  requires base > 0\n  ensures power(base, exp) > 0\n{\n  if exp == 0 {\n    assert power(base, 0) == 1;\n  } else {\n    PowerPositive(base, exp - 1);\n    assert power(base, exp) == base * power(base, exp - 1);\n    assert base > 0 && power(base, exp - 1) > 0;\n  }\n}\n\nlemma FibonacciInequality(n: nat)\n  requires n >= 1\n  ensures fib(n) <= power(2, n - 1)\n{\n  if n == 1 {\n    // Base case\n    assert fib(1) == 1;\n    assert power(2, 0) == 1;\n  } else if n == 2 {\n    // Base case\n    assert fib(2) == 1;\n    assert power(2, 1) == 2;\n    assert 1 <= 2;\n  } else {\n    // Inductive step (n >= 3)\n    assert n >= 3;\n    FibonacciInequality(n - 1);\n    FibonacciInequality(n - 2);\n\n    calc <= {\n      fib(n);\n      fib(n - 1) + fib(n - 2);\n      { // Induction hypotheses\n        assert fib(n - 1) <= power(2, n - 2);\n        assert fib(n - 2) <= power(2, n - 3);\n      }\n      power(2, n - 2) + power(2, n - 3);\n      { // Factor out power(2, n - 3)\n        assert power(2, n - 2) == 2 * power(2, n - 3);\n      }\n      2 * power(2, n - 3) + power(2, n - 3);\n      3 * power(2, n - 3);\n      { // 3 * 2^(n-3) <= 4 * 2^(n-3) = 2^(n-1)\n        assert 3 <= 4;\n        assert power(2, n - 1) == 4 * power(2, n - 3);\n      }\n      power(2, n - 1);\n    }\n  }\n}\n\nlemma StrongInduction(n: nat, P: nat -> bool)\n  requires forall k :: 0 <= k < n ==> P(k)\n  requires forall m :: m >= n && (forall j :: n <= j < m ==> P(j)) ==> P(m)\n  ensures P(n)\n{\n  // This demonstrates the strong induction principle\n  // Base case: all k < n satisfy P(k) by hypothesis\n  // Inductive case: if all j in [n, m) satisfy P, then P(m) holds\n\n  // The proof would proceed by showing P(n) directly\n  // using the second hypothesis with m = n\n  assert forall j :: n <= j < n ==> P(j); // Vacuously true\n}\n\nlemma CompleteInduction(n: nat, P: nat -> bool)\n  requires P(0)\n  requires forall k: nat :: k > 0 && (forall j: nat :: j < k ==> P(j)) ==> P(k)\n  ensures P(n)\n{\n  if n == 0 {\n    // Base case\n    assert P(0);\n  } else {\n    // Need to show all j < n satisfy P(j)\n    forall j: nat | j < n\n      ensures P(j)\n    {\n      if j == 0 {\n        assert P(0);\n      } else {\n        CompleteInduction(j, P);\n      }\n    }\n\n    // Now apply the inductive hypothesis\n    \n/*[CODE HERE]*/\n    assert P(n);\n  }\n}", "output": "assert forall j: nat :: j < n ==> P(j);"}, {"id": "example_CompleteInduction_2", "type": "call", "program": "// Induction proofs with detailed reasoning steps\n\n// Sum of first n natural numbers\nfunction {:spec} sumTo(n: nat): nat\n{\n  if n == 0 then 0 else n + sumTo(n - 1)\n}\n\n// Sum of first n odd numbers\nfunction {:spec} sumOdds(n: nat): nat\n{\n  if n == 0 then 0 else (2 * n - 1) + sumOdds(n - 1)\n}\n\n// Sum of first n squares\nfunction {:spec} sumSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + sumSquares(n - 1)\n}\n\n// Power function\nfunction {:spec} power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\n// Fibonacci\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// --- Detailed Inductive Proofs ---\n\nlemma SumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    // Base case\n    assert sumTo(0) == 0;\n    assert 0 * (0 + 1) / 2 == 0;\n  } else {\n    // Inductive step\n    SumToFormula(n - 1);\n\n    calc == {\n      sumTo(n);\n      n + sumTo(n - 1);\n      { // Induction hypothesis\n        assert sumTo(n - 1) == (n - 1) * n / 2;\n      }\n      n + (n - 1) * n / 2;\n      { // Algebra\n        assert n == 2 * n / 2;\n      }\n      2 * n / 2 + (n - 1) * n / 2;\n      (2 * n + (n - 1) * n) / 2;\n      (2 * n + n * n - n) / 2;\n      (n + n * n) / 2;\n      n * (1 + n) / 2;\n      n * (n + 1) / 2;\n    }\n  }\n}\n\nlemma SumOddsIsSquare(n: nat)\n  ensures sumOdds(n) == n * n\n{\n  if n == 0 {\n    // Base case\n    assert sumOdds(0) == 0;\n    assert 0 * 0 == 0;\n  } else {\n    // Inductive step\n    SumOddsIsSquare(n - 1);\n\n    calc == {\n      sumOdds(n);\n      (2 * n - 1) + sumOdds(n - 1);\n      { // Induction hypothesis\n        assert sumOdds(n - 1) == (n - 1) * (n - 1);\n      }\n      (2 * n - 1) + (n - 1) * (n - 1);\n      { // Expand (n-1)\u00b2\n        assert (n - 1) * (n - 1) == n * n - 2 * n + 1;\n      }\n      (2 * n - 1) + (n * n - 2 * n + 1);\n      2 * n - 1 + n * n - 2 * n + 1;\n      n * n;\n    }\n  }\n}\n\nlemma SumSquaresFormula(n: nat)\n  ensures sumSquares(n) == n * (n + 1) * (2 * n + 1) / 6\n{\n  if n == 0 {\n    // Base case\n    assert sumSquares(0) == 0;\n    assert 0 * (0 + 1) * (2 * 0 + 1) / 6 == 0;\n  } else {\n    // Inductive step\n    SumSquaresFormula(n - 1);\n\n    calc == {\n      sumSquares(n);\n      n * n + sumSquares(n - 1);\n      { // Induction hypothesis\n        assert sumSquares(n - 1) == (n - 1) * n * (2 * n - 1) / 6;\n      }\n      n * n + (n - 1) * n * (2 * n - 1) / 6;\n      { // Factor out common terms\n        assert n * n == 6 * n * n / 6;\n      }\n      6 * n * n / 6 + (n - 1) * n * (2 * n - 1) / 6;\n      (6 * n * n + (n - 1) * n * (2 * n - 1)) / 6;\n      { // Expand\n        assert (n - 1) * n * (2 * n - 1) == n * (n - 1) * (2 * n - 1);\n        assert n * (n - 1) * (2 * n - 1) == n * (2 * n * n - 3 * n + 1);\n        assert n * (2 * n * n - 3 * n + 1) == 2 * n * n * n - 3 * n * n + n;\n      }\n      (6 * n * n + 2 * n * n * n - 3 * n * n + n) / 6;\n      (2 * n * n * n + 3 * n * n + n) / 6;\n      n * (2 * n * n + 3 * n + 1) / 6;\n      { // Factor\n        assert 2 * n * n + 3 * n + 1 == (n + 1) * (2 * n + 1);\n      }\n      n * (n + 1) * (2 * n + 1) / 6;\n    }\n  }\n}\n\nlemma PowerOfTwo(n: nat)\n  ensures power(2, n) >= n + 1\n{\n  if n == 0 {\n    // Base case\n    assert power(2, 0) == 1;\n    assert 1 >= 0 + 1;\n  } else {\n    // Inductive step\n    PowerOfTwo(n - 1);\n\n    calc >= {\n      power(2, n);\n      2 * power(2, n - 1);\n      { // Induction hypothesis\n        assert power(2, n - 1) >= n;\n      }\n      2 * n;\n      { // Since n >= 1\n        assert n >= 1;\n        assert 2 * n >= n + 1;\n      }\n      n + 1;\n    }\n  }\n}\n\nlemma PowerMonotonic(base: nat, exp1: nat, exp2: nat)\n  requires base > 1\n  requires exp1 <= exp2\n  ensures power(base, exp1) <= power(base, exp2)\n{\n  if exp1 == exp2 {\n    // Equal case\n    assert power(base, exp1) == power(base, exp2);\n  } else {\n    // exp1 < exp2\n    assert exp1 < exp2;\n\n    if exp1 == 0 {\n      assert power(base, exp1) == 1;\n      PowerPositive(base, exp2);\n      assert power(base, exp2) >= 1;\n    } else {\n      // Both exp1 and exp2 are positive\n      PowerMonotonic(base, exp1 - 1, exp2 - 1);\n\n      calc <= {\n        power(base, exp1);\n        base * power(base, exp1 - 1);\n        { // Induction hypothesis\n          assert power(base, exp1 - 1) <= power(base, exp2 - 1);\n        }\n        base * power(base, exp2 - 1);\n        power(base, exp2);\n      }\n    }\n  }\n}\n\nlemma PowerPositive(base: nat, exp: nat)\n  requires base > 0\n  ensures power(base, exp) > 0\n{\n  if exp == 0 {\n    assert power(base, 0) == 1;\n  } else {\n    PowerPositive(base, exp - 1);\n    assert power(base, exp) == base * power(base, exp - 1);\n    assert base > 0 && power(base, exp - 1) > 0;\n  }\n}\n\nlemma FibonacciInequality(n: nat)\n  requires n >= 1\n  ensures fib(n) <= power(2, n - 1)\n{\n  if n == 1 {\n    // Base case\n    assert fib(1) == 1;\n    assert power(2, 0) == 1;\n  } else if n == 2 {\n    // Base case\n    assert fib(2) == 1;\n    assert power(2, 1) == 2;\n    assert 1 <= 2;\n  } else {\n    // Inductive step (n >= 3)\n    assert n >= 3;\n    FibonacciInequality(n - 1);\n    FibonacciInequality(n - 2);\n\n    calc <= {\n      fib(n);\n      fib(n - 1) + fib(n - 2);\n      { // Induction hypotheses\n        assert fib(n - 1) <= power(2, n - 2);\n        assert fib(n - 2) <= power(2, n - 3);\n      }\n      power(2, n - 2) + power(2, n - 3);\n      { // Factor out power(2, n - 3)\n        assert power(2, n - 2) == 2 * power(2, n - 3);\n      }\n      2 * power(2, n - 3) + power(2, n - 3);\n      3 * power(2, n - 3);\n      { // 3 * 2^(n-3) <= 4 * 2^(n-3) = 2^(n-1)\n        assert 3 <= 4;\n        assert power(2, n - 1) == 4 * power(2, n - 3);\n      }\n      power(2, n - 1);\n    }\n  }\n}\n\nlemma StrongInduction(n: nat, P: nat -> bool)\n  requires forall k :: 0 <= k < n ==> P(k)\n  requires forall m :: m >= n && (forall j :: n <= j < m ==> P(j)) ==> P(m)\n  ensures P(n)\n{\n  // This demonstrates the strong induction principle\n  // Base case: all k < n satisfy P(k) by hypothesis\n  // Inductive case: if all j in [n, m) satisfy P, then P(m) holds\n\n  // The proof would proceed by showing P(n) directly\n  // using the second hypothesis with m = n\n  assert forall j :: n <= j < n ==> P(j); // Vacuously true\n}\n\nlemma CompleteInduction(n: nat, P: nat -> bool)\n  requires P(0)\n  requires forall k: nat :: k > 0 && (forall j: nat :: j < k ==> P(j)) ==> P(k)\n  ensures P(n)\n{\n  if n == 0 {\n    // Base case\n    assert P(0);\n  } else {\n    // Need to show all j < n satisfy P(j)\n    forall j: nat | j < n\n      ensures P(j)\n    {\n      if j == 0 {\n        assert P(0);\n      } else {\n        \n/*[CODE HERE]*/\n      }\n    }\n\n    // Now apply the inductive hypothesis\n    assert forall j: nat :: j < n ==> P(j);\n    assert P(n);\n  }\n}", "output": "CompleteInduction(j, P);"}, {"id": "example_CompleteInduction_3", "type": "assert", "program": "// Induction proofs with detailed reasoning steps\n\n// Sum of first n natural numbers\nfunction {:spec} sumTo(n: nat): nat\n{\n  if n == 0 then 0 else n + sumTo(n - 1)\n}\n\n// Sum of first n odd numbers\nfunction {:spec} sumOdds(n: nat): nat\n{\n  if n == 0 then 0 else (2 * n - 1) + sumOdds(n - 1)\n}\n\n// Sum of first n squares\nfunction {:spec} sumSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + sumSquares(n - 1)\n}\n\n// Power function\nfunction {:spec} power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\n// Fibonacci\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// --- Detailed Inductive Proofs ---\n\nlemma SumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    // Base case\n    assert sumTo(0) == 0;\n    assert 0 * (0 + 1) / 2 == 0;\n  } else {\n    // Inductive step\n    SumToFormula(n - 1);\n\n    calc == {\n      sumTo(n);\n      n + sumTo(n - 1);\n      { // Induction hypothesis\n        assert sumTo(n - 1) == (n - 1) * n / 2;\n      }\n      n + (n - 1) * n / 2;\n      { // Algebra\n        assert n == 2 * n / 2;\n      }\n      2 * n / 2 + (n - 1) * n / 2;\n      (2 * n + (n - 1) * n) / 2;\n      (2 * n + n * n - n) / 2;\n      (n + n * n) / 2;\n      n * (1 + n) / 2;\n      n * (n + 1) / 2;\n    }\n  }\n}\n\nlemma SumOddsIsSquare(n: nat)\n  ensures sumOdds(n) == n * n\n{\n  if n == 0 {\n    // Base case\n    assert sumOdds(0) == 0;\n    assert 0 * 0 == 0;\n  } else {\n    // Inductive step\n    SumOddsIsSquare(n - 1);\n\n    calc == {\n      sumOdds(n);\n      (2 * n - 1) + sumOdds(n - 1);\n      { // Induction hypothesis\n        assert sumOdds(n - 1) == (n - 1) * (n - 1);\n      }\n      (2 * n - 1) + (n - 1) * (n - 1);\n      { // Expand (n-1)\u00b2\n        assert (n - 1) * (n - 1) == n * n - 2 * n + 1;\n      }\n      (2 * n - 1) + (n * n - 2 * n + 1);\n      2 * n - 1 + n * n - 2 * n + 1;\n      n * n;\n    }\n  }\n}\n\nlemma SumSquaresFormula(n: nat)\n  ensures sumSquares(n) == n * (n + 1) * (2 * n + 1) / 6\n{\n  if n == 0 {\n    // Base case\n    assert sumSquares(0) == 0;\n    assert 0 * (0 + 1) * (2 * 0 + 1) / 6 == 0;\n  } else {\n    // Inductive step\n    SumSquaresFormula(n - 1);\n\n    calc == {\n      sumSquares(n);\n      n * n + sumSquares(n - 1);\n      { // Induction hypothesis\n        assert sumSquares(n - 1) == (n - 1) * n * (2 * n - 1) / 6;\n      }\n      n * n + (n - 1) * n * (2 * n - 1) / 6;\n      { // Factor out common terms\n        assert n * n == 6 * n * n / 6;\n      }\n      6 * n * n / 6 + (n - 1) * n * (2 * n - 1) / 6;\n      (6 * n * n + (n - 1) * n * (2 * n - 1)) / 6;\n      { // Expand\n        assert (n - 1) * n * (2 * n - 1) == n * (n - 1) * (2 * n - 1);\n        assert n * (n - 1) * (2 * n - 1) == n * (2 * n * n - 3 * n + 1);\n        assert n * (2 * n * n - 3 * n + 1) == 2 * n * n * n - 3 * n * n + n;\n      }\n      (6 * n * n + 2 * n * n * n - 3 * n * n + n) / 6;\n      (2 * n * n * n + 3 * n * n + n) / 6;\n      n * (2 * n * n + 3 * n + 1) / 6;\n      { // Factor\n        assert 2 * n * n + 3 * n + 1 == (n + 1) * (2 * n + 1);\n      }\n      n * (n + 1) * (2 * n + 1) / 6;\n    }\n  }\n}\n\nlemma PowerOfTwo(n: nat)\n  ensures power(2, n) >= n + 1\n{\n  if n == 0 {\n    // Base case\n    assert power(2, 0) == 1;\n    assert 1 >= 0 + 1;\n  } else {\n    // Inductive step\n    PowerOfTwo(n - 1);\n\n    calc >= {\n      power(2, n);\n      2 * power(2, n - 1);\n      { // Induction hypothesis\n        assert power(2, n - 1) >= n;\n      }\n      2 * n;\n      { // Since n >= 1\n        assert n >= 1;\n        assert 2 * n >= n + 1;\n      }\n      n + 1;\n    }\n  }\n}\n\nlemma PowerMonotonic(base: nat, exp1: nat, exp2: nat)\n  requires base > 1\n  requires exp1 <= exp2\n  ensures power(base, exp1) <= power(base, exp2)\n{\n  if exp1 == exp2 {\n    // Equal case\n    assert power(base, exp1) == power(base, exp2);\n  } else {\n    // exp1 < exp2\n    assert exp1 < exp2;\n\n    if exp1 == 0 {\n      assert power(base, exp1) == 1;\n      PowerPositive(base, exp2);\n      assert power(base, exp2) >= 1;\n    } else {\n      // Both exp1 and exp2 are positive\n      PowerMonotonic(base, exp1 - 1, exp2 - 1);\n\n      calc <= {\n        power(base, exp1);\n        base * power(base, exp1 - 1);\n        { // Induction hypothesis\n          assert power(base, exp1 - 1) <= power(base, exp2 - 1);\n        }\n        base * power(base, exp2 - 1);\n        power(base, exp2);\n      }\n    }\n  }\n}\n\nlemma PowerPositive(base: nat, exp: nat)\n  requires base > 0\n  ensures power(base, exp) > 0\n{\n  if exp == 0 {\n    assert power(base, 0) == 1;\n  } else {\n    PowerPositive(base, exp - 1);\n    assert power(base, exp) == base * power(base, exp - 1);\n    assert base > 0 && power(base, exp - 1) > 0;\n  }\n}\n\nlemma FibonacciInequality(n: nat)\n  requires n >= 1\n  ensures fib(n) <= power(2, n - 1)\n{\n  if n == 1 {\n    // Base case\n    assert fib(1) == 1;\n    assert power(2, 0) == 1;\n  } else if n == 2 {\n    // Base case\n    assert fib(2) == 1;\n    assert power(2, 1) == 2;\n    assert 1 <= 2;\n  } else {\n    // Inductive step (n >= 3)\n    assert n >= 3;\n    FibonacciInequality(n - 1);\n    FibonacciInequality(n - 2);\n\n    calc <= {\n      fib(n);\n      fib(n - 1) + fib(n - 2);\n      { // Induction hypotheses\n        assert fib(n - 1) <= power(2, n - 2);\n        assert fib(n - 2) <= power(2, n - 3);\n      }\n      power(2, n - 2) + power(2, n - 3);\n      { // Factor out power(2, n - 3)\n        assert power(2, n - 2) == 2 * power(2, n - 3);\n      }\n      2 * power(2, n - 3) + power(2, n - 3);\n      3 * power(2, n - 3);\n      { // 3 * 2^(n-3) <= 4 * 2^(n-3) = 2^(n-1)\n        assert 3 <= 4;\n        assert power(2, n - 1) == 4 * power(2, n - 3);\n      }\n      power(2, n - 1);\n    }\n  }\n}\n\nlemma StrongInduction(n: nat, P: nat -> bool)\n  requires forall k :: 0 <= k < n ==> P(k)\n  requires forall m :: m >= n && (forall j :: n <= j < m ==> P(j)) ==> P(m)\n  ensures P(n)\n{\n  // This demonstrates the strong induction principle\n  // Base case: all k < n satisfy P(k) by hypothesis\n  // Inductive case: if all j in [n, m) satisfy P, then P(m) holds\n\n  // The proof would proceed by showing P(n) directly\n  // using the second hypothesis with m = n\n  assert forall j :: n <= j < n ==> P(j); // Vacuously true\n}\n\nlemma CompleteInduction(n: nat, P: nat -> bool)\n  requires P(0)\n  requires forall k: nat :: k > 0 && (forall j: nat :: j < k ==> P(j)) ==> P(k)\n  ensures P(n)\n{\n  if n == 0 {\n    // Base case\n    assert P(0);\n  } else {\n    // Need to show all j < n satisfy P(j)\n    forall j: nat | j < n\n      ensures P(j)\n    {\n      if j == 0 {\n        \n/*[CODE HERE]*/\n      } else {\n        CompleteInduction(j, P);\n      }\n    }\n\n    // Now apply the inductive hypothesis\n    assert forall j: nat :: j < n ==> P(j);\n    assert P(n);\n  }\n}", "output": "assert P(0);"}, {"id": "example_CompleteInduction_4", "type": "assert", "program": "// Induction proofs with detailed reasoning steps\n\n// Sum of first n natural numbers\nfunction {:spec} sumTo(n: nat): nat\n{\n  if n == 0 then 0 else n + sumTo(n - 1)\n}\n\n// Sum of first n odd numbers\nfunction {:spec} sumOdds(n: nat): nat\n{\n  if n == 0 then 0 else (2 * n - 1) + sumOdds(n - 1)\n}\n\n// Sum of first n squares\nfunction {:spec} sumSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + sumSquares(n - 1)\n}\n\n// Power function\nfunction {:spec} power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\n// Fibonacci\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// --- Detailed Inductive Proofs ---\n\nlemma SumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    // Base case\n    assert sumTo(0) == 0;\n    assert 0 * (0 + 1) / 2 == 0;\n  } else {\n    // Inductive step\n    SumToFormula(n - 1);\n\n    calc == {\n      sumTo(n);\n      n + sumTo(n - 1);\n      { // Induction hypothesis\n        assert sumTo(n - 1) == (n - 1) * n / 2;\n      }\n      n + (n - 1) * n / 2;\n      { // Algebra\n        assert n == 2 * n / 2;\n      }\n      2 * n / 2 + (n - 1) * n / 2;\n      (2 * n + (n - 1) * n) / 2;\n      (2 * n + n * n - n) / 2;\n      (n + n * n) / 2;\n      n * (1 + n) / 2;\n      n * (n + 1) / 2;\n    }\n  }\n}\n\nlemma SumOddsIsSquare(n: nat)\n  ensures sumOdds(n) == n * n\n{\n  if n == 0 {\n    // Base case\n    assert sumOdds(0) == 0;\n    assert 0 * 0 == 0;\n  } else {\n    // Inductive step\n    SumOddsIsSquare(n - 1);\n\n    calc == {\n      sumOdds(n);\n      (2 * n - 1) + sumOdds(n - 1);\n      { // Induction hypothesis\n        assert sumOdds(n - 1) == (n - 1) * (n - 1);\n      }\n      (2 * n - 1) + (n - 1) * (n - 1);\n      { // Expand (n-1)\u00b2\n        assert (n - 1) * (n - 1) == n * n - 2 * n + 1;\n      }\n      (2 * n - 1) + (n * n - 2 * n + 1);\n      2 * n - 1 + n * n - 2 * n + 1;\n      n * n;\n    }\n  }\n}\n\nlemma SumSquaresFormula(n: nat)\n  ensures sumSquares(n) == n * (n + 1) * (2 * n + 1) / 6\n{\n  if n == 0 {\n    // Base case\n    assert sumSquares(0) == 0;\n    assert 0 * (0 + 1) * (2 * 0 + 1) / 6 == 0;\n  } else {\n    // Inductive step\n    SumSquaresFormula(n - 1);\n\n    calc == {\n      sumSquares(n);\n      n * n + sumSquares(n - 1);\n      { // Induction hypothesis\n        assert sumSquares(n - 1) == (n - 1) * n * (2 * n - 1) / 6;\n      }\n      n * n + (n - 1) * n * (2 * n - 1) / 6;\n      { // Factor out common terms\n        assert n * n == 6 * n * n / 6;\n      }\n      6 * n * n / 6 + (n - 1) * n * (2 * n - 1) / 6;\n      (6 * n * n + (n - 1) * n * (2 * n - 1)) / 6;\n      { // Expand\n        assert (n - 1) * n * (2 * n - 1) == n * (n - 1) * (2 * n - 1);\n        assert n * (n - 1) * (2 * n - 1) == n * (2 * n * n - 3 * n + 1);\n        assert n * (2 * n * n - 3 * n + 1) == 2 * n * n * n - 3 * n * n + n;\n      }\n      (6 * n * n + 2 * n * n * n - 3 * n * n + n) / 6;\n      (2 * n * n * n + 3 * n * n + n) / 6;\n      n * (2 * n * n + 3 * n + 1) / 6;\n      { // Factor\n        assert 2 * n * n + 3 * n + 1 == (n + 1) * (2 * n + 1);\n      }\n      n * (n + 1) * (2 * n + 1) / 6;\n    }\n  }\n}\n\nlemma PowerOfTwo(n: nat)\n  ensures power(2, n) >= n + 1\n{\n  if n == 0 {\n    // Base case\n    assert power(2, 0) == 1;\n    assert 1 >= 0 + 1;\n  } else {\n    // Inductive step\n    PowerOfTwo(n - 1);\n\n    calc >= {\n      power(2, n);\n      2 * power(2, n - 1);\n      { // Induction hypothesis\n        assert power(2, n - 1) >= n;\n      }\n      2 * n;\n      { // Since n >= 1\n        assert n >= 1;\n        assert 2 * n >= n + 1;\n      }\n      n + 1;\n    }\n  }\n}\n\nlemma PowerMonotonic(base: nat, exp1: nat, exp2: nat)\n  requires base > 1\n  requires exp1 <= exp2\n  ensures power(base, exp1) <= power(base, exp2)\n{\n  if exp1 == exp2 {\n    // Equal case\n    assert power(base, exp1) == power(base, exp2);\n  } else {\n    // exp1 < exp2\n    assert exp1 < exp2;\n\n    if exp1 == 0 {\n      assert power(base, exp1) == 1;\n      PowerPositive(base, exp2);\n      assert power(base, exp2) >= 1;\n    } else {\n      // Both exp1 and exp2 are positive\n      PowerMonotonic(base, exp1 - 1, exp2 - 1);\n\n      calc <= {\n        power(base, exp1);\n        base * power(base, exp1 - 1);\n        { // Induction hypothesis\n          assert power(base, exp1 - 1) <= power(base, exp2 - 1);\n        }\n        base * power(base, exp2 - 1);\n        power(base, exp2);\n      }\n    }\n  }\n}\n\nlemma PowerPositive(base: nat, exp: nat)\n  requires base > 0\n  ensures power(base, exp) > 0\n{\n  if exp == 0 {\n    assert power(base, 0) == 1;\n  } else {\n    PowerPositive(base, exp - 1);\n    assert power(base, exp) == base * power(base, exp - 1);\n    assert base > 0 && power(base, exp - 1) > 0;\n  }\n}\n\nlemma FibonacciInequality(n: nat)\n  requires n >= 1\n  ensures fib(n) <= power(2, n - 1)\n{\n  if n == 1 {\n    // Base case\n    assert fib(1) == 1;\n    assert power(2, 0) == 1;\n  } else if n == 2 {\n    // Base case\n    assert fib(2) == 1;\n    assert power(2, 1) == 2;\n    assert 1 <= 2;\n  } else {\n    // Inductive step (n >= 3)\n    assert n >= 3;\n    FibonacciInequality(n - 1);\n    FibonacciInequality(n - 2);\n\n    calc <= {\n      fib(n);\n      fib(n - 1) + fib(n - 2);\n      { // Induction hypotheses\n        assert fib(n - 1) <= power(2, n - 2);\n        assert fib(n - 2) <= power(2, n - 3);\n      }\n      power(2, n - 2) + power(2, n - 3);\n      { // Factor out power(2, n - 3)\n        assert power(2, n - 2) == 2 * power(2, n - 3);\n      }\n      2 * power(2, n - 3) + power(2, n - 3);\n      3 * power(2, n - 3);\n      { // 3 * 2^(n-3) <= 4 * 2^(n-3) = 2^(n-1)\n        assert 3 <= 4;\n        assert power(2, n - 1) == 4 * power(2, n - 3);\n      }\n      power(2, n - 1);\n    }\n  }\n}\n\nlemma StrongInduction(n: nat, P: nat -> bool)\n  requires forall k :: 0 <= k < n ==> P(k)\n  requires forall m :: m >= n && (forall j :: n <= j < m ==> P(j)) ==> P(m)\n  ensures P(n)\n{\n  // This demonstrates the strong induction principle\n  // Base case: all k < n satisfy P(k) by hypothesis\n  // Inductive case: if all j in [n, m) satisfy P, then P(m) holds\n\n  // The proof would proceed by showing P(n) directly\n  // using the second hypothesis with m = n\n  assert forall j :: n <= j < n ==> P(j); // Vacuously true\n}\n\nlemma CompleteInduction(n: nat, P: nat -> bool)\n  requires P(0)\n  requires forall k: nat :: k > 0 && (forall j: nat :: j < k ==> P(j)) ==> P(k)\n  ensures P(n)\n{\n  if n == 0 {\n    // Base case\n    \n/*[CODE HERE]*/\n  } else {\n    // Need to show all j < n satisfy P(j)\n    forall j: nat | j < n\n      ensures P(j)\n    {\n      if j == 0 {\n        assert P(0);\n      } else {\n        CompleteInduction(j, P);\n      }\n    }\n\n    // Now apply the inductive hypothesis\n    assert forall j: nat :: j < n ==> P(j);\n    assert P(n);\n  }\n}", "output": "assert P(0);"}, {"id": "example_isSortedTransitive_0", "type": "assert", "program": "function isSorted(s: seq<int>): bool\n{\n  forall i, j :: 0 <= i < j < |s| ==> s[i] <= s[j]\n}\n\nfunction isSortedBetween(s: seq<int>, lo: int, hi: int): bool\n  requires 0 <= lo <= hi <= |s|\n{\n  forall i, j :: lo <= i < j < hi ==> s[i] <= s[j]\n}\n\nlemma isSortedCorrect(s: seq<int>)\n  ensures isSorted(s) <==> forall i, j :: 0 <= i < j < |s| ==> s[i] <= s[j]\n{\n  // Trivial by definition\n}\n\nlemma isSortedTransitive(s: seq<int>, i: int, j: int, k: int)\n  requires isSorted(s)\n  requires 0 <= i <= j <= k < |s|\n  ensures s[i] <= s[j] <= s[k]\n{\n  if i < j {\n    assert s[i] <= s[j];\n  } else {\n    assert i == j;\n    assert s[i] == s[j];\n  }\n  \n  if j < k {\n    assert s[j] <= s[k];\n  } else {\n    assert j == k;\n    \n/*[CODE HERE]*/\n  }\n}\n\nlemma isSortedSubsequence(s: seq<int>, lo: int, hi: int)\n  requires 0 <= lo <= hi <= |s|\n  requires isSorted(s)\n  ensures isSortedBetween(s, lo, hi)\n{\n  forall i, j | lo <= i < j < hi\n    ensures s[i] <= s[j]\n  {\n    assert 0 <= i < j < |s|;\n    assert s[i] <= s[j];\n  }\n}", "output": "assert s[j] == s[k];"}, {"id": "example_isSortedTransitive_1", "type": "assert", "program": "function isSorted(s: seq<int>): bool\n{\n  forall i, j :: 0 <= i < j < |s| ==> s[i] <= s[j]\n}\n\nfunction isSortedBetween(s: seq<int>, lo: int, hi: int): bool\n  requires 0 <= lo <= hi <= |s|\n{\n  forall i, j :: lo <= i < j < hi ==> s[i] <= s[j]\n}\n\nlemma isSortedCorrect(s: seq<int>)\n  ensures isSorted(s) <==> forall i, j :: 0 <= i < j < |s| ==> s[i] <= s[j]\n{\n  // Trivial by definition\n}\n\nlemma isSortedTransitive(s: seq<int>, i: int, j: int, k: int)\n  requires isSorted(s)\n  requires 0 <= i <= j <= k < |s|\n  ensures s[i] <= s[j] <= s[k]\n{\n  if i < j {\n    assert s[i] <= s[j];\n  } else {\n    assert i == j;\n    assert s[i] == s[j];\n  }\n  \n  if j < k {\n    assert s[j] <= s[k];\n  } else {\n    \n/*[CODE HERE]*/\n    assert s[j] == s[k];\n  }\n}\n\nlemma isSortedSubsequence(s: seq<int>, lo: int, hi: int)\n  requires 0 <= lo <= hi <= |s|\n  requires isSorted(s)\n  ensures isSortedBetween(s, lo, hi)\n{\n  forall i, j | lo <= i < j < hi\n    ensures s[i] <= s[j]\n  {\n    assert 0 <= i < j < |s|;\n    assert s[i] <= s[j];\n  }\n}", "output": "assert j == k;"}, {"id": "example_isSortedTransitive_2", "type": "assert", "program": "function isSorted(s: seq<int>): bool\n{\n  forall i, j :: 0 <= i < j < |s| ==> s[i] <= s[j]\n}\n\nfunction isSortedBetween(s: seq<int>, lo: int, hi: int): bool\n  requires 0 <= lo <= hi <= |s|\n{\n  forall i, j :: lo <= i < j < hi ==> s[i] <= s[j]\n}\n\nlemma isSortedCorrect(s: seq<int>)\n  ensures isSorted(s) <==> forall i, j :: 0 <= i < j < |s| ==> s[i] <= s[j]\n{\n  // Trivial by definition\n}\n\nlemma isSortedTransitive(s: seq<int>, i: int, j: int, k: int)\n  requires isSorted(s)\n  requires 0 <= i <= j <= k < |s|\n  ensures s[i] <= s[j] <= s[k]\n{\n  if i < j {\n    assert s[i] <= s[j];\n  } else {\n    assert i == j;\n    assert s[i] == s[j];\n  }\n  \n  if j < k {\n    \n/*[CODE HERE]*/\n  } else {\n    assert j == k;\n    assert s[j] == s[k];\n  }\n}\n\nlemma isSortedSubsequence(s: seq<int>, lo: int, hi: int)\n  requires 0 <= lo <= hi <= |s|\n  requires isSorted(s)\n  ensures isSortedBetween(s, lo, hi)\n{\n  forall i, j | lo <= i < j < hi\n    ensures s[i] <= s[j]\n  {\n    assert 0 <= i < j < |s|;\n    assert s[i] <= s[j];\n  }\n}", "output": "assert s[j] <= s[k];"}, {"id": "example_isSortedTransitive_3", "type": "assert", "program": "function isSorted(s: seq<int>): bool\n{\n  forall i, j :: 0 <= i < j < |s| ==> s[i] <= s[j]\n}\n\nfunction isSortedBetween(s: seq<int>, lo: int, hi: int): bool\n  requires 0 <= lo <= hi <= |s|\n{\n  forall i, j :: lo <= i < j < hi ==> s[i] <= s[j]\n}\n\nlemma isSortedCorrect(s: seq<int>)\n  ensures isSorted(s) <==> forall i, j :: 0 <= i < j < |s| ==> s[i] <= s[j]\n{\n  // Trivial by definition\n}\n\nlemma isSortedTransitive(s: seq<int>, i: int, j: int, k: int)\n  requires isSorted(s)\n  requires 0 <= i <= j <= k < |s|\n  ensures s[i] <= s[j] <= s[k]\n{\n  if i < j {\n    assert s[i] <= s[j];\n  } else {\n    assert i == j;\n    \n/*[CODE HERE]*/\n  }\n  \n  if j < k {\n    assert s[j] <= s[k];\n  } else {\n    assert j == k;\n    assert s[j] == s[k];\n  }\n}\n\nlemma isSortedSubsequence(s: seq<int>, lo: int, hi: int)\n  requires 0 <= lo <= hi <= |s|\n  requires isSorted(s)\n  ensures isSortedBetween(s, lo, hi)\n{\n  forall i, j | lo <= i < j < hi\n    ensures s[i] <= s[j]\n  {\n    assert 0 <= i < j < |s|;\n    assert s[i] <= s[j];\n  }\n}", "output": "assert s[i] == s[j];"}, {"id": "example_isSortedTransitive_4", "type": "assert", "program": "function isSorted(s: seq<int>): bool\n{\n  forall i, j :: 0 <= i < j < |s| ==> s[i] <= s[j]\n}\n\nfunction isSortedBetween(s: seq<int>, lo: int, hi: int): bool\n  requires 0 <= lo <= hi <= |s|\n{\n  forall i, j :: lo <= i < j < hi ==> s[i] <= s[j]\n}\n\nlemma isSortedCorrect(s: seq<int>)\n  ensures isSorted(s) <==> forall i, j :: 0 <= i < j < |s| ==> s[i] <= s[j]\n{\n  // Trivial by definition\n}\n\nlemma isSortedTransitive(s: seq<int>, i: int, j: int, k: int)\n  requires isSorted(s)\n  requires 0 <= i <= j <= k < |s|\n  ensures s[i] <= s[j] <= s[k]\n{\n  if i < j {\n    assert s[i] <= s[j];\n  } else {\n    \n/*[CODE HERE]*/\n    assert s[i] == s[j];\n  }\n  \n  if j < k {\n    assert s[j] <= s[k];\n  } else {\n    assert j == k;\n    assert s[j] == s[k];\n  }\n}\n\nlemma isSortedSubsequence(s: seq<int>, lo: int, hi: int)\n  requires 0 <= lo <= hi <= |s|\n  requires isSorted(s)\n  ensures isSortedBetween(s, lo, hi)\n{\n  forall i, j | lo <= i < j < hi\n    ensures s[i] <= s[j]\n  {\n    assert 0 <= i < j < |s|;\n    assert s[i] <= s[j];\n  }\n}", "output": "assert i == j;"}, {"id": "example_isSortedTransitive_5", "type": "assert", "program": "function isSorted(s: seq<int>): bool\n{\n  forall i, j :: 0 <= i < j < |s| ==> s[i] <= s[j]\n}\n\nfunction isSortedBetween(s: seq<int>, lo: int, hi: int): bool\n  requires 0 <= lo <= hi <= |s|\n{\n  forall i, j :: lo <= i < j < hi ==> s[i] <= s[j]\n}\n\nlemma isSortedCorrect(s: seq<int>)\n  ensures isSorted(s) <==> forall i, j :: 0 <= i < j < |s| ==> s[i] <= s[j]\n{\n  // Trivial by definition\n}\n\nlemma isSortedTransitive(s: seq<int>, i: int, j: int, k: int)\n  requires isSorted(s)\n  requires 0 <= i <= j <= k < |s|\n  ensures s[i] <= s[j] <= s[k]\n{\n  if i < j {\n    \n/*[CODE HERE]*/\n  } else {\n    assert i == j;\n    assert s[i] == s[j];\n  }\n  \n  if j < k {\n    assert s[j] <= s[k];\n  } else {\n    assert j == k;\n    assert s[j] == s[k];\n  }\n}\n\nlemma isSortedSubsequence(s: seq<int>, lo: int, hi: int)\n  requires 0 <= lo <= hi <= |s|\n  requires isSorted(s)\n  ensures isSortedBetween(s, lo, hi)\n{\n  forall i, j | lo <= i < j < hi\n    ensures s[i] <= s[j]\n  {\n    assert 0 <= i < j < |s|;\n    assert s[i] <= s[j];\n  }\n}", "output": "assert s[i] <= s[j];"}, {"id": "example_isSortedSubsequence_0", "type": "assert", "program": "function isSorted(s: seq<int>): bool\n{\n  forall i, j :: 0 <= i < j < |s| ==> s[i] <= s[j]\n}\n\nfunction isSortedBetween(s: seq<int>, lo: int, hi: int): bool\n  requires 0 <= lo <= hi <= |s|\n{\n  forall i, j :: lo <= i < j < hi ==> s[i] <= s[j]\n}\n\nlemma isSortedCorrect(s: seq<int>)\n  ensures isSorted(s) <==> forall i, j :: 0 <= i < j < |s| ==> s[i] <= s[j]\n{\n  // Trivial by definition\n}\n\nlemma isSortedTransitive(s: seq<int>, i: int, j: int, k: int)\n  requires isSorted(s)\n  requires 0 <= i <= j <= k < |s|\n  ensures s[i] <= s[j] <= s[k]\n{\n  if i < j {\n    assert s[i] <= s[j];\n  } else {\n    assert i == j;\n    assert s[i] == s[j];\n  }\n  \n  if j < k {\n    assert s[j] <= s[k];\n  } else {\n    assert j == k;\n    assert s[j] == s[k];\n  }\n}\n\nlemma isSortedSubsequence(s: seq<int>, lo: int, hi: int)\n  requires 0 <= lo <= hi <= |s|\n  requires isSorted(s)\n  ensures isSortedBetween(s, lo, hi)\n{\n  forall i, j | lo <= i < j < hi\n    ensures s[i] <= s[j]\n  {\n    assert 0 <= i < j < |s|;\n    \n/*[CODE HERE]*/\n  }\n}", "output": "assert s[i] <= s[j];"}, {"id": "example_isSortedSubsequence_1", "type": "assert", "program": "function isSorted(s: seq<int>): bool\n{\n  forall i, j :: 0 <= i < j < |s| ==> s[i] <= s[j]\n}\n\nfunction isSortedBetween(s: seq<int>, lo: int, hi: int): bool\n  requires 0 <= lo <= hi <= |s|\n{\n  forall i, j :: lo <= i < j < hi ==> s[i] <= s[j]\n}\n\nlemma isSortedCorrect(s: seq<int>)\n  ensures isSorted(s) <==> forall i, j :: 0 <= i < j < |s| ==> s[i] <= s[j]\n{\n  // Trivial by definition\n}\n\nlemma isSortedTransitive(s: seq<int>, i: int, j: int, k: int)\n  requires isSorted(s)\n  requires 0 <= i <= j <= k < |s|\n  ensures s[i] <= s[j] <= s[k]\n{\n  if i < j {\n    assert s[i] <= s[j];\n  } else {\n    assert i == j;\n    assert s[i] == s[j];\n  }\n  \n  if j < k {\n    assert s[j] <= s[k];\n  } else {\n    assert j == k;\n    assert s[j] == s[k];\n  }\n}\n\nlemma isSortedSubsequence(s: seq<int>, lo: int, hi: int)\n  requires 0 <= lo <= hi <= |s|\n  requires isSorted(s)\n  ensures isSortedBetween(s, lo, hi)\n{\n  forall i, j | lo <= i < j < hi\n    ensures s[i] <= s[j]\n  {\n    \n/*[CODE HERE]*/\n    assert s[i] <= s[j];\n  }\n}", "output": "assert 0 <= i < j < |s|;"}, {"id": "example_LengthAppend_0", "type": "call", "program": "// Linked list operations: insert, delete, reverse, cycle detection\n\ndatatype LinkedList<T> = Nil | Cons(head: T, tail: LinkedList<T>)\n\n// Length of linked list\nfunction {:spec} length<T>(list: LinkedList<T>): nat\n{\n  match list\n  case Nil => 0\n  case Cons(_, tail) => 1 + length(tail)\n}\n\n// Append two linked lists\nfunction {:spec} append<T>(l1: LinkedList<T>, l2: LinkedList<T>): LinkedList<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, append(t, l2))\n}\n\n// Reverse a linked list\nfunction {:spec} reverse<T>(list: LinkedList<T>): LinkedList<T>\n{\n  reverseHelper(list, Nil)\n}\n\nfunction reverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>): LinkedList<T>\n{\n  match list\n  case Nil => acc\n  case Cons(h, t) => reverseHelper(t, Cons(h, acc))\n}\n\n// Get nth element (0-indexed)\nfunction {:spec} nth<T>(list: LinkedList<T>, n: nat): T\n  requires n < length(list)\n{\n  match list\n  case Cons(h, t) => if n == 0 then h else nth(t, n - 1)\n}\n\n// Check if element exists in list\npredicate {:spec} contains<T(==)>(list: LinkedList<T>, x: T)\n{\n  match list\n  case Nil => false\n  case Cons(h, t) => h == x || contains(t, x)\n}\n\n// Remove first occurrence of element\nfunction {:spec} remove<T(==)>(list: LinkedList<T>, x: T): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => if h == x then t else Cons(h, remove(t, x))\n}\n\n// Insert at position\nfunction {:spec} insertAt<T>(list: LinkedList<T>, x: T, pos: nat): LinkedList<T>\n{\n  if pos == 0 then Cons(x, list)\n  else match list\n    case Nil => Cons(x, Nil)\n    case Cons(h, t) => Cons(h, insertAt(t, x, pos - 1))\n}\n\n// Convert to sequence\nfunction {:spec} toSeq<T>(list: LinkedList<T>): seq<T>\n{\n  match list\n  case Nil => []\n  case Cons(h, t) => [h] + toSeq(t)\n}\n\n// Convert from sequence\nfunction {:spec} fromSeq<T>(s: seq<T>): LinkedList<T>\n{\n  if |s| == 0 then Nil\n  else Cons(s[0], fromSeq(s[1..]))\n}\n\n// Map function over list\nfunction {:spec} listMap<T, U>(list: LinkedList<T>, f: T -> U): LinkedList<U>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => Cons(f(h), listMap(t, f))\n}\n\n// Filter list with predicate\nfunction {:spec} filter<T>(list: LinkedList<T>, p: T -> bool): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) =>\n    if p(h) then Cons(h, filter(t, p))\n    else filter(t, p)\n}\n\n// Take first n elements\nfunction {:spec} take<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n{\n  if n == 0 then Nil\n  else match list\n    case Nil => Nil\n    case Cons(h, t) => Cons(h, take(t, n - 1))\n}\n\n// Drop first n elements\nfunction {:spec} drop<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n  decreases list\n{\n  if n == 0 then list\n  else match list\n    case Nil => Nil\n    case Cons(_, t) => drop(t, n - 1)\n}\n\n// Check if list is palindrome\npredicate {:spec} isPalindrome<T(==)>(list: LinkedList<T>)\n{\n  toSeq(list) == toSeq(reverse(list))\n}\n\n// --- Lemmas for correctness ---\n\nlemma LengthAppend<T>(l1: LinkedList<T>, l2: LinkedList<T>)\n  ensures length(append(l1, l2)) == length(l1) + length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) =>\n    \n/*[CODE HERE]*/\n}\n\nlemma AppendNil<T>(list: LinkedList<T>)\n  ensures append(list, Nil) == list\n  ensures append(Nil, list) == list\n{\n  match list\n  case Nil =>\n  case Cons(_, t) =>\n    AppendNil(t);\n}\n\nlemma AppendAssociative<T>(l1: LinkedList<T>, l2: LinkedList<T>, l3: LinkedList<T>)\n  ensures append(append(l1, l2), l3) == append(l1, append(l2, l3))\n{\n  match l1\n  case Nil =>\n  case Cons(h, t) =>\n    AppendAssociative(t, l2, l3);\n}\n\nlemma ReverseLength<T>(list: LinkedList<T>)\n  ensures length(reverse(list)) == length(list)\n{\n  ReverseHelperLength(list, Nil);\n}\n\nlemma ReverseHelperLength<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures length(reverseHelper(list, acc)) == length(list) + length(acc)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    calc == {\n      length(reverseHelper(list, acc));\n      length(reverseHelper(t, Cons(h, acc)));\n      { ReverseHelperLength(t, Cons(h, acc)); }\n      length(t) + length(Cons(h, acc));\n      length(t) + 1 + length(acc);\n      length(list) + length(acc);\n    }\n}\n\nlemma ReverseReverse<T>(list: LinkedList<T>)\n  ensures reverse(reverse(list)) == list\n{\n  ReverseReverseHelper(list, Nil);\n}\n\nlemma ReverseReverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures reverseHelper(reverseHelper(list, acc), Nil) == reverseHelper(acc, list)\n{\n  match list\n  case Nil =>\n    assert reverseHelper(reverseHelper(Nil, acc), Nil) == reverseHelper(acc, Nil);\n  case Cons(h, t) =>\n    calc == {\n      reverseHelper(reverseHelper(Cons(h, t), acc), Nil);\n      reverseHelper(reverseHelper(t, Cons(h, acc)), Nil);\n      { ReverseReverseHelper(t, Cons(h, acc)); }\n      reverseHelper(Cons(h, acc), t);\n      reverseHelper(acc, Cons(h, t));\n    }\n}\n\nlemma ToSeqFromSeq<T>(s: seq<T>)\n  ensures toSeq(fromSeq(s)) == s\n{\n  if |s| == 0 {\n    assert fromSeq(s) == Nil;\n  } else {\n    ToSeqFromSeq(s[1..]);\n    assert toSeq(fromSeq(s)) == [s[0]] + toSeq(fromSeq(s[1..]));\n  }\n}\n\nlemma FromSeqToSeq<T>(list: LinkedList<T>)\n  ensures fromSeq(toSeq(list)) == list\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    FromSeqToSeq(t);\n}\n\nlemma NthCorrect<T>(list: LinkedList<T>, n: nat)\n  requires n < length(list)\n  ensures |toSeq(list)| > n\n  ensures toSeq(list)[n] == nth(list, n)\n{\n  match list\n  case Cons(h, t) =>\n    if n == 0 {\n      assert toSeq(list)[0] == h;\n    } else {\n      NthCorrect(t, n - 1);\n    }\n}\n\nlemma MapLength<T, U>(list: LinkedList<T>, f: T -> U)\n  ensures length(listMap(list, f)) == length(list)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    MapLength(t, f);\n}\n\nlemma FilterSubset<T>(list: LinkedList<T>, p: T -> bool)\n  ensures length(filter(list, p)) <= length(list)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    FilterSubset(t, p);\n    if p(h) {\n      assert length(filter(list, p)) == 1 + length(filter(t, p));\n    } else {\n      assert length(filter(list, p)) == length(filter(t, p));\n    }\n}\n\nlemma TakeDropConcat<T>(list: LinkedList<T>, n: nat)\n  ensures append(take(list, n), drop(list, n)) == list\n{\n  if n == 0 {\n    assert take(list, 0) == Nil;\n    assert drop(list, 0) == list;\n    AppendNil(list);\n  } else {\n    match list\n    case Nil =>\n    case Cons(h, t) =>\n      TakeDropConcat(t, n - 1);\n      calc == {\n        append(take(list, n), drop(list, n));\n        append(Cons(h, take(t, n - 1)), drop(t, n - 1));\n        Cons(h, append(take(t, n - 1), drop(t, n - 1)));\n        Cons(h, t);\n        list;\n      }\n  }\n}\n\nlemma RemoveDecreasesLength<T>(list: LinkedList<T>, x: T)\n  requires contains(list, x)\n  ensures length(remove(list, x)) == length(list) - 1\n{\n  match list\n  case Cons(h, t) =>\n    if h == x {\n      assert remove(list, x) == t;\n    } else {\n      assert contains(t, x);\n      RemoveDecreasesLength(t, x);\n    }\n}\n\nlemma InsertAtLength<T>(list: LinkedList<T>, x: T, pos: nat)\n  ensures length(insertAt(list, x, pos)) == length(list) + 1\n{\n  if pos == 0 {\n    assert insertAt(list, x, 0) == Cons(x, list);\n  } else {\n    match list\n    case Nil =>\n      assert insertAt(Nil, x, pos) == Cons(x, Nil);\n    case Cons(h, t) =>\n      InsertAtLength(t, x, pos - 1);\n  }\n}", "output": "LengthAppend(t, l2);"}, {"id": "example_AppendNil_0", "type": "call", "program": "// Linked list operations: insert, delete, reverse, cycle detection\n\ndatatype LinkedList<T> = Nil | Cons(head: T, tail: LinkedList<T>)\n\n// Length of linked list\nfunction {:spec} length<T>(list: LinkedList<T>): nat\n{\n  match list\n  case Nil => 0\n  case Cons(_, tail) => 1 + length(tail)\n}\n\n// Append two linked lists\nfunction {:spec} append<T>(l1: LinkedList<T>, l2: LinkedList<T>): LinkedList<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, append(t, l2))\n}\n\n// Reverse a linked list\nfunction {:spec} reverse<T>(list: LinkedList<T>): LinkedList<T>\n{\n  reverseHelper(list, Nil)\n}\n\nfunction reverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>): LinkedList<T>\n{\n  match list\n  case Nil => acc\n  case Cons(h, t) => reverseHelper(t, Cons(h, acc))\n}\n\n// Get nth element (0-indexed)\nfunction {:spec} nth<T>(list: LinkedList<T>, n: nat): T\n  requires n < length(list)\n{\n  match list\n  case Cons(h, t) => if n == 0 then h else nth(t, n - 1)\n}\n\n// Check if element exists in list\npredicate {:spec} contains<T(==)>(list: LinkedList<T>, x: T)\n{\n  match list\n  case Nil => false\n  case Cons(h, t) => h == x || contains(t, x)\n}\n\n// Remove first occurrence of element\nfunction {:spec} remove<T(==)>(list: LinkedList<T>, x: T): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => if h == x then t else Cons(h, remove(t, x))\n}\n\n// Insert at position\nfunction {:spec} insertAt<T>(list: LinkedList<T>, x: T, pos: nat): LinkedList<T>\n{\n  if pos == 0 then Cons(x, list)\n  else match list\n    case Nil => Cons(x, Nil)\n    case Cons(h, t) => Cons(h, insertAt(t, x, pos - 1))\n}\n\n// Convert to sequence\nfunction {:spec} toSeq<T>(list: LinkedList<T>): seq<T>\n{\n  match list\n  case Nil => []\n  case Cons(h, t) => [h] + toSeq(t)\n}\n\n// Convert from sequence\nfunction {:spec} fromSeq<T>(s: seq<T>): LinkedList<T>\n{\n  if |s| == 0 then Nil\n  else Cons(s[0], fromSeq(s[1..]))\n}\n\n// Map function over list\nfunction {:spec} listMap<T, U>(list: LinkedList<T>, f: T -> U): LinkedList<U>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => Cons(f(h), listMap(t, f))\n}\n\n// Filter list with predicate\nfunction {:spec} filter<T>(list: LinkedList<T>, p: T -> bool): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) =>\n    if p(h) then Cons(h, filter(t, p))\n    else filter(t, p)\n}\n\n// Take first n elements\nfunction {:spec} take<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n{\n  if n == 0 then Nil\n  else match list\n    case Nil => Nil\n    case Cons(h, t) => Cons(h, take(t, n - 1))\n}\n\n// Drop first n elements\nfunction {:spec} drop<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n  decreases list\n{\n  if n == 0 then list\n  else match list\n    case Nil => Nil\n    case Cons(_, t) => drop(t, n - 1)\n}\n\n// Check if list is palindrome\npredicate {:spec} isPalindrome<T(==)>(list: LinkedList<T>)\n{\n  toSeq(list) == toSeq(reverse(list))\n}\n\n// --- Lemmas for correctness ---\n\nlemma LengthAppend<T>(l1: LinkedList<T>, l2: LinkedList<T>)\n  ensures length(append(l1, l2)) == length(l1) + length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) =>\n    LengthAppend(t, l2);\n}\n\nlemma AppendNil<T>(list: LinkedList<T>)\n  ensures append(list, Nil) == list\n  ensures append(Nil, list) == list\n{\n  match list\n  case Nil =>\n  case Cons(_, t) =>\n    \n/*[CODE HERE]*/\n}\n\nlemma AppendAssociative<T>(l1: LinkedList<T>, l2: LinkedList<T>, l3: LinkedList<T>)\n  ensures append(append(l1, l2), l3) == append(l1, append(l2, l3))\n{\n  match l1\n  case Nil =>\n  case Cons(h, t) =>\n    AppendAssociative(t, l2, l3);\n}\n\nlemma ReverseLength<T>(list: LinkedList<T>)\n  ensures length(reverse(list)) == length(list)\n{\n  ReverseHelperLength(list, Nil);\n}\n\nlemma ReverseHelperLength<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures length(reverseHelper(list, acc)) == length(list) + length(acc)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    calc == {\n      length(reverseHelper(list, acc));\n      length(reverseHelper(t, Cons(h, acc)));\n      { ReverseHelperLength(t, Cons(h, acc)); }\n      length(t) + length(Cons(h, acc));\n      length(t) + 1 + length(acc);\n      length(list) + length(acc);\n    }\n}\n\nlemma ReverseReverse<T>(list: LinkedList<T>)\n  ensures reverse(reverse(list)) == list\n{\n  ReverseReverseHelper(list, Nil);\n}\n\nlemma ReverseReverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures reverseHelper(reverseHelper(list, acc), Nil) == reverseHelper(acc, list)\n{\n  match list\n  case Nil =>\n    assert reverseHelper(reverseHelper(Nil, acc), Nil) == reverseHelper(acc, Nil);\n  case Cons(h, t) =>\n    calc == {\n      reverseHelper(reverseHelper(Cons(h, t), acc), Nil);\n      reverseHelper(reverseHelper(t, Cons(h, acc)), Nil);\n      { ReverseReverseHelper(t, Cons(h, acc)); }\n      reverseHelper(Cons(h, acc), t);\n      reverseHelper(acc, Cons(h, t));\n    }\n}\n\nlemma ToSeqFromSeq<T>(s: seq<T>)\n  ensures toSeq(fromSeq(s)) == s\n{\n  if |s| == 0 {\n    assert fromSeq(s) == Nil;\n  } else {\n    ToSeqFromSeq(s[1..]);\n    assert toSeq(fromSeq(s)) == [s[0]] + toSeq(fromSeq(s[1..]));\n  }\n}\n\nlemma FromSeqToSeq<T>(list: LinkedList<T>)\n  ensures fromSeq(toSeq(list)) == list\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    FromSeqToSeq(t);\n}\n\nlemma NthCorrect<T>(list: LinkedList<T>, n: nat)\n  requires n < length(list)\n  ensures |toSeq(list)| > n\n  ensures toSeq(list)[n] == nth(list, n)\n{\n  match list\n  case Cons(h, t) =>\n    if n == 0 {\n      assert toSeq(list)[0] == h;\n    } else {\n      NthCorrect(t, n - 1);\n    }\n}\n\nlemma MapLength<T, U>(list: LinkedList<T>, f: T -> U)\n  ensures length(listMap(list, f)) == length(list)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    MapLength(t, f);\n}\n\nlemma FilterSubset<T>(list: LinkedList<T>, p: T -> bool)\n  ensures length(filter(list, p)) <= length(list)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    FilterSubset(t, p);\n    if p(h) {\n      assert length(filter(list, p)) == 1 + length(filter(t, p));\n    } else {\n      assert length(filter(list, p)) == length(filter(t, p));\n    }\n}\n\nlemma TakeDropConcat<T>(list: LinkedList<T>, n: nat)\n  ensures append(take(list, n), drop(list, n)) == list\n{\n  if n == 0 {\n    assert take(list, 0) == Nil;\n    assert drop(list, 0) == list;\n    AppendNil(list);\n  } else {\n    match list\n    case Nil =>\n    case Cons(h, t) =>\n      TakeDropConcat(t, n - 1);\n      calc == {\n        append(take(list, n), drop(list, n));\n        append(Cons(h, take(t, n - 1)), drop(t, n - 1));\n        Cons(h, append(take(t, n - 1), drop(t, n - 1)));\n        Cons(h, t);\n        list;\n      }\n  }\n}\n\nlemma RemoveDecreasesLength<T>(list: LinkedList<T>, x: T)\n  requires contains(list, x)\n  ensures length(remove(list, x)) == length(list) - 1\n{\n  match list\n  case Cons(h, t) =>\n    if h == x {\n      assert remove(list, x) == t;\n    } else {\n      assert contains(t, x);\n      RemoveDecreasesLength(t, x);\n    }\n}\n\nlemma InsertAtLength<T>(list: LinkedList<T>, x: T, pos: nat)\n  ensures length(insertAt(list, x, pos)) == length(list) + 1\n{\n  if pos == 0 {\n    assert insertAt(list, x, 0) == Cons(x, list);\n  } else {\n    match list\n    case Nil =>\n      assert insertAt(Nil, x, pos) == Cons(x, Nil);\n    case Cons(h, t) =>\n      InsertAtLength(t, x, pos - 1);\n  }\n}", "output": "AppendNil(t);"}, {"id": "example_AppendAssociative_0", "type": "call", "program": "// Linked list operations: insert, delete, reverse, cycle detection\n\ndatatype LinkedList<T> = Nil | Cons(head: T, tail: LinkedList<T>)\n\n// Length of linked list\nfunction {:spec} length<T>(list: LinkedList<T>): nat\n{\n  match list\n  case Nil => 0\n  case Cons(_, tail) => 1 + length(tail)\n}\n\n// Append two linked lists\nfunction {:spec} append<T>(l1: LinkedList<T>, l2: LinkedList<T>): LinkedList<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, append(t, l2))\n}\n\n// Reverse a linked list\nfunction {:spec} reverse<T>(list: LinkedList<T>): LinkedList<T>\n{\n  reverseHelper(list, Nil)\n}\n\nfunction reverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>): LinkedList<T>\n{\n  match list\n  case Nil => acc\n  case Cons(h, t) => reverseHelper(t, Cons(h, acc))\n}\n\n// Get nth element (0-indexed)\nfunction {:spec} nth<T>(list: LinkedList<T>, n: nat): T\n  requires n < length(list)\n{\n  match list\n  case Cons(h, t) => if n == 0 then h else nth(t, n - 1)\n}\n\n// Check if element exists in list\npredicate {:spec} contains<T(==)>(list: LinkedList<T>, x: T)\n{\n  match list\n  case Nil => false\n  case Cons(h, t) => h == x || contains(t, x)\n}\n\n// Remove first occurrence of element\nfunction {:spec} remove<T(==)>(list: LinkedList<T>, x: T): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => if h == x then t else Cons(h, remove(t, x))\n}\n\n// Insert at position\nfunction {:spec} insertAt<T>(list: LinkedList<T>, x: T, pos: nat): LinkedList<T>\n{\n  if pos == 0 then Cons(x, list)\n  else match list\n    case Nil => Cons(x, Nil)\n    case Cons(h, t) => Cons(h, insertAt(t, x, pos - 1))\n}\n\n// Convert to sequence\nfunction {:spec} toSeq<T>(list: LinkedList<T>): seq<T>\n{\n  match list\n  case Nil => []\n  case Cons(h, t) => [h] + toSeq(t)\n}\n\n// Convert from sequence\nfunction {:spec} fromSeq<T>(s: seq<T>): LinkedList<T>\n{\n  if |s| == 0 then Nil\n  else Cons(s[0], fromSeq(s[1..]))\n}\n\n// Map function over list\nfunction {:spec} listMap<T, U>(list: LinkedList<T>, f: T -> U): LinkedList<U>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => Cons(f(h), listMap(t, f))\n}\n\n// Filter list with predicate\nfunction {:spec} filter<T>(list: LinkedList<T>, p: T -> bool): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) =>\n    if p(h) then Cons(h, filter(t, p))\n    else filter(t, p)\n}\n\n// Take first n elements\nfunction {:spec} take<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n{\n  if n == 0 then Nil\n  else match list\n    case Nil => Nil\n    case Cons(h, t) => Cons(h, take(t, n - 1))\n}\n\n// Drop first n elements\nfunction {:spec} drop<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n  decreases list\n{\n  if n == 0 then list\n  else match list\n    case Nil => Nil\n    case Cons(_, t) => drop(t, n - 1)\n}\n\n// Check if list is palindrome\npredicate {:spec} isPalindrome<T(==)>(list: LinkedList<T>)\n{\n  toSeq(list) == toSeq(reverse(list))\n}\n\n// --- Lemmas for correctness ---\n\nlemma LengthAppend<T>(l1: LinkedList<T>, l2: LinkedList<T>)\n  ensures length(append(l1, l2)) == length(l1) + length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) =>\n    LengthAppend(t, l2);\n}\n\nlemma AppendNil<T>(list: LinkedList<T>)\n  ensures append(list, Nil) == list\n  ensures append(Nil, list) == list\n{\n  match list\n  case Nil =>\n  case Cons(_, t) =>\n    AppendNil(t);\n}\n\nlemma AppendAssociative<T>(l1: LinkedList<T>, l2: LinkedList<T>, l3: LinkedList<T>)\n  ensures append(append(l1, l2), l3) == append(l1, append(l2, l3))\n{\n  match l1\n  case Nil =>\n  case Cons(h, t) =>\n    \n/*[CODE HERE]*/\n}\n\nlemma ReverseLength<T>(list: LinkedList<T>)\n  ensures length(reverse(list)) == length(list)\n{\n  ReverseHelperLength(list, Nil);\n}\n\nlemma ReverseHelperLength<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures length(reverseHelper(list, acc)) == length(list) + length(acc)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    calc == {\n      length(reverseHelper(list, acc));\n      length(reverseHelper(t, Cons(h, acc)));\n      { ReverseHelperLength(t, Cons(h, acc)); }\n      length(t) + length(Cons(h, acc));\n      length(t) + 1 + length(acc);\n      length(list) + length(acc);\n    }\n}\n\nlemma ReverseReverse<T>(list: LinkedList<T>)\n  ensures reverse(reverse(list)) == list\n{\n  ReverseReverseHelper(list, Nil);\n}\n\nlemma ReverseReverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures reverseHelper(reverseHelper(list, acc), Nil) == reverseHelper(acc, list)\n{\n  match list\n  case Nil =>\n    assert reverseHelper(reverseHelper(Nil, acc), Nil) == reverseHelper(acc, Nil);\n  case Cons(h, t) =>\n    calc == {\n      reverseHelper(reverseHelper(Cons(h, t), acc), Nil);\n      reverseHelper(reverseHelper(t, Cons(h, acc)), Nil);\n      { ReverseReverseHelper(t, Cons(h, acc)); }\n      reverseHelper(Cons(h, acc), t);\n      reverseHelper(acc, Cons(h, t));\n    }\n}\n\nlemma ToSeqFromSeq<T>(s: seq<T>)\n  ensures toSeq(fromSeq(s)) == s\n{\n  if |s| == 0 {\n    assert fromSeq(s) == Nil;\n  } else {\n    ToSeqFromSeq(s[1..]);\n    assert toSeq(fromSeq(s)) == [s[0]] + toSeq(fromSeq(s[1..]));\n  }\n}\n\nlemma FromSeqToSeq<T>(list: LinkedList<T>)\n  ensures fromSeq(toSeq(list)) == list\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    FromSeqToSeq(t);\n}\n\nlemma NthCorrect<T>(list: LinkedList<T>, n: nat)\n  requires n < length(list)\n  ensures |toSeq(list)| > n\n  ensures toSeq(list)[n] == nth(list, n)\n{\n  match list\n  case Cons(h, t) =>\n    if n == 0 {\n      assert toSeq(list)[0] == h;\n    } else {\n      NthCorrect(t, n - 1);\n    }\n}\n\nlemma MapLength<T, U>(list: LinkedList<T>, f: T -> U)\n  ensures length(listMap(list, f)) == length(list)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    MapLength(t, f);\n}\n\nlemma FilterSubset<T>(list: LinkedList<T>, p: T -> bool)\n  ensures length(filter(list, p)) <= length(list)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    FilterSubset(t, p);\n    if p(h) {\n      assert length(filter(list, p)) == 1 + length(filter(t, p));\n    } else {\n      assert length(filter(list, p)) == length(filter(t, p));\n    }\n}\n\nlemma TakeDropConcat<T>(list: LinkedList<T>, n: nat)\n  ensures append(take(list, n), drop(list, n)) == list\n{\n  if n == 0 {\n    assert take(list, 0) == Nil;\n    assert drop(list, 0) == list;\n    AppendNil(list);\n  } else {\n    match list\n    case Nil =>\n    case Cons(h, t) =>\n      TakeDropConcat(t, n - 1);\n      calc == {\n        append(take(list, n), drop(list, n));\n        append(Cons(h, take(t, n - 1)), drop(t, n - 1));\n        Cons(h, append(take(t, n - 1), drop(t, n - 1)));\n        Cons(h, t);\n        list;\n      }\n  }\n}\n\nlemma RemoveDecreasesLength<T>(list: LinkedList<T>, x: T)\n  requires contains(list, x)\n  ensures length(remove(list, x)) == length(list) - 1\n{\n  match list\n  case Cons(h, t) =>\n    if h == x {\n      assert remove(list, x) == t;\n    } else {\n      assert contains(t, x);\n      RemoveDecreasesLength(t, x);\n    }\n}\n\nlemma InsertAtLength<T>(list: LinkedList<T>, x: T, pos: nat)\n  ensures length(insertAt(list, x, pos)) == length(list) + 1\n{\n  if pos == 0 {\n    assert insertAt(list, x, 0) == Cons(x, list);\n  } else {\n    match list\n    case Nil =>\n      assert insertAt(Nil, x, pos) == Cons(x, Nil);\n    case Cons(h, t) =>\n      InsertAtLength(t, x, pos - 1);\n  }\n}", "output": "AppendAssociative(t, l2, l3);"}, {"id": "example_ReverseLength_0", "type": "call", "program": "// Linked list operations: insert, delete, reverse, cycle detection\n\ndatatype LinkedList<T> = Nil | Cons(head: T, tail: LinkedList<T>)\n\n// Length of linked list\nfunction {:spec} length<T>(list: LinkedList<T>): nat\n{\n  match list\n  case Nil => 0\n  case Cons(_, tail) => 1 + length(tail)\n}\n\n// Append two linked lists\nfunction {:spec} append<T>(l1: LinkedList<T>, l2: LinkedList<T>): LinkedList<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, append(t, l2))\n}\n\n// Reverse a linked list\nfunction {:spec} reverse<T>(list: LinkedList<T>): LinkedList<T>\n{\n  reverseHelper(list, Nil)\n}\n\nfunction reverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>): LinkedList<T>\n{\n  match list\n  case Nil => acc\n  case Cons(h, t) => reverseHelper(t, Cons(h, acc))\n}\n\n// Get nth element (0-indexed)\nfunction {:spec} nth<T>(list: LinkedList<T>, n: nat): T\n  requires n < length(list)\n{\n  match list\n  case Cons(h, t) => if n == 0 then h else nth(t, n - 1)\n}\n\n// Check if element exists in list\npredicate {:spec} contains<T(==)>(list: LinkedList<T>, x: T)\n{\n  match list\n  case Nil => false\n  case Cons(h, t) => h == x || contains(t, x)\n}\n\n// Remove first occurrence of element\nfunction {:spec} remove<T(==)>(list: LinkedList<T>, x: T): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => if h == x then t else Cons(h, remove(t, x))\n}\n\n// Insert at position\nfunction {:spec} insertAt<T>(list: LinkedList<T>, x: T, pos: nat): LinkedList<T>\n{\n  if pos == 0 then Cons(x, list)\n  else match list\n    case Nil => Cons(x, Nil)\n    case Cons(h, t) => Cons(h, insertAt(t, x, pos - 1))\n}\n\n// Convert to sequence\nfunction {:spec} toSeq<T>(list: LinkedList<T>): seq<T>\n{\n  match list\n  case Nil => []\n  case Cons(h, t) => [h] + toSeq(t)\n}\n\n// Convert from sequence\nfunction {:spec} fromSeq<T>(s: seq<T>): LinkedList<T>\n{\n  if |s| == 0 then Nil\n  else Cons(s[0], fromSeq(s[1..]))\n}\n\n// Map function over list\nfunction {:spec} listMap<T, U>(list: LinkedList<T>, f: T -> U): LinkedList<U>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => Cons(f(h), listMap(t, f))\n}\n\n// Filter list with predicate\nfunction {:spec} filter<T>(list: LinkedList<T>, p: T -> bool): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) =>\n    if p(h) then Cons(h, filter(t, p))\n    else filter(t, p)\n}\n\n// Take first n elements\nfunction {:spec} take<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n{\n  if n == 0 then Nil\n  else match list\n    case Nil => Nil\n    case Cons(h, t) => Cons(h, take(t, n - 1))\n}\n\n// Drop first n elements\nfunction {:spec} drop<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n  decreases list\n{\n  if n == 0 then list\n  else match list\n    case Nil => Nil\n    case Cons(_, t) => drop(t, n - 1)\n}\n\n// Check if list is palindrome\npredicate {:spec} isPalindrome<T(==)>(list: LinkedList<T>)\n{\n  toSeq(list) == toSeq(reverse(list))\n}\n\n// --- Lemmas for correctness ---\n\nlemma LengthAppend<T>(l1: LinkedList<T>, l2: LinkedList<T>)\n  ensures length(append(l1, l2)) == length(l1) + length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) =>\n    LengthAppend(t, l2);\n}\n\nlemma AppendNil<T>(list: LinkedList<T>)\n  ensures append(list, Nil) == list\n  ensures append(Nil, list) == list\n{\n  match list\n  case Nil =>\n  case Cons(_, t) =>\n    AppendNil(t);\n}\n\nlemma AppendAssociative<T>(l1: LinkedList<T>, l2: LinkedList<T>, l3: LinkedList<T>)\n  ensures append(append(l1, l2), l3) == append(l1, append(l2, l3))\n{\n  match l1\n  case Nil =>\n  case Cons(h, t) =>\n    AppendAssociative(t, l2, l3);\n}\n\nlemma ReverseLength<T>(list: LinkedList<T>)\n  ensures length(reverse(list)) == length(list)\n{\n  \n/*[CODE HERE]*/\n}\n\nlemma ReverseHelperLength<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures length(reverseHelper(list, acc)) == length(list) + length(acc)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    calc == {\n      length(reverseHelper(list, acc));\n      length(reverseHelper(t, Cons(h, acc)));\n      { ReverseHelperLength(t, Cons(h, acc)); }\n      length(t) + length(Cons(h, acc));\n      length(t) + 1 + length(acc);\n      length(list) + length(acc);\n    }\n}\n\nlemma ReverseReverse<T>(list: LinkedList<T>)\n  ensures reverse(reverse(list)) == list\n{\n  ReverseReverseHelper(list, Nil);\n}\n\nlemma ReverseReverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures reverseHelper(reverseHelper(list, acc), Nil) == reverseHelper(acc, list)\n{\n  match list\n  case Nil =>\n    assert reverseHelper(reverseHelper(Nil, acc), Nil) == reverseHelper(acc, Nil);\n  case Cons(h, t) =>\n    calc == {\n      reverseHelper(reverseHelper(Cons(h, t), acc), Nil);\n      reverseHelper(reverseHelper(t, Cons(h, acc)), Nil);\n      { ReverseReverseHelper(t, Cons(h, acc)); }\n      reverseHelper(Cons(h, acc), t);\n      reverseHelper(acc, Cons(h, t));\n    }\n}\n\nlemma ToSeqFromSeq<T>(s: seq<T>)\n  ensures toSeq(fromSeq(s)) == s\n{\n  if |s| == 0 {\n    assert fromSeq(s) == Nil;\n  } else {\n    ToSeqFromSeq(s[1..]);\n    assert toSeq(fromSeq(s)) == [s[0]] + toSeq(fromSeq(s[1..]));\n  }\n}\n\nlemma FromSeqToSeq<T>(list: LinkedList<T>)\n  ensures fromSeq(toSeq(list)) == list\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    FromSeqToSeq(t);\n}\n\nlemma NthCorrect<T>(list: LinkedList<T>, n: nat)\n  requires n < length(list)\n  ensures |toSeq(list)| > n\n  ensures toSeq(list)[n] == nth(list, n)\n{\n  match list\n  case Cons(h, t) =>\n    if n == 0 {\n      assert toSeq(list)[0] == h;\n    } else {\n      NthCorrect(t, n - 1);\n    }\n}\n\nlemma MapLength<T, U>(list: LinkedList<T>, f: T -> U)\n  ensures length(listMap(list, f)) == length(list)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    MapLength(t, f);\n}\n\nlemma FilterSubset<T>(list: LinkedList<T>, p: T -> bool)\n  ensures length(filter(list, p)) <= length(list)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    FilterSubset(t, p);\n    if p(h) {\n      assert length(filter(list, p)) == 1 + length(filter(t, p));\n    } else {\n      assert length(filter(list, p)) == length(filter(t, p));\n    }\n}\n\nlemma TakeDropConcat<T>(list: LinkedList<T>, n: nat)\n  ensures append(take(list, n), drop(list, n)) == list\n{\n  if n == 0 {\n    assert take(list, 0) == Nil;\n    assert drop(list, 0) == list;\n    AppendNil(list);\n  } else {\n    match list\n    case Nil =>\n    case Cons(h, t) =>\n      TakeDropConcat(t, n - 1);\n      calc == {\n        append(take(list, n), drop(list, n));\n        append(Cons(h, take(t, n - 1)), drop(t, n - 1));\n        Cons(h, append(take(t, n - 1), drop(t, n - 1)));\n        Cons(h, t);\n        list;\n      }\n  }\n}\n\nlemma RemoveDecreasesLength<T>(list: LinkedList<T>, x: T)\n  requires contains(list, x)\n  ensures length(remove(list, x)) == length(list) - 1\n{\n  match list\n  case Cons(h, t) =>\n    if h == x {\n      assert remove(list, x) == t;\n    } else {\n      assert contains(t, x);\n      RemoveDecreasesLength(t, x);\n    }\n}\n\nlemma InsertAtLength<T>(list: LinkedList<T>, x: T, pos: nat)\n  ensures length(insertAt(list, x, pos)) == length(list) + 1\n{\n  if pos == 0 {\n    assert insertAt(list, x, 0) == Cons(x, list);\n  } else {\n    match list\n    case Nil =>\n      assert insertAt(Nil, x, pos) == Cons(x, Nil);\n    case Cons(h, t) =>\n      InsertAtLength(t, x, pos - 1);\n  }\n}", "output": "ReverseHelperLength(list, Nil);"}, {"id": "example_ReverseHelperLength_0", "type": "call", "program": "// Linked list operations: insert, delete, reverse, cycle detection\n\ndatatype LinkedList<T> = Nil | Cons(head: T, tail: LinkedList<T>)\n\n// Length of linked list\nfunction {:spec} length<T>(list: LinkedList<T>): nat\n{\n  match list\n  case Nil => 0\n  case Cons(_, tail) => 1 + length(tail)\n}\n\n// Append two linked lists\nfunction {:spec} append<T>(l1: LinkedList<T>, l2: LinkedList<T>): LinkedList<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, append(t, l2))\n}\n\n// Reverse a linked list\nfunction {:spec} reverse<T>(list: LinkedList<T>): LinkedList<T>\n{\n  reverseHelper(list, Nil)\n}\n\nfunction reverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>): LinkedList<T>\n{\n  match list\n  case Nil => acc\n  case Cons(h, t) => reverseHelper(t, Cons(h, acc))\n}\n\n// Get nth element (0-indexed)\nfunction {:spec} nth<T>(list: LinkedList<T>, n: nat): T\n  requires n < length(list)\n{\n  match list\n  case Cons(h, t) => if n == 0 then h else nth(t, n - 1)\n}\n\n// Check if element exists in list\npredicate {:spec} contains<T(==)>(list: LinkedList<T>, x: T)\n{\n  match list\n  case Nil => false\n  case Cons(h, t) => h == x || contains(t, x)\n}\n\n// Remove first occurrence of element\nfunction {:spec} remove<T(==)>(list: LinkedList<T>, x: T): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => if h == x then t else Cons(h, remove(t, x))\n}\n\n// Insert at position\nfunction {:spec} insertAt<T>(list: LinkedList<T>, x: T, pos: nat): LinkedList<T>\n{\n  if pos == 0 then Cons(x, list)\n  else match list\n    case Nil => Cons(x, Nil)\n    case Cons(h, t) => Cons(h, insertAt(t, x, pos - 1))\n}\n\n// Convert to sequence\nfunction {:spec} toSeq<T>(list: LinkedList<T>): seq<T>\n{\n  match list\n  case Nil => []\n  case Cons(h, t) => [h] + toSeq(t)\n}\n\n// Convert from sequence\nfunction {:spec} fromSeq<T>(s: seq<T>): LinkedList<T>\n{\n  if |s| == 0 then Nil\n  else Cons(s[0], fromSeq(s[1..]))\n}\n\n// Map function over list\nfunction {:spec} listMap<T, U>(list: LinkedList<T>, f: T -> U): LinkedList<U>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => Cons(f(h), listMap(t, f))\n}\n\n// Filter list with predicate\nfunction {:spec} filter<T>(list: LinkedList<T>, p: T -> bool): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) =>\n    if p(h) then Cons(h, filter(t, p))\n    else filter(t, p)\n}\n\n// Take first n elements\nfunction {:spec} take<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n{\n  if n == 0 then Nil\n  else match list\n    case Nil => Nil\n    case Cons(h, t) => Cons(h, take(t, n - 1))\n}\n\n// Drop first n elements\nfunction {:spec} drop<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n  decreases list\n{\n  if n == 0 then list\n  else match list\n    case Nil => Nil\n    case Cons(_, t) => drop(t, n - 1)\n}\n\n// Check if list is palindrome\npredicate {:spec} isPalindrome<T(==)>(list: LinkedList<T>)\n{\n  toSeq(list) == toSeq(reverse(list))\n}\n\n// --- Lemmas for correctness ---\n\nlemma LengthAppend<T>(l1: LinkedList<T>, l2: LinkedList<T>)\n  ensures length(append(l1, l2)) == length(l1) + length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) =>\n    LengthAppend(t, l2);\n}\n\nlemma AppendNil<T>(list: LinkedList<T>)\n  ensures append(list, Nil) == list\n  ensures append(Nil, list) == list\n{\n  match list\n  case Nil =>\n  case Cons(_, t) =>\n    AppendNil(t);\n}\n\nlemma AppendAssociative<T>(l1: LinkedList<T>, l2: LinkedList<T>, l3: LinkedList<T>)\n  ensures append(append(l1, l2), l3) == append(l1, append(l2, l3))\n{\n  match l1\n  case Nil =>\n  case Cons(h, t) =>\n    AppendAssociative(t, l2, l3);\n}\n\nlemma ReverseLength<T>(list: LinkedList<T>)\n  ensures length(reverse(list)) == length(list)\n{\n  ReverseHelperLength(list, Nil);\n}\n\nlemma ReverseHelperLength<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures length(reverseHelper(list, acc)) == length(list) + length(acc)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    calc == {\n      length(reverseHelper(list, acc));\n      length(reverseHelper(t, Cons(h, acc)));\n      { \n/*[CODE HERE]*/\n}\n      length(t) + length(Cons(h, acc));\n      length(t) + 1 + length(acc);\n      length(list) + length(acc);\n    }\n}\n\nlemma ReverseReverse<T>(list: LinkedList<T>)\n  ensures reverse(reverse(list)) == list\n{\n  ReverseReverseHelper(list, Nil);\n}\n\nlemma ReverseReverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures reverseHelper(reverseHelper(list, acc), Nil) == reverseHelper(acc, list)\n{\n  match list\n  case Nil =>\n    assert reverseHelper(reverseHelper(Nil, acc), Nil) == reverseHelper(acc, Nil);\n  case Cons(h, t) =>\n    calc == {\n      reverseHelper(reverseHelper(Cons(h, t), acc), Nil);\n      reverseHelper(reverseHelper(t, Cons(h, acc)), Nil);\n      { ReverseReverseHelper(t, Cons(h, acc)); }\n      reverseHelper(Cons(h, acc), t);\n      reverseHelper(acc, Cons(h, t));\n    }\n}\n\nlemma ToSeqFromSeq<T>(s: seq<T>)\n  ensures toSeq(fromSeq(s)) == s\n{\n  if |s| == 0 {\n    assert fromSeq(s) == Nil;\n  } else {\n    ToSeqFromSeq(s[1..]);\n    assert toSeq(fromSeq(s)) == [s[0]] + toSeq(fromSeq(s[1..]));\n  }\n}\n\nlemma FromSeqToSeq<T>(list: LinkedList<T>)\n  ensures fromSeq(toSeq(list)) == list\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    FromSeqToSeq(t);\n}\n\nlemma NthCorrect<T>(list: LinkedList<T>, n: nat)\n  requires n < length(list)\n  ensures |toSeq(list)| > n\n  ensures toSeq(list)[n] == nth(list, n)\n{\n  match list\n  case Cons(h, t) =>\n    if n == 0 {\n      assert toSeq(list)[0] == h;\n    } else {\n      NthCorrect(t, n - 1);\n    }\n}\n\nlemma MapLength<T, U>(list: LinkedList<T>, f: T -> U)\n  ensures length(listMap(list, f)) == length(list)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    MapLength(t, f);\n}\n\nlemma FilterSubset<T>(list: LinkedList<T>, p: T -> bool)\n  ensures length(filter(list, p)) <= length(list)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    FilterSubset(t, p);\n    if p(h) {\n      assert length(filter(list, p)) == 1 + length(filter(t, p));\n    } else {\n      assert length(filter(list, p)) == length(filter(t, p));\n    }\n}\n\nlemma TakeDropConcat<T>(list: LinkedList<T>, n: nat)\n  ensures append(take(list, n), drop(list, n)) == list\n{\n  if n == 0 {\n    assert take(list, 0) == Nil;\n    assert drop(list, 0) == list;\n    AppendNil(list);\n  } else {\n    match list\n    case Nil =>\n    case Cons(h, t) =>\n      TakeDropConcat(t, n - 1);\n      calc == {\n        append(take(list, n), drop(list, n));\n        append(Cons(h, take(t, n - 1)), drop(t, n - 1));\n        Cons(h, append(take(t, n - 1), drop(t, n - 1)));\n        Cons(h, t);\n        list;\n      }\n  }\n}\n\nlemma RemoveDecreasesLength<T>(list: LinkedList<T>, x: T)\n  requires contains(list, x)\n  ensures length(remove(list, x)) == length(list) - 1\n{\n  match list\n  case Cons(h, t) =>\n    if h == x {\n      assert remove(list, x) == t;\n    } else {\n      assert contains(t, x);\n      RemoveDecreasesLength(t, x);\n    }\n}\n\nlemma InsertAtLength<T>(list: LinkedList<T>, x: T, pos: nat)\n  ensures length(insertAt(list, x, pos)) == length(list) + 1\n{\n  if pos == 0 {\n    assert insertAt(list, x, 0) == Cons(x, list);\n  } else {\n    match list\n    case Nil =>\n      assert insertAt(Nil, x, pos) == Cons(x, Nil);\n    case Cons(h, t) =>\n      InsertAtLength(t, x, pos - 1);\n  }\n}", "output": "ReverseHelperLength(t, Cons(h, acc));"}, {"id": "example_ReverseReverse_0", "type": "call", "program": "// Linked list operations: insert, delete, reverse, cycle detection\n\ndatatype LinkedList<T> = Nil | Cons(head: T, tail: LinkedList<T>)\n\n// Length of linked list\nfunction {:spec} length<T>(list: LinkedList<T>): nat\n{\n  match list\n  case Nil => 0\n  case Cons(_, tail) => 1 + length(tail)\n}\n\n// Append two linked lists\nfunction {:spec} append<T>(l1: LinkedList<T>, l2: LinkedList<T>): LinkedList<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, append(t, l2))\n}\n\n// Reverse a linked list\nfunction {:spec} reverse<T>(list: LinkedList<T>): LinkedList<T>\n{\n  reverseHelper(list, Nil)\n}\n\nfunction reverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>): LinkedList<T>\n{\n  match list\n  case Nil => acc\n  case Cons(h, t) => reverseHelper(t, Cons(h, acc))\n}\n\n// Get nth element (0-indexed)\nfunction {:spec} nth<T>(list: LinkedList<T>, n: nat): T\n  requires n < length(list)\n{\n  match list\n  case Cons(h, t) => if n == 0 then h else nth(t, n - 1)\n}\n\n// Check if element exists in list\npredicate {:spec} contains<T(==)>(list: LinkedList<T>, x: T)\n{\n  match list\n  case Nil => false\n  case Cons(h, t) => h == x || contains(t, x)\n}\n\n// Remove first occurrence of element\nfunction {:spec} remove<T(==)>(list: LinkedList<T>, x: T): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => if h == x then t else Cons(h, remove(t, x))\n}\n\n// Insert at position\nfunction {:spec} insertAt<T>(list: LinkedList<T>, x: T, pos: nat): LinkedList<T>\n{\n  if pos == 0 then Cons(x, list)\n  else match list\n    case Nil => Cons(x, Nil)\n    case Cons(h, t) => Cons(h, insertAt(t, x, pos - 1))\n}\n\n// Convert to sequence\nfunction {:spec} toSeq<T>(list: LinkedList<T>): seq<T>\n{\n  match list\n  case Nil => []\n  case Cons(h, t) => [h] + toSeq(t)\n}\n\n// Convert from sequence\nfunction {:spec} fromSeq<T>(s: seq<T>): LinkedList<T>\n{\n  if |s| == 0 then Nil\n  else Cons(s[0], fromSeq(s[1..]))\n}\n\n// Map function over list\nfunction {:spec} listMap<T, U>(list: LinkedList<T>, f: T -> U): LinkedList<U>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => Cons(f(h), listMap(t, f))\n}\n\n// Filter list with predicate\nfunction {:spec} filter<T>(list: LinkedList<T>, p: T -> bool): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) =>\n    if p(h) then Cons(h, filter(t, p))\n    else filter(t, p)\n}\n\n// Take first n elements\nfunction {:spec} take<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n{\n  if n == 0 then Nil\n  else match list\n    case Nil => Nil\n    case Cons(h, t) => Cons(h, take(t, n - 1))\n}\n\n// Drop first n elements\nfunction {:spec} drop<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n  decreases list\n{\n  if n == 0 then list\n  else match list\n    case Nil => Nil\n    case Cons(_, t) => drop(t, n - 1)\n}\n\n// Check if list is palindrome\npredicate {:spec} isPalindrome<T(==)>(list: LinkedList<T>)\n{\n  toSeq(list) == toSeq(reverse(list))\n}\n\n// --- Lemmas for correctness ---\n\nlemma LengthAppend<T>(l1: LinkedList<T>, l2: LinkedList<T>)\n  ensures length(append(l1, l2)) == length(l1) + length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) =>\n    LengthAppend(t, l2);\n}\n\nlemma AppendNil<T>(list: LinkedList<T>)\n  ensures append(list, Nil) == list\n  ensures append(Nil, list) == list\n{\n  match list\n  case Nil =>\n  case Cons(_, t) =>\n    AppendNil(t);\n}\n\nlemma AppendAssociative<T>(l1: LinkedList<T>, l2: LinkedList<T>, l3: LinkedList<T>)\n  ensures append(append(l1, l2), l3) == append(l1, append(l2, l3))\n{\n  match l1\n  case Nil =>\n  case Cons(h, t) =>\n    AppendAssociative(t, l2, l3);\n}\n\nlemma ReverseLength<T>(list: LinkedList<T>)\n  ensures length(reverse(list)) == length(list)\n{\n  ReverseHelperLength(list, Nil);\n}\n\nlemma ReverseHelperLength<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures length(reverseHelper(list, acc)) == length(list) + length(acc)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    calc == {\n      length(reverseHelper(list, acc));\n      length(reverseHelper(t, Cons(h, acc)));\n      { ReverseHelperLength(t, Cons(h, acc)); }\n      length(t) + length(Cons(h, acc));\n      length(t) + 1 + length(acc);\n      length(list) + length(acc);\n    }\n}\n\nlemma ReverseReverse<T>(list: LinkedList<T>)\n  ensures reverse(reverse(list)) == list\n{\n  \n/*[CODE HERE]*/\n}\n\nlemma ReverseReverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures reverseHelper(reverseHelper(list, acc), Nil) == reverseHelper(acc, list)\n{\n  match list\n  case Nil =>\n    assert reverseHelper(reverseHelper(Nil, acc), Nil) == reverseHelper(acc, Nil);\n  case Cons(h, t) =>\n    calc == {\n      reverseHelper(reverseHelper(Cons(h, t), acc), Nil);\n      reverseHelper(reverseHelper(t, Cons(h, acc)), Nil);\n      { ReverseReverseHelper(t, Cons(h, acc)); }\n      reverseHelper(Cons(h, acc), t);\n      reverseHelper(acc, Cons(h, t));\n    }\n}\n\nlemma ToSeqFromSeq<T>(s: seq<T>)\n  ensures toSeq(fromSeq(s)) == s\n{\n  if |s| == 0 {\n    assert fromSeq(s) == Nil;\n  } else {\n    ToSeqFromSeq(s[1..]);\n    assert toSeq(fromSeq(s)) == [s[0]] + toSeq(fromSeq(s[1..]));\n  }\n}\n\nlemma FromSeqToSeq<T>(list: LinkedList<T>)\n  ensures fromSeq(toSeq(list)) == list\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    FromSeqToSeq(t);\n}\n\nlemma NthCorrect<T>(list: LinkedList<T>, n: nat)\n  requires n < length(list)\n  ensures |toSeq(list)| > n\n  ensures toSeq(list)[n] == nth(list, n)\n{\n  match list\n  case Cons(h, t) =>\n    if n == 0 {\n      assert toSeq(list)[0] == h;\n    } else {\n      NthCorrect(t, n - 1);\n    }\n}\n\nlemma MapLength<T, U>(list: LinkedList<T>, f: T -> U)\n  ensures length(listMap(list, f)) == length(list)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    MapLength(t, f);\n}\n\nlemma FilterSubset<T>(list: LinkedList<T>, p: T -> bool)\n  ensures length(filter(list, p)) <= length(list)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    FilterSubset(t, p);\n    if p(h) {\n      assert length(filter(list, p)) == 1 + length(filter(t, p));\n    } else {\n      assert length(filter(list, p)) == length(filter(t, p));\n    }\n}\n\nlemma TakeDropConcat<T>(list: LinkedList<T>, n: nat)\n  ensures append(take(list, n), drop(list, n)) == list\n{\n  if n == 0 {\n    assert take(list, 0) == Nil;\n    assert drop(list, 0) == list;\n    AppendNil(list);\n  } else {\n    match list\n    case Nil =>\n    case Cons(h, t) =>\n      TakeDropConcat(t, n - 1);\n      calc == {\n        append(take(list, n), drop(list, n));\n        append(Cons(h, take(t, n - 1)), drop(t, n - 1));\n        Cons(h, append(take(t, n - 1), drop(t, n - 1)));\n        Cons(h, t);\n        list;\n      }\n  }\n}\n\nlemma RemoveDecreasesLength<T>(list: LinkedList<T>, x: T)\n  requires contains(list, x)\n  ensures length(remove(list, x)) == length(list) - 1\n{\n  match list\n  case Cons(h, t) =>\n    if h == x {\n      assert remove(list, x) == t;\n    } else {\n      assert contains(t, x);\n      RemoveDecreasesLength(t, x);\n    }\n}\n\nlemma InsertAtLength<T>(list: LinkedList<T>, x: T, pos: nat)\n  ensures length(insertAt(list, x, pos)) == length(list) + 1\n{\n  if pos == 0 {\n    assert insertAt(list, x, 0) == Cons(x, list);\n  } else {\n    match list\n    case Nil =>\n      assert insertAt(Nil, x, pos) == Cons(x, Nil);\n    case Cons(h, t) =>\n      InsertAtLength(t, x, pos - 1);\n  }\n}", "output": "ReverseReverseHelper(list, Nil);"}, {"id": "example_ReverseReverseHelper_0", "type": "call", "program": "// Linked list operations: insert, delete, reverse, cycle detection\n\ndatatype LinkedList<T> = Nil | Cons(head: T, tail: LinkedList<T>)\n\n// Length of linked list\nfunction {:spec} length<T>(list: LinkedList<T>): nat\n{\n  match list\n  case Nil => 0\n  case Cons(_, tail) => 1 + length(tail)\n}\n\n// Append two linked lists\nfunction {:spec} append<T>(l1: LinkedList<T>, l2: LinkedList<T>): LinkedList<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, append(t, l2))\n}\n\n// Reverse a linked list\nfunction {:spec} reverse<T>(list: LinkedList<T>): LinkedList<T>\n{\n  reverseHelper(list, Nil)\n}\n\nfunction reverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>): LinkedList<T>\n{\n  match list\n  case Nil => acc\n  case Cons(h, t) => reverseHelper(t, Cons(h, acc))\n}\n\n// Get nth element (0-indexed)\nfunction {:spec} nth<T>(list: LinkedList<T>, n: nat): T\n  requires n < length(list)\n{\n  match list\n  case Cons(h, t) => if n == 0 then h else nth(t, n - 1)\n}\n\n// Check if element exists in list\npredicate {:spec} contains<T(==)>(list: LinkedList<T>, x: T)\n{\n  match list\n  case Nil => false\n  case Cons(h, t) => h == x || contains(t, x)\n}\n\n// Remove first occurrence of element\nfunction {:spec} remove<T(==)>(list: LinkedList<T>, x: T): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => if h == x then t else Cons(h, remove(t, x))\n}\n\n// Insert at position\nfunction {:spec} insertAt<T>(list: LinkedList<T>, x: T, pos: nat): LinkedList<T>\n{\n  if pos == 0 then Cons(x, list)\n  else match list\n    case Nil => Cons(x, Nil)\n    case Cons(h, t) => Cons(h, insertAt(t, x, pos - 1))\n}\n\n// Convert to sequence\nfunction {:spec} toSeq<T>(list: LinkedList<T>): seq<T>\n{\n  match list\n  case Nil => []\n  case Cons(h, t) => [h] + toSeq(t)\n}\n\n// Convert from sequence\nfunction {:spec} fromSeq<T>(s: seq<T>): LinkedList<T>\n{\n  if |s| == 0 then Nil\n  else Cons(s[0], fromSeq(s[1..]))\n}\n\n// Map function over list\nfunction {:spec} listMap<T, U>(list: LinkedList<T>, f: T -> U): LinkedList<U>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => Cons(f(h), listMap(t, f))\n}\n\n// Filter list with predicate\nfunction {:spec} filter<T>(list: LinkedList<T>, p: T -> bool): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) =>\n    if p(h) then Cons(h, filter(t, p))\n    else filter(t, p)\n}\n\n// Take first n elements\nfunction {:spec} take<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n{\n  if n == 0 then Nil\n  else match list\n    case Nil => Nil\n    case Cons(h, t) => Cons(h, take(t, n - 1))\n}\n\n// Drop first n elements\nfunction {:spec} drop<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n  decreases list\n{\n  if n == 0 then list\n  else match list\n    case Nil => Nil\n    case Cons(_, t) => drop(t, n - 1)\n}\n\n// Check if list is palindrome\npredicate {:spec} isPalindrome<T(==)>(list: LinkedList<T>)\n{\n  toSeq(list) == toSeq(reverse(list))\n}\n\n// --- Lemmas for correctness ---\n\nlemma LengthAppend<T>(l1: LinkedList<T>, l2: LinkedList<T>)\n  ensures length(append(l1, l2)) == length(l1) + length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) =>\n    LengthAppend(t, l2);\n}\n\nlemma AppendNil<T>(list: LinkedList<T>)\n  ensures append(list, Nil) == list\n  ensures append(Nil, list) == list\n{\n  match list\n  case Nil =>\n  case Cons(_, t) =>\n    AppendNil(t);\n}\n\nlemma AppendAssociative<T>(l1: LinkedList<T>, l2: LinkedList<T>, l3: LinkedList<T>)\n  ensures append(append(l1, l2), l3) == append(l1, append(l2, l3))\n{\n  match l1\n  case Nil =>\n  case Cons(h, t) =>\n    AppendAssociative(t, l2, l3);\n}\n\nlemma ReverseLength<T>(list: LinkedList<T>)\n  ensures length(reverse(list)) == length(list)\n{\n  ReverseHelperLength(list, Nil);\n}\n\nlemma ReverseHelperLength<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures length(reverseHelper(list, acc)) == length(list) + length(acc)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    calc == {\n      length(reverseHelper(list, acc));\n      length(reverseHelper(t, Cons(h, acc)));\n      { ReverseHelperLength(t, Cons(h, acc)); }\n      length(t) + length(Cons(h, acc));\n      length(t) + 1 + length(acc);\n      length(list) + length(acc);\n    }\n}\n\nlemma ReverseReverse<T>(list: LinkedList<T>)\n  ensures reverse(reverse(list)) == list\n{\n  ReverseReverseHelper(list, Nil);\n}\n\nlemma ReverseReverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures reverseHelper(reverseHelper(list, acc), Nil) == reverseHelper(acc, list)\n{\n  match list\n  case Nil =>\n    assert reverseHelper(reverseHelper(Nil, acc), Nil) == reverseHelper(acc, Nil);\n  case Cons(h, t) =>\n    calc == {\n      reverseHelper(reverseHelper(Cons(h, t), acc), Nil);\n      reverseHelper(reverseHelper(t, Cons(h, acc)), Nil);\n      { \n/*[CODE HERE]*/\n}\n      reverseHelper(Cons(h, acc), t);\n      reverseHelper(acc, Cons(h, t));\n    }\n}\n\nlemma ToSeqFromSeq<T>(s: seq<T>)\n  ensures toSeq(fromSeq(s)) == s\n{\n  if |s| == 0 {\n    assert fromSeq(s) == Nil;\n  } else {\n    ToSeqFromSeq(s[1..]);\n    assert toSeq(fromSeq(s)) == [s[0]] + toSeq(fromSeq(s[1..]));\n  }\n}\n\nlemma FromSeqToSeq<T>(list: LinkedList<T>)\n  ensures fromSeq(toSeq(list)) == list\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    FromSeqToSeq(t);\n}\n\nlemma NthCorrect<T>(list: LinkedList<T>, n: nat)\n  requires n < length(list)\n  ensures |toSeq(list)| > n\n  ensures toSeq(list)[n] == nth(list, n)\n{\n  match list\n  case Cons(h, t) =>\n    if n == 0 {\n      assert toSeq(list)[0] == h;\n    } else {\n      NthCorrect(t, n - 1);\n    }\n}\n\nlemma MapLength<T, U>(list: LinkedList<T>, f: T -> U)\n  ensures length(listMap(list, f)) == length(list)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    MapLength(t, f);\n}\n\nlemma FilterSubset<T>(list: LinkedList<T>, p: T -> bool)\n  ensures length(filter(list, p)) <= length(list)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    FilterSubset(t, p);\n    if p(h) {\n      assert length(filter(list, p)) == 1 + length(filter(t, p));\n    } else {\n      assert length(filter(list, p)) == length(filter(t, p));\n    }\n}\n\nlemma TakeDropConcat<T>(list: LinkedList<T>, n: nat)\n  ensures append(take(list, n), drop(list, n)) == list\n{\n  if n == 0 {\n    assert take(list, 0) == Nil;\n    assert drop(list, 0) == list;\n    AppendNil(list);\n  } else {\n    match list\n    case Nil =>\n    case Cons(h, t) =>\n      TakeDropConcat(t, n - 1);\n      calc == {\n        append(take(list, n), drop(list, n));\n        append(Cons(h, take(t, n - 1)), drop(t, n - 1));\n        Cons(h, append(take(t, n - 1), drop(t, n - 1)));\n        Cons(h, t);\n        list;\n      }\n  }\n}\n\nlemma RemoveDecreasesLength<T>(list: LinkedList<T>, x: T)\n  requires contains(list, x)\n  ensures length(remove(list, x)) == length(list) - 1\n{\n  match list\n  case Cons(h, t) =>\n    if h == x {\n      assert remove(list, x) == t;\n    } else {\n      assert contains(t, x);\n      RemoveDecreasesLength(t, x);\n    }\n}\n\nlemma InsertAtLength<T>(list: LinkedList<T>, x: T, pos: nat)\n  ensures length(insertAt(list, x, pos)) == length(list) + 1\n{\n  if pos == 0 {\n    assert insertAt(list, x, 0) == Cons(x, list);\n  } else {\n    match list\n    case Nil =>\n      assert insertAt(Nil, x, pos) == Cons(x, Nil);\n    case Cons(h, t) =>\n      InsertAtLength(t, x, pos - 1);\n  }\n}", "output": "ReverseReverseHelper(t, Cons(h, acc));"}, {"id": "example_ReverseReverseHelper_1", "type": "assert", "program": "// Linked list operations: insert, delete, reverse, cycle detection\n\ndatatype LinkedList<T> = Nil | Cons(head: T, tail: LinkedList<T>)\n\n// Length of linked list\nfunction {:spec} length<T>(list: LinkedList<T>): nat\n{\n  match list\n  case Nil => 0\n  case Cons(_, tail) => 1 + length(tail)\n}\n\n// Append two linked lists\nfunction {:spec} append<T>(l1: LinkedList<T>, l2: LinkedList<T>): LinkedList<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, append(t, l2))\n}\n\n// Reverse a linked list\nfunction {:spec} reverse<T>(list: LinkedList<T>): LinkedList<T>\n{\n  reverseHelper(list, Nil)\n}\n\nfunction reverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>): LinkedList<T>\n{\n  match list\n  case Nil => acc\n  case Cons(h, t) => reverseHelper(t, Cons(h, acc))\n}\n\n// Get nth element (0-indexed)\nfunction {:spec} nth<T>(list: LinkedList<T>, n: nat): T\n  requires n < length(list)\n{\n  match list\n  case Cons(h, t) => if n == 0 then h else nth(t, n - 1)\n}\n\n// Check if element exists in list\npredicate {:spec} contains<T(==)>(list: LinkedList<T>, x: T)\n{\n  match list\n  case Nil => false\n  case Cons(h, t) => h == x || contains(t, x)\n}\n\n// Remove first occurrence of element\nfunction {:spec} remove<T(==)>(list: LinkedList<T>, x: T): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => if h == x then t else Cons(h, remove(t, x))\n}\n\n// Insert at position\nfunction {:spec} insertAt<T>(list: LinkedList<T>, x: T, pos: nat): LinkedList<T>\n{\n  if pos == 0 then Cons(x, list)\n  else match list\n    case Nil => Cons(x, Nil)\n    case Cons(h, t) => Cons(h, insertAt(t, x, pos - 1))\n}\n\n// Convert to sequence\nfunction {:spec} toSeq<T>(list: LinkedList<T>): seq<T>\n{\n  match list\n  case Nil => []\n  case Cons(h, t) => [h] + toSeq(t)\n}\n\n// Convert from sequence\nfunction {:spec} fromSeq<T>(s: seq<T>): LinkedList<T>\n{\n  if |s| == 0 then Nil\n  else Cons(s[0], fromSeq(s[1..]))\n}\n\n// Map function over list\nfunction {:spec} listMap<T, U>(list: LinkedList<T>, f: T -> U): LinkedList<U>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => Cons(f(h), listMap(t, f))\n}\n\n// Filter list with predicate\nfunction {:spec} filter<T>(list: LinkedList<T>, p: T -> bool): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) =>\n    if p(h) then Cons(h, filter(t, p))\n    else filter(t, p)\n}\n\n// Take first n elements\nfunction {:spec} take<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n{\n  if n == 0 then Nil\n  else match list\n    case Nil => Nil\n    case Cons(h, t) => Cons(h, take(t, n - 1))\n}\n\n// Drop first n elements\nfunction {:spec} drop<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n  decreases list\n{\n  if n == 0 then list\n  else match list\n    case Nil => Nil\n    case Cons(_, t) => drop(t, n - 1)\n}\n\n// Check if list is palindrome\npredicate {:spec} isPalindrome<T(==)>(list: LinkedList<T>)\n{\n  toSeq(list) == toSeq(reverse(list))\n}\n\n// --- Lemmas for correctness ---\n\nlemma LengthAppend<T>(l1: LinkedList<T>, l2: LinkedList<T>)\n  ensures length(append(l1, l2)) == length(l1) + length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) =>\n    LengthAppend(t, l2);\n}\n\nlemma AppendNil<T>(list: LinkedList<T>)\n  ensures append(list, Nil) == list\n  ensures append(Nil, list) == list\n{\n  match list\n  case Nil =>\n  case Cons(_, t) =>\n    AppendNil(t);\n}\n\nlemma AppendAssociative<T>(l1: LinkedList<T>, l2: LinkedList<T>, l3: LinkedList<T>)\n  ensures append(append(l1, l2), l3) == append(l1, append(l2, l3))\n{\n  match l1\n  case Nil =>\n  case Cons(h, t) =>\n    AppendAssociative(t, l2, l3);\n}\n\nlemma ReverseLength<T>(list: LinkedList<T>)\n  ensures length(reverse(list)) == length(list)\n{\n  ReverseHelperLength(list, Nil);\n}\n\nlemma ReverseHelperLength<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures length(reverseHelper(list, acc)) == length(list) + length(acc)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    calc == {\n      length(reverseHelper(list, acc));\n      length(reverseHelper(t, Cons(h, acc)));\n      { ReverseHelperLength(t, Cons(h, acc)); }\n      length(t) + length(Cons(h, acc));\n      length(t) + 1 + length(acc);\n      length(list) + length(acc);\n    }\n}\n\nlemma ReverseReverse<T>(list: LinkedList<T>)\n  ensures reverse(reverse(list)) == list\n{\n  ReverseReverseHelper(list, Nil);\n}\n\nlemma ReverseReverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures reverseHelper(reverseHelper(list, acc), Nil) == reverseHelper(acc, list)\n{\n  match list\n  case Nil =>\n    \n/*[CODE HERE]*/\n  case Cons(h, t) =>\n    calc == {\n      reverseHelper(reverseHelper(Cons(h, t), acc), Nil);\n      reverseHelper(reverseHelper(t, Cons(h, acc)), Nil);\n      { ReverseReverseHelper(t, Cons(h, acc)); }\n      reverseHelper(Cons(h, acc), t);\n      reverseHelper(acc, Cons(h, t));\n    }\n}\n\nlemma ToSeqFromSeq<T>(s: seq<T>)\n  ensures toSeq(fromSeq(s)) == s\n{\n  if |s| == 0 {\n    assert fromSeq(s) == Nil;\n  } else {\n    ToSeqFromSeq(s[1..]);\n    assert toSeq(fromSeq(s)) == [s[0]] + toSeq(fromSeq(s[1..]));\n  }\n}\n\nlemma FromSeqToSeq<T>(list: LinkedList<T>)\n  ensures fromSeq(toSeq(list)) == list\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    FromSeqToSeq(t);\n}\n\nlemma NthCorrect<T>(list: LinkedList<T>, n: nat)\n  requires n < length(list)\n  ensures |toSeq(list)| > n\n  ensures toSeq(list)[n] == nth(list, n)\n{\n  match list\n  case Cons(h, t) =>\n    if n == 0 {\n      assert toSeq(list)[0] == h;\n    } else {\n      NthCorrect(t, n - 1);\n    }\n}\n\nlemma MapLength<T, U>(list: LinkedList<T>, f: T -> U)\n  ensures length(listMap(list, f)) == length(list)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    MapLength(t, f);\n}\n\nlemma FilterSubset<T>(list: LinkedList<T>, p: T -> bool)\n  ensures length(filter(list, p)) <= length(list)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    FilterSubset(t, p);\n    if p(h) {\n      assert length(filter(list, p)) == 1 + length(filter(t, p));\n    } else {\n      assert length(filter(list, p)) == length(filter(t, p));\n    }\n}\n\nlemma TakeDropConcat<T>(list: LinkedList<T>, n: nat)\n  ensures append(take(list, n), drop(list, n)) == list\n{\n  if n == 0 {\n    assert take(list, 0) == Nil;\n    assert drop(list, 0) == list;\n    AppendNil(list);\n  } else {\n    match list\n    case Nil =>\n    case Cons(h, t) =>\n      TakeDropConcat(t, n - 1);\n      calc == {\n        append(take(list, n), drop(list, n));\n        append(Cons(h, take(t, n - 1)), drop(t, n - 1));\n        Cons(h, append(take(t, n - 1), drop(t, n - 1)));\n        Cons(h, t);\n        list;\n      }\n  }\n}\n\nlemma RemoveDecreasesLength<T>(list: LinkedList<T>, x: T)\n  requires contains(list, x)\n  ensures length(remove(list, x)) == length(list) - 1\n{\n  match list\n  case Cons(h, t) =>\n    if h == x {\n      assert remove(list, x) == t;\n    } else {\n      assert contains(t, x);\n      RemoveDecreasesLength(t, x);\n    }\n}\n\nlemma InsertAtLength<T>(list: LinkedList<T>, x: T, pos: nat)\n  ensures length(insertAt(list, x, pos)) == length(list) + 1\n{\n  if pos == 0 {\n    assert insertAt(list, x, 0) == Cons(x, list);\n  } else {\n    match list\n    case Nil =>\n      assert insertAt(Nil, x, pos) == Cons(x, Nil);\n    case Cons(h, t) =>\n      InsertAtLength(t, x, pos - 1);\n  }\n}", "output": "assert reverseHelper(reverseHelper(Nil, acc), Nil) == reverseHelper(acc, Nil);"}, {"id": "example_ToSeqFromSeq_0", "type": "assert", "program": "// Linked list operations: insert, delete, reverse, cycle detection\n\ndatatype LinkedList<T> = Nil | Cons(head: T, tail: LinkedList<T>)\n\n// Length of linked list\nfunction {:spec} length<T>(list: LinkedList<T>): nat\n{\n  match list\n  case Nil => 0\n  case Cons(_, tail) => 1 + length(tail)\n}\n\n// Append two linked lists\nfunction {:spec} append<T>(l1: LinkedList<T>, l2: LinkedList<T>): LinkedList<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, append(t, l2))\n}\n\n// Reverse a linked list\nfunction {:spec} reverse<T>(list: LinkedList<T>): LinkedList<T>\n{\n  reverseHelper(list, Nil)\n}\n\nfunction reverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>): LinkedList<T>\n{\n  match list\n  case Nil => acc\n  case Cons(h, t) => reverseHelper(t, Cons(h, acc))\n}\n\n// Get nth element (0-indexed)\nfunction {:spec} nth<T>(list: LinkedList<T>, n: nat): T\n  requires n < length(list)\n{\n  match list\n  case Cons(h, t) => if n == 0 then h else nth(t, n - 1)\n}\n\n// Check if element exists in list\npredicate {:spec} contains<T(==)>(list: LinkedList<T>, x: T)\n{\n  match list\n  case Nil => false\n  case Cons(h, t) => h == x || contains(t, x)\n}\n\n// Remove first occurrence of element\nfunction {:spec} remove<T(==)>(list: LinkedList<T>, x: T): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => if h == x then t else Cons(h, remove(t, x))\n}\n\n// Insert at position\nfunction {:spec} insertAt<T>(list: LinkedList<T>, x: T, pos: nat): LinkedList<T>\n{\n  if pos == 0 then Cons(x, list)\n  else match list\n    case Nil => Cons(x, Nil)\n    case Cons(h, t) => Cons(h, insertAt(t, x, pos - 1))\n}\n\n// Convert to sequence\nfunction {:spec} toSeq<T>(list: LinkedList<T>): seq<T>\n{\n  match list\n  case Nil => []\n  case Cons(h, t) => [h] + toSeq(t)\n}\n\n// Convert from sequence\nfunction {:spec} fromSeq<T>(s: seq<T>): LinkedList<T>\n{\n  if |s| == 0 then Nil\n  else Cons(s[0], fromSeq(s[1..]))\n}\n\n// Map function over list\nfunction {:spec} listMap<T, U>(list: LinkedList<T>, f: T -> U): LinkedList<U>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => Cons(f(h), listMap(t, f))\n}\n\n// Filter list with predicate\nfunction {:spec} filter<T>(list: LinkedList<T>, p: T -> bool): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) =>\n    if p(h) then Cons(h, filter(t, p))\n    else filter(t, p)\n}\n\n// Take first n elements\nfunction {:spec} take<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n{\n  if n == 0 then Nil\n  else match list\n    case Nil => Nil\n    case Cons(h, t) => Cons(h, take(t, n - 1))\n}\n\n// Drop first n elements\nfunction {:spec} drop<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n  decreases list\n{\n  if n == 0 then list\n  else match list\n    case Nil => Nil\n    case Cons(_, t) => drop(t, n - 1)\n}\n\n// Check if list is palindrome\npredicate {:spec} isPalindrome<T(==)>(list: LinkedList<T>)\n{\n  toSeq(list) == toSeq(reverse(list))\n}\n\n// --- Lemmas for correctness ---\n\nlemma LengthAppend<T>(l1: LinkedList<T>, l2: LinkedList<T>)\n  ensures length(append(l1, l2)) == length(l1) + length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) =>\n    LengthAppend(t, l2);\n}\n\nlemma AppendNil<T>(list: LinkedList<T>)\n  ensures append(list, Nil) == list\n  ensures append(Nil, list) == list\n{\n  match list\n  case Nil =>\n  case Cons(_, t) =>\n    AppendNil(t);\n}\n\nlemma AppendAssociative<T>(l1: LinkedList<T>, l2: LinkedList<T>, l3: LinkedList<T>)\n  ensures append(append(l1, l2), l3) == append(l1, append(l2, l3))\n{\n  match l1\n  case Nil =>\n  case Cons(h, t) =>\n    AppendAssociative(t, l2, l3);\n}\n\nlemma ReverseLength<T>(list: LinkedList<T>)\n  ensures length(reverse(list)) == length(list)\n{\n  ReverseHelperLength(list, Nil);\n}\n\nlemma ReverseHelperLength<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures length(reverseHelper(list, acc)) == length(list) + length(acc)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    calc == {\n      length(reverseHelper(list, acc));\n      length(reverseHelper(t, Cons(h, acc)));\n      { ReverseHelperLength(t, Cons(h, acc)); }\n      length(t) + length(Cons(h, acc));\n      length(t) + 1 + length(acc);\n      length(list) + length(acc);\n    }\n}\n\nlemma ReverseReverse<T>(list: LinkedList<T>)\n  ensures reverse(reverse(list)) == list\n{\n  ReverseReverseHelper(list, Nil);\n}\n\nlemma ReverseReverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures reverseHelper(reverseHelper(list, acc), Nil) == reverseHelper(acc, list)\n{\n  match list\n  case Nil =>\n    assert reverseHelper(reverseHelper(Nil, acc), Nil) == reverseHelper(acc, Nil);\n  case Cons(h, t) =>\n    calc == {\n      reverseHelper(reverseHelper(Cons(h, t), acc), Nil);\n      reverseHelper(reverseHelper(t, Cons(h, acc)), Nil);\n      { ReverseReverseHelper(t, Cons(h, acc)); }\n      reverseHelper(Cons(h, acc), t);\n      reverseHelper(acc, Cons(h, t));\n    }\n}\n\nlemma ToSeqFromSeq<T>(s: seq<T>)\n  ensures toSeq(fromSeq(s)) == s\n{\n  if |s| == 0 {\n    assert fromSeq(s) == Nil;\n  } else {\n    ToSeqFromSeq(s[1..]);\n    \n/*[CODE HERE]*/\n  }\n}\n\nlemma FromSeqToSeq<T>(list: LinkedList<T>)\n  ensures fromSeq(toSeq(list)) == list\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    FromSeqToSeq(t);\n}\n\nlemma NthCorrect<T>(list: LinkedList<T>, n: nat)\n  requires n < length(list)\n  ensures |toSeq(list)| > n\n  ensures toSeq(list)[n] == nth(list, n)\n{\n  match list\n  case Cons(h, t) =>\n    if n == 0 {\n      assert toSeq(list)[0] == h;\n    } else {\n      NthCorrect(t, n - 1);\n    }\n}\n\nlemma MapLength<T, U>(list: LinkedList<T>, f: T -> U)\n  ensures length(listMap(list, f)) == length(list)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    MapLength(t, f);\n}\n\nlemma FilterSubset<T>(list: LinkedList<T>, p: T -> bool)\n  ensures length(filter(list, p)) <= length(list)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    FilterSubset(t, p);\n    if p(h) {\n      assert length(filter(list, p)) == 1 + length(filter(t, p));\n    } else {\n      assert length(filter(list, p)) == length(filter(t, p));\n    }\n}\n\nlemma TakeDropConcat<T>(list: LinkedList<T>, n: nat)\n  ensures append(take(list, n), drop(list, n)) == list\n{\n  if n == 0 {\n    assert take(list, 0) == Nil;\n    assert drop(list, 0) == list;\n    AppendNil(list);\n  } else {\n    match list\n    case Nil =>\n    case Cons(h, t) =>\n      TakeDropConcat(t, n - 1);\n      calc == {\n        append(take(list, n), drop(list, n));\n        append(Cons(h, take(t, n - 1)), drop(t, n - 1));\n        Cons(h, append(take(t, n - 1), drop(t, n - 1)));\n        Cons(h, t);\n        list;\n      }\n  }\n}\n\nlemma RemoveDecreasesLength<T>(list: LinkedList<T>, x: T)\n  requires contains(list, x)\n  ensures length(remove(list, x)) == length(list) - 1\n{\n  match list\n  case Cons(h, t) =>\n    if h == x {\n      assert remove(list, x) == t;\n    } else {\n      assert contains(t, x);\n      RemoveDecreasesLength(t, x);\n    }\n}\n\nlemma InsertAtLength<T>(list: LinkedList<T>, x: T, pos: nat)\n  ensures length(insertAt(list, x, pos)) == length(list) + 1\n{\n  if pos == 0 {\n    assert insertAt(list, x, 0) == Cons(x, list);\n  } else {\n    match list\n    case Nil =>\n      assert insertAt(Nil, x, pos) == Cons(x, Nil);\n    case Cons(h, t) =>\n      InsertAtLength(t, x, pos - 1);\n  }\n}", "output": "assert toSeq(fromSeq(s)) == [s[0]] + toSeq(fromSeq(s[1..]));"}, {"id": "example_ToSeqFromSeq_1", "type": "call", "program": "// Linked list operations: insert, delete, reverse, cycle detection\n\ndatatype LinkedList<T> = Nil | Cons(head: T, tail: LinkedList<T>)\n\n// Length of linked list\nfunction {:spec} length<T>(list: LinkedList<T>): nat\n{\n  match list\n  case Nil => 0\n  case Cons(_, tail) => 1 + length(tail)\n}\n\n// Append two linked lists\nfunction {:spec} append<T>(l1: LinkedList<T>, l2: LinkedList<T>): LinkedList<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, append(t, l2))\n}\n\n// Reverse a linked list\nfunction {:spec} reverse<T>(list: LinkedList<T>): LinkedList<T>\n{\n  reverseHelper(list, Nil)\n}\n\nfunction reverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>): LinkedList<T>\n{\n  match list\n  case Nil => acc\n  case Cons(h, t) => reverseHelper(t, Cons(h, acc))\n}\n\n// Get nth element (0-indexed)\nfunction {:spec} nth<T>(list: LinkedList<T>, n: nat): T\n  requires n < length(list)\n{\n  match list\n  case Cons(h, t) => if n == 0 then h else nth(t, n - 1)\n}\n\n// Check if element exists in list\npredicate {:spec} contains<T(==)>(list: LinkedList<T>, x: T)\n{\n  match list\n  case Nil => false\n  case Cons(h, t) => h == x || contains(t, x)\n}\n\n// Remove first occurrence of element\nfunction {:spec} remove<T(==)>(list: LinkedList<T>, x: T): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => if h == x then t else Cons(h, remove(t, x))\n}\n\n// Insert at position\nfunction {:spec} insertAt<T>(list: LinkedList<T>, x: T, pos: nat): LinkedList<T>\n{\n  if pos == 0 then Cons(x, list)\n  else match list\n    case Nil => Cons(x, Nil)\n    case Cons(h, t) => Cons(h, insertAt(t, x, pos - 1))\n}\n\n// Convert to sequence\nfunction {:spec} toSeq<T>(list: LinkedList<T>): seq<T>\n{\n  match list\n  case Nil => []\n  case Cons(h, t) => [h] + toSeq(t)\n}\n\n// Convert from sequence\nfunction {:spec} fromSeq<T>(s: seq<T>): LinkedList<T>\n{\n  if |s| == 0 then Nil\n  else Cons(s[0], fromSeq(s[1..]))\n}\n\n// Map function over list\nfunction {:spec} listMap<T, U>(list: LinkedList<T>, f: T -> U): LinkedList<U>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => Cons(f(h), listMap(t, f))\n}\n\n// Filter list with predicate\nfunction {:spec} filter<T>(list: LinkedList<T>, p: T -> bool): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) =>\n    if p(h) then Cons(h, filter(t, p))\n    else filter(t, p)\n}\n\n// Take first n elements\nfunction {:spec} take<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n{\n  if n == 0 then Nil\n  else match list\n    case Nil => Nil\n    case Cons(h, t) => Cons(h, take(t, n - 1))\n}\n\n// Drop first n elements\nfunction {:spec} drop<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n  decreases list\n{\n  if n == 0 then list\n  else match list\n    case Nil => Nil\n    case Cons(_, t) => drop(t, n - 1)\n}\n\n// Check if list is palindrome\npredicate {:spec} isPalindrome<T(==)>(list: LinkedList<T>)\n{\n  toSeq(list) == toSeq(reverse(list))\n}\n\n// --- Lemmas for correctness ---\n\nlemma LengthAppend<T>(l1: LinkedList<T>, l2: LinkedList<T>)\n  ensures length(append(l1, l2)) == length(l1) + length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) =>\n    LengthAppend(t, l2);\n}\n\nlemma AppendNil<T>(list: LinkedList<T>)\n  ensures append(list, Nil) == list\n  ensures append(Nil, list) == list\n{\n  match list\n  case Nil =>\n  case Cons(_, t) =>\n    AppendNil(t);\n}\n\nlemma AppendAssociative<T>(l1: LinkedList<T>, l2: LinkedList<T>, l3: LinkedList<T>)\n  ensures append(append(l1, l2), l3) == append(l1, append(l2, l3))\n{\n  match l1\n  case Nil =>\n  case Cons(h, t) =>\n    AppendAssociative(t, l2, l3);\n}\n\nlemma ReverseLength<T>(list: LinkedList<T>)\n  ensures length(reverse(list)) == length(list)\n{\n  ReverseHelperLength(list, Nil);\n}\n\nlemma ReverseHelperLength<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures length(reverseHelper(list, acc)) == length(list) + length(acc)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    calc == {\n      length(reverseHelper(list, acc));\n      length(reverseHelper(t, Cons(h, acc)));\n      { ReverseHelperLength(t, Cons(h, acc)); }\n      length(t) + length(Cons(h, acc));\n      length(t) + 1 + length(acc);\n      length(list) + length(acc);\n    }\n}\n\nlemma ReverseReverse<T>(list: LinkedList<T>)\n  ensures reverse(reverse(list)) == list\n{\n  ReverseReverseHelper(list, Nil);\n}\n\nlemma ReverseReverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures reverseHelper(reverseHelper(list, acc), Nil) == reverseHelper(acc, list)\n{\n  match list\n  case Nil =>\n    assert reverseHelper(reverseHelper(Nil, acc), Nil) == reverseHelper(acc, Nil);\n  case Cons(h, t) =>\n    calc == {\n      reverseHelper(reverseHelper(Cons(h, t), acc), Nil);\n      reverseHelper(reverseHelper(t, Cons(h, acc)), Nil);\n      { ReverseReverseHelper(t, Cons(h, acc)); }\n      reverseHelper(Cons(h, acc), t);\n      reverseHelper(acc, Cons(h, t));\n    }\n}\n\nlemma ToSeqFromSeq<T>(s: seq<T>)\n  ensures toSeq(fromSeq(s)) == s\n{\n  if |s| == 0 {\n    assert fromSeq(s) == Nil;\n  } else {\n    \n/*[CODE HERE]*/\n    assert toSeq(fromSeq(s)) == [s[0]] + toSeq(fromSeq(s[1..]));\n  }\n}\n\nlemma FromSeqToSeq<T>(list: LinkedList<T>)\n  ensures fromSeq(toSeq(list)) == list\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    FromSeqToSeq(t);\n}\n\nlemma NthCorrect<T>(list: LinkedList<T>, n: nat)\n  requires n < length(list)\n  ensures |toSeq(list)| > n\n  ensures toSeq(list)[n] == nth(list, n)\n{\n  match list\n  case Cons(h, t) =>\n    if n == 0 {\n      assert toSeq(list)[0] == h;\n    } else {\n      NthCorrect(t, n - 1);\n    }\n}\n\nlemma MapLength<T, U>(list: LinkedList<T>, f: T -> U)\n  ensures length(listMap(list, f)) == length(list)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    MapLength(t, f);\n}\n\nlemma FilterSubset<T>(list: LinkedList<T>, p: T -> bool)\n  ensures length(filter(list, p)) <= length(list)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    FilterSubset(t, p);\n    if p(h) {\n      assert length(filter(list, p)) == 1 + length(filter(t, p));\n    } else {\n      assert length(filter(list, p)) == length(filter(t, p));\n    }\n}\n\nlemma TakeDropConcat<T>(list: LinkedList<T>, n: nat)\n  ensures append(take(list, n), drop(list, n)) == list\n{\n  if n == 0 {\n    assert take(list, 0) == Nil;\n    assert drop(list, 0) == list;\n    AppendNil(list);\n  } else {\n    match list\n    case Nil =>\n    case Cons(h, t) =>\n      TakeDropConcat(t, n - 1);\n      calc == {\n        append(take(list, n), drop(list, n));\n        append(Cons(h, take(t, n - 1)), drop(t, n - 1));\n        Cons(h, append(take(t, n - 1), drop(t, n - 1)));\n        Cons(h, t);\n        list;\n      }\n  }\n}\n\nlemma RemoveDecreasesLength<T>(list: LinkedList<T>, x: T)\n  requires contains(list, x)\n  ensures length(remove(list, x)) == length(list) - 1\n{\n  match list\n  case Cons(h, t) =>\n    if h == x {\n      assert remove(list, x) == t;\n    } else {\n      assert contains(t, x);\n      RemoveDecreasesLength(t, x);\n    }\n}\n\nlemma InsertAtLength<T>(list: LinkedList<T>, x: T, pos: nat)\n  ensures length(insertAt(list, x, pos)) == length(list) + 1\n{\n  if pos == 0 {\n    assert insertAt(list, x, 0) == Cons(x, list);\n  } else {\n    match list\n    case Nil =>\n      assert insertAt(Nil, x, pos) == Cons(x, Nil);\n    case Cons(h, t) =>\n      InsertAtLength(t, x, pos - 1);\n  }\n}", "output": "ToSeqFromSeq(s[1..]);"}, {"id": "example_ToSeqFromSeq_2", "type": "assert", "program": "// Linked list operations: insert, delete, reverse, cycle detection\n\ndatatype LinkedList<T> = Nil | Cons(head: T, tail: LinkedList<T>)\n\n// Length of linked list\nfunction {:spec} length<T>(list: LinkedList<T>): nat\n{\n  match list\n  case Nil => 0\n  case Cons(_, tail) => 1 + length(tail)\n}\n\n// Append two linked lists\nfunction {:spec} append<T>(l1: LinkedList<T>, l2: LinkedList<T>): LinkedList<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, append(t, l2))\n}\n\n// Reverse a linked list\nfunction {:spec} reverse<T>(list: LinkedList<T>): LinkedList<T>\n{\n  reverseHelper(list, Nil)\n}\n\nfunction reverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>): LinkedList<T>\n{\n  match list\n  case Nil => acc\n  case Cons(h, t) => reverseHelper(t, Cons(h, acc))\n}\n\n// Get nth element (0-indexed)\nfunction {:spec} nth<T>(list: LinkedList<T>, n: nat): T\n  requires n < length(list)\n{\n  match list\n  case Cons(h, t) => if n == 0 then h else nth(t, n - 1)\n}\n\n// Check if element exists in list\npredicate {:spec} contains<T(==)>(list: LinkedList<T>, x: T)\n{\n  match list\n  case Nil => false\n  case Cons(h, t) => h == x || contains(t, x)\n}\n\n// Remove first occurrence of element\nfunction {:spec} remove<T(==)>(list: LinkedList<T>, x: T): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => if h == x then t else Cons(h, remove(t, x))\n}\n\n// Insert at position\nfunction {:spec} insertAt<T>(list: LinkedList<T>, x: T, pos: nat): LinkedList<T>\n{\n  if pos == 0 then Cons(x, list)\n  else match list\n    case Nil => Cons(x, Nil)\n    case Cons(h, t) => Cons(h, insertAt(t, x, pos - 1))\n}\n\n// Convert to sequence\nfunction {:spec} toSeq<T>(list: LinkedList<T>): seq<T>\n{\n  match list\n  case Nil => []\n  case Cons(h, t) => [h] + toSeq(t)\n}\n\n// Convert from sequence\nfunction {:spec} fromSeq<T>(s: seq<T>): LinkedList<T>\n{\n  if |s| == 0 then Nil\n  else Cons(s[0], fromSeq(s[1..]))\n}\n\n// Map function over list\nfunction {:spec} listMap<T, U>(list: LinkedList<T>, f: T -> U): LinkedList<U>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => Cons(f(h), listMap(t, f))\n}\n\n// Filter list with predicate\nfunction {:spec} filter<T>(list: LinkedList<T>, p: T -> bool): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) =>\n    if p(h) then Cons(h, filter(t, p))\n    else filter(t, p)\n}\n\n// Take first n elements\nfunction {:spec} take<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n{\n  if n == 0 then Nil\n  else match list\n    case Nil => Nil\n    case Cons(h, t) => Cons(h, take(t, n - 1))\n}\n\n// Drop first n elements\nfunction {:spec} drop<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n  decreases list\n{\n  if n == 0 then list\n  else match list\n    case Nil => Nil\n    case Cons(_, t) => drop(t, n - 1)\n}\n\n// Check if list is palindrome\npredicate {:spec} isPalindrome<T(==)>(list: LinkedList<T>)\n{\n  toSeq(list) == toSeq(reverse(list))\n}\n\n// --- Lemmas for correctness ---\n\nlemma LengthAppend<T>(l1: LinkedList<T>, l2: LinkedList<T>)\n  ensures length(append(l1, l2)) == length(l1) + length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) =>\n    LengthAppend(t, l2);\n}\n\nlemma AppendNil<T>(list: LinkedList<T>)\n  ensures append(list, Nil) == list\n  ensures append(Nil, list) == list\n{\n  match list\n  case Nil =>\n  case Cons(_, t) =>\n    AppendNil(t);\n}\n\nlemma AppendAssociative<T>(l1: LinkedList<T>, l2: LinkedList<T>, l3: LinkedList<T>)\n  ensures append(append(l1, l2), l3) == append(l1, append(l2, l3))\n{\n  match l1\n  case Nil =>\n  case Cons(h, t) =>\n    AppendAssociative(t, l2, l3);\n}\n\nlemma ReverseLength<T>(list: LinkedList<T>)\n  ensures length(reverse(list)) == length(list)\n{\n  ReverseHelperLength(list, Nil);\n}\n\nlemma ReverseHelperLength<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures length(reverseHelper(list, acc)) == length(list) + length(acc)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    calc == {\n      length(reverseHelper(list, acc));\n      length(reverseHelper(t, Cons(h, acc)));\n      { ReverseHelperLength(t, Cons(h, acc)); }\n      length(t) + length(Cons(h, acc));\n      length(t) + 1 + length(acc);\n      length(list) + length(acc);\n    }\n}\n\nlemma ReverseReverse<T>(list: LinkedList<T>)\n  ensures reverse(reverse(list)) == list\n{\n  ReverseReverseHelper(list, Nil);\n}\n\nlemma ReverseReverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures reverseHelper(reverseHelper(list, acc), Nil) == reverseHelper(acc, list)\n{\n  match list\n  case Nil =>\n    assert reverseHelper(reverseHelper(Nil, acc), Nil) == reverseHelper(acc, Nil);\n  case Cons(h, t) =>\n    calc == {\n      reverseHelper(reverseHelper(Cons(h, t), acc), Nil);\n      reverseHelper(reverseHelper(t, Cons(h, acc)), Nil);\n      { ReverseReverseHelper(t, Cons(h, acc)); }\n      reverseHelper(Cons(h, acc), t);\n      reverseHelper(acc, Cons(h, t));\n    }\n}\n\nlemma ToSeqFromSeq<T>(s: seq<T>)\n  ensures toSeq(fromSeq(s)) == s\n{\n  if |s| == 0 {\n    \n/*[CODE HERE]*/\n  } else {\n    ToSeqFromSeq(s[1..]);\n    assert toSeq(fromSeq(s)) == [s[0]] + toSeq(fromSeq(s[1..]));\n  }\n}\n\nlemma FromSeqToSeq<T>(list: LinkedList<T>)\n  ensures fromSeq(toSeq(list)) == list\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    FromSeqToSeq(t);\n}\n\nlemma NthCorrect<T>(list: LinkedList<T>, n: nat)\n  requires n < length(list)\n  ensures |toSeq(list)| > n\n  ensures toSeq(list)[n] == nth(list, n)\n{\n  match list\n  case Cons(h, t) =>\n    if n == 0 {\n      assert toSeq(list)[0] == h;\n    } else {\n      NthCorrect(t, n - 1);\n    }\n}\n\nlemma MapLength<T, U>(list: LinkedList<T>, f: T -> U)\n  ensures length(listMap(list, f)) == length(list)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    MapLength(t, f);\n}\n\nlemma FilterSubset<T>(list: LinkedList<T>, p: T -> bool)\n  ensures length(filter(list, p)) <= length(list)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    FilterSubset(t, p);\n    if p(h) {\n      assert length(filter(list, p)) == 1 + length(filter(t, p));\n    } else {\n      assert length(filter(list, p)) == length(filter(t, p));\n    }\n}\n\nlemma TakeDropConcat<T>(list: LinkedList<T>, n: nat)\n  ensures append(take(list, n), drop(list, n)) == list\n{\n  if n == 0 {\n    assert take(list, 0) == Nil;\n    assert drop(list, 0) == list;\n    AppendNil(list);\n  } else {\n    match list\n    case Nil =>\n    case Cons(h, t) =>\n      TakeDropConcat(t, n - 1);\n      calc == {\n        append(take(list, n), drop(list, n));\n        append(Cons(h, take(t, n - 1)), drop(t, n - 1));\n        Cons(h, append(take(t, n - 1), drop(t, n - 1)));\n        Cons(h, t);\n        list;\n      }\n  }\n}\n\nlemma RemoveDecreasesLength<T>(list: LinkedList<T>, x: T)\n  requires contains(list, x)\n  ensures length(remove(list, x)) == length(list) - 1\n{\n  match list\n  case Cons(h, t) =>\n    if h == x {\n      assert remove(list, x) == t;\n    } else {\n      assert contains(t, x);\n      RemoveDecreasesLength(t, x);\n    }\n}\n\nlemma InsertAtLength<T>(list: LinkedList<T>, x: T, pos: nat)\n  ensures length(insertAt(list, x, pos)) == length(list) + 1\n{\n  if pos == 0 {\n    assert insertAt(list, x, 0) == Cons(x, list);\n  } else {\n    match list\n    case Nil =>\n      assert insertAt(Nil, x, pos) == Cons(x, Nil);\n    case Cons(h, t) =>\n      InsertAtLength(t, x, pos - 1);\n  }\n}", "output": "assert fromSeq(s) == Nil;"}, {"id": "example_FromSeqToSeq_0", "type": "call", "program": "// Linked list operations: insert, delete, reverse, cycle detection\n\ndatatype LinkedList<T> = Nil | Cons(head: T, tail: LinkedList<T>)\n\n// Length of linked list\nfunction {:spec} length<T>(list: LinkedList<T>): nat\n{\n  match list\n  case Nil => 0\n  case Cons(_, tail) => 1 + length(tail)\n}\n\n// Append two linked lists\nfunction {:spec} append<T>(l1: LinkedList<T>, l2: LinkedList<T>): LinkedList<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, append(t, l2))\n}\n\n// Reverse a linked list\nfunction {:spec} reverse<T>(list: LinkedList<T>): LinkedList<T>\n{\n  reverseHelper(list, Nil)\n}\n\nfunction reverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>): LinkedList<T>\n{\n  match list\n  case Nil => acc\n  case Cons(h, t) => reverseHelper(t, Cons(h, acc))\n}\n\n// Get nth element (0-indexed)\nfunction {:spec} nth<T>(list: LinkedList<T>, n: nat): T\n  requires n < length(list)\n{\n  match list\n  case Cons(h, t) => if n == 0 then h else nth(t, n - 1)\n}\n\n// Check if element exists in list\npredicate {:spec} contains<T(==)>(list: LinkedList<T>, x: T)\n{\n  match list\n  case Nil => false\n  case Cons(h, t) => h == x || contains(t, x)\n}\n\n// Remove first occurrence of element\nfunction {:spec} remove<T(==)>(list: LinkedList<T>, x: T): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => if h == x then t else Cons(h, remove(t, x))\n}\n\n// Insert at position\nfunction {:spec} insertAt<T>(list: LinkedList<T>, x: T, pos: nat): LinkedList<T>\n{\n  if pos == 0 then Cons(x, list)\n  else match list\n    case Nil => Cons(x, Nil)\n    case Cons(h, t) => Cons(h, insertAt(t, x, pos - 1))\n}\n\n// Convert to sequence\nfunction {:spec} toSeq<T>(list: LinkedList<T>): seq<T>\n{\n  match list\n  case Nil => []\n  case Cons(h, t) => [h] + toSeq(t)\n}\n\n// Convert from sequence\nfunction {:spec} fromSeq<T>(s: seq<T>): LinkedList<T>\n{\n  if |s| == 0 then Nil\n  else Cons(s[0], fromSeq(s[1..]))\n}\n\n// Map function over list\nfunction {:spec} listMap<T, U>(list: LinkedList<T>, f: T -> U): LinkedList<U>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => Cons(f(h), listMap(t, f))\n}\n\n// Filter list with predicate\nfunction {:spec} filter<T>(list: LinkedList<T>, p: T -> bool): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) =>\n    if p(h) then Cons(h, filter(t, p))\n    else filter(t, p)\n}\n\n// Take first n elements\nfunction {:spec} take<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n{\n  if n == 0 then Nil\n  else match list\n    case Nil => Nil\n    case Cons(h, t) => Cons(h, take(t, n - 1))\n}\n\n// Drop first n elements\nfunction {:spec} drop<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n  decreases list\n{\n  if n == 0 then list\n  else match list\n    case Nil => Nil\n    case Cons(_, t) => drop(t, n - 1)\n}\n\n// Check if list is palindrome\npredicate {:spec} isPalindrome<T(==)>(list: LinkedList<T>)\n{\n  toSeq(list) == toSeq(reverse(list))\n}\n\n// --- Lemmas for correctness ---\n\nlemma LengthAppend<T>(l1: LinkedList<T>, l2: LinkedList<T>)\n  ensures length(append(l1, l2)) == length(l1) + length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) =>\n    LengthAppend(t, l2);\n}\n\nlemma AppendNil<T>(list: LinkedList<T>)\n  ensures append(list, Nil) == list\n  ensures append(Nil, list) == list\n{\n  match list\n  case Nil =>\n  case Cons(_, t) =>\n    AppendNil(t);\n}\n\nlemma AppendAssociative<T>(l1: LinkedList<T>, l2: LinkedList<T>, l3: LinkedList<T>)\n  ensures append(append(l1, l2), l3) == append(l1, append(l2, l3))\n{\n  match l1\n  case Nil =>\n  case Cons(h, t) =>\n    AppendAssociative(t, l2, l3);\n}\n\nlemma ReverseLength<T>(list: LinkedList<T>)\n  ensures length(reverse(list)) == length(list)\n{\n  ReverseHelperLength(list, Nil);\n}\n\nlemma ReverseHelperLength<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures length(reverseHelper(list, acc)) == length(list) + length(acc)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    calc == {\n      length(reverseHelper(list, acc));\n      length(reverseHelper(t, Cons(h, acc)));\n      { ReverseHelperLength(t, Cons(h, acc)); }\n      length(t) + length(Cons(h, acc));\n      length(t) + 1 + length(acc);\n      length(list) + length(acc);\n    }\n}\n\nlemma ReverseReverse<T>(list: LinkedList<T>)\n  ensures reverse(reverse(list)) == list\n{\n  ReverseReverseHelper(list, Nil);\n}\n\nlemma ReverseReverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures reverseHelper(reverseHelper(list, acc), Nil) == reverseHelper(acc, list)\n{\n  match list\n  case Nil =>\n    assert reverseHelper(reverseHelper(Nil, acc), Nil) == reverseHelper(acc, Nil);\n  case Cons(h, t) =>\n    calc == {\n      reverseHelper(reverseHelper(Cons(h, t), acc), Nil);\n      reverseHelper(reverseHelper(t, Cons(h, acc)), Nil);\n      { ReverseReverseHelper(t, Cons(h, acc)); }\n      reverseHelper(Cons(h, acc), t);\n      reverseHelper(acc, Cons(h, t));\n    }\n}\n\nlemma ToSeqFromSeq<T>(s: seq<T>)\n  ensures toSeq(fromSeq(s)) == s\n{\n  if |s| == 0 {\n    assert fromSeq(s) == Nil;\n  } else {\n    ToSeqFromSeq(s[1..]);\n    assert toSeq(fromSeq(s)) == [s[0]] + toSeq(fromSeq(s[1..]));\n  }\n}\n\nlemma FromSeqToSeq<T>(list: LinkedList<T>)\n  ensures fromSeq(toSeq(list)) == list\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    \n/*[CODE HERE]*/\n}\n\nlemma NthCorrect<T>(list: LinkedList<T>, n: nat)\n  requires n < length(list)\n  ensures |toSeq(list)| > n\n  ensures toSeq(list)[n] == nth(list, n)\n{\n  match list\n  case Cons(h, t) =>\n    if n == 0 {\n      assert toSeq(list)[0] == h;\n    } else {\n      NthCorrect(t, n - 1);\n    }\n}\n\nlemma MapLength<T, U>(list: LinkedList<T>, f: T -> U)\n  ensures length(listMap(list, f)) == length(list)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    MapLength(t, f);\n}\n\nlemma FilterSubset<T>(list: LinkedList<T>, p: T -> bool)\n  ensures length(filter(list, p)) <= length(list)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    FilterSubset(t, p);\n    if p(h) {\n      assert length(filter(list, p)) == 1 + length(filter(t, p));\n    } else {\n      assert length(filter(list, p)) == length(filter(t, p));\n    }\n}\n\nlemma TakeDropConcat<T>(list: LinkedList<T>, n: nat)\n  ensures append(take(list, n), drop(list, n)) == list\n{\n  if n == 0 {\n    assert take(list, 0) == Nil;\n    assert drop(list, 0) == list;\n    AppendNil(list);\n  } else {\n    match list\n    case Nil =>\n    case Cons(h, t) =>\n      TakeDropConcat(t, n - 1);\n      calc == {\n        append(take(list, n), drop(list, n));\n        append(Cons(h, take(t, n - 1)), drop(t, n - 1));\n        Cons(h, append(take(t, n - 1), drop(t, n - 1)));\n        Cons(h, t);\n        list;\n      }\n  }\n}\n\nlemma RemoveDecreasesLength<T>(list: LinkedList<T>, x: T)\n  requires contains(list, x)\n  ensures length(remove(list, x)) == length(list) - 1\n{\n  match list\n  case Cons(h, t) =>\n    if h == x {\n      assert remove(list, x) == t;\n    } else {\n      assert contains(t, x);\n      RemoveDecreasesLength(t, x);\n    }\n}\n\nlemma InsertAtLength<T>(list: LinkedList<T>, x: T, pos: nat)\n  ensures length(insertAt(list, x, pos)) == length(list) + 1\n{\n  if pos == 0 {\n    assert insertAt(list, x, 0) == Cons(x, list);\n  } else {\n    match list\n    case Nil =>\n      assert insertAt(Nil, x, pos) == Cons(x, Nil);\n    case Cons(h, t) =>\n      InsertAtLength(t, x, pos - 1);\n  }\n}", "output": "FromSeqToSeq(t);"}, {"id": "example_NthCorrect_0", "type": "call", "program": "// Linked list operations: insert, delete, reverse, cycle detection\n\ndatatype LinkedList<T> = Nil | Cons(head: T, tail: LinkedList<T>)\n\n// Length of linked list\nfunction {:spec} length<T>(list: LinkedList<T>): nat\n{\n  match list\n  case Nil => 0\n  case Cons(_, tail) => 1 + length(tail)\n}\n\n// Append two linked lists\nfunction {:spec} append<T>(l1: LinkedList<T>, l2: LinkedList<T>): LinkedList<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, append(t, l2))\n}\n\n// Reverse a linked list\nfunction {:spec} reverse<T>(list: LinkedList<T>): LinkedList<T>\n{\n  reverseHelper(list, Nil)\n}\n\nfunction reverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>): LinkedList<T>\n{\n  match list\n  case Nil => acc\n  case Cons(h, t) => reverseHelper(t, Cons(h, acc))\n}\n\n// Get nth element (0-indexed)\nfunction {:spec} nth<T>(list: LinkedList<T>, n: nat): T\n  requires n < length(list)\n{\n  match list\n  case Cons(h, t) => if n == 0 then h else nth(t, n - 1)\n}\n\n// Check if element exists in list\npredicate {:spec} contains<T(==)>(list: LinkedList<T>, x: T)\n{\n  match list\n  case Nil => false\n  case Cons(h, t) => h == x || contains(t, x)\n}\n\n// Remove first occurrence of element\nfunction {:spec} remove<T(==)>(list: LinkedList<T>, x: T): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => if h == x then t else Cons(h, remove(t, x))\n}\n\n// Insert at position\nfunction {:spec} insertAt<T>(list: LinkedList<T>, x: T, pos: nat): LinkedList<T>\n{\n  if pos == 0 then Cons(x, list)\n  else match list\n    case Nil => Cons(x, Nil)\n    case Cons(h, t) => Cons(h, insertAt(t, x, pos - 1))\n}\n\n// Convert to sequence\nfunction {:spec} toSeq<T>(list: LinkedList<T>): seq<T>\n{\n  match list\n  case Nil => []\n  case Cons(h, t) => [h] + toSeq(t)\n}\n\n// Convert from sequence\nfunction {:spec} fromSeq<T>(s: seq<T>): LinkedList<T>\n{\n  if |s| == 0 then Nil\n  else Cons(s[0], fromSeq(s[1..]))\n}\n\n// Map function over list\nfunction {:spec} listMap<T, U>(list: LinkedList<T>, f: T -> U): LinkedList<U>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => Cons(f(h), listMap(t, f))\n}\n\n// Filter list with predicate\nfunction {:spec} filter<T>(list: LinkedList<T>, p: T -> bool): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) =>\n    if p(h) then Cons(h, filter(t, p))\n    else filter(t, p)\n}\n\n// Take first n elements\nfunction {:spec} take<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n{\n  if n == 0 then Nil\n  else match list\n    case Nil => Nil\n    case Cons(h, t) => Cons(h, take(t, n - 1))\n}\n\n// Drop first n elements\nfunction {:spec} drop<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n  decreases list\n{\n  if n == 0 then list\n  else match list\n    case Nil => Nil\n    case Cons(_, t) => drop(t, n - 1)\n}\n\n// Check if list is palindrome\npredicate {:spec} isPalindrome<T(==)>(list: LinkedList<T>)\n{\n  toSeq(list) == toSeq(reverse(list))\n}\n\n// --- Lemmas for correctness ---\n\nlemma LengthAppend<T>(l1: LinkedList<T>, l2: LinkedList<T>)\n  ensures length(append(l1, l2)) == length(l1) + length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) =>\n    LengthAppend(t, l2);\n}\n\nlemma AppendNil<T>(list: LinkedList<T>)\n  ensures append(list, Nil) == list\n  ensures append(Nil, list) == list\n{\n  match list\n  case Nil =>\n  case Cons(_, t) =>\n    AppendNil(t);\n}\n\nlemma AppendAssociative<T>(l1: LinkedList<T>, l2: LinkedList<T>, l3: LinkedList<T>)\n  ensures append(append(l1, l2), l3) == append(l1, append(l2, l3))\n{\n  match l1\n  case Nil =>\n  case Cons(h, t) =>\n    AppendAssociative(t, l2, l3);\n}\n\nlemma ReverseLength<T>(list: LinkedList<T>)\n  ensures length(reverse(list)) == length(list)\n{\n  ReverseHelperLength(list, Nil);\n}\n\nlemma ReverseHelperLength<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures length(reverseHelper(list, acc)) == length(list) + length(acc)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    calc == {\n      length(reverseHelper(list, acc));\n      length(reverseHelper(t, Cons(h, acc)));\n      { ReverseHelperLength(t, Cons(h, acc)); }\n      length(t) + length(Cons(h, acc));\n      length(t) + 1 + length(acc);\n      length(list) + length(acc);\n    }\n}\n\nlemma ReverseReverse<T>(list: LinkedList<T>)\n  ensures reverse(reverse(list)) == list\n{\n  ReverseReverseHelper(list, Nil);\n}\n\nlemma ReverseReverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures reverseHelper(reverseHelper(list, acc), Nil) == reverseHelper(acc, list)\n{\n  match list\n  case Nil =>\n    assert reverseHelper(reverseHelper(Nil, acc), Nil) == reverseHelper(acc, Nil);\n  case Cons(h, t) =>\n    calc == {\n      reverseHelper(reverseHelper(Cons(h, t), acc), Nil);\n      reverseHelper(reverseHelper(t, Cons(h, acc)), Nil);\n      { ReverseReverseHelper(t, Cons(h, acc)); }\n      reverseHelper(Cons(h, acc), t);\n      reverseHelper(acc, Cons(h, t));\n    }\n}\n\nlemma ToSeqFromSeq<T>(s: seq<T>)\n  ensures toSeq(fromSeq(s)) == s\n{\n  if |s| == 0 {\n    assert fromSeq(s) == Nil;\n  } else {\n    ToSeqFromSeq(s[1..]);\n    assert toSeq(fromSeq(s)) == [s[0]] + toSeq(fromSeq(s[1..]));\n  }\n}\n\nlemma FromSeqToSeq<T>(list: LinkedList<T>)\n  ensures fromSeq(toSeq(list)) == list\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    FromSeqToSeq(t);\n}\n\nlemma NthCorrect<T>(list: LinkedList<T>, n: nat)\n  requires n < length(list)\n  ensures |toSeq(list)| > n\n  ensures toSeq(list)[n] == nth(list, n)\n{\n  match list\n  case Cons(h, t) =>\n    if n == 0 {\n      assert toSeq(list)[0] == h;\n    } else {\n      \n/*[CODE HERE]*/\n    }\n}\n\nlemma MapLength<T, U>(list: LinkedList<T>, f: T -> U)\n  ensures length(listMap(list, f)) == length(list)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    MapLength(t, f);\n}\n\nlemma FilterSubset<T>(list: LinkedList<T>, p: T -> bool)\n  ensures length(filter(list, p)) <= length(list)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    FilterSubset(t, p);\n    if p(h) {\n      assert length(filter(list, p)) == 1 + length(filter(t, p));\n    } else {\n      assert length(filter(list, p)) == length(filter(t, p));\n    }\n}\n\nlemma TakeDropConcat<T>(list: LinkedList<T>, n: nat)\n  ensures append(take(list, n), drop(list, n)) == list\n{\n  if n == 0 {\n    assert take(list, 0) == Nil;\n    assert drop(list, 0) == list;\n    AppendNil(list);\n  } else {\n    match list\n    case Nil =>\n    case Cons(h, t) =>\n      TakeDropConcat(t, n - 1);\n      calc == {\n        append(take(list, n), drop(list, n));\n        append(Cons(h, take(t, n - 1)), drop(t, n - 1));\n        Cons(h, append(take(t, n - 1), drop(t, n - 1)));\n        Cons(h, t);\n        list;\n      }\n  }\n}\n\nlemma RemoveDecreasesLength<T>(list: LinkedList<T>, x: T)\n  requires contains(list, x)\n  ensures length(remove(list, x)) == length(list) - 1\n{\n  match list\n  case Cons(h, t) =>\n    if h == x {\n      assert remove(list, x) == t;\n    } else {\n      assert contains(t, x);\n      RemoveDecreasesLength(t, x);\n    }\n}\n\nlemma InsertAtLength<T>(list: LinkedList<T>, x: T, pos: nat)\n  ensures length(insertAt(list, x, pos)) == length(list) + 1\n{\n  if pos == 0 {\n    assert insertAt(list, x, 0) == Cons(x, list);\n  } else {\n    match list\n    case Nil =>\n      assert insertAt(Nil, x, pos) == Cons(x, Nil);\n    case Cons(h, t) =>\n      InsertAtLength(t, x, pos - 1);\n  }\n}", "output": "NthCorrect(t, n - 1);"}, {"id": "example_NthCorrect_1", "type": "assert", "program": "// Linked list operations: insert, delete, reverse, cycle detection\n\ndatatype LinkedList<T> = Nil | Cons(head: T, tail: LinkedList<T>)\n\n// Length of linked list\nfunction {:spec} length<T>(list: LinkedList<T>): nat\n{\n  match list\n  case Nil => 0\n  case Cons(_, tail) => 1 + length(tail)\n}\n\n// Append two linked lists\nfunction {:spec} append<T>(l1: LinkedList<T>, l2: LinkedList<T>): LinkedList<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, append(t, l2))\n}\n\n// Reverse a linked list\nfunction {:spec} reverse<T>(list: LinkedList<T>): LinkedList<T>\n{\n  reverseHelper(list, Nil)\n}\n\nfunction reverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>): LinkedList<T>\n{\n  match list\n  case Nil => acc\n  case Cons(h, t) => reverseHelper(t, Cons(h, acc))\n}\n\n// Get nth element (0-indexed)\nfunction {:spec} nth<T>(list: LinkedList<T>, n: nat): T\n  requires n < length(list)\n{\n  match list\n  case Cons(h, t) => if n == 0 then h else nth(t, n - 1)\n}\n\n// Check if element exists in list\npredicate {:spec} contains<T(==)>(list: LinkedList<T>, x: T)\n{\n  match list\n  case Nil => false\n  case Cons(h, t) => h == x || contains(t, x)\n}\n\n// Remove first occurrence of element\nfunction {:spec} remove<T(==)>(list: LinkedList<T>, x: T): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => if h == x then t else Cons(h, remove(t, x))\n}\n\n// Insert at position\nfunction {:spec} insertAt<T>(list: LinkedList<T>, x: T, pos: nat): LinkedList<T>\n{\n  if pos == 0 then Cons(x, list)\n  else match list\n    case Nil => Cons(x, Nil)\n    case Cons(h, t) => Cons(h, insertAt(t, x, pos - 1))\n}\n\n// Convert to sequence\nfunction {:spec} toSeq<T>(list: LinkedList<T>): seq<T>\n{\n  match list\n  case Nil => []\n  case Cons(h, t) => [h] + toSeq(t)\n}\n\n// Convert from sequence\nfunction {:spec} fromSeq<T>(s: seq<T>): LinkedList<T>\n{\n  if |s| == 0 then Nil\n  else Cons(s[0], fromSeq(s[1..]))\n}\n\n// Map function over list\nfunction {:spec} listMap<T, U>(list: LinkedList<T>, f: T -> U): LinkedList<U>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => Cons(f(h), listMap(t, f))\n}\n\n// Filter list with predicate\nfunction {:spec} filter<T>(list: LinkedList<T>, p: T -> bool): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) =>\n    if p(h) then Cons(h, filter(t, p))\n    else filter(t, p)\n}\n\n// Take first n elements\nfunction {:spec} take<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n{\n  if n == 0 then Nil\n  else match list\n    case Nil => Nil\n    case Cons(h, t) => Cons(h, take(t, n - 1))\n}\n\n// Drop first n elements\nfunction {:spec} drop<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n  decreases list\n{\n  if n == 0 then list\n  else match list\n    case Nil => Nil\n    case Cons(_, t) => drop(t, n - 1)\n}\n\n// Check if list is palindrome\npredicate {:spec} isPalindrome<T(==)>(list: LinkedList<T>)\n{\n  toSeq(list) == toSeq(reverse(list))\n}\n\n// --- Lemmas for correctness ---\n\nlemma LengthAppend<T>(l1: LinkedList<T>, l2: LinkedList<T>)\n  ensures length(append(l1, l2)) == length(l1) + length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) =>\n    LengthAppend(t, l2);\n}\n\nlemma AppendNil<T>(list: LinkedList<T>)\n  ensures append(list, Nil) == list\n  ensures append(Nil, list) == list\n{\n  match list\n  case Nil =>\n  case Cons(_, t) =>\n    AppendNil(t);\n}\n\nlemma AppendAssociative<T>(l1: LinkedList<T>, l2: LinkedList<T>, l3: LinkedList<T>)\n  ensures append(append(l1, l2), l3) == append(l1, append(l2, l3))\n{\n  match l1\n  case Nil =>\n  case Cons(h, t) =>\n    AppendAssociative(t, l2, l3);\n}\n\nlemma ReverseLength<T>(list: LinkedList<T>)\n  ensures length(reverse(list)) == length(list)\n{\n  ReverseHelperLength(list, Nil);\n}\n\nlemma ReverseHelperLength<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures length(reverseHelper(list, acc)) == length(list) + length(acc)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    calc == {\n      length(reverseHelper(list, acc));\n      length(reverseHelper(t, Cons(h, acc)));\n      { ReverseHelperLength(t, Cons(h, acc)); }\n      length(t) + length(Cons(h, acc));\n      length(t) + 1 + length(acc);\n      length(list) + length(acc);\n    }\n}\n\nlemma ReverseReverse<T>(list: LinkedList<T>)\n  ensures reverse(reverse(list)) == list\n{\n  ReverseReverseHelper(list, Nil);\n}\n\nlemma ReverseReverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures reverseHelper(reverseHelper(list, acc), Nil) == reverseHelper(acc, list)\n{\n  match list\n  case Nil =>\n    assert reverseHelper(reverseHelper(Nil, acc), Nil) == reverseHelper(acc, Nil);\n  case Cons(h, t) =>\n    calc == {\n      reverseHelper(reverseHelper(Cons(h, t), acc), Nil);\n      reverseHelper(reverseHelper(t, Cons(h, acc)), Nil);\n      { ReverseReverseHelper(t, Cons(h, acc)); }\n      reverseHelper(Cons(h, acc), t);\n      reverseHelper(acc, Cons(h, t));\n    }\n}\n\nlemma ToSeqFromSeq<T>(s: seq<T>)\n  ensures toSeq(fromSeq(s)) == s\n{\n  if |s| == 0 {\n    assert fromSeq(s) == Nil;\n  } else {\n    ToSeqFromSeq(s[1..]);\n    assert toSeq(fromSeq(s)) == [s[0]] + toSeq(fromSeq(s[1..]));\n  }\n}\n\nlemma FromSeqToSeq<T>(list: LinkedList<T>)\n  ensures fromSeq(toSeq(list)) == list\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    FromSeqToSeq(t);\n}\n\nlemma NthCorrect<T>(list: LinkedList<T>, n: nat)\n  requires n < length(list)\n  ensures |toSeq(list)| > n\n  ensures toSeq(list)[n] == nth(list, n)\n{\n  match list\n  case Cons(h, t) =>\n    if n == 0 {\n      \n/*[CODE HERE]*/\n    } else {\n      NthCorrect(t, n - 1);\n    }\n}\n\nlemma MapLength<T, U>(list: LinkedList<T>, f: T -> U)\n  ensures length(listMap(list, f)) == length(list)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    MapLength(t, f);\n}\n\nlemma FilterSubset<T>(list: LinkedList<T>, p: T -> bool)\n  ensures length(filter(list, p)) <= length(list)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    FilterSubset(t, p);\n    if p(h) {\n      assert length(filter(list, p)) == 1 + length(filter(t, p));\n    } else {\n      assert length(filter(list, p)) == length(filter(t, p));\n    }\n}\n\nlemma TakeDropConcat<T>(list: LinkedList<T>, n: nat)\n  ensures append(take(list, n), drop(list, n)) == list\n{\n  if n == 0 {\n    assert take(list, 0) == Nil;\n    assert drop(list, 0) == list;\n    AppendNil(list);\n  } else {\n    match list\n    case Nil =>\n    case Cons(h, t) =>\n      TakeDropConcat(t, n - 1);\n      calc == {\n        append(take(list, n), drop(list, n));\n        append(Cons(h, take(t, n - 1)), drop(t, n - 1));\n        Cons(h, append(take(t, n - 1), drop(t, n - 1)));\n        Cons(h, t);\n        list;\n      }\n  }\n}\n\nlemma RemoveDecreasesLength<T>(list: LinkedList<T>, x: T)\n  requires contains(list, x)\n  ensures length(remove(list, x)) == length(list) - 1\n{\n  match list\n  case Cons(h, t) =>\n    if h == x {\n      assert remove(list, x) == t;\n    } else {\n      assert contains(t, x);\n      RemoveDecreasesLength(t, x);\n    }\n}\n\nlemma InsertAtLength<T>(list: LinkedList<T>, x: T, pos: nat)\n  ensures length(insertAt(list, x, pos)) == length(list) + 1\n{\n  if pos == 0 {\n    assert insertAt(list, x, 0) == Cons(x, list);\n  } else {\n    match list\n    case Nil =>\n      assert insertAt(Nil, x, pos) == Cons(x, Nil);\n    case Cons(h, t) =>\n      InsertAtLength(t, x, pos - 1);\n  }\n}", "output": "assert toSeq(list)[0] == h;"}, {"id": "example_MapLength_0", "type": "call", "program": "// Linked list operations: insert, delete, reverse, cycle detection\n\ndatatype LinkedList<T> = Nil | Cons(head: T, tail: LinkedList<T>)\n\n// Length of linked list\nfunction {:spec} length<T>(list: LinkedList<T>): nat\n{\n  match list\n  case Nil => 0\n  case Cons(_, tail) => 1 + length(tail)\n}\n\n// Append two linked lists\nfunction {:spec} append<T>(l1: LinkedList<T>, l2: LinkedList<T>): LinkedList<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, append(t, l2))\n}\n\n// Reverse a linked list\nfunction {:spec} reverse<T>(list: LinkedList<T>): LinkedList<T>\n{\n  reverseHelper(list, Nil)\n}\n\nfunction reverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>): LinkedList<T>\n{\n  match list\n  case Nil => acc\n  case Cons(h, t) => reverseHelper(t, Cons(h, acc))\n}\n\n// Get nth element (0-indexed)\nfunction {:spec} nth<T>(list: LinkedList<T>, n: nat): T\n  requires n < length(list)\n{\n  match list\n  case Cons(h, t) => if n == 0 then h else nth(t, n - 1)\n}\n\n// Check if element exists in list\npredicate {:spec} contains<T(==)>(list: LinkedList<T>, x: T)\n{\n  match list\n  case Nil => false\n  case Cons(h, t) => h == x || contains(t, x)\n}\n\n// Remove first occurrence of element\nfunction {:spec} remove<T(==)>(list: LinkedList<T>, x: T): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => if h == x then t else Cons(h, remove(t, x))\n}\n\n// Insert at position\nfunction {:spec} insertAt<T>(list: LinkedList<T>, x: T, pos: nat): LinkedList<T>\n{\n  if pos == 0 then Cons(x, list)\n  else match list\n    case Nil => Cons(x, Nil)\n    case Cons(h, t) => Cons(h, insertAt(t, x, pos - 1))\n}\n\n// Convert to sequence\nfunction {:spec} toSeq<T>(list: LinkedList<T>): seq<T>\n{\n  match list\n  case Nil => []\n  case Cons(h, t) => [h] + toSeq(t)\n}\n\n// Convert from sequence\nfunction {:spec} fromSeq<T>(s: seq<T>): LinkedList<T>\n{\n  if |s| == 0 then Nil\n  else Cons(s[0], fromSeq(s[1..]))\n}\n\n// Map function over list\nfunction {:spec} listMap<T, U>(list: LinkedList<T>, f: T -> U): LinkedList<U>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => Cons(f(h), listMap(t, f))\n}\n\n// Filter list with predicate\nfunction {:spec} filter<T>(list: LinkedList<T>, p: T -> bool): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) =>\n    if p(h) then Cons(h, filter(t, p))\n    else filter(t, p)\n}\n\n// Take first n elements\nfunction {:spec} take<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n{\n  if n == 0 then Nil\n  else match list\n    case Nil => Nil\n    case Cons(h, t) => Cons(h, take(t, n - 1))\n}\n\n// Drop first n elements\nfunction {:spec} drop<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n  decreases list\n{\n  if n == 0 then list\n  else match list\n    case Nil => Nil\n    case Cons(_, t) => drop(t, n - 1)\n}\n\n// Check if list is palindrome\npredicate {:spec} isPalindrome<T(==)>(list: LinkedList<T>)\n{\n  toSeq(list) == toSeq(reverse(list))\n}\n\n// --- Lemmas for correctness ---\n\nlemma LengthAppend<T>(l1: LinkedList<T>, l2: LinkedList<T>)\n  ensures length(append(l1, l2)) == length(l1) + length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) =>\n    LengthAppend(t, l2);\n}\n\nlemma AppendNil<T>(list: LinkedList<T>)\n  ensures append(list, Nil) == list\n  ensures append(Nil, list) == list\n{\n  match list\n  case Nil =>\n  case Cons(_, t) =>\n    AppendNil(t);\n}\n\nlemma AppendAssociative<T>(l1: LinkedList<T>, l2: LinkedList<T>, l3: LinkedList<T>)\n  ensures append(append(l1, l2), l3) == append(l1, append(l2, l3))\n{\n  match l1\n  case Nil =>\n  case Cons(h, t) =>\n    AppendAssociative(t, l2, l3);\n}\n\nlemma ReverseLength<T>(list: LinkedList<T>)\n  ensures length(reverse(list)) == length(list)\n{\n  ReverseHelperLength(list, Nil);\n}\n\nlemma ReverseHelperLength<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures length(reverseHelper(list, acc)) == length(list) + length(acc)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    calc == {\n      length(reverseHelper(list, acc));\n      length(reverseHelper(t, Cons(h, acc)));\n      { ReverseHelperLength(t, Cons(h, acc)); }\n      length(t) + length(Cons(h, acc));\n      length(t) + 1 + length(acc);\n      length(list) + length(acc);\n    }\n}\n\nlemma ReverseReverse<T>(list: LinkedList<T>)\n  ensures reverse(reverse(list)) == list\n{\n  ReverseReverseHelper(list, Nil);\n}\n\nlemma ReverseReverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures reverseHelper(reverseHelper(list, acc), Nil) == reverseHelper(acc, list)\n{\n  match list\n  case Nil =>\n    assert reverseHelper(reverseHelper(Nil, acc), Nil) == reverseHelper(acc, Nil);\n  case Cons(h, t) =>\n    calc == {\n      reverseHelper(reverseHelper(Cons(h, t), acc), Nil);\n      reverseHelper(reverseHelper(t, Cons(h, acc)), Nil);\n      { ReverseReverseHelper(t, Cons(h, acc)); }\n      reverseHelper(Cons(h, acc), t);\n      reverseHelper(acc, Cons(h, t));\n    }\n}\n\nlemma ToSeqFromSeq<T>(s: seq<T>)\n  ensures toSeq(fromSeq(s)) == s\n{\n  if |s| == 0 {\n    assert fromSeq(s) == Nil;\n  } else {\n    ToSeqFromSeq(s[1..]);\n    assert toSeq(fromSeq(s)) == [s[0]] + toSeq(fromSeq(s[1..]));\n  }\n}\n\nlemma FromSeqToSeq<T>(list: LinkedList<T>)\n  ensures fromSeq(toSeq(list)) == list\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    FromSeqToSeq(t);\n}\n\nlemma NthCorrect<T>(list: LinkedList<T>, n: nat)\n  requires n < length(list)\n  ensures |toSeq(list)| > n\n  ensures toSeq(list)[n] == nth(list, n)\n{\n  match list\n  case Cons(h, t) =>\n    if n == 0 {\n      assert toSeq(list)[0] == h;\n    } else {\n      NthCorrect(t, n - 1);\n    }\n}\n\nlemma MapLength<T, U>(list: LinkedList<T>, f: T -> U)\n  ensures length(listMap(list, f)) == length(list)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    \n/*[CODE HERE]*/\n}\n\nlemma FilterSubset<T>(list: LinkedList<T>, p: T -> bool)\n  ensures length(filter(list, p)) <= length(list)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    FilterSubset(t, p);\n    if p(h) {\n      assert length(filter(list, p)) == 1 + length(filter(t, p));\n    } else {\n      assert length(filter(list, p)) == length(filter(t, p));\n    }\n}\n\nlemma TakeDropConcat<T>(list: LinkedList<T>, n: nat)\n  ensures append(take(list, n), drop(list, n)) == list\n{\n  if n == 0 {\n    assert take(list, 0) == Nil;\n    assert drop(list, 0) == list;\n    AppendNil(list);\n  } else {\n    match list\n    case Nil =>\n    case Cons(h, t) =>\n      TakeDropConcat(t, n - 1);\n      calc == {\n        append(take(list, n), drop(list, n));\n        append(Cons(h, take(t, n - 1)), drop(t, n - 1));\n        Cons(h, append(take(t, n - 1), drop(t, n - 1)));\n        Cons(h, t);\n        list;\n      }\n  }\n}\n\nlemma RemoveDecreasesLength<T>(list: LinkedList<T>, x: T)\n  requires contains(list, x)\n  ensures length(remove(list, x)) == length(list) - 1\n{\n  match list\n  case Cons(h, t) =>\n    if h == x {\n      assert remove(list, x) == t;\n    } else {\n      assert contains(t, x);\n      RemoveDecreasesLength(t, x);\n    }\n}\n\nlemma InsertAtLength<T>(list: LinkedList<T>, x: T, pos: nat)\n  ensures length(insertAt(list, x, pos)) == length(list) + 1\n{\n  if pos == 0 {\n    assert insertAt(list, x, 0) == Cons(x, list);\n  } else {\n    match list\n    case Nil =>\n      assert insertAt(Nil, x, pos) == Cons(x, Nil);\n    case Cons(h, t) =>\n      InsertAtLength(t, x, pos - 1);\n  }\n}", "output": "MapLength(t, f);"}, {"id": "example_FilterSubset_0", "type": "assert", "program": "// Linked list operations: insert, delete, reverse, cycle detection\n\ndatatype LinkedList<T> = Nil | Cons(head: T, tail: LinkedList<T>)\n\n// Length of linked list\nfunction {:spec} length<T>(list: LinkedList<T>): nat\n{\n  match list\n  case Nil => 0\n  case Cons(_, tail) => 1 + length(tail)\n}\n\n// Append two linked lists\nfunction {:spec} append<T>(l1: LinkedList<T>, l2: LinkedList<T>): LinkedList<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, append(t, l2))\n}\n\n// Reverse a linked list\nfunction {:spec} reverse<T>(list: LinkedList<T>): LinkedList<T>\n{\n  reverseHelper(list, Nil)\n}\n\nfunction reverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>): LinkedList<T>\n{\n  match list\n  case Nil => acc\n  case Cons(h, t) => reverseHelper(t, Cons(h, acc))\n}\n\n// Get nth element (0-indexed)\nfunction {:spec} nth<T>(list: LinkedList<T>, n: nat): T\n  requires n < length(list)\n{\n  match list\n  case Cons(h, t) => if n == 0 then h else nth(t, n - 1)\n}\n\n// Check if element exists in list\npredicate {:spec} contains<T(==)>(list: LinkedList<T>, x: T)\n{\n  match list\n  case Nil => false\n  case Cons(h, t) => h == x || contains(t, x)\n}\n\n// Remove first occurrence of element\nfunction {:spec} remove<T(==)>(list: LinkedList<T>, x: T): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => if h == x then t else Cons(h, remove(t, x))\n}\n\n// Insert at position\nfunction {:spec} insertAt<T>(list: LinkedList<T>, x: T, pos: nat): LinkedList<T>\n{\n  if pos == 0 then Cons(x, list)\n  else match list\n    case Nil => Cons(x, Nil)\n    case Cons(h, t) => Cons(h, insertAt(t, x, pos - 1))\n}\n\n// Convert to sequence\nfunction {:spec} toSeq<T>(list: LinkedList<T>): seq<T>\n{\n  match list\n  case Nil => []\n  case Cons(h, t) => [h] + toSeq(t)\n}\n\n// Convert from sequence\nfunction {:spec} fromSeq<T>(s: seq<T>): LinkedList<T>\n{\n  if |s| == 0 then Nil\n  else Cons(s[0], fromSeq(s[1..]))\n}\n\n// Map function over list\nfunction {:spec} listMap<T, U>(list: LinkedList<T>, f: T -> U): LinkedList<U>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => Cons(f(h), listMap(t, f))\n}\n\n// Filter list with predicate\nfunction {:spec} filter<T>(list: LinkedList<T>, p: T -> bool): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) =>\n    if p(h) then Cons(h, filter(t, p))\n    else filter(t, p)\n}\n\n// Take first n elements\nfunction {:spec} take<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n{\n  if n == 0 then Nil\n  else match list\n    case Nil => Nil\n    case Cons(h, t) => Cons(h, take(t, n - 1))\n}\n\n// Drop first n elements\nfunction {:spec} drop<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n  decreases list\n{\n  if n == 0 then list\n  else match list\n    case Nil => Nil\n    case Cons(_, t) => drop(t, n - 1)\n}\n\n// Check if list is palindrome\npredicate {:spec} isPalindrome<T(==)>(list: LinkedList<T>)\n{\n  toSeq(list) == toSeq(reverse(list))\n}\n\n// --- Lemmas for correctness ---\n\nlemma LengthAppend<T>(l1: LinkedList<T>, l2: LinkedList<T>)\n  ensures length(append(l1, l2)) == length(l1) + length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) =>\n    LengthAppend(t, l2);\n}\n\nlemma AppendNil<T>(list: LinkedList<T>)\n  ensures append(list, Nil) == list\n  ensures append(Nil, list) == list\n{\n  match list\n  case Nil =>\n  case Cons(_, t) =>\n    AppendNil(t);\n}\n\nlemma AppendAssociative<T>(l1: LinkedList<T>, l2: LinkedList<T>, l3: LinkedList<T>)\n  ensures append(append(l1, l2), l3) == append(l1, append(l2, l3))\n{\n  match l1\n  case Nil =>\n  case Cons(h, t) =>\n    AppendAssociative(t, l2, l3);\n}\n\nlemma ReverseLength<T>(list: LinkedList<T>)\n  ensures length(reverse(list)) == length(list)\n{\n  ReverseHelperLength(list, Nil);\n}\n\nlemma ReverseHelperLength<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures length(reverseHelper(list, acc)) == length(list) + length(acc)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    calc == {\n      length(reverseHelper(list, acc));\n      length(reverseHelper(t, Cons(h, acc)));\n      { ReverseHelperLength(t, Cons(h, acc)); }\n      length(t) + length(Cons(h, acc));\n      length(t) + 1 + length(acc);\n      length(list) + length(acc);\n    }\n}\n\nlemma ReverseReverse<T>(list: LinkedList<T>)\n  ensures reverse(reverse(list)) == list\n{\n  ReverseReverseHelper(list, Nil);\n}\n\nlemma ReverseReverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures reverseHelper(reverseHelper(list, acc), Nil) == reverseHelper(acc, list)\n{\n  match list\n  case Nil =>\n    assert reverseHelper(reverseHelper(Nil, acc), Nil) == reverseHelper(acc, Nil);\n  case Cons(h, t) =>\n    calc == {\n      reverseHelper(reverseHelper(Cons(h, t), acc), Nil);\n      reverseHelper(reverseHelper(t, Cons(h, acc)), Nil);\n      { ReverseReverseHelper(t, Cons(h, acc)); }\n      reverseHelper(Cons(h, acc), t);\n      reverseHelper(acc, Cons(h, t));\n    }\n}\n\nlemma ToSeqFromSeq<T>(s: seq<T>)\n  ensures toSeq(fromSeq(s)) == s\n{\n  if |s| == 0 {\n    assert fromSeq(s) == Nil;\n  } else {\n    ToSeqFromSeq(s[1..]);\n    assert toSeq(fromSeq(s)) == [s[0]] + toSeq(fromSeq(s[1..]));\n  }\n}\n\nlemma FromSeqToSeq<T>(list: LinkedList<T>)\n  ensures fromSeq(toSeq(list)) == list\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    FromSeqToSeq(t);\n}\n\nlemma NthCorrect<T>(list: LinkedList<T>, n: nat)\n  requires n < length(list)\n  ensures |toSeq(list)| > n\n  ensures toSeq(list)[n] == nth(list, n)\n{\n  match list\n  case Cons(h, t) =>\n    if n == 0 {\n      assert toSeq(list)[0] == h;\n    } else {\n      NthCorrect(t, n - 1);\n    }\n}\n\nlemma MapLength<T, U>(list: LinkedList<T>, f: T -> U)\n  ensures length(listMap(list, f)) == length(list)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    MapLength(t, f);\n}\n\nlemma FilterSubset<T>(list: LinkedList<T>, p: T -> bool)\n  ensures length(filter(list, p)) <= length(list)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    FilterSubset(t, p);\n    if p(h) {\n      assert length(filter(list, p)) == 1 + length(filter(t, p));\n    } else {\n      \n/*[CODE HERE]*/\n    }\n}\n\nlemma TakeDropConcat<T>(list: LinkedList<T>, n: nat)\n  ensures append(take(list, n), drop(list, n)) == list\n{\n  if n == 0 {\n    assert take(list, 0) == Nil;\n    assert drop(list, 0) == list;\n    AppendNil(list);\n  } else {\n    match list\n    case Nil =>\n    case Cons(h, t) =>\n      TakeDropConcat(t, n - 1);\n      calc == {\n        append(take(list, n), drop(list, n));\n        append(Cons(h, take(t, n - 1)), drop(t, n - 1));\n        Cons(h, append(take(t, n - 1), drop(t, n - 1)));\n        Cons(h, t);\n        list;\n      }\n  }\n}\n\nlemma RemoveDecreasesLength<T>(list: LinkedList<T>, x: T)\n  requires contains(list, x)\n  ensures length(remove(list, x)) == length(list) - 1\n{\n  match list\n  case Cons(h, t) =>\n    if h == x {\n      assert remove(list, x) == t;\n    } else {\n      assert contains(t, x);\n      RemoveDecreasesLength(t, x);\n    }\n}\n\nlemma InsertAtLength<T>(list: LinkedList<T>, x: T, pos: nat)\n  ensures length(insertAt(list, x, pos)) == length(list) + 1\n{\n  if pos == 0 {\n    assert insertAt(list, x, 0) == Cons(x, list);\n  } else {\n    match list\n    case Nil =>\n      assert insertAt(Nil, x, pos) == Cons(x, Nil);\n    case Cons(h, t) =>\n      InsertAtLength(t, x, pos - 1);\n  }\n}", "output": "assert length(filter(list, p)) == length(filter(t, p));"}, {"id": "example_FilterSubset_1", "type": "assert", "program": "// Linked list operations: insert, delete, reverse, cycle detection\n\ndatatype LinkedList<T> = Nil | Cons(head: T, tail: LinkedList<T>)\n\n// Length of linked list\nfunction {:spec} length<T>(list: LinkedList<T>): nat\n{\n  match list\n  case Nil => 0\n  case Cons(_, tail) => 1 + length(tail)\n}\n\n// Append two linked lists\nfunction {:spec} append<T>(l1: LinkedList<T>, l2: LinkedList<T>): LinkedList<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, append(t, l2))\n}\n\n// Reverse a linked list\nfunction {:spec} reverse<T>(list: LinkedList<T>): LinkedList<T>\n{\n  reverseHelper(list, Nil)\n}\n\nfunction reverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>): LinkedList<T>\n{\n  match list\n  case Nil => acc\n  case Cons(h, t) => reverseHelper(t, Cons(h, acc))\n}\n\n// Get nth element (0-indexed)\nfunction {:spec} nth<T>(list: LinkedList<T>, n: nat): T\n  requires n < length(list)\n{\n  match list\n  case Cons(h, t) => if n == 0 then h else nth(t, n - 1)\n}\n\n// Check if element exists in list\npredicate {:spec} contains<T(==)>(list: LinkedList<T>, x: T)\n{\n  match list\n  case Nil => false\n  case Cons(h, t) => h == x || contains(t, x)\n}\n\n// Remove first occurrence of element\nfunction {:spec} remove<T(==)>(list: LinkedList<T>, x: T): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => if h == x then t else Cons(h, remove(t, x))\n}\n\n// Insert at position\nfunction {:spec} insertAt<T>(list: LinkedList<T>, x: T, pos: nat): LinkedList<T>\n{\n  if pos == 0 then Cons(x, list)\n  else match list\n    case Nil => Cons(x, Nil)\n    case Cons(h, t) => Cons(h, insertAt(t, x, pos - 1))\n}\n\n// Convert to sequence\nfunction {:spec} toSeq<T>(list: LinkedList<T>): seq<T>\n{\n  match list\n  case Nil => []\n  case Cons(h, t) => [h] + toSeq(t)\n}\n\n// Convert from sequence\nfunction {:spec} fromSeq<T>(s: seq<T>): LinkedList<T>\n{\n  if |s| == 0 then Nil\n  else Cons(s[0], fromSeq(s[1..]))\n}\n\n// Map function over list\nfunction {:spec} listMap<T, U>(list: LinkedList<T>, f: T -> U): LinkedList<U>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => Cons(f(h), listMap(t, f))\n}\n\n// Filter list with predicate\nfunction {:spec} filter<T>(list: LinkedList<T>, p: T -> bool): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) =>\n    if p(h) then Cons(h, filter(t, p))\n    else filter(t, p)\n}\n\n// Take first n elements\nfunction {:spec} take<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n{\n  if n == 0 then Nil\n  else match list\n    case Nil => Nil\n    case Cons(h, t) => Cons(h, take(t, n - 1))\n}\n\n// Drop first n elements\nfunction {:spec} drop<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n  decreases list\n{\n  if n == 0 then list\n  else match list\n    case Nil => Nil\n    case Cons(_, t) => drop(t, n - 1)\n}\n\n// Check if list is palindrome\npredicate {:spec} isPalindrome<T(==)>(list: LinkedList<T>)\n{\n  toSeq(list) == toSeq(reverse(list))\n}\n\n// --- Lemmas for correctness ---\n\nlemma LengthAppend<T>(l1: LinkedList<T>, l2: LinkedList<T>)\n  ensures length(append(l1, l2)) == length(l1) + length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) =>\n    LengthAppend(t, l2);\n}\n\nlemma AppendNil<T>(list: LinkedList<T>)\n  ensures append(list, Nil) == list\n  ensures append(Nil, list) == list\n{\n  match list\n  case Nil =>\n  case Cons(_, t) =>\n    AppendNil(t);\n}\n\nlemma AppendAssociative<T>(l1: LinkedList<T>, l2: LinkedList<T>, l3: LinkedList<T>)\n  ensures append(append(l1, l2), l3) == append(l1, append(l2, l3))\n{\n  match l1\n  case Nil =>\n  case Cons(h, t) =>\n    AppendAssociative(t, l2, l3);\n}\n\nlemma ReverseLength<T>(list: LinkedList<T>)\n  ensures length(reverse(list)) == length(list)\n{\n  ReverseHelperLength(list, Nil);\n}\n\nlemma ReverseHelperLength<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures length(reverseHelper(list, acc)) == length(list) + length(acc)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    calc == {\n      length(reverseHelper(list, acc));\n      length(reverseHelper(t, Cons(h, acc)));\n      { ReverseHelperLength(t, Cons(h, acc)); }\n      length(t) + length(Cons(h, acc));\n      length(t) + 1 + length(acc);\n      length(list) + length(acc);\n    }\n}\n\nlemma ReverseReverse<T>(list: LinkedList<T>)\n  ensures reverse(reverse(list)) == list\n{\n  ReverseReverseHelper(list, Nil);\n}\n\nlemma ReverseReverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures reverseHelper(reverseHelper(list, acc), Nil) == reverseHelper(acc, list)\n{\n  match list\n  case Nil =>\n    assert reverseHelper(reverseHelper(Nil, acc), Nil) == reverseHelper(acc, Nil);\n  case Cons(h, t) =>\n    calc == {\n      reverseHelper(reverseHelper(Cons(h, t), acc), Nil);\n      reverseHelper(reverseHelper(t, Cons(h, acc)), Nil);\n      { ReverseReverseHelper(t, Cons(h, acc)); }\n      reverseHelper(Cons(h, acc), t);\n      reverseHelper(acc, Cons(h, t));\n    }\n}\n\nlemma ToSeqFromSeq<T>(s: seq<T>)\n  ensures toSeq(fromSeq(s)) == s\n{\n  if |s| == 0 {\n    assert fromSeq(s) == Nil;\n  } else {\n    ToSeqFromSeq(s[1..]);\n    assert toSeq(fromSeq(s)) == [s[0]] + toSeq(fromSeq(s[1..]));\n  }\n}\n\nlemma FromSeqToSeq<T>(list: LinkedList<T>)\n  ensures fromSeq(toSeq(list)) == list\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    FromSeqToSeq(t);\n}\n\nlemma NthCorrect<T>(list: LinkedList<T>, n: nat)\n  requires n < length(list)\n  ensures |toSeq(list)| > n\n  ensures toSeq(list)[n] == nth(list, n)\n{\n  match list\n  case Cons(h, t) =>\n    if n == 0 {\n      assert toSeq(list)[0] == h;\n    } else {\n      NthCorrect(t, n - 1);\n    }\n}\n\nlemma MapLength<T, U>(list: LinkedList<T>, f: T -> U)\n  ensures length(listMap(list, f)) == length(list)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    MapLength(t, f);\n}\n\nlemma FilterSubset<T>(list: LinkedList<T>, p: T -> bool)\n  ensures length(filter(list, p)) <= length(list)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    FilterSubset(t, p);\n    if p(h) {\n      \n/*[CODE HERE]*/\n    } else {\n      assert length(filter(list, p)) == length(filter(t, p));\n    }\n}\n\nlemma TakeDropConcat<T>(list: LinkedList<T>, n: nat)\n  ensures append(take(list, n), drop(list, n)) == list\n{\n  if n == 0 {\n    assert take(list, 0) == Nil;\n    assert drop(list, 0) == list;\n    AppendNil(list);\n  } else {\n    match list\n    case Nil =>\n    case Cons(h, t) =>\n      TakeDropConcat(t, n - 1);\n      calc == {\n        append(take(list, n), drop(list, n));\n        append(Cons(h, take(t, n - 1)), drop(t, n - 1));\n        Cons(h, append(take(t, n - 1), drop(t, n - 1)));\n        Cons(h, t);\n        list;\n      }\n  }\n}\n\nlemma RemoveDecreasesLength<T>(list: LinkedList<T>, x: T)\n  requires contains(list, x)\n  ensures length(remove(list, x)) == length(list) - 1\n{\n  match list\n  case Cons(h, t) =>\n    if h == x {\n      assert remove(list, x) == t;\n    } else {\n      assert contains(t, x);\n      RemoveDecreasesLength(t, x);\n    }\n}\n\nlemma InsertAtLength<T>(list: LinkedList<T>, x: T, pos: nat)\n  ensures length(insertAt(list, x, pos)) == length(list) + 1\n{\n  if pos == 0 {\n    assert insertAt(list, x, 0) == Cons(x, list);\n  } else {\n    match list\n    case Nil =>\n      assert insertAt(Nil, x, pos) == Cons(x, Nil);\n    case Cons(h, t) =>\n      InsertAtLength(t, x, pos - 1);\n  }\n}", "output": "assert length(filter(list, p)) == 1 + length(filter(t, p));"}, {"id": "example_FilterSubset_2", "type": "call", "program": "// Linked list operations: insert, delete, reverse, cycle detection\n\ndatatype LinkedList<T> = Nil | Cons(head: T, tail: LinkedList<T>)\n\n// Length of linked list\nfunction {:spec} length<T>(list: LinkedList<T>): nat\n{\n  match list\n  case Nil => 0\n  case Cons(_, tail) => 1 + length(tail)\n}\n\n// Append two linked lists\nfunction {:spec} append<T>(l1: LinkedList<T>, l2: LinkedList<T>): LinkedList<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, append(t, l2))\n}\n\n// Reverse a linked list\nfunction {:spec} reverse<T>(list: LinkedList<T>): LinkedList<T>\n{\n  reverseHelper(list, Nil)\n}\n\nfunction reverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>): LinkedList<T>\n{\n  match list\n  case Nil => acc\n  case Cons(h, t) => reverseHelper(t, Cons(h, acc))\n}\n\n// Get nth element (0-indexed)\nfunction {:spec} nth<T>(list: LinkedList<T>, n: nat): T\n  requires n < length(list)\n{\n  match list\n  case Cons(h, t) => if n == 0 then h else nth(t, n - 1)\n}\n\n// Check if element exists in list\npredicate {:spec} contains<T(==)>(list: LinkedList<T>, x: T)\n{\n  match list\n  case Nil => false\n  case Cons(h, t) => h == x || contains(t, x)\n}\n\n// Remove first occurrence of element\nfunction {:spec} remove<T(==)>(list: LinkedList<T>, x: T): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => if h == x then t else Cons(h, remove(t, x))\n}\n\n// Insert at position\nfunction {:spec} insertAt<T>(list: LinkedList<T>, x: T, pos: nat): LinkedList<T>\n{\n  if pos == 0 then Cons(x, list)\n  else match list\n    case Nil => Cons(x, Nil)\n    case Cons(h, t) => Cons(h, insertAt(t, x, pos - 1))\n}\n\n// Convert to sequence\nfunction {:spec} toSeq<T>(list: LinkedList<T>): seq<T>\n{\n  match list\n  case Nil => []\n  case Cons(h, t) => [h] + toSeq(t)\n}\n\n// Convert from sequence\nfunction {:spec} fromSeq<T>(s: seq<T>): LinkedList<T>\n{\n  if |s| == 0 then Nil\n  else Cons(s[0], fromSeq(s[1..]))\n}\n\n// Map function over list\nfunction {:spec} listMap<T, U>(list: LinkedList<T>, f: T -> U): LinkedList<U>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => Cons(f(h), listMap(t, f))\n}\n\n// Filter list with predicate\nfunction {:spec} filter<T>(list: LinkedList<T>, p: T -> bool): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) =>\n    if p(h) then Cons(h, filter(t, p))\n    else filter(t, p)\n}\n\n// Take first n elements\nfunction {:spec} take<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n{\n  if n == 0 then Nil\n  else match list\n    case Nil => Nil\n    case Cons(h, t) => Cons(h, take(t, n - 1))\n}\n\n// Drop first n elements\nfunction {:spec} drop<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n  decreases list\n{\n  if n == 0 then list\n  else match list\n    case Nil => Nil\n    case Cons(_, t) => drop(t, n - 1)\n}\n\n// Check if list is palindrome\npredicate {:spec} isPalindrome<T(==)>(list: LinkedList<T>)\n{\n  toSeq(list) == toSeq(reverse(list))\n}\n\n// --- Lemmas for correctness ---\n\nlemma LengthAppend<T>(l1: LinkedList<T>, l2: LinkedList<T>)\n  ensures length(append(l1, l2)) == length(l1) + length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) =>\n    LengthAppend(t, l2);\n}\n\nlemma AppendNil<T>(list: LinkedList<T>)\n  ensures append(list, Nil) == list\n  ensures append(Nil, list) == list\n{\n  match list\n  case Nil =>\n  case Cons(_, t) =>\n    AppendNil(t);\n}\n\nlemma AppendAssociative<T>(l1: LinkedList<T>, l2: LinkedList<T>, l3: LinkedList<T>)\n  ensures append(append(l1, l2), l3) == append(l1, append(l2, l3))\n{\n  match l1\n  case Nil =>\n  case Cons(h, t) =>\n    AppendAssociative(t, l2, l3);\n}\n\nlemma ReverseLength<T>(list: LinkedList<T>)\n  ensures length(reverse(list)) == length(list)\n{\n  ReverseHelperLength(list, Nil);\n}\n\nlemma ReverseHelperLength<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures length(reverseHelper(list, acc)) == length(list) + length(acc)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    calc == {\n      length(reverseHelper(list, acc));\n      length(reverseHelper(t, Cons(h, acc)));\n      { ReverseHelperLength(t, Cons(h, acc)); }\n      length(t) + length(Cons(h, acc));\n      length(t) + 1 + length(acc);\n      length(list) + length(acc);\n    }\n}\n\nlemma ReverseReverse<T>(list: LinkedList<T>)\n  ensures reverse(reverse(list)) == list\n{\n  ReverseReverseHelper(list, Nil);\n}\n\nlemma ReverseReverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures reverseHelper(reverseHelper(list, acc), Nil) == reverseHelper(acc, list)\n{\n  match list\n  case Nil =>\n    assert reverseHelper(reverseHelper(Nil, acc), Nil) == reverseHelper(acc, Nil);\n  case Cons(h, t) =>\n    calc == {\n      reverseHelper(reverseHelper(Cons(h, t), acc), Nil);\n      reverseHelper(reverseHelper(t, Cons(h, acc)), Nil);\n      { ReverseReverseHelper(t, Cons(h, acc)); }\n      reverseHelper(Cons(h, acc), t);\n      reverseHelper(acc, Cons(h, t));\n    }\n}\n\nlemma ToSeqFromSeq<T>(s: seq<T>)\n  ensures toSeq(fromSeq(s)) == s\n{\n  if |s| == 0 {\n    assert fromSeq(s) == Nil;\n  } else {\n    ToSeqFromSeq(s[1..]);\n    assert toSeq(fromSeq(s)) == [s[0]] + toSeq(fromSeq(s[1..]));\n  }\n}\n\nlemma FromSeqToSeq<T>(list: LinkedList<T>)\n  ensures fromSeq(toSeq(list)) == list\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    FromSeqToSeq(t);\n}\n\nlemma NthCorrect<T>(list: LinkedList<T>, n: nat)\n  requires n < length(list)\n  ensures |toSeq(list)| > n\n  ensures toSeq(list)[n] == nth(list, n)\n{\n  match list\n  case Cons(h, t) =>\n    if n == 0 {\n      assert toSeq(list)[0] == h;\n    } else {\n      NthCorrect(t, n - 1);\n    }\n}\n\nlemma MapLength<T, U>(list: LinkedList<T>, f: T -> U)\n  ensures length(listMap(list, f)) == length(list)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    MapLength(t, f);\n}\n\nlemma FilterSubset<T>(list: LinkedList<T>, p: T -> bool)\n  ensures length(filter(list, p)) <= length(list)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    \n/*[CODE HERE]*/\n    if p(h) {\n      assert length(filter(list, p)) == 1 + length(filter(t, p));\n    } else {\n      assert length(filter(list, p)) == length(filter(t, p));\n    }\n}\n\nlemma TakeDropConcat<T>(list: LinkedList<T>, n: nat)\n  ensures append(take(list, n), drop(list, n)) == list\n{\n  if n == 0 {\n    assert take(list, 0) == Nil;\n    assert drop(list, 0) == list;\n    AppendNil(list);\n  } else {\n    match list\n    case Nil =>\n    case Cons(h, t) =>\n      TakeDropConcat(t, n - 1);\n      calc == {\n        append(take(list, n), drop(list, n));\n        append(Cons(h, take(t, n - 1)), drop(t, n - 1));\n        Cons(h, append(take(t, n - 1), drop(t, n - 1)));\n        Cons(h, t);\n        list;\n      }\n  }\n}\n\nlemma RemoveDecreasesLength<T>(list: LinkedList<T>, x: T)\n  requires contains(list, x)\n  ensures length(remove(list, x)) == length(list) - 1\n{\n  match list\n  case Cons(h, t) =>\n    if h == x {\n      assert remove(list, x) == t;\n    } else {\n      assert contains(t, x);\n      RemoveDecreasesLength(t, x);\n    }\n}\n\nlemma InsertAtLength<T>(list: LinkedList<T>, x: T, pos: nat)\n  ensures length(insertAt(list, x, pos)) == length(list) + 1\n{\n  if pos == 0 {\n    assert insertAt(list, x, 0) == Cons(x, list);\n  } else {\n    match list\n    case Nil =>\n      assert insertAt(Nil, x, pos) == Cons(x, Nil);\n    case Cons(h, t) =>\n      InsertAtLength(t, x, pos - 1);\n  }\n}", "output": "FilterSubset(t, p);"}, {"id": "example_TakeDropConcat_0", "type": "call", "program": "// Linked list operations: insert, delete, reverse, cycle detection\n\ndatatype LinkedList<T> = Nil | Cons(head: T, tail: LinkedList<T>)\n\n// Length of linked list\nfunction {:spec} length<T>(list: LinkedList<T>): nat\n{\n  match list\n  case Nil => 0\n  case Cons(_, tail) => 1 + length(tail)\n}\n\n// Append two linked lists\nfunction {:spec} append<T>(l1: LinkedList<T>, l2: LinkedList<T>): LinkedList<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, append(t, l2))\n}\n\n// Reverse a linked list\nfunction {:spec} reverse<T>(list: LinkedList<T>): LinkedList<T>\n{\n  reverseHelper(list, Nil)\n}\n\nfunction reverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>): LinkedList<T>\n{\n  match list\n  case Nil => acc\n  case Cons(h, t) => reverseHelper(t, Cons(h, acc))\n}\n\n// Get nth element (0-indexed)\nfunction {:spec} nth<T>(list: LinkedList<T>, n: nat): T\n  requires n < length(list)\n{\n  match list\n  case Cons(h, t) => if n == 0 then h else nth(t, n - 1)\n}\n\n// Check if element exists in list\npredicate {:spec} contains<T(==)>(list: LinkedList<T>, x: T)\n{\n  match list\n  case Nil => false\n  case Cons(h, t) => h == x || contains(t, x)\n}\n\n// Remove first occurrence of element\nfunction {:spec} remove<T(==)>(list: LinkedList<T>, x: T): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => if h == x then t else Cons(h, remove(t, x))\n}\n\n// Insert at position\nfunction {:spec} insertAt<T>(list: LinkedList<T>, x: T, pos: nat): LinkedList<T>\n{\n  if pos == 0 then Cons(x, list)\n  else match list\n    case Nil => Cons(x, Nil)\n    case Cons(h, t) => Cons(h, insertAt(t, x, pos - 1))\n}\n\n// Convert to sequence\nfunction {:spec} toSeq<T>(list: LinkedList<T>): seq<T>\n{\n  match list\n  case Nil => []\n  case Cons(h, t) => [h] + toSeq(t)\n}\n\n// Convert from sequence\nfunction {:spec} fromSeq<T>(s: seq<T>): LinkedList<T>\n{\n  if |s| == 0 then Nil\n  else Cons(s[0], fromSeq(s[1..]))\n}\n\n// Map function over list\nfunction {:spec} listMap<T, U>(list: LinkedList<T>, f: T -> U): LinkedList<U>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => Cons(f(h), listMap(t, f))\n}\n\n// Filter list with predicate\nfunction {:spec} filter<T>(list: LinkedList<T>, p: T -> bool): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) =>\n    if p(h) then Cons(h, filter(t, p))\n    else filter(t, p)\n}\n\n// Take first n elements\nfunction {:spec} take<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n{\n  if n == 0 then Nil\n  else match list\n    case Nil => Nil\n    case Cons(h, t) => Cons(h, take(t, n - 1))\n}\n\n// Drop first n elements\nfunction {:spec} drop<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n  decreases list\n{\n  if n == 0 then list\n  else match list\n    case Nil => Nil\n    case Cons(_, t) => drop(t, n - 1)\n}\n\n// Check if list is palindrome\npredicate {:spec} isPalindrome<T(==)>(list: LinkedList<T>)\n{\n  toSeq(list) == toSeq(reverse(list))\n}\n\n// --- Lemmas for correctness ---\n\nlemma LengthAppend<T>(l1: LinkedList<T>, l2: LinkedList<T>)\n  ensures length(append(l1, l2)) == length(l1) + length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) =>\n    LengthAppend(t, l2);\n}\n\nlemma AppendNil<T>(list: LinkedList<T>)\n  ensures append(list, Nil) == list\n  ensures append(Nil, list) == list\n{\n  match list\n  case Nil =>\n  case Cons(_, t) =>\n    AppendNil(t);\n}\n\nlemma AppendAssociative<T>(l1: LinkedList<T>, l2: LinkedList<T>, l3: LinkedList<T>)\n  ensures append(append(l1, l2), l3) == append(l1, append(l2, l3))\n{\n  match l1\n  case Nil =>\n  case Cons(h, t) =>\n    AppendAssociative(t, l2, l3);\n}\n\nlemma ReverseLength<T>(list: LinkedList<T>)\n  ensures length(reverse(list)) == length(list)\n{\n  ReverseHelperLength(list, Nil);\n}\n\nlemma ReverseHelperLength<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures length(reverseHelper(list, acc)) == length(list) + length(acc)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    calc == {\n      length(reverseHelper(list, acc));\n      length(reverseHelper(t, Cons(h, acc)));\n      { ReverseHelperLength(t, Cons(h, acc)); }\n      length(t) + length(Cons(h, acc));\n      length(t) + 1 + length(acc);\n      length(list) + length(acc);\n    }\n}\n\nlemma ReverseReverse<T>(list: LinkedList<T>)\n  ensures reverse(reverse(list)) == list\n{\n  ReverseReverseHelper(list, Nil);\n}\n\nlemma ReverseReverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures reverseHelper(reverseHelper(list, acc), Nil) == reverseHelper(acc, list)\n{\n  match list\n  case Nil =>\n    assert reverseHelper(reverseHelper(Nil, acc), Nil) == reverseHelper(acc, Nil);\n  case Cons(h, t) =>\n    calc == {\n      reverseHelper(reverseHelper(Cons(h, t), acc), Nil);\n      reverseHelper(reverseHelper(t, Cons(h, acc)), Nil);\n      { ReverseReverseHelper(t, Cons(h, acc)); }\n      reverseHelper(Cons(h, acc), t);\n      reverseHelper(acc, Cons(h, t));\n    }\n}\n\nlemma ToSeqFromSeq<T>(s: seq<T>)\n  ensures toSeq(fromSeq(s)) == s\n{\n  if |s| == 0 {\n    assert fromSeq(s) == Nil;\n  } else {\n    ToSeqFromSeq(s[1..]);\n    assert toSeq(fromSeq(s)) == [s[0]] + toSeq(fromSeq(s[1..]));\n  }\n}\n\nlemma FromSeqToSeq<T>(list: LinkedList<T>)\n  ensures fromSeq(toSeq(list)) == list\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    FromSeqToSeq(t);\n}\n\nlemma NthCorrect<T>(list: LinkedList<T>, n: nat)\n  requires n < length(list)\n  ensures |toSeq(list)| > n\n  ensures toSeq(list)[n] == nth(list, n)\n{\n  match list\n  case Cons(h, t) =>\n    if n == 0 {\n      assert toSeq(list)[0] == h;\n    } else {\n      NthCorrect(t, n - 1);\n    }\n}\n\nlemma MapLength<T, U>(list: LinkedList<T>, f: T -> U)\n  ensures length(listMap(list, f)) == length(list)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    MapLength(t, f);\n}\n\nlemma FilterSubset<T>(list: LinkedList<T>, p: T -> bool)\n  ensures length(filter(list, p)) <= length(list)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    FilterSubset(t, p);\n    if p(h) {\n      assert length(filter(list, p)) == 1 + length(filter(t, p));\n    } else {\n      assert length(filter(list, p)) == length(filter(t, p));\n    }\n}\n\nlemma TakeDropConcat<T>(list: LinkedList<T>, n: nat)\n  ensures append(take(list, n), drop(list, n)) == list\n{\n  if n == 0 {\n    assert take(list, 0) == Nil;\n    assert drop(list, 0) == list;\n    AppendNil(list);\n  } else {\n    match list\n    case Nil =>\n    case Cons(h, t) =>\n      \n/*[CODE HERE]*/\n      calc == {\n        append(take(list, n), drop(list, n));\n        append(Cons(h, take(t, n - 1)), drop(t, n - 1));\n        Cons(h, append(take(t, n - 1), drop(t, n - 1)));\n        Cons(h, t);\n        list;\n      }\n  }\n}\n\nlemma RemoveDecreasesLength<T>(list: LinkedList<T>, x: T)\n  requires contains(list, x)\n  ensures length(remove(list, x)) == length(list) - 1\n{\n  match list\n  case Cons(h, t) =>\n    if h == x {\n      assert remove(list, x) == t;\n    } else {\n      assert contains(t, x);\n      RemoveDecreasesLength(t, x);\n    }\n}\n\nlemma InsertAtLength<T>(list: LinkedList<T>, x: T, pos: nat)\n  ensures length(insertAt(list, x, pos)) == length(list) + 1\n{\n  if pos == 0 {\n    assert insertAt(list, x, 0) == Cons(x, list);\n  } else {\n    match list\n    case Nil =>\n      assert insertAt(Nil, x, pos) == Cons(x, Nil);\n    case Cons(h, t) =>\n      InsertAtLength(t, x, pos - 1);\n  }\n}", "output": "TakeDropConcat(t, n - 1);"}, {"id": "example_TakeDropConcat_1", "type": "call", "program": "// Linked list operations: insert, delete, reverse, cycle detection\n\ndatatype LinkedList<T> = Nil | Cons(head: T, tail: LinkedList<T>)\n\n// Length of linked list\nfunction {:spec} length<T>(list: LinkedList<T>): nat\n{\n  match list\n  case Nil => 0\n  case Cons(_, tail) => 1 + length(tail)\n}\n\n// Append two linked lists\nfunction {:spec} append<T>(l1: LinkedList<T>, l2: LinkedList<T>): LinkedList<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, append(t, l2))\n}\n\n// Reverse a linked list\nfunction {:spec} reverse<T>(list: LinkedList<T>): LinkedList<T>\n{\n  reverseHelper(list, Nil)\n}\n\nfunction reverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>): LinkedList<T>\n{\n  match list\n  case Nil => acc\n  case Cons(h, t) => reverseHelper(t, Cons(h, acc))\n}\n\n// Get nth element (0-indexed)\nfunction {:spec} nth<T>(list: LinkedList<T>, n: nat): T\n  requires n < length(list)\n{\n  match list\n  case Cons(h, t) => if n == 0 then h else nth(t, n - 1)\n}\n\n// Check if element exists in list\npredicate {:spec} contains<T(==)>(list: LinkedList<T>, x: T)\n{\n  match list\n  case Nil => false\n  case Cons(h, t) => h == x || contains(t, x)\n}\n\n// Remove first occurrence of element\nfunction {:spec} remove<T(==)>(list: LinkedList<T>, x: T): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => if h == x then t else Cons(h, remove(t, x))\n}\n\n// Insert at position\nfunction {:spec} insertAt<T>(list: LinkedList<T>, x: T, pos: nat): LinkedList<T>\n{\n  if pos == 0 then Cons(x, list)\n  else match list\n    case Nil => Cons(x, Nil)\n    case Cons(h, t) => Cons(h, insertAt(t, x, pos - 1))\n}\n\n// Convert to sequence\nfunction {:spec} toSeq<T>(list: LinkedList<T>): seq<T>\n{\n  match list\n  case Nil => []\n  case Cons(h, t) => [h] + toSeq(t)\n}\n\n// Convert from sequence\nfunction {:spec} fromSeq<T>(s: seq<T>): LinkedList<T>\n{\n  if |s| == 0 then Nil\n  else Cons(s[0], fromSeq(s[1..]))\n}\n\n// Map function over list\nfunction {:spec} listMap<T, U>(list: LinkedList<T>, f: T -> U): LinkedList<U>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => Cons(f(h), listMap(t, f))\n}\n\n// Filter list with predicate\nfunction {:spec} filter<T>(list: LinkedList<T>, p: T -> bool): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) =>\n    if p(h) then Cons(h, filter(t, p))\n    else filter(t, p)\n}\n\n// Take first n elements\nfunction {:spec} take<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n{\n  if n == 0 then Nil\n  else match list\n    case Nil => Nil\n    case Cons(h, t) => Cons(h, take(t, n - 1))\n}\n\n// Drop first n elements\nfunction {:spec} drop<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n  decreases list\n{\n  if n == 0 then list\n  else match list\n    case Nil => Nil\n    case Cons(_, t) => drop(t, n - 1)\n}\n\n// Check if list is palindrome\npredicate {:spec} isPalindrome<T(==)>(list: LinkedList<T>)\n{\n  toSeq(list) == toSeq(reverse(list))\n}\n\n// --- Lemmas for correctness ---\n\nlemma LengthAppend<T>(l1: LinkedList<T>, l2: LinkedList<T>)\n  ensures length(append(l1, l2)) == length(l1) + length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) =>\n    LengthAppend(t, l2);\n}\n\nlemma AppendNil<T>(list: LinkedList<T>)\n  ensures append(list, Nil) == list\n  ensures append(Nil, list) == list\n{\n  match list\n  case Nil =>\n  case Cons(_, t) =>\n    AppendNil(t);\n}\n\nlemma AppendAssociative<T>(l1: LinkedList<T>, l2: LinkedList<T>, l3: LinkedList<T>)\n  ensures append(append(l1, l2), l3) == append(l1, append(l2, l3))\n{\n  match l1\n  case Nil =>\n  case Cons(h, t) =>\n    AppendAssociative(t, l2, l3);\n}\n\nlemma ReverseLength<T>(list: LinkedList<T>)\n  ensures length(reverse(list)) == length(list)\n{\n  ReverseHelperLength(list, Nil);\n}\n\nlemma ReverseHelperLength<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures length(reverseHelper(list, acc)) == length(list) + length(acc)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    calc == {\n      length(reverseHelper(list, acc));\n      length(reverseHelper(t, Cons(h, acc)));\n      { ReverseHelperLength(t, Cons(h, acc)); }\n      length(t) + length(Cons(h, acc));\n      length(t) + 1 + length(acc);\n      length(list) + length(acc);\n    }\n}\n\nlemma ReverseReverse<T>(list: LinkedList<T>)\n  ensures reverse(reverse(list)) == list\n{\n  ReverseReverseHelper(list, Nil);\n}\n\nlemma ReverseReverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures reverseHelper(reverseHelper(list, acc), Nil) == reverseHelper(acc, list)\n{\n  match list\n  case Nil =>\n    assert reverseHelper(reverseHelper(Nil, acc), Nil) == reverseHelper(acc, Nil);\n  case Cons(h, t) =>\n    calc == {\n      reverseHelper(reverseHelper(Cons(h, t), acc), Nil);\n      reverseHelper(reverseHelper(t, Cons(h, acc)), Nil);\n      { ReverseReverseHelper(t, Cons(h, acc)); }\n      reverseHelper(Cons(h, acc), t);\n      reverseHelper(acc, Cons(h, t));\n    }\n}\n\nlemma ToSeqFromSeq<T>(s: seq<T>)\n  ensures toSeq(fromSeq(s)) == s\n{\n  if |s| == 0 {\n    assert fromSeq(s) == Nil;\n  } else {\n    ToSeqFromSeq(s[1..]);\n    assert toSeq(fromSeq(s)) == [s[0]] + toSeq(fromSeq(s[1..]));\n  }\n}\n\nlemma FromSeqToSeq<T>(list: LinkedList<T>)\n  ensures fromSeq(toSeq(list)) == list\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    FromSeqToSeq(t);\n}\n\nlemma NthCorrect<T>(list: LinkedList<T>, n: nat)\n  requires n < length(list)\n  ensures |toSeq(list)| > n\n  ensures toSeq(list)[n] == nth(list, n)\n{\n  match list\n  case Cons(h, t) =>\n    if n == 0 {\n      assert toSeq(list)[0] == h;\n    } else {\n      NthCorrect(t, n - 1);\n    }\n}\n\nlemma MapLength<T, U>(list: LinkedList<T>, f: T -> U)\n  ensures length(listMap(list, f)) == length(list)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    MapLength(t, f);\n}\n\nlemma FilterSubset<T>(list: LinkedList<T>, p: T -> bool)\n  ensures length(filter(list, p)) <= length(list)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    FilterSubset(t, p);\n    if p(h) {\n      assert length(filter(list, p)) == 1 + length(filter(t, p));\n    } else {\n      assert length(filter(list, p)) == length(filter(t, p));\n    }\n}\n\nlemma TakeDropConcat<T>(list: LinkedList<T>, n: nat)\n  ensures append(take(list, n), drop(list, n)) == list\n{\n  if n == 0 {\n    assert take(list, 0) == Nil;\n    assert drop(list, 0) == list;\n    \n/*[CODE HERE]*/\n  } else {\n    match list\n    case Nil =>\n    case Cons(h, t) =>\n      TakeDropConcat(t, n - 1);\n      calc == {\n        append(take(list, n), drop(list, n));\n        append(Cons(h, take(t, n - 1)), drop(t, n - 1));\n        Cons(h, append(take(t, n - 1), drop(t, n - 1)));\n        Cons(h, t);\n        list;\n      }\n  }\n}\n\nlemma RemoveDecreasesLength<T>(list: LinkedList<T>, x: T)\n  requires contains(list, x)\n  ensures length(remove(list, x)) == length(list) - 1\n{\n  match list\n  case Cons(h, t) =>\n    if h == x {\n      assert remove(list, x) == t;\n    } else {\n      assert contains(t, x);\n      RemoveDecreasesLength(t, x);\n    }\n}\n\nlemma InsertAtLength<T>(list: LinkedList<T>, x: T, pos: nat)\n  ensures length(insertAt(list, x, pos)) == length(list) + 1\n{\n  if pos == 0 {\n    assert insertAt(list, x, 0) == Cons(x, list);\n  } else {\n    match list\n    case Nil =>\n      assert insertAt(Nil, x, pos) == Cons(x, Nil);\n    case Cons(h, t) =>\n      InsertAtLength(t, x, pos - 1);\n  }\n}", "output": "AppendNil(list);"}, {"id": "example_TakeDropConcat_2", "type": "assert", "program": "// Linked list operations: insert, delete, reverse, cycle detection\n\ndatatype LinkedList<T> = Nil | Cons(head: T, tail: LinkedList<T>)\n\n// Length of linked list\nfunction {:spec} length<T>(list: LinkedList<T>): nat\n{\n  match list\n  case Nil => 0\n  case Cons(_, tail) => 1 + length(tail)\n}\n\n// Append two linked lists\nfunction {:spec} append<T>(l1: LinkedList<T>, l2: LinkedList<T>): LinkedList<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, append(t, l2))\n}\n\n// Reverse a linked list\nfunction {:spec} reverse<T>(list: LinkedList<T>): LinkedList<T>\n{\n  reverseHelper(list, Nil)\n}\n\nfunction reverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>): LinkedList<T>\n{\n  match list\n  case Nil => acc\n  case Cons(h, t) => reverseHelper(t, Cons(h, acc))\n}\n\n// Get nth element (0-indexed)\nfunction {:spec} nth<T>(list: LinkedList<T>, n: nat): T\n  requires n < length(list)\n{\n  match list\n  case Cons(h, t) => if n == 0 then h else nth(t, n - 1)\n}\n\n// Check if element exists in list\npredicate {:spec} contains<T(==)>(list: LinkedList<T>, x: T)\n{\n  match list\n  case Nil => false\n  case Cons(h, t) => h == x || contains(t, x)\n}\n\n// Remove first occurrence of element\nfunction {:spec} remove<T(==)>(list: LinkedList<T>, x: T): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => if h == x then t else Cons(h, remove(t, x))\n}\n\n// Insert at position\nfunction {:spec} insertAt<T>(list: LinkedList<T>, x: T, pos: nat): LinkedList<T>\n{\n  if pos == 0 then Cons(x, list)\n  else match list\n    case Nil => Cons(x, Nil)\n    case Cons(h, t) => Cons(h, insertAt(t, x, pos - 1))\n}\n\n// Convert to sequence\nfunction {:spec} toSeq<T>(list: LinkedList<T>): seq<T>\n{\n  match list\n  case Nil => []\n  case Cons(h, t) => [h] + toSeq(t)\n}\n\n// Convert from sequence\nfunction {:spec} fromSeq<T>(s: seq<T>): LinkedList<T>\n{\n  if |s| == 0 then Nil\n  else Cons(s[0], fromSeq(s[1..]))\n}\n\n// Map function over list\nfunction {:spec} listMap<T, U>(list: LinkedList<T>, f: T -> U): LinkedList<U>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => Cons(f(h), listMap(t, f))\n}\n\n// Filter list with predicate\nfunction {:spec} filter<T>(list: LinkedList<T>, p: T -> bool): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) =>\n    if p(h) then Cons(h, filter(t, p))\n    else filter(t, p)\n}\n\n// Take first n elements\nfunction {:spec} take<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n{\n  if n == 0 then Nil\n  else match list\n    case Nil => Nil\n    case Cons(h, t) => Cons(h, take(t, n - 1))\n}\n\n// Drop first n elements\nfunction {:spec} drop<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n  decreases list\n{\n  if n == 0 then list\n  else match list\n    case Nil => Nil\n    case Cons(_, t) => drop(t, n - 1)\n}\n\n// Check if list is palindrome\npredicate {:spec} isPalindrome<T(==)>(list: LinkedList<T>)\n{\n  toSeq(list) == toSeq(reverse(list))\n}\n\n// --- Lemmas for correctness ---\n\nlemma LengthAppend<T>(l1: LinkedList<T>, l2: LinkedList<T>)\n  ensures length(append(l1, l2)) == length(l1) + length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) =>\n    LengthAppend(t, l2);\n}\n\nlemma AppendNil<T>(list: LinkedList<T>)\n  ensures append(list, Nil) == list\n  ensures append(Nil, list) == list\n{\n  match list\n  case Nil =>\n  case Cons(_, t) =>\n    AppendNil(t);\n}\n\nlemma AppendAssociative<T>(l1: LinkedList<T>, l2: LinkedList<T>, l3: LinkedList<T>)\n  ensures append(append(l1, l2), l3) == append(l1, append(l2, l3))\n{\n  match l1\n  case Nil =>\n  case Cons(h, t) =>\n    AppendAssociative(t, l2, l3);\n}\n\nlemma ReverseLength<T>(list: LinkedList<T>)\n  ensures length(reverse(list)) == length(list)\n{\n  ReverseHelperLength(list, Nil);\n}\n\nlemma ReverseHelperLength<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures length(reverseHelper(list, acc)) == length(list) + length(acc)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    calc == {\n      length(reverseHelper(list, acc));\n      length(reverseHelper(t, Cons(h, acc)));\n      { ReverseHelperLength(t, Cons(h, acc)); }\n      length(t) + length(Cons(h, acc));\n      length(t) + 1 + length(acc);\n      length(list) + length(acc);\n    }\n}\n\nlemma ReverseReverse<T>(list: LinkedList<T>)\n  ensures reverse(reverse(list)) == list\n{\n  ReverseReverseHelper(list, Nil);\n}\n\nlemma ReverseReverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures reverseHelper(reverseHelper(list, acc), Nil) == reverseHelper(acc, list)\n{\n  match list\n  case Nil =>\n    assert reverseHelper(reverseHelper(Nil, acc), Nil) == reverseHelper(acc, Nil);\n  case Cons(h, t) =>\n    calc == {\n      reverseHelper(reverseHelper(Cons(h, t), acc), Nil);\n      reverseHelper(reverseHelper(t, Cons(h, acc)), Nil);\n      { ReverseReverseHelper(t, Cons(h, acc)); }\n      reverseHelper(Cons(h, acc), t);\n      reverseHelper(acc, Cons(h, t));\n    }\n}\n\nlemma ToSeqFromSeq<T>(s: seq<T>)\n  ensures toSeq(fromSeq(s)) == s\n{\n  if |s| == 0 {\n    assert fromSeq(s) == Nil;\n  } else {\n    ToSeqFromSeq(s[1..]);\n    assert toSeq(fromSeq(s)) == [s[0]] + toSeq(fromSeq(s[1..]));\n  }\n}\n\nlemma FromSeqToSeq<T>(list: LinkedList<T>)\n  ensures fromSeq(toSeq(list)) == list\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    FromSeqToSeq(t);\n}\n\nlemma NthCorrect<T>(list: LinkedList<T>, n: nat)\n  requires n < length(list)\n  ensures |toSeq(list)| > n\n  ensures toSeq(list)[n] == nth(list, n)\n{\n  match list\n  case Cons(h, t) =>\n    if n == 0 {\n      assert toSeq(list)[0] == h;\n    } else {\n      NthCorrect(t, n - 1);\n    }\n}\n\nlemma MapLength<T, U>(list: LinkedList<T>, f: T -> U)\n  ensures length(listMap(list, f)) == length(list)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    MapLength(t, f);\n}\n\nlemma FilterSubset<T>(list: LinkedList<T>, p: T -> bool)\n  ensures length(filter(list, p)) <= length(list)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    FilterSubset(t, p);\n    if p(h) {\n      assert length(filter(list, p)) == 1 + length(filter(t, p));\n    } else {\n      assert length(filter(list, p)) == length(filter(t, p));\n    }\n}\n\nlemma TakeDropConcat<T>(list: LinkedList<T>, n: nat)\n  ensures append(take(list, n), drop(list, n)) == list\n{\n  if n == 0 {\n    assert take(list, 0) == Nil;\n    \n/*[CODE HERE]*/\n    AppendNil(list);\n  } else {\n    match list\n    case Nil =>\n    case Cons(h, t) =>\n      TakeDropConcat(t, n - 1);\n      calc == {\n        append(take(list, n), drop(list, n));\n        append(Cons(h, take(t, n - 1)), drop(t, n - 1));\n        Cons(h, append(take(t, n - 1), drop(t, n - 1)));\n        Cons(h, t);\n        list;\n      }\n  }\n}\n\nlemma RemoveDecreasesLength<T>(list: LinkedList<T>, x: T)\n  requires contains(list, x)\n  ensures length(remove(list, x)) == length(list) - 1\n{\n  match list\n  case Cons(h, t) =>\n    if h == x {\n      assert remove(list, x) == t;\n    } else {\n      assert contains(t, x);\n      RemoveDecreasesLength(t, x);\n    }\n}\n\nlemma InsertAtLength<T>(list: LinkedList<T>, x: T, pos: nat)\n  ensures length(insertAt(list, x, pos)) == length(list) + 1\n{\n  if pos == 0 {\n    assert insertAt(list, x, 0) == Cons(x, list);\n  } else {\n    match list\n    case Nil =>\n      assert insertAt(Nil, x, pos) == Cons(x, Nil);\n    case Cons(h, t) =>\n      InsertAtLength(t, x, pos - 1);\n  }\n}", "output": "assert drop(list, 0) == list;"}, {"id": "example_TakeDropConcat_3", "type": "assert", "program": "// Linked list operations: insert, delete, reverse, cycle detection\n\ndatatype LinkedList<T> = Nil | Cons(head: T, tail: LinkedList<T>)\n\n// Length of linked list\nfunction {:spec} length<T>(list: LinkedList<T>): nat\n{\n  match list\n  case Nil => 0\n  case Cons(_, tail) => 1 + length(tail)\n}\n\n// Append two linked lists\nfunction {:spec} append<T>(l1: LinkedList<T>, l2: LinkedList<T>): LinkedList<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, append(t, l2))\n}\n\n// Reverse a linked list\nfunction {:spec} reverse<T>(list: LinkedList<T>): LinkedList<T>\n{\n  reverseHelper(list, Nil)\n}\n\nfunction reverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>): LinkedList<T>\n{\n  match list\n  case Nil => acc\n  case Cons(h, t) => reverseHelper(t, Cons(h, acc))\n}\n\n// Get nth element (0-indexed)\nfunction {:spec} nth<T>(list: LinkedList<T>, n: nat): T\n  requires n < length(list)\n{\n  match list\n  case Cons(h, t) => if n == 0 then h else nth(t, n - 1)\n}\n\n// Check if element exists in list\npredicate {:spec} contains<T(==)>(list: LinkedList<T>, x: T)\n{\n  match list\n  case Nil => false\n  case Cons(h, t) => h == x || contains(t, x)\n}\n\n// Remove first occurrence of element\nfunction {:spec} remove<T(==)>(list: LinkedList<T>, x: T): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => if h == x then t else Cons(h, remove(t, x))\n}\n\n// Insert at position\nfunction {:spec} insertAt<T>(list: LinkedList<T>, x: T, pos: nat): LinkedList<T>\n{\n  if pos == 0 then Cons(x, list)\n  else match list\n    case Nil => Cons(x, Nil)\n    case Cons(h, t) => Cons(h, insertAt(t, x, pos - 1))\n}\n\n// Convert to sequence\nfunction {:spec} toSeq<T>(list: LinkedList<T>): seq<T>\n{\n  match list\n  case Nil => []\n  case Cons(h, t) => [h] + toSeq(t)\n}\n\n// Convert from sequence\nfunction {:spec} fromSeq<T>(s: seq<T>): LinkedList<T>\n{\n  if |s| == 0 then Nil\n  else Cons(s[0], fromSeq(s[1..]))\n}\n\n// Map function over list\nfunction {:spec} listMap<T, U>(list: LinkedList<T>, f: T -> U): LinkedList<U>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => Cons(f(h), listMap(t, f))\n}\n\n// Filter list with predicate\nfunction {:spec} filter<T>(list: LinkedList<T>, p: T -> bool): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) =>\n    if p(h) then Cons(h, filter(t, p))\n    else filter(t, p)\n}\n\n// Take first n elements\nfunction {:spec} take<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n{\n  if n == 0 then Nil\n  else match list\n    case Nil => Nil\n    case Cons(h, t) => Cons(h, take(t, n - 1))\n}\n\n// Drop first n elements\nfunction {:spec} drop<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n  decreases list\n{\n  if n == 0 then list\n  else match list\n    case Nil => Nil\n    case Cons(_, t) => drop(t, n - 1)\n}\n\n// Check if list is palindrome\npredicate {:spec} isPalindrome<T(==)>(list: LinkedList<T>)\n{\n  toSeq(list) == toSeq(reverse(list))\n}\n\n// --- Lemmas for correctness ---\n\nlemma LengthAppend<T>(l1: LinkedList<T>, l2: LinkedList<T>)\n  ensures length(append(l1, l2)) == length(l1) + length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) =>\n    LengthAppend(t, l2);\n}\n\nlemma AppendNil<T>(list: LinkedList<T>)\n  ensures append(list, Nil) == list\n  ensures append(Nil, list) == list\n{\n  match list\n  case Nil =>\n  case Cons(_, t) =>\n    AppendNil(t);\n}\n\nlemma AppendAssociative<T>(l1: LinkedList<T>, l2: LinkedList<T>, l3: LinkedList<T>)\n  ensures append(append(l1, l2), l3) == append(l1, append(l2, l3))\n{\n  match l1\n  case Nil =>\n  case Cons(h, t) =>\n    AppendAssociative(t, l2, l3);\n}\n\nlemma ReverseLength<T>(list: LinkedList<T>)\n  ensures length(reverse(list)) == length(list)\n{\n  ReverseHelperLength(list, Nil);\n}\n\nlemma ReverseHelperLength<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures length(reverseHelper(list, acc)) == length(list) + length(acc)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    calc == {\n      length(reverseHelper(list, acc));\n      length(reverseHelper(t, Cons(h, acc)));\n      { ReverseHelperLength(t, Cons(h, acc)); }\n      length(t) + length(Cons(h, acc));\n      length(t) + 1 + length(acc);\n      length(list) + length(acc);\n    }\n}\n\nlemma ReverseReverse<T>(list: LinkedList<T>)\n  ensures reverse(reverse(list)) == list\n{\n  ReverseReverseHelper(list, Nil);\n}\n\nlemma ReverseReverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures reverseHelper(reverseHelper(list, acc), Nil) == reverseHelper(acc, list)\n{\n  match list\n  case Nil =>\n    assert reverseHelper(reverseHelper(Nil, acc), Nil) == reverseHelper(acc, Nil);\n  case Cons(h, t) =>\n    calc == {\n      reverseHelper(reverseHelper(Cons(h, t), acc), Nil);\n      reverseHelper(reverseHelper(t, Cons(h, acc)), Nil);\n      { ReverseReverseHelper(t, Cons(h, acc)); }\n      reverseHelper(Cons(h, acc), t);\n      reverseHelper(acc, Cons(h, t));\n    }\n}\n\nlemma ToSeqFromSeq<T>(s: seq<T>)\n  ensures toSeq(fromSeq(s)) == s\n{\n  if |s| == 0 {\n    assert fromSeq(s) == Nil;\n  } else {\n    ToSeqFromSeq(s[1..]);\n    assert toSeq(fromSeq(s)) == [s[0]] + toSeq(fromSeq(s[1..]));\n  }\n}\n\nlemma FromSeqToSeq<T>(list: LinkedList<T>)\n  ensures fromSeq(toSeq(list)) == list\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    FromSeqToSeq(t);\n}\n\nlemma NthCorrect<T>(list: LinkedList<T>, n: nat)\n  requires n < length(list)\n  ensures |toSeq(list)| > n\n  ensures toSeq(list)[n] == nth(list, n)\n{\n  match list\n  case Cons(h, t) =>\n    if n == 0 {\n      assert toSeq(list)[0] == h;\n    } else {\n      NthCorrect(t, n - 1);\n    }\n}\n\nlemma MapLength<T, U>(list: LinkedList<T>, f: T -> U)\n  ensures length(listMap(list, f)) == length(list)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    MapLength(t, f);\n}\n\nlemma FilterSubset<T>(list: LinkedList<T>, p: T -> bool)\n  ensures length(filter(list, p)) <= length(list)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    FilterSubset(t, p);\n    if p(h) {\n      assert length(filter(list, p)) == 1 + length(filter(t, p));\n    } else {\n      assert length(filter(list, p)) == length(filter(t, p));\n    }\n}\n\nlemma TakeDropConcat<T>(list: LinkedList<T>, n: nat)\n  ensures append(take(list, n), drop(list, n)) == list\n{\n  if n == 0 {\n    \n/*[CODE HERE]*/\n    assert drop(list, 0) == list;\n    AppendNil(list);\n  } else {\n    match list\n    case Nil =>\n    case Cons(h, t) =>\n      TakeDropConcat(t, n - 1);\n      calc == {\n        append(take(list, n), drop(list, n));\n        append(Cons(h, take(t, n - 1)), drop(t, n - 1));\n        Cons(h, append(take(t, n - 1), drop(t, n - 1)));\n        Cons(h, t);\n        list;\n      }\n  }\n}\n\nlemma RemoveDecreasesLength<T>(list: LinkedList<T>, x: T)\n  requires contains(list, x)\n  ensures length(remove(list, x)) == length(list) - 1\n{\n  match list\n  case Cons(h, t) =>\n    if h == x {\n      assert remove(list, x) == t;\n    } else {\n      assert contains(t, x);\n      RemoveDecreasesLength(t, x);\n    }\n}\n\nlemma InsertAtLength<T>(list: LinkedList<T>, x: T, pos: nat)\n  ensures length(insertAt(list, x, pos)) == length(list) + 1\n{\n  if pos == 0 {\n    assert insertAt(list, x, 0) == Cons(x, list);\n  } else {\n    match list\n    case Nil =>\n      assert insertAt(Nil, x, pos) == Cons(x, Nil);\n    case Cons(h, t) =>\n      InsertAtLength(t, x, pos - 1);\n  }\n}", "output": "assert take(list, 0) == Nil;"}, {"id": "example_RemoveDecreasesLength_0", "type": "call", "program": "// Linked list operations: insert, delete, reverse, cycle detection\n\ndatatype LinkedList<T> = Nil | Cons(head: T, tail: LinkedList<T>)\n\n// Length of linked list\nfunction {:spec} length<T>(list: LinkedList<T>): nat\n{\n  match list\n  case Nil => 0\n  case Cons(_, tail) => 1 + length(tail)\n}\n\n// Append two linked lists\nfunction {:spec} append<T>(l1: LinkedList<T>, l2: LinkedList<T>): LinkedList<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, append(t, l2))\n}\n\n// Reverse a linked list\nfunction {:spec} reverse<T>(list: LinkedList<T>): LinkedList<T>\n{\n  reverseHelper(list, Nil)\n}\n\nfunction reverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>): LinkedList<T>\n{\n  match list\n  case Nil => acc\n  case Cons(h, t) => reverseHelper(t, Cons(h, acc))\n}\n\n// Get nth element (0-indexed)\nfunction {:spec} nth<T>(list: LinkedList<T>, n: nat): T\n  requires n < length(list)\n{\n  match list\n  case Cons(h, t) => if n == 0 then h else nth(t, n - 1)\n}\n\n// Check if element exists in list\npredicate {:spec} contains<T(==)>(list: LinkedList<T>, x: T)\n{\n  match list\n  case Nil => false\n  case Cons(h, t) => h == x || contains(t, x)\n}\n\n// Remove first occurrence of element\nfunction {:spec} remove<T(==)>(list: LinkedList<T>, x: T): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => if h == x then t else Cons(h, remove(t, x))\n}\n\n// Insert at position\nfunction {:spec} insertAt<T>(list: LinkedList<T>, x: T, pos: nat): LinkedList<T>\n{\n  if pos == 0 then Cons(x, list)\n  else match list\n    case Nil => Cons(x, Nil)\n    case Cons(h, t) => Cons(h, insertAt(t, x, pos - 1))\n}\n\n// Convert to sequence\nfunction {:spec} toSeq<T>(list: LinkedList<T>): seq<T>\n{\n  match list\n  case Nil => []\n  case Cons(h, t) => [h] + toSeq(t)\n}\n\n// Convert from sequence\nfunction {:spec} fromSeq<T>(s: seq<T>): LinkedList<T>\n{\n  if |s| == 0 then Nil\n  else Cons(s[0], fromSeq(s[1..]))\n}\n\n// Map function over list\nfunction {:spec} listMap<T, U>(list: LinkedList<T>, f: T -> U): LinkedList<U>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => Cons(f(h), listMap(t, f))\n}\n\n// Filter list with predicate\nfunction {:spec} filter<T>(list: LinkedList<T>, p: T -> bool): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) =>\n    if p(h) then Cons(h, filter(t, p))\n    else filter(t, p)\n}\n\n// Take first n elements\nfunction {:spec} take<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n{\n  if n == 0 then Nil\n  else match list\n    case Nil => Nil\n    case Cons(h, t) => Cons(h, take(t, n - 1))\n}\n\n// Drop first n elements\nfunction {:spec} drop<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n  decreases list\n{\n  if n == 0 then list\n  else match list\n    case Nil => Nil\n    case Cons(_, t) => drop(t, n - 1)\n}\n\n// Check if list is palindrome\npredicate {:spec} isPalindrome<T(==)>(list: LinkedList<T>)\n{\n  toSeq(list) == toSeq(reverse(list))\n}\n\n// --- Lemmas for correctness ---\n\nlemma LengthAppend<T>(l1: LinkedList<T>, l2: LinkedList<T>)\n  ensures length(append(l1, l2)) == length(l1) + length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) =>\n    LengthAppend(t, l2);\n}\n\nlemma AppendNil<T>(list: LinkedList<T>)\n  ensures append(list, Nil) == list\n  ensures append(Nil, list) == list\n{\n  match list\n  case Nil =>\n  case Cons(_, t) =>\n    AppendNil(t);\n}\n\nlemma AppendAssociative<T>(l1: LinkedList<T>, l2: LinkedList<T>, l3: LinkedList<T>)\n  ensures append(append(l1, l2), l3) == append(l1, append(l2, l3))\n{\n  match l1\n  case Nil =>\n  case Cons(h, t) =>\n    AppendAssociative(t, l2, l3);\n}\n\nlemma ReverseLength<T>(list: LinkedList<T>)\n  ensures length(reverse(list)) == length(list)\n{\n  ReverseHelperLength(list, Nil);\n}\n\nlemma ReverseHelperLength<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures length(reverseHelper(list, acc)) == length(list) + length(acc)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    calc == {\n      length(reverseHelper(list, acc));\n      length(reverseHelper(t, Cons(h, acc)));\n      { ReverseHelperLength(t, Cons(h, acc)); }\n      length(t) + length(Cons(h, acc));\n      length(t) + 1 + length(acc);\n      length(list) + length(acc);\n    }\n}\n\nlemma ReverseReverse<T>(list: LinkedList<T>)\n  ensures reverse(reverse(list)) == list\n{\n  ReverseReverseHelper(list, Nil);\n}\n\nlemma ReverseReverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures reverseHelper(reverseHelper(list, acc), Nil) == reverseHelper(acc, list)\n{\n  match list\n  case Nil =>\n    assert reverseHelper(reverseHelper(Nil, acc), Nil) == reverseHelper(acc, Nil);\n  case Cons(h, t) =>\n    calc == {\n      reverseHelper(reverseHelper(Cons(h, t), acc), Nil);\n      reverseHelper(reverseHelper(t, Cons(h, acc)), Nil);\n      { ReverseReverseHelper(t, Cons(h, acc)); }\n      reverseHelper(Cons(h, acc), t);\n      reverseHelper(acc, Cons(h, t));\n    }\n}\n\nlemma ToSeqFromSeq<T>(s: seq<T>)\n  ensures toSeq(fromSeq(s)) == s\n{\n  if |s| == 0 {\n    assert fromSeq(s) == Nil;\n  } else {\n    ToSeqFromSeq(s[1..]);\n    assert toSeq(fromSeq(s)) == [s[0]] + toSeq(fromSeq(s[1..]));\n  }\n}\n\nlemma FromSeqToSeq<T>(list: LinkedList<T>)\n  ensures fromSeq(toSeq(list)) == list\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    FromSeqToSeq(t);\n}\n\nlemma NthCorrect<T>(list: LinkedList<T>, n: nat)\n  requires n < length(list)\n  ensures |toSeq(list)| > n\n  ensures toSeq(list)[n] == nth(list, n)\n{\n  match list\n  case Cons(h, t) =>\n    if n == 0 {\n      assert toSeq(list)[0] == h;\n    } else {\n      NthCorrect(t, n - 1);\n    }\n}\n\nlemma MapLength<T, U>(list: LinkedList<T>, f: T -> U)\n  ensures length(listMap(list, f)) == length(list)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    MapLength(t, f);\n}\n\nlemma FilterSubset<T>(list: LinkedList<T>, p: T -> bool)\n  ensures length(filter(list, p)) <= length(list)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    FilterSubset(t, p);\n    if p(h) {\n      assert length(filter(list, p)) == 1 + length(filter(t, p));\n    } else {\n      assert length(filter(list, p)) == length(filter(t, p));\n    }\n}\n\nlemma TakeDropConcat<T>(list: LinkedList<T>, n: nat)\n  ensures append(take(list, n), drop(list, n)) == list\n{\n  if n == 0 {\n    assert take(list, 0) == Nil;\n    assert drop(list, 0) == list;\n    AppendNil(list);\n  } else {\n    match list\n    case Nil =>\n    case Cons(h, t) =>\n      TakeDropConcat(t, n - 1);\n      calc == {\n        append(take(list, n), drop(list, n));\n        append(Cons(h, take(t, n - 1)), drop(t, n - 1));\n        Cons(h, append(take(t, n - 1), drop(t, n - 1)));\n        Cons(h, t);\n        list;\n      }\n  }\n}\n\nlemma RemoveDecreasesLength<T>(list: LinkedList<T>, x: T)\n  requires contains(list, x)\n  ensures length(remove(list, x)) == length(list) - 1\n{\n  match list\n  case Cons(h, t) =>\n    if h == x {\n      assert remove(list, x) == t;\n    } else {\n      assert contains(t, x);\n      \n/*[CODE HERE]*/\n    }\n}\n\nlemma InsertAtLength<T>(list: LinkedList<T>, x: T, pos: nat)\n  ensures length(insertAt(list, x, pos)) == length(list) + 1\n{\n  if pos == 0 {\n    assert insertAt(list, x, 0) == Cons(x, list);\n  } else {\n    match list\n    case Nil =>\n      assert insertAt(Nil, x, pos) == Cons(x, Nil);\n    case Cons(h, t) =>\n      InsertAtLength(t, x, pos - 1);\n  }\n}", "output": "RemoveDecreasesLength(t, x);"}, {"id": "example_RemoveDecreasesLength_1", "type": "assert", "program": "// Linked list operations: insert, delete, reverse, cycle detection\n\ndatatype LinkedList<T> = Nil | Cons(head: T, tail: LinkedList<T>)\n\n// Length of linked list\nfunction {:spec} length<T>(list: LinkedList<T>): nat\n{\n  match list\n  case Nil => 0\n  case Cons(_, tail) => 1 + length(tail)\n}\n\n// Append two linked lists\nfunction {:spec} append<T>(l1: LinkedList<T>, l2: LinkedList<T>): LinkedList<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, append(t, l2))\n}\n\n// Reverse a linked list\nfunction {:spec} reverse<T>(list: LinkedList<T>): LinkedList<T>\n{\n  reverseHelper(list, Nil)\n}\n\nfunction reverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>): LinkedList<T>\n{\n  match list\n  case Nil => acc\n  case Cons(h, t) => reverseHelper(t, Cons(h, acc))\n}\n\n// Get nth element (0-indexed)\nfunction {:spec} nth<T>(list: LinkedList<T>, n: nat): T\n  requires n < length(list)\n{\n  match list\n  case Cons(h, t) => if n == 0 then h else nth(t, n - 1)\n}\n\n// Check if element exists in list\npredicate {:spec} contains<T(==)>(list: LinkedList<T>, x: T)\n{\n  match list\n  case Nil => false\n  case Cons(h, t) => h == x || contains(t, x)\n}\n\n// Remove first occurrence of element\nfunction {:spec} remove<T(==)>(list: LinkedList<T>, x: T): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => if h == x then t else Cons(h, remove(t, x))\n}\n\n// Insert at position\nfunction {:spec} insertAt<T>(list: LinkedList<T>, x: T, pos: nat): LinkedList<T>\n{\n  if pos == 0 then Cons(x, list)\n  else match list\n    case Nil => Cons(x, Nil)\n    case Cons(h, t) => Cons(h, insertAt(t, x, pos - 1))\n}\n\n// Convert to sequence\nfunction {:spec} toSeq<T>(list: LinkedList<T>): seq<T>\n{\n  match list\n  case Nil => []\n  case Cons(h, t) => [h] + toSeq(t)\n}\n\n// Convert from sequence\nfunction {:spec} fromSeq<T>(s: seq<T>): LinkedList<T>\n{\n  if |s| == 0 then Nil\n  else Cons(s[0], fromSeq(s[1..]))\n}\n\n// Map function over list\nfunction {:spec} listMap<T, U>(list: LinkedList<T>, f: T -> U): LinkedList<U>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => Cons(f(h), listMap(t, f))\n}\n\n// Filter list with predicate\nfunction {:spec} filter<T>(list: LinkedList<T>, p: T -> bool): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) =>\n    if p(h) then Cons(h, filter(t, p))\n    else filter(t, p)\n}\n\n// Take first n elements\nfunction {:spec} take<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n{\n  if n == 0 then Nil\n  else match list\n    case Nil => Nil\n    case Cons(h, t) => Cons(h, take(t, n - 1))\n}\n\n// Drop first n elements\nfunction {:spec} drop<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n  decreases list\n{\n  if n == 0 then list\n  else match list\n    case Nil => Nil\n    case Cons(_, t) => drop(t, n - 1)\n}\n\n// Check if list is palindrome\npredicate {:spec} isPalindrome<T(==)>(list: LinkedList<T>)\n{\n  toSeq(list) == toSeq(reverse(list))\n}\n\n// --- Lemmas for correctness ---\n\nlemma LengthAppend<T>(l1: LinkedList<T>, l2: LinkedList<T>)\n  ensures length(append(l1, l2)) == length(l1) + length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) =>\n    LengthAppend(t, l2);\n}\n\nlemma AppendNil<T>(list: LinkedList<T>)\n  ensures append(list, Nil) == list\n  ensures append(Nil, list) == list\n{\n  match list\n  case Nil =>\n  case Cons(_, t) =>\n    AppendNil(t);\n}\n\nlemma AppendAssociative<T>(l1: LinkedList<T>, l2: LinkedList<T>, l3: LinkedList<T>)\n  ensures append(append(l1, l2), l3) == append(l1, append(l2, l3))\n{\n  match l1\n  case Nil =>\n  case Cons(h, t) =>\n    AppendAssociative(t, l2, l3);\n}\n\nlemma ReverseLength<T>(list: LinkedList<T>)\n  ensures length(reverse(list)) == length(list)\n{\n  ReverseHelperLength(list, Nil);\n}\n\nlemma ReverseHelperLength<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures length(reverseHelper(list, acc)) == length(list) + length(acc)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    calc == {\n      length(reverseHelper(list, acc));\n      length(reverseHelper(t, Cons(h, acc)));\n      { ReverseHelperLength(t, Cons(h, acc)); }\n      length(t) + length(Cons(h, acc));\n      length(t) + 1 + length(acc);\n      length(list) + length(acc);\n    }\n}\n\nlemma ReverseReverse<T>(list: LinkedList<T>)\n  ensures reverse(reverse(list)) == list\n{\n  ReverseReverseHelper(list, Nil);\n}\n\nlemma ReverseReverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures reverseHelper(reverseHelper(list, acc), Nil) == reverseHelper(acc, list)\n{\n  match list\n  case Nil =>\n    assert reverseHelper(reverseHelper(Nil, acc), Nil) == reverseHelper(acc, Nil);\n  case Cons(h, t) =>\n    calc == {\n      reverseHelper(reverseHelper(Cons(h, t), acc), Nil);\n      reverseHelper(reverseHelper(t, Cons(h, acc)), Nil);\n      { ReverseReverseHelper(t, Cons(h, acc)); }\n      reverseHelper(Cons(h, acc), t);\n      reverseHelper(acc, Cons(h, t));\n    }\n}\n\nlemma ToSeqFromSeq<T>(s: seq<T>)\n  ensures toSeq(fromSeq(s)) == s\n{\n  if |s| == 0 {\n    assert fromSeq(s) == Nil;\n  } else {\n    ToSeqFromSeq(s[1..]);\n    assert toSeq(fromSeq(s)) == [s[0]] + toSeq(fromSeq(s[1..]));\n  }\n}\n\nlemma FromSeqToSeq<T>(list: LinkedList<T>)\n  ensures fromSeq(toSeq(list)) == list\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    FromSeqToSeq(t);\n}\n\nlemma NthCorrect<T>(list: LinkedList<T>, n: nat)\n  requires n < length(list)\n  ensures |toSeq(list)| > n\n  ensures toSeq(list)[n] == nth(list, n)\n{\n  match list\n  case Cons(h, t) =>\n    if n == 0 {\n      assert toSeq(list)[0] == h;\n    } else {\n      NthCorrect(t, n - 1);\n    }\n}\n\nlemma MapLength<T, U>(list: LinkedList<T>, f: T -> U)\n  ensures length(listMap(list, f)) == length(list)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    MapLength(t, f);\n}\n\nlemma FilterSubset<T>(list: LinkedList<T>, p: T -> bool)\n  ensures length(filter(list, p)) <= length(list)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    FilterSubset(t, p);\n    if p(h) {\n      assert length(filter(list, p)) == 1 + length(filter(t, p));\n    } else {\n      assert length(filter(list, p)) == length(filter(t, p));\n    }\n}\n\nlemma TakeDropConcat<T>(list: LinkedList<T>, n: nat)\n  ensures append(take(list, n), drop(list, n)) == list\n{\n  if n == 0 {\n    assert take(list, 0) == Nil;\n    assert drop(list, 0) == list;\n    AppendNil(list);\n  } else {\n    match list\n    case Nil =>\n    case Cons(h, t) =>\n      TakeDropConcat(t, n - 1);\n      calc == {\n        append(take(list, n), drop(list, n));\n        append(Cons(h, take(t, n - 1)), drop(t, n - 1));\n        Cons(h, append(take(t, n - 1), drop(t, n - 1)));\n        Cons(h, t);\n        list;\n      }\n  }\n}\n\nlemma RemoveDecreasesLength<T>(list: LinkedList<T>, x: T)\n  requires contains(list, x)\n  ensures length(remove(list, x)) == length(list) - 1\n{\n  match list\n  case Cons(h, t) =>\n    if h == x {\n      assert remove(list, x) == t;\n    } else {\n      \n/*[CODE HERE]*/\n      RemoveDecreasesLength(t, x);\n    }\n}\n\nlemma InsertAtLength<T>(list: LinkedList<T>, x: T, pos: nat)\n  ensures length(insertAt(list, x, pos)) == length(list) + 1\n{\n  if pos == 0 {\n    assert insertAt(list, x, 0) == Cons(x, list);\n  } else {\n    match list\n    case Nil =>\n      assert insertAt(Nil, x, pos) == Cons(x, Nil);\n    case Cons(h, t) =>\n      InsertAtLength(t, x, pos - 1);\n  }\n}", "output": "assert contains(t, x);"}, {"id": "example_RemoveDecreasesLength_2", "type": "assert", "program": "// Linked list operations: insert, delete, reverse, cycle detection\n\ndatatype LinkedList<T> = Nil | Cons(head: T, tail: LinkedList<T>)\n\n// Length of linked list\nfunction {:spec} length<T>(list: LinkedList<T>): nat\n{\n  match list\n  case Nil => 0\n  case Cons(_, tail) => 1 + length(tail)\n}\n\n// Append two linked lists\nfunction {:spec} append<T>(l1: LinkedList<T>, l2: LinkedList<T>): LinkedList<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, append(t, l2))\n}\n\n// Reverse a linked list\nfunction {:spec} reverse<T>(list: LinkedList<T>): LinkedList<T>\n{\n  reverseHelper(list, Nil)\n}\n\nfunction reverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>): LinkedList<T>\n{\n  match list\n  case Nil => acc\n  case Cons(h, t) => reverseHelper(t, Cons(h, acc))\n}\n\n// Get nth element (0-indexed)\nfunction {:spec} nth<T>(list: LinkedList<T>, n: nat): T\n  requires n < length(list)\n{\n  match list\n  case Cons(h, t) => if n == 0 then h else nth(t, n - 1)\n}\n\n// Check if element exists in list\npredicate {:spec} contains<T(==)>(list: LinkedList<T>, x: T)\n{\n  match list\n  case Nil => false\n  case Cons(h, t) => h == x || contains(t, x)\n}\n\n// Remove first occurrence of element\nfunction {:spec} remove<T(==)>(list: LinkedList<T>, x: T): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => if h == x then t else Cons(h, remove(t, x))\n}\n\n// Insert at position\nfunction {:spec} insertAt<T>(list: LinkedList<T>, x: T, pos: nat): LinkedList<T>\n{\n  if pos == 0 then Cons(x, list)\n  else match list\n    case Nil => Cons(x, Nil)\n    case Cons(h, t) => Cons(h, insertAt(t, x, pos - 1))\n}\n\n// Convert to sequence\nfunction {:spec} toSeq<T>(list: LinkedList<T>): seq<T>\n{\n  match list\n  case Nil => []\n  case Cons(h, t) => [h] + toSeq(t)\n}\n\n// Convert from sequence\nfunction {:spec} fromSeq<T>(s: seq<T>): LinkedList<T>\n{\n  if |s| == 0 then Nil\n  else Cons(s[0], fromSeq(s[1..]))\n}\n\n// Map function over list\nfunction {:spec} listMap<T, U>(list: LinkedList<T>, f: T -> U): LinkedList<U>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => Cons(f(h), listMap(t, f))\n}\n\n// Filter list with predicate\nfunction {:spec} filter<T>(list: LinkedList<T>, p: T -> bool): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) =>\n    if p(h) then Cons(h, filter(t, p))\n    else filter(t, p)\n}\n\n// Take first n elements\nfunction {:spec} take<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n{\n  if n == 0 then Nil\n  else match list\n    case Nil => Nil\n    case Cons(h, t) => Cons(h, take(t, n - 1))\n}\n\n// Drop first n elements\nfunction {:spec} drop<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n  decreases list\n{\n  if n == 0 then list\n  else match list\n    case Nil => Nil\n    case Cons(_, t) => drop(t, n - 1)\n}\n\n// Check if list is palindrome\npredicate {:spec} isPalindrome<T(==)>(list: LinkedList<T>)\n{\n  toSeq(list) == toSeq(reverse(list))\n}\n\n// --- Lemmas for correctness ---\n\nlemma LengthAppend<T>(l1: LinkedList<T>, l2: LinkedList<T>)\n  ensures length(append(l1, l2)) == length(l1) + length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) =>\n    LengthAppend(t, l2);\n}\n\nlemma AppendNil<T>(list: LinkedList<T>)\n  ensures append(list, Nil) == list\n  ensures append(Nil, list) == list\n{\n  match list\n  case Nil =>\n  case Cons(_, t) =>\n    AppendNil(t);\n}\n\nlemma AppendAssociative<T>(l1: LinkedList<T>, l2: LinkedList<T>, l3: LinkedList<T>)\n  ensures append(append(l1, l2), l3) == append(l1, append(l2, l3))\n{\n  match l1\n  case Nil =>\n  case Cons(h, t) =>\n    AppendAssociative(t, l2, l3);\n}\n\nlemma ReverseLength<T>(list: LinkedList<T>)\n  ensures length(reverse(list)) == length(list)\n{\n  ReverseHelperLength(list, Nil);\n}\n\nlemma ReverseHelperLength<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures length(reverseHelper(list, acc)) == length(list) + length(acc)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    calc == {\n      length(reverseHelper(list, acc));\n      length(reverseHelper(t, Cons(h, acc)));\n      { ReverseHelperLength(t, Cons(h, acc)); }\n      length(t) + length(Cons(h, acc));\n      length(t) + 1 + length(acc);\n      length(list) + length(acc);\n    }\n}\n\nlemma ReverseReverse<T>(list: LinkedList<T>)\n  ensures reverse(reverse(list)) == list\n{\n  ReverseReverseHelper(list, Nil);\n}\n\nlemma ReverseReverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures reverseHelper(reverseHelper(list, acc), Nil) == reverseHelper(acc, list)\n{\n  match list\n  case Nil =>\n    assert reverseHelper(reverseHelper(Nil, acc), Nil) == reverseHelper(acc, Nil);\n  case Cons(h, t) =>\n    calc == {\n      reverseHelper(reverseHelper(Cons(h, t), acc), Nil);\n      reverseHelper(reverseHelper(t, Cons(h, acc)), Nil);\n      { ReverseReverseHelper(t, Cons(h, acc)); }\n      reverseHelper(Cons(h, acc), t);\n      reverseHelper(acc, Cons(h, t));\n    }\n}\n\nlemma ToSeqFromSeq<T>(s: seq<T>)\n  ensures toSeq(fromSeq(s)) == s\n{\n  if |s| == 0 {\n    assert fromSeq(s) == Nil;\n  } else {\n    ToSeqFromSeq(s[1..]);\n    assert toSeq(fromSeq(s)) == [s[0]] + toSeq(fromSeq(s[1..]));\n  }\n}\n\nlemma FromSeqToSeq<T>(list: LinkedList<T>)\n  ensures fromSeq(toSeq(list)) == list\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    FromSeqToSeq(t);\n}\n\nlemma NthCorrect<T>(list: LinkedList<T>, n: nat)\n  requires n < length(list)\n  ensures |toSeq(list)| > n\n  ensures toSeq(list)[n] == nth(list, n)\n{\n  match list\n  case Cons(h, t) =>\n    if n == 0 {\n      assert toSeq(list)[0] == h;\n    } else {\n      NthCorrect(t, n - 1);\n    }\n}\n\nlemma MapLength<T, U>(list: LinkedList<T>, f: T -> U)\n  ensures length(listMap(list, f)) == length(list)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    MapLength(t, f);\n}\n\nlemma FilterSubset<T>(list: LinkedList<T>, p: T -> bool)\n  ensures length(filter(list, p)) <= length(list)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    FilterSubset(t, p);\n    if p(h) {\n      assert length(filter(list, p)) == 1 + length(filter(t, p));\n    } else {\n      assert length(filter(list, p)) == length(filter(t, p));\n    }\n}\n\nlemma TakeDropConcat<T>(list: LinkedList<T>, n: nat)\n  ensures append(take(list, n), drop(list, n)) == list\n{\n  if n == 0 {\n    assert take(list, 0) == Nil;\n    assert drop(list, 0) == list;\n    AppendNil(list);\n  } else {\n    match list\n    case Nil =>\n    case Cons(h, t) =>\n      TakeDropConcat(t, n - 1);\n      calc == {\n        append(take(list, n), drop(list, n));\n        append(Cons(h, take(t, n - 1)), drop(t, n - 1));\n        Cons(h, append(take(t, n - 1), drop(t, n - 1)));\n        Cons(h, t);\n        list;\n      }\n  }\n}\n\nlemma RemoveDecreasesLength<T>(list: LinkedList<T>, x: T)\n  requires contains(list, x)\n  ensures length(remove(list, x)) == length(list) - 1\n{\n  match list\n  case Cons(h, t) =>\n    if h == x {\n      \n/*[CODE HERE]*/\n    } else {\n      assert contains(t, x);\n      RemoveDecreasesLength(t, x);\n    }\n}\n\nlemma InsertAtLength<T>(list: LinkedList<T>, x: T, pos: nat)\n  ensures length(insertAt(list, x, pos)) == length(list) + 1\n{\n  if pos == 0 {\n    assert insertAt(list, x, 0) == Cons(x, list);\n  } else {\n    match list\n    case Nil =>\n      assert insertAt(Nil, x, pos) == Cons(x, Nil);\n    case Cons(h, t) =>\n      InsertAtLength(t, x, pos - 1);\n  }\n}", "output": "assert remove(list, x) == t;"}, {"id": "example_InsertAtLength_0", "type": "call", "program": "// Linked list operations: insert, delete, reverse, cycle detection\n\ndatatype LinkedList<T> = Nil | Cons(head: T, tail: LinkedList<T>)\n\n// Length of linked list\nfunction {:spec} length<T>(list: LinkedList<T>): nat\n{\n  match list\n  case Nil => 0\n  case Cons(_, tail) => 1 + length(tail)\n}\n\n// Append two linked lists\nfunction {:spec} append<T>(l1: LinkedList<T>, l2: LinkedList<T>): LinkedList<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, append(t, l2))\n}\n\n// Reverse a linked list\nfunction {:spec} reverse<T>(list: LinkedList<T>): LinkedList<T>\n{\n  reverseHelper(list, Nil)\n}\n\nfunction reverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>): LinkedList<T>\n{\n  match list\n  case Nil => acc\n  case Cons(h, t) => reverseHelper(t, Cons(h, acc))\n}\n\n// Get nth element (0-indexed)\nfunction {:spec} nth<T>(list: LinkedList<T>, n: nat): T\n  requires n < length(list)\n{\n  match list\n  case Cons(h, t) => if n == 0 then h else nth(t, n - 1)\n}\n\n// Check if element exists in list\npredicate {:spec} contains<T(==)>(list: LinkedList<T>, x: T)\n{\n  match list\n  case Nil => false\n  case Cons(h, t) => h == x || contains(t, x)\n}\n\n// Remove first occurrence of element\nfunction {:spec} remove<T(==)>(list: LinkedList<T>, x: T): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => if h == x then t else Cons(h, remove(t, x))\n}\n\n// Insert at position\nfunction {:spec} insertAt<T>(list: LinkedList<T>, x: T, pos: nat): LinkedList<T>\n{\n  if pos == 0 then Cons(x, list)\n  else match list\n    case Nil => Cons(x, Nil)\n    case Cons(h, t) => Cons(h, insertAt(t, x, pos - 1))\n}\n\n// Convert to sequence\nfunction {:spec} toSeq<T>(list: LinkedList<T>): seq<T>\n{\n  match list\n  case Nil => []\n  case Cons(h, t) => [h] + toSeq(t)\n}\n\n// Convert from sequence\nfunction {:spec} fromSeq<T>(s: seq<T>): LinkedList<T>\n{\n  if |s| == 0 then Nil\n  else Cons(s[0], fromSeq(s[1..]))\n}\n\n// Map function over list\nfunction {:spec} listMap<T, U>(list: LinkedList<T>, f: T -> U): LinkedList<U>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => Cons(f(h), listMap(t, f))\n}\n\n// Filter list with predicate\nfunction {:spec} filter<T>(list: LinkedList<T>, p: T -> bool): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) =>\n    if p(h) then Cons(h, filter(t, p))\n    else filter(t, p)\n}\n\n// Take first n elements\nfunction {:spec} take<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n{\n  if n == 0 then Nil\n  else match list\n    case Nil => Nil\n    case Cons(h, t) => Cons(h, take(t, n - 1))\n}\n\n// Drop first n elements\nfunction {:spec} drop<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n  decreases list\n{\n  if n == 0 then list\n  else match list\n    case Nil => Nil\n    case Cons(_, t) => drop(t, n - 1)\n}\n\n// Check if list is palindrome\npredicate {:spec} isPalindrome<T(==)>(list: LinkedList<T>)\n{\n  toSeq(list) == toSeq(reverse(list))\n}\n\n// --- Lemmas for correctness ---\n\nlemma LengthAppend<T>(l1: LinkedList<T>, l2: LinkedList<T>)\n  ensures length(append(l1, l2)) == length(l1) + length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) =>\n    LengthAppend(t, l2);\n}\n\nlemma AppendNil<T>(list: LinkedList<T>)\n  ensures append(list, Nil) == list\n  ensures append(Nil, list) == list\n{\n  match list\n  case Nil =>\n  case Cons(_, t) =>\n    AppendNil(t);\n}\n\nlemma AppendAssociative<T>(l1: LinkedList<T>, l2: LinkedList<T>, l3: LinkedList<T>)\n  ensures append(append(l1, l2), l3) == append(l1, append(l2, l3))\n{\n  match l1\n  case Nil =>\n  case Cons(h, t) =>\n    AppendAssociative(t, l2, l3);\n}\n\nlemma ReverseLength<T>(list: LinkedList<T>)\n  ensures length(reverse(list)) == length(list)\n{\n  ReverseHelperLength(list, Nil);\n}\n\nlemma ReverseHelperLength<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures length(reverseHelper(list, acc)) == length(list) + length(acc)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    calc == {\n      length(reverseHelper(list, acc));\n      length(reverseHelper(t, Cons(h, acc)));\n      { ReverseHelperLength(t, Cons(h, acc)); }\n      length(t) + length(Cons(h, acc));\n      length(t) + 1 + length(acc);\n      length(list) + length(acc);\n    }\n}\n\nlemma ReverseReverse<T>(list: LinkedList<T>)\n  ensures reverse(reverse(list)) == list\n{\n  ReverseReverseHelper(list, Nil);\n}\n\nlemma ReverseReverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures reverseHelper(reverseHelper(list, acc), Nil) == reverseHelper(acc, list)\n{\n  match list\n  case Nil =>\n    assert reverseHelper(reverseHelper(Nil, acc), Nil) == reverseHelper(acc, Nil);\n  case Cons(h, t) =>\n    calc == {\n      reverseHelper(reverseHelper(Cons(h, t), acc), Nil);\n      reverseHelper(reverseHelper(t, Cons(h, acc)), Nil);\n      { ReverseReverseHelper(t, Cons(h, acc)); }\n      reverseHelper(Cons(h, acc), t);\n      reverseHelper(acc, Cons(h, t));\n    }\n}\n\nlemma ToSeqFromSeq<T>(s: seq<T>)\n  ensures toSeq(fromSeq(s)) == s\n{\n  if |s| == 0 {\n    assert fromSeq(s) == Nil;\n  } else {\n    ToSeqFromSeq(s[1..]);\n    assert toSeq(fromSeq(s)) == [s[0]] + toSeq(fromSeq(s[1..]));\n  }\n}\n\nlemma FromSeqToSeq<T>(list: LinkedList<T>)\n  ensures fromSeq(toSeq(list)) == list\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    FromSeqToSeq(t);\n}\n\nlemma NthCorrect<T>(list: LinkedList<T>, n: nat)\n  requires n < length(list)\n  ensures |toSeq(list)| > n\n  ensures toSeq(list)[n] == nth(list, n)\n{\n  match list\n  case Cons(h, t) =>\n    if n == 0 {\n      assert toSeq(list)[0] == h;\n    } else {\n      NthCorrect(t, n - 1);\n    }\n}\n\nlemma MapLength<T, U>(list: LinkedList<T>, f: T -> U)\n  ensures length(listMap(list, f)) == length(list)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    MapLength(t, f);\n}\n\nlemma FilterSubset<T>(list: LinkedList<T>, p: T -> bool)\n  ensures length(filter(list, p)) <= length(list)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    FilterSubset(t, p);\n    if p(h) {\n      assert length(filter(list, p)) == 1 + length(filter(t, p));\n    } else {\n      assert length(filter(list, p)) == length(filter(t, p));\n    }\n}\n\nlemma TakeDropConcat<T>(list: LinkedList<T>, n: nat)\n  ensures append(take(list, n), drop(list, n)) == list\n{\n  if n == 0 {\n    assert take(list, 0) == Nil;\n    assert drop(list, 0) == list;\n    AppendNil(list);\n  } else {\n    match list\n    case Nil =>\n    case Cons(h, t) =>\n      TakeDropConcat(t, n - 1);\n      calc == {\n        append(take(list, n), drop(list, n));\n        append(Cons(h, take(t, n - 1)), drop(t, n - 1));\n        Cons(h, append(take(t, n - 1), drop(t, n - 1)));\n        Cons(h, t);\n        list;\n      }\n  }\n}\n\nlemma RemoveDecreasesLength<T>(list: LinkedList<T>, x: T)\n  requires contains(list, x)\n  ensures length(remove(list, x)) == length(list) - 1\n{\n  match list\n  case Cons(h, t) =>\n    if h == x {\n      assert remove(list, x) == t;\n    } else {\n      assert contains(t, x);\n      RemoveDecreasesLength(t, x);\n    }\n}\n\nlemma InsertAtLength<T>(list: LinkedList<T>, x: T, pos: nat)\n  ensures length(insertAt(list, x, pos)) == length(list) + 1\n{\n  if pos == 0 {\n    assert insertAt(list, x, 0) == Cons(x, list);\n  } else {\n    match list\n    case Nil =>\n      assert insertAt(Nil, x, pos) == Cons(x, Nil);\n    case Cons(h, t) =>\n      \n/*[CODE HERE]*/\n  }\n}", "output": "InsertAtLength(t, x, pos - 1);"}, {"id": "example_InsertAtLength_1", "type": "assert", "program": "// Linked list operations: insert, delete, reverse, cycle detection\n\ndatatype LinkedList<T> = Nil | Cons(head: T, tail: LinkedList<T>)\n\n// Length of linked list\nfunction {:spec} length<T>(list: LinkedList<T>): nat\n{\n  match list\n  case Nil => 0\n  case Cons(_, tail) => 1 + length(tail)\n}\n\n// Append two linked lists\nfunction {:spec} append<T>(l1: LinkedList<T>, l2: LinkedList<T>): LinkedList<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, append(t, l2))\n}\n\n// Reverse a linked list\nfunction {:spec} reverse<T>(list: LinkedList<T>): LinkedList<T>\n{\n  reverseHelper(list, Nil)\n}\n\nfunction reverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>): LinkedList<T>\n{\n  match list\n  case Nil => acc\n  case Cons(h, t) => reverseHelper(t, Cons(h, acc))\n}\n\n// Get nth element (0-indexed)\nfunction {:spec} nth<T>(list: LinkedList<T>, n: nat): T\n  requires n < length(list)\n{\n  match list\n  case Cons(h, t) => if n == 0 then h else nth(t, n - 1)\n}\n\n// Check if element exists in list\npredicate {:spec} contains<T(==)>(list: LinkedList<T>, x: T)\n{\n  match list\n  case Nil => false\n  case Cons(h, t) => h == x || contains(t, x)\n}\n\n// Remove first occurrence of element\nfunction {:spec} remove<T(==)>(list: LinkedList<T>, x: T): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => if h == x then t else Cons(h, remove(t, x))\n}\n\n// Insert at position\nfunction {:spec} insertAt<T>(list: LinkedList<T>, x: T, pos: nat): LinkedList<T>\n{\n  if pos == 0 then Cons(x, list)\n  else match list\n    case Nil => Cons(x, Nil)\n    case Cons(h, t) => Cons(h, insertAt(t, x, pos - 1))\n}\n\n// Convert to sequence\nfunction {:spec} toSeq<T>(list: LinkedList<T>): seq<T>\n{\n  match list\n  case Nil => []\n  case Cons(h, t) => [h] + toSeq(t)\n}\n\n// Convert from sequence\nfunction {:spec} fromSeq<T>(s: seq<T>): LinkedList<T>\n{\n  if |s| == 0 then Nil\n  else Cons(s[0], fromSeq(s[1..]))\n}\n\n// Map function over list\nfunction {:spec} listMap<T, U>(list: LinkedList<T>, f: T -> U): LinkedList<U>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => Cons(f(h), listMap(t, f))\n}\n\n// Filter list with predicate\nfunction {:spec} filter<T>(list: LinkedList<T>, p: T -> bool): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) =>\n    if p(h) then Cons(h, filter(t, p))\n    else filter(t, p)\n}\n\n// Take first n elements\nfunction {:spec} take<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n{\n  if n == 0 then Nil\n  else match list\n    case Nil => Nil\n    case Cons(h, t) => Cons(h, take(t, n - 1))\n}\n\n// Drop first n elements\nfunction {:spec} drop<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n  decreases list\n{\n  if n == 0 then list\n  else match list\n    case Nil => Nil\n    case Cons(_, t) => drop(t, n - 1)\n}\n\n// Check if list is palindrome\npredicate {:spec} isPalindrome<T(==)>(list: LinkedList<T>)\n{\n  toSeq(list) == toSeq(reverse(list))\n}\n\n// --- Lemmas for correctness ---\n\nlemma LengthAppend<T>(l1: LinkedList<T>, l2: LinkedList<T>)\n  ensures length(append(l1, l2)) == length(l1) + length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) =>\n    LengthAppend(t, l2);\n}\n\nlemma AppendNil<T>(list: LinkedList<T>)\n  ensures append(list, Nil) == list\n  ensures append(Nil, list) == list\n{\n  match list\n  case Nil =>\n  case Cons(_, t) =>\n    AppendNil(t);\n}\n\nlemma AppendAssociative<T>(l1: LinkedList<T>, l2: LinkedList<T>, l3: LinkedList<T>)\n  ensures append(append(l1, l2), l3) == append(l1, append(l2, l3))\n{\n  match l1\n  case Nil =>\n  case Cons(h, t) =>\n    AppendAssociative(t, l2, l3);\n}\n\nlemma ReverseLength<T>(list: LinkedList<T>)\n  ensures length(reverse(list)) == length(list)\n{\n  ReverseHelperLength(list, Nil);\n}\n\nlemma ReverseHelperLength<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures length(reverseHelper(list, acc)) == length(list) + length(acc)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    calc == {\n      length(reverseHelper(list, acc));\n      length(reverseHelper(t, Cons(h, acc)));\n      { ReverseHelperLength(t, Cons(h, acc)); }\n      length(t) + length(Cons(h, acc));\n      length(t) + 1 + length(acc);\n      length(list) + length(acc);\n    }\n}\n\nlemma ReverseReverse<T>(list: LinkedList<T>)\n  ensures reverse(reverse(list)) == list\n{\n  ReverseReverseHelper(list, Nil);\n}\n\nlemma ReverseReverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures reverseHelper(reverseHelper(list, acc), Nil) == reverseHelper(acc, list)\n{\n  match list\n  case Nil =>\n    assert reverseHelper(reverseHelper(Nil, acc), Nil) == reverseHelper(acc, Nil);\n  case Cons(h, t) =>\n    calc == {\n      reverseHelper(reverseHelper(Cons(h, t), acc), Nil);\n      reverseHelper(reverseHelper(t, Cons(h, acc)), Nil);\n      { ReverseReverseHelper(t, Cons(h, acc)); }\n      reverseHelper(Cons(h, acc), t);\n      reverseHelper(acc, Cons(h, t));\n    }\n}\n\nlemma ToSeqFromSeq<T>(s: seq<T>)\n  ensures toSeq(fromSeq(s)) == s\n{\n  if |s| == 0 {\n    assert fromSeq(s) == Nil;\n  } else {\n    ToSeqFromSeq(s[1..]);\n    assert toSeq(fromSeq(s)) == [s[0]] + toSeq(fromSeq(s[1..]));\n  }\n}\n\nlemma FromSeqToSeq<T>(list: LinkedList<T>)\n  ensures fromSeq(toSeq(list)) == list\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    FromSeqToSeq(t);\n}\n\nlemma NthCorrect<T>(list: LinkedList<T>, n: nat)\n  requires n < length(list)\n  ensures |toSeq(list)| > n\n  ensures toSeq(list)[n] == nth(list, n)\n{\n  match list\n  case Cons(h, t) =>\n    if n == 0 {\n      assert toSeq(list)[0] == h;\n    } else {\n      NthCorrect(t, n - 1);\n    }\n}\n\nlemma MapLength<T, U>(list: LinkedList<T>, f: T -> U)\n  ensures length(listMap(list, f)) == length(list)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    MapLength(t, f);\n}\n\nlemma FilterSubset<T>(list: LinkedList<T>, p: T -> bool)\n  ensures length(filter(list, p)) <= length(list)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    FilterSubset(t, p);\n    if p(h) {\n      assert length(filter(list, p)) == 1 + length(filter(t, p));\n    } else {\n      assert length(filter(list, p)) == length(filter(t, p));\n    }\n}\n\nlemma TakeDropConcat<T>(list: LinkedList<T>, n: nat)\n  ensures append(take(list, n), drop(list, n)) == list\n{\n  if n == 0 {\n    assert take(list, 0) == Nil;\n    assert drop(list, 0) == list;\n    AppendNil(list);\n  } else {\n    match list\n    case Nil =>\n    case Cons(h, t) =>\n      TakeDropConcat(t, n - 1);\n      calc == {\n        append(take(list, n), drop(list, n));\n        append(Cons(h, take(t, n - 1)), drop(t, n - 1));\n        Cons(h, append(take(t, n - 1), drop(t, n - 1)));\n        Cons(h, t);\n        list;\n      }\n  }\n}\n\nlemma RemoveDecreasesLength<T>(list: LinkedList<T>, x: T)\n  requires contains(list, x)\n  ensures length(remove(list, x)) == length(list) - 1\n{\n  match list\n  case Cons(h, t) =>\n    if h == x {\n      assert remove(list, x) == t;\n    } else {\n      assert contains(t, x);\n      RemoveDecreasesLength(t, x);\n    }\n}\n\nlemma InsertAtLength<T>(list: LinkedList<T>, x: T, pos: nat)\n  ensures length(insertAt(list, x, pos)) == length(list) + 1\n{\n  if pos == 0 {\n    assert insertAt(list, x, 0) == Cons(x, list);\n  } else {\n    match list\n    case Nil =>\n      \n/*[CODE HERE]*/\n    case Cons(h, t) =>\n      InsertAtLength(t, x, pos - 1);\n  }\n}", "output": "assert insertAt(Nil, x, pos) == Cons(x, Nil);"}, {"id": "example_InsertAtLength_2", "type": "assert", "program": "// Linked list operations: insert, delete, reverse, cycle detection\n\ndatatype LinkedList<T> = Nil | Cons(head: T, tail: LinkedList<T>)\n\n// Length of linked list\nfunction {:spec} length<T>(list: LinkedList<T>): nat\n{\n  match list\n  case Nil => 0\n  case Cons(_, tail) => 1 + length(tail)\n}\n\n// Append two linked lists\nfunction {:spec} append<T>(l1: LinkedList<T>, l2: LinkedList<T>): LinkedList<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, append(t, l2))\n}\n\n// Reverse a linked list\nfunction {:spec} reverse<T>(list: LinkedList<T>): LinkedList<T>\n{\n  reverseHelper(list, Nil)\n}\n\nfunction reverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>): LinkedList<T>\n{\n  match list\n  case Nil => acc\n  case Cons(h, t) => reverseHelper(t, Cons(h, acc))\n}\n\n// Get nth element (0-indexed)\nfunction {:spec} nth<T>(list: LinkedList<T>, n: nat): T\n  requires n < length(list)\n{\n  match list\n  case Cons(h, t) => if n == 0 then h else nth(t, n - 1)\n}\n\n// Check if element exists in list\npredicate {:spec} contains<T(==)>(list: LinkedList<T>, x: T)\n{\n  match list\n  case Nil => false\n  case Cons(h, t) => h == x || contains(t, x)\n}\n\n// Remove first occurrence of element\nfunction {:spec} remove<T(==)>(list: LinkedList<T>, x: T): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => if h == x then t else Cons(h, remove(t, x))\n}\n\n// Insert at position\nfunction {:spec} insertAt<T>(list: LinkedList<T>, x: T, pos: nat): LinkedList<T>\n{\n  if pos == 0 then Cons(x, list)\n  else match list\n    case Nil => Cons(x, Nil)\n    case Cons(h, t) => Cons(h, insertAt(t, x, pos - 1))\n}\n\n// Convert to sequence\nfunction {:spec} toSeq<T>(list: LinkedList<T>): seq<T>\n{\n  match list\n  case Nil => []\n  case Cons(h, t) => [h] + toSeq(t)\n}\n\n// Convert from sequence\nfunction {:spec} fromSeq<T>(s: seq<T>): LinkedList<T>\n{\n  if |s| == 0 then Nil\n  else Cons(s[0], fromSeq(s[1..]))\n}\n\n// Map function over list\nfunction {:spec} listMap<T, U>(list: LinkedList<T>, f: T -> U): LinkedList<U>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => Cons(f(h), listMap(t, f))\n}\n\n// Filter list with predicate\nfunction {:spec} filter<T>(list: LinkedList<T>, p: T -> bool): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) =>\n    if p(h) then Cons(h, filter(t, p))\n    else filter(t, p)\n}\n\n// Take first n elements\nfunction {:spec} take<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n{\n  if n == 0 then Nil\n  else match list\n    case Nil => Nil\n    case Cons(h, t) => Cons(h, take(t, n - 1))\n}\n\n// Drop first n elements\nfunction {:spec} drop<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n  decreases list\n{\n  if n == 0 then list\n  else match list\n    case Nil => Nil\n    case Cons(_, t) => drop(t, n - 1)\n}\n\n// Check if list is palindrome\npredicate {:spec} isPalindrome<T(==)>(list: LinkedList<T>)\n{\n  toSeq(list) == toSeq(reverse(list))\n}\n\n// --- Lemmas for correctness ---\n\nlemma LengthAppend<T>(l1: LinkedList<T>, l2: LinkedList<T>)\n  ensures length(append(l1, l2)) == length(l1) + length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) =>\n    LengthAppend(t, l2);\n}\n\nlemma AppendNil<T>(list: LinkedList<T>)\n  ensures append(list, Nil) == list\n  ensures append(Nil, list) == list\n{\n  match list\n  case Nil =>\n  case Cons(_, t) =>\n    AppendNil(t);\n}\n\nlemma AppendAssociative<T>(l1: LinkedList<T>, l2: LinkedList<T>, l3: LinkedList<T>)\n  ensures append(append(l1, l2), l3) == append(l1, append(l2, l3))\n{\n  match l1\n  case Nil =>\n  case Cons(h, t) =>\n    AppendAssociative(t, l2, l3);\n}\n\nlemma ReverseLength<T>(list: LinkedList<T>)\n  ensures length(reverse(list)) == length(list)\n{\n  ReverseHelperLength(list, Nil);\n}\n\nlemma ReverseHelperLength<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures length(reverseHelper(list, acc)) == length(list) + length(acc)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    calc == {\n      length(reverseHelper(list, acc));\n      length(reverseHelper(t, Cons(h, acc)));\n      { ReverseHelperLength(t, Cons(h, acc)); }\n      length(t) + length(Cons(h, acc));\n      length(t) + 1 + length(acc);\n      length(list) + length(acc);\n    }\n}\n\nlemma ReverseReverse<T>(list: LinkedList<T>)\n  ensures reverse(reverse(list)) == list\n{\n  ReverseReverseHelper(list, Nil);\n}\n\nlemma ReverseReverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures reverseHelper(reverseHelper(list, acc), Nil) == reverseHelper(acc, list)\n{\n  match list\n  case Nil =>\n    assert reverseHelper(reverseHelper(Nil, acc), Nil) == reverseHelper(acc, Nil);\n  case Cons(h, t) =>\n    calc == {\n      reverseHelper(reverseHelper(Cons(h, t), acc), Nil);\n      reverseHelper(reverseHelper(t, Cons(h, acc)), Nil);\n      { ReverseReverseHelper(t, Cons(h, acc)); }\n      reverseHelper(Cons(h, acc), t);\n      reverseHelper(acc, Cons(h, t));\n    }\n}\n\nlemma ToSeqFromSeq<T>(s: seq<T>)\n  ensures toSeq(fromSeq(s)) == s\n{\n  if |s| == 0 {\n    assert fromSeq(s) == Nil;\n  } else {\n    ToSeqFromSeq(s[1..]);\n    assert toSeq(fromSeq(s)) == [s[0]] + toSeq(fromSeq(s[1..]));\n  }\n}\n\nlemma FromSeqToSeq<T>(list: LinkedList<T>)\n  ensures fromSeq(toSeq(list)) == list\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    FromSeqToSeq(t);\n}\n\nlemma NthCorrect<T>(list: LinkedList<T>, n: nat)\n  requires n < length(list)\n  ensures |toSeq(list)| > n\n  ensures toSeq(list)[n] == nth(list, n)\n{\n  match list\n  case Cons(h, t) =>\n    if n == 0 {\n      assert toSeq(list)[0] == h;\n    } else {\n      NthCorrect(t, n - 1);\n    }\n}\n\nlemma MapLength<T, U>(list: LinkedList<T>, f: T -> U)\n  ensures length(listMap(list, f)) == length(list)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    MapLength(t, f);\n}\n\nlemma FilterSubset<T>(list: LinkedList<T>, p: T -> bool)\n  ensures length(filter(list, p)) <= length(list)\n{\n  match list\n  case Nil =>\n  case Cons(h, t) =>\n    FilterSubset(t, p);\n    if p(h) {\n      assert length(filter(list, p)) == 1 + length(filter(t, p));\n    } else {\n      assert length(filter(list, p)) == length(filter(t, p));\n    }\n}\n\nlemma TakeDropConcat<T>(list: LinkedList<T>, n: nat)\n  ensures append(take(list, n), drop(list, n)) == list\n{\n  if n == 0 {\n    assert take(list, 0) == Nil;\n    assert drop(list, 0) == list;\n    AppendNil(list);\n  } else {\n    match list\n    case Nil =>\n    case Cons(h, t) =>\n      TakeDropConcat(t, n - 1);\n      calc == {\n        append(take(list, n), drop(list, n));\n        append(Cons(h, take(t, n - 1)), drop(t, n - 1));\n        Cons(h, append(take(t, n - 1), drop(t, n - 1)));\n        Cons(h, t);\n        list;\n      }\n  }\n}\n\nlemma RemoveDecreasesLength<T>(list: LinkedList<T>, x: T)\n  requires contains(list, x)\n  ensures length(remove(list, x)) == length(list) - 1\n{\n  match list\n  case Cons(h, t) =>\n    if h == x {\n      assert remove(list, x) == t;\n    } else {\n      assert contains(t, x);\n      RemoveDecreasesLength(t, x);\n    }\n}\n\nlemma InsertAtLength<T>(list: LinkedList<T>, x: T, pos: nat)\n  ensures length(insertAt(list, x, pos)) == length(list) + 1\n{\n  if pos == 0 {\n    \n/*[CODE HERE]*/\n  } else {\n    match list\n    case Nil =>\n      assert insertAt(Nil, x, pos) == Cons(x, Nil);\n    case Cons(h, t) =>\n      InsertAtLength(t, x, pos - 1);\n  }\n}", "output": "assert insertAt(list, x, 0) == Cons(x, list);"}, {"id": "example_IndexOfCorrect_0", "type": "call", "program": "// List operations: append, length, nth element\n\nfunction {:spec} length<T>(l: seq<T>): nat\n{\n  |l|\n}\n\nfunction {:spec} append<T>(l1: seq<T>, l2: seq<T>): seq<T>\n{\n  l1 + l2\n}\n\nfunction {:spec} nth<T>(l: seq<T>, n: nat): T\n  requires n < |l|\n{\n  l[n]\n}\n\npredicate {:spec} contains<T(==)>(l: seq<T>, x: T)\n{\n  x in l\n}\n\nfunction {:spec} indexOf<T(==)>(l: seq<T>, x: T): int\n  requires x in l\n{\n  if l[0] == x then 0\n  else 1 + indexOf(l[1..], x)\n}\n\nfunction {:spec} take<T>(l: seq<T>, n: nat): seq<T>\n{\n  if n >= |l| then l\n  else l[..n]\n}\n\nfunction {:spec} drop<T>(l: seq<T>, n: nat): seq<T>\n{\n  if n >= |l| then []\n  else l[n..]\n}\n\nfunction {:spec} filter<T>(l: seq<T>, p: T -> bool): seq<T>\n{\n  if |l| == 0 then []\n  else if p(l[0]) then [l[0]] + filter(l[1..], p)\n  else filter(l[1..], p)\n}\n\nfunction {:spec} listMap<T, U>(l: seq<T>, f: T -> U): seq<U>\n{\n  if |l| == 0 then []\n  else [f(l[0])] + listMap(l[1..], f)\n}\n\nlemma AppendAssociative<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures append(append(a, b), c) == append(a, append(b, c))\n{\n  // Dafny proves this automatically\n}\n\nlemma AppendNeutral<T>(l: seq<T>)\n  ensures append(l, []) == l\n  ensures append([], l) == l\n{\n  // Dafny proves this automatically\n}\n\nlemma AppendLength<T>(l1: seq<T>, l2: seq<T>)\n  ensures length(append(l1, l2)) == length(l1) + length(l2)\n{\n  // Dafny proves this automatically\n}\n\nlemma NthAppend<T>(l1: seq<T>, l2: seq<T>, n: nat)\n  requires n < |l1| + |l2|\n  ensures nth(append(l1, l2), n) == (if n < |l1| then nth(l1, n) else nth(l2, n - |l1|))\n{\n  // Dafny proves this automatically\n}\n\nlemma IndexOfCorrect<T>(l: seq<T>, x: T)\n  requires x in l\n  ensures 0 <= indexOf(l, x) < |l|\n  ensures l[indexOf(l, x)] == x\n  ensures forall i :: 0 <= i < indexOf(l, x) ==> l[i] != x\n{\n  if l[0] == x {\n    // Base case\n  } else {\n    \n/*[CODE HERE]*/\n  }\n}\n\nlemma TakeDropConcat<T>(l: seq<T>, n: nat)\n  ensures append(take(l, n), drop(l, n)) == l\n{\n  if n >= |l| {\n    assert take(l, n) == l;\n    assert drop(l, n) == [];\n  }\n}\n\nlemma FilterSubset<T>(l: seq<T>, p: T -> bool, x: T)\n  requires x in filter(l, p)\n  ensures x in l && p(x)\n{\n  if |l| > 0 {\n    if p(l[0]) && x == l[0] {\n      // Found it\n    } else if p(l[0]) {\n      assert x in filter(l[1..], p);\n      FilterSubset(l[1..], p, x);\n    } else {\n      FilterSubset(l[1..], p, x);\n    }\n  }\n}\n\nlemma MapLength<T, U>(l: seq<T>, f: T -> U)\n  ensures |listMap(l, f)| == |l|\n{\n  if |l| == 0 {\n    // Base case\n  } else {\n    MapLength(l[1..], f);\n  }\n}\n\nlemma MapCompose<T, U, V>(l: seq<T>, f: T -> U, g: U -> V)\n  ensures listMap(listMap(l, f), g) == listMap(l, (x: T) => g(f(x)))\n{\n  if |l| == 0 {\n    // Base case\n  } else {\n    MapCompose(l[1..], f, g);\n  }\n}", "output": "IndexOfCorrect(l[1..], x);"}, {"id": "example_TakeDropConcat_0", "type": "assert", "program": "// List operations: append, length, nth element\n\nfunction {:spec} length<T>(l: seq<T>): nat\n{\n  |l|\n}\n\nfunction {:spec} append<T>(l1: seq<T>, l2: seq<T>): seq<T>\n{\n  l1 + l2\n}\n\nfunction {:spec} nth<T>(l: seq<T>, n: nat): T\n  requires n < |l|\n{\n  l[n]\n}\n\npredicate {:spec} contains<T(==)>(l: seq<T>, x: T)\n{\n  x in l\n}\n\nfunction {:spec} indexOf<T(==)>(l: seq<T>, x: T): int\n  requires x in l\n{\n  if l[0] == x then 0\n  else 1 + indexOf(l[1..], x)\n}\n\nfunction {:spec} take<T>(l: seq<T>, n: nat): seq<T>\n{\n  if n >= |l| then l\n  else l[..n]\n}\n\nfunction {:spec} drop<T>(l: seq<T>, n: nat): seq<T>\n{\n  if n >= |l| then []\n  else l[n..]\n}\n\nfunction {:spec} filter<T>(l: seq<T>, p: T -> bool): seq<T>\n{\n  if |l| == 0 then []\n  else if p(l[0]) then [l[0]] + filter(l[1..], p)\n  else filter(l[1..], p)\n}\n\nfunction {:spec} listMap<T, U>(l: seq<T>, f: T -> U): seq<U>\n{\n  if |l| == 0 then []\n  else [f(l[0])] + listMap(l[1..], f)\n}\n\nlemma AppendAssociative<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures append(append(a, b), c) == append(a, append(b, c))\n{\n  // Dafny proves this automatically\n}\n\nlemma AppendNeutral<T>(l: seq<T>)\n  ensures append(l, []) == l\n  ensures append([], l) == l\n{\n  // Dafny proves this automatically\n}\n\nlemma AppendLength<T>(l1: seq<T>, l2: seq<T>)\n  ensures length(append(l1, l2)) == length(l1) + length(l2)\n{\n  // Dafny proves this automatically\n}\n\nlemma NthAppend<T>(l1: seq<T>, l2: seq<T>, n: nat)\n  requires n < |l1| + |l2|\n  ensures nth(append(l1, l2), n) == (if n < |l1| then nth(l1, n) else nth(l2, n - |l1|))\n{\n  // Dafny proves this automatically\n}\n\nlemma IndexOfCorrect<T>(l: seq<T>, x: T)\n  requires x in l\n  ensures 0 <= indexOf(l, x) < |l|\n  ensures l[indexOf(l, x)] == x\n  ensures forall i :: 0 <= i < indexOf(l, x) ==> l[i] != x\n{\n  if l[0] == x {\n    // Base case\n  } else {\n    IndexOfCorrect(l[1..], x);\n  }\n}\n\nlemma TakeDropConcat<T>(l: seq<T>, n: nat)\n  ensures append(take(l, n), drop(l, n)) == l\n{\n  if n >= |l| {\n    assert take(l, n) == l;\n    \n/*[CODE HERE]*/\n  }\n}\n\nlemma FilterSubset<T>(l: seq<T>, p: T -> bool, x: T)\n  requires x in filter(l, p)\n  ensures x in l && p(x)\n{\n  if |l| > 0 {\n    if p(l[0]) && x == l[0] {\n      // Found it\n    } else if p(l[0]) {\n      assert x in filter(l[1..], p);\n      FilterSubset(l[1..], p, x);\n    } else {\n      FilterSubset(l[1..], p, x);\n    }\n  }\n}\n\nlemma MapLength<T, U>(l: seq<T>, f: T -> U)\n  ensures |listMap(l, f)| == |l|\n{\n  if |l| == 0 {\n    // Base case\n  } else {\n    MapLength(l[1..], f);\n  }\n}\n\nlemma MapCompose<T, U, V>(l: seq<T>, f: T -> U, g: U -> V)\n  ensures listMap(listMap(l, f), g) == listMap(l, (x: T) => g(f(x)))\n{\n  if |l| == 0 {\n    // Base case\n  } else {\n    MapCompose(l[1..], f, g);\n  }\n}", "output": "assert drop(l, n) == [];"}, {"id": "example_TakeDropConcat_1", "type": "assert", "program": "// List operations: append, length, nth element\n\nfunction {:spec} length<T>(l: seq<T>): nat\n{\n  |l|\n}\n\nfunction {:spec} append<T>(l1: seq<T>, l2: seq<T>): seq<T>\n{\n  l1 + l2\n}\n\nfunction {:spec} nth<T>(l: seq<T>, n: nat): T\n  requires n < |l|\n{\n  l[n]\n}\n\npredicate {:spec} contains<T(==)>(l: seq<T>, x: T)\n{\n  x in l\n}\n\nfunction {:spec} indexOf<T(==)>(l: seq<T>, x: T): int\n  requires x in l\n{\n  if l[0] == x then 0\n  else 1 + indexOf(l[1..], x)\n}\n\nfunction {:spec} take<T>(l: seq<T>, n: nat): seq<T>\n{\n  if n >= |l| then l\n  else l[..n]\n}\n\nfunction {:spec} drop<T>(l: seq<T>, n: nat): seq<T>\n{\n  if n >= |l| then []\n  else l[n..]\n}\n\nfunction {:spec} filter<T>(l: seq<T>, p: T -> bool): seq<T>\n{\n  if |l| == 0 then []\n  else if p(l[0]) then [l[0]] + filter(l[1..], p)\n  else filter(l[1..], p)\n}\n\nfunction {:spec} listMap<T, U>(l: seq<T>, f: T -> U): seq<U>\n{\n  if |l| == 0 then []\n  else [f(l[0])] + listMap(l[1..], f)\n}\n\nlemma AppendAssociative<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures append(append(a, b), c) == append(a, append(b, c))\n{\n  // Dafny proves this automatically\n}\n\nlemma AppendNeutral<T>(l: seq<T>)\n  ensures append(l, []) == l\n  ensures append([], l) == l\n{\n  // Dafny proves this automatically\n}\n\nlemma AppendLength<T>(l1: seq<T>, l2: seq<T>)\n  ensures length(append(l1, l2)) == length(l1) + length(l2)\n{\n  // Dafny proves this automatically\n}\n\nlemma NthAppend<T>(l1: seq<T>, l2: seq<T>, n: nat)\n  requires n < |l1| + |l2|\n  ensures nth(append(l1, l2), n) == (if n < |l1| then nth(l1, n) else nth(l2, n - |l1|))\n{\n  // Dafny proves this automatically\n}\n\nlemma IndexOfCorrect<T>(l: seq<T>, x: T)\n  requires x in l\n  ensures 0 <= indexOf(l, x) < |l|\n  ensures l[indexOf(l, x)] == x\n  ensures forall i :: 0 <= i < indexOf(l, x) ==> l[i] != x\n{\n  if l[0] == x {\n    // Base case\n  } else {\n    IndexOfCorrect(l[1..], x);\n  }\n}\n\nlemma TakeDropConcat<T>(l: seq<T>, n: nat)\n  ensures append(take(l, n), drop(l, n)) == l\n{\n  if n >= |l| {\n    \n/*[CODE HERE]*/\n    assert drop(l, n) == [];\n  }\n}\n\nlemma FilterSubset<T>(l: seq<T>, p: T -> bool, x: T)\n  requires x in filter(l, p)\n  ensures x in l && p(x)\n{\n  if |l| > 0 {\n    if p(l[0]) && x == l[0] {\n      // Found it\n    } else if p(l[0]) {\n      assert x in filter(l[1..], p);\n      FilterSubset(l[1..], p, x);\n    } else {\n      FilterSubset(l[1..], p, x);\n    }\n  }\n}\n\nlemma MapLength<T, U>(l: seq<T>, f: T -> U)\n  ensures |listMap(l, f)| == |l|\n{\n  if |l| == 0 {\n    // Base case\n  } else {\n    MapLength(l[1..], f);\n  }\n}\n\nlemma MapCompose<T, U, V>(l: seq<T>, f: T -> U, g: U -> V)\n  ensures listMap(listMap(l, f), g) == listMap(l, (x: T) => g(f(x)))\n{\n  if |l| == 0 {\n    // Base case\n  } else {\n    MapCompose(l[1..], f, g);\n  }\n}", "output": "assert take(l, n) == l;"}, {"id": "example_FilterSubset_0", "type": "call", "program": "// List operations: append, length, nth element\n\nfunction {:spec} length<T>(l: seq<T>): nat\n{\n  |l|\n}\n\nfunction {:spec} append<T>(l1: seq<T>, l2: seq<T>): seq<T>\n{\n  l1 + l2\n}\n\nfunction {:spec} nth<T>(l: seq<T>, n: nat): T\n  requires n < |l|\n{\n  l[n]\n}\n\npredicate {:spec} contains<T(==)>(l: seq<T>, x: T)\n{\n  x in l\n}\n\nfunction {:spec} indexOf<T(==)>(l: seq<T>, x: T): int\n  requires x in l\n{\n  if l[0] == x then 0\n  else 1 + indexOf(l[1..], x)\n}\n\nfunction {:spec} take<T>(l: seq<T>, n: nat): seq<T>\n{\n  if n >= |l| then l\n  else l[..n]\n}\n\nfunction {:spec} drop<T>(l: seq<T>, n: nat): seq<T>\n{\n  if n >= |l| then []\n  else l[n..]\n}\n\nfunction {:spec} filter<T>(l: seq<T>, p: T -> bool): seq<T>\n{\n  if |l| == 0 then []\n  else if p(l[0]) then [l[0]] + filter(l[1..], p)\n  else filter(l[1..], p)\n}\n\nfunction {:spec} listMap<T, U>(l: seq<T>, f: T -> U): seq<U>\n{\n  if |l| == 0 then []\n  else [f(l[0])] + listMap(l[1..], f)\n}\n\nlemma AppendAssociative<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures append(append(a, b), c) == append(a, append(b, c))\n{\n  // Dafny proves this automatically\n}\n\nlemma AppendNeutral<T>(l: seq<T>)\n  ensures append(l, []) == l\n  ensures append([], l) == l\n{\n  // Dafny proves this automatically\n}\n\nlemma AppendLength<T>(l1: seq<T>, l2: seq<T>)\n  ensures length(append(l1, l2)) == length(l1) + length(l2)\n{\n  // Dafny proves this automatically\n}\n\nlemma NthAppend<T>(l1: seq<T>, l2: seq<T>, n: nat)\n  requires n < |l1| + |l2|\n  ensures nth(append(l1, l2), n) == (if n < |l1| then nth(l1, n) else nth(l2, n - |l1|))\n{\n  // Dafny proves this automatically\n}\n\nlemma IndexOfCorrect<T>(l: seq<T>, x: T)\n  requires x in l\n  ensures 0 <= indexOf(l, x) < |l|\n  ensures l[indexOf(l, x)] == x\n  ensures forall i :: 0 <= i < indexOf(l, x) ==> l[i] != x\n{\n  if l[0] == x {\n    // Base case\n  } else {\n    IndexOfCorrect(l[1..], x);\n  }\n}\n\nlemma TakeDropConcat<T>(l: seq<T>, n: nat)\n  ensures append(take(l, n), drop(l, n)) == l\n{\n  if n >= |l| {\n    assert take(l, n) == l;\n    assert drop(l, n) == [];\n  }\n}\n\nlemma FilterSubset<T>(l: seq<T>, p: T -> bool, x: T)\n  requires x in filter(l, p)\n  ensures x in l && p(x)\n{\n  if |l| > 0 {\n    if p(l[0]) && x == l[0] {\n      // Found it\n    } else if p(l[0]) {\n      assert x in filter(l[1..], p);\n      FilterSubset(l[1..], p, x);\n    } else {\n      \n/*[CODE HERE]*/\n    }\n  }\n}\n\nlemma MapLength<T, U>(l: seq<T>, f: T -> U)\n  ensures |listMap(l, f)| == |l|\n{\n  if |l| == 0 {\n    // Base case\n  } else {\n    MapLength(l[1..], f);\n  }\n}\n\nlemma MapCompose<T, U, V>(l: seq<T>, f: T -> U, g: U -> V)\n  ensures listMap(listMap(l, f), g) == listMap(l, (x: T) => g(f(x)))\n{\n  if |l| == 0 {\n    // Base case\n  } else {\n    MapCompose(l[1..], f, g);\n  }\n}", "output": "FilterSubset(l[1..], p, x);"}, {"id": "example_FilterSubset_1", "type": "call", "program": "// List operations: append, length, nth element\n\nfunction {:spec} length<T>(l: seq<T>): nat\n{\n  |l|\n}\n\nfunction {:spec} append<T>(l1: seq<T>, l2: seq<T>): seq<T>\n{\n  l1 + l2\n}\n\nfunction {:spec} nth<T>(l: seq<T>, n: nat): T\n  requires n < |l|\n{\n  l[n]\n}\n\npredicate {:spec} contains<T(==)>(l: seq<T>, x: T)\n{\n  x in l\n}\n\nfunction {:spec} indexOf<T(==)>(l: seq<T>, x: T): int\n  requires x in l\n{\n  if l[0] == x then 0\n  else 1 + indexOf(l[1..], x)\n}\n\nfunction {:spec} take<T>(l: seq<T>, n: nat): seq<T>\n{\n  if n >= |l| then l\n  else l[..n]\n}\n\nfunction {:spec} drop<T>(l: seq<T>, n: nat): seq<T>\n{\n  if n >= |l| then []\n  else l[n..]\n}\n\nfunction {:spec} filter<T>(l: seq<T>, p: T -> bool): seq<T>\n{\n  if |l| == 0 then []\n  else if p(l[0]) then [l[0]] + filter(l[1..], p)\n  else filter(l[1..], p)\n}\n\nfunction {:spec} listMap<T, U>(l: seq<T>, f: T -> U): seq<U>\n{\n  if |l| == 0 then []\n  else [f(l[0])] + listMap(l[1..], f)\n}\n\nlemma AppendAssociative<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures append(append(a, b), c) == append(a, append(b, c))\n{\n  // Dafny proves this automatically\n}\n\nlemma AppendNeutral<T>(l: seq<T>)\n  ensures append(l, []) == l\n  ensures append([], l) == l\n{\n  // Dafny proves this automatically\n}\n\nlemma AppendLength<T>(l1: seq<T>, l2: seq<T>)\n  ensures length(append(l1, l2)) == length(l1) + length(l2)\n{\n  // Dafny proves this automatically\n}\n\nlemma NthAppend<T>(l1: seq<T>, l2: seq<T>, n: nat)\n  requires n < |l1| + |l2|\n  ensures nth(append(l1, l2), n) == (if n < |l1| then nth(l1, n) else nth(l2, n - |l1|))\n{\n  // Dafny proves this automatically\n}\n\nlemma IndexOfCorrect<T>(l: seq<T>, x: T)\n  requires x in l\n  ensures 0 <= indexOf(l, x) < |l|\n  ensures l[indexOf(l, x)] == x\n  ensures forall i :: 0 <= i < indexOf(l, x) ==> l[i] != x\n{\n  if l[0] == x {\n    // Base case\n  } else {\n    IndexOfCorrect(l[1..], x);\n  }\n}\n\nlemma TakeDropConcat<T>(l: seq<T>, n: nat)\n  ensures append(take(l, n), drop(l, n)) == l\n{\n  if n >= |l| {\n    assert take(l, n) == l;\n    assert drop(l, n) == [];\n  }\n}\n\nlemma FilterSubset<T>(l: seq<T>, p: T -> bool, x: T)\n  requires x in filter(l, p)\n  ensures x in l && p(x)\n{\n  if |l| > 0 {\n    if p(l[0]) && x == l[0] {\n      // Found it\n    } else if p(l[0]) {\n      assert x in filter(l[1..], p);\n      \n/*[CODE HERE]*/\n    } else {\n      FilterSubset(l[1..], p, x);\n    }\n  }\n}\n\nlemma MapLength<T, U>(l: seq<T>, f: T -> U)\n  ensures |listMap(l, f)| == |l|\n{\n  if |l| == 0 {\n    // Base case\n  } else {\n    MapLength(l[1..], f);\n  }\n}\n\nlemma MapCompose<T, U, V>(l: seq<T>, f: T -> U, g: U -> V)\n  ensures listMap(listMap(l, f), g) == listMap(l, (x: T) => g(f(x)))\n{\n  if |l| == 0 {\n    // Base case\n  } else {\n    MapCompose(l[1..], f, g);\n  }\n}", "output": "FilterSubset(l[1..], p, x);"}, {"id": "example_FilterSubset_2", "type": "assert", "program": "// List operations: append, length, nth element\n\nfunction {:spec} length<T>(l: seq<T>): nat\n{\n  |l|\n}\n\nfunction {:spec} append<T>(l1: seq<T>, l2: seq<T>): seq<T>\n{\n  l1 + l2\n}\n\nfunction {:spec} nth<T>(l: seq<T>, n: nat): T\n  requires n < |l|\n{\n  l[n]\n}\n\npredicate {:spec} contains<T(==)>(l: seq<T>, x: T)\n{\n  x in l\n}\n\nfunction {:spec} indexOf<T(==)>(l: seq<T>, x: T): int\n  requires x in l\n{\n  if l[0] == x then 0\n  else 1 + indexOf(l[1..], x)\n}\n\nfunction {:spec} take<T>(l: seq<T>, n: nat): seq<T>\n{\n  if n >= |l| then l\n  else l[..n]\n}\n\nfunction {:spec} drop<T>(l: seq<T>, n: nat): seq<T>\n{\n  if n >= |l| then []\n  else l[n..]\n}\n\nfunction {:spec} filter<T>(l: seq<T>, p: T -> bool): seq<T>\n{\n  if |l| == 0 then []\n  else if p(l[0]) then [l[0]] + filter(l[1..], p)\n  else filter(l[1..], p)\n}\n\nfunction {:spec} listMap<T, U>(l: seq<T>, f: T -> U): seq<U>\n{\n  if |l| == 0 then []\n  else [f(l[0])] + listMap(l[1..], f)\n}\n\nlemma AppendAssociative<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures append(append(a, b), c) == append(a, append(b, c))\n{\n  // Dafny proves this automatically\n}\n\nlemma AppendNeutral<T>(l: seq<T>)\n  ensures append(l, []) == l\n  ensures append([], l) == l\n{\n  // Dafny proves this automatically\n}\n\nlemma AppendLength<T>(l1: seq<T>, l2: seq<T>)\n  ensures length(append(l1, l2)) == length(l1) + length(l2)\n{\n  // Dafny proves this automatically\n}\n\nlemma NthAppend<T>(l1: seq<T>, l2: seq<T>, n: nat)\n  requires n < |l1| + |l2|\n  ensures nth(append(l1, l2), n) == (if n < |l1| then nth(l1, n) else nth(l2, n - |l1|))\n{\n  // Dafny proves this automatically\n}\n\nlemma IndexOfCorrect<T>(l: seq<T>, x: T)\n  requires x in l\n  ensures 0 <= indexOf(l, x) < |l|\n  ensures l[indexOf(l, x)] == x\n  ensures forall i :: 0 <= i < indexOf(l, x) ==> l[i] != x\n{\n  if l[0] == x {\n    // Base case\n  } else {\n    IndexOfCorrect(l[1..], x);\n  }\n}\n\nlemma TakeDropConcat<T>(l: seq<T>, n: nat)\n  ensures append(take(l, n), drop(l, n)) == l\n{\n  if n >= |l| {\n    assert take(l, n) == l;\n    assert drop(l, n) == [];\n  }\n}\n\nlemma FilterSubset<T>(l: seq<T>, p: T -> bool, x: T)\n  requires x in filter(l, p)\n  ensures x in l && p(x)\n{\n  if |l| > 0 {\n    if p(l[0]) && x == l[0] {\n      // Found it\n    } else if p(l[0]) {\n      \n/*[CODE HERE]*/\n      FilterSubset(l[1..], p, x);\n    } else {\n      FilterSubset(l[1..], p, x);\n    }\n  }\n}\n\nlemma MapLength<T, U>(l: seq<T>, f: T -> U)\n  ensures |listMap(l, f)| == |l|\n{\n  if |l| == 0 {\n    // Base case\n  } else {\n    MapLength(l[1..], f);\n  }\n}\n\nlemma MapCompose<T, U, V>(l: seq<T>, f: T -> U, g: U -> V)\n  ensures listMap(listMap(l, f), g) == listMap(l, (x: T) => g(f(x)))\n{\n  if |l| == 0 {\n    // Base case\n  } else {\n    MapCompose(l[1..], f, g);\n  }\n}", "output": "assert x in filter(l[1..], p);"}, {"id": "example_MapLength_0", "type": "call", "program": "// List operations: append, length, nth element\n\nfunction {:spec} length<T>(l: seq<T>): nat\n{\n  |l|\n}\n\nfunction {:spec} append<T>(l1: seq<T>, l2: seq<T>): seq<T>\n{\n  l1 + l2\n}\n\nfunction {:spec} nth<T>(l: seq<T>, n: nat): T\n  requires n < |l|\n{\n  l[n]\n}\n\npredicate {:spec} contains<T(==)>(l: seq<T>, x: T)\n{\n  x in l\n}\n\nfunction {:spec} indexOf<T(==)>(l: seq<T>, x: T): int\n  requires x in l\n{\n  if l[0] == x then 0\n  else 1 + indexOf(l[1..], x)\n}\n\nfunction {:spec} take<T>(l: seq<T>, n: nat): seq<T>\n{\n  if n >= |l| then l\n  else l[..n]\n}\n\nfunction {:spec} drop<T>(l: seq<T>, n: nat): seq<T>\n{\n  if n >= |l| then []\n  else l[n..]\n}\n\nfunction {:spec} filter<T>(l: seq<T>, p: T -> bool): seq<T>\n{\n  if |l| == 0 then []\n  else if p(l[0]) then [l[0]] + filter(l[1..], p)\n  else filter(l[1..], p)\n}\n\nfunction {:spec} listMap<T, U>(l: seq<T>, f: T -> U): seq<U>\n{\n  if |l| == 0 then []\n  else [f(l[0])] + listMap(l[1..], f)\n}\n\nlemma AppendAssociative<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures append(append(a, b), c) == append(a, append(b, c))\n{\n  // Dafny proves this automatically\n}\n\nlemma AppendNeutral<T>(l: seq<T>)\n  ensures append(l, []) == l\n  ensures append([], l) == l\n{\n  // Dafny proves this automatically\n}\n\nlemma AppendLength<T>(l1: seq<T>, l2: seq<T>)\n  ensures length(append(l1, l2)) == length(l1) + length(l2)\n{\n  // Dafny proves this automatically\n}\n\nlemma NthAppend<T>(l1: seq<T>, l2: seq<T>, n: nat)\n  requires n < |l1| + |l2|\n  ensures nth(append(l1, l2), n) == (if n < |l1| then nth(l1, n) else nth(l2, n - |l1|))\n{\n  // Dafny proves this automatically\n}\n\nlemma IndexOfCorrect<T>(l: seq<T>, x: T)\n  requires x in l\n  ensures 0 <= indexOf(l, x) < |l|\n  ensures l[indexOf(l, x)] == x\n  ensures forall i :: 0 <= i < indexOf(l, x) ==> l[i] != x\n{\n  if l[0] == x {\n    // Base case\n  } else {\n    IndexOfCorrect(l[1..], x);\n  }\n}\n\nlemma TakeDropConcat<T>(l: seq<T>, n: nat)\n  ensures append(take(l, n), drop(l, n)) == l\n{\n  if n >= |l| {\n    assert take(l, n) == l;\n    assert drop(l, n) == [];\n  }\n}\n\nlemma FilterSubset<T>(l: seq<T>, p: T -> bool, x: T)\n  requires x in filter(l, p)\n  ensures x in l && p(x)\n{\n  if |l| > 0 {\n    if p(l[0]) && x == l[0] {\n      // Found it\n    } else if p(l[0]) {\n      assert x in filter(l[1..], p);\n      FilterSubset(l[1..], p, x);\n    } else {\n      FilterSubset(l[1..], p, x);\n    }\n  }\n}\n\nlemma MapLength<T, U>(l: seq<T>, f: T -> U)\n  ensures |listMap(l, f)| == |l|\n{\n  if |l| == 0 {\n    // Base case\n  } else {\n    \n/*[CODE HERE]*/\n  }\n}\n\nlemma MapCompose<T, U, V>(l: seq<T>, f: T -> U, g: U -> V)\n  ensures listMap(listMap(l, f), g) == listMap(l, (x: T) => g(f(x)))\n{\n  if |l| == 0 {\n    // Base case\n  } else {\n    MapCompose(l[1..], f, g);\n  }\n}", "output": "MapLength(l[1..], f);"}, {"id": "example_MapCompose_0", "type": "call", "program": "// List operations: append, length, nth element\n\nfunction {:spec} length<T>(l: seq<T>): nat\n{\n  |l|\n}\n\nfunction {:spec} append<T>(l1: seq<T>, l2: seq<T>): seq<T>\n{\n  l1 + l2\n}\n\nfunction {:spec} nth<T>(l: seq<T>, n: nat): T\n  requires n < |l|\n{\n  l[n]\n}\n\npredicate {:spec} contains<T(==)>(l: seq<T>, x: T)\n{\n  x in l\n}\n\nfunction {:spec} indexOf<T(==)>(l: seq<T>, x: T): int\n  requires x in l\n{\n  if l[0] == x then 0\n  else 1 + indexOf(l[1..], x)\n}\n\nfunction {:spec} take<T>(l: seq<T>, n: nat): seq<T>\n{\n  if n >= |l| then l\n  else l[..n]\n}\n\nfunction {:spec} drop<T>(l: seq<T>, n: nat): seq<T>\n{\n  if n >= |l| then []\n  else l[n..]\n}\n\nfunction {:spec} filter<T>(l: seq<T>, p: T -> bool): seq<T>\n{\n  if |l| == 0 then []\n  else if p(l[0]) then [l[0]] + filter(l[1..], p)\n  else filter(l[1..], p)\n}\n\nfunction {:spec} listMap<T, U>(l: seq<T>, f: T -> U): seq<U>\n{\n  if |l| == 0 then []\n  else [f(l[0])] + listMap(l[1..], f)\n}\n\nlemma AppendAssociative<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures append(append(a, b), c) == append(a, append(b, c))\n{\n  // Dafny proves this automatically\n}\n\nlemma AppendNeutral<T>(l: seq<T>)\n  ensures append(l, []) == l\n  ensures append([], l) == l\n{\n  // Dafny proves this automatically\n}\n\nlemma AppendLength<T>(l1: seq<T>, l2: seq<T>)\n  ensures length(append(l1, l2)) == length(l1) + length(l2)\n{\n  // Dafny proves this automatically\n}\n\nlemma NthAppend<T>(l1: seq<T>, l2: seq<T>, n: nat)\n  requires n < |l1| + |l2|\n  ensures nth(append(l1, l2), n) == (if n < |l1| then nth(l1, n) else nth(l2, n - |l1|))\n{\n  // Dafny proves this automatically\n}\n\nlemma IndexOfCorrect<T>(l: seq<T>, x: T)\n  requires x in l\n  ensures 0 <= indexOf(l, x) < |l|\n  ensures l[indexOf(l, x)] == x\n  ensures forall i :: 0 <= i < indexOf(l, x) ==> l[i] != x\n{\n  if l[0] == x {\n    // Base case\n  } else {\n    IndexOfCorrect(l[1..], x);\n  }\n}\n\nlemma TakeDropConcat<T>(l: seq<T>, n: nat)\n  ensures append(take(l, n), drop(l, n)) == l\n{\n  if n >= |l| {\n    assert take(l, n) == l;\n    assert drop(l, n) == [];\n  }\n}\n\nlemma FilterSubset<T>(l: seq<T>, p: T -> bool, x: T)\n  requires x in filter(l, p)\n  ensures x in l && p(x)\n{\n  if |l| > 0 {\n    if p(l[0]) && x == l[0] {\n      // Found it\n    } else if p(l[0]) {\n      assert x in filter(l[1..], p);\n      FilterSubset(l[1..], p, x);\n    } else {\n      FilterSubset(l[1..], p, x);\n    }\n  }\n}\n\nlemma MapLength<T, U>(l: seq<T>, f: T -> U)\n  ensures |listMap(l, f)| == |l|\n{\n  if |l| == 0 {\n    // Base case\n  } else {\n    MapLength(l[1..], f);\n  }\n}\n\nlemma MapCompose<T, U, V>(l: seq<T>, f: T -> U, g: U -> V)\n  ensures listMap(listMap(l, f), g) == listMap(l, (x: T) => g(f(x)))\n{\n  if |l| == 0 {\n    // Base case\n  } else {\n    \n/*[CODE HERE]*/\n  }\n}", "output": "MapCompose(l[1..], f, g);"}, {"id": "example_sumCorrect_0", "type": "call", "program": "function sum(xs: seq<int>): int\n{\n  if |xs| == 0 then 0\n  else xs[0] + sum(xs[1..])\n}\n\nfunction sumTail(xs: seq<int>, acc: int): int\n  decreases |xs|\n{\n  if |xs| == 0 then acc\n  else sumTail(xs[1..], acc + xs[0])\n}\n\nlemma sumCorrect(xs: seq<int>)\n  ensures sum(xs) == sumTail(xs, 0)\n{\n  \n/*[CODE HERE]*/\n}\n\nlemma sumCorrectHelper(xs: seq<int>, acc: int)\n  ensures sumTail(xs, acc) == acc + sum(xs)\n{\n  if |xs| == 0 {\n  } else {\n    calc {\n      sumTail(xs, acc);\n      == sumTail(xs[1..], acc + xs[0]);\n      == { sumCorrectHelper(xs[1..], acc + xs[0]); }\n      (acc + xs[0]) + sum(xs[1..]);\n      == acc + (xs[0] + sum(xs[1..]));\n      == acc + sum(xs);\n    }\n  }\n}\n\nlemma sumAppend(xs: seq<int>, ys: seq<int>)\n  ensures sum(xs + ys) == sum(xs) + sum(ys)\n{\n  if |xs| == 0 {\n    assert xs + ys == ys;\n  } else {\n    assert xs + ys == [xs[0]] + (xs[1..] + ys);\n    calc {\n      sum(xs + ys);\n      == xs[0] + sum((xs[1..] + ys));\n      == { sumAppend(xs[1..], ys); }\n      xs[0] + (sum(xs[1..]) + sum(ys));\n      == (xs[0] + sum(xs[1..])) + sum(ys);\n      == sum(xs) + sum(ys);\n    }\n  }\n}\n\nlemma sumDistributive(xs: seq<int>, c: int)\n  ensures sum(seq(|xs|, i requires 0 <= i < |xs| => c * xs[i])) == c * sum(xs)\n{\n  if |xs| == 0 {\n    // Base case: empty sequence\n    assert seq(|xs|, i requires 0 <= i < |xs| => c * xs[i]) == [];\n    assert sum([]) == 0;\n    assert c * sum([]) == c * 0 == 0;\n  } else {\n    // Inductive case: non-empty sequence\n    var scaled_xs := seq(|xs|, i requires 0 <= i < |xs| => c * xs[i]);\n    assert scaled_xs == [c * xs[0]] + seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i]);\n    \n    calc {\n      sum(scaled_xs);\n      == sum([c * xs[0]] + seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i]));\n      == { sumAppend([c * xs[0]], seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i])); }\n      sum([c * xs[0]]) + sum(seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i]));\n      == c * xs[0] + sum(seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i]));\n      == { sumDistributive(xs[1..], c); }\n      c * xs[0] + c * sum(xs[1..]);\n      == c * (xs[0] + sum(xs[1..]));\n      == c * sum(xs);\n    }\n  }\n}\n", "output": "sumCorrectHelper(xs, 0);"}, {"id": "example_sumCorrectHelper_0", "type": "call", "program": "function sum(xs: seq<int>): int\n{\n  if |xs| == 0 then 0\n  else xs[0] + sum(xs[1..])\n}\n\nfunction sumTail(xs: seq<int>, acc: int): int\n  decreases |xs|\n{\n  if |xs| == 0 then acc\n  else sumTail(xs[1..], acc + xs[0])\n}\n\nlemma sumCorrect(xs: seq<int>)\n  ensures sum(xs) == sumTail(xs, 0)\n{\n  sumCorrectHelper(xs, 0);\n}\n\nlemma sumCorrectHelper(xs: seq<int>, acc: int)\n  ensures sumTail(xs, acc) == acc + sum(xs)\n{\n  if |xs| == 0 {\n  } else {\n    calc {\n      sumTail(xs, acc);\n      == sumTail(xs[1..], acc + xs[0]);\n      == { \n/*[CODE HERE]*/\n}\n      (acc + xs[0]) + sum(xs[1..]);\n      == acc + (xs[0] + sum(xs[1..]));\n      == acc + sum(xs);\n    }\n  }\n}\n\nlemma sumAppend(xs: seq<int>, ys: seq<int>)\n  ensures sum(xs + ys) == sum(xs) + sum(ys)\n{\n  if |xs| == 0 {\n    assert xs + ys == ys;\n  } else {\n    assert xs + ys == [xs[0]] + (xs[1..] + ys);\n    calc {\n      sum(xs + ys);\n      == xs[0] + sum((xs[1..] + ys));\n      == { sumAppend(xs[1..], ys); }\n      xs[0] + (sum(xs[1..]) + sum(ys));\n      == (xs[0] + sum(xs[1..])) + sum(ys);\n      == sum(xs) + sum(ys);\n    }\n  }\n}\n\nlemma sumDistributive(xs: seq<int>, c: int)\n  ensures sum(seq(|xs|, i requires 0 <= i < |xs| => c * xs[i])) == c * sum(xs)\n{\n  if |xs| == 0 {\n    // Base case: empty sequence\n    assert seq(|xs|, i requires 0 <= i < |xs| => c * xs[i]) == [];\n    assert sum([]) == 0;\n    assert c * sum([]) == c * 0 == 0;\n  } else {\n    // Inductive case: non-empty sequence\n    var scaled_xs := seq(|xs|, i requires 0 <= i < |xs| => c * xs[i]);\n    assert scaled_xs == [c * xs[0]] + seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i]);\n    \n    calc {\n      sum(scaled_xs);\n      == sum([c * xs[0]] + seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i]));\n      == { sumAppend([c * xs[0]], seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i])); }\n      sum([c * xs[0]]) + sum(seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i]));\n      == c * xs[0] + sum(seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i]));\n      == { sumDistributive(xs[1..], c); }\n      c * xs[0] + c * sum(xs[1..]);\n      == c * (xs[0] + sum(xs[1..]));\n      == c * sum(xs);\n    }\n  }\n}\n", "output": "sumCorrectHelper(xs[1..], acc + xs[0]);"}, {"id": "example_sumAppend_0", "type": "call", "program": "function sum(xs: seq<int>): int\n{\n  if |xs| == 0 then 0\n  else xs[0] + sum(xs[1..])\n}\n\nfunction sumTail(xs: seq<int>, acc: int): int\n  decreases |xs|\n{\n  if |xs| == 0 then acc\n  else sumTail(xs[1..], acc + xs[0])\n}\n\nlemma sumCorrect(xs: seq<int>)\n  ensures sum(xs) == sumTail(xs, 0)\n{\n  sumCorrectHelper(xs, 0);\n}\n\nlemma sumCorrectHelper(xs: seq<int>, acc: int)\n  ensures sumTail(xs, acc) == acc + sum(xs)\n{\n  if |xs| == 0 {\n  } else {\n    calc {\n      sumTail(xs, acc);\n      == sumTail(xs[1..], acc + xs[0]);\n      == { sumCorrectHelper(xs[1..], acc + xs[0]); }\n      (acc + xs[0]) + sum(xs[1..]);\n      == acc + (xs[0] + sum(xs[1..]));\n      == acc + sum(xs);\n    }\n  }\n}\n\nlemma sumAppend(xs: seq<int>, ys: seq<int>)\n  ensures sum(xs + ys) == sum(xs) + sum(ys)\n{\n  if |xs| == 0 {\n    assert xs + ys == ys;\n  } else {\n    assert xs + ys == [xs[0]] + (xs[1..] + ys);\n    calc {\n      sum(xs + ys);\n      == xs[0] + sum((xs[1..] + ys));\n      == { \n/*[CODE HERE]*/\n}\n      xs[0] + (sum(xs[1..]) + sum(ys));\n      == (xs[0] + sum(xs[1..])) + sum(ys);\n      == sum(xs) + sum(ys);\n    }\n  }\n}\n\nlemma sumDistributive(xs: seq<int>, c: int)\n  ensures sum(seq(|xs|, i requires 0 <= i < |xs| => c * xs[i])) == c * sum(xs)\n{\n  if |xs| == 0 {\n    // Base case: empty sequence\n    assert seq(|xs|, i requires 0 <= i < |xs| => c * xs[i]) == [];\n    assert sum([]) == 0;\n    assert c * sum([]) == c * 0 == 0;\n  } else {\n    // Inductive case: non-empty sequence\n    var scaled_xs := seq(|xs|, i requires 0 <= i < |xs| => c * xs[i]);\n    assert scaled_xs == [c * xs[0]] + seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i]);\n    \n    calc {\n      sum(scaled_xs);\n      == sum([c * xs[0]] + seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i]));\n      == { sumAppend([c * xs[0]], seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i])); }\n      sum([c * xs[0]]) + sum(seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i]));\n      == c * xs[0] + sum(seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i]));\n      == { sumDistributive(xs[1..], c); }\n      c * xs[0] + c * sum(xs[1..]);\n      == c * (xs[0] + sum(xs[1..]));\n      == c * sum(xs);\n    }\n  }\n}\n", "output": "sumAppend(xs[1..], ys);"}, {"id": "example_sumAppend_1", "type": "assert", "program": "function sum(xs: seq<int>): int\n{\n  if |xs| == 0 then 0\n  else xs[0] + sum(xs[1..])\n}\n\nfunction sumTail(xs: seq<int>, acc: int): int\n  decreases |xs|\n{\n  if |xs| == 0 then acc\n  else sumTail(xs[1..], acc + xs[0])\n}\n\nlemma sumCorrect(xs: seq<int>)\n  ensures sum(xs) == sumTail(xs, 0)\n{\n  sumCorrectHelper(xs, 0);\n}\n\nlemma sumCorrectHelper(xs: seq<int>, acc: int)\n  ensures sumTail(xs, acc) == acc + sum(xs)\n{\n  if |xs| == 0 {\n  } else {\n    calc {\n      sumTail(xs, acc);\n      == sumTail(xs[1..], acc + xs[0]);\n      == { sumCorrectHelper(xs[1..], acc + xs[0]); }\n      (acc + xs[0]) + sum(xs[1..]);\n      == acc + (xs[0] + sum(xs[1..]));\n      == acc + sum(xs);\n    }\n  }\n}\n\nlemma sumAppend(xs: seq<int>, ys: seq<int>)\n  ensures sum(xs + ys) == sum(xs) + sum(ys)\n{\n  if |xs| == 0 {\n    assert xs + ys == ys;\n  } else {\n    \n/*[CODE HERE]*/\n    calc {\n      sum(xs + ys);\n      == xs[0] + sum((xs[1..] + ys));\n      == { sumAppend(xs[1..], ys); }\n      xs[0] + (sum(xs[1..]) + sum(ys));\n      == (xs[0] + sum(xs[1..])) + sum(ys);\n      == sum(xs) + sum(ys);\n    }\n  }\n}\n\nlemma sumDistributive(xs: seq<int>, c: int)\n  ensures sum(seq(|xs|, i requires 0 <= i < |xs| => c * xs[i])) == c * sum(xs)\n{\n  if |xs| == 0 {\n    // Base case: empty sequence\n    assert seq(|xs|, i requires 0 <= i < |xs| => c * xs[i]) == [];\n    assert sum([]) == 0;\n    assert c * sum([]) == c * 0 == 0;\n  } else {\n    // Inductive case: non-empty sequence\n    var scaled_xs := seq(|xs|, i requires 0 <= i < |xs| => c * xs[i]);\n    assert scaled_xs == [c * xs[0]] + seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i]);\n    \n    calc {\n      sum(scaled_xs);\n      == sum([c * xs[0]] + seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i]));\n      == { sumAppend([c * xs[0]], seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i])); }\n      sum([c * xs[0]]) + sum(seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i]));\n      == c * xs[0] + sum(seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i]));\n      == { sumDistributive(xs[1..], c); }\n      c * xs[0] + c * sum(xs[1..]);\n      == c * (xs[0] + sum(xs[1..]));\n      == c * sum(xs);\n    }\n  }\n}\n", "output": "assert xs + ys == [xs[0]] + (xs[1..] + ys);"}, {"id": "example_sumAppend_2", "type": "assert", "program": "function sum(xs: seq<int>): int\n{\n  if |xs| == 0 then 0\n  else xs[0] + sum(xs[1..])\n}\n\nfunction sumTail(xs: seq<int>, acc: int): int\n  decreases |xs|\n{\n  if |xs| == 0 then acc\n  else sumTail(xs[1..], acc + xs[0])\n}\n\nlemma sumCorrect(xs: seq<int>)\n  ensures sum(xs) == sumTail(xs, 0)\n{\n  sumCorrectHelper(xs, 0);\n}\n\nlemma sumCorrectHelper(xs: seq<int>, acc: int)\n  ensures sumTail(xs, acc) == acc + sum(xs)\n{\n  if |xs| == 0 {\n  } else {\n    calc {\n      sumTail(xs, acc);\n      == sumTail(xs[1..], acc + xs[0]);\n      == { sumCorrectHelper(xs[1..], acc + xs[0]); }\n      (acc + xs[0]) + sum(xs[1..]);\n      == acc + (xs[0] + sum(xs[1..]));\n      == acc + sum(xs);\n    }\n  }\n}\n\nlemma sumAppend(xs: seq<int>, ys: seq<int>)\n  ensures sum(xs + ys) == sum(xs) + sum(ys)\n{\n  if |xs| == 0 {\n    \n/*[CODE HERE]*/\n  } else {\n    assert xs + ys == [xs[0]] + (xs[1..] + ys);\n    calc {\n      sum(xs + ys);\n      == xs[0] + sum((xs[1..] + ys));\n      == { sumAppend(xs[1..], ys); }\n      xs[0] + (sum(xs[1..]) + sum(ys));\n      == (xs[0] + sum(xs[1..])) + sum(ys);\n      == sum(xs) + sum(ys);\n    }\n  }\n}\n\nlemma sumDistributive(xs: seq<int>, c: int)\n  ensures sum(seq(|xs|, i requires 0 <= i < |xs| => c * xs[i])) == c * sum(xs)\n{\n  if |xs| == 0 {\n    // Base case: empty sequence\n    assert seq(|xs|, i requires 0 <= i < |xs| => c * xs[i]) == [];\n    assert sum([]) == 0;\n    assert c * sum([]) == c * 0 == 0;\n  } else {\n    // Inductive case: non-empty sequence\n    var scaled_xs := seq(|xs|, i requires 0 <= i < |xs| => c * xs[i]);\n    assert scaled_xs == [c * xs[0]] + seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i]);\n    \n    calc {\n      sum(scaled_xs);\n      == sum([c * xs[0]] + seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i]));\n      == { sumAppend([c * xs[0]], seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i])); }\n      sum([c * xs[0]]) + sum(seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i]));\n      == c * xs[0] + sum(seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i]));\n      == { sumDistributive(xs[1..], c); }\n      c * xs[0] + c * sum(xs[1..]);\n      == c * (xs[0] + sum(xs[1..]));\n      == c * sum(xs);\n    }\n  }\n}\n", "output": "assert xs + ys == ys;"}, {"id": "example_sumDistributive_0", "type": "call", "program": "function sum(xs: seq<int>): int\n{\n  if |xs| == 0 then 0\n  else xs[0] + sum(xs[1..])\n}\n\nfunction sumTail(xs: seq<int>, acc: int): int\n  decreases |xs|\n{\n  if |xs| == 0 then acc\n  else sumTail(xs[1..], acc + xs[0])\n}\n\nlemma sumCorrect(xs: seq<int>)\n  ensures sum(xs) == sumTail(xs, 0)\n{\n  sumCorrectHelper(xs, 0);\n}\n\nlemma sumCorrectHelper(xs: seq<int>, acc: int)\n  ensures sumTail(xs, acc) == acc + sum(xs)\n{\n  if |xs| == 0 {\n  } else {\n    calc {\n      sumTail(xs, acc);\n      == sumTail(xs[1..], acc + xs[0]);\n      == { sumCorrectHelper(xs[1..], acc + xs[0]); }\n      (acc + xs[0]) + sum(xs[1..]);\n      == acc + (xs[0] + sum(xs[1..]));\n      == acc + sum(xs);\n    }\n  }\n}\n\nlemma sumAppend(xs: seq<int>, ys: seq<int>)\n  ensures sum(xs + ys) == sum(xs) + sum(ys)\n{\n  if |xs| == 0 {\n    assert xs + ys == ys;\n  } else {\n    assert xs + ys == [xs[0]] + (xs[1..] + ys);\n    calc {\n      sum(xs + ys);\n      == xs[0] + sum((xs[1..] + ys));\n      == { sumAppend(xs[1..], ys); }\n      xs[0] + (sum(xs[1..]) + sum(ys));\n      == (xs[0] + sum(xs[1..])) + sum(ys);\n      == sum(xs) + sum(ys);\n    }\n  }\n}\n\nlemma sumDistributive(xs: seq<int>, c: int)\n  ensures sum(seq(|xs|, i requires 0 <= i < |xs| => c * xs[i])) == c * sum(xs)\n{\n  if |xs| == 0 {\n    // Base case: empty sequence\n    assert seq(|xs|, i requires 0 <= i < |xs| => c * xs[i]) == [];\n    assert sum([]) == 0;\n    assert c * sum([]) == c * 0 == 0;\n  } else {\n    // Inductive case: non-empty sequence\n    var scaled_xs := seq(|xs|, i requires 0 <= i < |xs| => c * xs[i]);\n    assert scaled_xs == [c * xs[0]] + seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i]);\n    \n    calc {\n      sum(scaled_xs);\n      == sum([c * xs[0]] + seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i]));\n      == { sumAppend([c * xs[0]], seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i])); }\n      sum([c * xs[0]]) + sum(seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i]));\n      == c * xs[0] + sum(seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i]));\n      == { \n/*[CODE HERE]*/\n}\n      c * xs[0] + c * sum(xs[1..]);\n      == c * (xs[0] + sum(xs[1..]));\n      == c * sum(xs);\n    }\n  }\n}\n", "output": "sumDistributive(xs[1..], c);"}, {"id": "example_sumDistributive_1", "type": "call", "program": "function sum(xs: seq<int>): int\n{\n  if |xs| == 0 then 0\n  else xs[0] + sum(xs[1..])\n}\n\nfunction sumTail(xs: seq<int>, acc: int): int\n  decreases |xs|\n{\n  if |xs| == 0 then acc\n  else sumTail(xs[1..], acc + xs[0])\n}\n\nlemma sumCorrect(xs: seq<int>)\n  ensures sum(xs) == sumTail(xs, 0)\n{\n  sumCorrectHelper(xs, 0);\n}\n\nlemma sumCorrectHelper(xs: seq<int>, acc: int)\n  ensures sumTail(xs, acc) == acc + sum(xs)\n{\n  if |xs| == 0 {\n  } else {\n    calc {\n      sumTail(xs, acc);\n      == sumTail(xs[1..], acc + xs[0]);\n      == { sumCorrectHelper(xs[1..], acc + xs[0]); }\n      (acc + xs[0]) + sum(xs[1..]);\n      == acc + (xs[0] + sum(xs[1..]));\n      == acc + sum(xs);\n    }\n  }\n}\n\nlemma sumAppend(xs: seq<int>, ys: seq<int>)\n  ensures sum(xs + ys) == sum(xs) + sum(ys)\n{\n  if |xs| == 0 {\n    assert xs + ys == ys;\n  } else {\n    assert xs + ys == [xs[0]] + (xs[1..] + ys);\n    calc {\n      sum(xs + ys);\n      == xs[0] + sum((xs[1..] + ys));\n      == { sumAppend(xs[1..], ys); }\n      xs[0] + (sum(xs[1..]) + sum(ys));\n      == (xs[0] + sum(xs[1..])) + sum(ys);\n      == sum(xs) + sum(ys);\n    }\n  }\n}\n\nlemma sumDistributive(xs: seq<int>, c: int)\n  ensures sum(seq(|xs|, i requires 0 <= i < |xs| => c * xs[i])) == c * sum(xs)\n{\n  if |xs| == 0 {\n    // Base case: empty sequence\n    assert seq(|xs|, i requires 0 <= i < |xs| => c * xs[i]) == [];\n    assert sum([]) == 0;\n    assert c * sum([]) == c * 0 == 0;\n  } else {\n    // Inductive case: non-empty sequence\n    var scaled_xs := seq(|xs|, i requires 0 <= i < |xs| => c * xs[i]);\n    assert scaled_xs == [c * xs[0]] + seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i]);\n    \n    calc {\n      sum(scaled_xs);\n      == sum([c * xs[0]] + seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i]));\n      == { \n/*[CODE HERE]*/\n}\n      sum([c * xs[0]]) + sum(seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i]));\n      == c * xs[0] + sum(seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i]));\n      == { sumDistributive(xs[1..], c); }\n      c * xs[0] + c * sum(xs[1..]);\n      == c * (xs[0] + sum(xs[1..]));\n      == c * sum(xs);\n    }\n  }\n}\n", "output": "sumAppend([c * xs[0]], seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i]));"}, {"id": "example_sumDistributive_2", "type": "assert", "program": "function sum(xs: seq<int>): int\n{\n  if |xs| == 0 then 0\n  else xs[0] + sum(xs[1..])\n}\n\nfunction sumTail(xs: seq<int>, acc: int): int\n  decreases |xs|\n{\n  if |xs| == 0 then acc\n  else sumTail(xs[1..], acc + xs[0])\n}\n\nlemma sumCorrect(xs: seq<int>)\n  ensures sum(xs) == sumTail(xs, 0)\n{\n  sumCorrectHelper(xs, 0);\n}\n\nlemma sumCorrectHelper(xs: seq<int>, acc: int)\n  ensures sumTail(xs, acc) == acc + sum(xs)\n{\n  if |xs| == 0 {\n  } else {\n    calc {\n      sumTail(xs, acc);\n      == sumTail(xs[1..], acc + xs[0]);\n      == { sumCorrectHelper(xs[1..], acc + xs[0]); }\n      (acc + xs[0]) + sum(xs[1..]);\n      == acc + (xs[0] + sum(xs[1..]));\n      == acc + sum(xs);\n    }\n  }\n}\n\nlemma sumAppend(xs: seq<int>, ys: seq<int>)\n  ensures sum(xs + ys) == sum(xs) + sum(ys)\n{\n  if |xs| == 0 {\n    assert xs + ys == ys;\n  } else {\n    assert xs + ys == [xs[0]] + (xs[1..] + ys);\n    calc {\n      sum(xs + ys);\n      == xs[0] + sum((xs[1..] + ys));\n      == { sumAppend(xs[1..], ys); }\n      xs[0] + (sum(xs[1..]) + sum(ys));\n      == (xs[0] + sum(xs[1..])) + sum(ys);\n      == sum(xs) + sum(ys);\n    }\n  }\n}\n\nlemma sumDistributive(xs: seq<int>, c: int)\n  ensures sum(seq(|xs|, i requires 0 <= i < |xs| => c * xs[i])) == c * sum(xs)\n{\n  if |xs| == 0 {\n    // Base case: empty sequence\n    assert seq(|xs|, i requires 0 <= i < |xs| => c * xs[i]) == [];\n    assert sum([]) == 0;\n    assert c * sum([]) == c * 0 == 0;\n  } else {\n    // Inductive case: non-empty sequence\n    var scaled_xs := seq(|xs|, i requires 0 <= i < |xs| => c * xs[i]);\n    \n/*[CODE HERE]*/\n    \n    calc {\n      sum(scaled_xs);\n      == sum([c * xs[0]] + seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i]));\n      == { sumAppend([c * xs[0]], seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i])); }\n      sum([c * xs[0]]) + sum(seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i]));\n      == c * xs[0] + sum(seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i]));\n      == { sumDistributive(xs[1..], c); }\n      c * xs[0] + c * sum(xs[1..]);\n      == c * (xs[0] + sum(xs[1..]));\n      == c * sum(xs);\n    }\n  }\n}\n", "output": "assert scaled_xs == [c * xs[0]] + seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i]);"}, {"id": "example_sumDistributive_3", "type": "assert", "program": "function sum(xs: seq<int>): int\n{\n  if |xs| == 0 then 0\n  else xs[0] + sum(xs[1..])\n}\n\nfunction sumTail(xs: seq<int>, acc: int): int\n  decreases |xs|\n{\n  if |xs| == 0 then acc\n  else sumTail(xs[1..], acc + xs[0])\n}\n\nlemma sumCorrect(xs: seq<int>)\n  ensures sum(xs) == sumTail(xs, 0)\n{\n  sumCorrectHelper(xs, 0);\n}\n\nlemma sumCorrectHelper(xs: seq<int>, acc: int)\n  ensures sumTail(xs, acc) == acc + sum(xs)\n{\n  if |xs| == 0 {\n  } else {\n    calc {\n      sumTail(xs, acc);\n      == sumTail(xs[1..], acc + xs[0]);\n      == { sumCorrectHelper(xs[1..], acc + xs[0]); }\n      (acc + xs[0]) + sum(xs[1..]);\n      == acc + (xs[0] + sum(xs[1..]));\n      == acc + sum(xs);\n    }\n  }\n}\n\nlemma sumAppend(xs: seq<int>, ys: seq<int>)\n  ensures sum(xs + ys) == sum(xs) + sum(ys)\n{\n  if |xs| == 0 {\n    assert xs + ys == ys;\n  } else {\n    assert xs + ys == [xs[0]] + (xs[1..] + ys);\n    calc {\n      sum(xs + ys);\n      == xs[0] + sum((xs[1..] + ys));\n      == { sumAppend(xs[1..], ys); }\n      xs[0] + (sum(xs[1..]) + sum(ys));\n      == (xs[0] + sum(xs[1..])) + sum(ys);\n      == sum(xs) + sum(ys);\n    }\n  }\n}\n\nlemma sumDistributive(xs: seq<int>, c: int)\n  ensures sum(seq(|xs|, i requires 0 <= i < |xs| => c * xs[i])) == c * sum(xs)\n{\n  if |xs| == 0 {\n    // Base case: empty sequence\n    assert seq(|xs|, i requires 0 <= i < |xs| => c * xs[i]) == [];\n    assert sum([]) == 0;\n    \n/*[CODE HERE]*/\n  } else {\n    // Inductive case: non-empty sequence\n    var scaled_xs := seq(|xs|, i requires 0 <= i < |xs| => c * xs[i]);\n    assert scaled_xs == [c * xs[0]] + seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i]);\n    \n    calc {\n      sum(scaled_xs);\n      == sum([c * xs[0]] + seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i]));\n      == { sumAppend([c * xs[0]], seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i])); }\n      sum([c * xs[0]]) + sum(seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i]));\n      == c * xs[0] + sum(seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i]));\n      == { sumDistributive(xs[1..], c); }\n      c * xs[0] + c * sum(xs[1..]);\n      == c * (xs[0] + sum(xs[1..]));\n      == c * sum(xs);\n    }\n  }\n}\n", "output": "assert c * sum([]) == c * 0 == 0;"}, {"id": "example_sumDistributive_4", "type": "assert", "program": "function sum(xs: seq<int>): int\n{\n  if |xs| == 0 then 0\n  else xs[0] + sum(xs[1..])\n}\n\nfunction sumTail(xs: seq<int>, acc: int): int\n  decreases |xs|\n{\n  if |xs| == 0 then acc\n  else sumTail(xs[1..], acc + xs[0])\n}\n\nlemma sumCorrect(xs: seq<int>)\n  ensures sum(xs) == sumTail(xs, 0)\n{\n  sumCorrectHelper(xs, 0);\n}\n\nlemma sumCorrectHelper(xs: seq<int>, acc: int)\n  ensures sumTail(xs, acc) == acc + sum(xs)\n{\n  if |xs| == 0 {\n  } else {\n    calc {\n      sumTail(xs, acc);\n      == sumTail(xs[1..], acc + xs[0]);\n      == { sumCorrectHelper(xs[1..], acc + xs[0]); }\n      (acc + xs[0]) + sum(xs[1..]);\n      == acc + (xs[0] + sum(xs[1..]));\n      == acc + sum(xs);\n    }\n  }\n}\n\nlemma sumAppend(xs: seq<int>, ys: seq<int>)\n  ensures sum(xs + ys) == sum(xs) + sum(ys)\n{\n  if |xs| == 0 {\n    assert xs + ys == ys;\n  } else {\n    assert xs + ys == [xs[0]] + (xs[1..] + ys);\n    calc {\n      sum(xs + ys);\n      == xs[0] + sum((xs[1..] + ys));\n      == { sumAppend(xs[1..], ys); }\n      xs[0] + (sum(xs[1..]) + sum(ys));\n      == (xs[0] + sum(xs[1..])) + sum(ys);\n      == sum(xs) + sum(ys);\n    }\n  }\n}\n\nlemma sumDistributive(xs: seq<int>, c: int)\n  ensures sum(seq(|xs|, i requires 0 <= i < |xs| => c * xs[i])) == c * sum(xs)\n{\n  if |xs| == 0 {\n    // Base case: empty sequence\n    assert seq(|xs|, i requires 0 <= i < |xs| => c * xs[i]) == [];\n    \n/*[CODE HERE]*/\n    assert c * sum([]) == c * 0 == 0;\n  } else {\n    // Inductive case: non-empty sequence\n    var scaled_xs := seq(|xs|, i requires 0 <= i < |xs| => c * xs[i]);\n    assert scaled_xs == [c * xs[0]] + seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i]);\n    \n    calc {\n      sum(scaled_xs);\n      == sum([c * xs[0]] + seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i]));\n      == { sumAppend([c * xs[0]], seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i])); }\n      sum([c * xs[0]]) + sum(seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i]));\n      == c * xs[0] + sum(seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i]));\n      == { sumDistributive(xs[1..], c); }\n      c * xs[0] + c * sum(xs[1..]);\n      == c * (xs[0] + sum(xs[1..]));\n      == c * sum(xs);\n    }\n  }\n}\n", "output": "assert sum([]) == 0;"}, {"id": "example_sumDistributive_5", "type": "assert", "program": "function sum(xs: seq<int>): int\n{\n  if |xs| == 0 then 0\n  else xs[0] + sum(xs[1..])\n}\n\nfunction sumTail(xs: seq<int>, acc: int): int\n  decreases |xs|\n{\n  if |xs| == 0 then acc\n  else sumTail(xs[1..], acc + xs[0])\n}\n\nlemma sumCorrect(xs: seq<int>)\n  ensures sum(xs) == sumTail(xs, 0)\n{\n  sumCorrectHelper(xs, 0);\n}\n\nlemma sumCorrectHelper(xs: seq<int>, acc: int)\n  ensures sumTail(xs, acc) == acc + sum(xs)\n{\n  if |xs| == 0 {\n  } else {\n    calc {\n      sumTail(xs, acc);\n      == sumTail(xs[1..], acc + xs[0]);\n      == { sumCorrectHelper(xs[1..], acc + xs[0]); }\n      (acc + xs[0]) + sum(xs[1..]);\n      == acc + (xs[0] + sum(xs[1..]));\n      == acc + sum(xs);\n    }\n  }\n}\n\nlemma sumAppend(xs: seq<int>, ys: seq<int>)\n  ensures sum(xs + ys) == sum(xs) + sum(ys)\n{\n  if |xs| == 0 {\n    assert xs + ys == ys;\n  } else {\n    assert xs + ys == [xs[0]] + (xs[1..] + ys);\n    calc {\n      sum(xs + ys);\n      == xs[0] + sum((xs[1..] + ys));\n      == { sumAppend(xs[1..], ys); }\n      xs[0] + (sum(xs[1..]) + sum(ys));\n      == (xs[0] + sum(xs[1..])) + sum(ys);\n      == sum(xs) + sum(ys);\n    }\n  }\n}\n\nlemma sumDistributive(xs: seq<int>, c: int)\n  ensures sum(seq(|xs|, i requires 0 <= i < |xs| => c * xs[i])) == c * sum(xs)\n{\n  if |xs| == 0 {\n    // Base case: empty sequence\n    \n/*[CODE HERE]*/\n    assert sum([]) == 0;\n    assert c * sum([]) == c * 0 == 0;\n  } else {\n    // Inductive case: non-empty sequence\n    var scaled_xs := seq(|xs|, i requires 0 <= i < |xs| => c * xs[i]);\n    assert scaled_xs == [c * xs[0]] + seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i]);\n    \n    calc {\n      sum(scaled_xs);\n      == sum([c * xs[0]] + seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i]));\n      == { sumAppend([c * xs[0]], seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i])); }\n      sum([c * xs[0]]) + sum(seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i]));\n      == c * xs[0] + sum(seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i]));\n      == { sumDistributive(xs[1..], c); }\n      c * xs[0] + c * sum(xs[1..]);\n      == c * (xs[0] + sum(xs[1..]));\n      == c * sum(xs);\n    }\n  }\n}\n", "output": "assert seq(|xs|, i requires 0 <= i < |xs| => c * xs[i]) == [];"}, {"id": "example_GcdPositive_0", "type": "call", "program": "// Mathematical operations: GCD, LCM, primes, modular arithmetic\n\n// Absolute value\nfunction {:spec} abs(x: int): nat\n{\n  if x < 0 then -x else x\n}\n\n// Greatest Common Divisor using Euclidean algorithm\nfunction {:spec} gcd(a: nat, b: nat): nat\n  decreases b\n{\n  if b == 0 then a\n  else gcd(b, a % b)\n}\n\n// Least Common Multiple\nfunction {:spec} lcm(a: nat, b: nat): nat\n  requires a > 0 && b > 0\n{\n  var g := gcd(a, b);\n  assert g > 0 by { GcdPositive(a, b); }\n  a / g * b  // Reordered to avoid overflow and ensure positive\n}\n\n// Check if a number divides another\npredicate {:spec} divides(d: nat, n: nat)\n  requires d > 0\n{\n  n % d == 0\n}\n\n// Check if a number is prime\npredicate {:spec} isPrime(n: nat)\n{\n  n > 1 && forall d :: 2 <= d < n ==> !divides(d, n)\n}\n\n// Check if two numbers are coprime (relatively prime)\npredicate {:spec} coprime(a: nat, b: nat)\n  requires a > 0 && b > 0\n{\n  gcd(a, b) == 1\n}\n\n// Modular exponentiation: (base^exp) mod m\nfunction {:spec} modPow(base: nat, exp: nat, m: nat): nat\n  requires m > 0\n  decreases exp\n{\n  if exp == 0 then 1 % m\n  else if exp % 2 == 0 then\n    var half := modPow(base, exp / 2, m);\n    (half * half) % m\n  else\n    ((base % m) * modPow(base, exp - 1, m)) % m\n}\n\n// Fibonacci function\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// Factorial function\nfunction {:spec} fact(n: nat): nat\n{\n  if n == 0 then 1\n  else n * fact(n - 1)\n}\n\n// Binomial coefficient (n choose k)\nfunction {:spec} binomial(n: nat, k: nat): nat\n  requires k <= n\n{\n  var denominator := fact(k) * fact(n - k);\n  if denominator == 0 then 0  // Can't happen but helps verifier\n  else fact(n) / denominator\n}\n\n// Sum of first n natural numbers\nfunction {:spec} sumToN(n: nat): nat\n{\n  if n == 0 then 0\n  else n + sumToN(n - 1)\n}\n\n// Check if a number is perfect (sum of divisors equals the number)\npredicate {:spec} isPerfect(n: nat)\n  requires n > 0\n{\n  sumOfDivisors(n) == 2 * n  // Including n itself\n}\n\nfunction {:spec} sumOfDivisors(n: nat): nat\n  requires n > 0\n{\n  sumOfDivisorsHelper(n, n)\n}\n\nfunction sumOfDivisorsHelper(n: nat, d: nat): nat\n  requires n > 0\n  requires d > 0\n  decreases d\n{\n  if d == 1 then 1\n  else if divides(d, n) then d + sumOfDivisorsHelper(n, d - 1)\n  else sumOfDivisorsHelper(n, d - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma GcdZero(a: nat)\n  ensures gcd(a, 0) == a\n{\n  // Automatic by definition\n}\n\nlemma GcdPositive(a: nat, b: nat)\n  requires a > 0 || b > 0\n  ensures gcd(a, b) > 0\n  decreases b\n{\n  if b == 0 {\n    assert gcd(a, b) == a;\n    assert a > 0;\n  } else {\n    \n/*[CODE HERE]*/\n  }\n}\n\nlemma GcdDividesBoth(a: nat, b: nat)\n  requires a > 0 && b > 0\n  ensures gcd(a, b) > 0\n{\n  GcdPositive(a, b);\n}\n\nlemma PrimeHasOnlyTwoDivisors(n: nat)\n  requires isPrime(n)\n  ensures divides(1, n) && divides(n, n)\n  ensures forall d: nat :: d > 0 && d < n && d != 1 ==> !divides(d, n)\n{\n  assert divides(1, n);\n  assert divides(n, n);\n  forall d: nat | d > 0 && d < n && d != 1\n    ensures !divides(d, n)\n  {\n    if d >= 2 {\n      assert 2 <= d < n;\n      // By definition of isPrime\n    }\n  }\n}\n\nlemma TwoPrime()\n  ensures isPrime(2)\n{\n  assert forall d :: 2 <= d < 2 ==> !divides(d, 2);\n}\n\nlemma ThreePrime()\n  ensures isPrime(3)\n{\n  assert !divides(2, 3);\n}\n\nfunction Power(base: nat, exp: nat): nat\n  decreases exp\n{\n  if exp == 0 then 1\n  else base * Power(base, exp - 1)\n}\n\nlemma PowerSquare(base: nat)\n  ensures Power(base, 2) == base * base\n{\n  assert Power(base, 2) == base * Power(base, 1);\n  assert Power(base, 1) == base;\n}\n\nlemma PowerAddition(base: nat, exp1: nat, exp2: nat)\n  ensures Power(base, exp1 + exp2) == Power(base, exp1) * Power(base, exp2)\n  decreases exp1\n{\n  if exp1 == 0 {\n    assert Power(base, 0) == 1;\n  } else {\n    PowerAddition(base, exp1 - 1, exp2);\n    assert Power(base, exp1 + exp2) == base * Power(base, exp1 - 1 + exp2);\n    assert Power(base, exp1) == base * Power(base, exp1 - 1);\n  }\n}\n\nlemma SumFormula(n: nat)\n  ensures sumToN(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    assert sumToN(0) == 0;\n  } else {\n    SumFormula(n - 1);\n    assert sumToN(n - 1) == (n - 1) * n / 2;\n    assert sumToN(n) == n + sumToN(n - 1);\n    assert sumToN(n) == n + (n - 1) * n / 2;\n    assert sumToN(n) == (2 * n + (n - 1) * n) / 2;\n    assert sumToN(n) == (2 * n + n * n - n) / 2;\n    assert sumToN(n) == (n + n * n) / 2;\n    assert sumToN(n) == n * (1 + n) / 2;\n  }\n}\n\nlemma FactorialPositive(n: nat)\n  ensures fact(n) > 0\n{\n  if n == 0 {\n    assert fact(0) == 1;\n  } else {\n    FactorialPositive(n - 1);\n  }\n}\n\nlemma FibonacciMonotonic(n: nat)\n  requires n > 0\n  ensures fib(n) <= fib(n + 1)\n{\n  if n == 1 {\n    assert fib(1) == 1;\n    assert fib(2) == 1;\n  } else {\n    assert fib(n + 1) == fib(n) + fib(n - 1);\n    if n > 1 {\n      assert fib(n - 1) >= 0;\n    }\n  }\n}\n\nlemma BinomialSymmetry(n: nat, k: nat)\n  requires k <= n\n  ensures binomial(n, k) == binomial(n, n - k)\n{\n  assert fact(k) * fact(n - k) == fact(n - k) * fact(k);\n}", "output": "GcdPositive(b, a % b);"}, {"id": "example_GcdPositive_1", "type": "assert", "program": "// Mathematical operations: GCD, LCM, primes, modular arithmetic\n\n// Absolute value\nfunction {:spec} abs(x: int): nat\n{\n  if x < 0 then -x else x\n}\n\n// Greatest Common Divisor using Euclidean algorithm\nfunction {:spec} gcd(a: nat, b: nat): nat\n  decreases b\n{\n  if b == 0 then a\n  else gcd(b, a % b)\n}\n\n// Least Common Multiple\nfunction {:spec} lcm(a: nat, b: nat): nat\n  requires a > 0 && b > 0\n{\n  var g := gcd(a, b);\n  assert g > 0 by { GcdPositive(a, b); }\n  a / g * b  // Reordered to avoid overflow and ensure positive\n}\n\n// Check if a number divides another\npredicate {:spec} divides(d: nat, n: nat)\n  requires d > 0\n{\n  n % d == 0\n}\n\n// Check if a number is prime\npredicate {:spec} isPrime(n: nat)\n{\n  n > 1 && forall d :: 2 <= d < n ==> !divides(d, n)\n}\n\n// Check if two numbers are coprime (relatively prime)\npredicate {:spec} coprime(a: nat, b: nat)\n  requires a > 0 && b > 0\n{\n  gcd(a, b) == 1\n}\n\n// Modular exponentiation: (base^exp) mod m\nfunction {:spec} modPow(base: nat, exp: nat, m: nat): nat\n  requires m > 0\n  decreases exp\n{\n  if exp == 0 then 1 % m\n  else if exp % 2 == 0 then\n    var half := modPow(base, exp / 2, m);\n    (half * half) % m\n  else\n    ((base % m) * modPow(base, exp - 1, m)) % m\n}\n\n// Fibonacci function\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// Factorial function\nfunction {:spec} fact(n: nat): nat\n{\n  if n == 0 then 1\n  else n * fact(n - 1)\n}\n\n// Binomial coefficient (n choose k)\nfunction {:spec} binomial(n: nat, k: nat): nat\n  requires k <= n\n{\n  var denominator := fact(k) * fact(n - k);\n  if denominator == 0 then 0  // Can't happen but helps verifier\n  else fact(n) / denominator\n}\n\n// Sum of first n natural numbers\nfunction {:spec} sumToN(n: nat): nat\n{\n  if n == 0 then 0\n  else n + sumToN(n - 1)\n}\n\n// Check if a number is perfect (sum of divisors equals the number)\npredicate {:spec} isPerfect(n: nat)\n  requires n > 0\n{\n  sumOfDivisors(n) == 2 * n  // Including n itself\n}\n\nfunction {:spec} sumOfDivisors(n: nat): nat\n  requires n > 0\n{\n  sumOfDivisorsHelper(n, n)\n}\n\nfunction sumOfDivisorsHelper(n: nat, d: nat): nat\n  requires n > 0\n  requires d > 0\n  decreases d\n{\n  if d == 1 then 1\n  else if divides(d, n) then d + sumOfDivisorsHelper(n, d - 1)\n  else sumOfDivisorsHelper(n, d - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma GcdZero(a: nat)\n  ensures gcd(a, 0) == a\n{\n  // Automatic by definition\n}\n\nlemma GcdPositive(a: nat, b: nat)\n  requires a > 0 || b > 0\n  ensures gcd(a, b) > 0\n  decreases b\n{\n  if b == 0 {\n    assert gcd(a, b) == a;\n    \n/*[CODE HERE]*/\n  } else {\n    GcdPositive(b, a % b);\n  }\n}\n\nlemma GcdDividesBoth(a: nat, b: nat)\n  requires a > 0 && b > 0\n  ensures gcd(a, b) > 0\n{\n  GcdPositive(a, b);\n}\n\nlemma PrimeHasOnlyTwoDivisors(n: nat)\n  requires isPrime(n)\n  ensures divides(1, n) && divides(n, n)\n  ensures forall d: nat :: d > 0 && d < n && d != 1 ==> !divides(d, n)\n{\n  assert divides(1, n);\n  assert divides(n, n);\n  forall d: nat | d > 0 && d < n && d != 1\n    ensures !divides(d, n)\n  {\n    if d >= 2 {\n      assert 2 <= d < n;\n      // By definition of isPrime\n    }\n  }\n}\n\nlemma TwoPrime()\n  ensures isPrime(2)\n{\n  assert forall d :: 2 <= d < 2 ==> !divides(d, 2);\n}\n\nlemma ThreePrime()\n  ensures isPrime(3)\n{\n  assert !divides(2, 3);\n}\n\nfunction Power(base: nat, exp: nat): nat\n  decreases exp\n{\n  if exp == 0 then 1\n  else base * Power(base, exp - 1)\n}\n\nlemma PowerSquare(base: nat)\n  ensures Power(base, 2) == base * base\n{\n  assert Power(base, 2) == base * Power(base, 1);\n  assert Power(base, 1) == base;\n}\n\nlemma PowerAddition(base: nat, exp1: nat, exp2: nat)\n  ensures Power(base, exp1 + exp2) == Power(base, exp1) * Power(base, exp2)\n  decreases exp1\n{\n  if exp1 == 0 {\n    assert Power(base, 0) == 1;\n  } else {\n    PowerAddition(base, exp1 - 1, exp2);\n    assert Power(base, exp1 + exp2) == base * Power(base, exp1 - 1 + exp2);\n    assert Power(base, exp1) == base * Power(base, exp1 - 1);\n  }\n}\n\nlemma SumFormula(n: nat)\n  ensures sumToN(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    assert sumToN(0) == 0;\n  } else {\n    SumFormula(n - 1);\n    assert sumToN(n - 1) == (n - 1) * n / 2;\n    assert sumToN(n) == n + sumToN(n - 1);\n    assert sumToN(n) == n + (n - 1) * n / 2;\n    assert sumToN(n) == (2 * n + (n - 1) * n) / 2;\n    assert sumToN(n) == (2 * n + n * n - n) / 2;\n    assert sumToN(n) == (n + n * n) / 2;\n    assert sumToN(n) == n * (1 + n) / 2;\n  }\n}\n\nlemma FactorialPositive(n: nat)\n  ensures fact(n) > 0\n{\n  if n == 0 {\n    assert fact(0) == 1;\n  } else {\n    FactorialPositive(n - 1);\n  }\n}\n\nlemma FibonacciMonotonic(n: nat)\n  requires n > 0\n  ensures fib(n) <= fib(n + 1)\n{\n  if n == 1 {\n    assert fib(1) == 1;\n    assert fib(2) == 1;\n  } else {\n    assert fib(n + 1) == fib(n) + fib(n - 1);\n    if n > 1 {\n      assert fib(n - 1) >= 0;\n    }\n  }\n}\n\nlemma BinomialSymmetry(n: nat, k: nat)\n  requires k <= n\n  ensures binomial(n, k) == binomial(n, n - k)\n{\n  assert fact(k) * fact(n - k) == fact(n - k) * fact(k);\n}", "output": "assert a > 0;"}, {"id": "example_GcdPositive_2", "type": "assert", "program": "// Mathematical operations: GCD, LCM, primes, modular arithmetic\n\n// Absolute value\nfunction {:spec} abs(x: int): nat\n{\n  if x < 0 then -x else x\n}\n\n// Greatest Common Divisor using Euclidean algorithm\nfunction {:spec} gcd(a: nat, b: nat): nat\n  decreases b\n{\n  if b == 0 then a\n  else gcd(b, a % b)\n}\n\n// Least Common Multiple\nfunction {:spec} lcm(a: nat, b: nat): nat\n  requires a > 0 && b > 0\n{\n  var g := gcd(a, b);\n  assert g > 0 by { GcdPositive(a, b); }\n  a / g * b  // Reordered to avoid overflow and ensure positive\n}\n\n// Check if a number divides another\npredicate {:spec} divides(d: nat, n: nat)\n  requires d > 0\n{\n  n % d == 0\n}\n\n// Check if a number is prime\npredicate {:spec} isPrime(n: nat)\n{\n  n > 1 && forall d :: 2 <= d < n ==> !divides(d, n)\n}\n\n// Check if two numbers are coprime (relatively prime)\npredicate {:spec} coprime(a: nat, b: nat)\n  requires a > 0 && b > 0\n{\n  gcd(a, b) == 1\n}\n\n// Modular exponentiation: (base^exp) mod m\nfunction {:spec} modPow(base: nat, exp: nat, m: nat): nat\n  requires m > 0\n  decreases exp\n{\n  if exp == 0 then 1 % m\n  else if exp % 2 == 0 then\n    var half := modPow(base, exp / 2, m);\n    (half * half) % m\n  else\n    ((base % m) * modPow(base, exp - 1, m)) % m\n}\n\n// Fibonacci function\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// Factorial function\nfunction {:spec} fact(n: nat): nat\n{\n  if n == 0 then 1\n  else n * fact(n - 1)\n}\n\n// Binomial coefficient (n choose k)\nfunction {:spec} binomial(n: nat, k: nat): nat\n  requires k <= n\n{\n  var denominator := fact(k) * fact(n - k);\n  if denominator == 0 then 0  // Can't happen but helps verifier\n  else fact(n) / denominator\n}\n\n// Sum of first n natural numbers\nfunction {:spec} sumToN(n: nat): nat\n{\n  if n == 0 then 0\n  else n + sumToN(n - 1)\n}\n\n// Check if a number is perfect (sum of divisors equals the number)\npredicate {:spec} isPerfect(n: nat)\n  requires n > 0\n{\n  sumOfDivisors(n) == 2 * n  // Including n itself\n}\n\nfunction {:spec} sumOfDivisors(n: nat): nat\n  requires n > 0\n{\n  sumOfDivisorsHelper(n, n)\n}\n\nfunction sumOfDivisorsHelper(n: nat, d: nat): nat\n  requires n > 0\n  requires d > 0\n  decreases d\n{\n  if d == 1 then 1\n  else if divides(d, n) then d + sumOfDivisorsHelper(n, d - 1)\n  else sumOfDivisorsHelper(n, d - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma GcdZero(a: nat)\n  ensures gcd(a, 0) == a\n{\n  // Automatic by definition\n}\n\nlemma GcdPositive(a: nat, b: nat)\n  requires a > 0 || b > 0\n  ensures gcd(a, b) > 0\n  decreases b\n{\n  if b == 0 {\n    \n/*[CODE HERE]*/\n    assert a > 0;\n  } else {\n    GcdPositive(b, a % b);\n  }\n}\n\nlemma GcdDividesBoth(a: nat, b: nat)\n  requires a > 0 && b > 0\n  ensures gcd(a, b) > 0\n{\n  GcdPositive(a, b);\n}\n\nlemma PrimeHasOnlyTwoDivisors(n: nat)\n  requires isPrime(n)\n  ensures divides(1, n) && divides(n, n)\n  ensures forall d: nat :: d > 0 && d < n && d != 1 ==> !divides(d, n)\n{\n  assert divides(1, n);\n  assert divides(n, n);\n  forall d: nat | d > 0 && d < n && d != 1\n    ensures !divides(d, n)\n  {\n    if d >= 2 {\n      assert 2 <= d < n;\n      // By definition of isPrime\n    }\n  }\n}\n\nlemma TwoPrime()\n  ensures isPrime(2)\n{\n  assert forall d :: 2 <= d < 2 ==> !divides(d, 2);\n}\n\nlemma ThreePrime()\n  ensures isPrime(3)\n{\n  assert !divides(2, 3);\n}\n\nfunction Power(base: nat, exp: nat): nat\n  decreases exp\n{\n  if exp == 0 then 1\n  else base * Power(base, exp - 1)\n}\n\nlemma PowerSquare(base: nat)\n  ensures Power(base, 2) == base * base\n{\n  assert Power(base, 2) == base * Power(base, 1);\n  assert Power(base, 1) == base;\n}\n\nlemma PowerAddition(base: nat, exp1: nat, exp2: nat)\n  ensures Power(base, exp1 + exp2) == Power(base, exp1) * Power(base, exp2)\n  decreases exp1\n{\n  if exp1 == 0 {\n    assert Power(base, 0) == 1;\n  } else {\n    PowerAddition(base, exp1 - 1, exp2);\n    assert Power(base, exp1 + exp2) == base * Power(base, exp1 - 1 + exp2);\n    assert Power(base, exp1) == base * Power(base, exp1 - 1);\n  }\n}\n\nlemma SumFormula(n: nat)\n  ensures sumToN(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    assert sumToN(0) == 0;\n  } else {\n    SumFormula(n - 1);\n    assert sumToN(n - 1) == (n - 1) * n / 2;\n    assert sumToN(n) == n + sumToN(n - 1);\n    assert sumToN(n) == n + (n - 1) * n / 2;\n    assert sumToN(n) == (2 * n + (n - 1) * n) / 2;\n    assert sumToN(n) == (2 * n + n * n - n) / 2;\n    assert sumToN(n) == (n + n * n) / 2;\n    assert sumToN(n) == n * (1 + n) / 2;\n  }\n}\n\nlemma FactorialPositive(n: nat)\n  ensures fact(n) > 0\n{\n  if n == 0 {\n    assert fact(0) == 1;\n  } else {\n    FactorialPositive(n - 1);\n  }\n}\n\nlemma FibonacciMonotonic(n: nat)\n  requires n > 0\n  ensures fib(n) <= fib(n + 1)\n{\n  if n == 1 {\n    assert fib(1) == 1;\n    assert fib(2) == 1;\n  } else {\n    assert fib(n + 1) == fib(n) + fib(n - 1);\n    if n > 1 {\n      assert fib(n - 1) >= 0;\n    }\n  }\n}\n\nlemma BinomialSymmetry(n: nat, k: nat)\n  requires k <= n\n  ensures binomial(n, k) == binomial(n, n - k)\n{\n  assert fact(k) * fact(n - k) == fact(n - k) * fact(k);\n}", "output": "assert gcd(a, b) == a;"}, {"id": "example_GcdDividesBoth_0", "type": "call", "program": "// Mathematical operations: GCD, LCM, primes, modular arithmetic\n\n// Absolute value\nfunction {:spec} abs(x: int): nat\n{\n  if x < 0 then -x else x\n}\n\n// Greatest Common Divisor using Euclidean algorithm\nfunction {:spec} gcd(a: nat, b: nat): nat\n  decreases b\n{\n  if b == 0 then a\n  else gcd(b, a % b)\n}\n\n// Least Common Multiple\nfunction {:spec} lcm(a: nat, b: nat): nat\n  requires a > 0 && b > 0\n{\n  var g := gcd(a, b);\n  assert g > 0 by { GcdPositive(a, b); }\n  a / g * b  // Reordered to avoid overflow and ensure positive\n}\n\n// Check if a number divides another\npredicate {:spec} divides(d: nat, n: nat)\n  requires d > 0\n{\n  n % d == 0\n}\n\n// Check if a number is prime\npredicate {:spec} isPrime(n: nat)\n{\n  n > 1 && forall d :: 2 <= d < n ==> !divides(d, n)\n}\n\n// Check if two numbers are coprime (relatively prime)\npredicate {:spec} coprime(a: nat, b: nat)\n  requires a > 0 && b > 0\n{\n  gcd(a, b) == 1\n}\n\n// Modular exponentiation: (base^exp) mod m\nfunction {:spec} modPow(base: nat, exp: nat, m: nat): nat\n  requires m > 0\n  decreases exp\n{\n  if exp == 0 then 1 % m\n  else if exp % 2 == 0 then\n    var half := modPow(base, exp / 2, m);\n    (half * half) % m\n  else\n    ((base % m) * modPow(base, exp - 1, m)) % m\n}\n\n// Fibonacci function\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// Factorial function\nfunction {:spec} fact(n: nat): nat\n{\n  if n == 0 then 1\n  else n * fact(n - 1)\n}\n\n// Binomial coefficient (n choose k)\nfunction {:spec} binomial(n: nat, k: nat): nat\n  requires k <= n\n{\n  var denominator := fact(k) * fact(n - k);\n  if denominator == 0 then 0  // Can't happen but helps verifier\n  else fact(n) / denominator\n}\n\n// Sum of first n natural numbers\nfunction {:spec} sumToN(n: nat): nat\n{\n  if n == 0 then 0\n  else n + sumToN(n - 1)\n}\n\n// Check if a number is perfect (sum of divisors equals the number)\npredicate {:spec} isPerfect(n: nat)\n  requires n > 0\n{\n  sumOfDivisors(n) == 2 * n  // Including n itself\n}\n\nfunction {:spec} sumOfDivisors(n: nat): nat\n  requires n > 0\n{\n  sumOfDivisorsHelper(n, n)\n}\n\nfunction sumOfDivisorsHelper(n: nat, d: nat): nat\n  requires n > 0\n  requires d > 0\n  decreases d\n{\n  if d == 1 then 1\n  else if divides(d, n) then d + sumOfDivisorsHelper(n, d - 1)\n  else sumOfDivisorsHelper(n, d - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma GcdZero(a: nat)\n  ensures gcd(a, 0) == a\n{\n  // Automatic by definition\n}\n\nlemma GcdPositive(a: nat, b: nat)\n  requires a > 0 || b > 0\n  ensures gcd(a, b) > 0\n  decreases b\n{\n  if b == 0 {\n    assert gcd(a, b) == a;\n    assert a > 0;\n  } else {\n    GcdPositive(b, a % b);\n  }\n}\n\nlemma GcdDividesBoth(a: nat, b: nat)\n  requires a > 0 && b > 0\n  ensures gcd(a, b) > 0\n{\n  \n/*[CODE HERE]*/\n}\n\nlemma PrimeHasOnlyTwoDivisors(n: nat)\n  requires isPrime(n)\n  ensures divides(1, n) && divides(n, n)\n  ensures forall d: nat :: d > 0 && d < n && d != 1 ==> !divides(d, n)\n{\n  assert divides(1, n);\n  assert divides(n, n);\n  forall d: nat | d > 0 && d < n && d != 1\n    ensures !divides(d, n)\n  {\n    if d >= 2 {\n      assert 2 <= d < n;\n      // By definition of isPrime\n    }\n  }\n}\n\nlemma TwoPrime()\n  ensures isPrime(2)\n{\n  assert forall d :: 2 <= d < 2 ==> !divides(d, 2);\n}\n\nlemma ThreePrime()\n  ensures isPrime(3)\n{\n  assert !divides(2, 3);\n}\n\nfunction Power(base: nat, exp: nat): nat\n  decreases exp\n{\n  if exp == 0 then 1\n  else base * Power(base, exp - 1)\n}\n\nlemma PowerSquare(base: nat)\n  ensures Power(base, 2) == base * base\n{\n  assert Power(base, 2) == base * Power(base, 1);\n  assert Power(base, 1) == base;\n}\n\nlemma PowerAddition(base: nat, exp1: nat, exp2: nat)\n  ensures Power(base, exp1 + exp2) == Power(base, exp1) * Power(base, exp2)\n  decreases exp1\n{\n  if exp1 == 0 {\n    assert Power(base, 0) == 1;\n  } else {\n    PowerAddition(base, exp1 - 1, exp2);\n    assert Power(base, exp1 + exp2) == base * Power(base, exp1 - 1 + exp2);\n    assert Power(base, exp1) == base * Power(base, exp1 - 1);\n  }\n}\n\nlemma SumFormula(n: nat)\n  ensures sumToN(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    assert sumToN(0) == 0;\n  } else {\n    SumFormula(n - 1);\n    assert sumToN(n - 1) == (n - 1) * n / 2;\n    assert sumToN(n) == n + sumToN(n - 1);\n    assert sumToN(n) == n + (n - 1) * n / 2;\n    assert sumToN(n) == (2 * n + (n - 1) * n) / 2;\n    assert sumToN(n) == (2 * n + n * n - n) / 2;\n    assert sumToN(n) == (n + n * n) / 2;\n    assert sumToN(n) == n * (1 + n) / 2;\n  }\n}\n\nlemma FactorialPositive(n: nat)\n  ensures fact(n) > 0\n{\n  if n == 0 {\n    assert fact(0) == 1;\n  } else {\n    FactorialPositive(n - 1);\n  }\n}\n\nlemma FibonacciMonotonic(n: nat)\n  requires n > 0\n  ensures fib(n) <= fib(n + 1)\n{\n  if n == 1 {\n    assert fib(1) == 1;\n    assert fib(2) == 1;\n  } else {\n    assert fib(n + 1) == fib(n) + fib(n - 1);\n    if n > 1 {\n      assert fib(n - 1) >= 0;\n    }\n  }\n}\n\nlemma BinomialSymmetry(n: nat, k: nat)\n  requires k <= n\n  ensures binomial(n, k) == binomial(n, n - k)\n{\n  assert fact(k) * fact(n - k) == fact(n - k) * fact(k);\n}", "output": "GcdPositive(a, b);"}, {"id": "example_PrimeHasOnlyTwoDivisors_0", "type": "assert", "program": "// Mathematical operations: GCD, LCM, primes, modular arithmetic\n\n// Absolute value\nfunction {:spec} abs(x: int): nat\n{\n  if x < 0 then -x else x\n}\n\n// Greatest Common Divisor using Euclidean algorithm\nfunction {:spec} gcd(a: nat, b: nat): nat\n  decreases b\n{\n  if b == 0 then a\n  else gcd(b, a % b)\n}\n\n// Least Common Multiple\nfunction {:spec} lcm(a: nat, b: nat): nat\n  requires a > 0 && b > 0\n{\n  var g := gcd(a, b);\n  assert g > 0 by { GcdPositive(a, b); }\n  a / g * b  // Reordered to avoid overflow and ensure positive\n}\n\n// Check if a number divides another\npredicate {:spec} divides(d: nat, n: nat)\n  requires d > 0\n{\n  n % d == 0\n}\n\n// Check if a number is prime\npredicate {:spec} isPrime(n: nat)\n{\n  n > 1 && forall d :: 2 <= d < n ==> !divides(d, n)\n}\n\n// Check if two numbers are coprime (relatively prime)\npredicate {:spec} coprime(a: nat, b: nat)\n  requires a > 0 && b > 0\n{\n  gcd(a, b) == 1\n}\n\n// Modular exponentiation: (base^exp) mod m\nfunction {:spec} modPow(base: nat, exp: nat, m: nat): nat\n  requires m > 0\n  decreases exp\n{\n  if exp == 0 then 1 % m\n  else if exp % 2 == 0 then\n    var half := modPow(base, exp / 2, m);\n    (half * half) % m\n  else\n    ((base % m) * modPow(base, exp - 1, m)) % m\n}\n\n// Fibonacci function\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// Factorial function\nfunction {:spec} fact(n: nat): nat\n{\n  if n == 0 then 1\n  else n * fact(n - 1)\n}\n\n// Binomial coefficient (n choose k)\nfunction {:spec} binomial(n: nat, k: nat): nat\n  requires k <= n\n{\n  var denominator := fact(k) * fact(n - k);\n  if denominator == 0 then 0  // Can't happen but helps verifier\n  else fact(n) / denominator\n}\n\n// Sum of first n natural numbers\nfunction {:spec} sumToN(n: nat): nat\n{\n  if n == 0 then 0\n  else n + sumToN(n - 1)\n}\n\n// Check if a number is perfect (sum of divisors equals the number)\npredicate {:spec} isPerfect(n: nat)\n  requires n > 0\n{\n  sumOfDivisors(n) == 2 * n  // Including n itself\n}\n\nfunction {:spec} sumOfDivisors(n: nat): nat\n  requires n > 0\n{\n  sumOfDivisorsHelper(n, n)\n}\n\nfunction sumOfDivisorsHelper(n: nat, d: nat): nat\n  requires n > 0\n  requires d > 0\n  decreases d\n{\n  if d == 1 then 1\n  else if divides(d, n) then d + sumOfDivisorsHelper(n, d - 1)\n  else sumOfDivisorsHelper(n, d - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma GcdZero(a: nat)\n  ensures gcd(a, 0) == a\n{\n  // Automatic by definition\n}\n\nlemma GcdPositive(a: nat, b: nat)\n  requires a > 0 || b > 0\n  ensures gcd(a, b) > 0\n  decreases b\n{\n  if b == 0 {\n    assert gcd(a, b) == a;\n    assert a > 0;\n  } else {\n    GcdPositive(b, a % b);\n  }\n}\n\nlemma GcdDividesBoth(a: nat, b: nat)\n  requires a > 0 && b > 0\n  ensures gcd(a, b) > 0\n{\n  GcdPositive(a, b);\n}\n\nlemma PrimeHasOnlyTwoDivisors(n: nat)\n  requires isPrime(n)\n  ensures divides(1, n) && divides(n, n)\n  ensures forall d: nat :: d > 0 && d < n && d != 1 ==> !divides(d, n)\n{\n  assert divides(1, n);\n  assert divides(n, n);\n  forall d: nat | d > 0 && d < n && d != 1\n    ensures !divides(d, n)\n  {\n    if d >= 2 {\n      \n/*[CODE HERE]*/\n      // By definition of isPrime\n    }\n  }\n}\n\nlemma TwoPrime()\n  ensures isPrime(2)\n{\n  assert forall d :: 2 <= d < 2 ==> !divides(d, 2);\n}\n\nlemma ThreePrime()\n  ensures isPrime(3)\n{\n  assert !divides(2, 3);\n}\n\nfunction Power(base: nat, exp: nat): nat\n  decreases exp\n{\n  if exp == 0 then 1\n  else base * Power(base, exp - 1)\n}\n\nlemma PowerSquare(base: nat)\n  ensures Power(base, 2) == base * base\n{\n  assert Power(base, 2) == base * Power(base, 1);\n  assert Power(base, 1) == base;\n}\n\nlemma PowerAddition(base: nat, exp1: nat, exp2: nat)\n  ensures Power(base, exp1 + exp2) == Power(base, exp1) * Power(base, exp2)\n  decreases exp1\n{\n  if exp1 == 0 {\n    assert Power(base, 0) == 1;\n  } else {\n    PowerAddition(base, exp1 - 1, exp2);\n    assert Power(base, exp1 + exp2) == base * Power(base, exp1 - 1 + exp2);\n    assert Power(base, exp1) == base * Power(base, exp1 - 1);\n  }\n}\n\nlemma SumFormula(n: nat)\n  ensures sumToN(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    assert sumToN(0) == 0;\n  } else {\n    SumFormula(n - 1);\n    assert sumToN(n - 1) == (n - 1) * n / 2;\n    assert sumToN(n) == n + sumToN(n - 1);\n    assert sumToN(n) == n + (n - 1) * n / 2;\n    assert sumToN(n) == (2 * n + (n - 1) * n) / 2;\n    assert sumToN(n) == (2 * n + n * n - n) / 2;\n    assert sumToN(n) == (n + n * n) / 2;\n    assert sumToN(n) == n * (1 + n) / 2;\n  }\n}\n\nlemma FactorialPositive(n: nat)\n  ensures fact(n) > 0\n{\n  if n == 0 {\n    assert fact(0) == 1;\n  } else {\n    FactorialPositive(n - 1);\n  }\n}\n\nlemma FibonacciMonotonic(n: nat)\n  requires n > 0\n  ensures fib(n) <= fib(n + 1)\n{\n  if n == 1 {\n    assert fib(1) == 1;\n    assert fib(2) == 1;\n  } else {\n    assert fib(n + 1) == fib(n) + fib(n - 1);\n    if n > 1 {\n      assert fib(n - 1) >= 0;\n    }\n  }\n}\n\nlemma BinomialSymmetry(n: nat, k: nat)\n  requires k <= n\n  ensures binomial(n, k) == binomial(n, n - k)\n{\n  assert fact(k) * fact(n - k) == fact(n - k) * fact(k);\n}", "output": "assert 2 <= d < n;"}, {"id": "example_PrimeHasOnlyTwoDivisors_1", "type": "assert", "program": "// Mathematical operations: GCD, LCM, primes, modular arithmetic\n\n// Absolute value\nfunction {:spec} abs(x: int): nat\n{\n  if x < 0 then -x else x\n}\n\n// Greatest Common Divisor using Euclidean algorithm\nfunction {:spec} gcd(a: nat, b: nat): nat\n  decreases b\n{\n  if b == 0 then a\n  else gcd(b, a % b)\n}\n\n// Least Common Multiple\nfunction {:spec} lcm(a: nat, b: nat): nat\n  requires a > 0 && b > 0\n{\n  var g := gcd(a, b);\n  assert g > 0 by { GcdPositive(a, b); }\n  a / g * b  // Reordered to avoid overflow and ensure positive\n}\n\n// Check if a number divides another\npredicate {:spec} divides(d: nat, n: nat)\n  requires d > 0\n{\n  n % d == 0\n}\n\n// Check if a number is prime\npredicate {:spec} isPrime(n: nat)\n{\n  n > 1 && forall d :: 2 <= d < n ==> !divides(d, n)\n}\n\n// Check if two numbers are coprime (relatively prime)\npredicate {:spec} coprime(a: nat, b: nat)\n  requires a > 0 && b > 0\n{\n  gcd(a, b) == 1\n}\n\n// Modular exponentiation: (base^exp) mod m\nfunction {:spec} modPow(base: nat, exp: nat, m: nat): nat\n  requires m > 0\n  decreases exp\n{\n  if exp == 0 then 1 % m\n  else if exp % 2 == 0 then\n    var half := modPow(base, exp / 2, m);\n    (half * half) % m\n  else\n    ((base % m) * modPow(base, exp - 1, m)) % m\n}\n\n// Fibonacci function\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// Factorial function\nfunction {:spec} fact(n: nat): nat\n{\n  if n == 0 then 1\n  else n * fact(n - 1)\n}\n\n// Binomial coefficient (n choose k)\nfunction {:spec} binomial(n: nat, k: nat): nat\n  requires k <= n\n{\n  var denominator := fact(k) * fact(n - k);\n  if denominator == 0 then 0  // Can't happen but helps verifier\n  else fact(n) / denominator\n}\n\n// Sum of first n natural numbers\nfunction {:spec} sumToN(n: nat): nat\n{\n  if n == 0 then 0\n  else n + sumToN(n - 1)\n}\n\n// Check if a number is perfect (sum of divisors equals the number)\npredicate {:spec} isPerfect(n: nat)\n  requires n > 0\n{\n  sumOfDivisors(n) == 2 * n  // Including n itself\n}\n\nfunction {:spec} sumOfDivisors(n: nat): nat\n  requires n > 0\n{\n  sumOfDivisorsHelper(n, n)\n}\n\nfunction sumOfDivisorsHelper(n: nat, d: nat): nat\n  requires n > 0\n  requires d > 0\n  decreases d\n{\n  if d == 1 then 1\n  else if divides(d, n) then d + sumOfDivisorsHelper(n, d - 1)\n  else sumOfDivisorsHelper(n, d - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma GcdZero(a: nat)\n  ensures gcd(a, 0) == a\n{\n  // Automatic by definition\n}\n\nlemma GcdPositive(a: nat, b: nat)\n  requires a > 0 || b > 0\n  ensures gcd(a, b) > 0\n  decreases b\n{\n  if b == 0 {\n    assert gcd(a, b) == a;\n    assert a > 0;\n  } else {\n    GcdPositive(b, a % b);\n  }\n}\n\nlemma GcdDividesBoth(a: nat, b: nat)\n  requires a > 0 && b > 0\n  ensures gcd(a, b) > 0\n{\n  GcdPositive(a, b);\n}\n\nlemma PrimeHasOnlyTwoDivisors(n: nat)\n  requires isPrime(n)\n  ensures divides(1, n) && divides(n, n)\n  ensures forall d: nat :: d > 0 && d < n && d != 1 ==> !divides(d, n)\n{\n  assert divides(1, n);\n  \n/*[CODE HERE]*/\n  forall d: nat | d > 0 && d < n && d != 1\n    ensures !divides(d, n)\n  {\n    if d >= 2 {\n      assert 2 <= d < n;\n      // By definition of isPrime\n    }\n  }\n}\n\nlemma TwoPrime()\n  ensures isPrime(2)\n{\n  assert forall d :: 2 <= d < 2 ==> !divides(d, 2);\n}\n\nlemma ThreePrime()\n  ensures isPrime(3)\n{\n  assert !divides(2, 3);\n}\n\nfunction Power(base: nat, exp: nat): nat\n  decreases exp\n{\n  if exp == 0 then 1\n  else base * Power(base, exp - 1)\n}\n\nlemma PowerSquare(base: nat)\n  ensures Power(base, 2) == base * base\n{\n  assert Power(base, 2) == base * Power(base, 1);\n  assert Power(base, 1) == base;\n}\n\nlemma PowerAddition(base: nat, exp1: nat, exp2: nat)\n  ensures Power(base, exp1 + exp2) == Power(base, exp1) * Power(base, exp2)\n  decreases exp1\n{\n  if exp1 == 0 {\n    assert Power(base, 0) == 1;\n  } else {\n    PowerAddition(base, exp1 - 1, exp2);\n    assert Power(base, exp1 + exp2) == base * Power(base, exp1 - 1 + exp2);\n    assert Power(base, exp1) == base * Power(base, exp1 - 1);\n  }\n}\n\nlemma SumFormula(n: nat)\n  ensures sumToN(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    assert sumToN(0) == 0;\n  } else {\n    SumFormula(n - 1);\n    assert sumToN(n - 1) == (n - 1) * n / 2;\n    assert sumToN(n) == n + sumToN(n - 1);\n    assert sumToN(n) == n + (n - 1) * n / 2;\n    assert sumToN(n) == (2 * n + (n - 1) * n) / 2;\n    assert sumToN(n) == (2 * n + n * n - n) / 2;\n    assert sumToN(n) == (n + n * n) / 2;\n    assert sumToN(n) == n * (1 + n) / 2;\n  }\n}\n\nlemma FactorialPositive(n: nat)\n  ensures fact(n) > 0\n{\n  if n == 0 {\n    assert fact(0) == 1;\n  } else {\n    FactorialPositive(n - 1);\n  }\n}\n\nlemma FibonacciMonotonic(n: nat)\n  requires n > 0\n  ensures fib(n) <= fib(n + 1)\n{\n  if n == 1 {\n    assert fib(1) == 1;\n    assert fib(2) == 1;\n  } else {\n    assert fib(n + 1) == fib(n) + fib(n - 1);\n    if n > 1 {\n      assert fib(n - 1) >= 0;\n    }\n  }\n}\n\nlemma BinomialSymmetry(n: nat, k: nat)\n  requires k <= n\n  ensures binomial(n, k) == binomial(n, n - k)\n{\n  assert fact(k) * fact(n - k) == fact(n - k) * fact(k);\n}", "output": "assert divides(n, n);"}, {"id": "example_PrimeHasOnlyTwoDivisors_2", "type": "assert", "program": "// Mathematical operations: GCD, LCM, primes, modular arithmetic\n\n// Absolute value\nfunction {:spec} abs(x: int): nat\n{\n  if x < 0 then -x else x\n}\n\n// Greatest Common Divisor using Euclidean algorithm\nfunction {:spec} gcd(a: nat, b: nat): nat\n  decreases b\n{\n  if b == 0 then a\n  else gcd(b, a % b)\n}\n\n// Least Common Multiple\nfunction {:spec} lcm(a: nat, b: nat): nat\n  requires a > 0 && b > 0\n{\n  var g := gcd(a, b);\n  assert g > 0 by { GcdPositive(a, b); }\n  a / g * b  // Reordered to avoid overflow and ensure positive\n}\n\n// Check if a number divides another\npredicate {:spec} divides(d: nat, n: nat)\n  requires d > 0\n{\n  n % d == 0\n}\n\n// Check if a number is prime\npredicate {:spec} isPrime(n: nat)\n{\n  n > 1 && forall d :: 2 <= d < n ==> !divides(d, n)\n}\n\n// Check if two numbers are coprime (relatively prime)\npredicate {:spec} coprime(a: nat, b: nat)\n  requires a > 0 && b > 0\n{\n  gcd(a, b) == 1\n}\n\n// Modular exponentiation: (base^exp) mod m\nfunction {:spec} modPow(base: nat, exp: nat, m: nat): nat\n  requires m > 0\n  decreases exp\n{\n  if exp == 0 then 1 % m\n  else if exp % 2 == 0 then\n    var half := modPow(base, exp / 2, m);\n    (half * half) % m\n  else\n    ((base % m) * modPow(base, exp - 1, m)) % m\n}\n\n// Fibonacci function\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// Factorial function\nfunction {:spec} fact(n: nat): nat\n{\n  if n == 0 then 1\n  else n * fact(n - 1)\n}\n\n// Binomial coefficient (n choose k)\nfunction {:spec} binomial(n: nat, k: nat): nat\n  requires k <= n\n{\n  var denominator := fact(k) * fact(n - k);\n  if denominator == 0 then 0  // Can't happen but helps verifier\n  else fact(n) / denominator\n}\n\n// Sum of first n natural numbers\nfunction {:spec} sumToN(n: nat): nat\n{\n  if n == 0 then 0\n  else n + sumToN(n - 1)\n}\n\n// Check if a number is perfect (sum of divisors equals the number)\npredicate {:spec} isPerfect(n: nat)\n  requires n > 0\n{\n  sumOfDivisors(n) == 2 * n  // Including n itself\n}\n\nfunction {:spec} sumOfDivisors(n: nat): nat\n  requires n > 0\n{\n  sumOfDivisorsHelper(n, n)\n}\n\nfunction sumOfDivisorsHelper(n: nat, d: nat): nat\n  requires n > 0\n  requires d > 0\n  decreases d\n{\n  if d == 1 then 1\n  else if divides(d, n) then d + sumOfDivisorsHelper(n, d - 1)\n  else sumOfDivisorsHelper(n, d - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma GcdZero(a: nat)\n  ensures gcd(a, 0) == a\n{\n  // Automatic by definition\n}\n\nlemma GcdPositive(a: nat, b: nat)\n  requires a > 0 || b > 0\n  ensures gcd(a, b) > 0\n  decreases b\n{\n  if b == 0 {\n    assert gcd(a, b) == a;\n    assert a > 0;\n  } else {\n    GcdPositive(b, a % b);\n  }\n}\n\nlemma GcdDividesBoth(a: nat, b: nat)\n  requires a > 0 && b > 0\n  ensures gcd(a, b) > 0\n{\n  GcdPositive(a, b);\n}\n\nlemma PrimeHasOnlyTwoDivisors(n: nat)\n  requires isPrime(n)\n  ensures divides(1, n) && divides(n, n)\n  ensures forall d: nat :: d > 0 && d < n && d != 1 ==> !divides(d, n)\n{\n  \n/*[CODE HERE]*/\n  assert divides(n, n);\n  forall d: nat | d > 0 && d < n && d != 1\n    ensures !divides(d, n)\n  {\n    if d >= 2 {\n      assert 2 <= d < n;\n      // By definition of isPrime\n    }\n  }\n}\n\nlemma TwoPrime()\n  ensures isPrime(2)\n{\n  assert forall d :: 2 <= d < 2 ==> !divides(d, 2);\n}\n\nlemma ThreePrime()\n  ensures isPrime(3)\n{\n  assert !divides(2, 3);\n}\n\nfunction Power(base: nat, exp: nat): nat\n  decreases exp\n{\n  if exp == 0 then 1\n  else base * Power(base, exp - 1)\n}\n\nlemma PowerSquare(base: nat)\n  ensures Power(base, 2) == base * base\n{\n  assert Power(base, 2) == base * Power(base, 1);\n  assert Power(base, 1) == base;\n}\n\nlemma PowerAddition(base: nat, exp1: nat, exp2: nat)\n  ensures Power(base, exp1 + exp2) == Power(base, exp1) * Power(base, exp2)\n  decreases exp1\n{\n  if exp1 == 0 {\n    assert Power(base, 0) == 1;\n  } else {\n    PowerAddition(base, exp1 - 1, exp2);\n    assert Power(base, exp1 + exp2) == base * Power(base, exp1 - 1 + exp2);\n    assert Power(base, exp1) == base * Power(base, exp1 - 1);\n  }\n}\n\nlemma SumFormula(n: nat)\n  ensures sumToN(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    assert sumToN(0) == 0;\n  } else {\n    SumFormula(n - 1);\n    assert sumToN(n - 1) == (n - 1) * n / 2;\n    assert sumToN(n) == n + sumToN(n - 1);\n    assert sumToN(n) == n + (n - 1) * n / 2;\n    assert sumToN(n) == (2 * n + (n - 1) * n) / 2;\n    assert sumToN(n) == (2 * n + n * n - n) / 2;\n    assert sumToN(n) == (n + n * n) / 2;\n    assert sumToN(n) == n * (1 + n) / 2;\n  }\n}\n\nlemma FactorialPositive(n: nat)\n  ensures fact(n) > 0\n{\n  if n == 0 {\n    assert fact(0) == 1;\n  } else {\n    FactorialPositive(n - 1);\n  }\n}\n\nlemma FibonacciMonotonic(n: nat)\n  requires n > 0\n  ensures fib(n) <= fib(n + 1)\n{\n  if n == 1 {\n    assert fib(1) == 1;\n    assert fib(2) == 1;\n  } else {\n    assert fib(n + 1) == fib(n) + fib(n - 1);\n    if n > 1 {\n      assert fib(n - 1) >= 0;\n    }\n  }\n}\n\nlemma BinomialSymmetry(n: nat, k: nat)\n  requires k <= n\n  ensures binomial(n, k) == binomial(n, n - k)\n{\n  assert fact(k) * fact(n - k) == fact(n - k) * fact(k);\n}", "output": "assert divides(1, n);"}, {"id": "example_TwoPrime_0", "type": "assert", "program": "// Mathematical operations: GCD, LCM, primes, modular arithmetic\n\n// Absolute value\nfunction {:spec} abs(x: int): nat\n{\n  if x < 0 then -x else x\n}\n\n// Greatest Common Divisor using Euclidean algorithm\nfunction {:spec} gcd(a: nat, b: nat): nat\n  decreases b\n{\n  if b == 0 then a\n  else gcd(b, a % b)\n}\n\n// Least Common Multiple\nfunction {:spec} lcm(a: nat, b: nat): nat\n  requires a > 0 && b > 0\n{\n  var g := gcd(a, b);\n  assert g > 0 by { GcdPositive(a, b); }\n  a / g * b  // Reordered to avoid overflow and ensure positive\n}\n\n// Check if a number divides another\npredicate {:spec} divides(d: nat, n: nat)\n  requires d > 0\n{\n  n % d == 0\n}\n\n// Check if a number is prime\npredicate {:spec} isPrime(n: nat)\n{\n  n > 1 && forall d :: 2 <= d < n ==> !divides(d, n)\n}\n\n// Check if two numbers are coprime (relatively prime)\npredicate {:spec} coprime(a: nat, b: nat)\n  requires a > 0 && b > 0\n{\n  gcd(a, b) == 1\n}\n\n// Modular exponentiation: (base^exp) mod m\nfunction {:spec} modPow(base: nat, exp: nat, m: nat): nat\n  requires m > 0\n  decreases exp\n{\n  if exp == 0 then 1 % m\n  else if exp % 2 == 0 then\n    var half := modPow(base, exp / 2, m);\n    (half * half) % m\n  else\n    ((base % m) * modPow(base, exp - 1, m)) % m\n}\n\n// Fibonacci function\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// Factorial function\nfunction {:spec} fact(n: nat): nat\n{\n  if n == 0 then 1\n  else n * fact(n - 1)\n}\n\n// Binomial coefficient (n choose k)\nfunction {:spec} binomial(n: nat, k: nat): nat\n  requires k <= n\n{\n  var denominator := fact(k) * fact(n - k);\n  if denominator == 0 then 0  // Can't happen but helps verifier\n  else fact(n) / denominator\n}\n\n// Sum of first n natural numbers\nfunction {:spec} sumToN(n: nat): nat\n{\n  if n == 0 then 0\n  else n + sumToN(n - 1)\n}\n\n// Check if a number is perfect (sum of divisors equals the number)\npredicate {:spec} isPerfect(n: nat)\n  requires n > 0\n{\n  sumOfDivisors(n) == 2 * n  // Including n itself\n}\n\nfunction {:spec} sumOfDivisors(n: nat): nat\n  requires n > 0\n{\n  sumOfDivisorsHelper(n, n)\n}\n\nfunction sumOfDivisorsHelper(n: nat, d: nat): nat\n  requires n > 0\n  requires d > 0\n  decreases d\n{\n  if d == 1 then 1\n  else if divides(d, n) then d + sumOfDivisorsHelper(n, d - 1)\n  else sumOfDivisorsHelper(n, d - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma GcdZero(a: nat)\n  ensures gcd(a, 0) == a\n{\n  // Automatic by definition\n}\n\nlemma GcdPositive(a: nat, b: nat)\n  requires a > 0 || b > 0\n  ensures gcd(a, b) > 0\n  decreases b\n{\n  if b == 0 {\n    assert gcd(a, b) == a;\n    assert a > 0;\n  } else {\n    GcdPositive(b, a % b);\n  }\n}\n\nlemma GcdDividesBoth(a: nat, b: nat)\n  requires a > 0 && b > 0\n  ensures gcd(a, b) > 0\n{\n  GcdPositive(a, b);\n}\n\nlemma PrimeHasOnlyTwoDivisors(n: nat)\n  requires isPrime(n)\n  ensures divides(1, n) && divides(n, n)\n  ensures forall d: nat :: d > 0 && d < n && d != 1 ==> !divides(d, n)\n{\n  assert divides(1, n);\n  assert divides(n, n);\n  forall d: nat | d > 0 && d < n && d != 1\n    ensures !divides(d, n)\n  {\n    if d >= 2 {\n      assert 2 <= d < n;\n      // By definition of isPrime\n    }\n  }\n}\n\nlemma TwoPrime()\n  ensures isPrime(2)\n{\n  \n/*[CODE HERE]*/\n}\n\nlemma ThreePrime()\n  ensures isPrime(3)\n{\n  assert !divides(2, 3);\n}\n\nfunction Power(base: nat, exp: nat): nat\n  decreases exp\n{\n  if exp == 0 then 1\n  else base * Power(base, exp - 1)\n}\n\nlemma PowerSquare(base: nat)\n  ensures Power(base, 2) == base * base\n{\n  assert Power(base, 2) == base * Power(base, 1);\n  assert Power(base, 1) == base;\n}\n\nlemma PowerAddition(base: nat, exp1: nat, exp2: nat)\n  ensures Power(base, exp1 + exp2) == Power(base, exp1) * Power(base, exp2)\n  decreases exp1\n{\n  if exp1 == 0 {\n    assert Power(base, 0) == 1;\n  } else {\n    PowerAddition(base, exp1 - 1, exp2);\n    assert Power(base, exp1 + exp2) == base * Power(base, exp1 - 1 + exp2);\n    assert Power(base, exp1) == base * Power(base, exp1 - 1);\n  }\n}\n\nlemma SumFormula(n: nat)\n  ensures sumToN(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    assert sumToN(0) == 0;\n  } else {\n    SumFormula(n - 1);\n    assert sumToN(n - 1) == (n - 1) * n / 2;\n    assert sumToN(n) == n + sumToN(n - 1);\n    assert sumToN(n) == n + (n - 1) * n / 2;\n    assert sumToN(n) == (2 * n + (n - 1) * n) / 2;\n    assert sumToN(n) == (2 * n + n * n - n) / 2;\n    assert sumToN(n) == (n + n * n) / 2;\n    assert sumToN(n) == n * (1 + n) / 2;\n  }\n}\n\nlemma FactorialPositive(n: nat)\n  ensures fact(n) > 0\n{\n  if n == 0 {\n    assert fact(0) == 1;\n  } else {\n    FactorialPositive(n - 1);\n  }\n}\n\nlemma FibonacciMonotonic(n: nat)\n  requires n > 0\n  ensures fib(n) <= fib(n + 1)\n{\n  if n == 1 {\n    assert fib(1) == 1;\n    assert fib(2) == 1;\n  } else {\n    assert fib(n + 1) == fib(n) + fib(n - 1);\n    if n > 1 {\n      assert fib(n - 1) >= 0;\n    }\n  }\n}\n\nlemma BinomialSymmetry(n: nat, k: nat)\n  requires k <= n\n  ensures binomial(n, k) == binomial(n, n - k)\n{\n  assert fact(k) * fact(n - k) == fact(n - k) * fact(k);\n}", "output": "assert forall d :: 2 <= d < 2 ==> !divides(d, 2);"}, {"id": "example_ThreePrime_0", "type": "assert", "program": "// Mathematical operations: GCD, LCM, primes, modular arithmetic\n\n// Absolute value\nfunction {:spec} abs(x: int): nat\n{\n  if x < 0 then -x else x\n}\n\n// Greatest Common Divisor using Euclidean algorithm\nfunction {:spec} gcd(a: nat, b: nat): nat\n  decreases b\n{\n  if b == 0 then a\n  else gcd(b, a % b)\n}\n\n// Least Common Multiple\nfunction {:spec} lcm(a: nat, b: nat): nat\n  requires a > 0 && b > 0\n{\n  var g := gcd(a, b);\n  assert g > 0 by { GcdPositive(a, b); }\n  a / g * b  // Reordered to avoid overflow and ensure positive\n}\n\n// Check if a number divides another\npredicate {:spec} divides(d: nat, n: nat)\n  requires d > 0\n{\n  n % d == 0\n}\n\n// Check if a number is prime\npredicate {:spec} isPrime(n: nat)\n{\n  n > 1 && forall d :: 2 <= d < n ==> !divides(d, n)\n}\n\n// Check if two numbers are coprime (relatively prime)\npredicate {:spec} coprime(a: nat, b: nat)\n  requires a > 0 && b > 0\n{\n  gcd(a, b) == 1\n}\n\n// Modular exponentiation: (base^exp) mod m\nfunction {:spec} modPow(base: nat, exp: nat, m: nat): nat\n  requires m > 0\n  decreases exp\n{\n  if exp == 0 then 1 % m\n  else if exp % 2 == 0 then\n    var half := modPow(base, exp / 2, m);\n    (half * half) % m\n  else\n    ((base % m) * modPow(base, exp - 1, m)) % m\n}\n\n// Fibonacci function\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// Factorial function\nfunction {:spec} fact(n: nat): nat\n{\n  if n == 0 then 1\n  else n * fact(n - 1)\n}\n\n// Binomial coefficient (n choose k)\nfunction {:spec} binomial(n: nat, k: nat): nat\n  requires k <= n\n{\n  var denominator := fact(k) * fact(n - k);\n  if denominator == 0 then 0  // Can't happen but helps verifier\n  else fact(n) / denominator\n}\n\n// Sum of first n natural numbers\nfunction {:spec} sumToN(n: nat): nat\n{\n  if n == 0 then 0\n  else n + sumToN(n - 1)\n}\n\n// Check if a number is perfect (sum of divisors equals the number)\npredicate {:spec} isPerfect(n: nat)\n  requires n > 0\n{\n  sumOfDivisors(n) == 2 * n  // Including n itself\n}\n\nfunction {:spec} sumOfDivisors(n: nat): nat\n  requires n > 0\n{\n  sumOfDivisorsHelper(n, n)\n}\n\nfunction sumOfDivisorsHelper(n: nat, d: nat): nat\n  requires n > 0\n  requires d > 0\n  decreases d\n{\n  if d == 1 then 1\n  else if divides(d, n) then d + sumOfDivisorsHelper(n, d - 1)\n  else sumOfDivisorsHelper(n, d - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma GcdZero(a: nat)\n  ensures gcd(a, 0) == a\n{\n  // Automatic by definition\n}\n\nlemma GcdPositive(a: nat, b: nat)\n  requires a > 0 || b > 0\n  ensures gcd(a, b) > 0\n  decreases b\n{\n  if b == 0 {\n    assert gcd(a, b) == a;\n    assert a > 0;\n  } else {\n    GcdPositive(b, a % b);\n  }\n}\n\nlemma GcdDividesBoth(a: nat, b: nat)\n  requires a > 0 && b > 0\n  ensures gcd(a, b) > 0\n{\n  GcdPositive(a, b);\n}\n\nlemma PrimeHasOnlyTwoDivisors(n: nat)\n  requires isPrime(n)\n  ensures divides(1, n) && divides(n, n)\n  ensures forall d: nat :: d > 0 && d < n && d != 1 ==> !divides(d, n)\n{\n  assert divides(1, n);\n  assert divides(n, n);\n  forall d: nat | d > 0 && d < n && d != 1\n    ensures !divides(d, n)\n  {\n    if d >= 2 {\n      assert 2 <= d < n;\n      // By definition of isPrime\n    }\n  }\n}\n\nlemma TwoPrime()\n  ensures isPrime(2)\n{\n  assert forall d :: 2 <= d < 2 ==> !divides(d, 2);\n}\n\nlemma ThreePrime()\n  ensures isPrime(3)\n{\n  \n/*[CODE HERE]*/\n}\n\nfunction Power(base: nat, exp: nat): nat\n  decreases exp\n{\n  if exp == 0 then 1\n  else base * Power(base, exp - 1)\n}\n\nlemma PowerSquare(base: nat)\n  ensures Power(base, 2) == base * base\n{\n  assert Power(base, 2) == base * Power(base, 1);\n  assert Power(base, 1) == base;\n}\n\nlemma PowerAddition(base: nat, exp1: nat, exp2: nat)\n  ensures Power(base, exp1 + exp2) == Power(base, exp1) * Power(base, exp2)\n  decreases exp1\n{\n  if exp1 == 0 {\n    assert Power(base, 0) == 1;\n  } else {\n    PowerAddition(base, exp1 - 1, exp2);\n    assert Power(base, exp1 + exp2) == base * Power(base, exp1 - 1 + exp2);\n    assert Power(base, exp1) == base * Power(base, exp1 - 1);\n  }\n}\n\nlemma SumFormula(n: nat)\n  ensures sumToN(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    assert sumToN(0) == 0;\n  } else {\n    SumFormula(n - 1);\n    assert sumToN(n - 1) == (n - 1) * n / 2;\n    assert sumToN(n) == n + sumToN(n - 1);\n    assert sumToN(n) == n + (n - 1) * n / 2;\n    assert sumToN(n) == (2 * n + (n - 1) * n) / 2;\n    assert sumToN(n) == (2 * n + n * n - n) / 2;\n    assert sumToN(n) == (n + n * n) / 2;\n    assert sumToN(n) == n * (1 + n) / 2;\n  }\n}\n\nlemma FactorialPositive(n: nat)\n  ensures fact(n) > 0\n{\n  if n == 0 {\n    assert fact(0) == 1;\n  } else {\n    FactorialPositive(n - 1);\n  }\n}\n\nlemma FibonacciMonotonic(n: nat)\n  requires n > 0\n  ensures fib(n) <= fib(n + 1)\n{\n  if n == 1 {\n    assert fib(1) == 1;\n    assert fib(2) == 1;\n  } else {\n    assert fib(n + 1) == fib(n) + fib(n - 1);\n    if n > 1 {\n      assert fib(n - 1) >= 0;\n    }\n  }\n}\n\nlemma BinomialSymmetry(n: nat, k: nat)\n  requires k <= n\n  ensures binomial(n, k) == binomial(n, n - k)\n{\n  assert fact(k) * fact(n - k) == fact(n - k) * fact(k);\n}", "output": "assert !divides(2, 3);"}, {"id": "example_PowerSquare_0", "type": "assert", "program": "// Mathematical operations: GCD, LCM, primes, modular arithmetic\n\n// Absolute value\nfunction {:spec} abs(x: int): nat\n{\n  if x < 0 then -x else x\n}\n\n// Greatest Common Divisor using Euclidean algorithm\nfunction {:spec} gcd(a: nat, b: nat): nat\n  decreases b\n{\n  if b == 0 then a\n  else gcd(b, a % b)\n}\n\n// Least Common Multiple\nfunction {:spec} lcm(a: nat, b: nat): nat\n  requires a > 0 && b > 0\n{\n  var g := gcd(a, b);\n  assert g > 0 by { GcdPositive(a, b); }\n  a / g * b  // Reordered to avoid overflow and ensure positive\n}\n\n// Check if a number divides another\npredicate {:spec} divides(d: nat, n: nat)\n  requires d > 0\n{\n  n % d == 0\n}\n\n// Check if a number is prime\npredicate {:spec} isPrime(n: nat)\n{\n  n > 1 && forall d :: 2 <= d < n ==> !divides(d, n)\n}\n\n// Check if two numbers are coprime (relatively prime)\npredicate {:spec} coprime(a: nat, b: nat)\n  requires a > 0 && b > 0\n{\n  gcd(a, b) == 1\n}\n\n// Modular exponentiation: (base^exp) mod m\nfunction {:spec} modPow(base: nat, exp: nat, m: nat): nat\n  requires m > 0\n  decreases exp\n{\n  if exp == 0 then 1 % m\n  else if exp % 2 == 0 then\n    var half := modPow(base, exp / 2, m);\n    (half * half) % m\n  else\n    ((base % m) * modPow(base, exp - 1, m)) % m\n}\n\n// Fibonacci function\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// Factorial function\nfunction {:spec} fact(n: nat): nat\n{\n  if n == 0 then 1\n  else n * fact(n - 1)\n}\n\n// Binomial coefficient (n choose k)\nfunction {:spec} binomial(n: nat, k: nat): nat\n  requires k <= n\n{\n  var denominator := fact(k) * fact(n - k);\n  if denominator == 0 then 0  // Can't happen but helps verifier\n  else fact(n) / denominator\n}\n\n// Sum of first n natural numbers\nfunction {:spec} sumToN(n: nat): nat\n{\n  if n == 0 then 0\n  else n + sumToN(n - 1)\n}\n\n// Check if a number is perfect (sum of divisors equals the number)\npredicate {:spec} isPerfect(n: nat)\n  requires n > 0\n{\n  sumOfDivisors(n) == 2 * n  // Including n itself\n}\n\nfunction {:spec} sumOfDivisors(n: nat): nat\n  requires n > 0\n{\n  sumOfDivisorsHelper(n, n)\n}\n\nfunction sumOfDivisorsHelper(n: nat, d: nat): nat\n  requires n > 0\n  requires d > 0\n  decreases d\n{\n  if d == 1 then 1\n  else if divides(d, n) then d + sumOfDivisorsHelper(n, d - 1)\n  else sumOfDivisorsHelper(n, d - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma GcdZero(a: nat)\n  ensures gcd(a, 0) == a\n{\n  // Automatic by definition\n}\n\nlemma GcdPositive(a: nat, b: nat)\n  requires a > 0 || b > 0\n  ensures gcd(a, b) > 0\n  decreases b\n{\n  if b == 0 {\n    assert gcd(a, b) == a;\n    assert a > 0;\n  } else {\n    GcdPositive(b, a % b);\n  }\n}\n\nlemma GcdDividesBoth(a: nat, b: nat)\n  requires a > 0 && b > 0\n  ensures gcd(a, b) > 0\n{\n  GcdPositive(a, b);\n}\n\nlemma PrimeHasOnlyTwoDivisors(n: nat)\n  requires isPrime(n)\n  ensures divides(1, n) && divides(n, n)\n  ensures forall d: nat :: d > 0 && d < n && d != 1 ==> !divides(d, n)\n{\n  assert divides(1, n);\n  assert divides(n, n);\n  forall d: nat | d > 0 && d < n && d != 1\n    ensures !divides(d, n)\n  {\n    if d >= 2 {\n      assert 2 <= d < n;\n      // By definition of isPrime\n    }\n  }\n}\n\nlemma TwoPrime()\n  ensures isPrime(2)\n{\n  assert forall d :: 2 <= d < 2 ==> !divides(d, 2);\n}\n\nlemma ThreePrime()\n  ensures isPrime(3)\n{\n  assert !divides(2, 3);\n}\n\nfunction Power(base: nat, exp: nat): nat\n  decreases exp\n{\n  if exp == 0 then 1\n  else base * Power(base, exp - 1)\n}\n\nlemma PowerSquare(base: nat)\n  ensures Power(base, 2) == base * base\n{\n  assert Power(base, 2) == base * Power(base, 1);\n  \n/*[CODE HERE]*/\n}\n\nlemma PowerAddition(base: nat, exp1: nat, exp2: nat)\n  ensures Power(base, exp1 + exp2) == Power(base, exp1) * Power(base, exp2)\n  decreases exp1\n{\n  if exp1 == 0 {\n    assert Power(base, 0) == 1;\n  } else {\n    PowerAddition(base, exp1 - 1, exp2);\n    assert Power(base, exp1 + exp2) == base * Power(base, exp1 - 1 + exp2);\n    assert Power(base, exp1) == base * Power(base, exp1 - 1);\n  }\n}\n\nlemma SumFormula(n: nat)\n  ensures sumToN(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    assert sumToN(0) == 0;\n  } else {\n    SumFormula(n - 1);\n    assert sumToN(n - 1) == (n - 1) * n / 2;\n    assert sumToN(n) == n + sumToN(n - 1);\n    assert sumToN(n) == n + (n - 1) * n / 2;\n    assert sumToN(n) == (2 * n + (n - 1) * n) / 2;\n    assert sumToN(n) == (2 * n + n * n - n) / 2;\n    assert sumToN(n) == (n + n * n) / 2;\n    assert sumToN(n) == n * (1 + n) / 2;\n  }\n}\n\nlemma FactorialPositive(n: nat)\n  ensures fact(n) > 0\n{\n  if n == 0 {\n    assert fact(0) == 1;\n  } else {\n    FactorialPositive(n - 1);\n  }\n}\n\nlemma FibonacciMonotonic(n: nat)\n  requires n > 0\n  ensures fib(n) <= fib(n + 1)\n{\n  if n == 1 {\n    assert fib(1) == 1;\n    assert fib(2) == 1;\n  } else {\n    assert fib(n + 1) == fib(n) + fib(n - 1);\n    if n > 1 {\n      assert fib(n - 1) >= 0;\n    }\n  }\n}\n\nlemma BinomialSymmetry(n: nat, k: nat)\n  requires k <= n\n  ensures binomial(n, k) == binomial(n, n - k)\n{\n  assert fact(k) * fact(n - k) == fact(n - k) * fact(k);\n}", "output": "assert Power(base, 1) == base;"}, {"id": "example_PowerSquare_1", "type": "assert", "program": "// Mathematical operations: GCD, LCM, primes, modular arithmetic\n\n// Absolute value\nfunction {:spec} abs(x: int): nat\n{\n  if x < 0 then -x else x\n}\n\n// Greatest Common Divisor using Euclidean algorithm\nfunction {:spec} gcd(a: nat, b: nat): nat\n  decreases b\n{\n  if b == 0 then a\n  else gcd(b, a % b)\n}\n\n// Least Common Multiple\nfunction {:spec} lcm(a: nat, b: nat): nat\n  requires a > 0 && b > 0\n{\n  var g := gcd(a, b);\n  assert g > 0 by { GcdPositive(a, b); }\n  a / g * b  // Reordered to avoid overflow and ensure positive\n}\n\n// Check if a number divides another\npredicate {:spec} divides(d: nat, n: nat)\n  requires d > 0\n{\n  n % d == 0\n}\n\n// Check if a number is prime\npredicate {:spec} isPrime(n: nat)\n{\n  n > 1 && forall d :: 2 <= d < n ==> !divides(d, n)\n}\n\n// Check if two numbers are coprime (relatively prime)\npredicate {:spec} coprime(a: nat, b: nat)\n  requires a > 0 && b > 0\n{\n  gcd(a, b) == 1\n}\n\n// Modular exponentiation: (base^exp) mod m\nfunction {:spec} modPow(base: nat, exp: nat, m: nat): nat\n  requires m > 0\n  decreases exp\n{\n  if exp == 0 then 1 % m\n  else if exp % 2 == 0 then\n    var half := modPow(base, exp / 2, m);\n    (half * half) % m\n  else\n    ((base % m) * modPow(base, exp - 1, m)) % m\n}\n\n// Fibonacci function\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// Factorial function\nfunction {:spec} fact(n: nat): nat\n{\n  if n == 0 then 1\n  else n * fact(n - 1)\n}\n\n// Binomial coefficient (n choose k)\nfunction {:spec} binomial(n: nat, k: nat): nat\n  requires k <= n\n{\n  var denominator := fact(k) * fact(n - k);\n  if denominator == 0 then 0  // Can't happen but helps verifier\n  else fact(n) / denominator\n}\n\n// Sum of first n natural numbers\nfunction {:spec} sumToN(n: nat): nat\n{\n  if n == 0 then 0\n  else n + sumToN(n - 1)\n}\n\n// Check if a number is perfect (sum of divisors equals the number)\npredicate {:spec} isPerfect(n: nat)\n  requires n > 0\n{\n  sumOfDivisors(n) == 2 * n  // Including n itself\n}\n\nfunction {:spec} sumOfDivisors(n: nat): nat\n  requires n > 0\n{\n  sumOfDivisorsHelper(n, n)\n}\n\nfunction sumOfDivisorsHelper(n: nat, d: nat): nat\n  requires n > 0\n  requires d > 0\n  decreases d\n{\n  if d == 1 then 1\n  else if divides(d, n) then d + sumOfDivisorsHelper(n, d - 1)\n  else sumOfDivisorsHelper(n, d - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma GcdZero(a: nat)\n  ensures gcd(a, 0) == a\n{\n  // Automatic by definition\n}\n\nlemma GcdPositive(a: nat, b: nat)\n  requires a > 0 || b > 0\n  ensures gcd(a, b) > 0\n  decreases b\n{\n  if b == 0 {\n    assert gcd(a, b) == a;\n    assert a > 0;\n  } else {\n    GcdPositive(b, a % b);\n  }\n}\n\nlemma GcdDividesBoth(a: nat, b: nat)\n  requires a > 0 && b > 0\n  ensures gcd(a, b) > 0\n{\n  GcdPositive(a, b);\n}\n\nlemma PrimeHasOnlyTwoDivisors(n: nat)\n  requires isPrime(n)\n  ensures divides(1, n) && divides(n, n)\n  ensures forall d: nat :: d > 0 && d < n && d != 1 ==> !divides(d, n)\n{\n  assert divides(1, n);\n  assert divides(n, n);\n  forall d: nat | d > 0 && d < n && d != 1\n    ensures !divides(d, n)\n  {\n    if d >= 2 {\n      assert 2 <= d < n;\n      // By definition of isPrime\n    }\n  }\n}\n\nlemma TwoPrime()\n  ensures isPrime(2)\n{\n  assert forall d :: 2 <= d < 2 ==> !divides(d, 2);\n}\n\nlemma ThreePrime()\n  ensures isPrime(3)\n{\n  assert !divides(2, 3);\n}\n\nfunction Power(base: nat, exp: nat): nat\n  decreases exp\n{\n  if exp == 0 then 1\n  else base * Power(base, exp - 1)\n}\n\nlemma PowerSquare(base: nat)\n  ensures Power(base, 2) == base * base\n{\n  \n/*[CODE HERE]*/\n  assert Power(base, 1) == base;\n}\n\nlemma PowerAddition(base: nat, exp1: nat, exp2: nat)\n  ensures Power(base, exp1 + exp2) == Power(base, exp1) * Power(base, exp2)\n  decreases exp1\n{\n  if exp1 == 0 {\n    assert Power(base, 0) == 1;\n  } else {\n    PowerAddition(base, exp1 - 1, exp2);\n    assert Power(base, exp1 + exp2) == base * Power(base, exp1 - 1 + exp2);\n    assert Power(base, exp1) == base * Power(base, exp1 - 1);\n  }\n}\n\nlemma SumFormula(n: nat)\n  ensures sumToN(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    assert sumToN(0) == 0;\n  } else {\n    SumFormula(n - 1);\n    assert sumToN(n - 1) == (n - 1) * n / 2;\n    assert sumToN(n) == n + sumToN(n - 1);\n    assert sumToN(n) == n + (n - 1) * n / 2;\n    assert sumToN(n) == (2 * n + (n - 1) * n) / 2;\n    assert sumToN(n) == (2 * n + n * n - n) / 2;\n    assert sumToN(n) == (n + n * n) / 2;\n    assert sumToN(n) == n * (1 + n) / 2;\n  }\n}\n\nlemma FactorialPositive(n: nat)\n  ensures fact(n) > 0\n{\n  if n == 0 {\n    assert fact(0) == 1;\n  } else {\n    FactorialPositive(n - 1);\n  }\n}\n\nlemma FibonacciMonotonic(n: nat)\n  requires n > 0\n  ensures fib(n) <= fib(n + 1)\n{\n  if n == 1 {\n    assert fib(1) == 1;\n    assert fib(2) == 1;\n  } else {\n    assert fib(n + 1) == fib(n) + fib(n - 1);\n    if n > 1 {\n      assert fib(n - 1) >= 0;\n    }\n  }\n}\n\nlemma BinomialSymmetry(n: nat, k: nat)\n  requires k <= n\n  ensures binomial(n, k) == binomial(n, n - k)\n{\n  assert fact(k) * fact(n - k) == fact(n - k) * fact(k);\n}", "output": "assert Power(base, 2) == base * Power(base, 1);"}, {"id": "example_PowerAddition_0", "type": "assert", "program": "// Mathematical operations: GCD, LCM, primes, modular arithmetic\n\n// Absolute value\nfunction {:spec} abs(x: int): nat\n{\n  if x < 0 then -x else x\n}\n\n// Greatest Common Divisor using Euclidean algorithm\nfunction {:spec} gcd(a: nat, b: nat): nat\n  decreases b\n{\n  if b == 0 then a\n  else gcd(b, a % b)\n}\n\n// Least Common Multiple\nfunction {:spec} lcm(a: nat, b: nat): nat\n  requires a > 0 && b > 0\n{\n  var g := gcd(a, b);\n  assert g > 0 by { GcdPositive(a, b); }\n  a / g * b  // Reordered to avoid overflow and ensure positive\n}\n\n// Check if a number divides another\npredicate {:spec} divides(d: nat, n: nat)\n  requires d > 0\n{\n  n % d == 0\n}\n\n// Check if a number is prime\npredicate {:spec} isPrime(n: nat)\n{\n  n > 1 && forall d :: 2 <= d < n ==> !divides(d, n)\n}\n\n// Check if two numbers are coprime (relatively prime)\npredicate {:spec} coprime(a: nat, b: nat)\n  requires a > 0 && b > 0\n{\n  gcd(a, b) == 1\n}\n\n// Modular exponentiation: (base^exp) mod m\nfunction {:spec} modPow(base: nat, exp: nat, m: nat): nat\n  requires m > 0\n  decreases exp\n{\n  if exp == 0 then 1 % m\n  else if exp % 2 == 0 then\n    var half := modPow(base, exp / 2, m);\n    (half * half) % m\n  else\n    ((base % m) * modPow(base, exp - 1, m)) % m\n}\n\n// Fibonacci function\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// Factorial function\nfunction {:spec} fact(n: nat): nat\n{\n  if n == 0 then 1\n  else n * fact(n - 1)\n}\n\n// Binomial coefficient (n choose k)\nfunction {:spec} binomial(n: nat, k: nat): nat\n  requires k <= n\n{\n  var denominator := fact(k) * fact(n - k);\n  if denominator == 0 then 0  // Can't happen but helps verifier\n  else fact(n) / denominator\n}\n\n// Sum of first n natural numbers\nfunction {:spec} sumToN(n: nat): nat\n{\n  if n == 0 then 0\n  else n + sumToN(n - 1)\n}\n\n// Check if a number is perfect (sum of divisors equals the number)\npredicate {:spec} isPerfect(n: nat)\n  requires n > 0\n{\n  sumOfDivisors(n) == 2 * n  // Including n itself\n}\n\nfunction {:spec} sumOfDivisors(n: nat): nat\n  requires n > 0\n{\n  sumOfDivisorsHelper(n, n)\n}\n\nfunction sumOfDivisorsHelper(n: nat, d: nat): nat\n  requires n > 0\n  requires d > 0\n  decreases d\n{\n  if d == 1 then 1\n  else if divides(d, n) then d + sumOfDivisorsHelper(n, d - 1)\n  else sumOfDivisorsHelper(n, d - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma GcdZero(a: nat)\n  ensures gcd(a, 0) == a\n{\n  // Automatic by definition\n}\n\nlemma GcdPositive(a: nat, b: nat)\n  requires a > 0 || b > 0\n  ensures gcd(a, b) > 0\n  decreases b\n{\n  if b == 0 {\n    assert gcd(a, b) == a;\n    assert a > 0;\n  } else {\n    GcdPositive(b, a % b);\n  }\n}\n\nlemma GcdDividesBoth(a: nat, b: nat)\n  requires a > 0 && b > 0\n  ensures gcd(a, b) > 0\n{\n  GcdPositive(a, b);\n}\n\nlemma PrimeHasOnlyTwoDivisors(n: nat)\n  requires isPrime(n)\n  ensures divides(1, n) && divides(n, n)\n  ensures forall d: nat :: d > 0 && d < n && d != 1 ==> !divides(d, n)\n{\n  assert divides(1, n);\n  assert divides(n, n);\n  forall d: nat | d > 0 && d < n && d != 1\n    ensures !divides(d, n)\n  {\n    if d >= 2 {\n      assert 2 <= d < n;\n      // By definition of isPrime\n    }\n  }\n}\n\nlemma TwoPrime()\n  ensures isPrime(2)\n{\n  assert forall d :: 2 <= d < 2 ==> !divides(d, 2);\n}\n\nlemma ThreePrime()\n  ensures isPrime(3)\n{\n  assert !divides(2, 3);\n}\n\nfunction Power(base: nat, exp: nat): nat\n  decreases exp\n{\n  if exp == 0 then 1\n  else base * Power(base, exp - 1)\n}\n\nlemma PowerSquare(base: nat)\n  ensures Power(base, 2) == base * base\n{\n  assert Power(base, 2) == base * Power(base, 1);\n  assert Power(base, 1) == base;\n}\n\nlemma PowerAddition(base: nat, exp1: nat, exp2: nat)\n  ensures Power(base, exp1 + exp2) == Power(base, exp1) * Power(base, exp2)\n  decreases exp1\n{\n  if exp1 == 0 {\n    assert Power(base, 0) == 1;\n  } else {\n    PowerAddition(base, exp1 - 1, exp2);\n    assert Power(base, exp1 + exp2) == base * Power(base, exp1 - 1 + exp2);\n    \n/*[CODE HERE]*/\n  }\n}\n\nlemma SumFormula(n: nat)\n  ensures sumToN(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    assert sumToN(0) == 0;\n  } else {\n    SumFormula(n - 1);\n    assert sumToN(n - 1) == (n - 1) * n / 2;\n    assert sumToN(n) == n + sumToN(n - 1);\n    assert sumToN(n) == n + (n - 1) * n / 2;\n    assert sumToN(n) == (2 * n + (n - 1) * n) / 2;\n    assert sumToN(n) == (2 * n + n * n - n) / 2;\n    assert sumToN(n) == (n + n * n) / 2;\n    assert sumToN(n) == n * (1 + n) / 2;\n  }\n}\n\nlemma FactorialPositive(n: nat)\n  ensures fact(n) > 0\n{\n  if n == 0 {\n    assert fact(0) == 1;\n  } else {\n    FactorialPositive(n - 1);\n  }\n}\n\nlemma FibonacciMonotonic(n: nat)\n  requires n > 0\n  ensures fib(n) <= fib(n + 1)\n{\n  if n == 1 {\n    assert fib(1) == 1;\n    assert fib(2) == 1;\n  } else {\n    assert fib(n + 1) == fib(n) + fib(n - 1);\n    if n > 1 {\n      assert fib(n - 1) >= 0;\n    }\n  }\n}\n\nlemma BinomialSymmetry(n: nat, k: nat)\n  requires k <= n\n  ensures binomial(n, k) == binomial(n, n - k)\n{\n  assert fact(k) * fact(n - k) == fact(n - k) * fact(k);\n}", "output": "assert Power(base, exp1) == base * Power(base, exp1 - 1);"}, {"id": "example_PowerAddition_1", "type": "assert", "program": "// Mathematical operations: GCD, LCM, primes, modular arithmetic\n\n// Absolute value\nfunction {:spec} abs(x: int): nat\n{\n  if x < 0 then -x else x\n}\n\n// Greatest Common Divisor using Euclidean algorithm\nfunction {:spec} gcd(a: nat, b: nat): nat\n  decreases b\n{\n  if b == 0 then a\n  else gcd(b, a % b)\n}\n\n// Least Common Multiple\nfunction {:spec} lcm(a: nat, b: nat): nat\n  requires a > 0 && b > 0\n{\n  var g := gcd(a, b);\n  assert g > 0 by { GcdPositive(a, b); }\n  a / g * b  // Reordered to avoid overflow and ensure positive\n}\n\n// Check if a number divides another\npredicate {:spec} divides(d: nat, n: nat)\n  requires d > 0\n{\n  n % d == 0\n}\n\n// Check if a number is prime\npredicate {:spec} isPrime(n: nat)\n{\n  n > 1 && forall d :: 2 <= d < n ==> !divides(d, n)\n}\n\n// Check if two numbers are coprime (relatively prime)\npredicate {:spec} coprime(a: nat, b: nat)\n  requires a > 0 && b > 0\n{\n  gcd(a, b) == 1\n}\n\n// Modular exponentiation: (base^exp) mod m\nfunction {:spec} modPow(base: nat, exp: nat, m: nat): nat\n  requires m > 0\n  decreases exp\n{\n  if exp == 0 then 1 % m\n  else if exp % 2 == 0 then\n    var half := modPow(base, exp / 2, m);\n    (half * half) % m\n  else\n    ((base % m) * modPow(base, exp - 1, m)) % m\n}\n\n// Fibonacci function\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// Factorial function\nfunction {:spec} fact(n: nat): nat\n{\n  if n == 0 then 1\n  else n * fact(n - 1)\n}\n\n// Binomial coefficient (n choose k)\nfunction {:spec} binomial(n: nat, k: nat): nat\n  requires k <= n\n{\n  var denominator := fact(k) * fact(n - k);\n  if denominator == 0 then 0  // Can't happen but helps verifier\n  else fact(n) / denominator\n}\n\n// Sum of first n natural numbers\nfunction {:spec} sumToN(n: nat): nat\n{\n  if n == 0 then 0\n  else n + sumToN(n - 1)\n}\n\n// Check if a number is perfect (sum of divisors equals the number)\npredicate {:spec} isPerfect(n: nat)\n  requires n > 0\n{\n  sumOfDivisors(n) == 2 * n  // Including n itself\n}\n\nfunction {:spec} sumOfDivisors(n: nat): nat\n  requires n > 0\n{\n  sumOfDivisorsHelper(n, n)\n}\n\nfunction sumOfDivisorsHelper(n: nat, d: nat): nat\n  requires n > 0\n  requires d > 0\n  decreases d\n{\n  if d == 1 then 1\n  else if divides(d, n) then d + sumOfDivisorsHelper(n, d - 1)\n  else sumOfDivisorsHelper(n, d - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma GcdZero(a: nat)\n  ensures gcd(a, 0) == a\n{\n  // Automatic by definition\n}\n\nlemma GcdPositive(a: nat, b: nat)\n  requires a > 0 || b > 0\n  ensures gcd(a, b) > 0\n  decreases b\n{\n  if b == 0 {\n    assert gcd(a, b) == a;\n    assert a > 0;\n  } else {\n    GcdPositive(b, a % b);\n  }\n}\n\nlemma GcdDividesBoth(a: nat, b: nat)\n  requires a > 0 && b > 0\n  ensures gcd(a, b) > 0\n{\n  GcdPositive(a, b);\n}\n\nlemma PrimeHasOnlyTwoDivisors(n: nat)\n  requires isPrime(n)\n  ensures divides(1, n) && divides(n, n)\n  ensures forall d: nat :: d > 0 && d < n && d != 1 ==> !divides(d, n)\n{\n  assert divides(1, n);\n  assert divides(n, n);\n  forall d: nat | d > 0 && d < n && d != 1\n    ensures !divides(d, n)\n  {\n    if d >= 2 {\n      assert 2 <= d < n;\n      // By definition of isPrime\n    }\n  }\n}\n\nlemma TwoPrime()\n  ensures isPrime(2)\n{\n  assert forall d :: 2 <= d < 2 ==> !divides(d, 2);\n}\n\nlemma ThreePrime()\n  ensures isPrime(3)\n{\n  assert !divides(2, 3);\n}\n\nfunction Power(base: nat, exp: nat): nat\n  decreases exp\n{\n  if exp == 0 then 1\n  else base * Power(base, exp - 1)\n}\n\nlemma PowerSquare(base: nat)\n  ensures Power(base, 2) == base * base\n{\n  assert Power(base, 2) == base * Power(base, 1);\n  assert Power(base, 1) == base;\n}\n\nlemma PowerAddition(base: nat, exp1: nat, exp2: nat)\n  ensures Power(base, exp1 + exp2) == Power(base, exp1) * Power(base, exp2)\n  decreases exp1\n{\n  if exp1 == 0 {\n    assert Power(base, 0) == 1;\n  } else {\n    PowerAddition(base, exp1 - 1, exp2);\n    \n/*[CODE HERE]*/\n    assert Power(base, exp1) == base * Power(base, exp1 - 1);\n  }\n}\n\nlemma SumFormula(n: nat)\n  ensures sumToN(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    assert sumToN(0) == 0;\n  } else {\n    SumFormula(n - 1);\n    assert sumToN(n - 1) == (n - 1) * n / 2;\n    assert sumToN(n) == n + sumToN(n - 1);\n    assert sumToN(n) == n + (n - 1) * n / 2;\n    assert sumToN(n) == (2 * n + (n - 1) * n) / 2;\n    assert sumToN(n) == (2 * n + n * n - n) / 2;\n    assert sumToN(n) == (n + n * n) / 2;\n    assert sumToN(n) == n * (1 + n) / 2;\n  }\n}\n\nlemma FactorialPositive(n: nat)\n  ensures fact(n) > 0\n{\n  if n == 0 {\n    assert fact(0) == 1;\n  } else {\n    FactorialPositive(n - 1);\n  }\n}\n\nlemma FibonacciMonotonic(n: nat)\n  requires n > 0\n  ensures fib(n) <= fib(n + 1)\n{\n  if n == 1 {\n    assert fib(1) == 1;\n    assert fib(2) == 1;\n  } else {\n    assert fib(n + 1) == fib(n) + fib(n - 1);\n    if n > 1 {\n      assert fib(n - 1) >= 0;\n    }\n  }\n}\n\nlemma BinomialSymmetry(n: nat, k: nat)\n  requires k <= n\n  ensures binomial(n, k) == binomial(n, n - k)\n{\n  assert fact(k) * fact(n - k) == fact(n - k) * fact(k);\n}", "output": "assert Power(base, exp1 + exp2) == base * Power(base, exp1 - 1 + exp2);"}, {"id": "example_PowerAddition_2", "type": "call", "program": "// Mathematical operations: GCD, LCM, primes, modular arithmetic\n\n// Absolute value\nfunction {:spec} abs(x: int): nat\n{\n  if x < 0 then -x else x\n}\n\n// Greatest Common Divisor using Euclidean algorithm\nfunction {:spec} gcd(a: nat, b: nat): nat\n  decreases b\n{\n  if b == 0 then a\n  else gcd(b, a % b)\n}\n\n// Least Common Multiple\nfunction {:spec} lcm(a: nat, b: nat): nat\n  requires a > 0 && b > 0\n{\n  var g := gcd(a, b);\n  assert g > 0 by { GcdPositive(a, b); }\n  a / g * b  // Reordered to avoid overflow and ensure positive\n}\n\n// Check if a number divides another\npredicate {:spec} divides(d: nat, n: nat)\n  requires d > 0\n{\n  n % d == 0\n}\n\n// Check if a number is prime\npredicate {:spec} isPrime(n: nat)\n{\n  n > 1 && forall d :: 2 <= d < n ==> !divides(d, n)\n}\n\n// Check if two numbers are coprime (relatively prime)\npredicate {:spec} coprime(a: nat, b: nat)\n  requires a > 0 && b > 0\n{\n  gcd(a, b) == 1\n}\n\n// Modular exponentiation: (base^exp) mod m\nfunction {:spec} modPow(base: nat, exp: nat, m: nat): nat\n  requires m > 0\n  decreases exp\n{\n  if exp == 0 then 1 % m\n  else if exp % 2 == 0 then\n    var half := modPow(base, exp / 2, m);\n    (half * half) % m\n  else\n    ((base % m) * modPow(base, exp - 1, m)) % m\n}\n\n// Fibonacci function\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// Factorial function\nfunction {:spec} fact(n: nat): nat\n{\n  if n == 0 then 1\n  else n * fact(n - 1)\n}\n\n// Binomial coefficient (n choose k)\nfunction {:spec} binomial(n: nat, k: nat): nat\n  requires k <= n\n{\n  var denominator := fact(k) * fact(n - k);\n  if denominator == 0 then 0  // Can't happen but helps verifier\n  else fact(n) / denominator\n}\n\n// Sum of first n natural numbers\nfunction {:spec} sumToN(n: nat): nat\n{\n  if n == 0 then 0\n  else n + sumToN(n - 1)\n}\n\n// Check if a number is perfect (sum of divisors equals the number)\npredicate {:spec} isPerfect(n: nat)\n  requires n > 0\n{\n  sumOfDivisors(n) == 2 * n  // Including n itself\n}\n\nfunction {:spec} sumOfDivisors(n: nat): nat\n  requires n > 0\n{\n  sumOfDivisorsHelper(n, n)\n}\n\nfunction sumOfDivisorsHelper(n: nat, d: nat): nat\n  requires n > 0\n  requires d > 0\n  decreases d\n{\n  if d == 1 then 1\n  else if divides(d, n) then d + sumOfDivisorsHelper(n, d - 1)\n  else sumOfDivisorsHelper(n, d - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma GcdZero(a: nat)\n  ensures gcd(a, 0) == a\n{\n  // Automatic by definition\n}\n\nlemma GcdPositive(a: nat, b: nat)\n  requires a > 0 || b > 0\n  ensures gcd(a, b) > 0\n  decreases b\n{\n  if b == 0 {\n    assert gcd(a, b) == a;\n    assert a > 0;\n  } else {\n    GcdPositive(b, a % b);\n  }\n}\n\nlemma GcdDividesBoth(a: nat, b: nat)\n  requires a > 0 && b > 0\n  ensures gcd(a, b) > 0\n{\n  GcdPositive(a, b);\n}\n\nlemma PrimeHasOnlyTwoDivisors(n: nat)\n  requires isPrime(n)\n  ensures divides(1, n) && divides(n, n)\n  ensures forall d: nat :: d > 0 && d < n && d != 1 ==> !divides(d, n)\n{\n  assert divides(1, n);\n  assert divides(n, n);\n  forall d: nat | d > 0 && d < n && d != 1\n    ensures !divides(d, n)\n  {\n    if d >= 2 {\n      assert 2 <= d < n;\n      // By definition of isPrime\n    }\n  }\n}\n\nlemma TwoPrime()\n  ensures isPrime(2)\n{\n  assert forall d :: 2 <= d < 2 ==> !divides(d, 2);\n}\n\nlemma ThreePrime()\n  ensures isPrime(3)\n{\n  assert !divides(2, 3);\n}\n\nfunction Power(base: nat, exp: nat): nat\n  decreases exp\n{\n  if exp == 0 then 1\n  else base * Power(base, exp - 1)\n}\n\nlemma PowerSquare(base: nat)\n  ensures Power(base, 2) == base * base\n{\n  assert Power(base, 2) == base * Power(base, 1);\n  assert Power(base, 1) == base;\n}\n\nlemma PowerAddition(base: nat, exp1: nat, exp2: nat)\n  ensures Power(base, exp1 + exp2) == Power(base, exp1) * Power(base, exp2)\n  decreases exp1\n{\n  if exp1 == 0 {\n    assert Power(base, 0) == 1;\n  } else {\n    \n/*[CODE HERE]*/\n    assert Power(base, exp1 + exp2) == base * Power(base, exp1 - 1 + exp2);\n    assert Power(base, exp1) == base * Power(base, exp1 - 1);\n  }\n}\n\nlemma SumFormula(n: nat)\n  ensures sumToN(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    assert sumToN(0) == 0;\n  } else {\n    SumFormula(n - 1);\n    assert sumToN(n - 1) == (n - 1) * n / 2;\n    assert sumToN(n) == n + sumToN(n - 1);\n    assert sumToN(n) == n + (n - 1) * n / 2;\n    assert sumToN(n) == (2 * n + (n - 1) * n) / 2;\n    assert sumToN(n) == (2 * n + n * n - n) / 2;\n    assert sumToN(n) == (n + n * n) / 2;\n    assert sumToN(n) == n * (1 + n) / 2;\n  }\n}\n\nlemma FactorialPositive(n: nat)\n  ensures fact(n) > 0\n{\n  if n == 0 {\n    assert fact(0) == 1;\n  } else {\n    FactorialPositive(n - 1);\n  }\n}\n\nlemma FibonacciMonotonic(n: nat)\n  requires n > 0\n  ensures fib(n) <= fib(n + 1)\n{\n  if n == 1 {\n    assert fib(1) == 1;\n    assert fib(2) == 1;\n  } else {\n    assert fib(n + 1) == fib(n) + fib(n - 1);\n    if n > 1 {\n      assert fib(n - 1) >= 0;\n    }\n  }\n}\n\nlemma BinomialSymmetry(n: nat, k: nat)\n  requires k <= n\n  ensures binomial(n, k) == binomial(n, n - k)\n{\n  assert fact(k) * fact(n - k) == fact(n - k) * fact(k);\n}", "output": "PowerAddition(base, exp1 - 1, exp2);"}, {"id": "example_PowerAddition_3", "type": "assert", "program": "// Mathematical operations: GCD, LCM, primes, modular arithmetic\n\n// Absolute value\nfunction {:spec} abs(x: int): nat\n{\n  if x < 0 then -x else x\n}\n\n// Greatest Common Divisor using Euclidean algorithm\nfunction {:spec} gcd(a: nat, b: nat): nat\n  decreases b\n{\n  if b == 0 then a\n  else gcd(b, a % b)\n}\n\n// Least Common Multiple\nfunction {:spec} lcm(a: nat, b: nat): nat\n  requires a > 0 && b > 0\n{\n  var g := gcd(a, b);\n  assert g > 0 by { GcdPositive(a, b); }\n  a / g * b  // Reordered to avoid overflow and ensure positive\n}\n\n// Check if a number divides another\npredicate {:spec} divides(d: nat, n: nat)\n  requires d > 0\n{\n  n % d == 0\n}\n\n// Check if a number is prime\npredicate {:spec} isPrime(n: nat)\n{\n  n > 1 && forall d :: 2 <= d < n ==> !divides(d, n)\n}\n\n// Check if two numbers are coprime (relatively prime)\npredicate {:spec} coprime(a: nat, b: nat)\n  requires a > 0 && b > 0\n{\n  gcd(a, b) == 1\n}\n\n// Modular exponentiation: (base^exp) mod m\nfunction {:spec} modPow(base: nat, exp: nat, m: nat): nat\n  requires m > 0\n  decreases exp\n{\n  if exp == 0 then 1 % m\n  else if exp % 2 == 0 then\n    var half := modPow(base, exp / 2, m);\n    (half * half) % m\n  else\n    ((base % m) * modPow(base, exp - 1, m)) % m\n}\n\n// Fibonacci function\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// Factorial function\nfunction {:spec} fact(n: nat): nat\n{\n  if n == 0 then 1\n  else n * fact(n - 1)\n}\n\n// Binomial coefficient (n choose k)\nfunction {:spec} binomial(n: nat, k: nat): nat\n  requires k <= n\n{\n  var denominator := fact(k) * fact(n - k);\n  if denominator == 0 then 0  // Can't happen but helps verifier\n  else fact(n) / denominator\n}\n\n// Sum of first n natural numbers\nfunction {:spec} sumToN(n: nat): nat\n{\n  if n == 0 then 0\n  else n + sumToN(n - 1)\n}\n\n// Check if a number is perfect (sum of divisors equals the number)\npredicate {:spec} isPerfect(n: nat)\n  requires n > 0\n{\n  sumOfDivisors(n) == 2 * n  // Including n itself\n}\n\nfunction {:spec} sumOfDivisors(n: nat): nat\n  requires n > 0\n{\n  sumOfDivisorsHelper(n, n)\n}\n\nfunction sumOfDivisorsHelper(n: nat, d: nat): nat\n  requires n > 0\n  requires d > 0\n  decreases d\n{\n  if d == 1 then 1\n  else if divides(d, n) then d + sumOfDivisorsHelper(n, d - 1)\n  else sumOfDivisorsHelper(n, d - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma GcdZero(a: nat)\n  ensures gcd(a, 0) == a\n{\n  // Automatic by definition\n}\n\nlemma GcdPositive(a: nat, b: nat)\n  requires a > 0 || b > 0\n  ensures gcd(a, b) > 0\n  decreases b\n{\n  if b == 0 {\n    assert gcd(a, b) == a;\n    assert a > 0;\n  } else {\n    GcdPositive(b, a % b);\n  }\n}\n\nlemma GcdDividesBoth(a: nat, b: nat)\n  requires a > 0 && b > 0\n  ensures gcd(a, b) > 0\n{\n  GcdPositive(a, b);\n}\n\nlemma PrimeHasOnlyTwoDivisors(n: nat)\n  requires isPrime(n)\n  ensures divides(1, n) && divides(n, n)\n  ensures forall d: nat :: d > 0 && d < n && d != 1 ==> !divides(d, n)\n{\n  assert divides(1, n);\n  assert divides(n, n);\n  forall d: nat | d > 0 && d < n && d != 1\n    ensures !divides(d, n)\n  {\n    if d >= 2 {\n      assert 2 <= d < n;\n      // By definition of isPrime\n    }\n  }\n}\n\nlemma TwoPrime()\n  ensures isPrime(2)\n{\n  assert forall d :: 2 <= d < 2 ==> !divides(d, 2);\n}\n\nlemma ThreePrime()\n  ensures isPrime(3)\n{\n  assert !divides(2, 3);\n}\n\nfunction Power(base: nat, exp: nat): nat\n  decreases exp\n{\n  if exp == 0 then 1\n  else base * Power(base, exp - 1)\n}\n\nlemma PowerSquare(base: nat)\n  ensures Power(base, 2) == base * base\n{\n  assert Power(base, 2) == base * Power(base, 1);\n  assert Power(base, 1) == base;\n}\n\nlemma PowerAddition(base: nat, exp1: nat, exp2: nat)\n  ensures Power(base, exp1 + exp2) == Power(base, exp1) * Power(base, exp2)\n  decreases exp1\n{\n  if exp1 == 0 {\n    \n/*[CODE HERE]*/\n  } else {\n    PowerAddition(base, exp1 - 1, exp2);\n    assert Power(base, exp1 + exp2) == base * Power(base, exp1 - 1 + exp2);\n    assert Power(base, exp1) == base * Power(base, exp1 - 1);\n  }\n}\n\nlemma SumFormula(n: nat)\n  ensures sumToN(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    assert sumToN(0) == 0;\n  } else {\n    SumFormula(n - 1);\n    assert sumToN(n - 1) == (n - 1) * n / 2;\n    assert sumToN(n) == n + sumToN(n - 1);\n    assert sumToN(n) == n + (n - 1) * n / 2;\n    assert sumToN(n) == (2 * n + (n - 1) * n) / 2;\n    assert sumToN(n) == (2 * n + n * n - n) / 2;\n    assert sumToN(n) == (n + n * n) / 2;\n    assert sumToN(n) == n * (1 + n) / 2;\n  }\n}\n\nlemma FactorialPositive(n: nat)\n  ensures fact(n) > 0\n{\n  if n == 0 {\n    assert fact(0) == 1;\n  } else {\n    FactorialPositive(n - 1);\n  }\n}\n\nlemma FibonacciMonotonic(n: nat)\n  requires n > 0\n  ensures fib(n) <= fib(n + 1)\n{\n  if n == 1 {\n    assert fib(1) == 1;\n    assert fib(2) == 1;\n  } else {\n    assert fib(n + 1) == fib(n) + fib(n - 1);\n    if n > 1 {\n      assert fib(n - 1) >= 0;\n    }\n  }\n}\n\nlemma BinomialSymmetry(n: nat, k: nat)\n  requires k <= n\n  ensures binomial(n, k) == binomial(n, n - k)\n{\n  assert fact(k) * fact(n - k) == fact(n - k) * fact(k);\n}", "output": "assert Power(base, 0) == 1;"}, {"id": "example_SumFormula_0", "type": "assert", "program": "// Mathematical operations: GCD, LCM, primes, modular arithmetic\n\n// Absolute value\nfunction {:spec} abs(x: int): nat\n{\n  if x < 0 then -x else x\n}\n\n// Greatest Common Divisor using Euclidean algorithm\nfunction {:spec} gcd(a: nat, b: nat): nat\n  decreases b\n{\n  if b == 0 then a\n  else gcd(b, a % b)\n}\n\n// Least Common Multiple\nfunction {:spec} lcm(a: nat, b: nat): nat\n  requires a > 0 && b > 0\n{\n  var g := gcd(a, b);\n  assert g > 0 by { GcdPositive(a, b); }\n  a / g * b  // Reordered to avoid overflow and ensure positive\n}\n\n// Check if a number divides another\npredicate {:spec} divides(d: nat, n: nat)\n  requires d > 0\n{\n  n % d == 0\n}\n\n// Check if a number is prime\npredicate {:spec} isPrime(n: nat)\n{\n  n > 1 && forall d :: 2 <= d < n ==> !divides(d, n)\n}\n\n// Check if two numbers are coprime (relatively prime)\npredicate {:spec} coprime(a: nat, b: nat)\n  requires a > 0 && b > 0\n{\n  gcd(a, b) == 1\n}\n\n// Modular exponentiation: (base^exp) mod m\nfunction {:spec} modPow(base: nat, exp: nat, m: nat): nat\n  requires m > 0\n  decreases exp\n{\n  if exp == 0 then 1 % m\n  else if exp % 2 == 0 then\n    var half := modPow(base, exp / 2, m);\n    (half * half) % m\n  else\n    ((base % m) * modPow(base, exp - 1, m)) % m\n}\n\n// Fibonacci function\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// Factorial function\nfunction {:spec} fact(n: nat): nat\n{\n  if n == 0 then 1\n  else n * fact(n - 1)\n}\n\n// Binomial coefficient (n choose k)\nfunction {:spec} binomial(n: nat, k: nat): nat\n  requires k <= n\n{\n  var denominator := fact(k) * fact(n - k);\n  if denominator == 0 then 0  // Can't happen but helps verifier\n  else fact(n) / denominator\n}\n\n// Sum of first n natural numbers\nfunction {:spec} sumToN(n: nat): nat\n{\n  if n == 0 then 0\n  else n + sumToN(n - 1)\n}\n\n// Check if a number is perfect (sum of divisors equals the number)\npredicate {:spec} isPerfect(n: nat)\n  requires n > 0\n{\n  sumOfDivisors(n) == 2 * n  // Including n itself\n}\n\nfunction {:spec} sumOfDivisors(n: nat): nat\n  requires n > 0\n{\n  sumOfDivisorsHelper(n, n)\n}\n\nfunction sumOfDivisorsHelper(n: nat, d: nat): nat\n  requires n > 0\n  requires d > 0\n  decreases d\n{\n  if d == 1 then 1\n  else if divides(d, n) then d + sumOfDivisorsHelper(n, d - 1)\n  else sumOfDivisorsHelper(n, d - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma GcdZero(a: nat)\n  ensures gcd(a, 0) == a\n{\n  // Automatic by definition\n}\n\nlemma GcdPositive(a: nat, b: nat)\n  requires a > 0 || b > 0\n  ensures gcd(a, b) > 0\n  decreases b\n{\n  if b == 0 {\n    assert gcd(a, b) == a;\n    assert a > 0;\n  } else {\n    GcdPositive(b, a % b);\n  }\n}\n\nlemma GcdDividesBoth(a: nat, b: nat)\n  requires a > 0 && b > 0\n  ensures gcd(a, b) > 0\n{\n  GcdPositive(a, b);\n}\n\nlemma PrimeHasOnlyTwoDivisors(n: nat)\n  requires isPrime(n)\n  ensures divides(1, n) && divides(n, n)\n  ensures forall d: nat :: d > 0 && d < n && d != 1 ==> !divides(d, n)\n{\n  assert divides(1, n);\n  assert divides(n, n);\n  forall d: nat | d > 0 && d < n && d != 1\n    ensures !divides(d, n)\n  {\n    if d >= 2 {\n      assert 2 <= d < n;\n      // By definition of isPrime\n    }\n  }\n}\n\nlemma TwoPrime()\n  ensures isPrime(2)\n{\n  assert forall d :: 2 <= d < 2 ==> !divides(d, 2);\n}\n\nlemma ThreePrime()\n  ensures isPrime(3)\n{\n  assert !divides(2, 3);\n}\n\nfunction Power(base: nat, exp: nat): nat\n  decreases exp\n{\n  if exp == 0 then 1\n  else base * Power(base, exp - 1)\n}\n\nlemma PowerSquare(base: nat)\n  ensures Power(base, 2) == base * base\n{\n  assert Power(base, 2) == base * Power(base, 1);\n  assert Power(base, 1) == base;\n}\n\nlemma PowerAddition(base: nat, exp1: nat, exp2: nat)\n  ensures Power(base, exp1 + exp2) == Power(base, exp1) * Power(base, exp2)\n  decreases exp1\n{\n  if exp1 == 0 {\n    assert Power(base, 0) == 1;\n  } else {\n    PowerAddition(base, exp1 - 1, exp2);\n    assert Power(base, exp1 + exp2) == base * Power(base, exp1 - 1 + exp2);\n    assert Power(base, exp1) == base * Power(base, exp1 - 1);\n  }\n}\n\nlemma SumFormula(n: nat)\n  ensures sumToN(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    assert sumToN(0) == 0;\n  } else {\n    SumFormula(n - 1);\n    assert sumToN(n - 1) == (n - 1) * n / 2;\n    assert sumToN(n) == n + sumToN(n - 1);\n    assert sumToN(n) == n + (n - 1) * n / 2;\n    assert sumToN(n) == (2 * n + (n - 1) * n) / 2;\n    assert sumToN(n) == (2 * n + n * n - n) / 2;\n    assert sumToN(n) == (n + n * n) / 2;\n    \n/*[CODE HERE]*/\n  }\n}\n\nlemma FactorialPositive(n: nat)\n  ensures fact(n) > 0\n{\n  if n == 0 {\n    assert fact(0) == 1;\n  } else {\n    FactorialPositive(n - 1);\n  }\n}\n\nlemma FibonacciMonotonic(n: nat)\n  requires n > 0\n  ensures fib(n) <= fib(n + 1)\n{\n  if n == 1 {\n    assert fib(1) == 1;\n    assert fib(2) == 1;\n  } else {\n    assert fib(n + 1) == fib(n) + fib(n - 1);\n    if n > 1 {\n      assert fib(n - 1) >= 0;\n    }\n  }\n}\n\nlemma BinomialSymmetry(n: nat, k: nat)\n  requires k <= n\n  ensures binomial(n, k) == binomial(n, n - k)\n{\n  assert fact(k) * fact(n - k) == fact(n - k) * fact(k);\n}", "output": "assert sumToN(n) == n * (1 + n) / 2;"}, {"id": "example_SumFormula_1", "type": "assert", "program": "// Mathematical operations: GCD, LCM, primes, modular arithmetic\n\n// Absolute value\nfunction {:spec} abs(x: int): nat\n{\n  if x < 0 then -x else x\n}\n\n// Greatest Common Divisor using Euclidean algorithm\nfunction {:spec} gcd(a: nat, b: nat): nat\n  decreases b\n{\n  if b == 0 then a\n  else gcd(b, a % b)\n}\n\n// Least Common Multiple\nfunction {:spec} lcm(a: nat, b: nat): nat\n  requires a > 0 && b > 0\n{\n  var g := gcd(a, b);\n  assert g > 0 by { GcdPositive(a, b); }\n  a / g * b  // Reordered to avoid overflow and ensure positive\n}\n\n// Check if a number divides another\npredicate {:spec} divides(d: nat, n: nat)\n  requires d > 0\n{\n  n % d == 0\n}\n\n// Check if a number is prime\npredicate {:spec} isPrime(n: nat)\n{\n  n > 1 && forall d :: 2 <= d < n ==> !divides(d, n)\n}\n\n// Check if two numbers are coprime (relatively prime)\npredicate {:spec} coprime(a: nat, b: nat)\n  requires a > 0 && b > 0\n{\n  gcd(a, b) == 1\n}\n\n// Modular exponentiation: (base^exp) mod m\nfunction {:spec} modPow(base: nat, exp: nat, m: nat): nat\n  requires m > 0\n  decreases exp\n{\n  if exp == 0 then 1 % m\n  else if exp % 2 == 0 then\n    var half := modPow(base, exp / 2, m);\n    (half * half) % m\n  else\n    ((base % m) * modPow(base, exp - 1, m)) % m\n}\n\n// Fibonacci function\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// Factorial function\nfunction {:spec} fact(n: nat): nat\n{\n  if n == 0 then 1\n  else n * fact(n - 1)\n}\n\n// Binomial coefficient (n choose k)\nfunction {:spec} binomial(n: nat, k: nat): nat\n  requires k <= n\n{\n  var denominator := fact(k) * fact(n - k);\n  if denominator == 0 then 0  // Can't happen but helps verifier\n  else fact(n) / denominator\n}\n\n// Sum of first n natural numbers\nfunction {:spec} sumToN(n: nat): nat\n{\n  if n == 0 then 0\n  else n + sumToN(n - 1)\n}\n\n// Check if a number is perfect (sum of divisors equals the number)\npredicate {:spec} isPerfect(n: nat)\n  requires n > 0\n{\n  sumOfDivisors(n) == 2 * n  // Including n itself\n}\n\nfunction {:spec} sumOfDivisors(n: nat): nat\n  requires n > 0\n{\n  sumOfDivisorsHelper(n, n)\n}\n\nfunction sumOfDivisorsHelper(n: nat, d: nat): nat\n  requires n > 0\n  requires d > 0\n  decreases d\n{\n  if d == 1 then 1\n  else if divides(d, n) then d + sumOfDivisorsHelper(n, d - 1)\n  else sumOfDivisorsHelper(n, d - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma GcdZero(a: nat)\n  ensures gcd(a, 0) == a\n{\n  // Automatic by definition\n}\n\nlemma GcdPositive(a: nat, b: nat)\n  requires a > 0 || b > 0\n  ensures gcd(a, b) > 0\n  decreases b\n{\n  if b == 0 {\n    assert gcd(a, b) == a;\n    assert a > 0;\n  } else {\n    GcdPositive(b, a % b);\n  }\n}\n\nlemma GcdDividesBoth(a: nat, b: nat)\n  requires a > 0 && b > 0\n  ensures gcd(a, b) > 0\n{\n  GcdPositive(a, b);\n}\n\nlemma PrimeHasOnlyTwoDivisors(n: nat)\n  requires isPrime(n)\n  ensures divides(1, n) && divides(n, n)\n  ensures forall d: nat :: d > 0 && d < n && d != 1 ==> !divides(d, n)\n{\n  assert divides(1, n);\n  assert divides(n, n);\n  forall d: nat | d > 0 && d < n && d != 1\n    ensures !divides(d, n)\n  {\n    if d >= 2 {\n      assert 2 <= d < n;\n      // By definition of isPrime\n    }\n  }\n}\n\nlemma TwoPrime()\n  ensures isPrime(2)\n{\n  assert forall d :: 2 <= d < 2 ==> !divides(d, 2);\n}\n\nlemma ThreePrime()\n  ensures isPrime(3)\n{\n  assert !divides(2, 3);\n}\n\nfunction Power(base: nat, exp: nat): nat\n  decreases exp\n{\n  if exp == 0 then 1\n  else base * Power(base, exp - 1)\n}\n\nlemma PowerSquare(base: nat)\n  ensures Power(base, 2) == base * base\n{\n  assert Power(base, 2) == base * Power(base, 1);\n  assert Power(base, 1) == base;\n}\n\nlemma PowerAddition(base: nat, exp1: nat, exp2: nat)\n  ensures Power(base, exp1 + exp2) == Power(base, exp1) * Power(base, exp2)\n  decreases exp1\n{\n  if exp1 == 0 {\n    assert Power(base, 0) == 1;\n  } else {\n    PowerAddition(base, exp1 - 1, exp2);\n    assert Power(base, exp1 + exp2) == base * Power(base, exp1 - 1 + exp2);\n    assert Power(base, exp1) == base * Power(base, exp1 - 1);\n  }\n}\n\nlemma SumFormula(n: nat)\n  ensures sumToN(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    assert sumToN(0) == 0;\n  } else {\n    SumFormula(n - 1);\n    assert sumToN(n - 1) == (n - 1) * n / 2;\n    assert sumToN(n) == n + sumToN(n - 1);\n    assert sumToN(n) == n + (n - 1) * n / 2;\n    assert sumToN(n) == (2 * n + (n - 1) * n) / 2;\n    assert sumToN(n) == (2 * n + n * n - n) / 2;\n    \n/*[CODE HERE]*/\n    assert sumToN(n) == n * (1 + n) / 2;\n  }\n}\n\nlemma FactorialPositive(n: nat)\n  ensures fact(n) > 0\n{\n  if n == 0 {\n    assert fact(0) == 1;\n  } else {\n    FactorialPositive(n - 1);\n  }\n}\n\nlemma FibonacciMonotonic(n: nat)\n  requires n > 0\n  ensures fib(n) <= fib(n + 1)\n{\n  if n == 1 {\n    assert fib(1) == 1;\n    assert fib(2) == 1;\n  } else {\n    assert fib(n + 1) == fib(n) + fib(n - 1);\n    if n > 1 {\n      assert fib(n - 1) >= 0;\n    }\n  }\n}\n\nlemma BinomialSymmetry(n: nat, k: nat)\n  requires k <= n\n  ensures binomial(n, k) == binomial(n, n - k)\n{\n  assert fact(k) * fact(n - k) == fact(n - k) * fact(k);\n}", "output": "assert sumToN(n) == (n + n * n) / 2;"}, {"id": "example_SumFormula_2", "type": "assert", "program": "// Mathematical operations: GCD, LCM, primes, modular arithmetic\n\n// Absolute value\nfunction {:spec} abs(x: int): nat\n{\n  if x < 0 then -x else x\n}\n\n// Greatest Common Divisor using Euclidean algorithm\nfunction {:spec} gcd(a: nat, b: nat): nat\n  decreases b\n{\n  if b == 0 then a\n  else gcd(b, a % b)\n}\n\n// Least Common Multiple\nfunction {:spec} lcm(a: nat, b: nat): nat\n  requires a > 0 && b > 0\n{\n  var g := gcd(a, b);\n  assert g > 0 by { GcdPositive(a, b); }\n  a / g * b  // Reordered to avoid overflow and ensure positive\n}\n\n// Check if a number divides another\npredicate {:spec} divides(d: nat, n: nat)\n  requires d > 0\n{\n  n % d == 0\n}\n\n// Check if a number is prime\npredicate {:spec} isPrime(n: nat)\n{\n  n > 1 && forall d :: 2 <= d < n ==> !divides(d, n)\n}\n\n// Check if two numbers are coprime (relatively prime)\npredicate {:spec} coprime(a: nat, b: nat)\n  requires a > 0 && b > 0\n{\n  gcd(a, b) == 1\n}\n\n// Modular exponentiation: (base^exp) mod m\nfunction {:spec} modPow(base: nat, exp: nat, m: nat): nat\n  requires m > 0\n  decreases exp\n{\n  if exp == 0 then 1 % m\n  else if exp % 2 == 0 then\n    var half := modPow(base, exp / 2, m);\n    (half * half) % m\n  else\n    ((base % m) * modPow(base, exp - 1, m)) % m\n}\n\n// Fibonacci function\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// Factorial function\nfunction {:spec} fact(n: nat): nat\n{\n  if n == 0 then 1\n  else n * fact(n - 1)\n}\n\n// Binomial coefficient (n choose k)\nfunction {:spec} binomial(n: nat, k: nat): nat\n  requires k <= n\n{\n  var denominator := fact(k) * fact(n - k);\n  if denominator == 0 then 0  // Can't happen but helps verifier\n  else fact(n) / denominator\n}\n\n// Sum of first n natural numbers\nfunction {:spec} sumToN(n: nat): nat\n{\n  if n == 0 then 0\n  else n + sumToN(n - 1)\n}\n\n// Check if a number is perfect (sum of divisors equals the number)\npredicate {:spec} isPerfect(n: nat)\n  requires n > 0\n{\n  sumOfDivisors(n) == 2 * n  // Including n itself\n}\n\nfunction {:spec} sumOfDivisors(n: nat): nat\n  requires n > 0\n{\n  sumOfDivisorsHelper(n, n)\n}\n\nfunction sumOfDivisorsHelper(n: nat, d: nat): nat\n  requires n > 0\n  requires d > 0\n  decreases d\n{\n  if d == 1 then 1\n  else if divides(d, n) then d + sumOfDivisorsHelper(n, d - 1)\n  else sumOfDivisorsHelper(n, d - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma GcdZero(a: nat)\n  ensures gcd(a, 0) == a\n{\n  // Automatic by definition\n}\n\nlemma GcdPositive(a: nat, b: nat)\n  requires a > 0 || b > 0\n  ensures gcd(a, b) > 0\n  decreases b\n{\n  if b == 0 {\n    assert gcd(a, b) == a;\n    assert a > 0;\n  } else {\n    GcdPositive(b, a % b);\n  }\n}\n\nlemma GcdDividesBoth(a: nat, b: nat)\n  requires a > 0 && b > 0\n  ensures gcd(a, b) > 0\n{\n  GcdPositive(a, b);\n}\n\nlemma PrimeHasOnlyTwoDivisors(n: nat)\n  requires isPrime(n)\n  ensures divides(1, n) && divides(n, n)\n  ensures forall d: nat :: d > 0 && d < n && d != 1 ==> !divides(d, n)\n{\n  assert divides(1, n);\n  assert divides(n, n);\n  forall d: nat | d > 0 && d < n && d != 1\n    ensures !divides(d, n)\n  {\n    if d >= 2 {\n      assert 2 <= d < n;\n      // By definition of isPrime\n    }\n  }\n}\n\nlemma TwoPrime()\n  ensures isPrime(2)\n{\n  assert forall d :: 2 <= d < 2 ==> !divides(d, 2);\n}\n\nlemma ThreePrime()\n  ensures isPrime(3)\n{\n  assert !divides(2, 3);\n}\n\nfunction Power(base: nat, exp: nat): nat\n  decreases exp\n{\n  if exp == 0 then 1\n  else base * Power(base, exp - 1)\n}\n\nlemma PowerSquare(base: nat)\n  ensures Power(base, 2) == base * base\n{\n  assert Power(base, 2) == base * Power(base, 1);\n  assert Power(base, 1) == base;\n}\n\nlemma PowerAddition(base: nat, exp1: nat, exp2: nat)\n  ensures Power(base, exp1 + exp2) == Power(base, exp1) * Power(base, exp2)\n  decreases exp1\n{\n  if exp1 == 0 {\n    assert Power(base, 0) == 1;\n  } else {\n    PowerAddition(base, exp1 - 1, exp2);\n    assert Power(base, exp1 + exp2) == base * Power(base, exp1 - 1 + exp2);\n    assert Power(base, exp1) == base * Power(base, exp1 - 1);\n  }\n}\n\nlemma SumFormula(n: nat)\n  ensures sumToN(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    assert sumToN(0) == 0;\n  } else {\n    SumFormula(n - 1);\n    assert sumToN(n - 1) == (n - 1) * n / 2;\n    assert sumToN(n) == n + sumToN(n - 1);\n    assert sumToN(n) == n + (n - 1) * n / 2;\n    assert sumToN(n) == (2 * n + (n - 1) * n) / 2;\n    \n/*[CODE HERE]*/\n    assert sumToN(n) == (n + n * n) / 2;\n    assert sumToN(n) == n * (1 + n) / 2;\n  }\n}\n\nlemma FactorialPositive(n: nat)\n  ensures fact(n) > 0\n{\n  if n == 0 {\n    assert fact(0) == 1;\n  } else {\n    FactorialPositive(n - 1);\n  }\n}\n\nlemma FibonacciMonotonic(n: nat)\n  requires n > 0\n  ensures fib(n) <= fib(n + 1)\n{\n  if n == 1 {\n    assert fib(1) == 1;\n    assert fib(2) == 1;\n  } else {\n    assert fib(n + 1) == fib(n) + fib(n - 1);\n    if n > 1 {\n      assert fib(n - 1) >= 0;\n    }\n  }\n}\n\nlemma BinomialSymmetry(n: nat, k: nat)\n  requires k <= n\n  ensures binomial(n, k) == binomial(n, n - k)\n{\n  assert fact(k) * fact(n - k) == fact(n - k) * fact(k);\n}", "output": "assert sumToN(n) == (2 * n + n * n - n) / 2;"}, {"id": "example_SumFormula_3", "type": "assert", "program": "// Mathematical operations: GCD, LCM, primes, modular arithmetic\n\n// Absolute value\nfunction {:spec} abs(x: int): nat\n{\n  if x < 0 then -x else x\n}\n\n// Greatest Common Divisor using Euclidean algorithm\nfunction {:spec} gcd(a: nat, b: nat): nat\n  decreases b\n{\n  if b == 0 then a\n  else gcd(b, a % b)\n}\n\n// Least Common Multiple\nfunction {:spec} lcm(a: nat, b: nat): nat\n  requires a > 0 && b > 0\n{\n  var g := gcd(a, b);\n  assert g > 0 by { GcdPositive(a, b); }\n  a / g * b  // Reordered to avoid overflow and ensure positive\n}\n\n// Check if a number divides another\npredicate {:spec} divides(d: nat, n: nat)\n  requires d > 0\n{\n  n % d == 0\n}\n\n// Check if a number is prime\npredicate {:spec} isPrime(n: nat)\n{\n  n > 1 && forall d :: 2 <= d < n ==> !divides(d, n)\n}\n\n// Check if two numbers are coprime (relatively prime)\npredicate {:spec} coprime(a: nat, b: nat)\n  requires a > 0 && b > 0\n{\n  gcd(a, b) == 1\n}\n\n// Modular exponentiation: (base^exp) mod m\nfunction {:spec} modPow(base: nat, exp: nat, m: nat): nat\n  requires m > 0\n  decreases exp\n{\n  if exp == 0 then 1 % m\n  else if exp % 2 == 0 then\n    var half := modPow(base, exp / 2, m);\n    (half * half) % m\n  else\n    ((base % m) * modPow(base, exp - 1, m)) % m\n}\n\n// Fibonacci function\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// Factorial function\nfunction {:spec} fact(n: nat): nat\n{\n  if n == 0 then 1\n  else n * fact(n - 1)\n}\n\n// Binomial coefficient (n choose k)\nfunction {:spec} binomial(n: nat, k: nat): nat\n  requires k <= n\n{\n  var denominator := fact(k) * fact(n - k);\n  if denominator == 0 then 0  // Can't happen but helps verifier\n  else fact(n) / denominator\n}\n\n// Sum of first n natural numbers\nfunction {:spec} sumToN(n: nat): nat\n{\n  if n == 0 then 0\n  else n + sumToN(n - 1)\n}\n\n// Check if a number is perfect (sum of divisors equals the number)\npredicate {:spec} isPerfect(n: nat)\n  requires n > 0\n{\n  sumOfDivisors(n) == 2 * n  // Including n itself\n}\n\nfunction {:spec} sumOfDivisors(n: nat): nat\n  requires n > 0\n{\n  sumOfDivisorsHelper(n, n)\n}\n\nfunction sumOfDivisorsHelper(n: nat, d: nat): nat\n  requires n > 0\n  requires d > 0\n  decreases d\n{\n  if d == 1 then 1\n  else if divides(d, n) then d + sumOfDivisorsHelper(n, d - 1)\n  else sumOfDivisorsHelper(n, d - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma GcdZero(a: nat)\n  ensures gcd(a, 0) == a\n{\n  // Automatic by definition\n}\n\nlemma GcdPositive(a: nat, b: nat)\n  requires a > 0 || b > 0\n  ensures gcd(a, b) > 0\n  decreases b\n{\n  if b == 0 {\n    assert gcd(a, b) == a;\n    assert a > 0;\n  } else {\n    GcdPositive(b, a % b);\n  }\n}\n\nlemma GcdDividesBoth(a: nat, b: nat)\n  requires a > 0 && b > 0\n  ensures gcd(a, b) > 0\n{\n  GcdPositive(a, b);\n}\n\nlemma PrimeHasOnlyTwoDivisors(n: nat)\n  requires isPrime(n)\n  ensures divides(1, n) && divides(n, n)\n  ensures forall d: nat :: d > 0 && d < n && d != 1 ==> !divides(d, n)\n{\n  assert divides(1, n);\n  assert divides(n, n);\n  forall d: nat | d > 0 && d < n && d != 1\n    ensures !divides(d, n)\n  {\n    if d >= 2 {\n      assert 2 <= d < n;\n      // By definition of isPrime\n    }\n  }\n}\n\nlemma TwoPrime()\n  ensures isPrime(2)\n{\n  assert forall d :: 2 <= d < 2 ==> !divides(d, 2);\n}\n\nlemma ThreePrime()\n  ensures isPrime(3)\n{\n  assert !divides(2, 3);\n}\n\nfunction Power(base: nat, exp: nat): nat\n  decreases exp\n{\n  if exp == 0 then 1\n  else base * Power(base, exp - 1)\n}\n\nlemma PowerSquare(base: nat)\n  ensures Power(base, 2) == base * base\n{\n  assert Power(base, 2) == base * Power(base, 1);\n  assert Power(base, 1) == base;\n}\n\nlemma PowerAddition(base: nat, exp1: nat, exp2: nat)\n  ensures Power(base, exp1 + exp2) == Power(base, exp1) * Power(base, exp2)\n  decreases exp1\n{\n  if exp1 == 0 {\n    assert Power(base, 0) == 1;\n  } else {\n    PowerAddition(base, exp1 - 1, exp2);\n    assert Power(base, exp1 + exp2) == base * Power(base, exp1 - 1 + exp2);\n    assert Power(base, exp1) == base * Power(base, exp1 - 1);\n  }\n}\n\nlemma SumFormula(n: nat)\n  ensures sumToN(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    assert sumToN(0) == 0;\n  } else {\n    SumFormula(n - 1);\n    assert sumToN(n - 1) == (n - 1) * n / 2;\n    assert sumToN(n) == n + sumToN(n - 1);\n    assert sumToN(n) == n + (n - 1) * n / 2;\n    \n/*[CODE HERE]*/\n    assert sumToN(n) == (2 * n + n * n - n) / 2;\n    assert sumToN(n) == (n + n * n) / 2;\n    assert sumToN(n) == n * (1 + n) / 2;\n  }\n}\n\nlemma FactorialPositive(n: nat)\n  ensures fact(n) > 0\n{\n  if n == 0 {\n    assert fact(0) == 1;\n  } else {\n    FactorialPositive(n - 1);\n  }\n}\n\nlemma FibonacciMonotonic(n: nat)\n  requires n > 0\n  ensures fib(n) <= fib(n + 1)\n{\n  if n == 1 {\n    assert fib(1) == 1;\n    assert fib(2) == 1;\n  } else {\n    assert fib(n + 1) == fib(n) + fib(n - 1);\n    if n > 1 {\n      assert fib(n - 1) >= 0;\n    }\n  }\n}\n\nlemma BinomialSymmetry(n: nat, k: nat)\n  requires k <= n\n  ensures binomial(n, k) == binomial(n, n - k)\n{\n  assert fact(k) * fact(n - k) == fact(n - k) * fact(k);\n}", "output": "assert sumToN(n) == (2 * n + (n - 1) * n) / 2;"}, {"id": "example_SumFormula_4", "type": "assert", "program": "// Mathematical operations: GCD, LCM, primes, modular arithmetic\n\n// Absolute value\nfunction {:spec} abs(x: int): nat\n{\n  if x < 0 then -x else x\n}\n\n// Greatest Common Divisor using Euclidean algorithm\nfunction {:spec} gcd(a: nat, b: nat): nat\n  decreases b\n{\n  if b == 0 then a\n  else gcd(b, a % b)\n}\n\n// Least Common Multiple\nfunction {:spec} lcm(a: nat, b: nat): nat\n  requires a > 0 && b > 0\n{\n  var g := gcd(a, b);\n  assert g > 0 by { GcdPositive(a, b); }\n  a / g * b  // Reordered to avoid overflow and ensure positive\n}\n\n// Check if a number divides another\npredicate {:spec} divides(d: nat, n: nat)\n  requires d > 0\n{\n  n % d == 0\n}\n\n// Check if a number is prime\npredicate {:spec} isPrime(n: nat)\n{\n  n > 1 && forall d :: 2 <= d < n ==> !divides(d, n)\n}\n\n// Check if two numbers are coprime (relatively prime)\npredicate {:spec} coprime(a: nat, b: nat)\n  requires a > 0 && b > 0\n{\n  gcd(a, b) == 1\n}\n\n// Modular exponentiation: (base^exp) mod m\nfunction {:spec} modPow(base: nat, exp: nat, m: nat): nat\n  requires m > 0\n  decreases exp\n{\n  if exp == 0 then 1 % m\n  else if exp % 2 == 0 then\n    var half := modPow(base, exp / 2, m);\n    (half * half) % m\n  else\n    ((base % m) * modPow(base, exp - 1, m)) % m\n}\n\n// Fibonacci function\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// Factorial function\nfunction {:spec} fact(n: nat): nat\n{\n  if n == 0 then 1\n  else n * fact(n - 1)\n}\n\n// Binomial coefficient (n choose k)\nfunction {:spec} binomial(n: nat, k: nat): nat\n  requires k <= n\n{\n  var denominator := fact(k) * fact(n - k);\n  if denominator == 0 then 0  // Can't happen but helps verifier\n  else fact(n) / denominator\n}\n\n// Sum of first n natural numbers\nfunction {:spec} sumToN(n: nat): nat\n{\n  if n == 0 then 0\n  else n + sumToN(n - 1)\n}\n\n// Check if a number is perfect (sum of divisors equals the number)\npredicate {:spec} isPerfect(n: nat)\n  requires n > 0\n{\n  sumOfDivisors(n) == 2 * n  // Including n itself\n}\n\nfunction {:spec} sumOfDivisors(n: nat): nat\n  requires n > 0\n{\n  sumOfDivisorsHelper(n, n)\n}\n\nfunction sumOfDivisorsHelper(n: nat, d: nat): nat\n  requires n > 0\n  requires d > 0\n  decreases d\n{\n  if d == 1 then 1\n  else if divides(d, n) then d + sumOfDivisorsHelper(n, d - 1)\n  else sumOfDivisorsHelper(n, d - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma GcdZero(a: nat)\n  ensures gcd(a, 0) == a\n{\n  // Automatic by definition\n}\n\nlemma GcdPositive(a: nat, b: nat)\n  requires a > 0 || b > 0\n  ensures gcd(a, b) > 0\n  decreases b\n{\n  if b == 0 {\n    assert gcd(a, b) == a;\n    assert a > 0;\n  } else {\n    GcdPositive(b, a % b);\n  }\n}\n\nlemma GcdDividesBoth(a: nat, b: nat)\n  requires a > 0 && b > 0\n  ensures gcd(a, b) > 0\n{\n  GcdPositive(a, b);\n}\n\nlemma PrimeHasOnlyTwoDivisors(n: nat)\n  requires isPrime(n)\n  ensures divides(1, n) && divides(n, n)\n  ensures forall d: nat :: d > 0 && d < n && d != 1 ==> !divides(d, n)\n{\n  assert divides(1, n);\n  assert divides(n, n);\n  forall d: nat | d > 0 && d < n && d != 1\n    ensures !divides(d, n)\n  {\n    if d >= 2 {\n      assert 2 <= d < n;\n      // By definition of isPrime\n    }\n  }\n}\n\nlemma TwoPrime()\n  ensures isPrime(2)\n{\n  assert forall d :: 2 <= d < 2 ==> !divides(d, 2);\n}\n\nlemma ThreePrime()\n  ensures isPrime(3)\n{\n  assert !divides(2, 3);\n}\n\nfunction Power(base: nat, exp: nat): nat\n  decreases exp\n{\n  if exp == 0 then 1\n  else base * Power(base, exp - 1)\n}\n\nlemma PowerSquare(base: nat)\n  ensures Power(base, 2) == base * base\n{\n  assert Power(base, 2) == base * Power(base, 1);\n  assert Power(base, 1) == base;\n}\n\nlemma PowerAddition(base: nat, exp1: nat, exp2: nat)\n  ensures Power(base, exp1 + exp2) == Power(base, exp1) * Power(base, exp2)\n  decreases exp1\n{\n  if exp1 == 0 {\n    assert Power(base, 0) == 1;\n  } else {\n    PowerAddition(base, exp1 - 1, exp2);\n    assert Power(base, exp1 + exp2) == base * Power(base, exp1 - 1 + exp2);\n    assert Power(base, exp1) == base * Power(base, exp1 - 1);\n  }\n}\n\nlemma SumFormula(n: nat)\n  ensures sumToN(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    assert sumToN(0) == 0;\n  } else {\n    SumFormula(n - 1);\n    assert sumToN(n - 1) == (n - 1) * n / 2;\n    assert sumToN(n) == n + sumToN(n - 1);\n    \n/*[CODE HERE]*/\n    assert sumToN(n) == (2 * n + (n - 1) * n) / 2;\n    assert sumToN(n) == (2 * n + n * n - n) / 2;\n    assert sumToN(n) == (n + n * n) / 2;\n    assert sumToN(n) == n * (1 + n) / 2;\n  }\n}\n\nlemma FactorialPositive(n: nat)\n  ensures fact(n) > 0\n{\n  if n == 0 {\n    assert fact(0) == 1;\n  } else {\n    FactorialPositive(n - 1);\n  }\n}\n\nlemma FibonacciMonotonic(n: nat)\n  requires n > 0\n  ensures fib(n) <= fib(n + 1)\n{\n  if n == 1 {\n    assert fib(1) == 1;\n    assert fib(2) == 1;\n  } else {\n    assert fib(n + 1) == fib(n) + fib(n - 1);\n    if n > 1 {\n      assert fib(n - 1) >= 0;\n    }\n  }\n}\n\nlemma BinomialSymmetry(n: nat, k: nat)\n  requires k <= n\n  ensures binomial(n, k) == binomial(n, n - k)\n{\n  assert fact(k) * fact(n - k) == fact(n - k) * fact(k);\n}", "output": "assert sumToN(n) == n + (n - 1) * n / 2;"}, {"id": "example_SumFormula_5", "type": "assert", "program": "// Mathematical operations: GCD, LCM, primes, modular arithmetic\n\n// Absolute value\nfunction {:spec} abs(x: int): nat\n{\n  if x < 0 then -x else x\n}\n\n// Greatest Common Divisor using Euclidean algorithm\nfunction {:spec} gcd(a: nat, b: nat): nat\n  decreases b\n{\n  if b == 0 then a\n  else gcd(b, a % b)\n}\n\n// Least Common Multiple\nfunction {:spec} lcm(a: nat, b: nat): nat\n  requires a > 0 && b > 0\n{\n  var g := gcd(a, b);\n  assert g > 0 by { GcdPositive(a, b); }\n  a / g * b  // Reordered to avoid overflow and ensure positive\n}\n\n// Check if a number divides another\npredicate {:spec} divides(d: nat, n: nat)\n  requires d > 0\n{\n  n % d == 0\n}\n\n// Check if a number is prime\npredicate {:spec} isPrime(n: nat)\n{\n  n > 1 && forall d :: 2 <= d < n ==> !divides(d, n)\n}\n\n// Check if two numbers are coprime (relatively prime)\npredicate {:spec} coprime(a: nat, b: nat)\n  requires a > 0 && b > 0\n{\n  gcd(a, b) == 1\n}\n\n// Modular exponentiation: (base^exp) mod m\nfunction {:spec} modPow(base: nat, exp: nat, m: nat): nat\n  requires m > 0\n  decreases exp\n{\n  if exp == 0 then 1 % m\n  else if exp % 2 == 0 then\n    var half := modPow(base, exp / 2, m);\n    (half * half) % m\n  else\n    ((base % m) * modPow(base, exp - 1, m)) % m\n}\n\n// Fibonacci function\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// Factorial function\nfunction {:spec} fact(n: nat): nat\n{\n  if n == 0 then 1\n  else n * fact(n - 1)\n}\n\n// Binomial coefficient (n choose k)\nfunction {:spec} binomial(n: nat, k: nat): nat\n  requires k <= n\n{\n  var denominator := fact(k) * fact(n - k);\n  if denominator == 0 then 0  // Can't happen but helps verifier\n  else fact(n) / denominator\n}\n\n// Sum of first n natural numbers\nfunction {:spec} sumToN(n: nat): nat\n{\n  if n == 0 then 0\n  else n + sumToN(n - 1)\n}\n\n// Check if a number is perfect (sum of divisors equals the number)\npredicate {:spec} isPerfect(n: nat)\n  requires n > 0\n{\n  sumOfDivisors(n) == 2 * n  // Including n itself\n}\n\nfunction {:spec} sumOfDivisors(n: nat): nat\n  requires n > 0\n{\n  sumOfDivisorsHelper(n, n)\n}\n\nfunction sumOfDivisorsHelper(n: nat, d: nat): nat\n  requires n > 0\n  requires d > 0\n  decreases d\n{\n  if d == 1 then 1\n  else if divides(d, n) then d + sumOfDivisorsHelper(n, d - 1)\n  else sumOfDivisorsHelper(n, d - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma GcdZero(a: nat)\n  ensures gcd(a, 0) == a\n{\n  // Automatic by definition\n}\n\nlemma GcdPositive(a: nat, b: nat)\n  requires a > 0 || b > 0\n  ensures gcd(a, b) > 0\n  decreases b\n{\n  if b == 0 {\n    assert gcd(a, b) == a;\n    assert a > 0;\n  } else {\n    GcdPositive(b, a % b);\n  }\n}\n\nlemma GcdDividesBoth(a: nat, b: nat)\n  requires a > 0 && b > 0\n  ensures gcd(a, b) > 0\n{\n  GcdPositive(a, b);\n}\n\nlemma PrimeHasOnlyTwoDivisors(n: nat)\n  requires isPrime(n)\n  ensures divides(1, n) && divides(n, n)\n  ensures forall d: nat :: d > 0 && d < n && d != 1 ==> !divides(d, n)\n{\n  assert divides(1, n);\n  assert divides(n, n);\n  forall d: nat | d > 0 && d < n && d != 1\n    ensures !divides(d, n)\n  {\n    if d >= 2 {\n      assert 2 <= d < n;\n      // By definition of isPrime\n    }\n  }\n}\n\nlemma TwoPrime()\n  ensures isPrime(2)\n{\n  assert forall d :: 2 <= d < 2 ==> !divides(d, 2);\n}\n\nlemma ThreePrime()\n  ensures isPrime(3)\n{\n  assert !divides(2, 3);\n}\n\nfunction Power(base: nat, exp: nat): nat\n  decreases exp\n{\n  if exp == 0 then 1\n  else base * Power(base, exp - 1)\n}\n\nlemma PowerSquare(base: nat)\n  ensures Power(base, 2) == base * base\n{\n  assert Power(base, 2) == base * Power(base, 1);\n  assert Power(base, 1) == base;\n}\n\nlemma PowerAddition(base: nat, exp1: nat, exp2: nat)\n  ensures Power(base, exp1 + exp2) == Power(base, exp1) * Power(base, exp2)\n  decreases exp1\n{\n  if exp1 == 0 {\n    assert Power(base, 0) == 1;\n  } else {\n    PowerAddition(base, exp1 - 1, exp2);\n    assert Power(base, exp1 + exp2) == base * Power(base, exp1 - 1 + exp2);\n    assert Power(base, exp1) == base * Power(base, exp1 - 1);\n  }\n}\n\nlemma SumFormula(n: nat)\n  ensures sumToN(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    assert sumToN(0) == 0;\n  } else {\n    SumFormula(n - 1);\n    assert sumToN(n - 1) == (n - 1) * n / 2;\n    \n/*[CODE HERE]*/\n    assert sumToN(n) == n + (n - 1) * n / 2;\n    assert sumToN(n) == (2 * n + (n - 1) * n) / 2;\n    assert sumToN(n) == (2 * n + n * n - n) / 2;\n    assert sumToN(n) == (n + n * n) / 2;\n    assert sumToN(n) == n * (1 + n) / 2;\n  }\n}\n\nlemma FactorialPositive(n: nat)\n  ensures fact(n) > 0\n{\n  if n == 0 {\n    assert fact(0) == 1;\n  } else {\n    FactorialPositive(n - 1);\n  }\n}\n\nlemma FibonacciMonotonic(n: nat)\n  requires n > 0\n  ensures fib(n) <= fib(n + 1)\n{\n  if n == 1 {\n    assert fib(1) == 1;\n    assert fib(2) == 1;\n  } else {\n    assert fib(n + 1) == fib(n) + fib(n - 1);\n    if n > 1 {\n      assert fib(n - 1) >= 0;\n    }\n  }\n}\n\nlemma BinomialSymmetry(n: nat, k: nat)\n  requires k <= n\n  ensures binomial(n, k) == binomial(n, n - k)\n{\n  assert fact(k) * fact(n - k) == fact(n - k) * fact(k);\n}", "output": "assert sumToN(n) == n + sumToN(n - 1);"}, {"id": "example_SumFormula_6", "type": "assert", "program": "// Mathematical operations: GCD, LCM, primes, modular arithmetic\n\n// Absolute value\nfunction {:spec} abs(x: int): nat\n{\n  if x < 0 then -x else x\n}\n\n// Greatest Common Divisor using Euclidean algorithm\nfunction {:spec} gcd(a: nat, b: nat): nat\n  decreases b\n{\n  if b == 0 then a\n  else gcd(b, a % b)\n}\n\n// Least Common Multiple\nfunction {:spec} lcm(a: nat, b: nat): nat\n  requires a > 0 && b > 0\n{\n  var g := gcd(a, b);\n  assert g > 0 by { GcdPositive(a, b); }\n  a / g * b  // Reordered to avoid overflow and ensure positive\n}\n\n// Check if a number divides another\npredicate {:spec} divides(d: nat, n: nat)\n  requires d > 0\n{\n  n % d == 0\n}\n\n// Check if a number is prime\npredicate {:spec} isPrime(n: nat)\n{\n  n > 1 && forall d :: 2 <= d < n ==> !divides(d, n)\n}\n\n// Check if two numbers are coprime (relatively prime)\npredicate {:spec} coprime(a: nat, b: nat)\n  requires a > 0 && b > 0\n{\n  gcd(a, b) == 1\n}\n\n// Modular exponentiation: (base^exp) mod m\nfunction {:spec} modPow(base: nat, exp: nat, m: nat): nat\n  requires m > 0\n  decreases exp\n{\n  if exp == 0 then 1 % m\n  else if exp % 2 == 0 then\n    var half := modPow(base, exp / 2, m);\n    (half * half) % m\n  else\n    ((base % m) * modPow(base, exp - 1, m)) % m\n}\n\n// Fibonacci function\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// Factorial function\nfunction {:spec} fact(n: nat): nat\n{\n  if n == 0 then 1\n  else n * fact(n - 1)\n}\n\n// Binomial coefficient (n choose k)\nfunction {:spec} binomial(n: nat, k: nat): nat\n  requires k <= n\n{\n  var denominator := fact(k) * fact(n - k);\n  if denominator == 0 then 0  // Can't happen but helps verifier\n  else fact(n) / denominator\n}\n\n// Sum of first n natural numbers\nfunction {:spec} sumToN(n: nat): nat\n{\n  if n == 0 then 0\n  else n + sumToN(n - 1)\n}\n\n// Check if a number is perfect (sum of divisors equals the number)\npredicate {:spec} isPerfect(n: nat)\n  requires n > 0\n{\n  sumOfDivisors(n) == 2 * n  // Including n itself\n}\n\nfunction {:spec} sumOfDivisors(n: nat): nat\n  requires n > 0\n{\n  sumOfDivisorsHelper(n, n)\n}\n\nfunction sumOfDivisorsHelper(n: nat, d: nat): nat\n  requires n > 0\n  requires d > 0\n  decreases d\n{\n  if d == 1 then 1\n  else if divides(d, n) then d + sumOfDivisorsHelper(n, d - 1)\n  else sumOfDivisorsHelper(n, d - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma GcdZero(a: nat)\n  ensures gcd(a, 0) == a\n{\n  // Automatic by definition\n}\n\nlemma GcdPositive(a: nat, b: nat)\n  requires a > 0 || b > 0\n  ensures gcd(a, b) > 0\n  decreases b\n{\n  if b == 0 {\n    assert gcd(a, b) == a;\n    assert a > 0;\n  } else {\n    GcdPositive(b, a % b);\n  }\n}\n\nlemma GcdDividesBoth(a: nat, b: nat)\n  requires a > 0 && b > 0\n  ensures gcd(a, b) > 0\n{\n  GcdPositive(a, b);\n}\n\nlemma PrimeHasOnlyTwoDivisors(n: nat)\n  requires isPrime(n)\n  ensures divides(1, n) && divides(n, n)\n  ensures forall d: nat :: d > 0 && d < n && d != 1 ==> !divides(d, n)\n{\n  assert divides(1, n);\n  assert divides(n, n);\n  forall d: nat | d > 0 && d < n && d != 1\n    ensures !divides(d, n)\n  {\n    if d >= 2 {\n      assert 2 <= d < n;\n      // By definition of isPrime\n    }\n  }\n}\n\nlemma TwoPrime()\n  ensures isPrime(2)\n{\n  assert forall d :: 2 <= d < 2 ==> !divides(d, 2);\n}\n\nlemma ThreePrime()\n  ensures isPrime(3)\n{\n  assert !divides(2, 3);\n}\n\nfunction Power(base: nat, exp: nat): nat\n  decreases exp\n{\n  if exp == 0 then 1\n  else base * Power(base, exp - 1)\n}\n\nlemma PowerSquare(base: nat)\n  ensures Power(base, 2) == base * base\n{\n  assert Power(base, 2) == base * Power(base, 1);\n  assert Power(base, 1) == base;\n}\n\nlemma PowerAddition(base: nat, exp1: nat, exp2: nat)\n  ensures Power(base, exp1 + exp2) == Power(base, exp1) * Power(base, exp2)\n  decreases exp1\n{\n  if exp1 == 0 {\n    assert Power(base, 0) == 1;\n  } else {\n    PowerAddition(base, exp1 - 1, exp2);\n    assert Power(base, exp1 + exp2) == base * Power(base, exp1 - 1 + exp2);\n    assert Power(base, exp1) == base * Power(base, exp1 - 1);\n  }\n}\n\nlemma SumFormula(n: nat)\n  ensures sumToN(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    assert sumToN(0) == 0;\n  } else {\n    SumFormula(n - 1);\n    \n/*[CODE HERE]*/\n    assert sumToN(n) == n + sumToN(n - 1);\n    assert sumToN(n) == n + (n - 1) * n / 2;\n    assert sumToN(n) == (2 * n + (n - 1) * n) / 2;\n    assert sumToN(n) == (2 * n + n * n - n) / 2;\n    assert sumToN(n) == (n + n * n) / 2;\n    assert sumToN(n) == n * (1 + n) / 2;\n  }\n}\n\nlemma FactorialPositive(n: nat)\n  ensures fact(n) > 0\n{\n  if n == 0 {\n    assert fact(0) == 1;\n  } else {\n    FactorialPositive(n - 1);\n  }\n}\n\nlemma FibonacciMonotonic(n: nat)\n  requires n > 0\n  ensures fib(n) <= fib(n + 1)\n{\n  if n == 1 {\n    assert fib(1) == 1;\n    assert fib(2) == 1;\n  } else {\n    assert fib(n + 1) == fib(n) + fib(n - 1);\n    if n > 1 {\n      assert fib(n - 1) >= 0;\n    }\n  }\n}\n\nlemma BinomialSymmetry(n: nat, k: nat)\n  requires k <= n\n  ensures binomial(n, k) == binomial(n, n - k)\n{\n  assert fact(k) * fact(n - k) == fact(n - k) * fact(k);\n}", "output": "assert sumToN(n - 1) == (n - 1) * n / 2;"}, {"id": "example_SumFormula_7", "type": "call", "program": "// Mathematical operations: GCD, LCM, primes, modular arithmetic\n\n// Absolute value\nfunction {:spec} abs(x: int): nat\n{\n  if x < 0 then -x else x\n}\n\n// Greatest Common Divisor using Euclidean algorithm\nfunction {:spec} gcd(a: nat, b: nat): nat\n  decreases b\n{\n  if b == 0 then a\n  else gcd(b, a % b)\n}\n\n// Least Common Multiple\nfunction {:spec} lcm(a: nat, b: nat): nat\n  requires a > 0 && b > 0\n{\n  var g := gcd(a, b);\n  assert g > 0 by { GcdPositive(a, b); }\n  a / g * b  // Reordered to avoid overflow and ensure positive\n}\n\n// Check if a number divides another\npredicate {:spec} divides(d: nat, n: nat)\n  requires d > 0\n{\n  n % d == 0\n}\n\n// Check if a number is prime\npredicate {:spec} isPrime(n: nat)\n{\n  n > 1 && forall d :: 2 <= d < n ==> !divides(d, n)\n}\n\n// Check if two numbers are coprime (relatively prime)\npredicate {:spec} coprime(a: nat, b: nat)\n  requires a > 0 && b > 0\n{\n  gcd(a, b) == 1\n}\n\n// Modular exponentiation: (base^exp) mod m\nfunction {:spec} modPow(base: nat, exp: nat, m: nat): nat\n  requires m > 0\n  decreases exp\n{\n  if exp == 0 then 1 % m\n  else if exp % 2 == 0 then\n    var half := modPow(base, exp / 2, m);\n    (half * half) % m\n  else\n    ((base % m) * modPow(base, exp - 1, m)) % m\n}\n\n// Fibonacci function\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// Factorial function\nfunction {:spec} fact(n: nat): nat\n{\n  if n == 0 then 1\n  else n * fact(n - 1)\n}\n\n// Binomial coefficient (n choose k)\nfunction {:spec} binomial(n: nat, k: nat): nat\n  requires k <= n\n{\n  var denominator := fact(k) * fact(n - k);\n  if denominator == 0 then 0  // Can't happen but helps verifier\n  else fact(n) / denominator\n}\n\n// Sum of first n natural numbers\nfunction {:spec} sumToN(n: nat): nat\n{\n  if n == 0 then 0\n  else n + sumToN(n - 1)\n}\n\n// Check if a number is perfect (sum of divisors equals the number)\npredicate {:spec} isPerfect(n: nat)\n  requires n > 0\n{\n  sumOfDivisors(n) == 2 * n  // Including n itself\n}\n\nfunction {:spec} sumOfDivisors(n: nat): nat\n  requires n > 0\n{\n  sumOfDivisorsHelper(n, n)\n}\n\nfunction sumOfDivisorsHelper(n: nat, d: nat): nat\n  requires n > 0\n  requires d > 0\n  decreases d\n{\n  if d == 1 then 1\n  else if divides(d, n) then d + sumOfDivisorsHelper(n, d - 1)\n  else sumOfDivisorsHelper(n, d - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma GcdZero(a: nat)\n  ensures gcd(a, 0) == a\n{\n  // Automatic by definition\n}\n\nlemma GcdPositive(a: nat, b: nat)\n  requires a > 0 || b > 0\n  ensures gcd(a, b) > 0\n  decreases b\n{\n  if b == 0 {\n    assert gcd(a, b) == a;\n    assert a > 0;\n  } else {\n    GcdPositive(b, a % b);\n  }\n}\n\nlemma GcdDividesBoth(a: nat, b: nat)\n  requires a > 0 && b > 0\n  ensures gcd(a, b) > 0\n{\n  GcdPositive(a, b);\n}\n\nlemma PrimeHasOnlyTwoDivisors(n: nat)\n  requires isPrime(n)\n  ensures divides(1, n) && divides(n, n)\n  ensures forall d: nat :: d > 0 && d < n && d != 1 ==> !divides(d, n)\n{\n  assert divides(1, n);\n  assert divides(n, n);\n  forall d: nat | d > 0 && d < n && d != 1\n    ensures !divides(d, n)\n  {\n    if d >= 2 {\n      assert 2 <= d < n;\n      // By definition of isPrime\n    }\n  }\n}\n\nlemma TwoPrime()\n  ensures isPrime(2)\n{\n  assert forall d :: 2 <= d < 2 ==> !divides(d, 2);\n}\n\nlemma ThreePrime()\n  ensures isPrime(3)\n{\n  assert !divides(2, 3);\n}\n\nfunction Power(base: nat, exp: nat): nat\n  decreases exp\n{\n  if exp == 0 then 1\n  else base * Power(base, exp - 1)\n}\n\nlemma PowerSquare(base: nat)\n  ensures Power(base, 2) == base * base\n{\n  assert Power(base, 2) == base * Power(base, 1);\n  assert Power(base, 1) == base;\n}\n\nlemma PowerAddition(base: nat, exp1: nat, exp2: nat)\n  ensures Power(base, exp1 + exp2) == Power(base, exp1) * Power(base, exp2)\n  decreases exp1\n{\n  if exp1 == 0 {\n    assert Power(base, 0) == 1;\n  } else {\n    PowerAddition(base, exp1 - 1, exp2);\n    assert Power(base, exp1 + exp2) == base * Power(base, exp1 - 1 + exp2);\n    assert Power(base, exp1) == base * Power(base, exp1 - 1);\n  }\n}\n\nlemma SumFormula(n: nat)\n  ensures sumToN(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    assert sumToN(0) == 0;\n  } else {\n    \n/*[CODE HERE]*/\n    assert sumToN(n - 1) == (n - 1) * n / 2;\n    assert sumToN(n) == n + sumToN(n - 1);\n    assert sumToN(n) == n + (n - 1) * n / 2;\n    assert sumToN(n) == (2 * n + (n - 1) * n) / 2;\n    assert sumToN(n) == (2 * n + n * n - n) / 2;\n    assert sumToN(n) == (n + n * n) / 2;\n    assert sumToN(n) == n * (1 + n) / 2;\n  }\n}\n\nlemma FactorialPositive(n: nat)\n  ensures fact(n) > 0\n{\n  if n == 0 {\n    assert fact(0) == 1;\n  } else {\n    FactorialPositive(n - 1);\n  }\n}\n\nlemma FibonacciMonotonic(n: nat)\n  requires n > 0\n  ensures fib(n) <= fib(n + 1)\n{\n  if n == 1 {\n    assert fib(1) == 1;\n    assert fib(2) == 1;\n  } else {\n    assert fib(n + 1) == fib(n) + fib(n - 1);\n    if n > 1 {\n      assert fib(n - 1) >= 0;\n    }\n  }\n}\n\nlemma BinomialSymmetry(n: nat, k: nat)\n  requires k <= n\n  ensures binomial(n, k) == binomial(n, n - k)\n{\n  assert fact(k) * fact(n - k) == fact(n - k) * fact(k);\n}", "output": "SumFormula(n - 1);"}, {"id": "example_SumFormula_8", "type": "assert", "program": "// Mathematical operations: GCD, LCM, primes, modular arithmetic\n\n// Absolute value\nfunction {:spec} abs(x: int): nat\n{\n  if x < 0 then -x else x\n}\n\n// Greatest Common Divisor using Euclidean algorithm\nfunction {:spec} gcd(a: nat, b: nat): nat\n  decreases b\n{\n  if b == 0 then a\n  else gcd(b, a % b)\n}\n\n// Least Common Multiple\nfunction {:spec} lcm(a: nat, b: nat): nat\n  requires a > 0 && b > 0\n{\n  var g := gcd(a, b);\n  assert g > 0 by { GcdPositive(a, b); }\n  a / g * b  // Reordered to avoid overflow and ensure positive\n}\n\n// Check if a number divides another\npredicate {:spec} divides(d: nat, n: nat)\n  requires d > 0\n{\n  n % d == 0\n}\n\n// Check if a number is prime\npredicate {:spec} isPrime(n: nat)\n{\n  n > 1 && forall d :: 2 <= d < n ==> !divides(d, n)\n}\n\n// Check if two numbers are coprime (relatively prime)\npredicate {:spec} coprime(a: nat, b: nat)\n  requires a > 0 && b > 0\n{\n  gcd(a, b) == 1\n}\n\n// Modular exponentiation: (base^exp) mod m\nfunction {:spec} modPow(base: nat, exp: nat, m: nat): nat\n  requires m > 0\n  decreases exp\n{\n  if exp == 0 then 1 % m\n  else if exp % 2 == 0 then\n    var half := modPow(base, exp / 2, m);\n    (half * half) % m\n  else\n    ((base % m) * modPow(base, exp - 1, m)) % m\n}\n\n// Fibonacci function\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// Factorial function\nfunction {:spec} fact(n: nat): nat\n{\n  if n == 0 then 1\n  else n * fact(n - 1)\n}\n\n// Binomial coefficient (n choose k)\nfunction {:spec} binomial(n: nat, k: nat): nat\n  requires k <= n\n{\n  var denominator := fact(k) * fact(n - k);\n  if denominator == 0 then 0  // Can't happen but helps verifier\n  else fact(n) / denominator\n}\n\n// Sum of first n natural numbers\nfunction {:spec} sumToN(n: nat): nat\n{\n  if n == 0 then 0\n  else n + sumToN(n - 1)\n}\n\n// Check if a number is perfect (sum of divisors equals the number)\npredicate {:spec} isPerfect(n: nat)\n  requires n > 0\n{\n  sumOfDivisors(n) == 2 * n  // Including n itself\n}\n\nfunction {:spec} sumOfDivisors(n: nat): nat\n  requires n > 0\n{\n  sumOfDivisorsHelper(n, n)\n}\n\nfunction sumOfDivisorsHelper(n: nat, d: nat): nat\n  requires n > 0\n  requires d > 0\n  decreases d\n{\n  if d == 1 then 1\n  else if divides(d, n) then d + sumOfDivisorsHelper(n, d - 1)\n  else sumOfDivisorsHelper(n, d - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma GcdZero(a: nat)\n  ensures gcd(a, 0) == a\n{\n  // Automatic by definition\n}\n\nlemma GcdPositive(a: nat, b: nat)\n  requires a > 0 || b > 0\n  ensures gcd(a, b) > 0\n  decreases b\n{\n  if b == 0 {\n    assert gcd(a, b) == a;\n    assert a > 0;\n  } else {\n    GcdPositive(b, a % b);\n  }\n}\n\nlemma GcdDividesBoth(a: nat, b: nat)\n  requires a > 0 && b > 0\n  ensures gcd(a, b) > 0\n{\n  GcdPositive(a, b);\n}\n\nlemma PrimeHasOnlyTwoDivisors(n: nat)\n  requires isPrime(n)\n  ensures divides(1, n) && divides(n, n)\n  ensures forall d: nat :: d > 0 && d < n && d != 1 ==> !divides(d, n)\n{\n  assert divides(1, n);\n  assert divides(n, n);\n  forall d: nat | d > 0 && d < n && d != 1\n    ensures !divides(d, n)\n  {\n    if d >= 2 {\n      assert 2 <= d < n;\n      // By definition of isPrime\n    }\n  }\n}\n\nlemma TwoPrime()\n  ensures isPrime(2)\n{\n  assert forall d :: 2 <= d < 2 ==> !divides(d, 2);\n}\n\nlemma ThreePrime()\n  ensures isPrime(3)\n{\n  assert !divides(2, 3);\n}\n\nfunction Power(base: nat, exp: nat): nat\n  decreases exp\n{\n  if exp == 0 then 1\n  else base * Power(base, exp - 1)\n}\n\nlemma PowerSquare(base: nat)\n  ensures Power(base, 2) == base * base\n{\n  assert Power(base, 2) == base * Power(base, 1);\n  assert Power(base, 1) == base;\n}\n\nlemma PowerAddition(base: nat, exp1: nat, exp2: nat)\n  ensures Power(base, exp1 + exp2) == Power(base, exp1) * Power(base, exp2)\n  decreases exp1\n{\n  if exp1 == 0 {\n    assert Power(base, 0) == 1;\n  } else {\n    PowerAddition(base, exp1 - 1, exp2);\n    assert Power(base, exp1 + exp2) == base * Power(base, exp1 - 1 + exp2);\n    assert Power(base, exp1) == base * Power(base, exp1 - 1);\n  }\n}\n\nlemma SumFormula(n: nat)\n  ensures sumToN(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    \n/*[CODE HERE]*/\n  } else {\n    SumFormula(n - 1);\n    assert sumToN(n - 1) == (n - 1) * n / 2;\n    assert sumToN(n) == n + sumToN(n - 1);\n    assert sumToN(n) == n + (n - 1) * n / 2;\n    assert sumToN(n) == (2 * n + (n - 1) * n) / 2;\n    assert sumToN(n) == (2 * n + n * n - n) / 2;\n    assert sumToN(n) == (n + n * n) / 2;\n    assert sumToN(n) == n * (1 + n) / 2;\n  }\n}\n\nlemma FactorialPositive(n: nat)\n  ensures fact(n) > 0\n{\n  if n == 0 {\n    assert fact(0) == 1;\n  } else {\n    FactorialPositive(n - 1);\n  }\n}\n\nlemma FibonacciMonotonic(n: nat)\n  requires n > 0\n  ensures fib(n) <= fib(n + 1)\n{\n  if n == 1 {\n    assert fib(1) == 1;\n    assert fib(2) == 1;\n  } else {\n    assert fib(n + 1) == fib(n) + fib(n - 1);\n    if n > 1 {\n      assert fib(n - 1) >= 0;\n    }\n  }\n}\n\nlemma BinomialSymmetry(n: nat, k: nat)\n  requires k <= n\n  ensures binomial(n, k) == binomial(n, n - k)\n{\n  assert fact(k) * fact(n - k) == fact(n - k) * fact(k);\n}", "output": "assert sumToN(0) == 0;"}, {"id": "example_FactorialPositive_0", "type": "call", "program": "// Mathematical operations: GCD, LCM, primes, modular arithmetic\n\n// Absolute value\nfunction {:spec} abs(x: int): nat\n{\n  if x < 0 then -x else x\n}\n\n// Greatest Common Divisor using Euclidean algorithm\nfunction {:spec} gcd(a: nat, b: nat): nat\n  decreases b\n{\n  if b == 0 then a\n  else gcd(b, a % b)\n}\n\n// Least Common Multiple\nfunction {:spec} lcm(a: nat, b: nat): nat\n  requires a > 0 && b > 0\n{\n  var g := gcd(a, b);\n  assert g > 0 by { GcdPositive(a, b); }\n  a / g * b  // Reordered to avoid overflow and ensure positive\n}\n\n// Check if a number divides another\npredicate {:spec} divides(d: nat, n: nat)\n  requires d > 0\n{\n  n % d == 0\n}\n\n// Check if a number is prime\npredicate {:spec} isPrime(n: nat)\n{\n  n > 1 && forall d :: 2 <= d < n ==> !divides(d, n)\n}\n\n// Check if two numbers are coprime (relatively prime)\npredicate {:spec} coprime(a: nat, b: nat)\n  requires a > 0 && b > 0\n{\n  gcd(a, b) == 1\n}\n\n// Modular exponentiation: (base^exp) mod m\nfunction {:spec} modPow(base: nat, exp: nat, m: nat): nat\n  requires m > 0\n  decreases exp\n{\n  if exp == 0 then 1 % m\n  else if exp % 2 == 0 then\n    var half := modPow(base, exp / 2, m);\n    (half * half) % m\n  else\n    ((base % m) * modPow(base, exp - 1, m)) % m\n}\n\n// Fibonacci function\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// Factorial function\nfunction {:spec} fact(n: nat): nat\n{\n  if n == 0 then 1\n  else n * fact(n - 1)\n}\n\n// Binomial coefficient (n choose k)\nfunction {:spec} binomial(n: nat, k: nat): nat\n  requires k <= n\n{\n  var denominator := fact(k) * fact(n - k);\n  if denominator == 0 then 0  // Can't happen but helps verifier\n  else fact(n) / denominator\n}\n\n// Sum of first n natural numbers\nfunction {:spec} sumToN(n: nat): nat\n{\n  if n == 0 then 0\n  else n + sumToN(n - 1)\n}\n\n// Check if a number is perfect (sum of divisors equals the number)\npredicate {:spec} isPerfect(n: nat)\n  requires n > 0\n{\n  sumOfDivisors(n) == 2 * n  // Including n itself\n}\n\nfunction {:spec} sumOfDivisors(n: nat): nat\n  requires n > 0\n{\n  sumOfDivisorsHelper(n, n)\n}\n\nfunction sumOfDivisorsHelper(n: nat, d: nat): nat\n  requires n > 0\n  requires d > 0\n  decreases d\n{\n  if d == 1 then 1\n  else if divides(d, n) then d + sumOfDivisorsHelper(n, d - 1)\n  else sumOfDivisorsHelper(n, d - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma GcdZero(a: nat)\n  ensures gcd(a, 0) == a\n{\n  // Automatic by definition\n}\n\nlemma GcdPositive(a: nat, b: nat)\n  requires a > 0 || b > 0\n  ensures gcd(a, b) > 0\n  decreases b\n{\n  if b == 0 {\n    assert gcd(a, b) == a;\n    assert a > 0;\n  } else {\n    GcdPositive(b, a % b);\n  }\n}\n\nlemma GcdDividesBoth(a: nat, b: nat)\n  requires a > 0 && b > 0\n  ensures gcd(a, b) > 0\n{\n  GcdPositive(a, b);\n}\n\nlemma PrimeHasOnlyTwoDivisors(n: nat)\n  requires isPrime(n)\n  ensures divides(1, n) && divides(n, n)\n  ensures forall d: nat :: d > 0 && d < n && d != 1 ==> !divides(d, n)\n{\n  assert divides(1, n);\n  assert divides(n, n);\n  forall d: nat | d > 0 && d < n && d != 1\n    ensures !divides(d, n)\n  {\n    if d >= 2 {\n      assert 2 <= d < n;\n      // By definition of isPrime\n    }\n  }\n}\n\nlemma TwoPrime()\n  ensures isPrime(2)\n{\n  assert forall d :: 2 <= d < 2 ==> !divides(d, 2);\n}\n\nlemma ThreePrime()\n  ensures isPrime(3)\n{\n  assert !divides(2, 3);\n}\n\nfunction Power(base: nat, exp: nat): nat\n  decreases exp\n{\n  if exp == 0 then 1\n  else base * Power(base, exp - 1)\n}\n\nlemma PowerSquare(base: nat)\n  ensures Power(base, 2) == base * base\n{\n  assert Power(base, 2) == base * Power(base, 1);\n  assert Power(base, 1) == base;\n}\n\nlemma PowerAddition(base: nat, exp1: nat, exp2: nat)\n  ensures Power(base, exp1 + exp2) == Power(base, exp1) * Power(base, exp2)\n  decreases exp1\n{\n  if exp1 == 0 {\n    assert Power(base, 0) == 1;\n  } else {\n    PowerAddition(base, exp1 - 1, exp2);\n    assert Power(base, exp1 + exp2) == base * Power(base, exp1 - 1 + exp2);\n    assert Power(base, exp1) == base * Power(base, exp1 - 1);\n  }\n}\n\nlemma SumFormula(n: nat)\n  ensures sumToN(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    assert sumToN(0) == 0;\n  } else {\n    SumFormula(n - 1);\n    assert sumToN(n - 1) == (n - 1) * n / 2;\n    assert sumToN(n) == n + sumToN(n - 1);\n    assert sumToN(n) == n + (n - 1) * n / 2;\n    assert sumToN(n) == (2 * n + (n - 1) * n) / 2;\n    assert sumToN(n) == (2 * n + n * n - n) / 2;\n    assert sumToN(n) == (n + n * n) / 2;\n    assert sumToN(n) == n * (1 + n) / 2;\n  }\n}\n\nlemma FactorialPositive(n: nat)\n  ensures fact(n) > 0\n{\n  if n == 0 {\n    assert fact(0) == 1;\n  } else {\n    \n/*[CODE HERE]*/\n  }\n}\n\nlemma FibonacciMonotonic(n: nat)\n  requires n > 0\n  ensures fib(n) <= fib(n + 1)\n{\n  if n == 1 {\n    assert fib(1) == 1;\n    assert fib(2) == 1;\n  } else {\n    assert fib(n + 1) == fib(n) + fib(n - 1);\n    if n > 1 {\n      assert fib(n - 1) >= 0;\n    }\n  }\n}\n\nlemma BinomialSymmetry(n: nat, k: nat)\n  requires k <= n\n  ensures binomial(n, k) == binomial(n, n - k)\n{\n  assert fact(k) * fact(n - k) == fact(n - k) * fact(k);\n}", "output": "FactorialPositive(n - 1);"}, {"id": "example_FactorialPositive_1", "type": "assert", "program": "// Mathematical operations: GCD, LCM, primes, modular arithmetic\n\n// Absolute value\nfunction {:spec} abs(x: int): nat\n{\n  if x < 0 then -x else x\n}\n\n// Greatest Common Divisor using Euclidean algorithm\nfunction {:spec} gcd(a: nat, b: nat): nat\n  decreases b\n{\n  if b == 0 then a\n  else gcd(b, a % b)\n}\n\n// Least Common Multiple\nfunction {:spec} lcm(a: nat, b: nat): nat\n  requires a > 0 && b > 0\n{\n  var g := gcd(a, b);\n  assert g > 0 by { GcdPositive(a, b); }\n  a / g * b  // Reordered to avoid overflow and ensure positive\n}\n\n// Check if a number divides another\npredicate {:spec} divides(d: nat, n: nat)\n  requires d > 0\n{\n  n % d == 0\n}\n\n// Check if a number is prime\npredicate {:spec} isPrime(n: nat)\n{\n  n > 1 && forall d :: 2 <= d < n ==> !divides(d, n)\n}\n\n// Check if two numbers are coprime (relatively prime)\npredicate {:spec} coprime(a: nat, b: nat)\n  requires a > 0 && b > 0\n{\n  gcd(a, b) == 1\n}\n\n// Modular exponentiation: (base^exp) mod m\nfunction {:spec} modPow(base: nat, exp: nat, m: nat): nat\n  requires m > 0\n  decreases exp\n{\n  if exp == 0 then 1 % m\n  else if exp % 2 == 0 then\n    var half := modPow(base, exp / 2, m);\n    (half * half) % m\n  else\n    ((base % m) * modPow(base, exp - 1, m)) % m\n}\n\n// Fibonacci function\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// Factorial function\nfunction {:spec} fact(n: nat): nat\n{\n  if n == 0 then 1\n  else n * fact(n - 1)\n}\n\n// Binomial coefficient (n choose k)\nfunction {:spec} binomial(n: nat, k: nat): nat\n  requires k <= n\n{\n  var denominator := fact(k) * fact(n - k);\n  if denominator == 0 then 0  // Can't happen but helps verifier\n  else fact(n) / denominator\n}\n\n// Sum of first n natural numbers\nfunction {:spec} sumToN(n: nat): nat\n{\n  if n == 0 then 0\n  else n + sumToN(n - 1)\n}\n\n// Check if a number is perfect (sum of divisors equals the number)\npredicate {:spec} isPerfect(n: nat)\n  requires n > 0\n{\n  sumOfDivisors(n) == 2 * n  // Including n itself\n}\n\nfunction {:spec} sumOfDivisors(n: nat): nat\n  requires n > 0\n{\n  sumOfDivisorsHelper(n, n)\n}\n\nfunction sumOfDivisorsHelper(n: nat, d: nat): nat\n  requires n > 0\n  requires d > 0\n  decreases d\n{\n  if d == 1 then 1\n  else if divides(d, n) then d + sumOfDivisorsHelper(n, d - 1)\n  else sumOfDivisorsHelper(n, d - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma GcdZero(a: nat)\n  ensures gcd(a, 0) == a\n{\n  // Automatic by definition\n}\n\nlemma GcdPositive(a: nat, b: nat)\n  requires a > 0 || b > 0\n  ensures gcd(a, b) > 0\n  decreases b\n{\n  if b == 0 {\n    assert gcd(a, b) == a;\n    assert a > 0;\n  } else {\n    GcdPositive(b, a % b);\n  }\n}\n\nlemma GcdDividesBoth(a: nat, b: nat)\n  requires a > 0 && b > 0\n  ensures gcd(a, b) > 0\n{\n  GcdPositive(a, b);\n}\n\nlemma PrimeHasOnlyTwoDivisors(n: nat)\n  requires isPrime(n)\n  ensures divides(1, n) && divides(n, n)\n  ensures forall d: nat :: d > 0 && d < n && d != 1 ==> !divides(d, n)\n{\n  assert divides(1, n);\n  assert divides(n, n);\n  forall d: nat | d > 0 && d < n && d != 1\n    ensures !divides(d, n)\n  {\n    if d >= 2 {\n      assert 2 <= d < n;\n      // By definition of isPrime\n    }\n  }\n}\n\nlemma TwoPrime()\n  ensures isPrime(2)\n{\n  assert forall d :: 2 <= d < 2 ==> !divides(d, 2);\n}\n\nlemma ThreePrime()\n  ensures isPrime(3)\n{\n  assert !divides(2, 3);\n}\n\nfunction Power(base: nat, exp: nat): nat\n  decreases exp\n{\n  if exp == 0 then 1\n  else base * Power(base, exp - 1)\n}\n\nlemma PowerSquare(base: nat)\n  ensures Power(base, 2) == base * base\n{\n  assert Power(base, 2) == base * Power(base, 1);\n  assert Power(base, 1) == base;\n}\n\nlemma PowerAddition(base: nat, exp1: nat, exp2: nat)\n  ensures Power(base, exp1 + exp2) == Power(base, exp1) * Power(base, exp2)\n  decreases exp1\n{\n  if exp1 == 0 {\n    assert Power(base, 0) == 1;\n  } else {\n    PowerAddition(base, exp1 - 1, exp2);\n    assert Power(base, exp1 + exp2) == base * Power(base, exp1 - 1 + exp2);\n    assert Power(base, exp1) == base * Power(base, exp1 - 1);\n  }\n}\n\nlemma SumFormula(n: nat)\n  ensures sumToN(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    assert sumToN(0) == 0;\n  } else {\n    SumFormula(n - 1);\n    assert sumToN(n - 1) == (n - 1) * n / 2;\n    assert sumToN(n) == n + sumToN(n - 1);\n    assert sumToN(n) == n + (n - 1) * n / 2;\n    assert sumToN(n) == (2 * n + (n - 1) * n) / 2;\n    assert sumToN(n) == (2 * n + n * n - n) / 2;\n    assert sumToN(n) == (n + n * n) / 2;\n    assert sumToN(n) == n * (1 + n) / 2;\n  }\n}\n\nlemma FactorialPositive(n: nat)\n  ensures fact(n) > 0\n{\n  if n == 0 {\n    \n/*[CODE HERE]*/\n  } else {\n    FactorialPositive(n - 1);\n  }\n}\n\nlemma FibonacciMonotonic(n: nat)\n  requires n > 0\n  ensures fib(n) <= fib(n + 1)\n{\n  if n == 1 {\n    assert fib(1) == 1;\n    assert fib(2) == 1;\n  } else {\n    assert fib(n + 1) == fib(n) + fib(n - 1);\n    if n > 1 {\n      assert fib(n - 1) >= 0;\n    }\n  }\n}\n\nlemma BinomialSymmetry(n: nat, k: nat)\n  requires k <= n\n  ensures binomial(n, k) == binomial(n, n - k)\n{\n  assert fact(k) * fact(n - k) == fact(n - k) * fact(k);\n}", "output": "assert fact(0) == 1;"}, {"id": "example_FibonacciMonotonic_0", "type": "assert", "program": "// Mathematical operations: GCD, LCM, primes, modular arithmetic\n\n// Absolute value\nfunction {:spec} abs(x: int): nat\n{\n  if x < 0 then -x else x\n}\n\n// Greatest Common Divisor using Euclidean algorithm\nfunction {:spec} gcd(a: nat, b: nat): nat\n  decreases b\n{\n  if b == 0 then a\n  else gcd(b, a % b)\n}\n\n// Least Common Multiple\nfunction {:spec} lcm(a: nat, b: nat): nat\n  requires a > 0 && b > 0\n{\n  var g := gcd(a, b);\n  assert g > 0 by { GcdPositive(a, b); }\n  a / g * b  // Reordered to avoid overflow and ensure positive\n}\n\n// Check if a number divides another\npredicate {:spec} divides(d: nat, n: nat)\n  requires d > 0\n{\n  n % d == 0\n}\n\n// Check if a number is prime\npredicate {:spec} isPrime(n: nat)\n{\n  n > 1 && forall d :: 2 <= d < n ==> !divides(d, n)\n}\n\n// Check if two numbers are coprime (relatively prime)\npredicate {:spec} coprime(a: nat, b: nat)\n  requires a > 0 && b > 0\n{\n  gcd(a, b) == 1\n}\n\n// Modular exponentiation: (base^exp) mod m\nfunction {:spec} modPow(base: nat, exp: nat, m: nat): nat\n  requires m > 0\n  decreases exp\n{\n  if exp == 0 then 1 % m\n  else if exp % 2 == 0 then\n    var half := modPow(base, exp / 2, m);\n    (half * half) % m\n  else\n    ((base % m) * modPow(base, exp - 1, m)) % m\n}\n\n// Fibonacci function\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// Factorial function\nfunction {:spec} fact(n: nat): nat\n{\n  if n == 0 then 1\n  else n * fact(n - 1)\n}\n\n// Binomial coefficient (n choose k)\nfunction {:spec} binomial(n: nat, k: nat): nat\n  requires k <= n\n{\n  var denominator := fact(k) * fact(n - k);\n  if denominator == 0 then 0  // Can't happen but helps verifier\n  else fact(n) / denominator\n}\n\n// Sum of first n natural numbers\nfunction {:spec} sumToN(n: nat): nat\n{\n  if n == 0 then 0\n  else n + sumToN(n - 1)\n}\n\n// Check if a number is perfect (sum of divisors equals the number)\npredicate {:spec} isPerfect(n: nat)\n  requires n > 0\n{\n  sumOfDivisors(n) == 2 * n  // Including n itself\n}\n\nfunction {:spec} sumOfDivisors(n: nat): nat\n  requires n > 0\n{\n  sumOfDivisorsHelper(n, n)\n}\n\nfunction sumOfDivisorsHelper(n: nat, d: nat): nat\n  requires n > 0\n  requires d > 0\n  decreases d\n{\n  if d == 1 then 1\n  else if divides(d, n) then d + sumOfDivisorsHelper(n, d - 1)\n  else sumOfDivisorsHelper(n, d - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma GcdZero(a: nat)\n  ensures gcd(a, 0) == a\n{\n  // Automatic by definition\n}\n\nlemma GcdPositive(a: nat, b: nat)\n  requires a > 0 || b > 0\n  ensures gcd(a, b) > 0\n  decreases b\n{\n  if b == 0 {\n    assert gcd(a, b) == a;\n    assert a > 0;\n  } else {\n    GcdPositive(b, a % b);\n  }\n}\n\nlemma GcdDividesBoth(a: nat, b: nat)\n  requires a > 0 && b > 0\n  ensures gcd(a, b) > 0\n{\n  GcdPositive(a, b);\n}\n\nlemma PrimeHasOnlyTwoDivisors(n: nat)\n  requires isPrime(n)\n  ensures divides(1, n) && divides(n, n)\n  ensures forall d: nat :: d > 0 && d < n && d != 1 ==> !divides(d, n)\n{\n  assert divides(1, n);\n  assert divides(n, n);\n  forall d: nat | d > 0 && d < n && d != 1\n    ensures !divides(d, n)\n  {\n    if d >= 2 {\n      assert 2 <= d < n;\n      // By definition of isPrime\n    }\n  }\n}\n\nlemma TwoPrime()\n  ensures isPrime(2)\n{\n  assert forall d :: 2 <= d < 2 ==> !divides(d, 2);\n}\n\nlemma ThreePrime()\n  ensures isPrime(3)\n{\n  assert !divides(2, 3);\n}\n\nfunction Power(base: nat, exp: nat): nat\n  decreases exp\n{\n  if exp == 0 then 1\n  else base * Power(base, exp - 1)\n}\n\nlemma PowerSquare(base: nat)\n  ensures Power(base, 2) == base * base\n{\n  assert Power(base, 2) == base * Power(base, 1);\n  assert Power(base, 1) == base;\n}\n\nlemma PowerAddition(base: nat, exp1: nat, exp2: nat)\n  ensures Power(base, exp1 + exp2) == Power(base, exp1) * Power(base, exp2)\n  decreases exp1\n{\n  if exp1 == 0 {\n    assert Power(base, 0) == 1;\n  } else {\n    PowerAddition(base, exp1 - 1, exp2);\n    assert Power(base, exp1 + exp2) == base * Power(base, exp1 - 1 + exp2);\n    assert Power(base, exp1) == base * Power(base, exp1 - 1);\n  }\n}\n\nlemma SumFormula(n: nat)\n  ensures sumToN(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    assert sumToN(0) == 0;\n  } else {\n    SumFormula(n - 1);\n    assert sumToN(n - 1) == (n - 1) * n / 2;\n    assert sumToN(n) == n + sumToN(n - 1);\n    assert sumToN(n) == n + (n - 1) * n / 2;\n    assert sumToN(n) == (2 * n + (n - 1) * n) / 2;\n    assert sumToN(n) == (2 * n + n * n - n) / 2;\n    assert sumToN(n) == (n + n * n) / 2;\n    assert sumToN(n) == n * (1 + n) / 2;\n  }\n}\n\nlemma FactorialPositive(n: nat)\n  ensures fact(n) > 0\n{\n  if n == 0 {\n    assert fact(0) == 1;\n  } else {\n    FactorialPositive(n - 1);\n  }\n}\n\nlemma FibonacciMonotonic(n: nat)\n  requires n > 0\n  ensures fib(n) <= fib(n + 1)\n{\n  if n == 1 {\n    assert fib(1) == 1;\n    assert fib(2) == 1;\n  } else {\n    assert fib(n + 1) == fib(n) + fib(n - 1);\n    if n > 1 {\n      \n/*[CODE HERE]*/\n    }\n  }\n}\n\nlemma BinomialSymmetry(n: nat, k: nat)\n  requires k <= n\n  ensures binomial(n, k) == binomial(n, n - k)\n{\n  assert fact(k) * fact(n - k) == fact(n - k) * fact(k);\n}", "output": "assert fib(n - 1) >= 0;"}, {"id": "example_FibonacciMonotonic_1", "type": "assert", "program": "// Mathematical operations: GCD, LCM, primes, modular arithmetic\n\n// Absolute value\nfunction {:spec} abs(x: int): nat\n{\n  if x < 0 then -x else x\n}\n\n// Greatest Common Divisor using Euclidean algorithm\nfunction {:spec} gcd(a: nat, b: nat): nat\n  decreases b\n{\n  if b == 0 then a\n  else gcd(b, a % b)\n}\n\n// Least Common Multiple\nfunction {:spec} lcm(a: nat, b: nat): nat\n  requires a > 0 && b > 0\n{\n  var g := gcd(a, b);\n  assert g > 0 by { GcdPositive(a, b); }\n  a / g * b  // Reordered to avoid overflow and ensure positive\n}\n\n// Check if a number divides another\npredicate {:spec} divides(d: nat, n: nat)\n  requires d > 0\n{\n  n % d == 0\n}\n\n// Check if a number is prime\npredicate {:spec} isPrime(n: nat)\n{\n  n > 1 && forall d :: 2 <= d < n ==> !divides(d, n)\n}\n\n// Check if two numbers are coprime (relatively prime)\npredicate {:spec} coprime(a: nat, b: nat)\n  requires a > 0 && b > 0\n{\n  gcd(a, b) == 1\n}\n\n// Modular exponentiation: (base^exp) mod m\nfunction {:spec} modPow(base: nat, exp: nat, m: nat): nat\n  requires m > 0\n  decreases exp\n{\n  if exp == 0 then 1 % m\n  else if exp % 2 == 0 then\n    var half := modPow(base, exp / 2, m);\n    (half * half) % m\n  else\n    ((base % m) * modPow(base, exp - 1, m)) % m\n}\n\n// Fibonacci function\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// Factorial function\nfunction {:spec} fact(n: nat): nat\n{\n  if n == 0 then 1\n  else n * fact(n - 1)\n}\n\n// Binomial coefficient (n choose k)\nfunction {:spec} binomial(n: nat, k: nat): nat\n  requires k <= n\n{\n  var denominator := fact(k) * fact(n - k);\n  if denominator == 0 then 0  // Can't happen but helps verifier\n  else fact(n) / denominator\n}\n\n// Sum of first n natural numbers\nfunction {:spec} sumToN(n: nat): nat\n{\n  if n == 0 then 0\n  else n + sumToN(n - 1)\n}\n\n// Check if a number is perfect (sum of divisors equals the number)\npredicate {:spec} isPerfect(n: nat)\n  requires n > 0\n{\n  sumOfDivisors(n) == 2 * n  // Including n itself\n}\n\nfunction {:spec} sumOfDivisors(n: nat): nat\n  requires n > 0\n{\n  sumOfDivisorsHelper(n, n)\n}\n\nfunction sumOfDivisorsHelper(n: nat, d: nat): nat\n  requires n > 0\n  requires d > 0\n  decreases d\n{\n  if d == 1 then 1\n  else if divides(d, n) then d + sumOfDivisorsHelper(n, d - 1)\n  else sumOfDivisorsHelper(n, d - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma GcdZero(a: nat)\n  ensures gcd(a, 0) == a\n{\n  // Automatic by definition\n}\n\nlemma GcdPositive(a: nat, b: nat)\n  requires a > 0 || b > 0\n  ensures gcd(a, b) > 0\n  decreases b\n{\n  if b == 0 {\n    assert gcd(a, b) == a;\n    assert a > 0;\n  } else {\n    GcdPositive(b, a % b);\n  }\n}\n\nlemma GcdDividesBoth(a: nat, b: nat)\n  requires a > 0 && b > 0\n  ensures gcd(a, b) > 0\n{\n  GcdPositive(a, b);\n}\n\nlemma PrimeHasOnlyTwoDivisors(n: nat)\n  requires isPrime(n)\n  ensures divides(1, n) && divides(n, n)\n  ensures forall d: nat :: d > 0 && d < n && d != 1 ==> !divides(d, n)\n{\n  assert divides(1, n);\n  assert divides(n, n);\n  forall d: nat | d > 0 && d < n && d != 1\n    ensures !divides(d, n)\n  {\n    if d >= 2 {\n      assert 2 <= d < n;\n      // By definition of isPrime\n    }\n  }\n}\n\nlemma TwoPrime()\n  ensures isPrime(2)\n{\n  assert forall d :: 2 <= d < 2 ==> !divides(d, 2);\n}\n\nlemma ThreePrime()\n  ensures isPrime(3)\n{\n  assert !divides(2, 3);\n}\n\nfunction Power(base: nat, exp: nat): nat\n  decreases exp\n{\n  if exp == 0 then 1\n  else base * Power(base, exp - 1)\n}\n\nlemma PowerSquare(base: nat)\n  ensures Power(base, 2) == base * base\n{\n  assert Power(base, 2) == base * Power(base, 1);\n  assert Power(base, 1) == base;\n}\n\nlemma PowerAddition(base: nat, exp1: nat, exp2: nat)\n  ensures Power(base, exp1 + exp2) == Power(base, exp1) * Power(base, exp2)\n  decreases exp1\n{\n  if exp1 == 0 {\n    assert Power(base, 0) == 1;\n  } else {\n    PowerAddition(base, exp1 - 1, exp2);\n    assert Power(base, exp1 + exp2) == base * Power(base, exp1 - 1 + exp2);\n    assert Power(base, exp1) == base * Power(base, exp1 - 1);\n  }\n}\n\nlemma SumFormula(n: nat)\n  ensures sumToN(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    assert sumToN(0) == 0;\n  } else {\n    SumFormula(n - 1);\n    assert sumToN(n - 1) == (n - 1) * n / 2;\n    assert sumToN(n) == n + sumToN(n - 1);\n    assert sumToN(n) == n + (n - 1) * n / 2;\n    assert sumToN(n) == (2 * n + (n - 1) * n) / 2;\n    assert sumToN(n) == (2 * n + n * n - n) / 2;\n    assert sumToN(n) == (n + n * n) / 2;\n    assert sumToN(n) == n * (1 + n) / 2;\n  }\n}\n\nlemma FactorialPositive(n: nat)\n  ensures fact(n) > 0\n{\n  if n == 0 {\n    assert fact(0) == 1;\n  } else {\n    FactorialPositive(n - 1);\n  }\n}\n\nlemma FibonacciMonotonic(n: nat)\n  requires n > 0\n  ensures fib(n) <= fib(n + 1)\n{\n  if n == 1 {\n    assert fib(1) == 1;\n    assert fib(2) == 1;\n  } else {\n    \n/*[CODE HERE]*/\n    if n > 1 {\n      assert fib(n - 1) >= 0;\n    }\n  }\n}\n\nlemma BinomialSymmetry(n: nat, k: nat)\n  requires k <= n\n  ensures binomial(n, k) == binomial(n, n - k)\n{\n  assert fact(k) * fact(n - k) == fact(n - k) * fact(k);\n}", "output": "assert fib(n + 1) == fib(n) + fib(n - 1);"}, {"id": "example_FibonacciMonotonic_2", "type": "assert", "program": "// Mathematical operations: GCD, LCM, primes, modular arithmetic\n\n// Absolute value\nfunction {:spec} abs(x: int): nat\n{\n  if x < 0 then -x else x\n}\n\n// Greatest Common Divisor using Euclidean algorithm\nfunction {:spec} gcd(a: nat, b: nat): nat\n  decreases b\n{\n  if b == 0 then a\n  else gcd(b, a % b)\n}\n\n// Least Common Multiple\nfunction {:spec} lcm(a: nat, b: nat): nat\n  requires a > 0 && b > 0\n{\n  var g := gcd(a, b);\n  assert g > 0 by { GcdPositive(a, b); }\n  a / g * b  // Reordered to avoid overflow and ensure positive\n}\n\n// Check if a number divides another\npredicate {:spec} divides(d: nat, n: nat)\n  requires d > 0\n{\n  n % d == 0\n}\n\n// Check if a number is prime\npredicate {:spec} isPrime(n: nat)\n{\n  n > 1 && forall d :: 2 <= d < n ==> !divides(d, n)\n}\n\n// Check if two numbers are coprime (relatively prime)\npredicate {:spec} coprime(a: nat, b: nat)\n  requires a > 0 && b > 0\n{\n  gcd(a, b) == 1\n}\n\n// Modular exponentiation: (base^exp) mod m\nfunction {:spec} modPow(base: nat, exp: nat, m: nat): nat\n  requires m > 0\n  decreases exp\n{\n  if exp == 0 then 1 % m\n  else if exp % 2 == 0 then\n    var half := modPow(base, exp / 2, m);\n    (half * half) % m\n  else\n    ((base % m) * modPow(base, exp - 1, m)) % m\n}\n\n// Fibonacci function\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// Factorial function\nfunction {:spec} fact(n: nat): nat\n{\n  if n == 0 then 1\n  else n * fact(n - 1)\n}\n\n// Binomial coefficient (n choose k)\nfunction {:spec} binomial(n: nat, k: nat): nat\n  requires k <= n\n{\n  var denominator := fact(k) * fact(n - k);\n  if denominator == 0 then 0  // Can't happen but helps verifier\n  else fact(n) / denominator\n}\n\n// Sum of first n natural numbers\nfunction {:spec} sumToN(n: nat): nat\n{\n  if n == 0 then 0\n  else n + sumToN(n - 1)\n}\n\n// Check if a number is perfect (sum of divisors equals the number)\npredicate {:spec} isPerfect(n: nat)\n  requires n > 0\n{\n  sumOfDivisors(n) == 2 * n  // Including n itself\n}\n\nfunction {:spec} sumOfDivisors(n: nat): nat\n  requires n > 0\n{\n  sumOfDivisorsHelper(n, n)\n}\n\nfunction sumOfDivisorsHelper(n: nat, d: nat): nat\n  requires n > 0\n  requires d > 0\n  decreases d\n{\n  if d == 1 then 1\n  else if divides(d, n) then d + sumOfDivisorsHelper(n, d - 1)\n  else sumOfDivisorsHelper(n, d - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma GcdZero(a: nat)\n  ensures gcd(a, 0) == a\n{\n  // Automatic by definition\n}\n\nlemma GcdPositive(a: nat, b: nat)\n  requires a > 0 || b > 0\n  ensures gcd(a, b) > 0\n  decreases b\n{\n  if b == 0 {\n    assert gcd(a, b) == a;\n    assert a > 0;\n  } else {\n    GcdPositive(b, a % b);\n  }\n}\n\nlemma GcdDividesBoth(a: nat, b: nat)\n  requires a > 0 && b > 0\n  ensures gcd(a, b) > 0\n{\n  GcdPositive(a, b);\n}\n\nlemma PrimeHasOnlyTwoDivisors(n: nat)\n  requires isPrime(n)\n  ensures divides(1, n) && divides(n, n)\n  ensures forall d: nat :: d > 0 && d < n && d != 1 ==> !divides(d, n)\n{\n  assert divides(1, n);\n  assert divides(n, n);\n  forall d: nat | d > 0 && d < n && d != 1\n    ensures !divides(d, n)\n  {\n    if d >= 2 {\n      assert 2 <= d < n;\n      // By definition of isPrime\n    }\n  }\n}\n\nlemma TwoPrime()\n  ensures isPrime(2)\n{\n  assert forall d :: 2 <= d < 2 ==> !divides(d, 2);\n}\n\nlemma ThreePrime()\n  ensures isPrime(3)\n{\n  assert !divides(2, 3);\n}\n\nfunction Power(base: nat, exp: nat): nat\n  decreases exp\n{\n  if exp == 0 then 1\n  else base * Power(base, exp - 1)\n}\n\nlemma PowerSquare(base: nat)\n  ensures Power(base, 2) == base * base\n{\n  assert Power(base, 2) == base * Power(base, 1);\n  assert Power(base, 1) == base;\n}\n\nlemma PowerAddition(base: nat, exp1: nat, exp2: nat)\n  ensures Power(base, exp1 + exp2) == Power(base, exp1) * Power(base, exp2)\n  decreases exp1\n{\n  if exp1 == 0 {\n    assert Power(base, 0) == 1;\n  } else {\n    PowerAddition(base, exp1 - 1, exp2);\n    assert Power(base, exp1 + exp2) == base * Power(base, exp1 - 1 + exp2);\n    assert Power(base, exp1) == base * Power(base, exp1 - 1);\n  }\n}\n\nlemma SumFormula(n: nat)\n  ensures sumToN(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    assert sumToN(0) == 0;\n  } else {\n    SumFormula(n - 1);\n    assert sumToN(n - 1) == (n - 1) * n / 2;\n    assert sumToN(n) == n + sumToN(n - 1);\n    assert sumToN(n) == n + (n - 1) * n / 2;\n    assert sumToN(n) == (2 * n + (n - 1) * n) / 2;\n    assert sumToN(n) == (2 * n + n * n - n) / 2;\n    assert sumToN(n) == (n + n * n) / 2;\n    assert sumToN(n) == n * (1 + n) / 2;\n  }\n}\n\nlemma FactorialPositive(n: nat)\n  ensures fact(n) > 0\n{\n  if n == 0 {\n    assert fact(0) == 1;\n  } else {\n    FactorialPositive(n - 1);\n  }\n}\n\nlemma FibonacciMonotonic(n: nat)\n  requires n > 0\n  ensures fib(n) <= fib(n + 1)\n{\n  if n == 1 {\n    assert fib(1) == 1;\n    \n/*[CODE HERE]*/\n  } else {\n    assert fib(n + 1) == fib(n) + fib(n - 1);\n    if n > 1 {\n      assert fib(n - 1) >= 0;\n    }\n  }\n}\n\nlemma BinomialSymmetry(n: nat, k: nat)\n  requires k <= n\n  ensures binomial(n, k) == binomial(n, n - k)\n{\n  assert fact(k) * fact(n - k) == fact(n - k) * fact(k);\n}", "output": "assert fib(2) == 1;"}, {"id": "example_FibonacciMonotonic_3", "type": "assert", "program": "// Mathematical operations: GCD, LCM, primes, modular arithmetic\n\n// Absolute value\nfunction {:spec} abs(x: int): nat\n{\n  if x < 0 then -x else x\n}\n\n// Greatest Common Divisor using Euclidean algorithm\nfunction {:spec} gcd(a: nat, b: nat): nat\n  decreases b\n{\n  if b == 0 then a\n  else gcd(b, a % b)\n}\n\n// Least Common Multiple\nfunction {:spec} lcm(a: nat, b: nat): nat\n  requires a > 0 && b > 0\n{\n  var g := gcd(a, b);\n  assert g > 0 by { GcdPositive(a, b); }\n  a / g * b  // Reordered to avoid overflow and ensure positive\n}\n\n// Check if a number divides another\npredicate {:spec} divides(d: nat, n: nat)\n  requires d > 0\n{\n  n % d == 0\n}\n\n// Check if a number is prime\npredicate {:spec} isPrime(n: nat)\n{\n  n > 1 && forall d :: 2 <= d < n ==> !divides(d, n)\n}\n\n// Check if two numbers are coprime (relatively prime)\npredicate {:spec} coprime(a: nat, b: nat)\n  requires a > 0 && b > 0\n{\n  gcd(a, b) == 1\n}\n\n// Modular exponentiation: (base^exp) mod m\nfunction {:spec} modPow(base: nat, exp: nat, m: nat): nat\n  requires m > 0\n  decreases exp\n{\n  if exp == 0 then 1 % m\n  else if exp % 2 == 0 then\n    var half := modPow(base, exp / 2, m);\n    (half * half) % m\n  else\n    ((base % m) * modPow(base, exp - 1, m)) % m\n}\n\n// Fibonacci function\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// Factorial function\nfunction {:spec} fact(n: nat): nat\n{\n  if n == 0 then 1\n  else n * fact(n - 1)\n}\n\n// Binomial coefficient (n choose k)\nfunction {:spec} binomial(n: nat, k: nat): nat\n  requires k <= n\n{\n  var denominator := fact(k) * fact(n - k);\n  if denominator == 0 then 0  // Can't happen but helps verifier\n  else fact(n) / denominator\n}\n\n// Sum of first n natural numbers\nfunction {:spec} sumToN(n: nat): nat\n{\n  if n == 0 then 0\n  else n + sumToN(n - 1)\n}\n\n// Check if a number is perfect (sum of divisors equals the number)\npredicate {:spec} isPerfect(n: nat)\n  requires n > 0\n{\n  sumOfDivisors(n) == 2 * n  // Including n itself\n}\n\nfunction {:spec} sumOfDivisors(n: nat): nat\n  requires n > 0\n{\n  sumOfDivisorsHelper(n, n)\n}\n\nfunction sumOfDivisorsHelper(n: nat, d: nat): nat\n  requires n > 0\n  requires d > 0\n  decreases d\n{\n  if d == 1 then 1\n  else if divides(d, n) then d + sumOfDivisorsHelper(n, d - 1)\n  else sumOfDivisorsHelper(n, d - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma GcdZero(a: nat)\n  ensures gcd(a, 0) == a\n{\n  // Automatic by definition\n}\n\nlemma GcdPositive(a: nat, b: nat)\n  requires a > 0 || b > 0\n  ensures gcd(a, b) > 0\n  decreases b\n{\n  if b == 0 {\n    assert gcd(a, b) == a;\n    assert a > 0;\n  } else {\n    GcdPositive(b, a % b);\n  }\n}\n\nlemma GcdDividesBoth(a: nat, b: nat)\n  requires a > 0 && b > 0\n  ensures gcd(a, b) > 0\n{\n  GcdPositive(a, b);\n}\n\nlemma PrimeHasOnlyTwoDivisors(n: nat)\n  requires isPrime(n)\n  ensures divides(1, n) && divides(n, n)\n  ensures forall d: nat :: d > 0 && d < n && d != 1 ==> !divides(d, n)\n{\n  assert divides(1, n);\n  assert divides(n, n);\n  forall d: nat | d > 0 && d < n && d != 1\n    ensures !divides(d, n)\n  {\n    if d >= 2 {\n      assert 2 <= d < n;\n      // By definition of isPrime\n    }\n  }\n}\n\nlemma TwoPrime()\n  ensures isPrime(2)\n{\n  assert forall d :: 2 <= d < 2 ==> !divides(d, 2);\n}\n\nlemma ThreePrime()\n  ensures isPrime(3)\n{\n  assert !divides(2, 3);\n}\n\nfunction Power(base: nat, exp: nat): nat\n  decreases exp\n{\n  if exp == 0 then 1\n  else base * Power(base, exp - 1)\n}\n\nlemma PowerSquare(base: nat)\n  ensures Power(base, 2) == base * base\n{\n  assert Power(base, 2) == base * Power(base, 1);\n  assert Power(base, 1) == base;\n}\n\nlemma PowerAddition(base: nat, exp1: nat, exp2: nat)\n  ensures Power(base, exp1 + exp2) == Power(base, exp1) * Power(base, exp2)\n  decreases exp1\n{\n  if exp1 == 0 {\n    assert Power(base, 0) == 1;\n  } else {\n    PowerAddition(base, exp1 - 1, exp2);\n    assert Power(base, exp1 + exp2) == base * Power(base, exp1 - 1 + exp2);\n    assert Power(base, exp1) == base * Power(base, exp1 - 1);\n  }\n}\n\nlemma SumFormula(n: nat)\n  ensures sumToN(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    assert sumToN(0) == 0;\n  } else {\n    SumFormula(n - 1);\n    assert sumToN(n - 1) == (n - 1) * n / 2;\n    assert sumToN(n) == n + sumToN(n - 1);\n    assert sumToN(n) == n + (n - 1) * n / 2;\n    assert sumToN(n) == (2 * n + (n - 1) * n) / 2;\n    assert sumToN(n) == (2 * n + n * n - n) / 2;\n    assert sumToN(n) == (n + n * n) / 2;\n    assert sumToN(n) == n * (1 + n) / 2;\n  }\n}\n\nlemma FactorialPositive(n: nat)\n  ensures fact(n) > 0\n{\n  if n == 0 {\n    assert fact(0) == 1;\n  } else {\n    FactorialPositive(n - 1);\n  }\n}\n\nlemma FibonacciMonotonic(n: nat)\n  requires n > 0\n  ensures fib(n) <= fib(n + 1)\n{\n  if n == 1 {\n    \n/*[CODE HERE]*/\n    assert fib(2) == 1;\n  } else {\n    assert fib(n + 1) == fib(n) + fib(n - 1);\n    if n > 1 {\n      assert fib(n - 1) >= 0;\n    }\n  }\n}\n\nlemma BinomialSymmetry(n: nat, k: nat)\n  requires k <= n\n  ensures binomial(n, k) == binomial(n, n - k)\n{\n  assert fact(k) * fact(n - k) == fact(n - k) * fact(k);\n}", "output": "assert fib(1) == 1;"}, {"id": "example_BinomialSymmetry_0", "type": "assert", "program": "// Mathematical operations: GCD, LCM, primes, modular arithmetic\n\n// Absolute value\nfunction {:spec} abs(x: int): nat\n{\n  if x < 0 then -x else x\n}\n\n// Greatest Common Divisor using Euclidean algorithm\nfunction {:spec} gcd(a: nat, b: nat): nat\n  decreases b\n{\n  if b == 0 then a\n  else gcd(b, a % b)\n}\n\n// Least Common Multiple\nfunction {:spec} lcm(a: nat, b: nat): nat\n  requires a > 0 && b > 0\n{\n  var g := gcd(a, b);\n  assert g > 0 by { GcdPositive(a, b); }\n  a / g * b  // Reordered to avoid overflow and ensure positive\n}\n\n// Check if a number divides another\npredicate {:spec} divides(d: nat, n: nat)\n  requires d > 0\n{\n  n % d == 0\n}\n\n// Check if a number is prime\npredicate {:spec} isPrime(n: nat)\n{\n  n > 1 && forall d :: 2 <= d < n ==> !divides(d, n)\n}\n\n// Check if two numbers are coprime (relatively prime)\npredicate {:spec} coprime(a: nat, b: nat)\n  requires a > 0 && b > 0\n{\n  gcd(a, b) == 1\n}\n\n// Modular exponentiation: (base^exp) mod m\nfunction {:spec} modPow(base: nat, exp: nat, m: nat): nat\n  requires m > 0\n  decreases exp\n{\n  if exp == 0 then 1 % m\n  else if exp % 2 == 0 then\n    var half := modPow(base, exp / 2, m);\n    (half * half) % m\n  else\n    ((base % m) * modPow(base, exp - 1, m)) % m\n}\n\n// Fibonacci function\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// Factorial function\nfunction {:spec} fact(n: nat): nat\n{\n  if n == 0 then 1\n  else n * fact(n - 1)\n}\n\n// Binomial coefficient (n choose k)\nfunction {:spec} binomial(n: nat, k: nat): nat\n  requires k <= n\n{\n  var denominator := fact(k) * fact(n - k);\n  if denominator == 0 then 0  // Can't happen but helps verifier\n  else fact(n) / denominator\n}\n\n// Sum of first n natural numbers\nfunction {:spec} sumToN(n: nat): nat\n{\n  if n == 0 then 0\n  else n + sumToN(n - 1)\n}\n\n// Check if a number is perfect (sum of divisors equals the number)\npredicate {:spec} isPerfect(n: nat)\n  requires n > 0\n{\n  sumOfDivisors(n) == 2 * n  // Including n itself\n}\n\nfunction {:spec} sumOfDivisors(n: nat): nat\n  requires n > 0\n{\n  sumOfDivisorsHelper(n, n)\n}\n\nfunction sumOfDivisorsHelper(n: nat, d: nat): nat\n  requires n > 0\n  requires d > 0\n  decreases d\n{\n  if d == 1 then 1\n  else if divides(d, n) then d + sumOfDivisorsHelper(n, d - 1)\n  else sumOfDivisorsHelper(n, d - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma GcdZero(a: nat)\n  ensures gcd(a, 0) == a\n{\n  // Automatic by definition\n}\n\nlemma GcdPositive(a: nat, b: nat)\n  requires a > 0 || b > 0\n  ensures gcd(a, b) > 0\n  decreases b\n{\n  if b == 0 {\n    assert gcd(a, b) == a;\n    assert a > 0;\n  } else {\n    GcdPositive(b, a % b);\n  }\n}\n\nlemma GcdDividesBoth(a: nat, b: nat)\n  requires a > 0 && b > 0\n  ensures gcd(a, b) > 0\n{\n  GcdPositive(a, b);\n}\n\nlemma PrimeHasOnlyTwoDivisors(n: nat)\n  requires isPrime(n)\n  ensures divides(1, n) && divides(n, n)\n  ensures forall d: nat :: d > 0 && d < n && d != 1 ==> !divides(d, n)\n{\n  assert divides(1, n);\n  assert divides(n, n);\n  forall d: nat | d > 0 && d < n && d != 1\n    ensures !divides(d, n)\n  {\n    if d >= 2 {\n      assert 2 <= d < n;\n      // By definition of isPrime\n    }\n  }\n}\n\nlemma TwoPrime()\n  ensures isPrime(2)\n{\n  assert forall d :: 2 <= d < 2 ==> !divides(d, 2);\n}\n\nlemma ThreePrime()\n  ensures isPrime(3)\n{\n  assert !divides(2, 3);\n}\n\nfunction Power(base: nat, exp: nat): nat\n  decreases exp\n{\n  if exp == 0 then 1\n  else base * Power(base, exp - 1)\n}\n\nlemma PowerSquare(base: nat)\n  ensures Power(base, 2) == base * base\n{\n  assert Power(base, 2) == base * Power(base, 1);\n  assert Power(base, 1) == base;\n}\n\nlemma PowerAddition(base: nat, exp1: nat, exp2: nat)\n  ensures Power(base, exp1 + exp2) == Power(base, exp1) * Power(base, exp2)\n  decreases exp1\n{\n  if exp1 == 0 {\n    assert Power(base, 0) == 1;\n  } else {\n    PowerAddition(base, exp1 - 1, exp2);\n    assert Power(base, exp1 + exp2) == base * Power(base, exp1 - 1 + exp2);\n    assert Power(base, exp1) == base * Power(base, exp1 - 1);\n  }\n}\n\nlemma SumFormula(n: nat)\n  ensures sumToN(n) == n * (n + 1) / 2\n{\n  if n == 0 {\n    assert sumToN(0) == 0;\n  } else {\n    SumFormula(n - 1);\n    assert sumToN(n - 1) == (n - 1) * n / 2;\n    assert sumToN(n) == n + sumToN(n - 1);\n    assert sumToN(n) == n + (n - 1) * n / 2;\n    assert sumToN(n) == (2 * n + (n - 1) * n) / 2;\n    assert sumToN(n) == (2 * n + n * n - n) / 2;\n    assert sumToN(n) == (n + n * n) / 2;\n    assert sumToN(n) == n * (1 + n) / 2;\n  }\n}\n\nlemma FactorialPositive(n: nat)\n  ensures fact(n) > 0\n{\n  if n == 0 {\n    assert fact(0) == 1;\n  } else {\n    FactorialPositive(n - 1);\n  }\n}\n\nlemma FibonacciMonotonic(n: nat)\n  requires n > 0\n  ensures fib(n) <= fib(n + 1)\n{\n  if n == 1 {\n    assert fib(1) == 1;\n    assert fib(2) == 1;\n  } else {\n    assert fib(n + 1) == fib(n) + fib(n - 1);\n    if n > 1 {\n      assert fib(n - 1) >= 0;\n    }\n  }\n}\n\nlemma BinomialSymmetry(n: nat, k: nat)\n  requires k <= n\n  ensures binomial(n, k) == binomial(n, n - k)\n{\n  \n/*[CODE HERE]*/\n}", "output": "assert fact(k) * fact(n - k) == fact(n - k) * fact(k);"}, {"id": "example_maxIsCorrect_0", "type": "assert", "program": "// Finding maximum element in a sequence\n\npredicate {:spec} isMax(s: seq<int>, m: int)\n{\n  m in s && forall x :: x in s ==> x <= m\n}\n\nfunction max(s: seq<int>): int\n  requires |s| > 0\n{\n  if |s| == 1 then s[0]\n  else \n    var restMax := max(s[1..]);\n    if s[0] >= restMax then s[0] else restMax\n}\n\nlemma maxIsCorrect(s: seq<int>)\n  requires |s| > 0\n  ensures isMax(s, max(s))\n{\n  if |s| == 1 {\n    // Base case is trivial\n  } else {\n    var restMax := max(s[1..]);\n    maxIsCorrect(s[1..]);\n    // We know isMax(s[1..], restMax)\n    // So restMax in s[1..] and forall x in s[1..] :: x <= restMax\n    \n    if s[0] >= restMax {\n      // max returns s[0]\n      // Need to show: s[0] in s (trivial) and forall x in s :: x <= s[0]\n      forall x | x in s\n        ensures x <= s[0]\n      {\n        if x == s[0] {\n          // x <= s[0] trivially\n        } else {\n          // x must be in s[1..]\n          assert x in s[1..];\n          // From induction hypothesis: x <= restMax\n          // We know s[0] >= restMax\n          // Therefore x <= s[0]\n        }\n      }\n    } else {\n      // max returns restMax\n      // Need to show: restMax in s and forall x in s :: x <= restMax\n      assert restMax in s[1..];\n      assert restMax in s;\n      \n      forall x | x in s\n        ensures x <= restMax\n      {\n        if x == s[0] {\n          // We know s[0] < restMax\n        } else {\n          // x must be in s[1..]\n          \n/*[CODE HERE]*/\n          // From induction hypothesis: x <= restMax\n        }\n      }\n    }\n  }\n}", "output": "assert x in s[1..];"}, {"id": "example_maxIsCorrect_1", "type": "assert", "program": "// Finding maximum element in a sequence\n\npredicate {:spec} isMax(s: seq<int>, m: int)\n{\n  m in s && forall x :: x in s ==> x <= m\n}\n\nfunction max(s: seq<int>): int\n  requires |s| > 0\n{\n  if |s| == 1 then s[0]\n  else \n    var restMax := max(s[1..]);\n    if s[0] >= restMax then s[0] else restMax\n}\n\nlemma maxIsCorrect(s: seq<int>)\n  requires |s| > 0\n  ensures isMax(s, max(s))\n{\n  if |s| == 1 {\n    // Base case is trivial\n  } else {\n    var restMax := max(s[1..]);\n    maxIsCorrect(s[1..]);\n    // We know isMax(s[1..], restMax)\n    // So restMax in s[1..] and forall x in s[1..] :: x <= restMax\n    \n    if s[0] >= restMax {\n      // max returns s[0]\n      // Need to show: s[0] in s (trivial) and forall x in s :: x <= s[0]\n      forall x | x in s\n        ensures x <= s[0]\n      {\n        if x == s[0] {\n          // x <= s[0] trivially\n        } else {\n          // x must be in s[1..]\n          assert x in s[1..];\n          // From induction hypothesis: x <= restMax\n          // We know s[0] >= restMax\n          // Therefore x <= s[0]\n        }\n      }\n    } else {\n      // max returns restMax\n      // Need to show: restMax in s and forall x in s :: x <= restMax\n      assert restMax in s[1..];\n      \n/*[CODE HERE]*/\n      \n      forall x | x in s\n        ensures x <= restMax\n      {\n        if x == s[0] {\n          // We know s[0] < restMax\n        } else {\n          // x must be in s[1..]\n          assert x in s[1..];\n          // From induction hypothesis: x <= restMax\n        }\n      }\n    }\n  }\n}", "output": "assert restMax in s;"}, {"id": "example_maxIsCorrect_2", "type": "assert", "program": "// Finding maximum element in a sequence\n\npredicate {:spec} isMax(s: seq<int>, m: int)\n{\n  m in s && forall x :: x in s ==> x <= m\n}\n\nfunction max(s: seq<int>): int\n  requires |s| > 0\n{\n  if |s| == 1 then s[0]\n  else \n    var restMax := max(s[1..]);\n    if s[0] >= restMax then s[0] else restMax\n}\n\nlemma maxIsCorrect(s: seq<int>)\n  requires |s| > 0\n  ensures isMax(s, max(s))\n{\n  if |s| == 1 {\n    // Base case is trivial\n  } else {\n    var restMax := max(s[1..]);\n    maxIsCorrect(s[1..]);\n    // We know isMax(s[1..], restMax)\n    // So restMax in s[1..] and forall x in s[1..] :: x <= restMax\n    \n    if s[0] >= restMax {\n      // max returns s[0]\n      // Need to show: s[0] in s (trivial) and forall x in s :: x <= s[0]\n      forall x | x in s\n        ensures x <= s[0]\n      {\n        if x == s[0] {\n          // x <= s[0] trivially\n        } else {\n          // x must be in s[1..]\n          assert x in s[1..];\n          // From induction hypothesis: x <= restMax\n          // We know s[0] >= restMax\n          // Therefore x <= s[0]\n        }\n      }\n    } else {\n      // max returns restMax\n      // Need to show: restMax in s and forall x in s :: x <= restMax\n      \n/*[CODE HERE]*/\n      assert restMax in s;\n      \n      forall x | x in s\n        ensures x <= restMax\n      {\n        if x == s[0] {\n          // We know s[0] < restMax\n        } else {\n          // x must be in s[1..]\n          assert x in s[1..];\n          // From induction hypothesis: x <= restMax\n        }\n      }\n    }\n  }\n}", "output": "assert restMax in s[1..];"}, {"id": "example_maxIsCorrect_3", "type": "assert", "program": "// Finding maximum element in a sequence\n\npredicate {:spec} isMax(s: seq<int>, m: int)\n{\n  m in s && forall x :: x in s ==> x <= m\n}\n\nfunction max(s: seq<int>): int\n  requires |s| > 0\n{\n  if |s| == 1 then s[0]\n  else \n    var restMax := max(s[1..]);\n    if s[0] >= restMax then s[0] else restMax\n}\n\nlemma maxIsCorrect(s: seq<int>)\n  requires |s| > 0\n  ensures isMax(s, max(s))\n{\n  if |s| == 1 {\n    // Base case is trivial\n  } else {\n    var restMax := max(s[1..]);\n    maxIsCorrect(s[1..]);\n    // We know isMax(s[1..], restMax)\n    // So restMax in s[1..] and forall x in s[1..] :: x <= restMax\n    \n    if s[0] >= restMax {\n      // max returns s[0]\n      // Need to show: s[0] in s (trivial) and forall x in s :: x <= s[0]\n      forall x | x in s\n        ensures x <= s[0]\n      {\n        if x == s[0] {\n          // x <= s[0] trivially\n        } else {\n          // x must be in s[1..]\n          \n/*[CODE HERE]*/\n          // From induction hypothesis: x <= restMax\n          // We know s[0] >= restMax\n          // Therefore x <= s[0]\n        }\n      }\n    } else {\n      // max returns restMax\n      // Need to show: restMax in s and forall x in s :: x <= restMax\n      assert restMax in s[1..];\n      assert restMax in s;\n      \n      forall x | x in s\n        ensures x <= restMax\n      {\n        if x == s[0] {\n          // We know s[0] < restMax\n        } else {\n          // x must be in s[1..]\n          assert x in s[1..];\n          // From induction hypothesis: x <= restMax\n        }\n      }\n    }\n  }\n}", "output": "assert x in s[1..];"}, {"id": "example_maxIsCorrect_4", "type": "call", "program": "// Finding maximum element in a sequence\n\npredicate {:spec} isMax(s: seq<int>, m: int)\n{\n  m in s && forall x :: x in s ==> x <= m\n}\n\nfunction max(s: seq<int>): int\n  requires |s| > 0\n{\n  if |s| == 1 then s[0]\n  else \n    var restMax := max(s[1..]);\n    if s[0] >= restMax then s[0] else restMax\n}\n\nlemma maxIsCorrect(s: seq<int>)\n  requires |s| > 0\n  ensures isMax(s, max(s))\n{\n  if |s| == 1 {\n    // Base case is trivial\n  } else {\n    var restMax := max(s[1..]);\n    \n/*[CODE HERE]*/\n    // We know isMax(s[1..], restMax)\n    // So restMax in s[1..] and forall x in s[1..] :: x <= restMax\n    \n    if s[0] >= restMax {\n      // max returns s[0]\n      // Need to show: s[0] in s (trivial) and forall x in s :: x <= s[0]\n      forall x | x in s\n        ensures x <= s[0]\n      {\n        if x == s[0] {\n          // x <= s[0] trivially\n        } else {\n          // x must be in s[1..]\n          assert x in s[1..];\n          // From induction hypothesis: x <= restMax\n          // We know s[0] >= restMax\n          // Therefore x <= s[0]\n        }\n      }\n    } else {\n      // max returns restMax\n      // Need to show: restMax in s and forall x in s :: x <= restMax\n      assert restMax in s[1..];\n      assert restMax in s;\n      \n      forall x | x in s\n        ensures x <= restMax\n      {\n        if x == s[0] {\n          // We know s[0] < restMax\n        } else {\n          // x must be in s[1..]\n          assert x in s[1..];\n          // From induction hypothesis: x <= restMax\n        }\n      }\n    }\n  }\n}", "output": "maxIsCorrect(s[1..]);"}, {"id": "example_optimizeOptimal_0", "type": "call", "program": "datatype Expr =\n  | Const(value: int)\n  | Var(name: string)\n  | Add(left: Expr, right: Expr)\n\npredicate {:spec} optimal(e: Expr)\n{\n  match e\n  case Add(Const(0), _) => false\n  case Add(_, Const(0)) => false\n  case Add(e1, e2) => optimal(e1) && optimal(e2)\n  case _ => true\n}\n\nfunction optimize(e: Expr): Expr\n{\n  match e {\n  case Add(e1, e2) =>\n    match (optimize(e1), optimize(e2)) {\n    case (Const(0), oe2) => oe2\n    case (oe1, Const(0)) => oe1\n    case (oe1, oe2) => Add(oe1, oe2)\n    }\n  case _ => e\n  }\n}\n\nlemma optimizeOptimal(e: Expr)\nensures optimal(optimize(e))\n{\n  // Structural induction on e\n  match e {\n      case Const(value) => {\n      }\n      case Var(name) => {\n      }\n      case Add(left, right) => {\n          optimizeOptimal(left);\n          \n/*[CODE HERE]*/\n      }\n  }\n}", "output": "optimizeOptimal(right);"}, {"id": "example_optimizeOptimal_1", "type": "call", "program": "datatype Expr =\n  | Const(value: int)\n  | Var(name: string)\n  | Add(left: Expr, right: Expr)\n\npredicate {:spec} optimal(e: Expr)\n{\n  match e\n  case Add(Const(0), _) => false\n  case Add(_, Const(0)) => false\n  case Add(e1, e2) => optimal(e1) && optimal(e2)\n  case _ => true\n}\n\nfunction optimize(e: Expr): Expr\n{\n  match e {\n  case Add(e1, e2) =>\n    match (optimize(e1), optimize(e2)) {\n    case (Const(0), oe2) => oe2\n    case (oe1, Const(0)) => oe1\n    case (oe1, oe2) => Add(oe1, oe2)\n    }\n  case _ => e\n  }\n}\n\nlemma optimizeOptimal(e: Expr)\nensures optimal(optimize(e))\n{\n  // Structural induction on e\n  match e {\n      case Const(value) => {\n      }\n      case Var(name) => {\n      }\n      case Add(left, right) => {\n          \n/*[CODE HERE]*/\n          optimizeOptimal(right);\n      }\n  }\n}", "output": "optimizeOptimal(left);"}, {"id": "example_appendNilRight_0", "type": "call", "program": "datatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction reverse<T>(xs: List<T>): List<T>\n{\n  match xs\n  case Nil => Nil\n  case Cons(h, t) => append(reverse(t), Cons(h, Nil))\n}\n\nfunction append<T>(xs: List<T>, ys: List<T>): List<T>\n{\n  match xs\n  case Nil => ys\n  case Cons(h, t) => Cons(h, append(t, ys))\n}\n\npredicate {:spec} isPalindrome<T(==)>(xs: List<T>)\n{\n  xs == reverse(xs)\n}\n\nfunction makePalindrome<T>(xs: List<T>): List<T>\n{\n  append(xs, reverse(xs))\n}\n\nlemma appendNilRight<T>(xs: List<T>)\n  ensures append(xs, Nil) == xs\n{\n  match xs\n  case Nil => \n  case Cons(h, t) => \n/*[CODE HERE]*/\n}\n\nlemma appendAssoc<T>(xs: List<T>, ys: List<T>, zs: List<T>)\n  ensures append(append(xs, ys), zs) == append(xs, append(ys, zs))\n{\n  match xs\n  case Nil =>\n  case Cons(h, t) => appendAssoc(t, ys, zs);\n}\n\nlemma reverseAppend<T>(xs: List<T>, ys: List<T>)\n  ensures reverse(append(xs, ys)) == append(reverse(ys), reverse(xs))\n{\n  match xs\n  case Nil => \n    assert reverse(append(Nil, ys)) == reverse(ys);\n    appendNilRight(reverse(ys));\n  case Cons(h, t) =>\n    reverseAppend(t, ys);\n    appendAssoc(reverse(ys), reverse(t), Cons(h, Nil));\n}\n\nlemma reverseReverse<T>(xs: List<T>)\n  ensures reverse(reverse(xs)) == xs\n{\n  match xs\n  case Nil =>\n  case Cons(h, t) =>\n    reverseReverse(t);\n    reverseAppend(reverse(t), Cons(h, Nil));\n    assert reverse(Cons(h, Nil)) == Cons(h, Nil);\n}\n\nlemma makePalindromeCorrect<T>(xs: List<T>)\n  ensures isPalindrome(makePalindrome(xs))\n{\n  calc == {\n    reverse(makePalindrome(xs));\n    reverse(append(xs, reverse(xs)));\n    { reverseAppend(xs, reverse(xs)); }\n    append(reverse(reverse(xs)), reverse(xs));\n    { reverseReverse(xs); }\n    append(xs, reverse(xs));\n    makePalindrome(xs);\n  }\n}", "output": "appendNilRight(t);"}, {"id": "example_appendAssoc_0", "type": "call", "program": "datatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction reverse<T>(xs: List<T>): List<T>\n{\n  match xs\n  case Nil => Nil\n  case Cons(h, t) => append(reverse(t), Cons(h, Nil))\n}\n\nfunction append<T>(xs: List<T>, ys: List<T>): List<T>\n{\n  match xs\n  case Nil => ys\n  case Cons(h, t) => Cons(h, append(t, ys))\n}\n\npredicate {:spec} isPalindrome<T(==)>(xs: List<T>)\n{\n  xs == reverse(xs)\n}\n\nfunction makePalindrome<T>(xs: List<T>): List<T>\n{\n  append(xs, reverse(xs))\n}\n\nlemma appendNilRight<T>(xs: List<T>)\n  ensures append(xs, Nil) == xs\n{\n  match xs\n  case Nil => \n  case Cons(h, t) => appendNilRight(t);\n}\n\nlemma appendAssoc<T>(xs: List<T>, ys: List<T>, zs: List<T>)\n  ensures append(append(xs, ys), zs) == append(xs, append(ys, zs))\n{\n  match xs\n  case Nil =>\n  case Cons(h, t) => \n/*[CODE HERE]*/\n}\n\nlemma reverseAppend<T>(xs: List<T>, ys: List<T>)\n  ensures reverse(append(xs, ys)) == append(reverse(ys), reverse(xs))\n{\n  match xs\n  case Nil => \n    assert reverse(append(Nil, ys)) == reverse(ys);\n    appendNilRight(reverse(ys));\n  case Cons(h, t) =>\n    reverseAppend(t, ys);\n    appendAssoc(reverse(ys), reverse(t), Cons(h, Nil));\n}\n\nlemma reverseReverse<T>(xs: List<T>)\n  ensures reverse(reverse(xs)) == xs\n{\n  match xs\n  case Nil =>\n  case Cons(h, t) =>\n    reverseReverse(t);\n    reverseAppend(reverse(t), Cons(h, Nil));\n    assert reverse(Cons(h, Nil)) == Cons(h, Nil);\n}\n\nlemma makePalindromeCorrect<T>(xs: List<T>)\n  ensures isPalindrome(makePalindrome(xs))\n{\n  calc == {\n    reverse(makePalindrome(xs));\n    reverse(append(xs, reverse(xs)));\n    { reverseAppend(xs, reverse(xs)); }\n    append(reverse(reverse(xs)), reverse(xs));\n    { reverseReverse(xs); }\n    append(xs, reverse(xs));\n    makePalindrome(xs);\n  }\n}", "output": "appendAssoc(t, ys, zs);"}, {"id": "example_reverseAppend_0", "type": "call", "program": "datatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction reverse<T>(xs: List<T>): List<T>\n{\n  match xs\n  case Nil => Nil\n  case Cons(h, t) => append(reverse(t), Cons(h, Nil))\n}\n\nfunction append<T>(xs: List<T>, ys: List<T>): List<T>\n{\n  match xs\n  case Nil => ys\n  case Cons(h, t) => Cons(h, append(t, ys))\n}\n\npredicate {:spec} isPalindrome<T(==)>(xs: List<T>)\n{\n  xs == reverse(xs)\n}\n\nfunction makePalindrome<T>(xs: List<T>): List<T>\n{\n  append(xs, reverse(xs))\n}\n\nlemma appendNilRight<T>(xs: List<T>)\n  ensures append(xs, Nil) == xs\n{\n  match xs\n  case Nil => \n  case Cons(h, t) => appendNilRight(t);\n}\n\nlemma appendAssoc<T>(xs: List<T>, ys: List<T>, zs: List<T>)\n  ensures append(append(xs, ys), zs) == append(xs, append(ys, zs))\n{\n  match xs\n  case Nil =>\n  case Cons(h, t) => appendAssoc(t, ys, zs);\n}\n\nlemma reverseAppend<T>(xs: List<T>, ys: List<T>)\n  ensures reverse(append(xs, ys)) == append(reverse(ys), reverse(xs))\n{\n  match xs\n  case Nil => \n    assert reverse(append(Nil, ys)) == reverse(ys);\n    appendNilRight(reverse(ys));\n  case Cons(h, t) =>\n    reverseAppend(t, ys);\n    \n/*[CODE HERE]*/\n}\n\nlemma reverseReverse<T>(xs: List<T>)\n  ensures reverse(reverse(xs)) == xs\n{\n  match xs\n  case Nil =>\n  case Cons(h, t) =>\n    reverseReverse(t);\n    reverseAppend(reverse(t), Cons(h, Nil));\n    assert reverse(Cons(h, Nil)) == Cons(h, Nil);\n}\n\nlemma makePalindromeCorrect<T>(xs: List<T>)\n  ensures isPalindrome(makePalindrome(xs))\n{\n  calc == {\n    reverse(makePalindrome(xs));\n    reverse(append(xs, reverse(xs)));\n    { reverseAppend(xs, reverse(xs)); }\n    append(reverse(reverse(xs)), reverse(xs));\n    { reverseReverse(xs); }\n    append(xs, reverse(xs));\n    makePalindrome(xs);\n  }\n}", "output": "appendAssoc(reverse(ys), reverse(t), Cons(h, Nil));"}, {"id": "example_reverseAppend_1", "type": "call", "program": "datatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction reverse<T>(xs: List<T>): List<T>\n{\n  match xs\n  case Nil => Nil\n  case Cons(h, t) => append(reverse(t), Cons(h, Nil))\n}\n\nfunction append<T>(xs: List<T>, ys: List<T>): List<T>\n{\n  match xs\n  case Nil => ys\n  case Cons(h, t) => Cons(h, append(t, ys))\n}\n\npredicate {:spec} isPalindrome<T(==)>(xs: List<T>)\n{\n  xs == reverse(xs)\n}\n\nfunction makePalindrome<T>(xs: List<T>): List<T>\n{\n  append(xs, reverse(xs))\n}\n\nlemma appendNilRight<T>(xs: List<T>)\n  ensures append(xs, Nil) == xs\n{\n  match xs\n  case Nil => \n  case Cons(h, t) => appendNilRight(t);\n}\n\nlemma appendAssoc<T>(xs: List<T>, ys: List<T>, zs: List<T>)\n  ensures append(append(xs, ys), zs) == append(xs, append(ys, zs))\n{\n  match xs\n  case Nil =>\n  case Cons(h, t) => appendAssoc(t, ys, zs);\n}\n\nlemma reverseAppend<T>(xs: List<T>, ys: List<T>)\n  ensures reverse(append(xs, ys)) == append(reverse(ys), reverse(xs))\n{\n  match xs\n  case Nil => \n    assert reverse(append(Nil, ys)) == reverse(ys);\n    appendNilRight(reverse(ys));\n  case Cons(h, t) =>\n    \n/*[CODE HERE]*/\n    appendAssoc(reverse(ys), reverse(t), Cons(h, Nil));\n}\n\nlemma reverseReverse<T>(xs: List<T>)\n  ensures reverse(reverse(xs)) == xs\n{\n  match xs\n  case Nil =>\n  case Cons(h, t) =>\n    reverseReverse(t);\n    reverseAppend(reverse(t), Cons(h, Nil));\n    assert reverse(Cons(h, Nil)) == Cons(h, Nil);\n}\n\nlemma makePalindromeCorrect<T>(xs: List<T>)\n  ensures isPalindrome(makePalindrome(xs))\n{\n  calc == {\n    reverse(makePalindrome(xs));\n    reverse(append(xs, reverse(xs)));\n    { reverseAppend(xs, reverse(xs)); }\n    append(reverse(reverse(xs)), reverse(xs));\n    { reverseReverse(xs); }\n    append(xs, reverse(xs));\n    makePalindrome(xs);\n  }\n}", "output": "reverseAppend(t, ys);"}, {"id": "example_reverseAppend_2", "type": "call", "program": "datatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction reverse<T>(xs: List<T>): List<T>\n{\n  match xs\n  case Nil => Nil\n  case Cons(h, t) => append(reverse(t), Cons(h, Nil))\n}\n\nfunction append<T>(xs: List<T>, ys: List<T>): List<T>\n{\n  match xs\n  case Nil => ys\n  case Cons(h, t) => Cons(h, append(t, ys))\n}\n\npredicate {:spec} isPalindrome<T(==)>(xs: List<T>)\n{\n  xs == reverse(xs)\n}\n\nfunction makePalindrome<T>(xs: List<T>): List<T>\n{\n  append(xs, reverse(xs))\n}\n\nlemma appendNilRight<T>(xs: List<T>)\n  ensures append(xs, Nil) == xs\n{\n  match xs\n  case Nil => \n  case Cons(h, t) => appendNilRight(t);\n}\n\nlemma appendAssoc<T>(xs: List<T>, ys: List<T>, zs: List<T>)\n  ensures append(append(xs, ys), zs) == append(xs, append(ys, zs))\n{\n  match xs\n  case Nil =>\n  case Cons(h, t) => appendAssoc(t, ys, zs);\n}\n\nlemma reverseAppend<T>(xs: List<T>, ys: List<T>)\n  ensures reverse(append(xs, ys)) == append(reverse(ys), reverse(xs))\n{\n  match xs\n  case Nil => \n    assert reverse(append(Nil, ys)) == reverse(ys);\n    \n/*[CODE HERE]*/\n  case Cons(h, t) =>\n    reverseAppend(t, ys);\n    appendAssoc(reverse(ys), reverse(t), Cons(h, Nil));\n}\n\nlemma reverseReverse<T>(xs: List<T>)\n  ensures reverse(reverse(xs)) == xs\n{\n  match xs\n  case Nil =>\n  case Cons(h, t) =>\n    reverseReverse(t);\n    reverseAppend(reverse(t), Cons(h, Nil));\n    assert reverse(Cons(h, Nil)) == Cons(h, Nil);\n}\n\nlemma makePalindromeCorrect<T>(xs: List<T>)\n  ensures isPalindrome(makePalindrome(xs))\n{\n  calc == {\n    reverse(makePalindrome(xs));\n    reverse(append(xs, reverse(xs)));\n    { reverseAppend(xs, reverse(xs)); }\n    append(reverse(reverse(xs)), reverse(xs));\n    { reverseReverse(xs); }\n    append(xs, reverse(xs));\n    makePalindrome(xs);\n  }\n}", "output": "appendNilRight(reverse(ys));"}, {"id": "example_reverseAppend_3", "type": "assert", "program": "datatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction reverse<T>(xs: List<T>): List<T>\n{\n  match xs\n  case Nil => Nil\n  case Cons(h, t) => append(reverse(t), Cons(h, Nil))\n}\n\nfunction append<T>(xs: List<T>, ys: List<T>): List<T>\n{\n  match xs\n  case Nil => ys\n  case Cons(h, t) => Cons(h, append(t, ys))\n}\n\npredicate {:spec} isPalindrome<T(==)>(xs: List<T>)\n{\n  xs == reverse(xs)\n}\n\nfunction makePalindrome<T>(xs: List<T>): List<T>\n{\n  append(xs, reverse(xs))\n}\n\nlemma appendNilRight<T>(xs: List<T>)\n  ensures append(xs, Nil) == xs\n{\n  match xs\n  case Nil => \n  case Cons(h, t) => appendNilRight(t);\n}\n\nlemma appendAssoc<T>(xs: List<T>, ys: List<T>, zs: List<T>)\n  ensures append(append(xs, ys), zs) == append(xs, append(ys, zs))\n{\n  match xs\n  case Nil =>\n  case Cons(h, t) => appendAssoc(t, ys, zs);\n}\n\nlemma reverseAppend<T>(xs: List<T>, ys: List<T>)\n  ensures reverse(append(xs, ys)) == append(reverse(ys), reverse(xs))\n{\n  match xs\n  case Nil => \n    \n/*[CODE HERE]*/\n    appendNilRight(reverse(ys));\n  case Cons(h, t) =>\n    reverseAppend(t, ys);\n    appendAssoc(reverse(ys), reverse(t), Cons(h, Nil));\n}\n\nlemma reverseReverse<T>(xs: List<T>)\n  ensures reverse(reverse(xs)) == xs\n{\n  match xs\n  case Nil =>\n  case Cons(h, t) =>\n    reverseReverse(t);\n    reverseAppend(reverse(t), Cons(h, Nil));\n    assert reverse(Cons(h, Nil)) == Cons(h, Nil);\n}\n\nlemma makePalindromeCorrect<T>(xs: List<T>)\n  ensures isPalindrome(makePalindrome(xs))\n{\n  calc == {\n    reverse(makePalindrome(xs));\n    reverse(append(xs, reverse(xs)));\n    { reverseAppend(xs, reverse(xs)); }\n    append(reverse(reverse(xs)), reverse(xs));\n    { reverseReverse(xs); }\n    append(xs, reverse(xs));\n    makePalindrome(xs);\n  }\n}", "output": "assert reverse(append(Nil, ys)) == reverse(ys);"}, {"id": "example_reverseReverse_0", "type": "assert", "program": "datatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction reverse<T>(xs: List<T>): List<T>\n{\n  match xs\n  case Nil => Nil\n  case Cons(h, t) => append(reverse(t), Cons(h, Nil))\n}\n\nfunction append<T>(xs: List<T>, ys: List<T>): List<T>\n{\n  match xs\n  case Nil => ys\n  case Cons(h, t) => Cons(h, append(t, ys))\n}\n\npredicate {:spec} isPalindrome<T(==)>(xs: List<T>)\n{\n  xs == reverse(xs)\n}\n\nfunction makePalindrome<T>(xs: List<T>): List<T>\n{\n  append(xs, reverse(xs))\n}\n\nlemma appendNilRight<T>(xs: List<T>)\n  ensures append(xs, Nil) == xs\n{\n  match xs\n  case Nil => \n  case Cons(h, t) => appendNilRight(t);\n}\n\nlemma appendAssoc<T>(xs: List<T>, ys: List<T>, zs: List<T>)\n  ensures append(append(xs, ys), zs) == append(xs, append(ys, zs))\n{\n  match xs\n  case Nil =>\n  case Cons(h, t) => appendAssoc(t, ys, zs);\n}\n\nlemma reverseAppend<T>(xs: List<T>, ys: List<T>)\n  ensures reverse(append(xs, ys)) == append(reverse(ys), reverse(xs))\n{\n  match xs\n  case Nil => \n    assert reverse(append(Nil, ys)) == reverse(ys);\n    appendNilRight(reverse(ys));\n  case Cons(h, t) =>\n    reverseAppend(t, ys);\n    appendAssoc(reverse(ys), reverse(t), Cons(h, Nil));\n}\n\nlemma reverseReverse<T>(xs: List<T>)\n  ensures reverse(reverse(xs)) == xs\n{\n  match xs\n  case Nil =>\n  case Cons(h, t) =>\n    reverseReverse(t);\n    reverseAppend(reverse(t), Cons(h, Nil));\n    \n/*[CODE HERE]*/\n}\n\nlemma makePalindromeCorrect<T>(xs: List<T>)\n  ensures isPalindrome(makePalindrome(xs))\n{\n  calc == {\n    reverse(makePalindrome(xs));\n    reverse(append(xs, reverse(xs)));\n    { reverseAppend(xs, reverse(xs)); }\n    append(reverse(reverse(xs)), reverse(xs));\n    { reverseReverse(xs); }\n    append(xs, reverse(xs));\n    makePalindrome(xs);\n  }\n}", "output": "assert reverse(Cons(h, Nil)) == Cons(h, Nil);"}, {"id": "example_reverseReverse_1", "type": "call", "program": "datatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction reverse<T>(xs: List<T>): List<T>\n{\n  match xs\n  case Nil => Nil\n  case Cons(h, t) => append(reverse(t), Cons(h, Nil))\n}\n\nfunction append<T>(xs: List<T>, ys: List<T>): List<T>\n{\n  match xs\n  case Nil => ys\n  case Cons(h, t) => Cons(h, append(t, ys))\n}\n\npredicate {:spec} isPalindrome<T(==)>(xs: List<T>)\n{\n  xs == reverse(xs)\n}\n\nfunction makePalindrome<T>(xs: List<T>): List<T>\n{\n  append(xs, reverse(xs))\n}\n\nlemma appendNilRight<T>(xs: List<T>)\n  ensures append(xs, Nil) == xs\n{\n  match xs\n  case Nil => \n  case Cons(h, t) => appendNilRight(t);\n}\n\nlemma appendAssoc<T>(xs: List<T>, ys: List<T>, zs: List<T>)\n  ensures append(append(xs, ys), zs) == append(xs, append(ys, zs))\n{\n  match xs\n  case Nil =>\n  case Cons(h, t) => appendAssoc(t, ys, zs);\n}\n\nlemma reverseAppend<T>(xs: List<T>, ys: List<T>)\n  ensures reverse(append(xs, ys)) == append(reverse(ys), reverse(xs))\n{\n  match xs\n  case Nil => \n    assert reverse(append(Nil, ys)) == reverse(ys);\n    appendNilRight(reverse(ys));\n  case Cons(h, t) =>\n    reverseAppend(t, ys);\n    appendAssoc(reverse(ys), reverse(t), Cons(h, Nil));\n}\n\nlemma reverseReverse<T>(xs: List<T>)\n  ensures reverse(reverse(xs)) == xs\n{\n  match xs\n  case Nil =>\n  case Cons(h, t) =>\n    reverseReverse(t);\n    \n/*[CODE HERE]*/\n    assert reverse(Cons(h, Nil)) == Cons(h, Nil);\n}\n\nlemma makePalindromeCorrect<T>(xs: List<T>)\n  ensures isPalindrome(makePalindrome(xs))\n{\n  calc == {\n    reverse(makePalindrome(xs));\n    reverse(append(xs, reverse(xs)));\n    { reverseAppend(xs, reverse(xs)); }\n    append(reverse(reverse(xs)), reverse(xs));\n    { reverseReverse(xs); }\n    append(xs, reverse(xs));\n    makePalindrome(xs);\n  }\n}", "output": "reverseAppend(reverse(t), Cons(h, Nil));"}, {"id": "example_reverseReverse_2", "type": "call", "program": "datatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction reverse<T>(xs: List<T>): List<T>\n{\n  match xs\n  case Nil => Nil\n  case Cons(h, t) => append(reverse(t), Cons(h, Nil))\n}\n\nfunction append<T>(xs: List<T>, ys: List<T>): List<T>\n{\n  match xs\n  case Nil => ys\n  case Cons(h, t) => Cons(h, append(t, ys))\n}\n\npredicate {:spec} isPalindrome<T(==)>(xs: List<T>)\n{\n  xs == reverse(xs)\n}\n\nfunction makePalindrome<T>(xs: List<T>): List<T>\n{\n  append(xs, reverse(xs))\n}\n\nlemma appendNilRight<T>(xs: List<T>)\n  ensures append(xs, Nil) == xs\n{\n  match xs\n  case Nil => \n  case Cons(h, t) => appendNilRight(t);\n}\n\nlemma appendAssoc<T>(xs: List<T>, ys: List<T>, zs: List<T>)\n  ensures append(append(xs, ys), zs) == append(xs, append(ys, zs))\n{\n  match xs\n  case Nil =>\n  case Cons(h, t) => appendAssoc(t, ys, zs);\n}\n\nlemma reverseAppend<T>(xs: List<T>, ys: List<T>)\n  ensures reverse(append(xs, ys)) == append(reverse(ys), reverse(xs))\n{\n  match xs\n  case Nil => \n    assert reverse(append(Nil, ys)) == reverse(ys);\n    appendNilRight(reverse(ys));\n  case Cons(h, t) =>\n    reverseAppend(t, ys);\n    appendAssoc(reverse(ys), reverse(t), Cons(h, Nil));\n}\n\nlemma reverseReverse<T>(xs: List<T>)\n  ensures reverse(reverse(xs)) == xs\n{\n  match xs\n  case Nil =>\n  case Cons(h, t) =>\n    \n/*[CODE HERE]*/\n    reverseAppend(reverse(t), Cons(h, Nil));\n    assert reverse(Cons(h, Nil)) == Cons(h, Nil);\n}\n\nlemma makePalindromeCorrect<T>(xs: List<T>)\n  ensures isPalindrome(makePalindrome(xs))\n{\n  calc == {\n    reverse(makePalindrome(xs));\n    reverse(append(xs, reverse(xs)));\n    { reverseAppend(xs, reverse(xs)); }\n    append(reverse(reverse(xs)), reverse(xs));\n    { reverseReverse(xs); }\n    append(xs, reverse(xs));\n    makePalindrome(xs);\n  }\n}", "output": "reverseReverse(t);"}, {"id": "example_makePalindromeCorrect_0", "type": "call", "program": "datatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction reverse<T>(xs: List<T>): List<T>\n{\n  match xs\n  case Nil => Nil\n  case Cons(h, t) => append(reverse(t), Cons(h, Nil))\n}\n\nfunction append<T>(xs: List<T>, ys: List<T>): List<T>\n{\n  match xs\n  case Nil => ys\n  case Cons(h, t) => Cons(h, append(t, ys))\n}\n\npredicate {:spec} isPalindrome<T(==)>(xs: List<T>)\n{\n  xs == reverse(xs)\n}\n\nfunction makePalindrome<T>(xs: List<T>): List<T>\n{\n  append(xs, reverse(xs))\n}\n\nlemma appendNilRight<T>(xs: List<T>)\n  ensures append(xs, Nil) == xs\n{\n  match xs\n  case Nil => \n  case Cons(h, t) => appendNilRight(t);\n}\n\nlemma appendAssoc<T>(xs: List<T>, ys: List<T>, zs: List<T>)\n  ensures append(append(xs, ys), zs) == append(xs, append(ys, zs))\n{\n  match xs\n  case Nil =>\n  case Cons(h, t) => appendAssoc(t, ys, zs);\n}\n\nlemma reverseAppend<T>(xs: List<T>, ys: List<T>)\n  ensures reverse(append(xs, ys)) == append(reverse(ys), reverse(xs))\n{\n  match xs\n  case Nil => \n    assert reverse(append(Nil, ys)) == reverse(ys);\n    appendNilRight(reverse(ys));\n  case Cons(h, t) =>\n    reverseAppend(t, ys);\n    appendAssoc(reverse(ys), reverse(t), Cons(h, Nil));\n}\n\nlemma reverseReverse<T>(xs: List<T>)\n  ensures reverse(reverse(xs)) == xs\n{\n  match xs\n  case Nil =>\n  case Cons(h, t) =>\n    reverseReverse(t);\n    reverseAppend(reverse(t), Cons(h, Nil));\n    assert reverse(Cons(h, Nil)) == Cons(h, Nil);\n}\n\nlemma makePalindromeCorrect<T>(xs: List<T>)\n  ensures isPalindrome(makePalindrome(xs))\n{\n  calc == {\n    reverse(makePalindrome(xs));\n    reverse(append(xs, reverse(xs)));\n    { reverseAppend(xs, reverse(xs)); }\n    append(reverse(reverse(xs)), reverse(xs));\n    { \n/*[CODE HERE]*/\n}\n    append(xs, reverse(xs));\n    makePalindrome(xs);\n  }\n}", "output": "reverseReverse(xs);"}, {"id": "example_makePalindromeCorrect_1", "type": "call", "program": "datatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction reverse<T>(xs: List<T>): List<T>\n{\n  match xs\n  case Nil => Nil\n  case Cons(h, t) => append(reverse(t), Cons(h, Nil))\n}\n\nfunction append<T>(xs: List<T>, ys: List<T>): List<T>\n{\n  match xs\n  case Nil => ys\n  case Cons(h, t) => Cons(h, append(t, ys))\n}\n\npredicate {:spec} isPalindrome<T(==)>(xs: List<T>)\n{\n  xs == reverse(xs)\n}\n\nfunction makePalindrome<T>(xs: List<T>): List<T>\n{\n  append(xs, reverse(xs))\n}\n\nlemma appendNilRight<T>(xs: List<T>)\n  ensures append(xs, Nil) == xs\n{\n  match xs\n  case Nil => \n  case Cons(h, t) => appendNilRight(t);\n}\n\nlemma appendAssoc<T>(xs: List<T>, ys: List<T>, zs: List<T>)\n  ensures append(append(xs, ys), zs) == append(xs, append(ys, zs))\n{\n  match xs\n  case Nil =>\n  case Cons(h, t) => appendAssoc(t, ys, zs);\n}\n\nlemma reverseAppend<T>(xs: List<T>, ys: List<T>)\n  ensures reverse(append(xs, ys)) == append(reverse(ys), reverse(xs))\n{\n  match xs\n  case Nil => \n    assert reverse(append(Nil, ys)) == reverse(ys);\n    appendNilRight(reverse(ys));\n  case Cons(h, t) =>\n    reverseAppend(t, ys);\n    appendAssoc(reverse(ys), reverse(t), Cons(h, Nil));\n}\n\nlemma reverseReverse<T>(xs: List<T>)\n  ensures reverse(reverse(xs)) == xs\n{\n  match xs\n  case Nil =>\n  case Cons(h, t) =>\n    reverseReverse(t);\n    reverseAppend(reverse(t), Cons(h, Nil));\n    assert reverse(Cons(h, Nil)) == Cons(h, Nil);\n}\n\nlemma makePalindromeCorrect<T>(xs: List<T>)\n  ensures isPalindrome(makePalindrome(xs))\n{\n  calc == {\n    reverse(makePalindrome(xs));\n    reverse(append(xs, reverse(xs)));\n    { \n/*[CODE HERE]*/\n}\n    append(reverse(reverse(xs)), reverse(xs));\n    { reverseReverse(xs); }\n    append(xs, reverse(xs));\n    makePalindrome(xs);\n  }\n}", "output": "reverseAppend(xs, reverse(xs));"}, {"id": "example_partitionCorrect_0", "type": "assert", "program": "function partition(s: seq<int>): (seq<int>, seq<int>)\n{\n  if |s| == 0 then ([], [])\n  else\n    var (evens, odds) := partition(s[1..]);\n    if isEven(s[0]) then ([s[0]] + evens, odds)\n    else (evens, [s[0]] + odds)\n}\n\npredicate {:spec} isEven(n: int)\n{\n  n % 2 == 0\n}\n\nlemma partitionCorrect(s: seq<int>)\n  ensures var (evens, odds) := partition(s);\n    (forall x :: x in evens ==> isEven(x)) &&\n    (forall x :: x in odds ==> !isEven(x)) &&\n    |evens| + |odds| == |s| &&\n    multiset(evens + odds) == multiset(s)\n{\n  if |s| == 0 {\n  } else {\n    partitionCorrect(s[1..]);\n    var (evens, odds) := partition(s);\n    var (evens', odds') := partition(s[1..]);\n    \n    if isEven(s[0]) {\n      assert evens == [s[0]] + evens';\n      assert odds == odds';\n      assert multiset(evens + odds) == multiset([s[0]] + evens' + odds');\n      assert multiset([s[0]] + evens' + odds') == multiset{s[0]} + multiset(evens' + odds');\n      assert multiset(evens' + odds') == multiset(s[1..]);\n      assert multiset{s[0]} + multiset(s[1..]) == multiset(s);\n    } else {\n      assert evens == evens';\n      assert odds == [s[0]] + odds';\n      assert multiset(evens + odds) == multiset(evens' + [s[0]] + odds');\n      assert multiset(evens' + [s[0]] + odds') == multiset{s[0]} + multiset(evens' + odds');\n      assert multiset(evens' + odds') == multiset(s[1..]);\n      \n/*[CODE HERE]*/\n    }\n  }\n}", "output": "assert multiset{s[0]} + multiset(s[1..]) == multiset(s);"}, {"id": "example_partitionCorrect_1", "type": "assert", "program": "function partition(s: seq<int>): (seq<int>, seq<int>)\n{\n  if |s| == 0 then ([], [])\n  else\n    var (evens, odds) := partition(s[1..]);\n    if isEven(s[0]) then ([s[0]] + evens, odds)\n    else (evens, [s[0]] + odds)\n}\n\npredicate {:spec} isEven(n: int)\n{\n  n % 2 == 0\n}\n\nlemma partitionCorrect(s: seq<int>)\n  ensures var (evens, odds) := partition(s);\n    (forall x :: x in evens ==> isEven(x)) &&\n    (forall x :: x in odds ==> !isEven(x)) &&\n    |evens| + |odds| == |s| &&\n    multiset(evens + odds) == multiset(s)\n{\n  if |s| == 0 {\n  } else {\n    partitionCorrect(s[1..]);\n    var (evens, odds) := partition(s);\n    var (evens', odds') := partition(s[1..]);\n    \n    if isEven(s[0]) {\n      assert evens == [s[0]] + evens';\n      assert odds == odds';\n      assert multiset(evens + odds) == multiset([s[0]] + evens' + odds');\n      assert multiset([s[0]] + evens' + odds') == multiset{s[0]} + multiset(evens' + odds');\n      assert multiset(evens' + odds') == multiset(s[1..]);\n      assert multiset{s[0]} + multiset(s[1..]) == multiset(s);\n    } else {\n      assert evens == evens';\n      assert odds == [s[0]] + odds';\n      assert multiset(evens + odds) == multiset(evens' + [s[0]] + odds');\n      assert multiset(evens' + [s[0]] + odds') == multiset{s[0]} + multiset(evens' + odds');\n      \n/*[CODE HERE]*/\n      assert multiset{s[0]} + multiset(s[1..]) == multiset(s);\n    }\n  }\n}", "output": "assert multiset(evens' + odds') == multiset(s[1..]);"}, {"id": "example_partitionCorrect_2", "type": "assert", "program": "function partition(s: seq<int>): (seq<int>, seq<int>)\n{\n  if |s| == 0 then ([], [])\n  else\n    var (evens, odds) := partition(s[1..]);\n    if isEven(s[0]) then ([s[0]] + evens, odds)\n    else (evens, [s[0]] + odds)\n}\n\npredicate {:spec} isEven(n: int)\n{\n  n % 2 == 0\n}\n\nlemma partitionCorrect(s: seq<int>)\n  ensures var (evens, odds) := partition(s);\n    (forall x :: x in evens ==> isEven(x)) &&\n    (forall x :: x in odds ==> !isEven(x)) &&\n    |evens| + |odds| == |s| &&\n    multiset(evens + odds) == multiset(s)\n{\n  if |s| == 0 {\n  } else {\n    partitionCorrect(s[1..]);\n    var (evens, odds) := partition(s);\n    var (evens', odds') := partition(s[1..]);\n    \n    if isEven(s[0]) {\n      assert evens == [s[0]] + evens';\n      assert odds == odds';\n      assert multiset(evens + odds) == multiset([s[0]] + evens' + odds');\n      assert multiset([s[0]] + evens' + odds') == multiset{s[0]} + multiset(evens' + odds');\n      assert multiset(evens' + odds') == multiset(s[1..]);\n      assert multiset{s[0]} + multiset(s[1..]) == multiset(s);\n    } else {\n      assert evens == evens';\n      assert odds == [s[0]] + odds';\n      assert multiset(evens + odds) == multiset(evens' + [s[0]] + odds');\n      \n/*[CODE HERE]*/\n      assert multiset(evens' + odds') == multiset(s[1..]);\n      assert multiset{s[0]} + multiset(s[1..]) == multiset(s);\n    }\n  }\n}", "output": "assert multiset(evens' + [s[0]] + odds') == multiset{s[0]} + multiset(evens' + odds');"}, {"id": "example_partitionCorrect_3", "type": "assert", "program": "function partition(s: seq<int>): (seq<int>, seq<int>)\n{\n  if |s| == 0 then ([], [])\n  else\n    var (evens, odds) := partition(s[1..]);\n    if isEven(s[0]) then ([s[0]] + evens, odds)\n    else (evens, [s[0]] + odds)\n}\n\npredicate {:spec} isEven(n: int)\n{\n  n % 2 == 0\n}\n\nlemma partitionCorrect(s: seq<int>)\n  ensures var (evens, odds) := partition(s);\n    (forall x :: x in evens ==> isEven(x)) &&\n    (forall x :: x in odds ==> !isEven(x)) &&\n    |evens| + |odds| == |s| &&\n    multiset(evens + odds) == multiset(s)\n{\n  if |s| == 0 {\n  } else {\n    partitionCorrect(s[1..]);\n    var (evens, odds) := partition(s);\n    var (evens', odds') := partition(s[1..]);\n    \n    if isEven(s[0]) {\n      assert evens == [s[0]] + evens';\n      assert odds == odds';\n      assert multiset(evens + odds) == multiset([s[0]] + evens' + odds');\n      assert multiset([s[0]] + evens' + odds') == multiset{s[0]} + multiset(evens' + odds');\n      assert multiset(evens' + odds') == multiset(s[1..]);\n      assert multiset{s[0]} + multiset(s[1..]) == multiset(s);\n    } else {\n      assert evens == evens';\n      assert odds == [s[0]] + odds';\n      \n/*[CODE HERE]*/\n      assert multiset(evens' + [s[0]] + odds') == multiset{s[0]} + multiset(evens' + odds');\n      assert multiset(evens' + odds') == multiset(s[1..]);\n      assert multiset{s[0]} + multiset(s[1..]) == multiset(s);\n    }\n  }\n}", "output": "assert multiset(evens + odds) == multiset(evens' + [s[0]] + odds');"}, {"id": "example_partitionCorrect_4", "type": "assert", "program": "function partition(s: seq<int>): (seq<int>, seq<int>)\n{\n  if |s| == 0 then ([], [])\n  else\n    var (evens, odds) := partition(s[1..]);\n    if isEven(s[0]) then ([s[0]] + evens, odds)\n    else (evens, [s[0]] + odds)\n}\n\npredicate {:spec} isEven(n: int)\n{\n  n % 2 == 0\n}\n\nlemma partitionCorrect(s: seq<int>)\n  ensures var (evens, odds) := partition(s);\n    (forall x :: x in evens ==> isEven(x)) &&\n    (forall x :: x in odds ==> !isEven(x)) &&\n    |evens| + |odds| == |s| &&\n    multiset(evens + odds) == multiset(s)\n{\n  if |s| == 0 {\n  } else {\n    partitionCorrect(s[1..]);\n    var (evens, odds) := partition(s);\n    var (evens', odds') := partition(s[1..]);\n    \n    if isEven(s[0]) {\n      assert evens == [s[0]] + evens';\n      assert odds == odds';\n      assert multiset(evens + odds) == multiset([s[0]] + evens' + odds');\n      assert multiset([s[0]] + evens' + odds') == multiset{s[0]} + multiset(evens' + odds');\n      assert multiset(evens' + odds') == multiset(s[1..]);\n      assert multiset{s[0]} + multiset(s[1..]) == multiset(s);\n    } else {\n      assert evens == evens';\n      \n/*[CODE HERE]*/\n      assert multiset(evens + odds) == multiset(evens' + [s[0]] + odds');\n      assert multiset(evens' + [s[0]] + odds') == multiset{s[0]} + multiset(evens' + odds');\n      assert multiset(evens' + odds') == multiset(s[1..]);\n      assert multiset{s[0]} + multiset(s[1..]) == multiset(s);\n    }\n  }\n}", "output": "assert odds == [s[0]] + odds';"}, {"id": "example_partitionCorrect_5", "type": "assert", "program": "function partition(s: seq<int>): (seq<int>, seq<int>)\n{\n  if |s| == 0 then ([], [])\n  else\n    var (evens, odds) := partition(s[1..]);\n    if isEven(s[0]) then ([s[0]] + evens, odds)\n    else (evens, [s[0]] + odds)\n}\n\npredicate {:spec} isEven(n: int)\n{\n  n % 2 == 0\n}\n\nlemma partitionCorrect(s: seq<int>)\n  ensures var (evens, odds) := partition(s);\n    (forall x :: x in evens ==> isEven(x)) &&\n    (forall x :: x in odds ==> !isEven(x)) &&\n    |evens| + |odds| == |s| &&\n    multiset(evens + odds) == multiset(s)\n{\n  if |s| == 0 {\n  } else {\n    partitionCorrect(s[1..]);\n    var (evens, odds) := partition(s);\n    var (evens', odds') := partition(s[1..]);\n    \n    if isEven(s[0]) {\n      assert evens == [s[0]] + evens';\n      assert odds == odds';\n      assert multiset(evens + odds) == multiset([s[0]] + evens' + odds');\n      assert multiset([s[0]] + evens' + odds') == multiset{s[0]} + multiset(evens' + odds');\n      assert multiset(evens' + odds') == multiset(s[1..]);\n      assert multiset{s[0]} + multiset(s[1..]) == multiset(s);\n    } else {\n      \n/*[CODE HERE]*/\n      assert odds == [s[0]] + odds';\n      assert multiset(evens + odds) == multiset(evens' + [s[0]] + odds');\n      assert multiset(evens' + [s[0]] + odds') == multiset{s[0]} + multiset(evens' + odds');\n      assert multiset(evens' + odds') == multiset(s[1..]);\n      assert multiset{s[0]} + multiset(s[1..]) == multiset(s);\n    }\n  }\n}", "output": "assert evens == evens';"}, {"id": "example_partitionCorrect_6", "type": "assert", "program": "function partition(s: seq<int>): (seq<int>, seq<int>)\n{\n  if |s| == 0 then ([], [])\n  else\n    var (evens, odds) := partition(s[1..]);\n    if isEven(s[0]) then ([s[0]] + evens, odds)\n    else (evens, [s[0]] + odds)\n}\n\npredicate {:spec} isEven(n: int)\n{\n  n % 2 == 0\n}\n\nlemma partitionCorrect(s: seq<int>)\n  ensures var (evens, odds) := partition(s);\n    (forall x :: x in evens ==> isEven(x)) &&\n    (forall x :: x in odds ==> !isEven(x)) &&\n    |evens| + |odds| == |s| &&\n    multiset(evens + odds) == multiset(s)\n{\n  if |s| == 0 {\n  } else {\n    partitionCorrect(s[1..]);\n    var (evens, odds) := partition(s);\n    var (evens', odds') := partition(s[1..]);\n    \n    if isEven(s[0]) {\n      assert evens == [s[0]] + evens';\n      assert odds == odds';\n      assert multiset(evens + odds) == multiset([s[0]] + evens' + odds');\n      assert multiset([s[0]] + evens' + odds') == multiset{s[0]} + multiset(evens' + odds');\n      assert multiset(evens' + odds') == multiset(s[1..]);\n      \n/*[CODE HERE]*/\n    } else {\n      assert evens == evens';\n      assert odds == [s[0]] + odds';\n      assert multiset(evens + odds) == multiset(evens' + [s[0]] + odds');\n      assert multiset(evens' + [s[0]] + odds') == multiset{s[0]} + multiset(evens' + odds');\n      assert multiset(evens' + odds') == multiset(s[1..]);\n      assert multiset{s[0]} + multiset(s[1..]) == multiset(s);\n    }\n  }\n}", "output": "assert multiset{s[0]} + multiset(s[1..]) == multiset(s);"}, {"id": "example_partitionCorrect_7", "type": "assert", "program": "function partition(s: seq<int>): (seq<int>, seq<int>)\n{\n  if |s| == 0 then ([], [])\n  else\n    var (evens, odds) := partition(s[1..]);\n    if isEven(s[0]) then ([s[0]] + evens, odds)\n    else (evens, [s[0]] + odds)\n}\n\npredicate {:spec} isEven(n: int)\n{\n  n % 2 == 0\n}\n\nlemma partitionCorrect(s: seq<int>)\n  ensures var (evens, odds) := partition(s);\n    (forall x :: x in evens ==> isEven(x)) &&\n    (forall x :: x in odds ==> !isEven(x)) &&\n    |evens| + |odds| == |s| &&\n    multiset(evens + odds) == multiset(s)\n{\n  if |s| == 0 {\n  } else {\n    partitionCorrect(s[1..]);\n    var (evens, odds) := partition(s);\n    var (evens', odds') := partition(s[1..]);\n    \n    if isEven(s[0]) {\n      assert evens == [s[0]] + evens';\n      assert odds == odds';\n      assert multiset(evens + odds) == multiset([s[0]] + evens' + odds');\n      assert multiset([s[0]] + evens' + odds') == multiset{s[0]} + multiset(evens' + odds');\n      \n/*[CODE HERE]*/\n      assert multiset{s[0]} + multiset(s[1..]) == multiset(s);\n    } else {\n      assert evens == evens';\n      assert odds == [s[0]] + odds';\n      assert multiset(evens + odds) == multiset(evens' + [s[0]] + odds');\n      assert multiset(evens' + [s[0]] + odds') == multiset{s[0]} + multiset(evens' + odds');\n      assert multiset(evens' + odds') == multiset(s[1..]);\n      assert multiset{s[0]} + multiset(s[1..]) == multiset(s);\n    }\n  }\n}", "output": "assert multiset(evens' + odds') == multiset(s[1..]);"}, {"id": "example_partitionCorrect_8", "type": "assert", "program": "function partition(s: seq<int>): (seq<int>, seq<int>)\n{\n  if |s| == 0 then ([], [])\n  else\n    var (evens, odds) := partition(s[1..]);\n    if isEven(s[0]) then ([s[0]] + evens, odds)\n    else (evens, [s[0]] + odds)\n}\n\npredicate {:spec} isEven(n: int)\n{\n  n % 2 == 0\n}\n\nlemma partitionCorrect(s: seq<int>)\n  ensures var (evens, odds) := partition(s);\n    (forall x :: x in evens ==> isEven(x)) &&\n    (forall x :: x in odds ==> !isEven(x)) &&\n    |evens| + |odds| == |s| &&\n    multiset(evens + odds) == multiset(s)\n{\n  if |s| == 0 {\n  } else {\n    partitionCorrect(s[1..]);\n    var (evens, odds) := partition(s);\n    var (evens', odds') := partition(s[1..]);\n    \n    if isEven(s[0]) {\n      assert evens == [s[0]] + evens';\n      assert odds == odds';\n      assert multiset(evens + odds) == multiset([s[0]] + evens' + odds');\n      \n/*[CODE HERE]*/\n      assert multiset(evens' + odds') == multiset(s[1..]);\n      assert multiset{s[0]} + multiset(s[1..]) == multiset(s);\n    } else {\n      assert evens == evens';\n      assert odds == [s[0]] + odds';\n      assert multiset(evens + odds) == multiset(evens' + [s[0]] + odds');\n      assert multiset(evens' + [s[0]] + odds') == multiset{s[0]} + multiset(evens' + odds');\n      assert multiset(evens' + odds') == multiset(s[1..]);\n      assert multiset{s[0]} + multiset(s[1..]) == multiset(s);\n    }\n  }\n}", "output": "assert multiset([s[0]] + evens' + odds') == multiset{s[0]} + multiset(evens' + odds');"}, {"id": "example_partitionCorrect_9", "type": "assert", "program": "function partition(s: seq<int>): (seq<int>, seq<int>)\n{\n  if |s| == 0 then ([], [])\n  else\n    var (evens, odds) := partition(s[1..]);\n    if isEven(s[0]) then ([s[0]] + evens, odds)\n    else (evens, [s[0]] + odds)\n}\n\npredicate {:spec} isEven(n: int)\n{\n  n % 2 == 0\n}\n\nlemma partitionCorrect(s: seq<int>)\n  ensures var (evens, odds) := partition(s);\n    (forall x :: x in evens ==> isEven(x)) &&\n    (forall x :: x in odds ==> !isEven(x)) &&\n    |evens| + |odds| == |s| &&\n    multiset(evens + odds) == multiset(s)\n{\n  if |s| == 0 {\n  } else {\n    partitionCorrect(s[1..]);\n    var (evens, odds) := partition(s);\n    var (evens', odds') := partition(s[1..]);\n    \n    if isEven(s[0]) {\n      assert evens == [s[0]] + evens';\n      assert odds == odds';\n      \n/*[CODE HERE]*/\n      assert multiset([s[0]] + evens' + odds') == multiset{s[0]} + multiset(evens' + odds');\n      assert multiset(evens' + odds') == multiset(s[1..]);\n      assert multiset{s[0]} + multiset(s[1..]) == multiset(s);\n    } else {\n      assert evens == evens';\n      assert odds == [s[0]] + odds';\n      assert multiset(evens + odds) == multiset(evens' + [s[0]] + odds');\n      assert multiset(evens' + [s[0]] + odds') == multiset{s[0]} + multiset(evens' + odds');\n      assert multiset(evens' + odds') == multiset(s[1..]);\n      assert multiset{s[0]} + multiset(s[1..]) == multiset(s);\n    }\n  }\n}", "output": "assert multiset(evens + odds) == multiset([s[0]] + evens' + odds');"}, {"id": "example_partitionCorrect_10", "type": "assert", "program": "function partition(s: seq<int>): (seq<int>, seq<int>)\n{\n  if |s| == 0 then ([], [])\n  else\n    var (evens, odds) := partition(s[1..]);\n    if isEven(s[0]) then ([s[0]] + evens, odds)\n    else (evens, [s[0]] + odds)\n}\n\npredicate {:spec} isEven(n: int)\n{\n  n % 2 == 0\n}\n\nlemma partitionCorrect(s: seq<int>)\n  ensures var (evens, odds) := partition(s);\n    (forall x :: x in evens ==> isEven(x)) &&\n    (forall x :: x in odds ==> !isEven(x)) &&\n    |evens| + |odds| == |s| &&\n    multiset(evens + odds) == multiset(s)\n{\n  if |s| == 0 {\n  } else {\n    partitionCorrect(s[1..]);\n    var (evens, odds) := partition(s);\n    var (evens', odds') := partition(s[1..]);\n    \n    if isEven(s[0]) {\n      assert evens == [s[0]] + evens';\n      \n/*[CODE HERE]*/\n      assert multiset(evens + odds) == multiset([s[0]] + evens' + odds');\n      assert multiset([s[0]] + evens' + odds') == multiset{s[0]} + multiset(evens' + odds');\n      assert multiset(evens' + odds') == multiset(s[1..]);\n      assert multiset{s[0]} + multiset(s[1..]) == multiset(s);\n    } else {\n      assert evens == evens';\n      assert odds == [s[0]] + odds';\n      assert multiset(evens + odds) == multiset(evens' + [s[0]] + odds');\n      assert multiset(evens' + [s[0]] + odds') == multiset{s[0]} + multiset(evens' + odds');\n      assert multiset(evens' + odds') == multiset(s[1..]);\n      assert multiset{s[0]} + multiset(s[1..]) == multiset(s);\n    }\n  }\n}", "output": "assert odds == odds';"}, {"id": "example_partitionCorrect_11", "type": "assert", "program": "function partition(s: seq<int>): (seq<int>, seq<int>)\n{\n  if |s| == 0 then ([], [])\n  else\n    var (evens, odds) := partition(s[1..]);\n    if isEven(s[0]) then ([s[0]] + evens, odds)\n    else (evens, [s[0]] + odds)\n}\n\npredicate {:spec} isEven(n: int)\n{\n  n % 2 == 0\n}\n\nlemma partitionCorrect(s: seq<int>)\n  ensures var (evens, odds) := partition(s);\n    (forall x :: x in evens ==> isEven(x)) &&\n    (forall x :: x in odds ==> !isEven(x)) &&\n    |evens| + |odds| == |s| &&\n    multiset(evens + odds) == multiset(s)\n{\n  if |s| == 0 {\n  } else {\n    partitionCorrect(s[1..]);\n    var (evens, odds) := partition(s);\n    var (evens', odds') := partition(s[1..]);\n    \n    if isEven(s[0]) {\n      \n/*[CODE HERE]*/\n      assert odds == odds';\n      assert multiset(evens + odds) == multiset([s[0]] + evens' + odds');\n      assert multiset([s[0]] + evens' + odds') == multiset{s[0]} + multiset(evens' + odds');\n      assert multiset(evens' + odds') == multiset(s[1..]);\n      assert multiset{s[0]} + multiset(s[1..]) == multiset(s);\n    } else {\n      assert evens == evens';\n      assert odds == [s[0]] + odds';\n      assert multiset(evens + odds) == multiset(evens' + [s[0]] + odds');\n      assert multiset(evens' + [s[0]] + odds') == multiset{s[0]} + multiset(evens' + odds');\n      assert multiset(evens' + odds') == multiset(s[1..]);\n      assert multiset{s[0]} + multiset(s[1..]) == multiset(s);\n    }\n  }\n}", "output": "assert evens == [s[0]] + evens';"}, {"id": "example_partitionCorrect_12", "type": "call", "program": "function partition(s: seq<int>): (seq<int>, seq<int>)\n{\n  if |s| == 0 then ([], [])\n  else\n    var (evens, odds) := partition(s[1..]);\n    if isEven(s[0]) then ([s[0]] + evens, odds)\n    else (evens, [s[0]] + odds)\n}\n\npredicate {:spec} isEven(n: int)\n{\n  n % 2 == 0\n}\n\nlemma partitionCorrect(s: seq<int>)\n  ensures var (evens, odds) := partition(s);\n    (forall x :: x in evens ==> isEven(x)) &&\n    (forall x :: x in odds ==> !isEven(x)) &&\n    |evens| + |odds| == |s| &&\n    multiset(evens + odds) == multiset(s)\n{\n  if |s| == 0 {\n  } else {\n    \n/*[CODE HERE]*/\n    var (evens, odds) := partition(s);\n    var (evens', odds') := partition(s[1..]);\n    \n    if isEven(s[0]) {\n      assert evens == [s[0]] + evens';\n      assert odds == odds';\n      assert multiset(evens + odds) == multiset([s[0]] + evens' + odds');\n      assert multiset([s[0]] + evens' + odds') == multiset{s[0]} + multiset(evens' + odds');\n      assert multiset(evens' + odds') == multiset(s[1..]);\n      assert multiset{s[0]} + multiset(s[1..]) == multiset(s);\n    } else {\n      assert evens == evens';\n      assert odds == [s[0]] + odds';\n      assert multiset(evens + odds) == multiset(evens' + [s[0]] + odds');\n      assert multiset(evens' + [s[0]] + odds') == multiset{s[0]} + multiset(evens' + odds');\n      assert multiset(evens' + odds') == multiset(s[1..]);\n      assert multiset{s[0]} + multiset(s[1..]) == multiset(s);\n    }\n  }\n}", "output": "partitionCorrect(s[1..]);"}, {"id": "example_powerAdd_0", "type": "call", "program": "function power(base: int, exp: nat): int\n{\n  if exp == 0 then 1\n  else base * power(base, exp - 1)\n}\n\nfunction {:spec} powerSpec(base: int, exp: nat): int\n  decreases exp\n{\n  if exp == 0 then 1\n  else base * powerSpec(base, exp - 1)\n}\n\nlemma powerCorrect(base: int, exp: nat)\n  ensures power(base, exp) == powerSpec(base, exp)\n{\n}\n\nlemma powerZero(base: int)\n  ensures power(base, 0) == 1\n{\n}\n\nlemma powerOne(base: int)\n  ensures power(base, 1) == base\n{\n  calc {\n    power(base, 1);\n    == base * power(base, 0);\n    == base * 1;\n    == base;\n  }\n}\n\nlemma powerAdd(base: int, exp1: nat, exp2: nat)\n  ensures power(base, exp1 + exp2) == power(base, exp1) * power(base, exp2)\n{\n  if exp1 == 0 {\n    calc {\n      power(base, exp1 + exp2);\n      == power(base, 0 + exp2);\n      == power(base, exp2);\n      == 1 * power(base, exp2);\n      == power(base, 0) * power(base, exp2);\n      == power(base, exp1) * power(base, exp2);\n    }\n  } else {\n    powerAdd(base, exp1 - 1, exp2);\n    calc {\n      power(base, exp1 + exp2);\n      == { assert exp1 + exp2 == (exp1 - 1) + exp2 + 1; }\n      power(base, (exp1 - 1) + exp2 + 1);\n      == base * power(base, (exp1 - 1) + exp2);\n      == { \n/*[CODE HERE]*/\n}\n      base * (power(base, exp1 - 1) * power(base, exp2));\n      == (base * power(base, exp1 - 1)) * power(base, exp2);\n      == power(base, exp1) * power(base, exp2);\n    }\n  }\n}", "output": "powerAdd(base, exp1 - 1, exp2);"}, {"id": "example_powerAdd_1", "type": "assert", "program": "function power(base: int, exp: nat): int\n{\n  if exp == 0 then 1\n  else base * power(base, exp - 1)\n}\n\nfunction {:spec} powerSpec(base: int, exp: nat): int\n  decreases exp\n{\n  if exp == 0 then 1\n  else base * powerSpec(base, exp - 1)\n}\n\nlemma powerCorrect(base: int, exp: nat)\n  ensures power(base, exp) == powerSpec(base, exp)\n{\n}\n\nlemma powerZero(base: int)\n  ensures power(base, 0) == 1\n{\n}\n\nlemma powerOne(base: int)\n  ensures power(base, 1) == base\n{\n  calc {\n    power(base, 1);\n    == base * power(base, 0);\n    == base * 1;\n    == base;\n  }\n}\n\nlemma powerAdd(base: int, exp1: nat, exp2: nat)\n  ensures power(base, exp1 + exp2) == power(base, exp1) * power(base, exp2)\n{\n  if exp1 == 0 {\n    calc {\n      power(base, exp1 + exp2);\n      == power(base, 0 + exp2);\n      == power(base, exp2);\n      == 1 * power(base, exp2);\n      == power(base, 0) * power(base, exp2);\n      == power(base, exp1) * power(base, exp2);\n    }\n  } else {\n    powerAdd(base, exp1 - 1, exp2);\n    calc {\n      power(base, exp1 + exp2);\n      == { \n/*[CODE HERE]*/\n}\n      power(base, (exp1 - 1) + exp2 + 1);\n      == base * power(base, (exp1 - 1) + exp2);\n      == { powerAdd(base, exp1 - 1, exp2); }\n      base * (power(base, exp1 - 1) * power(base, exp2));\n      == (base * power(base, exp1 - 1)) * power(base, exp2);\n      == power(base, exp1) * power(base, exp2);\n    }\n  }\n}", "output": "assert exp1 + exp2 == (exp1 - 1) + exp2 + 1;"}, {"id": "example_powerAdd_2", "type": "call", "program": "function power(base: int, exp: nat): int\n{\n  if exp == 0 then 1\n  else base * power(base, exp - 1)\n}\n\nfunction {:spec} powerSpec(base: int, exp: nat): int\n  decreases exp\n{\n  if exp == 0 then 1\n  else base * powerSpec(base, exp - 1)\n}\n\nlemma powerCorrect(base: int, exp: nat)\n  ensures power(base, exp) == powerSpec(base, exp)\n{\n}\n\nlemma powerZero(base: int)\n  ensures power(base, 0) == 1\n{\n}\n\nlemma powerOne(base: int)\n  ensures power(base, 1) == base\n{\n  calc {\n    power(base, 1);\n    == base * power(base, 0);\n    == base * 1;\n    == base;\n  }\n}\n\nlemma powerAdd(base: int, exp1: nat, exp2: nat)\n  ensures power(base, exp1 + exp2) == power(base, exp1) * power(base, exp2)\n{\n  if exp1 == 0 {\n    calc {\n      power(base, exp1 + exp2);\n      == power(base, 0 + exp2);\n      == power(base, exp2);\n      == 1 * power(base, exp2);\n      == power(base, 0) * power(base, exp2);\n      == power(base, exp1) * power(base, exp2);\n    }\n  } else {\n    \n/*[CODE HERE]*/\n    calc {\n      power(base, exp1 + exp2);\n      == { assert exp1 + exp2 == (exp1 - 1) + exp2 + 1; }\n      power(base, (exp1 - 1) + exp2 + 1);\n      == base * power(base, (exp1 - 1) + exp2);\n      == { powerAdd(base, exp1 - 1, exp2); }\n      base * (power(base, exp1 - 1) * power(base, exp2));\n      == (base * power(base, exp1 - 1)) * power(base, exp2);\n      == power(base, exp1) * power(base, exp2);\n    }\n  }\n}", "output": "powerAdd(base, exp1 - 1, exp2);"}, {"id": "example_ReverseLength_0", "type": "assert", "program": "// Queue operations: enqueue, dequeue, isEmpty, size\n\ndatatype Queue<T> = Queue(front: seq<T>, rear: seq<T>)\n\nfunction {:spec} queueEmpty<T>(): Queue<T>\n{\n  Queue([], [])\n}\n\npredicate {:spec} queueIsEmpty<T>(q: Queue<T>)\n{\n  q.front == [] && q.rear == []\n}\n\nfunction {:spec} enqueue<T>(q: Queue<T>, x: T): Queue<T>\n{\n  Queue(q.front, [x] + q.rear)\n}\n\nfunction {:spec} dequeue<T>(q: Queue<T>): Queue<T>\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    Queue(q.front[1..], q.rear)\n  else\n    // Front is empty, so we reverse rear and put it in front\n    if |q.rear| == 1 then\n      Queue([], [])\n    else\n      Queue(reverse(q.rear)[1..], [])\n}\n\nfunction {:spec} queueFront<T>(q: Queue<T>): T\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    q.front[0]\n  else\n    // Front is empty, so the front element is the first element of rear (when reversed)\n    q.rear[|q.rear| - 1]\n}\n\nfunction {:spec} queueSize<T>(q: Queue<T>): nat\n{\n  |q.front| + |q.rear|\n}\n\nfunction {:spec} queueToSeq<T>(q: Queue<T>): seq<T>\n{\n  q.front + reverse(q.rear)\n}\n\nfunction reverse<T>(s: seq<T>): seq<T>\n{\n  if |s| == 0 then []\n  else reverse(s[1..]) + [s[0]]\n}\n\n// Alternative queue representation with invariant\ndatatype SimpleQueue<T> = SimpleQueue(elements: seq<T>)\n\nfunction {:spec} simpleQueueEmpty<T>(): SimpleQueue<T>\n{\n  SimpleQueue([])\n}\n\npredicate {:spec} simpleQueueIsEmpty<T>(q: SimpleQueue<T>)\n{\n  q.elements == []\n}\n\nfunction {:spec} simpleEnqueue<T>(q: SimpleQueue<T>, x: T): SimpleQueue<T>\n{\n  SimpleQueue(q.elements + [x])\n}\n\nfunction {:spec} simpleDequeue<T>(q: SimpleQueue<T>): SimpleQueue<T>\n  requires !simpleQueueIsEmpty(q)\n{\n  SimpleQueue(q.elements[1..])\n}\n\nfunction {:spec} simpleQueueFront<T>(q: SimpleQueue<T>): T\n  requires !simpleQueueIsEmpty(q)\n{\n  q.elements[0]\n}\n\nfunction {:spec} simpleQueueSize<T>(q: SimpleQueue<T>): nat\n{\n  |q.elements|\n}\n\nlemma ReverseLength<T>(s: seq<T>)\n  ensures |reverse(s)| == |s|\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseLength(s[1..]);\n    \n/*[CODE HERE]*/\n  }\n}\n\nlemma ReverseReverse<T>(s: seq<T>)\n  ensures reverse(reverse(s)) == s\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseReverse(s[1..]);\n    ReverseAppend(reverse(s[1..]), [s[0]]);\n    assert reverse(reverse(s)) == s;\n  }\n}\n\nlemma ReverseAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n  } else {\n    assert s1 + s2 == [s1[0]] + (s1[1..] + s2);\n    ReverseAppend(s1[1..], s2);\n  }\n}\n\nlemma ReverseFirst<T>(s: seq<T>)\n  requires |s| > 0\n  ensures |reverse(s)| == |s|\n  ensures reverse(s)[|reverse(s)| - 1] == s[0]\n  ensures reverse(s)[0] == s[|s| - 1]\n{\n  ReverseLength(s);\n  if |s| == 1 {\n    assert reverse(s) == [s[0]];\n  } else {\n    ReverseFirst(s[1..]);\n    assert reverse(s) == reverse(s[1..]) + [s[0]];\n    ReverseLength(s[1..]);\n    assert |reverse(s[1..])| == |s| - 1;\n  }\n}\n\nlemma SeqAssoc<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures a + (b + c) == (a + b) + c\n{\n  // Dafny proves this automatically\n}\n\nlemma QueueSizeProperty<T>(q: Queue<T>)\n  ensures queueSize(q) == |queueToSeq(q)|\n{\n  ReverseLength(q.rear);\n}\n\nlemma EnqueueCorrect<T>(q: Queue<T>, x: T)\n  ensures queueToSeq(enqueue(q, x)) == queueToSeq(q) + [x]\n  ensures queueSize(enqueue(q, x)) == queueSize(q) + 1\n{\n  var q' := enqueue(q, x);\n  assert q'.front == q.front;\n  assert q'.rear == [x] + q.rear;\n\n  ReverseAppend([x], q.rear);\n  assert reverse([x]) == [x];\n  assert reverse([x] + q.rear) == reverse(q.rear) + reverse([x]);\n  assert reverse([x] + q.rear) == reverse(q.rear) + [x];\n\n  calc == {\n    queueToSeq(q');\n    q'.front + reverse(q'.rear);\n    q.front + reverse([x] + q.rear);\n    q.front + (reverse(q.rear) + [x]);\n    { SeqAssoc(q.front, reverse(q.rear), [x]); }\n    (q.front + reverse(q.rear)) + [x];\n    queueToSeq(q) + [x];\n  }\n\n  QueueSizeProperty(q);\n  QueueSizeProperty(q');\n}\n\nlemma DequeueCorrect<T>(q: Queue<T>)\n  requires !queueIsEmpty(q)\n  ensures |queueToSeq(q)| > 0\n  ensures queueToSeq(dequeue(q)) == queueToSeq(q)[1..]\n  ensures queueFront(q) == queueToSeq(q)[0]\n{\n  if |q.front| > 0 {\n    assert queueToSeq(q) == q.front + reverse(q.rear);\n    assert queueToSeq(dequeue(q)) == q.front[1..] + reverse(q.rear);\n    assert queueFront(q) == q.front[0];\n  } else {\n    assert q.front == [];\n    assert |q.rear| > 0;\n    var rev := reverse(q.rear);\n    ReverseLength(q.rear);\n    assert |rev| == |q.rear|;\n    assert queueToSeq(q) == rev;\n    assert queueFront(q) == q.rear[|q.rear| - 1];\n\n    ReverseFirst(q.rear);\n    assert rev[0] == q.rear[|q.rear| - 1];\n\n    if |q.rear| == 1 {\n      assert rev == [q.rear[0]];\n      assert queueToSeq(q) == [q.rear[0]];\n      assert queueFront(q) == q.rear[0];\n      assert queueToSeq(q)[0] == q.rear[0];\n    } else {\n      assert |rev| > 1;\n      assert queueToSeq(dequeue(q)) == rev[1..];\n      assert queueFront(q) == rev[0];\n    }\n  }\n}\n\nlemma SimpleQueueEquivalence<T>(sq: SimpleQueue<T>, q: Queue<T>)\n  requires sq.elements == queueToSeq(q)\n  ensures simpleQueueIsEmpty(sq) == queueIsEmpty(q)\n  ensures simpleQueueSize(sq) == queueSize(q)\n{\n  if queueIsEmpty(q) {\n    assert q.front == [] && q.rear == [];\n    assert queueToSeq(q) == [];\n    assert sq.elements == [];\n  }\n  QueueSizeProperty(q);\n}", "output": "assert |reverse(s)| == |reverse(s[1..])| + 1;"}, {"id": "example_ReverseLength_1", "type": "call", "program": "// Queue operations: enqueue, dequeue, isEmpty, size\n\ndatatype Queue<T> = Queue(front: seq<T>, rear: seq<T>)\n\nfunction {:spec} queueEmpty<T>(): Queue<T>\n{\n  Queue([], [])\n}\n\npredicate {:spec} queueIsEmpty<T>(q: Queue<T>)\n{\n  q.front == [] && q.rear == []\n}\n\nfunction {:spec} enqueue<T>(q: Queue<T>, x: T): Queue<T>\n{\n  Queue(q.front, [x] + q.rear)\n}\n\nfunction {:spec} dequeue<T>(q: Queue<T>): Queue<T>\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    Queue(q.front[1..], q.rear)\n  else\n    // Front is empty, so we reverse rear and put it in front\n    if |q.rear| == 1 then\n      Queue([], [])\n    else\n      Queue(reverse(q.rear)[1..], [])\n}\n\nfunction {:spec} queueFront<T>(q: Queue<T>): T\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    q.front[0]\n  else\n    // Front is empty, so the front element is the first element of rear (when reversed)\n    q.rear[|q.rear| - 1]\n}\n\nfunction {:spec} queueSize<T>(q: Queue<T>): nat\n{\n  |q.front| + |q.rear|\n}\n\nfunction {:spec} queueToSeq<T>(q: Queue<T>): seq<T>\n{\n  q.front + reverse(q.rear)\n}\n\nfunction reverse<T>(s: seq<T>): seq<T>\n{\n  if |s| == 0 then []\n  else reverse(s[1..]) + [s[0]]\n}\n\n// Alternative queue representation with invariant\ndatatype SimpleQueue<T> = SimpleQueue(elements: seq<T>)\n\nfunction {:spec} simpleQueueEmpty<T>(): SimpleQueue<T>\n{\n  SimpleQueue([])\n}\n\npredicate {:spec} simpleQueueIsEmpty<T>(q: SimpleQueue<T>)\n{\n  q.elements == []\n}\n\nfunction {:spec} simpleEnqueue<T>(q: SimpleQueue<T>, x: T): SimpleQueue<T>\n{\n  SimpleQueue(q.elements + [x])\n}\n\nfunction {:spec} simpleDequeue<T>(q: SimpleQueue<T>): SimpleQueue<T>\n  requires !simpleQueueIsEmpty(q)\n{\n  SimpleQueue(q.elements[1..])\n}\n\nfunction {:spec} simpleQueueFront<T>(q: SimpleQueue<T>): T\n  requires !simpleQueueIsEmpty(q)\n{\n  q.elements[0]\n}\n\nfunction {:spec} simpleQueueSize<T>(q: SimpleQueue<T>): nat\n{\n  |q.elements|\n}\n\nlemma ReverseLength<T>(s: seq<T>)\n  ensures |reverse(s)| == |s|\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    \n/*[CODE HERE]*/\n    assert |reverse(s)| == |reverse(s[1..])| + 1;\n  }\n}\n\nlemma ReverseReverse<T>(s: seq<T>)\n  ensures reverse(reverse(s)) == s\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseReverse(s[1..]);\n    ReverseAppend(reverse(s[1..]), [s[0]]);\n    assert reverse(reverse(s)) == s;\n  }\n}\n\nlemma ReverseAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n  } else {\n    assert s1 + s2 == [s1[0]] + (s1[1..] + s2);\n    ReverseAppend(s1[1..], s2);\n  }\n}\n\nlemma ReverseFirst<T>(s: seq<T>)\n  requires |s| > 0\n  ensures |reverse(s)| == |s|\n  ensures reverse(s)[|reverse(s)| - 1] == s[0]\n  ensures reverse(s)[0] == s[|s| - 1]\n{\n  ReverseLength(s);\n  if |s| == 1 {\n    assert reverse(s) == [s[0]];\n  } else {\n    ReverseFirst(s[1..]);\n    assert reverse(s) == reverse(s[1..]) + [s[0]];\n    ReverseLength(s[1..]);\n    assert |reverse(s[1..])| == |s| - 1;\n  }\n}\n\nlemma SeqAssoc<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures a + (b + c) == (a + b) + c\n{\n  // Dafny proves this automatically\n}\n\nlemma QueueSizeProperty<T>(q: Queue<T>)\n  ensures queueSize(q) == |queueToSeq(q)|\n{\n  ReverseLength(q.rear);\n}\n\nlemma EnqueueCorrect<T>(q: Queue<T>, x: T)\n  ensures queueToSeq(enqueue(q, x)) == queueToSeq(q) + [x]\n  ensures queueSize(enqueue(q, x)) == queueSize(q) + 1\n{\n  var q' := enqueue(q, x);\n  assert q'.front == q.front;\n  assert q'.rear == [x] + q.rear;\n\n  ReverseAppend([x], q.rear);\n  assert reverse([x]) == [x];\n  assert reverse([x] + q.rear) == reverse(q.rear) + reverse([x]);\n  assert reverse([x] + q.rear) == reverse(q.rear) + [x];\n\n  calc == {\n    queueToSeq(q');\n    q'.front + reverse(q'.rear);\n    q.front + reverse([x] + q.rear);\n    q.front + (reverse(q.rear) + [x]);\n    { SeqAssoc(q.front, reverse(q.rear), [x]); }\n    (q.front + reverse(q.rear)) + [x];\n    queueToSeq(q) + [x];\n  }\n\n  QueueSizeProperty(q);\n  QueueSizeProperty(q');\n}\n\nlemma DequeueCorrect<T>(q: Queue<T>)\n  requires !queueIsEmpty(q)\n  ensures |queueToSeq(q)| > 0\n  ensures queueToSeq(dequeue(q)) == queueToSeq(q)[1..]\n  ensures queueFront(q) == queueToSeq(q)[0]\n{\n  if |q.front| > 0 {\n    assert queueToSeq(q) == q.front + reverse(q.rear);\n    assert queueToSeq(dequeue(q)) == q.front[1..] + reverse(q.rear);\n    assert queueFront(q) == q.front[0];\n  } else {\n    assert q.front == [];\n    assert |q.rear| > 0;\n    var rev := reverse(q.rear);\n    ReverseLength(q.rear);\n    assert |rev| == |q.rear|;\n    assert queueToSeq(q) == rev;\n    assert queueFront(q) == q.rear[|q.rear| - 1];\n\n    ReverseFirst(q.rear);\n    assert rev[0] == q.rear[|q.rear| - 1];\n\n    if |q.rear| == 1 {\n      assert rev == [q.rear[0]];\n      assert queueToSeq(q) == [q.rear[0]];\n      assert queueFront(q) == q.rear[0];\n      assert queueToSeq(q)[0] == q.rear[0];\n    } else {\n      assert |rev| > 1;\n      assert queueToSeq(dequeue(q)) == rev[1..];\n      assert queueFront(q) == rev[0];\n    }\n  }\n}\n\nlemma SimpleQueueEquivalence<T>(sq: SimpleQueue<T>, q: Queue<T>)\n  requires sq.elements == queueToSeq(q)\n  ensures simpleQueueIsEmpty(sq) == queueIsEmpty(q)\n  ensures simpleQueueSize(sq) == queueSize(q)\n{\n  if queueIsEmpty(q) {\n    assert q.front == [] && q.rear == [];\n    assert queueToSeq(q) == [];\n    assert sq.elements == [];\n  }\n  QueueSizeProperty(q);\n}", "output": "ReverseLength(s[1..]);"}, {"id": "example_ReverseReverse_0", "type": "assert", "program": "// Queue operations: enqueue, dequeue, isEmpty, size\n\ndatatype Queue<T> = Queue(front: seq<T>, rear: seq<T>)\n\nfunction {:spec} queueEmpty<T>(): Queue<T>\n{\n  Queue([], [])\n}\n\npredicate {:spec} queueIsEmpty<T>(q: Queue<T>)\n{\n  q.front == [] && q.rear == []\n}\n\nfunction {:spec} enqueue<T>(q: Queue<T>, x: T): Queue<T>\n{\n  Queue(q.front, [x] + q.rear)\n}\n\nfunction {:spec} dequeue<T>(q: Queue<T>): Queue<T>\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    Queue(q.front[1..], q.rear)\n  else\n    // Front is empty, so we reverse rear and put it in front\n    if |q.rear| == 1 then\n      Queue([], [])\n    else\n      Queue(reverse(q.rear)[1..], [])\n}\n\nfunction {:spec} queueFront<T>(q: Queue<T>): T\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    q.front[0]\n  else\n    // Front is empty, so the front element is the first element of rear (when reversed)\n    q.rear[|q.rear| - 1]\n}\n\nfunction {:spec} queueSize<T>(q: Queue<T>): nat\n{\n  |q.front| + |q.rear|\n}\n\nfunction {:spec} queueToSeq<T>(q: Queue<T>): seq<T>\n{\n  q.front + reverse(q.rear)\n}\n\nfunction reverse<T>(s: seq<T>): seq<T>\n{\n  if |s| == 0 then []\n  else reverse(s[1..]) + [s[0]]\n}\n\n// Alternative queue representation with invariant\ndatatype SimpleQueue<T> = SimpleQueue(elements: seq<T>)\n\nfunction {:spec} simpleQueueEmpty<T>(): SimpleQueue<T>\n{\n  SimpleQueue([])\n}\n\npredicate {:spec} simpleQueueIsEmpty<T>(q: SimpleQueue<T>)\n{\n  q.elements == []\n}\n\nfunction {:spec} simpleEnqueue<T>(q: SimpleQueue<T>, x: T): SimpleQueue<T>\n{\n  SimpleQueue(q.elements + [x])\n}\n\nfunction {:spec} simpleDequeue<T>(q: SimpleQueue<T>): SimpleQueue<T>\n  requires !simpleQueueIsEmpty(q)\n{\n  SimpleQueue(q.elements[1..])\n}\n\nfunction {:spec} simpleQueueFront<T>(q: SimpleQueue<T>): T\n  requires !simpleQueueIsEmpty(q)\n{\n  q.elements[0]\n}\n\nfunction {:spec} simpleQueueSize<T>(q: SimpleQueue<T>): nat\n{\n  |q.elements|\n}\n\nlemma ReverseLength<T>(s: seq<T>)\n  ensures |reverse(s)| == |s|\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseLength(s[1..]);\n    assert |reverse(s)| == |reverse(s[1..])| + 1;\n  }\n}\n\nlemma ReverseReverse<T>(s: seq<T>)\n  ensures reverse(reverse(s)) == s\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseReverse(s[1..]);\n    ReverseAppend(reverse(s[1..]), [s[0]]);\n    \n/*[CODE HERE]*/\n  }\n}\n\nlemma ReverseAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n  } else {\n    assert s1 + s2 == [s1[0]] + (s1[1..] + s2);\n    ReverseAppend(s1[1..], s2);\n  }\n}\n\nlemma ReverseFirst<T>(s: seq<T>)\n  requires |s| > 0\n  ensures |reverse(s)| == |s|\n  ensures reverse(s)[|reverse(s)| - 1] == s[0]\n  ensures reverse(s)[0] == s[|s| - 1]\n{\n  ReverseLength(s);\n  if |s| == 1 {\n    assert reverse(s) == [s[0]];\n  } else {\n    ReverseFirst(s[1..]);\n    assert reverse(s) == reverse(s[1..]) + [s[0]];\n    ReverseLength(s[1..]);\n    assert |reverse(s[1..])| == |s| - 1;\n  }\n}\n\nlemma SeqAssoc<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures a + (b + c) == (a + b) + c\n{\n  // Dafny proves this automatically\n}\n\nlemma QueueSizeProperty<T>(q: Queue<T>)\n  ensures queueSize(q) == |queueToSeq(q)|\n{\n  ReverseLength(q.rear);\n}\n\nlemma EnqueueCorrect<T>(q: Queue<T>, x: T)\n  ensures queueToSeq(enqueue(q, x)) == queueToSeq(q) + [x]\n  ensures queueSize(enqueue(q, x)) == queueSize(q) + 1\n{\n  var q' := enqueue(q, x);\n  assert q'.front == q.front;\n  assert q'.rear == [x] + q.rear;\n\n  ReverseAppend([x], q.rear);\n  assert reverse([x]) == [x];\n  assert reverse([x] + q.rear) == reverse(q.rear) + reverse([x]);\n  assert reverse([x] + q.rear) == reverse(q.rear) + [x];\n\n  calc == {\n    queueToSeq(q');\n    q'.front + reverse(q'.rear);\n    q.front + reverse([x] + q.rear);\n    q.front + (reverse(q.rear) + [x]);\n    { SeqAssoc(q.front, reverse(q.rear), [x]); }\n    (q.front + reverse(q.rear)) + [x];\n    queueToSeq(q) + [x];\n  }\n\n  QueueSizeProperty(q);\n  QueueSizeProperty(q');\n}\n\nlemma DequeueCorrect<T>(q: Queue<T>)\n  requires !queueIsEmpty(q)\n  ensures |queueToSeq(q)| > 0\n  ensures queueToSeq(dequeue(q)) == queueToSeq(q)[1..]\n  ensures queueFront(q) == queueToSeq(q)[0]\n{\n  if |q.front| > 0 {\n    assert queueToSeq(q) == q.front + reverse(q.rear);\n    assert queueToSeq(dequeue(q)) == q.front[1..] + reverse(q.rear);\n    assert queueFront(q) == q.front[0];\n  } else {\n    assert q.front == [];\n    assert |q.rear| > 0;\n    var rev := reverse(q.rear);\n    ReverseLength(q.rear);\n    assert |rev| == |q.rear|;\n    assert queueToSeq(q) == rev;\n    assert queueFront(q) == q.rear[|q.rear| - 1];\n\n    ReverseFirst(q.rear);\n    assert rev[0] == q.rear[|q.rear| - 1];\n\n    if |q.rear| == 1 {\n      assert rev == [q.rear[0]];\n      assert queueToSeq(q) == [q.rear[0]];\n      assert queueFront(q) == q.rear[0];\n      assert queueToSeq(q)[0] == q.rear[0];\n    } else {\n      assert |rev| > 1;\n      assert queueToSeq(dequeue(q)) == rev[1..];\n      assert queueFront(q) == rev[0];\n    }\n  }\n}\n\nlemma SimpleQueueEquivalence<T>(sq: SimpleQueue<T>, q: Queue<T>)\n  requires sq.elements == queueToSeq(q)\n  ensures simpleQueueIsEmpty(sq) == queueIsEmpty(q)\n  ensures simpleQueueSize(sq) == queueSize(q)\n{\n  if queueIsEmpty(q) {\n    assert q.front == [] && q.rear == [];\n    assert queueToSeq(q) == [];\n    assert sq.elements == [];\n  }\n  QueueSizeProperty(q);\n}", "output": "assert reverse(reverse(s)) == s;"}, {"id": "example_ReverseReverse_1", "type": "call", "program": "// Queue operations: enqueue, dequeue, isEmpty, size\n\ndatatype Queue<T> = Queue(front: seq<T>, rear: seq<T>)\n\nfunction {:spec} queueEmpty<T>(): Queue<T>\n{\n  Queue([], [])\n}\n\npredicate {:spec} queueIsEmpty<T>(q: Queue<T>)\n{\n  q.front == [] && q.rear == []\n}\n\nfunction {:spec} enqueue<T>(q: Queue<T>, x: T): Queue<T>\n{\n  Queue(q.front, [x] + q.rear)\n}\n\nfunction {:spec} dequeue<T>(q: Queue<T>): Queue<T>\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    Queue(q.front[1..], q.rear)\n  else\n    // Front is empty, so we reverse rear and put it in front\n    if |q.rear| == 1 then\n      Queue([], [])\n    else\n      Queue(reverse(q.rear)[1..], [])\n}\n\nfunction {:spec} queueFront<T>(q: Queue<T>): T\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    q.front[0]\n  else\n    // Front is empty, so the front element is the first element of rear (when reversed)\n    q.rear[|q.rear| - 1]\n}\n\nfunction {:spec} queueSize<T>(q: Queue<T>): nat\n{\n  |q.front| + |q.rear|\n}\n\nfunction {:spec} queueToSeq<T>(q: Queue<T>): seq<T>\n{\n  q.front + reverse(q.rear)\n}\n\nfunction reverse<T>(s: seq<T>): seq<T>\n{\n  if |s| == 0 then []\n  else reverse(s[1..]) + [s[0]]\n}\n\n// Alternative queue representation with invariant\ndatatype SimpleQueue<T> = SimpleQueue(elements: seq<T>)\n\nfunction {:spec} simpleQueueEmpty<T>(): SimpleQueue<T>\n{\n  SimpleQueue([])\n}\n\npredicate {:spec} simpleQueueIsEmpty<T>(q: SimpleQueue<T>)\n{\n  q.elements == []\n}\n\nfunction {:spec} simpleEnqueue<T>(q: SimpleQueue<T>, x: T): SimpleQueue<T>\n{\n  SimpleQueue(q.elements + [x])\n}\n\nfunction {:spec} simpleDequeue<T>(q: SimpleQueue<T>): SimpleQueue<T>\n  requires !simpleQueueIsEmpty(q)\n{\n  SimpleQueue(q.elements[1..])\n}\n\nfunction {:spec} simpleQueueFront<T>(q: SimpleQueue<T>): T\n  requires !simpleQueueIsEmpty(q)\n{\n  q.elements[0]\n}\n\nfunction {:spec} simpleQueueSize<T>(q: SimpleQueue<T>): nat\n{\n  |q.elements|\n}\n\nlemma ReverseLength<T>(s: seq<T>)\n  ensures |reverse(s)| == |s|\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseLength(s[1..]);\n    assert |reverse(s)| == |reverse(s[1..])| + 1;\n  }\n}\n\nlemma ReverseReverse<T>(s: seq<T>)\n  ensures reverse(reverse(s)) == s\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseReverse(s[1..]);\n    \n/*[CODE HERE]*/\n    assert reverse(reverse(s)) == s;\n  }\n}\n\nlemma ReverseAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n  } else {\n    assert s1 + s2 == [s1[0]] + (s1[1..] + s2);\n    ReverseAppend(s1[1..], s2);\n  }\n}\n\nlemma ReverseFirst<T>(s: seq<T>)\n  requires |s| > 0\n  ensures |reverse(s)| == |s|\n  ensures reverse(s)[|reverse(s)| - 1] == s[0]\n  ensures reverse(s)[0] == s[|s| - 1]\n{\n  ReverseLength(s);\n  if |s| == 1 {\n    assert reverse(s) == [s[0]];\n  } else {\n    ReverseFirst(s[1..]);\n    assert reverse(s) == reverse(s[1..]) + [s[0]];\n    ReverseLength(s[1..]);\n    assert |reverse(s[1..])| == |s| - 1;\n  }\n}\n\nlemma SeqAssoc<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures a + (b + c) == (a + b) + c\n{\n  // Dafny proves this automatically\n}\n\nlemma QueueSizeProperty<T>(q: Queue<T>)\n  ensures queueSize(q) == |queueToSeq(q)|\n{\n  ReverseLength(q.rear);\n}\n\nlemma EnqueueCorrect<T>(q: Queue<T>, x: T)\n  ensures queueToSeq(enqueue(q, x)) == queueToSeq(q) + [x]\n  ensures queueSize(enqueue(q, x)) == queueSize(q) + 1\n{\n  var q' := enqueue(q, x);\n  assert q'.front == q.front;\n  assert q'.rear == [x] + q.rear;\n\n  ReverseAppend([x], q.rear);\n  assert reverse([x]) == [x];\n  assert reverse([x] + q.rear) == reverse(q.rear) + reverse([x]);\n  assert reverse([x] + q.rear) == reverse(q.rear) + [x];\n\n  calc == {\n    queueToSeq(q');\n    q'.front + reverse(q'.rear);\n    q.front + reverse([x] + q.rear);\n    q.front + (reverse(q.rear) + [x]);\n    { SeqAssoc(q.front, reverse(q.rear), [x]); }\n    (q.front + reverse(q.rear)) + [x];\n    queueToSeq(q) + [x];\n  }\n\n  QueueSizeProperty(q);\n  QueueSizeProperty(q');\n}\n\nlemma DequeueCorrect<T>(q: Queue<T>)\n  requires !queueIsEmpty(q)\n  ensures |queueToSeq(q)| > 0\n  ensures queueToSeq(dequeue(q)) == queueToSeq(q)[1..]\n  ensures queueFront(q) == queueToSeq(q)[0]\n{\n  if |q.front| > 0 {\n    assert queueToSeq(q) == q.front + reverse(q.rear);\n    assert queueToSeq(dequeue(q)) == q.front[1..] + reverse(q.rear);\n    assert queueFront(q) == q.front[0];\n  } else {\n    assert q.front == [];\n    assert |q.rear| > 0;\n    var rev := reverse(q.rear);\n    ReverseLength(q.rear);\n    assert |rev| == |q.rear|;\n    assert queueToSeq(q) == rev;\n    assert queueFront(q) == q.rear[|q.rear| - 1];\n\n    ReverseFirst(q.rear);\n    assert rev[0] == q.rear[|q.rear| - 1];\n\n    if |q.rear| == 1 {\n      assert rev == [q.rear[0]];\n      assert queueToSeq(q) == [q.rear[0]];\n      assert queueFront(q) == q.rear[0];\n      assert queueToSeq(q)[0] == q.rear[0];\n    } else {\n      assert |rev| > 1;\n      assert queueToSeq(dequeue(q)) == rev[1..];\n      assert queueFront(q) == rev[0];\n    }\n  }\n}\n\nlemma SimpleQueueEquivalence<T>(sq: SimpleQueue<T>, q: Queue<T>)\n  requires sq.elements == queueToSeq(q)\n  ensures simpleQueueIsEmpty(sq) == queueIsEmpty(q)\n  ensures simpleQueueSize(sq) == queueSize(q)\n{\n  if queueIsEmpty(q) {\n    assert q.front == [] && q.rear == [];\n    assert queueToSeq(q) == [];\n    assert sq.elements == [];\n  }\n  QueueSizeProperty(q);\n}", "output": "ReverseAppend(reverse(s[1..]), [s[0]]);"}, {"id": "example_ReverseReverse_2", "type": "call", "program": "// Queue operations: enqueue, dequeue, isEmpty, size\n\ndatatype Queue<T> = Queue(front: seq<T>, rear: seq<T>)\n\nfunction {:spec} queueEmpty<T>(): Queue<T>\n{\n  Queue([], [])\n}\n\npredicate {:spec} queueIsEmpty<T>(q: Queue<T>)\n{\n  q.front == [] && q.rear == []\n}\n\nfunction {:spec} enqueue<T>(q: Queue<T>, x: T): Queue<T>\n{\n  Queue(q.front, [x] + q.rear)\n}\n\nfunction {:spec} dequeue<T>(q: Queue<T>): Queue<T>\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    Queue(q.front[1..], q.rear)\n  else\n    // Front is empty, so we reverse rear and put it in front\n    if |q.rear| == 1 then\n      Queue([], [])\n    else\n      Queue(reverse(q.rear)[1..], [])\n}\n\nfunction {:spec} queueFront<T>(q: Queue<T>): T\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    q.front[0]\n  else\n    // Front is empty, so the front element is the first element of rear (when reversed)\n    q.rear[|q.rear| - 1]\n}\n\nfunction {:spec} queueSize<T>(q: Queue<T>): nat\n{\n  |q.front| + |q.rear|\n}\n\nfunction {:spec} queueToSeq<T>(q: Queue<T>): seq<T>\n{\n  q.front + reverse(q.rear)\n}\n\nfunction reverse<T>(s: seq<T>): seq<T>\n{\n  if |s| == 0 then []\n  else reverse(s[1..]) + [s[0]]\n}\n\n// Alternative queue representation with invariant\ndatatype SimpleQueue<T> = SimpleQueue(elements: seq<T>)\n\nfunction {:spec} simpleQueueEmpty<T>(): SimpleQueue<T>\n{\n  SimpleQueue([])\n}\n\npredicate {:spec} simpleQueueIsEmpty<T>(q: SimpleQueue<T>)\n{\n  q.elements == []\n}\n\nfunction {:spec} simpleEnqueue<T>(q: SimpleQueue<T>, x: T): SimpleQueue<T>\n{\n  SimpleQueue(q.elements + [x])\n}\n\nfunction {:spec} simpleDequeue<T>(q: SimpleQueue<T>): SimpleQueue<T>\n  requires !simpleQueueIsEmpty(q)\n{\n  SimpleQueue(q.elements[1..])\n}\n\nfunction {:spec} simpleQueueFront<T>(q: SimpleQueue<T>): T\n  requires !simpleQueueIsEmpty(q)\n{\n  q.elements[0]\n}\n\nfunction {:spec} simpleQueueSize<T>(q: SimpleQueue<T>): nat\n{\n  |q.elements|\n}\n\nlemma ReverseLength<T>(s: seq<T>)\n  ensures |reverse(s)| == |s|\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseLength(s[1..]);\n    assert |reverse(s)| == |reverse(s[1..])| + 1;\n  }\n}\n\nlemma ReverseReverse<T>(s: seq<T>)\n  ensures reverse(reverse(s)) == s\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    \n/*[CODE HERE]*/\n    ReverseAppend(reverse(s[1..]), [s[0]]);\n    assert reverse(reverse(s)) == s;\n  }\n}\n\nlemma ReverseAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n  } else {\n    assert s1 + s2 == [s1[0]] + (s1[1..] + s2);\n    ReverseAppend(s1[1..], s2);\n  }\n}\n\nlemma ReverseFirst<T>(s: seq<T>)\n  requires |s| > 0\n  ensures |reverse(s)| == |s|\n  ensures reverse(s)[|reverse(s)| - 1] == s[0]\n  ensures reverse(s)[0] == s[|s| - 1]\n{\n  ReverseLength(s);\n  if |s| == 1 {\n    assert reverse(s) == [s[0]];\n  } else {\n    ReverseFirst(s[1..]);\n    assert reverse(s) == reverse(s[1..]) + [s[0]];\n    ReverseLength(s[1..]);\n    assert |reverse(s[1..])| == |s| - 1;\n  }\n}\n\nlemma SeqAssoc<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures a + (b + c) == (a + b) + c\n{\n  // Dafny proves this automatically\n}\n\nlemma QueueSizeProperty<T>(q: Queue<T>)\n  ensures queueSize(q) == |queueToSeq(q)|\n{\n  ReverseLength(q.rear);\n}\n\nlemma EnqueueCorrect<T>(q: Queue<T>, x: T)\n  ensures queueToSeq(enqueue(q, x)) == queueToSeq(q) + [x]\n  ensures queueSize(enqueue(q, x)) == queueSize(q) + 1\n{\n  var q' := enqueue(q, x);\n  assert q'.front == q.front;\n  assert q'.rear == [x] + q.rear;\n\n  ReverseAppend([x], q.rear);\n  assert reverse([x]) == [x];\n  assert reverse([x] + q.rear) == reverse(q.rear) + reverse([x]);\n  assert reverse([x] + q.rear) == reverse(q.rear) + [x];\n\n  calc == {\n    queueToSeq(q');\n    q'.front + reverse(q'.rear);\n    q.front + reverse([x] + q.rear);\n    q.front + (reverse(q.rear) + [x]);\n    { SeqAssoc(q.front, reverse(q.rear), [x]); }\n    (q.front + reverse(q.rear)) + [x];\n    queueToSeq(q) + [x];\n  }\n\n  QueueSizeProperty(q);\n  QueueSizeProperty(q');\n}\n\nlemma DequeueCorrect<T>(q: Queue<T>)\n  requires !queueIsEmpty(q)\n  ensures |queueToSeq(q)| > 0\n  ensures queueToSeq(dequeue(q)) == queueToSeq(q)[1..]\n  ensures queueFront(q) == queueToSeq(q)[0]\n{\n  if |q.front| > 0 {\n    assert queueToSeq(q) == q.front + reverse(q.rear);\n    assert queueToSeq(dequeue(q)) == q.front[1..] + reverse(q.rear);\n    assert queueFront(q) == q.front[0];\n  } else {\n    assert q.front == [];\n    assert |q.rear| > 0;\n    var rev := reverse(q.rear);\n    ReverseLength(q.rear);\n    assert |rev| == |q.rear|;\n    assert queueToSeq(q) == rev;\n    assert queueFront(q) == q.rear[|q.rear| - 1];\n\n    ReverseFirst(q.rear);\n    assert rev[0] == q.rear[|q.rear| - 1];\n\n    if |q.rear| == 1 {\n      assert rev == [q.rear[0]];\n      assert queueToSeq(q) == [q.rear[0]];\n      assert queueFront(q) == q.rear[0];\n      assert queueToSeq(q)[0] == q.rear[0];\n    } else {\n      assert |rev| > 1;\n      assert queueToSeq(dequeue(q)) == rev[1..];\n      assert queueFront(q) == rev[0];\n    }\n  }\n}\n\nlemma SimpleQueueEquivalence<T>(sq: SimpleQueue<T>, q: Queue<T>)\n  requires sq.elements == queueToSeq(q)\n  ensures simpleQueueIsEmpty(sq) == queueIsEmpty(q)\n  ensures simpleQueueSize(sq) == queueSize(q)\n{\n  if queueIsEmpty(q) {\n    assert q.front == [] && q.rear == [];\n    assert queueToSeq(q) == [];\n    assert sq.elements == [];\n  }\n  QueueSizeProperty(q);\n}", "output": "ReverseReverse(s[1..]);"}, {"id": "example_ReverseAppend_0", "type": "call", "program": "// Queue operations: enqueue, dequeue, isEmpty, size\n\ndatatype Queue<T> = Queue(front: seq<T>, rear: seq<T>)\n\nfunction {:spec} queueEmpty<T>(): Queue<T>\n{\n  Queue([], [])\n}\n\npredicate {:spec} queueIsEmpty<T>(q: Queue<T>)\n{\n  q.front == [] && q.rear == []\n}\n\nfunction {:spec} enqueue<T>(q: Queue<T>, x: T): Queue<T>\n{\n  Queue(q.front, [x] + q.rear)\n}\n\nfunction {:spec} dequeue<T>(q: Queue<T>): Queue<T>\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    Queue(q.front[1..], q.rear)\n  else\n    // Front is empty, so we reverse rear and put it in front\n    if |q.rear| == 1 then\n      Queue([], [])\n    else\n      Queue(reverse(q.rear)[1..], [])\n}\n\nfunction {:spec} queueFront<T>(q: Queue<T>): T\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    q.front[0]\n  else\n    // Front is empty, so the front element is the first element of rear (when reversed)\n    q.rear[|q.rear| - 1]\n}\n\nfunction {:spec} queueSize<T>(q: Queue<T>): nat\n{\n  |q.front| + |q.rear|\n}\n\nfunction {:spec} queueToSeq<T>(q: Queue<T>): seq<T>\n{\n  q.front + reverse(q.rear)\n}\n\nfunction reverse<T>(s: seq<T>): seq<T>\n{\n  if |s| == 0 then []\n  else reverse(s[1..]) + [s[0]]\n}\n\n// Alternative queue representation with invariant\ndatatype SimpleQueue<T> = SimpleQueue(elements: seq<T>)\n\nfunction {:spec} simpleQueueEmpty<T>(): SimpleQueue<T>\n{\n  SimpleQueue([])\n}\n\npredicate {:spec} simpleQueueIsEmpty<T>(q: SimpleQueue<T>)\n{\n  q.elements == []\n}\n\nfunction {:spec} simpleEnqueue<T>(q: SimpleQueue<T>, x: T): SimpleQueue<T>\n{\n  SimpleQueue(q.elements + [x])\n}\n\nfunction {:spec} simpleDequeue<T>(q: SimpleQueue<T>): SimpleQueue<T>\n  requires !simpleQueueIsEmpty(q)\n{\n  SimpleQueue(q.elements[1..])\n}\n\nfunction {:spec} simpleQueueFront<T>(q: SimpleQueue<T>): T\n  requires !simpleQueueIsEmpty(q)\n{\n  q.elements[0]\n}\n\nfunction {:spec} simpleQueueSize<T>(q: SimpleQueue<T>): nat\n{\n  |q.elements|\n}\n\nlemma ReverseLength<T>(s: seq<T>)\n  ensures |reverse(s)| == |s|\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseLength(s[1..]);\n    assert |reverse(s)| == |reverse(s[1..])| + 1;\n  }\n}\n\nlemma ReverseReverse<T>(s: seq<T>)\n  ensures reverse(reverse(s)) == s\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseReverse(s[1..]);\n    ReverseAppend(reverse(s[1..]), [s[0]]);\n    assert reverse(reverse(s)) == s;\n  }\n}\n\nlemma ReverseAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n  } else {\n    assert s1 + s2 == [s1[0]] + (s1[1..] + s2);\n    \n/*[CODE HERE]*/\n  }\n}\n\nlemma ReverseFirst<T>(s: seq<T>)\n  requires |s| > 0\n  ensures |reverse(s)| == |s|\n  ensures reverse(s)[|reverse(s)| - 1] == s[0]\n  ensures reverse(s)[0] == s[|s| - 1]\n{\n  ReverseLength(s);\n  if |s| == 1 {\n    assert reverse(s) == [s[0]];\n  } else {\n    ReverseFirst(s[1..]);\n    assert reverse(s) == reverse(s[1..]) + [s[0]];\n    ReverseLength(s[1..]);\n    assert |reverse(s[1..])| == |s| - 1;\n  }\n}\n\nlemma SeqAssoc<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures a + (b + c) == (a + b) + c\n{\n  // Dafny proves this automatically\n}\n\nlemma QueueSizeProperty<T>(q: Queue<T>)\n  ensures queueSize(q) == |queueToSeq(q)|\n{\n  ReverseLength(q.rear);\n}\n\nlemma EnqueueCorrect<T>(q: Queue<T>, x: T)\n  ensures queueToSeq(enqueue(q, x)) == queueToSeq(q) + [x]\n  ensures queueSize(enqueue(q, x)) == queueSize(q) + 1\n{\n  var q' := enqueue(q, x);\n  assert q'.front == q.front;\n  assert q'.rear == [x] + q.rear;\n\n  ReverseAppend([x], q.rear);\n  assert reverse([x]) == [x];\n  assert reverse([x] + q.rear) == reverse(q.rear) + reverse([x]);\n  assert reverse([x] + q.rear) == reverse(q.rear) + [x];\n\n  calc == {\n    queueToSeq(q');\n    q'.front + reverse(q'.rear);\n    q.front + reverse([x] + q.rear);\n    q.front + (reverse(q.rear) + [x]);\n    { SeqAssoc(q.front, reverse(q.rear), [x]); }\n    (q.front + reverse(q.rear)) + [x];\n    queueToSeq(q) + [x];\n  }\n\n  QueueSizeProperty(q);\n  QueueSizeProperty(q');\n}\n\nlemma DequeueCorrect<T>(q: Queue<T>)\n  requires !queueIsEmpty(q)\n  ensures |queueToSeq(q)| > 0\n  ensures queueToSeq(dequeue(q)) == queueToSeq(q)[1..]\n  ensures queueFront(q) == queueToSeq(q)[0]\n{\n  if |q.front| > 0 {\n    assert queueToSeq(q) == q.front + reverse(q.rear);\n    assert queueToSeq(dequeue(q)) == q.front[1..] + reverse(q.rear);\n    assert queueFront(q) == q.front[0];\n  } else {\n    assert q.front == [];\n    assert |q.rear| > 0;\n    var rev := reverse(q.rear);\n    ReverseLength(q.rear);\n    assert |rev| == |q.rear|;\n    assert queueToSeq(q) == rev;\n    assert queueFront(q) == q.rear[|q.rear| - 1];\n\n    ReverseFirst(q.rear);\n    assert rev[0] == q.rear[|q.rear| - 1];\n\n    if |q.rear| == 1 {\n      assert rev == [q.rear[0]];\n      assert queueToSeq(q) == [q.rear[0]];\n      assert queueFront(q) == q.rear[0];\n      assert queueToSeq(q)[0] == q.rear[0];\n    } else {\n      assert |rev| > 1;\n      assert queueToSeq(dequeue(q)) == rev[1..];\n      assert queueFront(q) == rev[0];\n    }\n  }\n}\n\nlemma SimpleQueueEquivalence<T>(sq: SimpleQueue<T>, q: Queue<T>)\n  requires sq.elements == queueToSeq(q)\n  ensures simpleQueueIsEmpty(sq) == queueIsEmpty(q)\n  ensures simpleQueueSize(sq) == queueSize(q)\n{\n  if queueIsEmpty(q) {\n    assert q.front == [] && q.rear == [];\n    assert queueToSeq(q) == [];\n    assert sq.elements == [];\n  }\n  QueueSizeProperty(q);\n}", "output": "ReverseAppend(s1[1..], s2);"}, {"id": "example_ReverseAppend_1", "type": "assert", "program": "// Queue operations: enqueue, dequeue, isEmpty, size\n\ndatatype Queue<T> = Queue(front: seq<T>, rear: seq<T>)\n\nfunction {:spec} queueEmpty<T>(): Queue<T>\n{\n  Queue([], [])\n}\n\npredicate {:spec} queueIsEmpty<T>(q: Queue<T>)\n{\n  q.front == [] && q.rear == []\n}\n\nfunction {:spec} enqueue<T>(q: Queue<T>, x: T): Queue<T>\n{\n  Queue(q.front, [x] + q.rear)\n}\n\nfunction {:spec} dequeue<T>(q: Queue<T>): Queue<T>\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    Queue(q.front[1..], q.rear)\n  else\n    // Front is empty, so we reverse rear and put it in front\n    if |q.rear| == 1 then\n      Queue([], [])\n    else\n      Queue(reverse(q.rear)[1..], [])\n}\n\nfunction {:spec} queueFront<T>(q: Queue<T>): T\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    q.front[0]\n  else\n    // Front is empty, so the front element is the first element of rear (when reversed)\n    q.rear[|q.rear| - 1]\n}\n\nfunction {:spec} queueSize<T>(q: Queue<T>): nat\n{\n  |q.front| + |q.rear|\n}\n\nfunction {:spec} queueToSeq<T>(q: Queue<T>): seq<T>\n{\n  q.front + reverse(q.rear)\n}\n\nfunction reverse<T>(s: seq<T>): seq<T>\n{\n  if |s| == 0 then []\n  else reverse(s[1..]) + [s[0]]\n}\n\n// Alternative queue representation with invariant\ndatatype SimpleQueue<T> = SimpleQueue(elements: seq<T>)\n\nfunction {:spec} simpleQueueEmpty<T>(): SimpleQueue<T>\n{\n  SimpleQueue([])\n}\n\npredicate {:spec} simpleQueueIsEmpty<T>(q: SimpleQueue<T>)\n{\n  q.elements == []\n}\n\nfunction {:spec} simpleEnqueue<T>(q: SimpleQueue<T>, x: T): SimpleQueue<T>\n{\n  SimpleQueue(q.elements + [x])\n}\n\nfunction {:spec} simpleDequeue<T>(q: SimpleQueue<T>): SimpleQueue<T>\n  requires !simpleQueueIsEmpty(q)\n{\n  SimpleQueue(q.elements[1..])\n}\n\nfunction {:spec} simpleQueueFront<T>(q: SimpleQueue<T>): T\n  requires !simpleQueueIsEmpty(q)\n{\n  q.elements[0]\n}\n\nfunction {:spec} simpleQueueSize<T>(q: SimpleQueue<T>): nat\n{\n  |q.elements|\n}\n\nlemma ReverseLength<T>(s: seq<T>)\n  ensures |reverse(s)| == |s|\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseLength(s[1..]);\n    assert |reverse(s)| == |reverse(s[1..])| + 1;\n  }\n}\n\nlemma ReverseReverse<T>(s: seq<T>)\n  ensures reverse(reverse(s)) == s\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseReverse(s[1..]);\n    ReverseAppend(reverse(s[1..]), [s[0]]);\n    assert reverse(reverse(s)) == s;\n  }\n}\n\nlemma ReverseAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n  } else {\n    \n/*[CODE HERE]*/\n    ReverseAppend(s1[1..], s2);\n  }\n}\n\nlemma ReverseFirst<T>(s: seq<T>)\n  requires |s| > 0\n  ensures |reverse(s)| == |s|\n  ensures reverse(s)[|reverse(s)| - 1] == s[0]\n  ensures reverse(s)[0] == s[|s| - 1]\n{\n  ReverseLength(s);\n  if |s| == 1 {\n    assert reverse(s) == [s[0]];\n  } else {\n    ReverseFirst(s[1..]);\n    assert reverse(s) == reverse(s[1..]) + [s[0]];\n    ReverseLength(s[1..]);\n    assert |reverse(s[1..])| == |s| - 1;\n  }\n}\n\nlemma SeqAssoc<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures a + (b + c) == (a + b) + c\n{\n  // Dafny proves this automatically\n}\n\nlemma QueueSizeProperty<T>(q: Queue<T>)\n  ensures queueSize(q) == |queueToSeq(q)|\n{\n  ReverseLength(q.rear);\n}\n\nlemma EnqueueCorrect<T>(q: Queue<T>, x: T)\n  ensures queueToSeq(enqueue(q, x)) == queueToSeq(q) + [x]\n  ensures queueSize(enqueue(q, x)) == queueSize(q) + 1\n{\n  var q' := enqueue(q, x);\n  assert q'.front == q.front;\n  assert q'.rear == [x] + q.rear;\n\n  ReverseAppend([x], q.rear);\n  assert reverse([x]) == [x];\n  assert reverse([x] + q.rear) == reverse(q.rear) + reverse([x]);\n  assert reverse([x] + q.rear) == reverse(q.rear) + [x];\n\n  calc == {\n    queueToSeq(q');\n    q'.front + reverse(q'.rear);\n    q.front + reverse([x] + q.rear);\n    q.front + (reverse(q.rear) + [x]);\n    { SeqAssoc(q.front, reverse(q.rear), [x]); }\n    (q.front + reverse(q.rear)) + [x];\n    queueToSeq(q) + [x];\n  }\n\n  QueueSizeProperty(q);\n  QueueSizeProperty(q');\n}\n\nlemma DequeueCorrect<T>(q: Queue<T>)\n  requires !queueIsEmpty(q)\n  ensures |queueToSeq(q)| > 0\n  ensures queueToSeq(dequeue(q)) == queueToSeq(q)[1..]\n  ensures queueFront(q) == queueToSeq(q)[0]\n{\n  if |q.front| > 0 {\n    assert queueToSeq(q) == q.front + reverse(q.rear);\n    assert queueToSeq(dequeue(q)) == q.front[1..] + reverse(q.rear);\n    assert queueFront(q) == q.front[0];\n  } else {\n    assert q.front == [];\n    assert |q.rear| > 0;\n    var rev := reverse(q.rear);\n    ReverseLength(q.rear);\n    assert |rev| == |q.rear|;\n    assert queueToSeq(q) == rev;\n    assert queueFront(q) == q.rear[|q.rear| - 1];\n\n    ReverseFirst(q.rear);\n    assert rev[0] == q.rear[|q.rear| - 1];\n\n    if |q.rear| == 1 {\n      assert rev == [q.rear[0]];\n      assert queueToSeq(q) == [q.rear[0]];\n      assert queueFront(q) == q.rear[0];\n      assert queueToSeq(q)[0] == q.rear[0];\n    } else {\n      assert |rev| > 1;\n      assert queueToSeq(dequeue(q)) == rev[1..];\n      assert queueFront(q) == rev[0];\n    }\n  }\n}\n\nlemma SimpleQueueEquivalence<T>(sq: SimpleQueue<T>, q: Queue<T>)\n  requires sq.elements == queueToSeq(q)\n  ensures simpleQueueIsEmpty(sq) == queueIsEmpty(q)\n  ensures simpleQueueSize(sq) == queueSize(q)\n{\n  if queueIsEmpty(q) {\n    assert q.front == [] && q.rear == [];\n    assert queueToSeq(q) == [];\n    assert sq.elements == [];\n  }\n  QueueSizeProperty(q);\n}", "output": "assert s1 + s2 == [s1[0]] + (s1[1..] + s2);"}, {"id": "example_ReverseAppend_2", "type": "assert", "program": "// Queue operations: enqueue, dequeue, isEmpty, size\n\ndatatype Queue<T> = Queue(front: seq<T>, rear: seq<T>)\n\nfunction {:spec} queueEmpty<T>(): Queue<T>\n{\n  Queue([], [])\n}\n\npredicate {:spec} queueIsEmpty<T>(q: Queue<T>)\n{\n  q.front == [] && q.rear == []\n}\n\nfunction {:spec} enqueue<T>(q: Queue<T>, x: T): Queue<T>\n{\n  Queue(q.front, [x] + q.rear)\n}\n\nfunction {:spec} dequeue<T>(q: Queue<T>): Queue<T>\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    Queue(q.front[1..], q.rear)\n  else\n    // Front is empty, so we reverse rear and put it in front\n    if |q.rear| == 1 then\n      Queue([], [])\n    else\n      Queue(reverse(q.rear)[1..], [])\n}\n\nfunction {:spec} queueFront<T>(q: Queue<T>): T\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    q.front[0]\n  else\n    // Front is empty, so the front element is the first element of rear (when reversed)\n    q.rear[|q.rear| - 1]\n}\n\nfunction {:spec} queueSize<T>(q: Queue<T>): nat\n{\n  |q.front| + |q.rear|\n}\n\nfunction {:spec} queueToSeq<T>(q: Queue<T>): seq<T>\n{\n  q.front + reverse(q.rear)\n}\n\nfunction reverse<T>(s: seq<T>): seq<T>\n{\n  if |s| == 0 then []\n  else reverse(s[1..]) + [s[0]]\n}\n\n// Alternative queue representation with invariant\ndatatype SimpleQueue<T> = SimpleQueue(elements: seq<T>)\n\nfunction {:spec} simpleQueueEmpty<T>(): SimpleQueue<T>\n{\n  SimpleQueue([])\n}\n\npredicate {:spec} simpleQueueIsEmpty<T>(q: SimpleQueue<T>)\n{\n  q.elements == []\n}\n\nfunction {:spec} simpleEnqueue<T>(q: SimpleQueue<T>, x: T): SimpleQueue<T>\n{\n  SimpleQueue(q.elements + [x])\n}\n\nfunction {:spec} simpleDequeue<T>(q: SimpleQueue<T>): SimpleQueue<T>\n  requires !simpleQueueIsEmpty(q)\n{\n  SimpleQueue(q.elements[1..])\n}\n\nfunction {:spec} simpleQueueFront<T>(q: SimpleQueue<T>): T\n  requires !simpleQueueIsEmpty(q)\n{\n  q.elements[0]\n}\n\nfunction {:spec} simpleQueueSize<T>(q: SimpleQueue<T>): nat\n{\n  |q.elements|\n}\n\nlemma ReverseLength<T>(s: seq<T>)\n  ensures |reverse(s)| == |s|\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseLength(s[1..]);\n    assert |reverse(s)| == |reverse(s[1..])| + 1;\n  }\n}\n\nlemma ReverseReverse<T>(s: seq<T>)\n  ensures reverse(reverse(s)) == s\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseReverse(s[1..]);\n    ReverseAppend(reverse(s[1..]), [s[0]]);\n    assert reverse(reverse(s)) == s;\n  }\n}\n\nlemma ReverseAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    \n/*[CODE HERE]*/\n  } else {\n    assert s1 + s2 == [s1[0]] + (s1[1..] + s2);\n    ReverseAppend(s1[1..], s2);\n  }\n}\n\nlemma ReverseFirst<T>(s: seq<T>)\n  requires |s| > 0\n  ensures |reverse(s)| == |s|\n  ensures reverse(s)[|reverse(s)| - 1] == s[0]\n  ensures reverse(s)[0] == s[|s| - 1]\n{\n  ReverseLength(s);\n  if |s| == 1 {\n    assert reverse(s) == [s[0]];\n  } else {\n    ReverseFirst(s[1..]);\n    assert reverse(s) == reverse(s[1..]) + [s[0]];\n    ReverseLength(s[1..]);\n    assert |reverse(s[1..])| == |s| - 1;\n  }\n}\n\nlemma SeqAssoc<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures a + (b + c) == (a + b) + c\n{\n  // Dafny proves this automatically\n}\n\nlemma QueueSizeProperty<T>(q: Queue<T>)\n  ensures queueSize(q) == |queueToSeq(q)|\n{\n  ReverseLength(q.rear);\n}\n\nlemma EnqueueCorrect<T>(q: Queue<T>, x: T)\n  ensures queueToSeq(enqueue(q, x)) == queueToSeq(q) + [x]\n  ensures queueSize(enqueue(q, x)) == queueSize(q) + 1\n{\n  var q' := enqueue(q, x);\n  assert q'.front == q.front;\n  assert q'.rear == [x] + q.rear;\n\n  ReverseAppend([x], q.rear);\n  assert reverse([x]) == [x];\n  assert reverse([x] + q.rear) == reverse(q.rear) + reverse([x]);\n  assert reverse([x] + q.rear) == reverse(q.rear) + [x];\n\n  calc == {\n    queueToSeq(q');\n    q'.front + reverse(q'.rear);\n    q.front + reverse([x] + q.rear);\n    q.front + (reverse(q.rear) + [x]);\n    { SeqAssoc(q.front, reverse(q.rear), [x]); }\n    (q.front + reverse(q.rear)) + [x];\n    queueToSeq(q) + [x];\n  }\n\n  QueueSizeProperty(q);\n  QueueSizeProperty(q');\n}\n\nlemma DequeueCorrect<T>(q: Queue<T>)\n  requires !queueIsEmpty(q)\n  ensures |queueToSeq(q)| > 0\n  ensures queueToSeq(dequeue(q)) == queueToSeq(q)[1..]\n  ensures queueFront(q) == queueToSeq(q)[0]\n{\n  if |q.front| > 0 {\n    assert queueToSeq(q) == q.front + reverse(q.rear);\n    assert queueToSeq(dequeue(q)) == q.front[1..] + reverse(q.rear);\n    assert queueFront(q) == q.front[0];\n  } else {\n    assert q.front == [];\n    assert |q.rear| > 0;\n    var rev := reverse(q.rear);\n    ReverseLength(q.rear);\n    assert |rev| == |q.rear|;\n    assert queueToSeq(q) == rev;\n    assert queueFront(q) == q.rear[|q.rear| - 1];\n\n    ReverseFirst(q.rear);\n    assert rev[0] == q.rear[|q.rear| - 1];\n\n    if |q.rear| == 1 {\n      assert rev == [q.rear[0]];\n      assert queueToSeq(q) == [q.rear[0]];\n      assert queueFront(q) == q.rear[0];\n      assert queueToSeq(q)[0] == q.rear[0];\n    } else {\n      assert |rev| > 1;\n      assert queueToSeq(dequeue(q)) == rev[1..];\n      assert queueFront(q) == rev[0];\n    }\n  }\n}\n\nlemma SimpleQueueEquivalence<T>(sq: SimpleQueue<T>, q: Queue<T>)\n  requires sq.elements == queueToSeq(q)\n  ensures simpleQueueIsEmpty(sq) == queueIsEmpty(q)\n  ensures simpleQueueSize(sq) == queueSize(q)\n{\n  if queueIsEmpty(q) {\n    assert q.front == [] && q.rear == [];\n    assert queueToSeq(q) == [];\n    assert sq.elements == [];\n  }\n  QueueSizeProperty(q);\n}", "output": "assert reverse(s1) == [];"}, {"id": "example_ReverseAppend_3", "type": "assert", "program": "// Queue operations: enqueue, dequeue, isEmpty, size\n\ndatatype Queue<T> = Queue(front: seq<T>, rear: seq<T>)\n\nfunction {:spec} queueEmpty<T>(): Queue<T>\n{\n  Queue([], [])\n}\n\npredicate {:spec} queueIsEmpty<T>(q: Queue<T>)\n{\n  q.front == [] && q.rear == []\n}\n\nfunction {:spec} enqueue<T>(q: Queue<T>, x: T): Queue<T>\n{\n  Queue(q.front, [x] + q.rear)\n}\n\nfunction {:spec} dequeue<T>(q: Queue<T>): Queue<T>\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    Queue(q.front[1..], q.rear)\n  else\n    // Front is empty, so we reverse rear and put it in front\n    if |q.rear| == 1 then\n      Queue([], [])\n    else\n      Queue(reverse(q.rear)[1..], [])\n}\n\nfunction {:spec} queueFront<T>(q: Queue<T>): T\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    q.front[0]\n  else\n    // Front is empty, so the front element is the first element of rear (when reversed)\n    q.rear[|q.rear| - 1]\n}\n\nfunction {:spec} queueSize<T>(q: Queue<T>): nat\n{\n  |q.front| + |q.rear|\n}\n\nfunction {:spec} queueToSeq<T>(q: Queue<T>): seq<T>\n{\n  q.front + reverse(q.rear)\n}\n\nfunction reverse<T>(s: seq<T>): seq<T>\n{\n  if |s| == 0 then []\n  else reverse(s[1..]) + [s[0]]\n}\n\n// Alternative queue representation with invariant\ndatatype SimpleQueue<T> = SimpleQueue(elements: seq<T>)\n\nfunction {:spec} simpleQueueEmpty<T>(): SimpleQueue<T>\n{\n  SimpleQueue([])\n}\n\npredicate {:spec} simpleQueueIsEmpty<T>(q: SimpleQueue<T>)\n{\n  q.elements == []\n}\n\nfunction {:spec} simpleEnqueue<T>(q: SimpleQueue<T>, x: T): SimpleQueue<T>\n{\n  SimpleQueue(q.elements + [x])\n}\n\nfunction {:spec} simpleDequeue<T>(q: SimpleQueue<T>): SimpleQueue<T>\n  requires !simpleQueueIsEmpty(q)\n{\n  SimpleQueue(q.elements[1..])\n}\n\nfunction {:spec} simpleQueueFront<T>(q: SimpleQueue<T>): T\n  requires !simpleQueueIsEmpty(q)\n{\n  q.elements[0]\n}\n\nfunction {:spec} simpleQueueSize<T>(q: SimpleQueue<T>): nat\n{\n  |q.elements|\n}\n\nlemma ReverseLength<T>(s: seq<T>)\n  ensures |reverse(s)| == |s|\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseLength(s[1..]);\n    assert |reverse(s)| == |reverse(s[1..])| + 1;\n  }\n}\n\nlemma ReverseReverse<T>(s: seq<T>)\n  ensures reverse(reverse(s)) == s\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseReverse(s[1..]);\n    ReverseAppend(reverse(s[1..]), [s[0]]);\n    assert reverse(reverse(s)) == s;\n  }\n}\n\nlemma ReverseAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    \n/*[CODE HERE]*/\n    assert reverse(s1) == [];\n  } else {\n    assert s1 + s2 == [s1[0]] + (s1[1..] + s2);\n    ReverseAppend(s1[1..], s2);\n  }\n}\n\nlemma ReverseFirst<T>(s: seq<T>)\n  requires |s| > 0\n  ensures |reverse(s)| == |s|\n  ensures reverse(s)[|reverse(s)| - 1] == s[0]\n  ensures reverse(s)[0] == s[|s| - 1]\n{\n  ReverseLength(s);\n  if |s| == 1 {\n    assert reverse(s) == [s[0]];\n  } else {\n    ReverseFirst(s[1..]);\n    assert reverse(s) == reverse(s[1..]) + [s[0]];\n    ReverseLength(s[1..]);\n    assert |reverse(s[1..])| == |s| - 1;\n  }\n}\n\nlemma SeqAssoc<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures a + (b + c) == (a + b) + c\n{\n  // Dafny proves this automatically\n}\n\nlemma QueueSizeProperty<T>(q: Queue<T>)\n  ensures queueSize(q) == |queueToSeq(q)|\n{\n  ReverseLength(q.rear);\n}\n\nlemma EnqueueCorrect<T>(q: Queue<T>, x: T)\n  ensures queueToSeq(enqueue(q, x)) == queueToSeq(q) + [x]\n  ensures queueSize(enqueue(q, x)) == queueSize(q) + 1\n{\n  var q' := enqueue(q, x);\n  assert q'.front == q.front;\n  assert q'.rear == [x] + q.rear;\n\n  ReverseAppend([x], q.rear);\n  assert reverse([x]) == [x];\n  assert reverse([x] + q.rear) == reverse(q.rear) + reverse([x]);\n  assert reverse([x] + q.rear) == reverse(q.rear) + [x];\n\n  calc == {\n    queueToSeq(q');\n    q'.front + reverse(q'.rear);\n    q.front + reverse([x] + q.rear);\n    q.front + (reverse(q.rear) + [x]);\n    { SeqAssoc(q.front, reverse(q.rear), [x]); }\n    (q.front + reverse(q.rear)) + [x];\n    queueToSeq(q) + [x];\n  }\n\n  QueueSizeProperty(q);\n  QueueSizeProperty(q');\n}\n\nlemma DequeueCorrect<T>(q: Queue<T>)\n  requires !queueIsEmpty(q)\n  ensures |queueToSeq(q)| > 0\n  ensures queueToSeq(dequeue(q)) == queueToSeq(q)[1..]\n  ensures queueFront(q) == queueToSeq(q)[0]\n{\n  if |q.front| > 0 {\n    assert queueToSeq(q) == q.front + reverse(q.rear);\n    assert queueToSeq(dequeue(q)) == q.front[1..] + reverse(q.rear);\n    assert queueFront(q) == q.front[0];\n  } else {\n    assert q.front == [];\n    assert |q.rear| > 0;\n    var rev := reverse(q.rear);\n    ReverseLength(q.rear);\n    assert |rev| == |q.rear|;\n    assert queueToSeq(q) == rev;\n    assert queueFront(q) == q.rear[|q.rear| - 1];\n\n    ReverseFirst(q.rear);\n    assert rev[0] == q.rear[|q.rear| - 1];\n\n    if |q.rear| == 1 {\n      assert rev == [q.rear[0]];\n      assert queueToSeq(q) == [q.rear[0]];\n      assert queueFront(q) == q.rear[0];\n      assert queueToSeq(q)[0] == q.rear[0];\n    } else {\n      assert |rev| > 1;\n      assert queueToSeq(dequeue(q)) == rev[1..];\n      assert queueFront(q) == rev[0];\n    }\n  }\n}\n\nlemma SimpleQueueEquivalence<T>(sq: SimpleQueue<T>, q: Queue<T>)\n  requires sq.elements == queueToSeq(q)\n  ensures simpleQueueIsEmpty(sq) == queueIsEmpty(q)\n  ensures simpleQueueSize(sq) == queueSize(q)\n{\n  if queueIsEmpty(q) {\n    assert q.front == [] && q.rear == [];\n    assert queueToSeq(q) == [];\n    assert sq.elements == [];\n  }\n  QueueSizeProperty(q);\n}", "output": "assert s1 + s2 == s2;"}, {"id": "example_ReverseFirst_0", "type": "assert", "program": "// Queue operations: enqueue, dequeue, isEmpty, size\n\ndatatype Queue<T> = Queue(front: seq<T>, rear: seq<T>)\n\nfunction {:spec} queueEmpty<T>(): Queue<T>\n{\n  Queue([], [])\n}\n\npredicate {:spec} queueIsEmpty<T>(q: Queue<T>)\n{\n  q.front == [] && q.rear == []\n}\n\nfunction {:spec} enqueue<T>(q: Queue<T>, x: T): Queue<T>\n{\n  Queue(q.front, [x] + q.rear)\n}\n\nfunction {:spec} dequeue<T>(q: Queue<T>): Queue<T>\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    Queue(q.front[1..], q.rear)\n  else\n    // Front is empty, so we reverse rear and put it in front\n    if |q.rear| == 1 then\n      Queue([], [])\n    else\n      Queue(reverse(q.rear)[1..], [])\n}\n\nfunction {:spec} queueFront<T>(q: Queue<T>): T\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    q.front[0]\n  else\n    // Front is empty, so the front element is the first element of rear (when reversed)\n    q.rear[|q.rear| - 1]\n}\n\nfunction {:spec} queueSize<T>(q: Queue<T>): nat\n{\n  |q.front| + |q.rear|\n}\n\nfunction {:spec} queueToSeq<T>(q: Queue<T>): seq<T>\n{\n  q.front + reverse(q.rear)\n}\n\nfunction reverse<T>(s: seq<T>): seq<T>\n{\n  if |s| == 0 then []\n  else reverse(s[1..]) + [s[0]]\n}\n\n// Alternative queue representation with invariant\ndatatype SimpleQueue<T> = SimpleQueue(elements: seq<T>)\n\nfunction {:spec} simpleQueueEmpty<T>(): SimpleQueue<T>\n{\n  SimpleQueue([])\n}\n\npredicate {:spec} simpleQueueIsEmpty<T>(q: SimpleQueue<T>)\n{\n  q.elements == []\n}\n\nfunction {:spec} simpleEnqueue<T>(q: SimpleQueue<T>, x: T): SimpleQueue<T>\n{\n  SimpleQueue(q.elements + [x])\n}\n\nfunction {:spec} simpleDequeue<T>(q: SimpleQueue<T>): SimpleQueue<T>\n  requires !simpleQueueIsEmpty(q)\n{\n  SimpleQueue(q.elements[1..])\n}\n\nfunction {:spec} simpleQueueFront<T>(q: SimpleQueue<T>): T\n  requires !simpleQueueIsEmpty(q)\n{\n  q.elements[0]\n}\n\nfunction {:spec} simpleQueueSize<T>(q: SimpleQueue<T>): nat\n{\n  |q.elements|\n}\n\nlemma ReverseLength<T>(s: seq<T>)\n  ensures |reverse(s)| == |s|\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseLength(s[1..]);\n    assert |reverse(s)| == |reverse(s[1..])| + 1;\n  }\n}\n\nlemma ReverseReverse<T>(s: seq<T>)\n  ensures reverse(reverse(s)) == s\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseReverse(s[1..]);\n    ReverseAppend(reverse(s[1..]), [s[0]]);\n    assert reverse(reverse(s)) == s;\n  }\n}\n\nlemma ReverseAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n  } else {\n    assert s1 + s2 == [s1[0]] + (s1[1..] + s2);\n    ReverseAppend(s1[1..], s2);\n  }\n}\n\nlemma ReverseFirst<T>(s: seq<T>)\n  requires |s| > 0\n  ensures |reverse(s)| == |s|\n  ensures reverse(s)[|reverse(s)| - 1] == s[0]\n  ensures reverse(s)[0] == s[|s| - 1]\n{\n  ReverseLength(s);\n  if |s| == 1 {\n    assert reverse(s) == [s[0]];\n  } else {\n    ReverseFirst(s[1..]);\n    assert reverse(s) == reverse(s[1..]) + [s[0]];\n    ReverseLength(s[1..]);\n    \n/*[CODE HERE]*/\n  }\n}\n\nlemma SeqAssoc<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures a + (b + c) == (a + b) + c\n{\n  // Dafny proves this automatically\n}\n\nlemma QueueSizeProperty<T>(q: Queue<T>)\n  ensures queueSize(q) == |queueToSeq(q)|\n{\n  ReverseLength(q.rear);\n}\n\nlemma EnqueueCorrect<T>(q: Queue<T>, x: T)\n  ensures queueToSeq(enqueue(q, x)) == queueToSeq(q) + [x]\n  ensures queueSize(enqueue(q, x)) == queueSize(q) + 1\n{\n  var q' := enqueue(q, x);\n  assert q'.front == q.front;\n  assert q'.rear == [x] + q.rear;\n\n  ReverseAppend([x], q.rear);\n  assert reverse([x]) == [x];\n  assert reverse([x] + q.rear) == reverse(q.rear) + reverse([x]);\n  assert reverse([x] + q.rear) == reverse(q.rear) + [x];\n\n  calc == {\n    queueToSeq(q');\n    q'.front + reverse(q'.rear);\n    q.front + reverse([x] + q.rear);\n    q.front + (reverse(q.rear) + [x]);\n    { SeqAssoc(q.front, reverse(q.rear), [x]); }\n    (q.front + reverse(q.rear)) + [x];\n    queueToSeq(q) + [x];\n  }\n\n  QueueSizeProperty(q);\n  QueueSizeProperty(q');\n}\n\nlemma DequeueCorrect<T>(q: Queue<T>)\n  requires !queueIsEmpty(q)\n  ensures |queueToSeq(q)| > 0\n  ensures queueToSeq(dequeue(q)) == queueToSeq(q)[1..]\n  ensures queueFront(q) == queueToSeq(q)[0]\n{\n  if |q.front| > 0 {\n    assert queueToSeq(q) == q.front + reverse(q.rear);\n    assert queueToSeq(dequeue(q)) == q.front[1..] + reverse(q.rear);\n    assert queueFront(q) == q.front[0];\n  } else {\n    assert q.front == [];\n    assert |q.rear| > 0;\n    var rev := reverse(q.rear);\n    ReverseLength(q.rear);\n    assert |rev| == |q.rear|;\n    assert queueToSeq(q) == rev;\n    assert queueFront(q) == q.rear[|q.rear| - 1];\n\n    ReverseFirst(q.rear);\n    assert rev[0] == q.rear[|q.rear| - 1];\n\n    if |q.rear| == 1 {\n      assert rev == [q.rear[0]];\n      assert queueToSeq(q) == [q.rear[0]];\n      assert queueFront(q) == q.rear[0];\n      assert queueToSeq(q)[0] == q.rear[0];\n    } else {\n      assert |rev| > 1;\n      assert queueToSeq(dequeue(q)) == rev[1..];\n      assert queueFront(q) == rev[0];\n    }\n  }\n}\n\nlemma SimpleQueueEquivalence<T>(sq: SimpleQueue<T>, q: Queue<T>)\n  requires sq.elements == queueToSeq(q)\n  ensures simpleQueueIsEmpty(sq) == queueIsEmpty(q)\n  ensures simpleQueueSize(sq) == queueSize(q)\n{\n  if queueIsEmpty(q) {\n    assert q.front == [] && q.rear == [];\n    assert queueToSeq(q) == [];\n    assert sq.elements == [];\n  }\n  QueueSizeProperty(q);\n}", "output": "assert |reverse(s[1..])| == |s| - 1;"}, {"id": "example_ReverseFirst_1", "type": "call", "program": "// Queue operations: enqueue, dequeue, isEmpty, size\n\ndatatype Queue<T> = Queue(front: seq<T>, rear: seq<T>)\n\nfunction {:spec} queueEmpty<T>(): Queue<T>\n{\n  Queue([], [])\n}\n\npredicate {:spec} queueIsEmpty<T>(q: Queue<T>)\n{\n  q.front == [] && q.rear == []\n}\n\nfunction {:spec} enqueue<T>(q: Queue<T>, x: T): Queue<T>\n{\n  Queue(q.front, [x] + q.rear)\n}\n\nfunction {:spec} dequeue<T>(q: Queue<T>): Queue<T>\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    Queue(q.front[1..], q.rear)\n  else\n    // Front is empty, so we reverse rear and put it in front\n    if |q.rear| == 1 then\n      Queue([], [])\n    else\n      Queue(reverse(q.rear)[1..], [])\n}\n\nfunction {:spec} queueFront<T>(q: Queue<T>): T\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    q.front[0]\n  else\n    // Front is empty, so the front element is the first element of rear (when reversed)\n    q.rear[|q.rear| - 1]\n}\n\nfunction {:spec} queueSize<T>(q: Queue<T>): nat\n{\n  |q.front| + |q.rear|\n}\n\nfunction {:spec} queueToSeq<T>(q: Queue<T>): seq<T>\n{\n  q.front + reverse(q.rear)\n}\n\nfunction reverse<T>(s: seq<T>): seq<T>\n{\n  if |s| == 0 then []\n  else reverse(s[1..]) + [s[0]]\n}\n\n// Alternative queue representation with invariant\ndatatype SimpleQueue<T> = SimpleQueue(elements: seq<T>)\n\nfunction {:spec} simpleQueueEmpty<T>(): SimpleQueue<T>\n{\n  SimpleQueue([])\n}\n\npredicate {:spec} simpleQueueIsEmpty<T>(q: SimpleQueue<T>)\n{\n  q.elements == []\n}\n\nfunction {:spec} simpleEnqueue<T>(q: SimpleQueue<T>, x: T): SimpleQueue<T>\n{\n  SimpleQueue(q.elements + [x])\n}\n\nfunction {:spec} simpleDequeue<T>(q: SimpleQueue<T>): SimpleQueue<T>\n  requires !simpleQueueIsEmpty(q)\n{\n  SimpleQueue(q.elements[1..])\n}\n\nfunction {:spec} simpleQueueFront<T>(q: SimpleQueue<T>): T\n  requires !simpleQueueIsEmpty(q)\n{\n  q.elements[0]\n}\n\nfunction {:spec} simpleQueueSize<T>(q: SimpleQueue<T>): nat\n{\n  |q.elements|\n}\n\nlemma ReverseLength<T>(s: seq<T>)\n  ensures |reverse(s)| == |s|\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseLength(s[1..]);\n    assert |reverse(s)| == |reverse(s[1..])| + 1;\n  }\n}\n\nlemma ReverseReverse<T>(s: seq<T>)\n  ensures reverse(reverse(s)) == s\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseReverse(s[1..]);\n    ReverseAppend(reverse(s[1..]), [s[0]]);\n    assert reverse(reverse(s)) == s;\n  }\n}\n\nlemma ReverseAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n  } else {\n    assert s1 + s2 == [s1[0]] + (s1[1..] + s2);\n    ReverseAppend(s1[1..], s2);\n  }\n}\n\nlemma ReverseFirst<T>(s: seq<T>)\n  requires |s| > 0\n  ensures |reverse(s)| == |s|\n  ensures reverse(s)[|reverse(s)| - 1] == s[0]\n  ensures reverse(s)[0] == s[|s| - 1]\n{\n  ReverseLength(s);\n  if |s| == 1 {\n    assert reverse(s) == [s[0]];\n  } else {\n    ReverseFirst(s[1..]);\n    assert reverse(s) == reverse(s[1..]) + [s[0]];\n    \n/*[CODE HERE]*/\n    assert |reverse(s[1..])| == |s| - 1;\n  }\n}\n\nlemma SeqAssoc<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures a + (b + c) == (a + b) + c\n{\n  // Dafny proves this automatically\n}\n\nlemma QueueSizeProperty<T>(q: Queue<T>)\n  ensures queueSize(q) == |queueToSeq(q)|\n{\n  ReverseLength(q.rear);\n}\n\nlemma EnqueueCorrect<T>(q: Queue<T>, x: T)\n  ensures queueToSeq(enqueue(q, x)) == queueToSeq(q) + [x]\n  ensures queueSize(enqueue(q, x)) == queueSize(q) + 1\n{\n  var q' := enqueue(q, x);\n  assert q'.front == q.front;\n  assert q'.rear == [x] + q.rear;\n\n  ReverseAppend([x], q.rear);\n  assert reverse([x]) == [x];\n  assert reverse([x] + q.rear) == reverse(q.rear) + reverse([x]);\n  assert reverse([x] + q.rear) == reverse(q.rear) + [x];\n\n  calc == {\n    queueToSeq(q');\n    q'.front + reverse(q'.rear);\n    q.front + reverse([x] + q.rear);\n    q.front + (reverse(q.rear) + [x]);\n    { SeqAssoc(q.front, reverse(q.rear), [x]); }\n    (q.front + reverse(q.rear)) + [x];\n    queueToSeq(q) + [x];\n  }\n\n  QueueSizeProperty(q);\n  QueueSizeProperty(q');\n}\n\nlemma DequeueCorrect<T>(q: Queue<T>)\n  requires !queueIsEmpty(q)\n  ensures |queueToSeq(q)| > 0\n  ensures queueToSeq(dequeue(q)) == queueToSeq(q)[1..]\n  ensures queueFront(q) == queueToSeq(q)[0]\n{\n  if |q.front| > 0 {\n    assert queueToSeq(q) == q.front + reverse(q.rear);\n    assert queueToSeq(dequeue(q)) == q.front[1..] + reverse(q.rear);\n    assert queueFront(q) == q.front[0];\n  } else {\n    assert q.front == [];\n    assert |q.rear| > 0;\n    var rev := reverse(q.rear);\n    ReverseLength(q.rear);\n    assert |rev| == |q.rear|;\n    assert queueToSeq(q) == rev;\n    assert queueFront(q) == q.rear[|q.rear| - 1];\n\n    ReverseFirst(q.rear);\n    assert rev[0] == q.rear[|q.rear| - 1];\n\n    if |q.rear| == 1 {\n      assert rev == [q.rear[0]];\n      assert queueToSeq(q) == [q.rear[0]];\n      assert queueFront(q) == q.rear[0];\n      assert queueToSeq(q)[0] == q.rear[0];\n    } else {\n      assert |rev| > 1;\n      assert queueToSeq(dequeue(q)) == rev[1..];\n      assert queueFront(q) == rev[0];\n    }\n  }\n}\n\nlemma SimpleQueueEquivalence<T>(sq: SimpleQueue<T>, q: Queue<T>)\n  requires sq.elements == queueToSeq(q)\n  ensures simpleQueueIsEmpty(sq) == queueIsEmpty(q)\n  ensures simpleQueueSize(sq) == queueSize(q)\n{\n  if queueIsEmpty(q) {\n    assert q.front == [] && q.rear == [];\n    assert queueToSeq(q) == [];\n    assert sq.elements == [];\n  }\n  QueueSizeProperty(q);\n}", "output": "ReverseLength(s[1..]);"}, {"id": "example_ReverseFirst_2", "type": "assert", "program": "// Queue operations: enqueue, dequeue, isEmpty, size\n\ndatatype Queue<T> = Queue(front: seq<T>, rear: seq<T>)\n\nfunction {:spec} queueEmpty<T>(): Queue<T>\n{\n  Queue([], [])\n}\n\npredicate {:spec} queueIsEmpty<T>(q: Queue<T>)\n{\n  q.front == [] && q.rear == []\n}\n\nfunction {:spec} enqueue<T>(q: Queue<T>, x: T): Queue<T>\n{\n  Queue(q.front, [x] + q.rear)\n}\n\nfunction {:spec} dequeue<T>(q: Queue<T>): Queue<T>\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    Queue(q.front[1..], q.rear)\n  else\n    // Front is empty, so we reverse rear and put it in front\n    if |q.rear| == 1 then\n      Queue([], [])\n    else\n      Queue(reverse(q.rear)[1..], [])\n}\n\nfunction {:spec} queueFront<T>(q: Queue<T>): T\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    q.front[0]\n  else\n    // Front is empty, so the front element is the first element of rear (when reversed)\n    q.rear[|q.rear| - 1]\n}\n\nfunction {:spec} queueSize<T>(q: Queue<T>): nat\n{\n  |q.front| + |q.rear|\n}\n\nfunction {:spec} queueToSeq<T>(q: Queue<T>): seq<T>\n{\n  q.front + reverse(q.rear)\n}\n\nfunction reverse<T>(s: seq<T>): seq<T>\n{\n  if |s| == 0 then []\n  else reverse(s[1..]) + [s[0]]\n}\n\n// Alternative queue representation with invariant\ndatatype SimpleQueue<T> = SimpleQueue(elements: seq<T>)\n\nfunction {:spec} simpleQueueEmpty<T>(): SimpleQueue<T>\n{\n  SimpleQueue([])\n}\n\npredicate {:spec} simpleQueueIsEmpty<T>(q: SimpleQueue<T>)\n{\n  q.elements == []\n}\n\nfunction {:spec} simpleEnqueue<T>(q: SimpleQueue<T>, x: T): SimpleQueue<T>\n{\n  SimpleQueue(q.elements + [x])\n}\n\nfunction {:spec} simpleDequeue<T>(q: SimpleQueue<T>): SimpleQueue<T>\n  requires !simpleQueueIsEmpty(q)\n{\n  SimpleQueue(q.elements[1..])\n}\n\nfunction {:spec} simpleQueueFront<T>(q: SimpleQueue<T>): T\n  requires !simpleQueueIsEmpty(q)\n{\n  q.elements[0]\n}\n\nfunction {:spec} simpleQueueSize<T>(q: SimpleQueue<T>): nat\n{\n  |q.elements|\n}\n\nlemma ReverseLength<T>(s: seq<T>)\n  ensures |reverse(s)| == |s|\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseLength(s[1..]);\n    assert |reverse(s)| == |reverse(s[1..])| + 1;\n  }\n}\n\nlemma ReverseReverse<T>(s: seq<T>)\n  ensures reverse(reverse(s)) == s\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseReverse(s[1..]);\n    ReverseAppend(reverse(s[1..]), [s[0]]);\n    assert reverse(reverse(s)) == s;\n  }\n}\n\nlemma ReverseAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n  } else {\n    assert s1 + s2 == [s1[0]] + (s1[1..] + s2);\n    ReverseAppend(s1[1..], s2);\n  }\n}\n\nlemma ReverseFirst<T>(s: seq<T>)\n  requires |s| > 0\n  ensures |reverse(s)| == |s|\n  ensures reverse(s)[|reverse(s)| - 1] == s[0]\n  ensures reverse(s)[0] == s[|s| - 1]\n{\n  ReverseLength(s);\n  if |s| == 1 {\n    assert reverse(s) == [s[0]];\n  } else {\n    ReverseFirst(s[1..]);\n    \n/*[CODE HERE]*/\n    ReverseLength(s[1..]);\n    assert |reverse(s[1..])| == |s| - 1;\n  }\n}\n\nlemma SeqAssoc<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures a + (b + c) == (a + b) + c\n{\n  // Dafny proves this automatically\n}\n\nlemma QueueSizeProperty<T>(q: Queue<T>)\n  ensures queueSize(q) == |queueToSeq(q)|\n{\n  ReverseLength(q.rear);\n}\n\nlemma EnqueueCorrect<T>(q: Queue<T>, x: T)\n  ensures queueToSeq(enqueue(q, x)) == queueToSeq(q) + [x]\n  ensures queueSize(enqueue(q, x)) == queueSize(q) + 1\n{\n  var q' := enqueue(q, x);\n  assert q'.front == q.front;\n  assert q'.rear == [x] + q.rear;\n\n  ReverseAppend([x], q.rear);\n  assert reverse([x]) == [x];\n  assert reverse([x] + q.rear) == reverse(q.rear) + reverse([x]);\n  assert reverse([x] + q.rear) == reverse(q.rear) + [x];\n\n  calc == {\n    queueToSeq(q');\n    q'.front + reverse(q'.rear);\n    q.front + reverse([x] + q.rear);\n    q.front + (reverse(q.rear) + [x]);\n    { SeqAssoc(q.front, reverse(q.rear), [x]); }\n    (q.front + reverse(q.rear)) + [x];\n    queueToSeq(q) + [x];\n  }\n\n  QueueSizeProperty(q);\n  QueueSizeProperty(q');\n}\n\nlemma DequeueCorrect<T>(q: Queue<T>)\n  requires !queueIsEmpty(q)\n  ensures |queueToSeq(q)| > 0\n  ensures queueToSeq(dequeue(q)) == queueToSeq(q)[1..]\n  ensures queueFront(q) == queueToSeq(q)[0]\n{\n  if |q.front| > 0 {\n    assert queueToSeq(q) == q.front + reverse(q.rear);\n    assert queueToSeq(dequeue(q)) == q.front[1..] + reverse(q.rear);\n    assert queueFront(q) == q.front[0];\n  } else {\n    assert q.front == [];\n    assert |q.rear| > 0;\n    var rev := reverse(q.rear);\n    ReverseLength(q.rear);\n    assert |rev| == |q.rear|;\n    assert queueToSeq(q) == rev;\n    assert queueFront(q) == q.rear[|q.rear| - 1];\n\n    ReverseFirst(q.rear);\n    assert rev[0] == q.rear[|q.rear| - 1];\n\n    if |q.rear| == 1 {\n      assert rev == [q.rear[0]];\n      assert queueToSeq(q) == [q.rear[0]];\n      assert queueFront(q) == q.rear[0];\n      assert queueToSeq(q)[0] == q.rear[0];\n    } else {\n      assert |rev| > 1;\n      assert queueToSeq(dequeue(q)) == rev[1..];\n      assert queueFront(q) == rev[0];\n    }\n  }\n}\n\nlemma SimpleQueueEquivalence<T>(sq: SimpleQueue<T>, q: Queue<T>)\n  requires sq.elements == queueToSeq(q)\n  ensures simpleQueueIsEmpty(sq) == queueIsEmpty(q)\n  ensures simpleQueueSize(sq) == queueSize(q)\n{\n  if queueIsEmpty(q) {\n    assert q.front == [] && q.rear == [];\n    assert queueToSeq(q) == [];\n    assert sq.elements == [];\n  }\n  QueueSizeProperty(q);\n}", "output": "assert reverse(s) == reverse(s[1..]) + [s[0]];"}, {"id": "example_ReverseFirst_3", "type": "call", "program": "// Queue operations: enqueue, dequeue, isEmpty, size\n\ndatatype Queue<T> = Queue(front: seq<T>, rear: seq<T>)\n\nfunction {:spec} queueEmpty<T>(): Queue<T>\n{\n  Queue([], [])\n}\n\npredicate {:spec} queueIsEmpty<T>(q: Queue<T>)\n{\n  q.front == [] && q.rear == []\n}\n\nfunction {:spec} enqueue<T>(q: Queue<T>, x: T): Queue<T>\n{\n  Queue(q.front, [x] + q.rear)\n}\n\nfunction {:spec} dequeue<T>(q: Queue<T>): Queue<T>\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    Queue(q.front[1..], q.rear)\n  else\n    // Front is empty, so we reverse rear and put it in front\n    if |q.rear| == 1 then\n      Queue([], [])\n    else\n      Queue(reverse(q.rear)[1..], [])\n}\n\nfunction {:spec} queueFront<T>(q: Queue<T>): T\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    q.front[0]\n  else\n    // Front is empty, so the front element is the first element of rear (when reversed)\n    q.rear[|q.rear| - 1]\n}\n\nfunction {:spec} queueSize<T>(q: Queue<T>): nat\n{\n  |q.front| + |q.rear|\n}\n\nfunction {:spec} queueToSeq<T>(q: Queue<T>): seq<T>\n{\n  q.front + reverse(q.rear)\n}\n\nfunction reverse<T>(s: seq<T>): seq<T>\n{\n  if |s| == 0 then []\n  else reverse(s[1..]) + [s[0]]\n}\n\n// Alternative queue representation with invariant\ndatatype SimpleQueue<T> = SimpleQueue(elements: seq<T>)\n\nfunction {:spec} simpleQueueEmpty<T>(): SimpleQueue<T>\n{\n  SimpleQueue([])\n}\n\npredicate {:spec} simpleQueueIsEmpty<T>(q: SimpleQueue<T>)\n{\n  q.elements == []\n}\n\nfunction {:spec} simpleEnqueue<T>(q: SimpleQueue<T>, x: T): SimpleQueue<T>\n{\n  SimpleQueue(q.elements + [x])\n}\n\nfunction {:spec} simpleDequeue<T>(q: SimpleQueue<T>): SimpleQueue<T>\n  requires !simpleQueueIsEmpty(q)\n{\n  SimpleQueue(q.elements[1..])\n}\n\nfunction {:spec} simpleQueueFront<T>(q: SimpleQueue<T>): T\n  requires !simpleQueueIsEmpty(q)\n{\n  q.elements[0]\n}\n\nfunction {:spec} simpleQueueSize<T>(q: SimpleQueue<T>): nat\n{\n  |q.elements|\n}\n\nlemma ReverseLength<T>(s: seq<T>)\n  ensures |reverse(s)| == |s|\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseLength(s[1..]);\n    assert |reverse(s)| == |reverse(s[1..])| + 1;\n  }\n}\n\nlemma ReverseReverse<T>(s: seq<T>)\n  ensures reverse(reverse(s)) == s\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseReverse(s[1..]);\n    ReverseAppend(reverse(s[1..]), [s[0]]);\n    assert reverse(reverse(s)) == s;\n  }\n}\n\nlemma ReverseAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n  } else {\n    assert s1 + s2 == [s1[0]] + (s1[1..] + s2);\n    ReverseAppend(s1[1..], s2);\n  }\n}\n\nlemma ReverseFirst<T>(s: seq<T>)\n  requires |s| > 0\n  ensures |reverse(s)| == |s|\n  ensures reverse(s)[|reverse(s)| - 1] == s[0]\n  ensures reverse(s)[0] == s[|s| - 1]\n{\n  ReverseLength(s);\n  if |s| == 1 {\n    assert reverse(s) == [s[0]];\n  } else {\n    \n/*[CODE HERE]*/\n    assert reverse(s) == reverse(s[1..]) + [s[0]];\n    ReverseLength(s[1..]);\n    assert |reverse(s[1..])| == |s| - 1;\n  }\n}\n\nlemma SeqAssoc<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures a + (b + c) == (a + b) + c\n{\n  // Dafny proves this automatically\n}\n\nlemma QueueSizeProperty<T>(q: Queue<T>)\n  ensures queueSize(q) == |queueToSeq(q)|\n{\n  ReverseLength(q.rear);\n}\n\nlemma EnqueueCorrect<T>(q: Queue<T>, x: T)\n  ensures queueToSeq(enqueue(q, x)) == queueToSeq(q) + [x]\n  ensures queueSize(enqueue(q, x)) == queueSize(q) + 1\n{\n  var q' := enqueue(q, x);\n  assert q'.front == q.front;\n  assert q'.rear == [x] + q.rear;\n\n  ReverseAppend([x], q.rear);\n  assert reverse([x]) == [x];\n  assert reverse([x] + q.rear) == reverse(q.rear) + reverse([x]);\n  assert reverse([x] + q.rear) == reverse(q.rear) + [x];\n\n  calc == {\n    queueToSeq(q');\n    q'.front + reverse(q'.rear);\n    q.front + reverse([x] + q.rear);\n    q.front + (reverse(q.rear) + [x]);\n    { SeqAssoc(q.front, reverse(q.rear), [x]); }\n    (q.front + reverse(q.rear)) + [x];\n    queueToSeq(q) + [x];\n  }\n\n  QueueSizeProperty(q);\n  QueueSizeProperty(q');\n}\n\nlemma DequeueCorrect<T>(q: Queue<T>)\n  requires !queueIsEmpty(q)\n  ensures |queueToSeq(q)| > 0\n  ensures queueToSeq(dequeue(q)) == queueToSeq(q)[1..]\n  ensures queueFront(q) == queueToSeq(q)[0]\n{\n  if |q.front| > 0 {\n    assert queueToSeq(q) == q.front + reverse(q.rear);\n    assert queueToSeq(dequeue(q)) == q.front[1..] + reverse(q.rear);\n    assert queueFront(q) == q.front[0];\n  } else {\n    assert q.front == [];\n    assert |q.rear| > 0;\n    var rev := reverse(q.rear);\n    ReverseLength(q.rear);\n    assert |rev| == |q.rear|;\n    assert queueToSeq(q) == rev;\n    assert queueFront(q) == q.rear[|q.rear| - 1];\n\n    ReverseFirst(q.rear);\n    assert rev[0] == q.rear[|q.rear| - 1];\n\n    if |q.rear| == 1 {\n      assert rev == [q.rear[0]];\n      assert queueToSeq(q) == [q.rear[0]];\n      assert queueFront(q) == q.rear[0];\n      assert queueToSeq(q)[0] == q.rear[0];\n    } else {\n      assert |rev| > 1;\n      assert queueToSeq(dequeue(q)) == rev[1..];\n      assert queueFront(q) == rev[0];\n    }\n  }\n}\n\nlemma SimpleQueueEquivalence<T>(sq: SimpleQueue<T>, q: Queue<T>)\n  requires sq.elements == queueToSeq(q)\n  ensures simpleQueueIsEmpty(sq) == queueIsEmpty(q)\n  ensures simpleQueueSize(sq) == queueSize(q)\n{\n  if queueIsEmpty(q) {\n    assert q.front == [] && q.rear == [];\n    assert queueToSeq(q) == [];\n    assert sq.elements == [];\n  }\n  QueueSizeProperty(q);\n}", "output": "ReverseFirst(s[1..]);"}, {"id": "example_ReverseFirst_4", "type": "assert", "program": "// Queue operations: enqueue, dequeue, isEmpty, size\n\ndatatype Queue<T> = Queue(front: seq<T>, rear: seq<T>)\n\nfunction {:spec} queueEmpty<T>(): Queue<T>\n{\n  Queue([], [])\n}\n\npredicate {:spec} queueIsEmpty<T>(q: Queue<T>)\n{\n  q.front == [] && q.rear == []\n}\n\nfunction {:spec} enqueue<T>(q: Queue<T>, x: T): Queue<T>\n{\n  Queue(q.front, [x] + q.rear)\n}\n\nfunction {:spec} dequeue<T>(q: Queue<T>): Queue<T>\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    Queue(q.front[1..], q.rear)\n  else\n    // Front is empty, so we reverse rear and put it in front\n    if |q.rear| == 1 then\n      Queue([], [])\n    else\n      Queue(reverse(q.rear)[1..], [])\n}\n\nfunction {:spec} queueFront<T>(q: Queue<T>): T\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    q.front[0]\n  else\n    // Front is empty, so the front element is the first element of rear (when reversed)\n    q.rear[|q.rear| - 1]\n}\n\nfunction {:spec} queueSize<T>(q: Queue<T>): nat\n{\n  |q.front| + |q.rear|\n}\n\nfunction {:spec} queueToSeq<T>(q: Queue<T>): seq<T>\n{\n  q.front + reverse(q.rear)\n}\n\nfunction reverse<T>(s: seq<T>): seq<T>\n{\n  if |s| == 0 then []\n  else reverse(s[1..]) + [s[0]]\n}\n\n// Alternative queue representation with invariant\ndatatype SimpleQueue<T> = SimpleQueue(elements: seq<T>)\n\nfunction {:spec} simpleQueueEmpty<T>(): SimpleQueue<T>\n{\n  SimpleQueue([])\n}\n\npredicate {:spec} simpleQueueIsEmpty<T>(q: SimpleQueue<T>)\n{\n  q.elements == []\n}\n\nfunction {:spec} simpleEnqueue<T>(q: SimpleQueue<T>, x: T): SimpleQueue<T>\n{\n  SimpleQueue(q.elements + [x])\n}\n\nfunction {:spec} simpleDequeue<T>(q: SimpleQueue<T>): SimpleQueue<T>\n  requires !simpleQueueIsEmpty(q)\n{\n  SimpleQueue(q.elements[1..])\n}\n\nfunction {:spec} simpleQueueFront<T>(q: SimpleQueue<T>): T\n  requires !simpleQueueIsEmpty(q)\n{\n  q.elements[0]\n}\n\nfunction {:spec} simpleQueueSize<T>(q: SimpleQueue<T>): nat\n{\n  |q.elements|\n}\n\nlemma ReverseLength<T>(s: seq<T>)\n  ensures |reverse(s)| == |s|\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseLength(s[1..]);\n    assert |reverse(s)| == |reverse(s[1..])| + 1;\n  }\n}\n\nlemma ReverseReverse<T>(s: seq<T>)\n  ensures reverse(reverse(s)) == s\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseReverse(s[1..]);\n    ReverseAppend(reverse(s[1..]), [s[0]]);\n    assert reverse(reverse(s)) == s;\n  }\n}\n\nlemma ReverseAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n  } else {\n    assert s1 + s2 == [s1[0]] + (s1[1..] + s2);\n    ReverseAppend(s1[1..], s2);\n  }\n}\n\nlemma ReverseFirst<T>(s: seq<T>)\n  requires |s| > 0\n  ensures |reverse(s)| == |s|\n  ensures reverse(s)[|reverse(s)| - 1] == s[0]\n  ensures reverse(s)[0] == s[|s| - 1]\n{\n  ReverseLength(s);\n  if |s| == 1 {\n    \n/*[CODE HERE]*/\n  } else {\n    ReverseFirst(s[1..]);\n    assert reverse(s) == reverse(s[1..]) + [s[0]];\n    ReverseLength(s[1..]);\n    assert |reverse(s[1..])| == |s| - 1;\n  }\n}\n\nlemma SeqAssoc<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures a + (b + c) == (a + b) + c\n{\n  // Dafny proves this automatically\n}\n\nlemma QueueSizeProperty<T>(q: Queue<T>)\n  ensures queueSize(q) == |queueToSeq(q)|\n{\n  ReverseLength(q.rear);\n}\n\nlemma EnqueueCorrect<T>(q: Queue<T>, x: T)\n  ensures queueToSeq(enqueue(q, x)) == queueToSeq(q) + [x]\n  ensures queueSize(enqueue(q, x)) == queueSize(q) + 1\n{\n  var q' := enqueue(q, x);\n  assert q'.front == q.front;\n  assert q'.rear == [x] + q.rear;\n\n  ReverseAppend([x], q.rear);\n  assert reverse([x]) == [x];\n  assert reverse([x] + q.rear) == reverse(q.rear) + reverse([x]);\n  assert reverse([x] + q.rear) == reverse(q.rear) + [x];\n\n  calc == {\n    queueToSeq(q');\n    q'.front + reverse(q'.rear);\n    q.front + reverse([x] + q.rear);\n    q.front + (reverse(q.rear) + [x]);\n    { SeqAssoc(q.front, reverse(q.rear), [x]); }\n    (q.front + reverse(q.rear)) + [x];\n    queueToSeq(q) + [x];\n  }\n\n  QueueSizeProperty(q);\n  QueueSizeProperty(q');\n}\n\nlemma DequeueCorrect<T>(q: Queue<T>)\n  requires !queueIsEmpty(q)\n  ensures |queueToSeq(q)| > 0\n  ensures queueToSeq(dequeue(q)) == queueToSeq(q)[1..]\n  ensures queueFront(q) == queueToSeq(q)[0]\n{\n  if |q.front| > 0 {\n    assert queueToSeq(q) == q.front + reverse(q.rear);\n    assert queueToSeq(dequeue(q)) == q.front[1..] + reverse(q.rear);\n    assert queueFront(q) == q.front[0];\n  } else {\n    assert q.front == [];\n    assert |q.rear| > 0;\n    var rev := reverse(q.rear);\n    ReverseLength(q.rear);\n    assert |rev| == |q.rear|;\n    assert queueToSeq(q) == rev;\n    assert queueFront(q) == q.rear[|q.rear| - 1];\n\n    ReverseFirst(q.rear);\n    assert rev[0] == q.rear[|q.rear| - 1];\n\n    if |q.rear| == 1 {\n      assert rev == [q.rear[0]];\n      assert queueToSeq(q) == [q.rear[0]];\n      assert queueFront(q) == q.rear[0];\n      assert queueToSeq(q)[0] == q.rear[0];\n    } else {\n      assert |rev| > 1;\n      assert queueToSeq(dequeue(q)) == rev[1..];\n      assert queueFront(q) == rev[0];\n    }\n  }\n}\n\nlemma SimpleQueueEquivalence<T>(sq: SimpleQueue<T>, q: Queue<T>)\n  requires sq.elements == queueToSeq(q)\n  ensures simpleQueueIsEmpty(sq) == queueIsEmpty(q)\n  ensures simpleQueueSize(sq) == queueSize(q)\n{\n  if queueIsEmpty(q) {\n    assert q.front == [] && q.rear == [];\n    assert queueToSeq(q) == [];\n    assert sq.elements == [];\n  }\n  QueueSizeProperty(q);\n}", "output": "assert reverse(s) == [s[0]];"}, {"id": "example_ReverseFirst_5", "type": "call", "program": "// Queue operations: enqueue, dequeue, isEmpty, size\n\ndatatype Queue<T> = Queue(front: seq<T>, rear: seq<T>)\n\nfunction {:spec} queueEmpty<T>(): Queue<T>\n{\n  Queue([], [])\n}\n\npredicate {:spec} queueIsEmpty<T>(q: Queue<T>)\n{\n  q.front == [] && q.rear == []\n}\n\nfunction {:spec} enqueue<T>(q: Queue<T>, x: T): Queue<T>\n{\n  Queue(q.front, [x] + q.rear)\n}\n\nfunction {:spec} dequeue<T>(q: Queue<T>): Queue<T>\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    Queue(q.front[1..], q.rear)\n  else\n    // Front is empty, so we reverse rear and put it in front\n    if |q.rear| == 1 then\n      Queue([], [])\n    else\n      Queue(reverse(q.rear)[1..], [])\n}\n\nfunction {:spec} queueFront<T>(q: Queue<T>): T\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    q.front[0]\n  else\n    // Front is empty, so the front element is the first element of rear (when reversed)\n    q.rear[|q.rear| - 1]\n}\n\nfunction {:spec} queueSize<T>(q: Queue<T>): nat\n{\n  |q.front| + |q.rear|\n}\n\nfunction {:spec} queueToSeq<T>(q: Queue<T>): seq<T>\n{\n  q.front + reverse(q.rear)\n}\n\nfunction reverse<T>(s: seq<T>): seq<T>\n{\n  if |s| == 0 then []\n  else reverse(s[1..]) + [s[0]]\n}\n\n// Alternative queue representation with invariant\ndatatype SimpleQueue<T> = SimpleQueue(elements: seq<T>)\n\nfunction {:spec} simpleQueueEmpty<T>(): SimpleQueue<T>\n{\n  SimpleQueue([])\n}\n\npredicate {:spec} simpleQueueIsEmpty<T>(q: SimpleQueue<T>)\n{\n  q.elements == []\n}\n\nfunction {:spec} simpleEnqueue<T>(q: SimpleQueue<T>, x: T): SimpleQueue<T>\n{\n  SimpleQueue(q.elements + [x])\n}\n\nfunction {:spec} simpleDequeue<T>(q: SimpleQueue<T>): SimpleQueue<T>\n  requires !simpleQueueIsEmpty(q)\n{\n  SimpleQueue(q.elements[1..])\n}\n\nfunction {:spec} simpleQueueFront<T>(q: SimpleQueue<T>): T\n  requires !simpleQueueIsEmpty(q)\n{\n  q.elements[0]\n}\n\nfunction {:spec} simpleQueueSize<T>(q: SimpleQueue<T>): nat\n{\n  |q.elements|\n}\n\nlemma ReverseLength<T>(s: seq<T>)\n  ensures |reverse(s)| == |s|\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseLength(s[1..]);\n    assert |reverse(s)| == |reverse(s[1..])| + 1;\n  }\n}\n\nlemma ReverseReverse<T>(s: seq<T>)\n  ensures reverse(reverse(s)) == s\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseReverse(s[1..]);\n    ReverseAppend(reverse(s[1..]), [s[0]]);\n    assert reverse(reverse(s)) == s;\n  }\n}\n\nlemma ReverseAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n  } else {\n    assert s1 + s2 == [s1[0]] + (s1[1..] + s2);\n    ReverseAppend(s1[1..], s2);\n  }\n}\n\nlemma ReverseFirst<T>(s: seq<T>)\n  requires |s| > 0\n  ensures |reverse(s)| == |s|\n  ensures reverse(s)[|reverse(s)| - 1] == s[0]\n  ensures reverse(s)[0] == s[|s| - 1]\n{\n  \n/*[CODE HERE]*/\n  if |s| == 1 {\n    assert reverse(s) == [s[0]];\n  } else {\n    ReverseFirst(s[1..]);\n    assert reverse(s) == reverse(s[1..]) + [s[0]];\n    ReverseLength(s[1..]);\n    assert |reverse(s[1..])| == |s| - 1;\n  }\n}\n\nlemma SeqAssoc<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures a + (b + c) == (a + b) + c\n{\n  // Dafny proves this automatically\n}\n\nlemma QueueSizeProperty<T>(q: Queue<T>)\n  ensures queueSize(q) == |queueToSeq(q)|\n{\n  ReverseLength(q.rear);\n}\n\nlemma EnqueueCorrect<T>(q: Queue<T>, x: T)\n  ensures queueToSeq(enqueue(q, x)) == queueToSeq(q) + [x]\n  ensures queueSize(enqueue(q, x)) == queueSize(q) + 1\n{\n  var q' := enqueue(q, x);\n  assert q'.front == q.front;\n  assert q'.rear == [x] + q.rear;\n\n  ReverseAppend([x], q.rear);\n  assert reverse([x]) == [x];\n  assert reverse([x] + q.rear) == reverse(q.rear) + reverse([x]);\n  assert reverse([x] + q.rear) == reverse(q.rear) + [x];\n\n  calc == {\n    queueToSeq(q');\n    q'.front + reverse(q'.rear);\n    q.front + reverse([x] + q.rear);\n    q.front + (reverse(q.rear) + [x]);\n    { SeqAssoc(q.front, reverse(q.rear), [x]); }\n    (q.front + reverse(q.rear)) + [x];\n    queueToSeq(q) + [x];\n  }\n\n  QueueSizeProperty(q);\n  QueueSizeProperty(q');\n}\n\nlemma DequeueCorrect<T>(q: Queue<T>)\n  requires !queueIsEmpty(q)\n  ensures |queueToSeq(q)| > 0\n  ensures queueToSeq(dequeue(q)) == queueToSeq(q)[1..]\n  ensures queueFront(q) == queueToSeq(q)[0]\n{\n  if |q.front| > 0 {\n    assert queueToSeq(q) == q.front + reverse(q.rear);\n    assert queueToSeq(dequeue(q)) == q.front[1..] + reverse(q.rear);\n    assert queueFront(q) == q.front[0];\n  } else {\n    assert q.front == [];\n    assert |q.rear| > 0;\n    var rev := reverse(q.rear);\n    ReverseLength(q.rear);\n    assert |rev| == |q.rear|;\n    assert queueToSeq(q) == rev;\n    assert queueFront(q) == q.rear[|q.rear| - 1];\n\n    ReverseFirst(q.rear);\n    assert rev[0] == q.rear[|q.rear| - 1];\n\n    if |q.rear| == 1 {\n      assert rev == [q.rear[0]];\n      assert queueToSeq(q) == [q.rear[0]];\n      assert queueFront(q) == q.rear[0];\n      assert queueToSeq(q)[0] == q.rear[0];\n    } else {\n      assert |rev| > 1;\n      assert queueToSeq(dequeue(q)) == rev[1..];\n      assert queueFront(q) == rev[0];\n    }\n  }\n}\n\nlemma SimpleQueueEquivalence<T>(sq: SimpleQueue<T>, q: Queue<T>)\n  requires sq.elements == queueToSeq(q)\n  ensures simpleQueueIsEmpty(sq) == queueIsEmpty(q)\n  ensures simpleQueueSize(sq) == queueSize(q)\n{\n  if queueIsEmpty(q) {\n    assert q.front == [] && q.rear == [];\n    assert queueToSeq(q) == [];\n    assert sq.elements == [];\n  }\n  QueueSizeProperty(q);\n}", "output": "ReverseLength(s);"}, {"id": "example_QueueSizeProperty_0", "type": "call", "program": "// Queue operations: enqueue, dequeue, isEmpty, size\n\ndatatype Queue<T> = Queue(front: seq<T>, rear: seq<T>)\n\nfunction {:spec} queueEmpty<T>(): Queue<T>\n{\n  Queue([], [])\n}\n\npredicate {:spec} queueIsEmpty<T>(q: Queue<T>)\n{\n  q.front == [] && q.rear == []\n}\n\nfunction {:spec} enqueue<T>(q: Queue<T>, x: T): Queue<T>\n{\n  Queue(q.front, [x] + q.rear)\n}\n\nfunction {:spec} dequeue<T>(q: Queue<T>): Queue<T>\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    Queue(q.front[1..], q.rear)\n  else\n    // Front is empty, so we reverse rear and put it in front\n    if |q.rear| == 1 then\n      Queue([], [])\n    else\n      Queue(reverse(q.rear)[1..], [])\n}\n\nfunction {:spec} queueFront<T>(q: Queue<T>): T\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    q.front[0]\n  else\n    // Front is empty, so the front element is the first element of rear (when reversed)\n    q.rear[|q.rear| - 1]\n}\n\nfunction {:spec} queueSize<T>(q: Queue<T>): nat\n{\n  |q.front| + |q.rear|\n}\n\nfunction {:spec} queueToSeq<T>(q: Queue<T>): seq<T>\n{\n  q.front + reverse(q.rear)\n}\n\nfunction reverse<T>(s: seq<T>): seq<T>\n{\n  if |s| == 0 then []\n  else reverse(s[1..]) + [s[0]]\n}\n\n// Alternative queue representation with invariant\ndatatype SimpleQueue<T> = SimpleQueue(elements: seq<T>)\n\nfunction {:spec} simpleQueueEmpty<T>(): SimpleQueue<T>\n{\n  SimpleQueue([])\n}\n\npredicate {:spec} simpleQueueIsEmpty<T>(q: SimpleQueue<T>)\n{\n  q.elements == []\n}\n\nfunction {:spec} simpleEnqueue<T>(q: SimpleQueue<T>, x: T): SimpleQueue<T>\n{\n  SimpleQueue(q.elements + [x])\n}\n\nfunction {:spec} simpleDequeue<T>(q: SimpleQueue<T>): SimpleQueue<T>\n  requires !simpleQueueIsEmpty(q)\n{\n  SimpleQueue(q.elements[1..])\n}\n\nfunction {:spec} simpleQueueFront<T>(q: SimpleQueue<T>): T\n  requires !simpleQueueIsEmpty(q)\n{\n  q.elements[0]\n}\n\nfunction {:spec} simpleQueueSize<T>(q: SimpleQueue<T>): nat\n{\n  |q.elements|\n}\n\nlemma ReverseLength<T>(s: seq<T>)\n  ensures |reverse(s)| == |s|\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseLength(s[1..]);\n    assert |reverse(s)| == |reverse(s[1..])| + 1;\n  }\n}\n\nlemma ReverseReverse<T>(s: seq<T>)\n  ensures reverse(reverse(s)) == s\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseReverse(s[1..]);\n    ReverseAppend(reverse(s[1..]), [s[0]]);\n    assert reverse(reverse(s)) == s;\n  }\n}\n\nlemma ReverseAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n  } else {\n    assert s1 + s2 == [s1[0]] + (s1[1..] + s2);\n    ReverseAppend(s1[1..], s2);\n  }\n}\n\nlemma ReverseFirst<T>(s: seq<T>)\n  requires |s| > 0\n  ensures |reverse(s)| == |s|\n  ensures reverse(s)[|reverse(s)| - 1] == s[0]\n  ensures reverse(s)[0] == s[|s| - 1]\n{\n  ReverseLength(s);\n  if |s| == 1 {\n    assert reverse(s) == [s[0]];\n  } else {\n    ReverseFirst(s[1..]);\n    assert reverse(s) == reverse(s[1..]) + [s[0]];\n    ReverseLength(s[1..]);\n    assert |reverse(s[1..])| == |s| - 1;\n  }\n}\n\nlemma SeqAssoc<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures a + (b + c) == (a + b) + c\n{\n  // Dafny proves this automatically\n}\n\nlemma QueueSizeProperty<T>(q: Queue<T>)\n  ensures queueSize(q) == |queueToSeq(q)|\n{\n  \n/*[CODE HERE]*/\n}\n\nlemma EnqueueCorrect<T>(q: Queue<T>, x: T)\n  ensures queueToSeq(enqueue(q, x)) == queueToSeq(q) + [x]\n  ensures queueSize(enqueue(q, x)) == queueSize(q) + 1\n{\n  var q' := enqueue(q, x);\n  assert q'.front == q.front;\n  assert q'.rear == [x] + q.rear;\n\n  ReverseAppend([x], q.rear);\n  assert reverse([x]) == [x];\n  assert reverse([x] + q.rear) == reverse(q.rear) + reverse([x]);\n  assert reverse([x] + q.rear) == reverse(q.rear) + [x];\n\n  calc == {\n    queueToSeq(q');\n    q'.front + reverse(q'.rear);\n    q.front + reverse([x] + q.rear);\n    q.front + (reverse(q.rear) + [x]);\n    { SeqAssoc(q.front, reverse(q.rear), [x]); }\n    (q.front + reverse(q.rear)) + [x];\n    queueToSeq(q) + [x];\n  }\n\n  QueueSizeProperty(q);\n  QueueSizeProperty(q');\n}\n\nlemma DequeueCorrect<T>(q: Queue<T>)\n  requires !queueIsEmpty(q)\n  ensures |queueToSeq(q)| > 0\n  ensures queueToSeq(dequeue(q)) == queueToSeq(q)[1..]\n  ensures queueFront(q) == queueToSeq(q)[0]\n{\n  if |q.front| > 0 {\n    assert queueToSeq(q) == q.front + reverse(q.rear);\n    assert queueToSeq(dequeue(q)) == q.front[1..] + reverse(q.rear);\n    assert queueFront(q) == q.front[0];\n  } else {\n    assert q.front == [];\n    assert |q.rear| > 0;\n    var rev := reverse(q.rear);\n    ReverseLength(q.rear);\n    assert |rev| == |q.rear|;\n    assert queueToSeq(q) == rev;\n    assert queueFront(q) == q.rear[|q.rear| - 1];\n\n    ReverseFirst(q.rear);\n    assert rev[0] == q.rear[|q.rear| - 1];\n\n    if |q.rear| == 1 {\n      assert rev == [q.rear[0]];\n      assert queueToSeq(q) == [q.rear[0]];\n      assert queueFront(q) == q.rear[0];\n      assert queueToSeq(q)[0] == q.rear[0];\n    } else {\n      assert |rev| > 1;\n      assert queueToSeq(dequeue(q)) == rev[1..];\n      assert queueFront(q) == rev[0];\n    }\n  }\n}\n\nlemma SimpleQueueEquivalence<T>(sq: SimpleQueue<T>, q: Queue<T>)\n  requires sq.elements == queueToSeq(q)\n  ensures simpleQueueIsEmpty(sq) == queueIsEmpty(q)\n  ensures simpleQueueSize(sq) == queueSize(q)\n{\n  if queueIsEmpty(q) {\n    assert q.front == [] && q.rear == [];\n    assert queueToSeq(q) == [];\n    assert sq.elements == [];\n  }\n  QueueSizeProperty(q);\n}", "output": "ReverseLength(q.rear);"}, {"id": "example_EnqueueCorrect_0", "type": "call", "program": "// Queue operations: enqueue, dequeue, isEmpty, size\n\ndatatype Queue<T> = Queue(front: seq<T>, rear: seq<T>)\n\nfunction {:spec} queueEmpty<T>(): Queue<T>\n{\n  Queue([], [])\n}\n\npredicate {:spec} queueIsEmpty<T>(q: Queue<T>)\n{\n  q.front == [] && q.rear == []\n}\n\nfunction {:spec} enqueue<T>(q: Queue<T>, x: T): Queue<T>\n{\n  Queue(q.front, [x] + q.rear)\n}\n\nfunction {:spec} dequeue<T>(q: Queue<T>): Queue<T>\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    Queue(q.front[1..], q.rear)\n  else\n    // Front is empty, so we reverse rear and put it in front\n    if |q.rear| == 1 then\n      Queue([], [])\n    else\n      Queue(reverse(q.rear)[1..], [])\n}\n\nfunction {:spec} queueFront<T>(q: Queue<T>): T\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    q.front[0]\n  else\n    // Front is empty, so the front element is the first element of rear (when reversed)\n    q.rear[|q.rear| - 1]\n}\n\nfunction {:spec} queueSize<T>(q: Queue<T>): nat\n{\n  |q.front| + |q.rear|\n}\n\nfunction {:spec} queueToSeq<T>(q: Queue<T>): seq<T>\n{\n  q.front + reverse(q.rear)\n}\n\nfunction reverse<T>(s: seq<T>): seq<T>\n{\n  if |s| == 0 then []\n  else reverse(s[1..]) + [s[0]]\n}\n\n// Alternative queue representation with invariant\ndatatype SimpleQueue<T> = SimpleQueue(elements: seq<T>)\n\nfunction {:spec} simpleQueueEmpty<T>(): SimpleQueue<T>\n{\n  SimpleQueue([])\n}\n\npredicate {:spec} simpleQueueIsEmpty<T>(q: SimpleQueue<T>)\n{\n  q.elements == []\n}\n\nfunction {:spec} simpleEnqueue<T>(q: SimpleQueue<T>, x: T): SimpleQueue<T>\n{\n  SimpleQueue(q.elements + [x])\n}\n\nfunction {:spec} simpleDequeue<T>(q: SimpleQueue<T>): SimpleQueue<T>\n  requires !simpleQueueIsEmpty(q)\n{\n  SimpleQueue(q.elements[1..])\n}\n\nfunction {:spec} simpleQueueFront<T>(q: SimpleQueue<T>): T\n  requires !simpleQueueIsEmpty(q)\n{\n  q.elements[0]\n}\n\nfunction {:spec} simpleQueueSize<T>(q: SimpleQueue<T>): nat\n{\n  |q.elements|\n}\n\nlemma ReverseLength<T>(s: seq<T>)\n  ensures |reverse(s)| == |s|\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseLength(s[1..]);\n    assert |reverse(s)| == |reverse(s[1..])| + 1;\n  }\n}\n\nlemma ReverseReverse<T>(s: seq<T>)\n  ensures reverse(reverse(s)) == s\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseReverse(s[1..]);\n    ReverseAppend(reverse(s[1..]), [s[0]]);\n    assert reverse(reverse(s)) == s;\n  }\n}\n\nlemma ReverseAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n  } else {\n    assert s1 + s2 == [s1[0]] + (s1[1..] + s2);\n    ReverseAppend(s1[1..], s2);\n  }\n}\n\nlemma ReverseFirst<T>(s: seq<T>)\n  requires |s| > 0\n  ensures |reverse(s)| == |s|\n  ensures reverse(s)[|reverse(s)| - 1] == s[0]\n  ensures reverse(s)[0] == s[|s| - 1]\n{\n  ReverseLength(s);\n  if |s| == 1 {\n    assert reverse(s) == [s[0]];\n  } else {\n    ReverseFirst(s[1..]);\n    assert reverse(s) == reverse(s[1..]) + [s[0]];\n    ReverseLength(s[1..]);\n    assert |reverse(s[1..])| == |s| - 1;\n  }\n}\n\nlemma SeqAssoc<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures a + (b + c) == (a + b) + c\n{\n  // Dafny proves this automatically\n}\n\nlemma QueueSizeProperty<T>(q: Queue<T>)\n  ensures queueSize(q) == |queueToSeq(q)|\n{\n  ReverseLength(q.rear);\n}\n\nlemma EnqueueCorrect<T>(q: Queue<T>, x: T)\n  ensures queueToSeq(enqueue(q, x)) == queueToSeq(q) + [x]\n  ensures queueSize(enqueue(q, x)) == queueSize(q) + 1\n{\n  var q' := enqueue(q, x);\n  assert q'.front == q.front;\n  assert q'.rear == [x] + q.rear;\n\n  ReverseAppend([x], q.rear);\n  assert reverse([x]) == [x];\n  assert reverse([x] + q.rear) == reverse(q.rear) + reverse([x]);\n  assert reverse([x] + q.rear) == reverse(q.rear) + [x];\n\n  calc == {\n    queueToSeq(q');\n    q'.front + reverse(q'.rear);\n    q.front + reverse([x] + q.rear);\n    q.front + (reverse(q.rear) + [x]);\n    { SeqAssoc(q.front, reverse(q.rear), [x]); }\n    (q.front + reverse(q.rear)) + [x];\n    queueToSeq(q) + [x];\n  }\n\n  QueueSizeProperty(q);\n  \n/*[CODE HERE]*/\n}\n\nlemma DequeueCorrect<T>(q: Queue<T>)\n  requires !queueIsEmpty(q)\n  ensures |queueToSeq(q)| > 0\n  ensures queueToSeq(dequeue(q)) == queueToSeq(q)[1..]\n  ensures queueFront(q) == queueToSeq(q)[0]\n{\n  if |q.front| > 0 {\n    assert queueToSeq(q) == q.front + reverse(q.rear);\n    assert queueToSeq(dequeue(q)) == q.front[1..] + reverse(q.rear);\n    assert queueFront(q) == q.front[0];\n  } else {\n    assert q.front == [];\n    assert |q.rear| > 0;\n    var rev := reverse(q.rear);\n    ReverseLength(q.rear);\n    assert |rev| == |q.rear|;\n    assert queueToSeq(q) == rev;\n    assert queueFront(q) == q.rear[|q.rear| - 1];\n\n    ReverseFirst(q.rear);\n    assert rev[0] == q.rear[|q.rear| - 1];\n\n    if |q.rear| == 1 {\n      assert rev == [q.rear[0]];\n      assert queueToSeq(q) == [q.rear[0]];\n      assert queueFront(q) == q.rear[0];\n      assert queueToSeq(q)[0] == q.rear[0];\n    } else {\n      assert |rev| > 1;\n      assert queueToSeq(dequeue(q)) == rev[1..];\n      assert queueFront(q) == rev[0];\n    }\n  }\n}\n\nlemma SimpleQueueEquivalence<T>(sq: SimpleQueue<T>, q: Queue<T>)\n  requires sq.elements == queueToSeq(q)\n  ensures simpleQueueIsEmpty(sq) == queueIsEmpty(q)\n  ensures simpleQueueSize(sq) == queueSize(q)\n{\n  if queueIsEmpty(q) {\n    assert q.front == [] && q.rear == [];\n    assert queueToSeq(q) == [];\n    assert sq.elements == [];\n  }\n  QueueSizeProperty(q);\n}", "output": "QueueSizeProperty(q');"}, {"id": "example_EnqueueCorrect_1", "type": "call", "program": "// Queue operations: enqueue, dequeue, isEmpty, size\n\ndatatype Queue<T> = Queue(front: seq<T>, rear: seq<T>)\n\nfunction {:spec} queueEmpty<T>(): Queue<T>\n{\n  Queue([], [])\n}\n\npredicate {:spec} queueIsEmpty<T>(q: Queue<T>)\n{\n  q.front == [] && q.rear == []\n}\n\nfunction {:spec} enqueue<T>(q: Queue<T>, x: T): Queue<T>\n{\n  Queue(q.front, [x] + q.rear)\n}\n\nfunction {:spec} dequeue<T>(q: Queue<T>): Queue<T>\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    Queue(q.front[1..], q.rear)\n  else\n    // Front is empty, so we reverse rear and put it in front\n    if |q.rear| == 1 then\n      Queue([], [])\n    else\n      Queue(reverse(q.rear)[1..], [])\n}\n\nfunction {:spec} queueFront<T>(q: Queue<T>): T\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    q.front[0]\n  else\n    // Front is empty, so the front element is the first element of rear (when reversed)\n    q.rear[|q.rear| - 1]\n}\n\nfunction {:spec} queueSize<T>(q: Queue<T>): nat\n{\n  |q.front| + |q.rear|\n}\n\nfunction {:spec} queueToSeq<T>(q: Queue<T>): seq<T>\n{\n  q.front + reverse(q.rear)\n}\n\nfunction reverse<T>(s: seq<T>): seq<T>\n{\n  if |s| == 0 then []\n  else reverse(s[1..]) + [s[0]]\n}\n\n// Alternative queue representation with invariant\ndatatype SimpleQueue<T> = SimpleQueue(elements: seq<T>)\n\nfunction {:spec} simpleQueueEmpty<T>(): SimpleQueue<T>\n{\n  SimpleQueue([])\n}\n\npredicate {:spec} simpleQueueIsEmpty<T>(q: SimpleQueue<T>)\n{\n  q.elements == []\n}\n\nfunction {:spec} simpleEnqueue<T>(q: SimpleQueue<T>, x: T): SimpleQueue<T>\n{\n  SimpleQueue(q.elements + [x])\n}\n\nfunction {:spec} simpleDequeue<T>(q: SimpleQueue<T>): SimpleQueue<T>\n  requires !simpleQueueIsEmpty(q)\n{\n  SimpleQueue(q.elements[1..])\n}\n\nfunction {:spec} simpleQueueFront<T>(q: SimpleQueue<T>): T\n  requires !simpleQueueIsEmpty(q)\n{\n  q.elements[0]\n}\n\nfunction {:spec} simpleQueueSize<T>(q: SimpleQueue<T>): nat\n{\n  |q.elements|\n}\n\nlemma ReverseLength<T>(s: seq<T>)\n  ensures |reverse(s)| == |s|\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseLength(s[1..]);\n    assert |reverse(s)| == |reverse(s[1..])| + 1;\n  }\n}\n\nlemma ReverseReverse<T>(s: seq<T>)\n  ensures reverse(reverse(s)) == s\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseReverse(s[1..]);\n    ReverseAppend(reverse(s[1..]), [s[0]]);\n    assert reverse(reverse(s)) == s;\n  }\n}\n\nlemma ReverseAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n  } else {\n    assert s1 + s2 == [s1[0]] + (s1[1..] + s2);\n    ReverseAppend(s1[1..], s2);\n  }\n}\n\nlemma ReverseFirst<T>(s: seq<T>)\n  requires |s| > 0\n  ensures |reverse(s)| == |s|\n  ensures reverse(s)[|reverse(s)| - 1] == s[0]\n  ensures reverse(s)[0] == s[|s| - 1]\n{\n  ReverseLength(s);\n  if |s| == 1 {\n    assert reverse(s) == [s[0]];\n  } else {\n    ReverseFirst(s[1..]);\n    assert reverse(s) == reverse(s[1..]) + [s[0]];\n    ReverseLength(s[1..]);\n    assert |reverse(s[1..])| == |s| - 1;\n  }\n}\n\nlemma SeqAssoc<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures a + (b + c) == (a + b) + c\n{\n  // Dafny proves this automatically\n}\n\nlemma QueueSizeProperty<T>(q: Queue<T>)\n  ensures queueSize(q) == |queueToSeq(q)|\n{\n  ReverseLength(q.rear);\n}\n\nlemma EnqueueCorrect<T>(q: Queue<T>, x: T)\n  ensures queueToSeq(enqueue(q, x)) == queueToSeq(q) + [x]\n  ensures queueSize(enqueue(q, x)) == queueSize(q) + 1\n{\n  var q' := enqueue(q, x);\n  assert q'.front == q.front;\n  assert q'.rear == [x] + q.rear;\n\n  ReverseAppend([x], q.rear);\n  assert reverse([x]) == [x];\n  assert reverse([x] + q.rear) == reverse(q.rear) + reverse([x]);\n  assert reverse([x] + q.rear) == reverse(q.rear) + [x];\n\n  calc == {\n    queueToSeq(q');\n    q'.front + reverse(q'.rear);\n    q.front + reverse([x] + q.rear);\n    q.front + (reverse(q.rear) + [x]);\n    { SeqAssoc(q.front, reverse(q.rear), [x]); }\n    (q.front + reverse(q.rear)) + [x];\n    queueToSeq(q) + [x];\n  }\n\n  \n/*[CODE HERE]*/\n  QueueSizeProperty(q');\n}\n\nlemma DequeueCorrect<T>(q: Queue<T>)\n  requires !queueIsEmpty(q)\n  ensures |queueToSeq(q)| > 0\n  ensures queueToSeq(dequeue(q)) == queueToSeq(q)[1..]\n  ensures queueFront(q) == queueToSeq(q)[0]\n{\n  if |q.front| > 0 {\n    assert queueToSeq(q) == q.front + reverse(q.rear);\n    assert queueToSeq(dequeue(q)) == q.front[1..] + reverse(q.rear);\n    assert queueFront(q) == q.front[0];\n  } else {\n    assert q.front == [];\n    assert |q.rear| > 0;\n    var rev := reverse(q.rear);\n    ReverseLength(q.rear);\n    assert |rev| == |q.rear|;\n    assert queueToSeq(q) == rev;\n    assert queueFront(q) == q.rear[|q.rear| - 1];\n\n    ReverseFirst(q.rear);\n    assert rev[0] == q.rear[|q.rear| - 1];\n\n    if |q.rear| == 1 {\n      assert rev == [q.rear[0]];\n      assert queueToSeq(q) == [q.rear[0]];\n      assert queueFront(q) == q.rear[0];\n      assert queueToSeq(q)[0] == q.rear[0];\n    } else {\n      assert |rev| > 1;\n      assert queueToSeq(dequeue(q)) == rev[1..];\n      assert queueFront(q) == rev[0];\n    }\n  }\n}\n\nlemma SimpleQueueEquivalence<T>(sq: SimpleQueue<T>, q: Queue<T>)\n  requires sq.elements == queueToSeq(q)\n  ensures simpleQueueIsEmpty(sq) == queueIsEmpty(q)\n  ensures simpleQueueSize(sq) == queueSize(q)\n{\n  if queueIsEmpty(q) {\n    assert q.front == [] && q.rear == [];\n    assert queueToSeq(q) == [];\n    assert sq.elements == [];\n  }\n  QueueSizeProperty(q);\n}", "output": "QueueSizeProperty(q);"}, {"id": "example_EnqueueCorrect_2", "type": "call", "program": "// Queue operations: enqueue, dequeue, isEmpty, size\n\ndatatype Queue<T> = Queue(front: seq<T>, rear: seq<T>)\n\nfunction {:spec} queueEmpty<T>(): Queue<T>\n{\n  Queue([], [])\n}\n\npredicate {:spec} queueIsEmpty<T>(q: Queue<T>)\n{\n  q.front == [] && q.rear == []\n}\n\nfunction {:spec} enqueue<T>(q: Queue<T>, x: T): Queue<T>\n{\n  Queue(q.front, [x] + q.rear)\n}\n\nfunction {:spec} dequeue<T>(q: Queue<T>): Queue<T>\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    Queue(q.front[1..], q.rear)\n  else\n    // Front is empty, so we reverse rear and put it in front\n    if |q.rear| == 1 then\n      Queue([], [])\n    else\n      Queue(reverse(q.rear)[1..], [])\n}\n\nfunction {:spec} queueFront<T>(q: Queue<T>): T\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    q.front[0]\n  else\n    // Front is empty, so the front element is the first element of rear (when reversed)\n    q.rear[|q.rear| - 1]\n}\n\nfunction {:spec} queueSize<T>(q: Queue<T>): nat\n{\n  |q.front| + |q.rear|\n}\n\nfunction {:spec} queueToSeq<T>(q: Queue<T>): seq<T>\n{\n  q.front + reverse(q.rear)\n}\n\nfunction reverse<T>(s: seq<T>): seq<T>\n{\n  if |s| == 0 then []\n  else reverse(s[1..]) + [s[0]]\n}\n\n// Alternative queue representation with invariant\ndatatype SimpleQueue<T> = SimpleQueue(elements: seq<T>)\n\nfunction {:spec} simpleQueueEmpty<T>(): SimpleQueue<T>\n{\n  SimpleQueue([])\n}\n\npredicate {:spec} simpleQueueIsEmpty<T>(q: SimpleQueue<T>)\n{\n  q.elements == []\n}\n\nfunction {:spec} simpleEnqueue<T>(q: SimpleQueue<T>, x: T): SimpleQueue<T>\n{\n  SimpleQueue(q.elements + [x])\n}\n\nfunction {:spec} simpleDequeue<T>(q: SimpleQueue<T>): SimpleQueue<T>\n  requires !simpleQueueIsEmpty(q)\n{\n  SimpleQueue(q.elements[1..])\n}\n\nfunction {:spec} simpleQueueFront<T>(q: SimpleQueue<T>): T\n  requires !simpleQueueIsEmpty(q)\n{\n  q.elements[0]\n}\n\nfunction {:spec} simpleQueueSize<T>(q: SimpleQueue<T>): nat\n{\n  |q.elements|\n}\n\nlemma ReverseLength<T>(s: seq<T>)\n  ensures |reverse(s)| == |s|\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseLength(s[1..]);\n    assert |reverse(s)| == |reverse(s[1..])| + 1;\n  }\n}\n\nlemma ReverseReverse<T>(s: seq<T>)\n  ensures reverse(reverse(s)) == s\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseReverse(s[1..]);\n    ReverseAppend(reverse(s[1..]), [s[0]]);\n    assert reverse(reverse(s)) == s;\n  }\n}\n\nlemma ReverseAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n  } else {\n    assert s1 + s2 == [s1[0]] + (s1[1..] + s2);\n    ReverseAppend(s1[1..], s2);\n  }\n}\n\nlemma ReverseFirst<T>(s: seq<T>)\n  requires |s| > 0\n  ensures |reverse(s)| == |s|\n  ensures reverse(s)[|reverse(s)| - 1] == s[0]\n  ensures reverse(s)[0] == s[|s| - 1]\n{\n  ReverseLength(s);\n  if |s| == 1 {\n    assert reverse(s) == [s[0]];\n  } else {\n    ReverseFirst(s[1..]);\n    assert reverse(s) == reverse(s[1..]) + [s[0]];\n    ReverseLength(s[1..]);\n    assert |reverse(s[1..])| == |s| - 1;\n  }\n}\n\nlemma SeqAssoc<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures a + (b + c) == (a + b) + c\n{\n  // Dafny proves this automatically\n}\n\nlemma QueueSizeProperty<T>(q: Queue<T>)\n  ensures queueSize(q) == |queueToSeq(q)|\n{\n  ReverseLength(q.rear);\n}\n\nlemma EnqueueCorrect<T>(q: Queue<T>, x: T)\n  ensures queueToSeq(enqueue(q, x)) == queueToSeq(q) + [x]\n  ensures queueSize(enqueue(q, x)) == queueSize(q) + 1\n{\n  var q' := enqueue(q, x);\n  assert q'.front == q.front;\n  assert q'.rear == [x] + q.rear;\n\n  ReverseAppend([x], q.rear);\n  assert reverse([x]) == [x];\n  assert reverse([x] + q.rear) == reverse(q.rear) + reverse([x]);\n  assert reverse([x] + q.rear) == reverse(q.rear) + [x];\n\n  calc == {\n    queueToSeq(q');\n    q'.front + reverse(q'.rear);\n    q.front + reverse([x] + q.rear);\n    q.front + (reverse(q.rear) + [x]);\n    { \n/*[CODE HERE]*/\n}\n    (q.front + reverse(q.rear)) + [x];\n    queueToSeq(q) + [x];\n  }\n\n  QueueSizeProperty(q);\n  QueueSizeProperty(q');\n}\n\nlemma DequeueCorrect<T>(q: Queue<T>)\n  requires !queueIsEmpty(q)\n  ensures |queueToSeq(q)| > 0\n  ensures queueToSeq(dequeue(q)) == queueToSeq(q)[1..]\n  ensures queueFront(q) == queueToSeq(q)[0]\n{\n  if |q.front| > 0 {\n    assert queueToSeq(q) == q.front + reverse(q.rear);\n    assert queueToSeq(dequeue(q)) == q.front[1..] + reverse(q.rear);\n    assert queueFront(q) == q.front[0];\n  } else {\n    assert q.front == [];\n    assert |q.rear| > 0;\n    var rev := reverse(q.rear);\n    ReverseLength(q.rear);\n    assert |rev| == |q.rear|;\n    assert queueToSeq(q) == rev;\n    assert queueFront(q) == q.rear[|q.rear| - 1];\n\n    ReverseFirst(q.rear);\n    assert rev[0] == q.rear[|q.rear| - 1];\n\n    if |q.rear| == 1 {\n      assert rev == [q.rear[0]];\n      assert queueToSeq(q) == [q.rear[0]];\n      assert queueFront(q) == q.rear[0];\n      assert queueToSeq(q)[0] == q.rear[0];\n    } else {\n      assert |rev| > 1;\n      assert queueToSeq(dequeue(q)) == rev[1..];\n      assert queueFront(q) == rev[0];\n    }\n  }\n}\n\nlemma SimpleQueueEquivalence<T>(sq: SimpleQueue<T>, q: Queue<T>)\n  requires sq.elements == queueToSeq(q)\n  ensures simpleQueueIsEmpty(sq) == queueIsEmpty(q)\n  ensures simpleQueueSize(sq) == queueSize(q)\n{\n  if queueIsEmpty(q) {\n    assert q.front == [] && q.rear == [];\n    assert queueToSeq(q) == [];\n    assert sq.elements == [];\n  }\n  QueueSizeProperty(q);\n}", "output": "SeqAssoc(q.front, reverse(q.rear), [x]);"}, {"id": "example_EnqueueCorrect_3", "type": "assert", "program": "// Queue operations: enqueue, dequeue, isEmpty, size\n\ndatatype Queue<T> = Queue(front: seq<T>, rear: seq<T>)\n\nfunction {:spec} queueEmpty<T>(): Queue<T>\n{\n  Queue([], [])\n}\n\npredicate {:spec} queueIsEmpty<T>(q: Queue<T>)\n{\n  q.front == [] && q.rear == []\n}\n\nfunction {:spec} enqueue<T>(q: Queue<T>, x: T): Queue<T>\n{\n  Queue(q.front, [x] + q.rear)\n}\n\nfunction {:spec} dequeue<T>(q: Queue<T>): Queue<T>\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    Queue(q.front[1..], q.rear)\n  else\n    // Front is empty, so we reverse rear and put it in front\n    if |q.rear| == 1 then\n      Queue([], [])\n    else\n      Queue(reverse(q.rear)[1..], [])\n}\n\nfunction {:spec} queueFront<T>(q: Queue<T>): T\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    q.front[0]\n  else\n    // Front is empty, so the front element is the first element of rear (when reversed)\n    q.rear[|q.rear| - 1]\n}\n\nfunction {:spec} queueSize<T>(q: Queue<T>): nat\n{\n  |q.front| + |q.rear|\n}\n\nfunction {:spec} queueToSeq<T>(q: Queue<T>): seq<T>\n{\n  q.front + reverse(q.rear)\n}\n\nfunction reverse<T>(s: seq<T>): seq<T>\n{\n  if |s| == 0 then []\n  else reverse(s[1..]) + [s[0]]\n}\n\n// Alternative queue representation with invariant\ndatatype SimpleQueue<T> = SimpleQueue(elements: seq<T>)\n\nfunction {:spec} simpleQueueEmpty<T>(): SimpleQueue<T>\n{\n  SimpleQueue([])\n}\n\npredicate {:spec} simpleQueueIsEmpty<T>(q: SimpleQueue<T>)\n{\n  q.elements == []\n}\n\nfunction {:spec} simpleEnqueue<T>(q: SimpleQueue<T>, x: T): SimpleQueue<T>\n{\n  SimpleQueue(q.elements + [x])\n}\n\nfunction {:spec} simpleDequeue<T>(q: SimpleQueue<T>): SimpleQueue<T>\n  requires !simpleQueueIsEmpty(q)\n{\n  SimpleQueue(q.elements[1..])\n}\n\nfunction {:spec} simpleQueueFront<T>(q: SimpleQueue<T>): T\n  requires !simpleQueueIsEmpty(q)\n{\n  q.elements[0]\n}\n\nfunction {:spec} simpleQueueSize<T>(q: SimpleQueue<T>): nat\n{\n  |q.elements|\n}\n\nlemma ReverseLength<T>(s: seq<T>)\n  ensures |reverse(s)| == |s|\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseLength(s[1..]);\n    assert |reverse(s)| == |reverse(s[1..])| + 1;\n  }\n}\n\nlemma ReverseReverse<T>(s: seq<T>)\n  ensures reverse(reverse(s)) == s\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseReverse(s[1..]);\n    ReverseAppend(reverse(s[1..]), [s[0]]);\n    assert reverse(reverse(s)) == s;\n  }\n}\n\nlemma ReverseAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n  } else {\n    assert s1 + s2 == [s1[0]] + (s1[1..] + s2);\n    ReverseAppend(s1[1..], s2);\n  }\n}\n\nlemma ReverseFirst<T>(s: seq<T>)\n  requires |s| > 0\n  ensures |reverse(s)| == |s|\n  ensures reverse(s)[|reverse(s)| - 1] == s[0]\n  ensures reverse(s)[0] == s[|s| - 1]\n{\n  ReverseLength(s);\n  if |s| == 1 {\n    assert reverse(s) == [s[0]];\n  } else {\n    ReverseFirst(s[1..]);\n    assert reverse(s) == reverse(s[1..]) + [s[0]];\n    ReverseLength(s[1..]);\n    assert |reverse(s[1..])| == |s| - 1;\n  }\n}\n\nlemma SeqAssoc<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures a + (b + c) == (a + b) + c\n{\n  // Dafny proves this automatically\n}\n\nlemma QueueSizeProperty<T>(q: Queue<T>)\n  ensures queueSize(q) == |queueToSeq(q)|\n{\n  ReverseLength(q.rear);\n}\n\nlemma EnqueueCorrect<T>(q: Queue<T>, x: T)\n  ensures queueToSeq(enqueue(q, x)) == queueToSeq(q) + [x]\n  ensures queueSize(enqueue(q, x)) == queueSize(q) + 1\n{\n  var q' := enqueue(q, x);\n  assert q'.front == q.front;\n  assert q'.rear == [x] + q.rear;\n\n  ReverseAppend([x], q.rear);\n  assert reverse([x]) == [x];\n  assert reverse([x] + q.rear) == reverse(q.rear) + reverse([x]);\n  \n/*[CODE HERE]*/\n\n  calc == {\n    queueToSeq(q');\n    q'.front + reverse(q'.rear);\n    q.front + reverse([x] + q.rear);\n    q.front + (reverse(q.rear) + [x]);\n    { SeqAssoc(q.front, reverse(q.rear), [x]); }\n    (q.front + reverse(q.rear)) + [x];\n    queueToSeq(q) + [x];\n  }\n\n  QueueSizeProperty(q);\n  QueueSizeProperty(q');\n}\n\nlemma DequeueCorrect<T>(q: Queue<T>)\n  requires !queueIsEmpty(q)\n  ensures |queueToSeq(q)| > 0\n  ensures queueToSeq(dequeue(q)) == queueToSeq(q)[1..]\n  ensures queueFront(q) == queueToSeq(q)[0]\n{\n  if |q.front| > 0 {\n    assert queueToSeq(q) == q.front + reverse(q.rear);\n    assert queueToSeq(dequeue(q)) == q.front[1..] + reverse(q.rear);\n    assert queueFront(q) == q.front[0];\n  } else {\n    assert q.front == [];\n    assert |q.rear| > 0;\n    var rev := reverse(q.rear);\n    ReverseLength(q.rear);\n    assert |rev| == |q.rear|;\n    assert queueToSeq(q) == rev;\n    assert queueFront(q) == q.rear[|q.rear| - 1];\n\n    ReverseFirst(q.rear);\n    assert rev[0] == q.rear[|q.rear| - 1];\n\n    if |q.rear| == 1 {\n      assert rev == [q.rear[0]];\n      assert queueToSeq(q) == [q.rear[0]];\n      assert queueFront(q) == q.rear[0];\n      assert queueToSeq(q)[0] == q.rear[0];\n    } else {\n      assert |rev| > 1;\n      assert queueToSeq(dequeue(q)) == rev[1..];\n      assert queueFront(q) == rev[0];\n    }\n  }\n}\n\nlemma SimpleQueueEquivalence<T>(sq: SimpleQueue<T>, q: Queue<T>)\n  requires sq.elements == queueToSeq(q)\n  ensures simpleQueueIsEmpty(sq) == queueIsEmpty(q)\n  ensures simpleQueueSize(sq) == queueSize(q)\n{\n  if queueIsEmpty(q) {\n    assert q.front == [] && q.rear == [];\n    assert queueToSeq(q) == [];\n    assert sq.elements == [];\n  }\n  QueueSizeProperty(q);\n}", "output": "assert reverse([x] + q.rear) == reverse(q.rear) + [x];"}, {"id": "example_EnqueueCorrect_4", "type": "assert", "program": "// Queue operations: enqueue, dequeue, isEmpty, size\n\ndatatype Queue<T> = Queue(front: seq<T>, rear: seq<T>)\n\nfunction {:spec} queueEmpty<T>(): Queue<T>\n{\n  Queue([], [])\n}\n\npredicate {:spec} queueIsEmpty<T>(q: Queue<T>)\n{\n  q.front == [] && q.rear == []\n}\n\nfunction {:spec} enqueue<T>(q: Queue<T>, x: T): Queue<T>\n{\n  Queue(q.front, [x] + q.rear)\n}\n\nfunction {:spec} dequeue<T>(q: Queue<T>): Queue<T>\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    Queue(q.front[1..], q.rear)\n  else\n    // Front is empty, so we reverse rear and put it in front\n    if |q.rear| == 1 then\n      Queue([], [])\n    else\n      Queue(reverse(q.rear)[1..], [])\n}\n\nfunction {:spec} queueFront<T>(q: Queue<T>): T\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    q.front[0]\n  else\n    // Front is empty, so the front element is the first element of rear (when reversed)\n    q.rear[|q.rear| - 1]\n}\n\nfunction {:spec} queueSize<T>(q: Queue<T>): nat\n{\n  |q.front| + |q.rear|\n}\n\nfunction {:spec} queueToSeq<T>(q: Queue<T>): seq<T>\n{\n  q.front + reverse(q.rear)\n}\n\nfunction reverse<T>(s: seq<T>): seq<T>\n{\n  if |s| == 0 then []\n  else reverse(s[1..]) + [s[0]]\n}\n\n// Alternative queue representation with invariant\ndatatype SimpleQueue<T> = SimpleQueue(elements: seq<T>)\n\nfunction {:spec} simpleQueueEmpty<T>(): SimpleQueue<T>\n{\n  SimpleQueue([])\n}\n\npredicate {:spec} simpleQueueIsEmpty<T>(q: SimpleQueue<T>)\n{\n  q.elements == []\n}\n\nfunction {:spec} simpleEnqueue<T>(q: SimpleQueue<T>, x: T): SimpleQueue<T>\n{\n  SimpleQueue(q.elements + [x])\n}\n\nfunction {:spec} simpleDequeue<T>(q: SimpleQueue<T>): SimpleQueue<T>\n  requires !simpleQueueIsEmpty(q)\n{\n  SimpleQueue(q.elements[1..])\n}\n\nfunction {:spec} simpleQueueFront<T>(q: SimpleQueue<T>): T\n  requires !simpleQueueIsEmpty(q)\n{\n  q.elements[0]\n}\n\nfunction {:spec} simpleQueueSize<T>(q: SimpleQueue<T>): nat\n{\n  |q.elements|\n}\n\nlemma ReverseLength<T>(s: seq<T>)\n  ensures |reverse(s)| == |s|\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseLength(s[1..]);\n    assert |reverse(s)| == |reverse(s[1..])| + 1;\n  }\n}\n\nlemma ReverseReverse<T>(s: seq<T>)\n  ensures reverse(reverse(s)) == s\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseReverse(s[1..]);\n    ReverseAppend(reverse(s[1..]), [s[0]]);\n    assert reverse(reverse(s)) == s;\n  }\n}\n\nlemma ReverseAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n  } else {\n    assert s1 + s2 == [s1[0]] + (s1[1..] + s2);\n    ReverseAppend(s1[1..], s2);\n  }\n}\n\nlemma ReverseFirst<T>(s: seq<T>)\n  requires |s| > 0\n  ensures |reverse(s)| == |s|\n  ensures reverse(s)[|reverse(s)| - 1] == s[0]\n  ensures reverse(s)[0] == s[|s| - 1]\n{\n  ReverseLength(s);\n  if |s| == 1 {\n    assert reverse(s) == [s[0]];\n  } else {\n    ReverseFirst(s[1..]);\n    assert reverse(s) == reverse(s[1..]) + [s[0]];\n    ReverseLength(s[1..]);\n    assert |reverse(s[1..])| == |s| - 1;\n  }\n}\n\nlemma SeqAssoc<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures a + (b + c) == (a + b) + c\n{\n  // Dafny proves this automatically\n}\n\nlemma QueueSizeProperty<T>(q: Queue<T>)\n  ensures queueSize(q) == |queueToSeq(q)|\n{\n  ReverseLength(q.rear);\n}\n\nlemma EnqueueCorrect<T>(q: Queue<T>, x: T)\n  ensures queueToSeq(enqueue(q, x)) == queueToSeq(q) + [x]\n  ensures queueSize(enqueue(q, x)) == queueSize(q) + 1\n{\n  var q' := enqueue(q, x);\n  assert q'.front == q.front;\n  assert q'.rear == [x] + q.rear;\n\n  ReverseAppend([x], q.rear);\n  assert reverse([x]) == [x];\n  \n/*[CODE HERE]*/\n  assert reverse([x] + q.rear) == reverse(q.rear) + [x];\n\n  calc == {\n    queueToSeq(q');\n    q'.front + reverse(q'.rear);\n    q.front + reverse([x] + q.rear);\n    q.front + (reverse(q.rear) + [x]);\n    { SeqAssoc(q.front, reverse(q.rear), [x]); }\n    (q.front + reverse(q.rear)) + [x];\n    queueToSeq(q) + [x];\n  }\n\n  QueueSizeProperty(q);\n  QueueSizeProperty(q');\n}\n\nlemma DequeueCorrect<T>(q: Queue<T>)\n  requires !queueIsEmpty(q)\n  ensures |queueToSeq(q)| > 0\n  ensures queueToSeq(dequeue(q)) == queueToSeq(q)[1..]\n  ensures queueFront(q) == queueToSeq(q)[0]\n{\n  if |q.front| > 0 {\n    assert queueToSeq(q) == q.front + reverse(q.rear);\n    assert queueToSeq(dequeue(q)) == q.front[1..] + reverse(q.rear);\n    assert queueFront(q) == q.front[0];\n  } else {\n    assert q.front == [];\n    assert |q.rear| > 0;\n    var rev := reverse(q.rear);\n    ReverseLength(q.rear);\n    assert |rev| == |q.rear|;\n    assert queueToSeq(q) == rev;\n    assert queueFront(q) == q.rear[|q.rear| - 1];\n\n    ReverseFirst(q.rear);\n    assert rev[0] == q.rear[|q.rear| - 1];\n\n    if |q.rear| == 1 {\n      assert rev == [q.rear[0]];\n      assert queueToSeq(q) == [q.rear[0]];\n      assert queueFront(q) == q.rear[0];\n      assert queueToSeq(q)[0] == q.rear[0];\n    } else {\n      assert |rev| > 1;\n      assert queueToSeq(dequeue(q)) == rev[1..];\n      assert queueFront(q) == rev[0];\n    }\n  }\n}\n\nlemma SimpleQueueEquivalence<T>(sq: SimpleQueue<T>, q: Queue<T>)\n  requires sq.elements == queueToSeq(q)\n  ensures simpleQueueIsEmpty(sq) == queueIsEmpty(q)\n  ensures simpleQueueSize(sq) == queueSize(q)\n{\n  if queueIsEmpty(q) {\n    assert q.front == [] && q.rear == [];\n    assert queueToSeq(q) == [];\n    assert sq.elements == [];\n  }\n  QueueSizeProperty(q);\n}", "output": "assert reverse([x] + q.rear) == reverse(q.rear) + reverse([x]);"}, {"id": "example_EnqueueCorrect_5", "type": "assert", "program": "// Queue operations: enqueue, dequeue, isEmpty, size\n\ndatatype Queue<T> = Queue(front: seq<T>, rear: seq<T>)\n\nfunction {:spec} queueEmpty<T>(): Queue<T>\n{\n  Queue([], [])\n}\n\npredicate {:spec} queueIsEmpty<T>(q: Queue<T>)\n{\n  q.front == [] && q.rear == []\n}\n\nfunction {:spec} enqueue<T>(q: Queue<T>, x: T): Queue<T>\n{\n  Queue(q.front, [x] + q.rear)\n}\n\nfunction {:spec} dequeue<T>(q: Queue<T>): Queue<T>\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    Queue(q.front[1..], q.rear)\n  else\n    // Front is empty, so we reverse rear and put it in front\n    if |q.rear| == 1 then\n      Queue([], [])\n    else\n      Queue(reverse(q.rear)[1..], [])\n}\n\nfunction {:spec} queueFront<T>(q: Queue<T>): T\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    q.front[0]\n  else\n    // Front is empty, so the front element is the first element of rear (when reversed)\n    q.rear[|q.rear| - 1]\n}\n\nfunction {:spec} queueSize<T>(q: Queue<T>): nat\n{\n  |q.front| + |q.rear|\n}\n\nfunction {:spec} queueToSeq<T>(q: Queue<T>): seq<T>\n{\n  q.front + reverse(q.rear)\n}\n\nfunction reverse<T>(s: seq<T>): seq<T>\n{\n  if |s| == 0 then []\n  else reverse(s[1..]) + [s[0]]\n}\n\n// Alternative queue representation with invariant\ndatatype SimpleQueue<T> = SimpleQueue(elements: seq<T>)\n\nfunction {:spec} simpleQueueEmpty<T>(): SimpleQueue<T>\n{\n  SimpleQueue([])\n}\n\npredicate {:spec} simpleQueueIsEmpty<T>(q: SimpleQueue<T>)\n{\n  q.elements == []\n}\n\nfunction {:spec} simpleEnqueue<T>(q: SimpleQueue<T>, x: T): SimpleQueue<T>\n{\n  SimpleQueue(q.elements + [x])\n}\n\nfunction {:spec} simpleDequeue<T>(q: SimpleQueue<T>): SimpleQueue<T>\n  requires !simpleQueueIsEmpty(q)\n{\n  SimpleQueue(q.elements[1..])\n}\n\nfunction {:spec} simpleQueueFront<T>(q: SimpleQueue<T>): T\n  requires !simpleQueueIsEmpty(q)\n{\n  q.elements[0]\n}\n\nfunction {:spec} simpleQueueSize<T>(q: SimpleQueue<T>): nat\n{\n  |q.elements|\n}\n\nlemma ReverseLength<T>(s: seq<T>)\n  ensures |reverse(s)| == |s|\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseLength(s[1..]);\n    assert |reverse(s)| == |reverse(s[1..])| + 1;\n  }\n}\n\nlemma ReverseReverse<T>(s: seq<T>)\n  ensures reverse(reverse(s)) == s\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseReverse(s[1..]);\n    ReverseAppend(reverse(s[1..]), [s[0]]);\n    assert reverse(reverse(s)) == s;\n  }\n}\n\nlemma ReverseAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n  } else {\n    assert s1 + s2 == [s1[0]] + (s1[1..] + s2);\n    ReverseAppend(s1[1..], s2);\n  }\n}\n\nlemma ReverseFirst<T>(s: seq<T>)\n  requires |s| > 0\n  ensures |reverse(s)| == |s|\n  ensures reverse(s)[|reverse(s)| - 1] == s[0]\n  ensures reverse(s)[0] == s[|s| - 1]\n{\n  ReverseLength(s);\n  if |s| == 1 {\n    assert reverse(s) == [s[0]];\n  } else {\n    ReverseFirst(s[1..]);\n    assert reverse(s) == reverse(s[1..]) + [s[0]];\n    ReverseLength(s[1..]);\n    assert |reverse(s[1..])| == |s| - 1;\n  }\n}\n\nlemma SeqAssoc<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures a + (b + c) == (a + b) + c\n{\n  // Dafny proves this automatically\n}\n\nlemma QueueSizeProperty<T>(q: Queue<T>)\n  ensures queueSize(q) == |queueToSeq(q)|\n{\n  ReverseLength(q.rear);\n}\n\nlemma EnqueueCorrect<T>(q: Queue<T>, x: T)\n  ensures queueToSeq(enqueue(q, x)) == queueToSeq(q) + [x]\n  ensures queueSize(enqueue(q, x)) == queueSize(q) + 1\n{\n  var q' := enqueue(q, x);\n  assert q'.front == q.front;\n  assert q'.rear == [x] + q.rear;\n\n  ReverseAppend([x], q.rear);\n  \n/*[CODE HERE]*/\n  assert reverse([x] + q.rear) == reverse(q.rear) + reverse([x]);\n  assert reverse([x] + q.rear) == reverse(q.rear) + [x];\n\n  calc == {\n    queueToSeq(q');\n    q'.front + reverse(q'.rear);\n    q.front + reverse([x] + q.rear);\n    q.front + (reverse(q.rear) + [x]);\n    { SeqAssoc(q.front, reverse(q.rear), [x]); }\n    (q.front + reverse(q.rear)) + [x];\n    queueToSeq(q) + [x];\n  }\n\n  QueueSizeProperty(q);\n  QueueSizeProperty(q');\n}\n\nlemma DequeueCorrect<T>(q: Queue<T>)\n  requires !queueIsEmpty(q)\n  ensures |queueToSeq(q)| > 0\n  ensures queueToSeq(dequeue(q)) == queueToSeq(q)[1..]\n  ensures queueFront(q) == queueToSeq(q)[0]\n{\n  if |q.front| > 0 {\n    assert queueToSeq(q) == q.front + reverse(q.rear);\n    assert queueToSeq(dequeue(q)) == q.front[1..] + reverse(q.rear);\n    assert queueFront(q) == q.front[0];\n  } else {\n    assert q.front == [];\n    assert |q.rear| > 0;\n    var rev := reverse(q.rear);\n    ReverseLength(q.rear);\n    assert |rev| == |q.rear|;\n    assert queueToSeq(q) == rev;\n    assert queueFront(q) == q.rear[|q.rear| - 1];\n\n    ReverseFirst(q.rear);\n    assert rev[0] == q.rear[|q.rear| - 1];\n\n    if |q.rear| == 1 {\n      assert rev == [q.rear[0]];\n      assert queueToSeq(q) == [q.rear[0]];\n      assert queueFront(q) == q.rear[0];\n      assert queueToSeq(q)[0] == q.rear[0];\n    } else {\n      assert |rev| > 1;\n      assert queueToSeq(dequeue(q)) == rev[1..];\n      assert queueFront(q) == rev[0];\n    }\n  }\n}\n\nlemma SimpleQueueEquivalence<T>(sq: SimpleQueue<T>, q: Queue<T>)\n  requires sq.elements == queueToSeq(q)\n  ensures simpleQueueIsEmpty(sq) == queueIsEmpty(q)\n  ensures simpleQueueSize(sq) == queueSize(q)\n{\n  if queueIsEmpty(q) {\n    assert q.front == [] && q.rear == [];\n    assert queueToSeq(q) == [];\n    assert sq.elements == [];\n  }\n  QueueSizeProperty(q);\n}", "output": "assert reverse([x]) == [x];"}, {"id": "example_EnqueueCorrect_6", "type": "call", "program": "// Queue operations: enqueue, dequeue, isEmpty, size\n\ndatatype Queue<T> = Queue(front: seq<T>, rear: seq<T>)\n\nfunction {:spec} queueEmpty<T>(): Queue<T>\n{\n  Queue([], [])\n}\n\npredicate {:spec} queueIsEmpty<T>(q: Queue<T>)\n{\n  q.front == [] && q.rear == []\n}\n\nfunction {:spec} enqueue<T>(q: Queue<T>, x: T): Queue<T>\n{\n  Queue(q.front, [x] + q.rear)\n}\n\nfunction {:spec} dequeue<T>(q: Queue<T>): Queue<T>\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    Queue(q.front[1..], q.rear)\n  else\n    // Front is empty, so we reverse rear and put it in front\n    if |q.rear| == 1 then\n      Queue([], [])\n    else\n      Queue(reverse(q.rear)[1..], [])\n}\n\nfunction {:spec} queueFront<T>(q: Queue<T>): T\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    q.front[0]\n  else\n    // Front is empty, so the front element is the first element of rear (when reversed)\n    q.rear[|q.rear| - 1]\n}\n\nfunction {:spec} queueSize<T>(q: Queue<T>): nat\n{\n  |q.front| + |q.rear|\n}\n\nfunction {:spec} queueToSeq<T>(q: Queue<T>): seq<T>\n{\n  q.front + reverse(q.rear)\n}\n\nfunction reverse<T>(s: seq<T>): seq<T>\n{\n  if |s| == 0 then []\n  else reverse(s[1..]) + [s[0]]\n}\n\n// Alternative queue representation with invariant\ndatatype SimpleQueue<T> = SimpleQueue(elements: seq<T>)\n\nfunction {:spec} simpleQueueEmpty<T>(): SimpleQueue<T>\n{\n  SimpleQueue([])\n}\n\npredicate {:spec} simpleQueueIsEmpty<T>(q: SimpleQueue<T>)\n{\n  q.elements == []\n}\n\nfunction {:spec} simpleEnqueue<T>(q: SimpleQueue<T>, x: T): SimpleQueue<T>\n{\n  SimpleQueue(q.elements + [x])\n}\n\nfunction {:spec} simpleDequeue<T>(q: SimpleQueue<T>): SimpleQueue<T>\n  requires !simpleQueueIsEmpty(q)\n{\n  SimpleQueue(q.elements[1..])\n}\n\nfunction {:spec} simpleQueueFront<T>(q: SimpleQueue<T>): T\n  requires !simpleQueueIsEmpty(q)\n{\n  q.elements[0]\n}\n\nfunction {:spec} simpleQueueSize<T>(q: SimpleQueue<T>): nat\n{\n  |q.elements|\n}\n\nlemma ReverseLength<T>(s: seq<T>)\n  ensures |reverse(s)| == |s|\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseLength(s[1..]);\n    assert |reverse(s)| == |reverse(s[1..])| + 1;\n  }\n}\n\nlemma ReverseReverse<T>(s: seq<T>)\n  ensures reverse(reverse(s)) == s\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseReverse(s[1..]);\n    ReverseAppend(reverse(s[1..]), [s[0]]);\n    assert reverse(reverse(s)) == s;\n  }\n}\n\nlemma ReverseAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n  } else {\n    assert s1 + s2 == [s1[0]] + (s1[1..] + s2);\n    ReverseAppend(s1[1..], s2);\n  }\n}\n\nlemma ReverseFirst<T>(s: seq<T>)\n  requires |s| > 0\n  ensures |reverse(s)| == |s|\n  ensures reverse(s)[|reverse(s)| - 1] == s[0]\n  ensures reverse(s)[0] == s[|s| - 1]\n{\n  ReverseLength(s);\n  if |s| == 1 {\n    assert reverse(s) == [s[0]];\n  } else {\n    ReverseFirst(s[1..]);\n    assert reverse(s) == reverse(s[1..]) + [s[0]];\n    ReverseLength(s[1..]);\n    assert |reverse(s[1..])| == |s| - 1;\n  }\n}\n\nlemma SeqAssoc<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures a + (b + c) == (a + b) + c\n{\n  // Dafny proves this automatically\n}\n\nlemma QueueSizeProperty<T>(q: Queue<T>)\n  ensures queueSize(q) == |queueToSeq(q)|\n{\n  ReverseLength(q.rear);\n}\n\nlemma EnqueueCorrect<T>(q: Queue<T>, x: T)\n  ensures queueToSeq(enqueue(q, x)) == queueToSeq(q) + [x]\n  ensures queueSize(enqueue(q, x)) == queueSize(q) + 1\n{\n  var q' := enqueue(q, x);\n  assert q'.front == q.front;\n  assert q'.rear == [x] + q.rear;\n\n  \n/*[CODE HERE]*/\n  assert reverse([x]) == [x];\n  assert reverse([x] + q.rear) == reverse(q.rear) + reverse([x]);\n  assert reverse([x] + q.rear) == reverse(q.rear) + [x];\n\n  calc == {\n    queueToSeq(q');\n    q'.front + reverse(q'.rear);\n    q.front + reverse([x] + q.rear);\n    q.front + (reverse(q.rear) + [x]);\n    { SeqAssoc(q.front, reverse(q.rear), [x]); }\n    (q.front + reverse(q.rear)) + [x];\n    queueToSeq(q) + [x];\n  }\n\n  QueueSizeProperty(q);\n  QueueSizeProperty(q');\n}\n\nlemma DequeueCorrect<T>(q: Queue<T>)\n  requires !queueIsEmpty(q)\n  ensures |queueToSeq(q)| > 0\n  ensures queueToSeq(dequeue(q)) == queueToSeq(q)[1..]\n  ensures queueFront(q) == queueToSeq(q)[0]\n{\n  if |q.front| > 0 {\n    assert queueToSeq(q) == q.front + reverse(q.rear);\n    assert queueToSeq(dequeue(q)) == q.front[1..] + reverse(q.rear);\n    assert queueFront(q) == q.front[0];\n  } else {\n    assert q.front == [];\n    assert |q.rear| > 0;\n    var rev := reverse(q.rear);\n    ReverseLength(q.rear);\n    assert |rev| == |q.rear|;\n    assert queueToSeq(q) == rev;\n    assert queueFront(q) == q.rear[|q.rear| - 1];\n\n    ReverseFirst(q.rear);\n    assert rev[0] == q.rear[|q.rear| - 1];\n\n    if |q.rear| == 1 {\n      assert rev == [q.rear[0]];\n      assert queueToSeq(q) == [q.rear[0]];\n      assert queueFront(q) == q.rear[0];\n      assert queueToSeq(q)[0] == q.rear[0];\n    } else {\n      assert |rev| > 1;\n      assert queueToSeq(dequeue(q)) == rev[1..];\n      assert queueFront(q) == rev[0];\n    }\n  }\n}\n\nlemma SimpleQueueEquivalence<T>(sq: SimpleQueue<T>, q: Queue<T>)\n  requires sq.elements == queueToSeq(q)\n  ensures simpleQueueIsEmpty(sq) == queueIsEmpty(q)\n  ensures simpleQueueSize(sq) == queueSize(q)\n{\n  if queueIsEmpty(q) {\n    assert q.front == [] && q.rear == [];\n    assert queueToSeq(q) == [];\n    assert sq.elements == [];\n  }\n  QueueSizeProperty(q);\n}", "output": "ReverseAppend([x], q.rear);"}, {"id": "example_EnqueueCorrect_7", "type": "assert", "program": "// Queue operations: enqueue, dequeue, isEmpty, size\n\ndatatype Queue<T> = Queue(front: seq<T>, rear: seq<T>)\n\nfunction {:spec} queueEmpty<T>(): Queue<T>\n{\n  Queue([], [])\n}\n\npredicate {:spec} queueIsEmpty<T>(q: Queue<T>)\n{\n  q.front == [] && q.rear == []\n}\n\nfunction {:spec} enqueue<T>(q: Queue<T>, x: T): Queue<T>\n{\n  Queue(q.front, [x] + q.rear)\n}\n\nfunction {:spec} dequeue<T>(q: Queue<T>): Queue<T>\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    Queue(q.front[1..], q.rear)\n  else\n    // Front is empty, so we reverse rear and put it in front\n    if |q.rear| == 1 then\n      Queue([], [])\n    else\n      Queue(reverse(q.rear)[1..], [])\n}\n\nfunction {:spec} queueFront<T>(q: Queue<T>): T\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    q.front[0]\n  else\n    // Front is empty, so the front element is the first element of rear (when reversed)\n    q.rear[|q.rear| - 1]\n}\n\nfunction {:spec} queueSize<T>(q: Queue<T>): nat\n{\n  |q.front| + |q.rear|\n}\n\nfunction {:spec} queueToSeq<T>(q: Queue<T>): seq<T>\n{\n  q.front + reverse(q.rear)\n}\n\nfunction reverse<T>(s: seq<T>): seq<T>\n{\n  if |s| == 0 then []\n  else reverse(s[1..]) + [s[0]]\n}\n\n// Alternative queue representation with invariant\ndatatype SimpleQueue<T> = SimpleQueue(elements: seq<T>)\n\nfunction {:spec} simpleQueueEmpty<T>(): SimpleQueue<T>\n{\n  SimpleQueue([])\n}\n\npredicate {:spec} simpleQueueIsEmpty<T>(q: SimpleQueue<T>)\n{\n  q.elements == []\n}\n\nfunction {:spec} simpleEnqueue<T>(q: SimpleQueue<T>, x: T): SimpleQueue<T>\n{\n  SimpleQueue(q.elements + [x])\n}\n\nfunction {:spec} simpleDequeue<T>(q: SimpleQueue<T>): SimpleQueue<T>\n  requires !simpleQueueIsEmpty(q)\n{\n  SimpleQueue(q.elements[1..])\n}\n\nfunction {:spec} simpleQueueFront<T>(q: SimpleQueue<T>): T\n  requires !simpleQueueIsEmpty(q)\n{\n  q.elements[0]\n}\n\nfunction {:spec} simpleQueueSize<T>(q: SimpleQueue<T>): nat\n{\n  |q.elements|\n}\n\nlemma ReverseLength<T>(s: seq<T>)\n  ensures |reverse(s)| == |s|\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseLength(s[1..]);\n    assert |reverse(s)| == |reverse(s[1..])| + 1;\n  }\n}\n\nlemma ReverseReverse<T>(s: seq<T>)\n  ensures reverse(reverse(s)) == s\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseReverse(s[1..]);\n    ReverseAppend(reverse(s[1..]), [s[0]]);\n    assert reverse(reverse(s)) == s;\n  }\n}\n\nlemma ReverseAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n  } else {\n    assert s1 + s2 == [s1[0]] + (s1[1..] + s2);\n    ReverseAppend(s1[1..], s2);\n  }\n}\n\nlemma ReverseFirst<T>(s: seq<T>)\n  requires |s| > 0\n  ensures |reverse(s)| == |s|\n  ensures reverse(s)[|reverse(s)| - 1] == s[0]\n  ensures reverse(s)[0] == s[|s| - 1]\n{\n  ReverseLength(s);\n  if |s| == 1 {\n    assert reverse(s) == [s[0]];\n  } else {\n    ReverseFirst(s[1..]);\n    assert reverse(s) == reverse(s[1..]) + [s[0]];\n    ReverseLength(s[1..]);\n    assert |reverse(s[1..])| == |s| - 1;\n  }\n}\n\nlemma SeqAssoc<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures a + (b + c) == (a + b) + c\n{\n  // Dafny proves this automatically\n}\n\nlemma QueueSizeProperty<T>(q: Queue<T>)\n  ensures queueSize(q) == |queueToSeq(q)|\n{\n  ReverseLength(q.rear);\n}\n\nlemma EnqueueCorrect<T>(q: Queue<T>, x: T)\n  ensures queueToSeq(enqueue(q, x)) == queueToSeq(q) + [x]\n  ensures queueSize(enqueue(q, x)) == queueSize(q) + 1\n{\n  var q' := enqueue(q, x);\n  assert q'.front == q.front;\n  \n/*[CODE HERE]*/\n\n  ReverseAppend([x], q.rear);\n  assert reverse([x]) == [x];\n  assert reverse([x] + q.rear) == reverse(q.rear) + reverse([x]);\n  assert reverse([x] + q.rear) == reverse(q.rear) + [x];\n\n  calc == {\n    queueToSeq(q');\n    q'.front + reverse(q'.rear);\n    q.front + reverse([x] + q.rear);\n    q.front + (reverse(q.rear) + [x]);\n    { SeqAssoc(q.front, reverse(q.rear), [x]); }\n    (q.front + reverse(q.rear)) + [x];\n    queueToSeq(q) + [x];\n  }\n\n  QueueSizeProperty(q);\n  QueueSizeProperty(q');\n}\n\nlemma DequeueCorrect<T>(q: Queue<T>)\n  requires !queueIsEmpty(q)\n  ensures |queueToSeq(q)| > 0\n  ensures queueToSeq(dequeue(q)) == queueToSeq(q)[1..]\n  ensures queueFront(q) == queueToSeq(q)[0]\n{\n  if |q.front| > 0 {\n    assert queueToSeq(q) == q.front + reverse(q.rear);\n    assert queueToSeq(dequeue(q)) == q.front[1..] + reverse(q.rear);\n    assert queueFront(q) == q.front[0];\n  } else {\n    assert q.front == [];\n    assert |q.rear| > 0;\n    var rev := reverse(q.rear);\n    ReverseLength(q.rear);\n    assert |rev| == |q.rear|;\n    assert queueToSeq(q) == rev;\n    assert queueFront(q) == q.rear[|q.rear| - 1];\n\n    ReverseFirst(q.rear);\n    assert rev[0] == q.rear[|q.rear| - 1];\n\n    if |q.rear| == 1 {\n      assert rev == [q.rear[0]];\n      assert queueToSeq(q) == [q.rear[0]];\n      assert queueFront(q) == q.rear[0];\n      assert queueToSeq(q)[0] == q.rear[0];\n    } else {\n      assert |rev| > 1;\n      assert queueToSeq(dequeue(q)) == rev[1..];\n      assert queueFront(q) == rev[0];\n    }\n  }\n}\n\nlemma SimpleQueueEquivalence<T>(sq: SimpleQueue<T>, q: Queue<T>)\n  requires sq.elements == queueToSeq(q)\n  ensures simpleQueueIsEmpty(sq) == queueIsEmpty(q)\n  ensures simpleQueueSize(sq) == queueSize(q)\n{\n  if queueIsEmpty(q) {\n    assert q.front == [] && q.rear == [];\n    assert queueToSeq(q) == [];\n    assert sq.elements == [];\n  }\n  QueueSizeProperty(q);\n}", "output": "assert q'.rear == [x] + q.rear;"}, {"id": "example_EnqueueCorrect_8", "type": "assert", "program": "// Queue operations: enqueue, dequeue, isEmpty, size\n\ndatatype Queue<T> = Queue(front: seq<T>, rear: seq<T>)\n\nfunction {:spec} queueEmpty<T>(): Queue<T>\n{\n  Queue([], [])\n}\n\npredicate {:spec} queueIsEmpty<T>(q: Queue<T>)\n{\n  q.front == [] && q.rear == []\n}\n\nfunction {:spec} enqueue<T>(q: Queue<T>, x: T): Queue<T>\n{\n  Queue(q.front, [x] + q.rear)\n}\n\nfunction {:spec} dequeue<T>(q: Queue<T>): Queue<T>\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    Queue(q.front[1..], q.rear)\n  else\n    // Front is empty, so we reverse rear and put it in front\n    if |q.rear| == 1 then\n      Queue([], [])\n    else\n      Queue(reverse(q.rear)[1..], [])\n}\n\nfunction {:spec} queueFront<T>(q: Queue<T>): T\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    q.front[0]\n  else\n    // Front is empty, so the front element is the first element of rear (when reversed)\n    q.rear[|q.rear| - 1]\n}\n\nfunction {:spec} queueSize<T>(q: Queue<T>): nat\n{\n  |q.front| + |q.rear|\n}\n\nfunction {:spec} queueToSeq<T>(q: Queue<T>): seq<T>\n{\n  q.front + reverse(q.rear)\n}\n\nfunction reverse<T>(s: seq<T>): seq<T>\n{\n  if |s| == 0 then []\n  else reverse(s[1..]) + [s[0]]\n}\n\n// Alternative queue representation with invariant\ndatatype SimpleQueue<T> = SimpleQueue(elements: seq<T>)\n\nfunction {:spec} simpleQueueEmpty<T>(): SimpleQueue<T>\n{\n  SimpleQueue([])\n}\n\npredicate {:spec} simpleQueueIsEmpty<T>(q: SimpleQueue<T>)\n{\n  q.elements == []\n}\n\nfunction {:spec} simpleEnqueue<T>(q: SimpleQueue<T>, x: T): SimpleQueue<T>\n{\n  SimpleQueue(q.elements + [x])\n}\n\nfunction {:spec} simpleDequeue<T>(q: SimpleQueue<T>): SimpleQueue<T>\n  requires !simpleQueueIsEmpty(q)\n{\n  SimpleQueue(q.elements[1..])\n}\n\nfunction {:spec} simpleQueueFront<T>(q: SimpleQueue<T>): T\n  requires !simpleQueueIsEmpty(q)\n{\n  q.elements[0]\n}\n\nfunction {:spec} simpleQueueSize<T>(q: SimpleQueue<T>): nat\n{\n  |q.elements|\n}\n\nlemma ReverseLength<T>(s: seq<T>)\n  ensures |reverse(s)| == |s|\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseLength(s[1..]);\n    assert |reverse(s)| == |reverse(s[1..])| + 1;\n  }\n}\n\nlemma ReverseReverse<T>(s: seq<T>)\n  ensures reverse(reverse(s)) == s\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseReverse(s[1..]);\n    ReverseAppend(reverse(s[1..]), [s[0]]);\n    assert reverse(reverse(s)) == s;\n  }\n}\n\nlemma ReverseAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n  } else {\n    assert s1 + s2 == [s1[0]] + (s1[1..] + s2);\n    ReverseAppend(s1[1..], s2);\n  }\n}\n\nlemma ReverseFirst<T>(s: seq<T>)\n  requires |s| > 0\n  ensures |reverse(s)| == |s|\n  ensures reverse(s)[|reverse(s)| - 1] == s[0]\n  ensures reverse(s)[0] == s[|s| - 1]\n{\n  ReverseLength(s);\n  if |s| == 1 {\n    assert reverse(s) == [s[0]];\n  } else {\n    ReverseFirst(s[1..]);\n    assert reverse(s) == reverse(s[1..]) + [s[0]];\n    ReverseLength(s[1..]);\n    assert |reverse(s[1..])| == |s| - 1;\n  }\n}\n\nlemma SeqAssoc<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures a + (b + c) == (a + b) + c\n{\n  // Dafny proves this automatically\n}\n\nlemma QueueSizeProperty<T>(q: Queue<T>)\n  ensures queueSize(q) == |queueToSeq(q)|\n{\n  ReverseLength(q.rear);\n}\n\nlemma EnqueueCorrect<T>(q: Queue<T>, x: T)\n  ensures queueToSeq(enqueue(q, x)) == queueToSeq(q) + [x]\n  ensures queueSize(enqueue(q, x)) == queueSize(q) + 1\n{\n  var q' := enqueue(q, x);\n  \n/*[CODE HERE]*/\n  assert q'.rear == [x] + q.rear;\n\n  ReverseAppend([x], q.rear);\n  assert reverse([x]) == [x];\n  assert reverse([x] + q.rear) == reverse(q.rear) + reverse([x]);\n  assert reverse([x] + q.rear) == reverse(q.rear) + [x];\n\n  calc == {\n    queueToSeq(q');\n    q'.front + reverse(q'.rear);\n    q.front + reverse([x] + q.rear);\n    q.front + (reverse(q.rear) + [x]);\n    { SeqAssoc(q.front, reverse(q.rear), [x]); }\n    (q.front + reverse(q.rear)) + [x];\n    queueToSeq(q) + [x];\n  }\n\n  QueueSizeProperty(q);\n  QueueSizeProperty(q');\n}\n\nlemma DequeueCorrect<T>(q: Queue<T>)\n  requires !queueIsEmpty(q)\n  ensures |queueToSeq(q)| > 0\n  ensures queueToSeq(dequeue(q)) == queueToSeq(q)[1..]\n  ensures queueFront(q) == queueToSeq(q)[0]\n{\n  if |q.front| > 0 {\n    assert queueToSeq(q) == q.front + reverse(q.rear);\n    assert queueToSeq(dequeue(q)) == q.front[1..] + reverse(q.rear);\n    assert queueFront(q) == q.front[0];\n  } else {\n    assert q.front == [];\n    assert |q.rear| > 0;\n    var rev := reverse(q.rear);\n    ReverseLength(q.rear);\n    assert |rev| == |q.rear|;\n    assert queueToSeq(q) == rev;\n    assert queueFront(q) == q.rear[|q.rear| - 1];\n\n    ReverseFirst(q.rear);\n    assert rev[0] == q.rear[|q.rear| - 1];\n\n    if |q.rear| == 1 {\n      assert rev == [q.rear[0]];\n      assert queueToSeq(q) == [q.rear[0]];\n      assert queueFront(q) == q.rear[0];\n      assert queueToSeq(q)[0] == q.rear[0];\n    } else {\n      assert |rev| > 1;\n      assert queueToSeq(dequeue(q)) == rev[1..];\n      assert queueFront(q) == rev[0];\n    }\n  }\n}\n\nlemma SimpleQueueEquivalence<T>(sq: SimpleQueue<T>, q: Queue<T>)\n  requires sq.elements == queueToSeq(q)\n  ensures simpleQueueIsEmpty(sq) == queueIsEmpty(q)\n  ensures simpleQueueSize(sq) == queueSize(q)\n{\n  if queueIsEmpty(q) {\n    assert q.front == [] && q.rear == [];\n    assert queueToSeq(q) == [];\n    assert sq.elements == [];\n  }\n  QueueSizeProperty(q);\n}", "output": "assert q'.front == q.front;"}, {"id": "example_DequeueCorrect_0", "type": "assert", "program": "// Queue operations: enqueue, dequeue, isEmpty, size\n\ndatatype Queue<T> = Queue(front: seq<T>, rear: seq<T>)\n\nfunction {:spec} queueEmpty<T>(): Queue<T>\n{\n  Queue([], [])\n}\n\npredicate {:spec} queueIsEmpty<T>(q: Queue<T>)\n{\n  q.front == [] && q.rear == []\n}\n\nfunction {:spec} enqueue<T>(q: Queue<T>, x: T): Queue<T>\n{\n  Queue(q.front, [x] + q.rear)\n}\n\nfunction {:spec} dequeue<T>(q: Queue<T>): Queue<T>\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    Queue(q.front[1..], q.rear)\n  else\n    // Front is empty, so we reverse rear and put it in front\n    if |q.rear| == 1 then\n      Queue([], [])\n    else\n      Queue(reverse(q.rear)[1..], [])\n}\n\nfunction {:spec} queueFront<T>(q: Queue<T>): T\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    q.front[0]\n  else\n    // Front is empty, so the front element is the first element of rear (when reversed)\n    q.rear[|q.rear| - 1]\n}\n\nfunction {:spec} queueSize<T>(q: Queue<T>): nat\n{\n  |q.front| + |q.rear|\n}\n\nfunction {:spec} queueToSeq<T>(q: Queue<T>): seq<T>\n{\n  q.front + reverse(q.rear)\n}\n\nfunction reverse<T>(s: seq<T>): seq<T>\n{\n  if |s| == 0 then []\n  else reverse(s[1..]) + [s[0]]\n}\n\n// Alternative queue representation with invariant\ndatatype SimpleQueue<T> = SimpleQueue(elements: seq<T>)\n\nfunction {:spec} simpleQueueEmpty<T>(): SimpleQueue<T>\n{\n  SimpleQueue([])\n}\n\npredicate {:spec} simpleQueueIsEmpty<T>(q: SimpleQueue<T>)\n{\n  q.elements == []\n}\n\nfunction {:spec} simpleEnqueue<T>(q: SimpleQueue<T>, x: T): SimpleQueue<T>\n{\n  SimpleQueue(q.elements + [x])\n}\n\nfunction {:spec} simpleDequeue<T>(q: SimpleQueue<T>): SimpleQueue<T>\n  requires !simpleQueueIsEmpty(q)\n{\n  SimpleQueue(q.elements[1..])\n}\n\nfunction {:spec} simpleQueueFront<T>(q: SimpleQueue<T>): T\n  requires !simpleQueueIsEmpty(q)\n{\n  q.elements[0]\n}\n\nfunction {:spec} simpleQueueSize<T>(q: SimpleQueue<T>): nat\n{\n  |q.elements|\n}\n\nlemma ReverseLength<T>(s: seq<T>)\n  ensures |reverse(s)| == |s|\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseLength(s[1..]);\n    assert |reverse(s)| == |reverse(s[1..])| + 1;\n  }\n}\n\nlemma ReverseReverse<T>(s: seq<T>)\n  ensures reverse(reverse(s)) == s\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseReverse(s[1..]);\n    ReverseAppend(reverse(s[1..]), [s[0]]);\n    assert reverse(reverse(s)) == s;\n  }\n}\n\nlemma ReverseAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n  } else {\n    assert s1 + s2 == [s1[0]] + (s1[1..] + s2);\n    ReverseAppend(s1[1..], s2);\n  }\n}\n\nlemma ReverseFirst<T>(s: seq<T>)\n  requires |s| > 0\n  ensures |reverse(s)| == |s|\n  ensures reverse(s)[|reverse(s)| - 1] == s[0]\n  ensures reverse(s)[0] == s[|s| - 1]\n{\n  ReverseLength(s);\n  if |s| == 1 {\n    assert reverse(s) == [s[0]];\n  } else {\n    ReverseFirst(s[1..]);\n    assert reverse(s) == reverse(s[1..]) + [s[0]];\n    ReverseLength(s[1..]);\n    assert |reverse(s[1..])| == |s| - 1;\n  }\n}\n\nlemma SeqAssoc<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures a + (b + c) == (a + b) + c\n{\n  // Dafny proves this automatically\n}\n\nlemma QueueSizeProperty<T>(q: Queue<T>)\n  ensures queueSize(q) == |queueToSeq(q)|\n{\n  ReverseLength(q.rear);\n}\n\nlemma EnqueueCorrect<T>(q: Queue<T>, x: T)\n  ensures queueToSeq(enqueue(q, x)) == queueToSeq(q) + [x]\n  ensures queueSize(enqueue(q, x)) == queueSize(q) + 1\n{\n  var q' := enqueue(q, x);\n  assert q'.front == q.front;\n  assert q'.rear == [x] + q.rear;\n\n  ReverseAppend([x], q.rear);\n  assert reverse([x]) == [x];\n  assert reverse([x] + q.rear) == reverse(q.rear) + reverse([x]);\n  assert reverse([x] + q.rear) == reverse(q.rear) + [x];\n\n  calc == {\n    queueToSeq(q');\n    q'.front + reverse(q'.rear);\n    q.front + reverse([x] + q.rear);\n    q.front + (reverse(q.rear) + [x]);\n    { SeqAssoc(q.front, reverse(q.rear), [x]); }\n    (q.front + reverse(q.rear)) + [x];\n    queueToSeq(q) + [x];\n  }\n\n  QueueSizeProperty(q);\n  QueueSizeProperty(q');\n}\n\nlemma DequeueCorrect<T>(q: Queue<T>)\n  requires !queueIsEmpty(q)\n  ensures |queueToSeq(q)| > 0\n  ensures queueToSeq(dequeue(q)) == queueToSeq(q)[1..]\n  ensures queueFront(q) == queueToSeq(q)[0]\n{\n  if |q.front| > 0 {\n    assert queueToSeq(q) == q.front + reverse(q.rear);\n    assert queueToSeq(dequeue(q)) == q.front[1..] + reverse(q.rear);\n    assert queueFront(q) == q.front[0];\n  } else {\n    assert q.front == [];\n    assert |q.rear| > 0;\n    var rev := reverse(q.rear);\n    ReverseLength(q.rear);\n    assert |rev| == |q.rear|;\n    assert queueToSeq(q) == rev;\n    assert queueFront(q) == q.rear[|q.rear| - 1];\n\n    ReverseFirst(q.rear);\n    assert rev[0] == q.rear[|q.rear| - 1];\n\n    if |q.rear| == 1 {\n      assert rev == [q.rear[0]];\n      assert queueToSeq(q) == [q.rear[0]];\n      assert queueFront(q) == q.rear[0];\n      assert queueToSeq(q)[0] == q.rear[0];\n    } else {\n      assert |rev| > 1;\n      assert queueToSeq(dequeue(q)) == rev[1..];\n      \n/*[CODE HERE]*/\n    }\n  }\n}\n\nlemma SimpleQueueEquivalence<T>(sq: SimpleQueue<T>, q: Queue<T>)\n  requires sq.elements == queueToSeq(q)\n  ensures simpleQueueIsEmpty(sq) == queueIsEmpty(q)\n  ensures simpleQueueSize(sq) == queueSize(q)\n{\n  if queueIsEmpty(q) {\n    assert q.front == [] && q.rear == [];\n    assert queueToSeq(q) == [];\n    assert sq.elements == [];\n  }\n  QueueSizeProperty(q);\n}", "output": "assert queueFront(q) == rev[0];"}, {"id": "example_DequeueCorrect_1", "type": "assert", "program": "// Queue operations: enqueue, dequeue, isEmpty, size\n\ndatatype Queue<T> = Queue(front: seq<T>, rear: seq<T>)\n\nfunction {:spec} queueEmpty<T>(): Queue<T>\n{\n  Queue([], [])\n}\n\npredicate {:spec} queueIsEmpty<T>(q: Queue<T>)\n{\n  q.front == [] && q.rear == []\n}\n\nfunction {:spec} enqueue<T>(q: Queue<T>, x: T): Queue<T>\n{\n  Queue(q.front, [x] + q.rear)\n}\n\nfunction {:spec} dequeue<T>(q: Queue<T>): Queue<T>\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    Queue(q.front[1..], q.rear)\n  else\n    // Front is empty, so we reverse rear and put it in front\n    if |q.rear| == 1 then\n      Queue([], [])\n    else\n      Queue(reverse(q.rear)[1..], [])\n}\n\nfunction {:spec} queueFront<T>(q: Queue<T>): T\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    q.front[0]\n  else\n    // Front is empty, so the front element is the first element of rear (when reversed)\n    q.rear[|q.rear| - 1]\n}\n\nfunction {:spec} queueSize<T>(q: Queue<T>): nat\n{\n  |q.front| + |q.rear|\n}\n\nfunction {:spec} queueToSeq<T>(q: Queue<T>): seq<T>\n{\n  q.front + reverse(q.rear)\n}\n\nfunction reverse<T>(s: seq<T>): seq<T>\n{\n  if |s| == 0 then []\n  else reverse(s[1..]) + [s[0]]\n}\n\n// Alternative queue representation with invariant\ndatatype SimpleQueue<T> = SimpleQueue(elements: seq<T>)\n\nfunction {:spec} simpleQueueEmpty<T>(): SimpleQueue<T>\n{\n  SimpleQueue([])\n}\n\npredicate {:spec} simpleQueueIsEmpty<T>(q: SimpleQueue<T>)\n{\n  q.elements == []\n}\n\nfunction {:spec} simpleEnqueue<T>(q: SimpleQueue<T>, x: T): SimpleQueue<T>\n{\n  SimpleQueue(q.elements + [x])\n}\n\nfunction {:spec} simpleDequeue<T>(q: SimpleQueue<T>): SimpleQueue<T>\n  requires !simpleQueueIsEmpty(q)\n{\n  SimpleQueue(q.elements[1..])\n}\n\nfunction {:spec} simpleQueueFront<T>(q: SimpleQueue<T>): T\n  requires !simpleQueueIsEmpty(q)\n{\n  q.elements[0]\n}\n\nfunction {:spec} simpleQueueSize<T>(q: SimpleQueue<T>): nat\n{\n  |q.elements|\n}\n\nlemma ReverseLength<T>(s: seq<T>)\n  ensures |reverse(s)| == |s|\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseLength(s[1..]);\n    assert |reverse(s)| == |reverse(s[1..])| + 1;\n  }\n}\n\nlemma ReverseReverse<T>(s: seq<T>)\n  ensures reverse(reverse(s)) == s\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseReverse(s[1..]);\n    ReverseAppend(reverse(s[1..]), [s[0]]);\n    assert reverse(reverse(s)) == s;\n  }\n}\n\nlemma ReverseAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n  } else {\n    assert s1 + s2 == [s1[0]] + (s1[1..] + s2);\n    ReverseAppend(s1[1..], s2);\n  }\n}\n\nlemma ReverseFirst<T>(s: seq<T>)\n  requires |s| > 0\n  ensures |reverse(s)| == |s|\n  ensures reverse(s)[|reverse(s)| - 1] == s[0]\n  ensures reverse(s)[0] == s[|s| - 1]\n{\n  ReverseLength(s);\n  if |s| == 1 {\n    assert reverse(s) == [s[0]];\n  } else {\n    ReverseFirst(s[1..]);\n    assert reverse(s) == reverse(s[1..]) + [s[0]];\n    ReverseLength(s[1..]);\n    assert |reverse(s[1..])| == |s| - 1;\n  }\n}\n\nlemma SeqAssoc<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures a + (b + c) == (a + b) + c\n{\n  // Dafny proves this automatically\n}\n\nlemma QueueSizeProperty<T>(q: Queue<T>)\n  ensures queueSize(q) == |queueToSeq(q)|\n{\n  ReverseLength(q.rear);\n}\n\nlemma EnqueueCorrect<T>(q: Queue<T>, x: T)\n  ensures queueToSeq(enqueue(q, x)) == queueToSeq(q) + [x]\n  ensures queueSize(enqueue(q, x)) == queueSize(q) + 1\n{\n  var q' := enqueue(q, x);\n  assert q'.front == q.front;\n  assert q'.rear == [x] + q.rear;\n\n  ReverseAppend([x], q.rear);\n  assert reverse([x]) == [x];\n  assert reverse([x] + q.rear) == reverse(q.rear) + reverse([x]);\n  assert reverse([x] + q.rear) == reverse(q.rear) + [x];\n\n  calc == {\n    queueToSeq(q');\n    q'.front + reverse(q'.rear);\n    q.front + reverse([x] + q.rear);\n    q.front + (reverse(q.rear) + [x]);\n    { SeqAssoc(q.front, reverse(q.rear), [x]); }\n    (q.front + reverse(q.rear)) + [x];\n    queueToSeq(q) + [x];\n  }\n\n  QueueSizeProperty(q);\n  QueueSizeProperty(q');\n}\n\nlemma DequeueCorrect<T>(q: Queue<T>)\n  requires !queueIsEmpty(q)\n  ensures |queueToSeq(q)| > 0\n  ensures queueToSeq(dequeue(q)) == queueToSeq(q)[1..]\n  ensures queueFront(q) == queueToSeq(q)[0]\n{\n  if |q.front| > 0 {\n    assert queueToSeq(q) == q.front + reverse(q.rear);\n    assert queueToSeq(dequeue(q)) == q.front[1..] + reverse(q.rear);\n    assert queueFront(q) == q.front[0];\n  } else {\n    assert q.front == [];\n    assert |q.rear| > 0;\n    var rev := reverse(q.rear);\n    ReverseLength(q.rear);\n    assert |rev| == |q.rear|;\n    assert queueToSeq(q) == rev;\n    assert queueFront(q) == q.rear[|q.rear| - 1];\n\n    ReverseFirst(q.rear);\n    assert rev[0] == q.rear[|q.rear| - 1];\n\n    if |q.rear| == 1 {\n      assert rev == [q.rear[0]];\n      assert queueToSeq(q) == [q.rear[0]];\n      assert queueFront(q) == q.rear[0];\n      assert queueToSeq(q)[0] == q.rear[0];\n    } else {\n      assert |rev| > 1;\n      \n/*[CODE HERE]*/\n      assert queueFront(q) == rev[0];\n    }\n  }\n}\n\nlemma SimpleQueueEquivalence<T>(sq: SimpleQueue<T>, q: Queue<T>)\n  requires sq.elements == queueToSeq(q)\n  ensures simpleQueueIsEmpty(sq) == queueIsEmpty(q)\n  ensures simpleQueueSize(sq) == queueSize(q)\n{\n  if queueIsEmpty(q) {\n    assert q.front == [] && q.rear == [];\n    assert queueToSeq(q) == [];\n    assert sq.elements == [];\n  }\n  QueueSizeProperty(q);\n}", "output": "assert queueToSeq(dequeue(q)) == rev[1..];"}, {"id": "example_DequeueCorrect_2", "type": "assert", "program": "// Queue operations: enqueue, dequeue, isEmpty, size\n\ndatatype Queue<T> = Queue(front: seq<T>, rear: seq<T>)\n\nfunction {:spec} queueEmpty<T>(): Queue<T>\n{\n  Queue([], [])\n}\n\npredicate {:spec} queueIsEmpty<T>(q: Queue<T>)\n{\n  q.front == [] && q.rear == []\n}\n\nfunction {:spec} enqueue<T>(q: Queue<T>, x: T): Queue<T>\n{\n  Queue(q.front, [x] + q.rear)\n}\n\nfunction {:spec} dequeue<T>(q: Queue<T>): Queue<T>\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    Queue(q.front[1..], q.rear)\n  else\n    // Front is empty, so we reverse rear and put it in front\n    if |q.rear| == 1 then\n      Queue([], [])\n    else\n      Queue(reverse(q.rear)[1..], [])\n}\n\nfunction {:spec} queueFront<T>(q: Queue<T>): T\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    q.front[0]\n  else\n    // Front is empty, so the front element is the first element of rear (when reversed)\n    q.rear[|q.rear| - 1]\n}\n\nfunction {:spec} queueSize<T>(q: Queue<T>): nat\n{\n  |q.front| + |q.rear|\n}\n\nfunction {:spec} queueToSeq<T>(q: Queue<T>): seq<T>\n{\n  q.front + reverse(q.rear)\n}\n\nfunction reverse<T>(s: seq<T>): seq<T>\n{\n  if |s| == 0 then []\n  else reverse(s[1..]) + [s[0]]\n}\n\n// Alternative queue representation with invariant\ndatatype SimpleQueue<T> = SimpleQueue(elements: seq<T>)\n\nfunction {:spec} simpleQueueEmpty<T>(): SimpleQueue<T>\n{\n  SimpleQueue([])\n}\n\npredicate {:spec} simpleQueueIsEmpty<T>(q: SimpleQueue<T>)\n{\n  q.elements == []\n}\n\nfunction {:spec} simpleEnqueue<T>(q: SimpleQueue<T>, x: T): SimpleQueue<T>\n{\n  SimpleQueue(q.elements + [x])\n}\n\nfunction {:spec} simpleDequeue<T>(q: SimpleQueue<T>): SimpleQueue<T>\n  requires !simpleQueueIsEmpty(q)\n{\n  SimpleQueue(q.elements[1..])\n}\n\nfunction {:spec} simpleQueueFront<T>(q: SimpleQueue<T>): T\n  requires !simpleQueueIsEmpty(q)\n{\n  q.elements[0]\n}\n\nfunction {:spec} simpleQueueSize<T>(q: SimpleQueue<T>): nat\n{\n  |q.elements|\n}\n\nlemma ReverseLength<T>(s: seq<T>)\n  ensures |reverse(s)| == |s|\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseLength(s[1..]);\n    assert |reverse(s)| == |reverse(s[1..])| + 1;\n  }\n}\n\nlemma ReverseReverse<T>(s: seq<T>)\n  ensures reverse(reverse(s)) == s\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseReverse(s[1..]);\n    ReverseAppend(reverse(s[1..]), [s[0]]);\n    assert reverse(reverse(s)) == s;\n  }\n}\n\nlemma ReverseAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n  } else {\n    assert s1 + s2 == [s1[0]] + (s1[1..] + s2);\n    ReverseAppend(s1[1..], s2);\n  }\n}\n\nlemma ReverseFirst<T>(s: seq<T>)\n  requires |s| > 0\n  ensures |reverse(s)| == |s|\n  ensures reverse(s)[|reverse(s)| - 1] == s[0]\n  ensures reverse(s)[0] == s[|s| - 1]\n{\n  ReverseLength(s);\n  if |s| == 1 {\n    assert reverse(s) == [s[0]];\n  } else {\n    ReverseFirst(s[1..]);\n    assert reverse(s) == reverse(s[1..]) + [s[0]];\n    ReverseLength(s[1..]);\n    assert |reverse(s[1..])| == |s| - 1;\n  }\n}\n\nlemma SeqAssoc<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures a + (b + c) == (a + b) + c\n{\n  // Dafny proves this automatically\n}\n\nlemma QueueSizeProperty<T>(q: Queue<T>)\n  ensures queueSize(q) == |queueToSeq(q)|\n{\n  ReverseLength(q.rear);\n}\n\nlemma EnqueueCorrect<T>(q: Queue<T>, x: T)\n  ensures queueToSeq(enqueue(q, x)) == queueToSeq(q) + [x]\n  ensures queueSize(enqueue(q, x)) == queueSize(q) + 1\n{\n  var q' := enqueue(q, x);\n  assert q'.front == q.front;\n  assert q'.rear == [x] + q.rear;\n\n  ReverseAppend([x], q.rear);\n  assert reverse([x]) == [x];\n  assert reverse([x] + q.rear) == reverse(q.rear) + reverse([x]);\n  assert reverse([x] + q.rear) == reverse(q.rear) + [x];\n\n  calc == {\n    queueToSeq(q');\n    q'.front + reverse(q'.rear);\n    q.front + reverse([x] + q.rear);\n    q.front + (reverse(q.rear) + [x]);\n    { SeqAssoc(q.front, reverse(q.rear), [x]); }\n    (q.front + reverse(q.rear)) + [x];\n    queueToSeq(q) + [x];\n  }\n\n  QueueSizeProperty(q);\n  QueueSizeProperty(q');\n}\n\nlemma DequeueCorrect<T>(q: Queue<T>)\n  requires !queueIsEmpty(q)\n  ensures |queueToSeq(q)| > 0\n  ensures queueToSeq(dequeue(q)) == queueToSeq(q)[1..]\n  ensures queueFront(q) == queueToSeq(q)[0]\n{\n  if |q.front| > 0 {\n    assert queueToSeq(q) == q.front + reverse(q.rear);\n    assert queueToSeq(dequeue(q)) == q.front[1..] + reverse(q.rear);\n    assert queueFront(q) == q.front[0];\n  } else {\n    assert q.front == [];\n    assert |q.rear| > 0;\n    var rev := reverse(q.rear);\n    ReverseLength(q.rear);\n    assert |rev| == |q.rear|;\n    assert queueToSeq(q) == rev;\n    assert queueFront(q) == q.rear[|q.rear| - 1];\n\n    ReverseFirst(q.rear);\n    assert rev[0] == q.rear[|q.rear| - 1];\n\n    if |q.rear| == 1 {\n      assert rev == [q.rear[0]];\n      assert queueToSeq(q) == [q.rear[0]];\n      assert queueFront(q) == q.rear[0];\n      assert queueToSeq(q)[0] == q.rear[0];\n    } else {\n      \n/*[CODE HERE]*/\n      assert queueToSeq(dequeue(q)) == rev[1..];\n      assert queueFront(q) == rev[0];\n    }\n  }\n}\n\nlemma SimpleQueueEquivalence<T>(sq: SimpleQueue<T>, q: Queue<T>)\n  requires sq.elements == queueToSeq(q)\n  ensures simpleQueueIsEmpty(sq) == queueIsEmpty(q)\n  ensures simpleQueueSize(sq) == queueSize(q)\n{\n  if queueIsEmpty(q) {\n    assert q.front == [] && q.rear == [];\n    assert queueToSeq(q) == [];\n    assert sq.elements == [];\n  }\n  QueueSizeProperty(q);\n}", "output": "assert |rev| > 1;"}, {"id": "example_DequeueCorrect_3", "type": "assert", "program": "// Queue operations: enqueue, dequeue, isEmpty, size\n\ndatatype Queue<T> = Queue(front: seq<T>, rear: seq<T>)\n\nfunction {:spec} queueEmpty<T>(): Queue<T>\n{\n  Queue([], [])\n}\n\npredicate {:spec} queueIsEmpty<T>(q: Queue<T>)\n{\n  q.front == [] && q.rear == []\n}\n\nfunction {:spec} enqueue<T>(q: Queue<T>, x: T): Queue<T>\n{\n  Queue(q.front, [x] + q.rear)\n}\n\nfunction {:spec} dequeue<T>(q: Queue<T>): Queue<T>\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    Queue(q.front[1..], q.rear)\n  else\n    // Front is empty, so we reverse rear and put it in front\n    if |q.rear| == 1 then\n      Queue([], [])\n    else\n      Queue(reverse(q.rear)[1..], [])\n}\n\nfunction {:spec} queueFront<T>(q: Queue<T>): T\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    q.front[0]\n  else\n    // Front is empty, so the front element is the first element of rear (when reversed)\n    q.rear[|q.rear| - 1]\n}\n\nfunction {:spec} queueSize<T>(q: Queue<T>): nat\n{\n  |q.front| + |q.rear|\n}\n\nfunction {:spec} queueToSeq<T>(q: Queue<T>): seq<T>\n{\n  q.front + reverse(q.rear)\n}\n\nfunction reverse<T>(s: seq<T>): seq<T>\n{\n  if |s| == 0 then []\n  else reverse(s[1..]) + [s[0]]\n}\n\n// Alternative queue representation with invariant\ndatatype SimpleQueue<T> = SimpleQueue(elements: seq<T>)\n\nfunction {:spec} simpleQueueEmpty<T>(): SimpleQueue<T>\n{\n  SimpleQueue([])\n}\n\npredicate {:spec} simpleQueueIsEmpty<T>(q: SimpleQueue<T>)\n{\n  q.elements == []\n}\n\nfunction {:spec} simpleEnqueue<T>(q: SimpleQueue<T>, x: T): SimpleQueue<T>\n{\n  SimpleQueue(q.elements + [x])\n}\n\nfunction {:spec} simpleDequeue<T>(q: SimpleQueue<T>): SimpleQueue<T>\n  requires !simpleQueueIsEmpty(q)\n{\n  SimpleQueue(q.elements[1..])\n}\n\nfunction {:spec} simpleQueueFront<T>(q: SimpleQueue<T>): T\n  requires !simpleQueueIsEmpty(q)\n{\n  q.elements[0]\n}\n\nfunction {:spec} simpleQueueSize<T>(q: SimpleQueue<T>): nat\n{\n  |q.elements|\n}\n\nlemma ReverseLength<T>(s: seq<T>)\n  ensures |reverse(s)| == |s|\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseLength(s[1..]);\n    assert |reverse(s)| == |reverse(s[1..])| + 1;\n  }\n}\n\nlemma ReverseReverse<T>(s: seq<T>)\n  ensures reverse(reverse(s)) == s\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseReverse(s[1..]);\n    ReverseAppend(reverse(s[1..]), [s[0]]);\n    assert reverse(reverse(s)) == s;\n  }\n}\n\nlemma ReverseAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n  } else {\n    assert s1 + s2 == [s1[0]] + (s1[1..] + s2);\n    ReverseAppend(s1[1..], s2);\n  }\n}\n\nlemma ReverseFirst<T>(s: seq<T>)\n  requires |s| > 0\n  ensures |reverse(s)| == |s|\n  ensures reverse(s)[|reverse(s)| - 1] == s[0]\n  ensures reverse(s)[0] == s[|s| - 1]\n{\n  ReverseLength(s);\n  if |s| == 1 {\n    assert reverse(s) == [s[0]];\n  } else {\n    ReverseFirst(s[1..]);\n    assert reverse(s) == reverse(s[1..]) + [s[0]];\n    ReverseLength(s[1..]);\n    assert |reverse(s[1..])| == |s| - 1;\n  }\n}\n\nlemma SeqAssoc<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures a + (b + c) == (a + b) + c\n{\n  // Dafny proves this automatically\n}\n\nlemma QueueSizeProperty<T>(q: Queue<T>)\n  ensures queueSize(q) == |queueToSeq(q)|\n{\n  ReverseLength(q.rear);\n}\n\nlemma EnqueueCorrect<T>(q: Queue<T>, x: T)\n  ensures queueToSeq(enqueue(q, x)) == queueToSeq(q) + [x]\n  ensures queueSize(enqueue(q, x)) == queueSize(q) + 1\n{\n  var q' := enqueue(q, x);\n  assert q'.front == q.front;\n  assert q'.rear == [x] + q.rear;\n\n  ReverseAppend([x], q.rear);\n  assert reverse([x]) == [x];\n  assert reverse([x] + q.rear) == reverse(q.rear) + reverse([x]);\n  assert reverse([x] + q.rear) == reverse(q.rear) + [x];\n\n  calc == {\n    queueToSeq(q');\n    q'.front + reverse(q'.rear);\n    q.front + reverse([x] + q.rear);\n    q.front + (reverse(q.rear) + [x]);\n    { SeqAssoc(q.front, reverse(q.rear), [x]); }\n    (q.front + reverse(q.rear)) + [x];\n    queueToSeq(q) + [x];\n  }\n\n  QueueSizeProperty(q);\n  QueueSizeProperty(q');\n}\n\nlemma DequeueCorrect<T>(q: Queue<T>)\n  requires !queueIsEmpty(q)\n  ensures |queueToSeq(q)| > 0\n  ensures queueToSeq(dequeue(q)) == queueToSeq(q)[1..]\n  ensures queueFront(q) == queueToSeq(q)[0]\n{\n  if |q.front| > 0 {\n    assert queueToSeq(q) == q.front + reverse(q.rear);\n    assert queueToSeq(dequeue(q)) == q.front[1..] + reverse(q.rear);\n    assert queueFront(q) == q.front[0];\n  } else {\n    assert q.front == [];\n    assert |q.rear| > 0;\n    var rev := reverse(q.rear);\n    ReverseLength(q.rear);\n    assert |rev| == |q.rear|;\n    assert queueToSeq(q) == rev;\n    assert queueFront(q) == q.rear[|q.rear| - 1];\n\n    ReverseFirst(q.rear);\n    assert rev[0] == q.rear[|q.rear| - 1];\n\n    if |q.rear| == 1 {\n      assert rev == [q.rear[0]];\n      assert queueToSeq(q) == [q.rear[0]];\n      assert queueFront(q) == q.rear[0];\n      \n/*[CODE HERE]*/\n    } else {\n      assert |rev| > 1;\n      assert queueToSeq(dequeue(q)) == rev[1..];\n      assert queueFront(q) == rev[0];\n    }\n  }\n}\n\nlemma SimpleQueueEquivalence<T>(sq: SimpleQueue<T>, q: Queue<T>)\n  requires sq.elements == queueToSeq(q)\n  ensures simpleQueueIsEmpty(sq) == queueIsEmpty(q)\n  ensures simpleQueueSize(sq) == queueSize(q)\n{\n  if queueIsEmpty(q) {\n    assert q.front == [] && q.rear == [];\n    assert queueToSeq(q) == [];\n    assert sq.elements == [];\n  }\n  QueueSizeProperty(q);\n}", "output": "assert queueToSeq(q)[0] == q.rear[0];"}, {"id": "example_DequeueCorrect_4", "type": "assert", "program": "// Queue operations: enqueue, dequeue, isEmpty, size\n\ndatatype Queue<T> = Queue(front: seq<T>, rear: seq<T>)\n\nfunction {:spec} queueEmpty<T>(): Queue<T>\n{\n  Queue([], [])\n}\n\npredicate {:spec} queueIsEmpty<T>(q: Queue<T>)\n{\n  q.front == [] && q.rear == []\n}\n\nfunction {:spec} enqueue<T>(q: Queue<T>, x: T): Queue<T>\n{\n  Queue(q.front, [x] + q.rear)\n}\n\nfunction {:spec} dequeue<T>(q: Queue<T>): Queue<T>\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    Queue(q.front[1..], q.rear)\n  else\n    // Front is empty, so we reverse rear and put it in front\n    if |q.rear| == 1 then\n      Queue([], [])\n    else\n      Queue(reverse(q.rear)[1..], [])\n}\n\nfunction {:spec} queueFront<T>(q: Queue<T>): T\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    q.front[0]\n  else\n    // Front is empty, so the front element is the first element of rear (when reversed)\n    q.rear[|q.rear| - 1]\n}\n\nfunction {:spec} queueSize<T>(q: Queue<T>): nat\n{\n  |q.front| + |q.rear|\n}\n\nfunction {:spec} queueToSeq<T>(q: Queue<T>): seq<T>\n{\n  q.front + reverse(q.rear)\n}\n\nfunction reverse<T>(s: seq<T>): seq<T>\n{\n  if |s| == 0 then []\n  else reverse(s[1..]) + [s[0]]\n}\n\n// Alternative queue representation with invariant\ndatatype SimpleQueue<T> = SimpleQueue(elements: seq<T>)\n\nfunction {:spec} simpleQueueEmpty<T>(): SimpleQueue<T>\n{\n  SimpleQueue([])\n}\n\npredicate {:spec} simpleQueueIsEmpty<T>(q: SimpleQueue<T>)\n{\n  q.elements == []\n}\n\nfunction {:spec} simpleEnqueue<T>(q: SimpleQueue<T>, x: T): SimpleQueue<T>\n{\n  SimpleQueue(q.elements + [x])\n}\n\nfunction {:spec} simpleDequeue<T>(q: SimpleQueue<T>): SimpleQueue<T>\n  requires !simpleQueueIsEmpty(q)\n{\n  SimpleQueue(q.elements[1..])\n}\n\nfunction {:spec} simpleQueueFront<T>(q: SimpleQueue<T>): T\n  requires !simpleQueueIsEmpty(q)\n{\n  q.elements[0]\n}\n\nfunction {:spec} simpleQueueSize<T>(q: SimpleQueue<T>): nat\n{\n  |q.elements|\n}\n\nlemma ReverseLength<T>(s: seq<T>)\n  ensures |reverse(s)| == |s|\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseLength(s[1..]);\n    assert |reverse(s)| == |reverse(s[1..])| + 1;\n  }\n}\n\nlemma ReverseReverse<T>(s: seq<T>)\n  ensures reverse(reverse(s)) == s\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseReverse(s[1..]);\n    ReverseAppend(reverse(s[1..]), [s[0]]);\n    assert reverse(reverse(s)) == s;\n  }\n}\n\nlemma ReverseAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n  } else {\n    assert s1 + s2 == [s1[0]] + (s1[1..] + s2);\n    ReverseAppend(s1[1..], s2);\n  }\n}\n\nlemma ReverseFirst<T>(s: seq<T>)\n  requires |s| > 0\n  ensures |reverse(s)| == |s|\n  ensures reverse(s)[|reverse(s)| - 1] == s[0]\n  ensures reverse(s)[0] == s[|s| - 1]\n{\n  ReverseLength(s);\n  if |s| == 1 {\n    assert reverse(s) == [s[0]];\n  } else {\n    ReverseFirst(s[1..]);\n    assert reverse(s) == reverse(s[1..]) + [s[0]];\n    ReverseLength(s[1..]);\n    assert |reverse(s[1..])| == |s| - 1;\n  }\n}\n\nlemma SeqAssoc<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures a + (b + c) == (a + b) + c\n{\n  // Dafny proves this automatically\n}\n\nlemma QueueSizeProperty<T>(q: Queue<T>)\n  ensures queueSize(q) == |queueToSeq(q)|\n{\n  ReverseLength(q.rear);\n}\n\nlemma EnqueueCorrect<T>(q: Queue<T>, x: T)\n  ensures queueToSeq(enqueue(q, x)) == queueToSeq(q) + [x]\n  ensures queueSize(enqueue(q, x)) == queueSize(q) + 1\n{\n  var q' := enqueue(q, x);\n  assert q'.front == q.front;\n  assert q'.rear == [x] + q.rear;\n\n  ReverseAppend([x], q.rear);\n  assert reverse([x]) == [x];\n  assert reverse([x] + q.rear) == reverse(q.rear) + reverse([x]);\n  assert reverse([x] + q.rear) == reverse(q.rear) + [x];\n\n  calc == {\n    queueToSeq(q');\n    q'.front + reverse(q'.rear);\n    q.front + reverse([x] + q.rear);\n    q.front + (reverse(q.rear) + [x]);\n    { SeqAssoc(q.front, reverse(q.rear), [x]); }\n    (q.front + reverse(q.rear)) + [x];\n    queueToSeq(q) + [x];\n  }\n\n  QueueSizeProperty(q);\n  QueueSizeProperty(q');\n}\n\nlemma DequeueCorrect<T>(q: Queue<T>)\n  requires !queueIsEmpty(q)\n  ensures |queueToSeq(q)| > 0\n  ensures queueToSeq(dequeue(q)) == queueToSeq(q)[1..]\n  ensures queueFront(q) == queueToSeq(q)[0]\n{\n  if |q.front| > 0 {\n    assert queueToSeq(q) == q.front + reverse(q.rear);\n    assert queueToSeq(dequeue(q)) == q.front[1..] + reverse(q.rear);\n    assert queueFront(q) == q.front[0];\n  } else {\n    assert q.front == [];\n    assert |q.rear| > 0;\n    var rev := reverse(q.rear);\n    ReverseLength(q.rear);\n    assert |rev| == |q.rear|;\n    assert queueToSeq(q) == rev;\n    assert queueFront(q) == q.rear[|q.rear| - 1];\n\n    ReverseFirst(q.rear);\n    assert rev[0] == q.rear[|q.rear| - 1];\n\n    if |q.rear| == 1 {\n      assert rev == [q.rear[0]];\n      assert queueToSeq(q) == [q.rear[0]];\n      \n/*[CODE HERE]*/\n      assert queueToSeq(q)[0] == q.rear[0];\n    } else {\n      assert |rev| > 1;\n      assert queueToSeq(dequeue(q)) == rev[1..];\n      assert queueFront(q) == rev[0];\n    }\n  }\n}\n\nlemma SimpleQueueEquivalence<T>(sq: SimpleQueue<T>, q: Queue<T>)\n  requires sq.elements == queueToSeq(q)\n  ensures simpleQueueIsEmpty(sq) == queueIsEmpty(q)\n  ensures simpleQueueSize(sq) == queueSize(q)\n{\n  if queueIsEmpty(q) {\n    assert q.front == [] && q.rear == [];\n    assert queueToSeq(q) == [];\n    assert sq.elements == [];\n  }\n  QueueSizeProperty(q);\n}", "output": "assert queueFront(q) == q.rear[0];"}, {"id": "example_DequeueCorrect_5", "type": "assert", "program": "// Queue operations: enqueue, dequeue, isEmpty, size\n\ndatatype Queue<T> = Queue(front: seq<T>, rear: seq<T>)\n\nfunction {:spec} queueEmpty<T>(): Queue<T>\n{\n  Queue([], [])\n}\n\npredicate {:spec} queueIsEmpty<T>(q: Queue<T>)\n{\n  q.front == [] && q.rear == []\n}\n\nfunction {:spec} enqueue<T>(q: Queue<T>, x: T): Queue<T>\n{\n  Queue(q.front, [x] + q.rear)\n}\n\nfunction {:spec} dequeue<T>(q: Queue<T>): Queue<T>\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    Queue(q.front[1..], q.rear)\n  else\n    // Front is empty, so we reverse rear and put it in front\n    if |q.rear| == 1 then\n      Queue([], [])\n    else\n      Queue(reverse(q.rear)[1..], [])\n}\n\nfunction {:spec} queueFront<T>(q: Queue<T>): T\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    q.front[0]\n  else\n    // Front is empty, so the front element is the first element of rear (when reversed)\n    q.rear[|q.rear| - 1]\n}\n\nfunction {:spec} queueSize<T>(q: Queue<T>): nat\n{\n  |q.front| + |q.rear|\n}\n\nfunction {:spec} queueToSeq<T>(q: Queue<T>): seq<T>\n{\n  q.front + reverse(q.rear)\n}\n\nfunction reverse<T>(s: seq<T>): seq<T>\n{\n  if |s| == 0 then []\n  else reverse(s[1..]) + [s[0]]\n}\n\n// Alternative queue representation with invariant\ndatatype SimpleQueue<T> = SimpleQueue(elements: seq<T>)\n\nfunction {:spec} simpleQueueEmpty<T>(): SimpleQueue<T>\n{\n  SimpleQueue([])\n}\n\npredicate {:spec} simpleQueueIsEmpty<T>(q: SimpleQueue<T>)\n{\n  q.elements == []\n}\n\nfunction {:spec} simpleEnqueue<T>(q: SimpleQueue<T>, x: T): SimpleQueue<T>\n{\n  SimpleQueue(q.elements + [x])\n}\n\nfunction {:spec} simpleDequeue<T>(q: SimpleQueue<T>): SimpleQueue<T>\n  requires !simpleQueueIsEmpty(q)\n{\n  SimpleQueue(q.elements[1..])\n}\n\nfunction {:spec} simpleQueueFront<T>(q: SimpleQueue<T>): T\n  requires !simpleQueueIsEmpty(q)\n{\n  q.elements[0]\n}\n\nfunction {:spec} simpleQueueSize<T>(q: SimpleQueue<T>): nat\n{\n  |q.elements|\n}\n\nlemma ReverseLength<T>(s: seq<T>)\n  ensures |reverse(s)| == |s|\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseLength(s[1..]);\n    assert |reverse(s)| == |reverse(s[1..])| + 1;\n  }\n}\n\nlemma ReverseReverse<T>(s: seq<T>)\n  ensures reverse(reverse(s)) == s\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseReverse(s[1..]);\n    ReverseAppend(reverse(s[1..]), [s[0]]);\n    assert reverse(reverse(s)) == s;\n  }\n}\n\nlemma ReverseAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n  } else {\n    assert s1 + s2 == [s1[0]] + (s1[1..] + s2);\n    ReverseAppend(s1[1..], s2);\n  }\n}\n\nlemma ReverseFirst<T>(s: seq<T>)\n  requires |s| > 0\n  ensures |reverse(s)| == |s|\n  ensures reverse(s)[|reverse(s)| - 1] == s[0]\n  ensures reverse(s)[0] == s[|s| - 1]\n{\n  ReverseLength(s);\n  if |s| == 1 {\n    assert reverse(s) == [s[0]];\n  } else {\n    ReverseFirst(s[1..]);\n    assert reverse(s) == reverse(s[1..]) + [s[0]];\n    ReverseLength(s[1..]);\n    assert |reverse(s[1..])| == |s| - 1;\n  }\n}\n\nlemma SeqAssoc<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures a + (b + c) == (a + b) + c\n{\n  // Dafny proves this automatically\n}\n\nlemma QueueSizeProperty<T>(q: Queue<T>)\n  ensures queueSize(q) == |queueToSeq(q)|\n{\n  ReverseLength(q.rear);\n}\n\nlemma EnqueueCorrect<T>(q: Queue<T>, x: T)\n  ensures queueToSeq(enqueue(q, x)) == queueToSeq(q) + [x]\n  ensures queueSize(enqueue(q, x)) == queueSize(q) + 1\n{\n  var q' := enqueue(q, x);\n  assert q'.front == q.front;\n  assert q'.rear == [x] + q.rear;\n\n  ReverseAppend([x], q.rear);\n  assert reverse([x]) == [x];\n  assert reverse([x] + q.rear) == reverse(q.rear) + reverse([x]);\n  assert reverse([x] + q.rear) == reverse(q.rear) + [x];\n\n  calc == {\n    queueToSeq(q');\n    q'.front + reverse(q'.rear);\n    q.front + reverse([x] + q.rear);\n    q.front + (reverse(q.rear) + [x]);\n    { SeqAssoc(q.front, reverse(q.rear), [x]); }\n    (q.front + reverse(q.rear)) + [x];\n    queueToSeq(q) + [x];\n  }\n\n  QueueSizeProperty(q);\n  QueueSizeProperty(q');\n}\n\nlemma DequeueCorrect<T>(q: Queue<T>)\n  requires !queueIsEmpty(q)\n  ensures |queueToSeq(q)| > 0\n  ensures queueToSeq(dequeue(q)) == queueToSeq(q)[1..]\n  ensures queueFront(q) == queueToSeq(q)[0]\n{\n  if |q.front| > 0 {\n    assert queueToSeq(q) == q.front + reverse(q.rear);\n    assert queueToSeq(dequeue(q)) == q.front[1..] + reverse(q.rear);\n    assert queueFront(q) == q.front[0];\n  } else {\n    assert q.front == [];\n    assert |q.rear| > 0;\n    var rev := reverse(q.rear);\n    ReverseLength(q.rear);\n    assert |rev| == |q.rear|;\n    assert queueToSeq(q) == rev;\n    assert queueFront(q) == q.rear[|q.rear| - 1];\n\n    ReverseFirst(q.rear);\n    assert rev[0] == q.rear[|q.rear| - 1];\n\n    if |q.rear| == 1 {\n      assert rev == [q.rear[0]];\n      \n/*[CODE HERE]*/\n      assert queueFront(q) == q.rear[0];\n      assert queueToSeq(q)[0] == q.rear[0];\n    } else {\n      assert |rev| > 1;\n      assert queueToSeq(dequeue(q)) == rev[1..];\n      assert queueFront(q) == rev[0];\n    }\n  }\n}\n\nlemma SimpleQueueEquivalence<T>(sq: SimpleQueue<T>, q: Queue<T>)\n  requires sq.elements == queueToSeq(q)\n  ensures simpleQueueIsEmpty(sq) == queueIsEmpty(q)\n  ensures simpleQueueSize(sq) == queueSize(q)\n{\n  if queueIsEmpty(q) {\n    assert q.front == [] && q.rear == [];\n    assert queueToSeq(q) == [];\n    assert sq.elements == [];\n  }\n  QueueSizeProperty(q);\n}", "output": "assert queueToSeq(q) == [q.rear[0]];"}, {"id": "example_DequeueCorrect_6", "type": "assert", "program": "// Queue operations: enqueue, dequeue, isEmpty, size\n\ndatatype Queue<T> = Queue(front: seq<T>, rear: seq<T>)\n\nfunction {:spec} queueEmpty<T>(): Queue<T>\n{\n  Queue([], [])\n}\n\npredicate {:spec} queueIsEmpty<T>(q: Queue<T>)\n{\n  q.front == [] && q.rear == []\n}\n\nfunction {:spec} enqueue<T>(q: Queue<T>, x: T): Queue<T>\n{\n  Queue(q.front, [x] + q.rear)\n}\n\nfunction {:spec} dequeue<T>(q: Queue<T>): Queue<T>\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    Queue(q.front[1..], q.rear)\n  else\n    // Front is empty, so we reverse rear and put it in front\n    if |q.rear| == 1 then\n      Queue([], [])\n    else\n      Queue(reverse(q.rear)[1..], [])\n}\n\nfunction {:spec} queueFront<T>(q: Queue<T>): T\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    q.front[0]\n  else\n    // Front is empty, so the front element is the first element of rear (when reversed)\n    q.rear[|q.rear| - 1]\n}\n\nfunction {:spec} queueSize<T>(q: Queue<T>): nat\n{\n  |q.front| + |q.rear|\n}\n\nfunction {:spec} queueToSeq<T>(q: Queue<T>): seq<T>\n{\n  q.front + reverse(q.rear)\n}\n\nfunction reverse<T>(s: seq<T>): seq<T>\n{\n  if |s| == 0 then []\n  else reverse(s[1..]) + [s[0]]\n}\n\n// Alternative queue representation with invariant\ndatatype SimpleQueue<T> = SimpleQueue(elements: seq<T>)\n\nfunction {:spec} simpleQueueEmpty<T>(): SimpleQueue<T>\n{\n  SimpleQueue([])\n}\n\npredicate {:spec} simpleQueueIsEmpty<T>(q: SimpleQueue<T>)\n{\n  q.elements == []\n}\n\nfunction {:spec} simpleEnqueue<T>(q: SimpleQueue<T>, x: T): SimpleQueue<T>\n{\n  SimpleQueue(q.elements + [x])\n}\n\nfunction {:spec} simpleDequeue<T>(q: SimpleQueue<T>): SimpleQueue<T>\n  requires !simpleQueueIsEmpty(q)\n{\n  SimpleQueue(q.elements[1..])\n}\n\nfunction {:spec} simpleQueueFront<T>(q: SimpleQueue<T>): T\n  requires !simpleQueueIsEmpty(q)\n{\n  q.elements[0]\n}\n\nfunction {:spec} simpleQueueSize<T>(q: SimpleQueue<T>): nat\n{\n  |q.elements|\n}\n\nlemma ReverseLength<T>(s: seq<T>)\n  ensures |reverse(s)| == |s|\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseLength(s[1..]);\n    assert |reverse(s)| == |reverse(s[1..])| + 1;\n  }\n}\n\nlemma ReverseReverse<T>(s: seq<T>)\n  ensures reverse(reverse(s)) == s\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseReverse(s[1..]);\n    ReverseAppend(reverse(s[1..]), [s[0]]);\n    assert reverse(reverse(s)) == s;\n  }\n}\n\nlemma ReverseAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n  } else {\n    assert s1 + s2 == [s1[0]] + (s1[1..] + s2);\n    ReverseAppend(s1[1..], s2);\n  }\n}\n\nlemma ReverseFirst<T>(s: seq<T>)\n  requires |s| > 0\n  ensures |reverse(s)| == |s|\n  ensures reverse(s)[|reverse(s)| - 1] == s[0]\n  ensures reverse(s)[0] == s[|s| - 1]\n{\n  ReverseLength(s);\n  if |s| == 1 {\n    assert reverse(s) == [s[0]];\n  } else {\n    ReverseFirst(s[1..]);\n    assert reverse(s) == reverse(s[1..]) + [s[0]];\n    ReverseLength(s[1..]);\n    assert |reverse(s[1..])| == |s| - 1;\n  }\n}\n\nlemma SeqAssoc<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures a + (b + c) == (a + b) + c\n{\n  // Dafny proves this automatically\n}\n\nlemma QueueSizeProperty<T>(q: Queue<T>)\n  ensures queueSize(q) == |queueToSeq(q)|\n{\n  ReverseLength(q.rear);\n}\n\nlemma EnqueueCorrect<T>(q: Queue<T>, x: T)\n  ensures queueToSeq(enqueue(q, x)) == queueToSeq(q) + [x]\n  ensures queueSize(enqueue(q, x)) == queueSize(q) + 1\n{\n  var q' := enqueue(q, x);\n  assert q'.front == q.front;\n  assert q'.rear == [x] + q.rear;\n\n  ReverseAppend([x], q.rear);\n  assert reverse([x]) == [x];\n  assert reverse([x] + q.rear) == reverse(q.rear) + reverse([x]);\n  assert reverse([x] + q.rear) == reverse(q.rear) + [x];\n\n  calc == {\n    queueToSeq(q');\n    q'.front + reverse(q'.rear);\n    q.front + reverse([x] + q.rear);\n    q.front + (reverse(q.rear) + [x]);\n    { SeqAssoc(q.front, reverse(q.rear), [x]); }\n    (q.front + reverse(q.rear)) + [x];\n    queueToSeq(q) + [x];\n  }\n\n  QueueSizeProperty(q);\n  QueueSizeProperty(q');\n}\n\nlemma DequeueCorrect<T>(q: Queue<T>)\n  requires !queueIsEmpty(q)\n  ensures |queueToSeq(q)| > 0\n  ensures queueToSeq(dequeue(q)) == queueToSeq(q)[1..]\n  ensures queueFront(q) == queueToSeq(q)[0]\n{\n  if |q.front| > 0 {\n    assert queueToSeq(q) == q.front + reverse(q.rear);\n    assert queueToSeq(dequeue(q)) == q.front[1..] + reverse(q.rear);\n    assert queueFront(q) == q.front[0];\n  } else {\n    assert q.front == [];\n    assert |q.rear| > 0;\n    var rev := reverse(q.rear);\n    ReverseLength(q.rear);\n    assert |rev| == |q.rear|;\n    assert queueToSeq(q) == rev;\n    assert queueFront(q) == q.rear[|q.rear| - 1];\n\n    ReverseFirst(q.rear);\n    assert rev[0] == q.rear[|q.rear| - 1];\n\n    if |q.rear| == 1 {\n      \n/*[CODE HERE]*/\n      assert queueToSeq(q) == [q.rear[0]];\n      assert queueFront(q) == q.rear[0];\n      assert queueToSeq(q)[0] == q.rear[0];\n    } else {\n      assert |rev| > 1;\n      assert queueToSeq(dequeue(q)) == rev[1..];\n      assert queueFront(q) == rev[0];\n    }\n  }\n}\n\nlemma SimpleQueueEquivalence<T>(sq: SimpleQueue<T>, q: Queue<T>)\n  requires sq.elements == queueToSeq(q)\n  ensures simpleQueueIsEmpty(sq) == queueIsEmpty(q)\n  ensures simpleQueueSize(sq) == queueSize(q)\n{\n  if queueIsEmpty(q) {\n    assert q.front == [] && q.rear == [];\n    assert queueToSeq(q) == [];\n    assert sq.elements == [];\n  }\n  QueueSizeProperty(q);\n}", "output": "assert rev == [q.rear[0]];"}, {"id": "example_DequeueCorrect_7", "type": "assert", "program": "// Queue operations: enqueue, dequeue, isEmpty, size\n\ndatatype Queue<T> = Queue(front: seq<T>, rear: seq<T>)\n\nfunction {:spec} queueEmpty<T>(): Queue<T>\n{\n  Queue([], [])\n}\n\npredicate {:spec} queueIsEmpty<T>(q: Queue<T>)\n{\n  q.front == [] && q.rear == []\n}\n\nfunction {:spec} enqueue<T>(q: Queue<T>, x: T): Queue<T>\n{\n  Queue(q.front, [x] + q.rear)\n}\n\nfunction {:spec} dequeue<T>(q: Queue<T>): Queue<T>\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    Queue(q.front[1..], q.rear)\n  else\n    // Front is empty, so we reverse rear and put it in front\n    if |q.rear| == 1 then\n      Queue([], [])\n    else\n      Queue(reverse(q.rear)[1..], [])\n}\n\nfunction {:spec} queueFront<T>(q: Queue<T>): T\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    q.front[0]\n  else\n    // Front is empty, so the front element is the first element of rear (when reversed)\n    q.rear[|q.rear| - 1]\n}\n\nfunction {:spec} queueSize<T>(q: Queue<T>): nat\n{\n  |q.front| + |q.rear|\n}\n\nfunction {:spec} queueToSeq<T>(q: Queue<T>): seq<T>\n{\n  q.front + reverse(q.rear)\n}\n\nfunction reverse<T>(s: seq<T>): seq<T>\n{\n  if |s| == 0 then []\n  else reverse(s[1..]) + [s[0]]\n}\n\n// Alternative queue representation with invariant\ndatatype SimpleQueue<T> = SimpleQueue(elements: seq<T>)\n\nfunction {:spec} simpleQueueEmpty<T>(): SimpleQueue<T>\n{\n  SimpleQueue([])\n}\n\npredicate {:spec} simpleQueueIsEmpty<T>(q: SimpleQueue<T>)\n{\n  q.elements == []\n}\n\nfunction {:spec} simpleEnqueue<T>(q: SimpleQueue<T>, x: T): SimpleQueue<T>\n{\n  SimpleQueue(q.elements + [x])\n}\n\nfunction {:spec} simpleDequeue<T>(q: SimpleQueue<T>): SimpleQueue<T>\n  requires !simpleQueueIsEmpty(q)\n{\n  SimpleQueue(q.elements[1..])\n}\n\nfunction {:spec} simpleQueueFront<T>(q: SimpleQueue<T>): T\n  requires !simpleQueueIsEmpty(q)\n{\n  q.elements[0]\n}\n\nfunction {:spec} simpleQueueSize<T>(q: SimpleQueue<T>): nat\n{\n  |q.elements|\n}\n\nlemma ReverseLength<T>(s: seq<T>)\n  ensures |reverse(s)| == |s|\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseLength(s[1..]);\n    assert |reverse(s)| == |reverse(s[1..])| + 1;\n  }\n}\n\nlemma ReverseReverse<T>(s: seq<T>)\n  ensures reverse(reverse(s)) == s\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseReverse(s[1..]);\n    ReverseAppend(reverse(s[1..]), [s[0]]);\n    assert reverse(reverse(s)) == s;\n  }\n}\n\nlemma ReverseAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n  } else {\n    assert s1 + s2 == [s1[0]] + (s1[1..] + s2);\n    ReverseAppend(s1[1..], s2);\n  }\n}\n\nlemma ReverseFirst<T>(s: seq<T>)\n  requires |s| > 0\n  ensures |reverse(s)| == |s|\n  ensures reverse(s)[|reverse(s)| - 1] == s[0]\n  ensures reverse(s)[0] == s[|s| - 1]\n{\n  ReverseLength(s);\n  if |s| == 1 {\n    assert reverse(s) == [s[0]];\n  } else {\n    ReverseFirst(s[1..]);\n    assert reverse(s) == reverse(s[1..]) + [s[0]];\n    ReverseLength(s[1..]);\n    assert |reverse(s[1..])| == |s| - 1;\n  }\n}\n\nlemma SeqAssoc<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures a + (b + c) == (a + b) + c\n{\n  // Dafny proves this automatically\n}\n\nlemma QueueSizeProperty<T>(q: Queue<T>)\n  ensures queueSize(q) == |queueToSeq(q)|\n{\n  ReverseLength(q.rear);\n}\n\nlemma EnqueueCorrect<T>(q: Queue<T>, x: T)\n  ensures queueToSeq(enqueue(q, x)) == queueToSeq(q) + [x]\n  ensures queueSize(enqueue(q, x)) == queueSize(q) + 1\n{\n  var q' := enqueue(q, x);\n  assert q'.front == q.front;\n  assert q'.rear == [x] + q.rear;\n\n  ReverseAppend([x], q.rear);\n  assert reverse([x]) == [x];\n  assert reverse([x] + q.rear) == reverse(q.rear) + reverse([x]);\n  assert reverse([x] + q.rear) == reverse(q.rear) + [x];\n\n  calc == {\n    queueToSeq(q');\n    q'.front + reverse(q'.rear);\n    q.front + reverse([x] + q.rear);\n    q.front + (reverse(q.rear) + [x]);\n    { SeqAssoc(q.front, reverse(q.rear), [x]); }\n    (q.front + reverse(q.rear)) + [x];\n    queueToSeq(q) + [x];\n  }\n\n  QueueSizeProperty(q);\n  QueueSizeProperty(q');\n}\n\nlemma DequeueCorrect<T>(q: Queue<T>)\n  requires !queueIsEmpty(q)\n  ensures |queueToSeq(q)| > 0\n  ensures queueToSeq(dequeue(q)) == queueToSeq(q)[1..]\n  ensures queueFront(q) == queueToSeq(q)[0]\n{\n  if |q.front| > 0 {\n    assert queueToSeq(q) == q.front + reverse(q.rear);\n    assert queueToSeq(dequeue(q)) == q.front[1..] + reverse(q.rear);\n    assert queueFront(q) == q.front[0];\n  } else {\n    assert q.front == [];\n    assert |q.rear| > 0;\n    var rev := reverse(q.rear);\n    ReverseLength(q.rear);\n    assert |rev| == |q.rear|;\n    assert queueToSeq(q) == rev;\n    assert queueFront(q) == q.rear[|q.rear| - 1];\n\n    ReverseFirst(q.rear);\n    \n/*[CODE HERE]*/\n\n    if |q.rear| == 1 {\n      assert rev == [q.rear[0]];\n      assert queueToSeq(q) == [q.rear[0]];\n      assert queueFront(q) == q.rear[0];\n      assert queueToSeq(q)[0] == q.rear[0];\n    } else {\n      assert |rev| > 1;\n      assert queueToSeq(dequeue(q)) == rev[1..];\n      assert queueFront(q) == rev[0];\n    }\n  }\n}\n\nlemma SimpleQueueEquivalence<T>(sq: SimpleQueue<T>, q: Queue<T>)\n  requires sq.elements == queueToSeq(q)\n  ensures simpleQueueIsEmpty(sq) == queueIsEmpty(q)\n  ensures simpleQueueSize(sq) == queueSize(q)\n{\n  if queueIsEmpty(q) {\n    assert q.front == [] && q.rear == [];\n    assert queueToSeq(q) == [];\n    assert sq.elements == [];\n  }\n  QueueSizeProperty(q);\n}", "output": "assert rev[0] == q.rear[|q.rear| - 1];"}, {"id": "example_DequeueCorrect_8", "type": "call", "program": "// Queue operations: enqueue, dequeue, isEmpty, size\n\ndatatype Queue<T> = Queue(front: seq<T>, rear: seq<T>)\n\nfunction {:spec} queueEmpty<T>(): Queue<T>\n{\n  Queue([], [])\n}\n\npredicate {:spec} queueIsEmpty<T>(q: Queue<T>)\n{\n  q.front == [] && q.rear == []\n}\n\nfunction {:spec} enqueue<T>(q: Queue<T>, x: T): Queue<T>\n{\n  Queue(q.front, [x] + q.rear)\n}\n\nfunction {:spec} dequeue<T>(q: Queue<T>): Queue<T>\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    Queue(q.front[1..], q.rear)\n  else\n    // Front is empty, so we reverse rear and put it in front\n    if |q.rear| == 1 then\n      Queue([], [])\n    else\n      Queue(reverse(q.rear)[1..], [])\n}\n\nfunction {:spec} queueFront<T>(q: Queue<T>): T\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    q.front[0]\n  else\n    // Front is empty, so the front element is the first element of rear (when reversed)\n    q.rear[|q.rear| - 1]\n}\n\nfunction {:spec} queueSize<T>(q: Queue<T>): nat\n{\n  |q.front| + |q.rear|\n}\n\nfunction {:spec} queueToSeq<T>(q: Queue<T>): seq<T>\n{\n  q.front + reverse(q.rear)\n}\n\nfunction reverse<T>(s: seq<T>): seq<T>\n{\n  if |s| == 0 then []\n  else reverse(s[1..]) + [s[0]]\n}\n\n// Alternative queue representation with invariant\ndatatype SimpleQueue<T> = SimpleQueue(elements: seq<T>)\n\nfunction {:spec} simpleQueueEmpty<T>(): SimpleQueue<T>\n{\n  SimpleQueue([])\n}\n\npredicate {:spec} simpleQueueIsEmpty<T>(q: SimpleQueue<T>)\n{\n  q.elements == []\n}\n\nfunction {:spec} simpleEnqueue<T>(q: SimpleQueue<T>, x: T): SimpleQueue<T>\n{\n  SimpleQueue(q.elements + [x])\n}\n\nfunction {:spec} simpleDequeue<T>(q: SimpleQueue<T>): SimpleQueue<T>\n  requires !simpleQueueIsEmpty(q)\n{\n  SimpleQueue(q.elements[1..])\n}\n\nfunction {:spec} simpleQueueFront<T>(q: SimpleQueue<T>): T\n  requires !simpleQueueIsEmpty(q)\n{\n  q.elements[0]\n}\n\nfunction {:spec} simpleQueueSize<T>(q: SimpleQueue<T>): nat\n{\n  |q.elements|\n}\n\nlemma ReverseLength<T>(s: seq<T>)\n  ensures |reverse(s)| == |s|\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseLength(s[1..]);\n    assert |reverse(s)| == |reverse(s[1..])| + 1;\n  }\n}\n\nlemma ReverseReverse<T>(s: seq<T>)\n  ensures reverse(reverse(s)) == s\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseReverse(s[1..]);\n    ReverseAppend(reverse(s[1..]), [s[0]]);\n    assert reverse(reverse(s)) == s;\n  }\n}\n\nlemma ReverseAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n  } else {\n    assert s1 + s2 == [s1[0]] + (s1[1..] + s2);\n    ReverseAppend(s1[1..], s2);\n  }\n}\n\nlemma ReverseFirst<T>(s: seq<T>)\n  requires |s| > 0\n  ensures |reverse(s)| == |s|\n  ensures reverse(s)[|reverse(s)| - 1] == s[0]\n  ensures reverse(s)[0] == s[|s| - 1]\n{\n  ReverseLength(s);\n  if |s| == 1 {\n    assert reverse(s) == [s[0]];\n  } else {\n    ReverseFirst(s[1..]);\n    assert reverse(s) == reverse(s[1..]) + [s[0]];\n    ReverseLength(s[1..]);\n    assert |reverse(s[1..])| == |s| - 1;\n  }\n}\n\nlemma SeqAssoc<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures a + (b + c) == (a + b) + c\n{\n  // Dafny proves this automatically\n}\n\nlemma QueueSizeProperty<T>(q: Queue<T>)\n  ensures queueSize(q) == |queueToSeq(q)|\n{\n  ReverseLength(q.rear);\n}\n\nlemma EnqueueCorrect<T>(q: Queue<T>, x: T)\n  ensures queueToSeq(enqueue(q, x)) == queueToSeq(q) + [x]\n  ensures queueSize(enqueue(q, x)) == queueSize(q) + 1\n{\n  var q' := enqueue(q, x);\n  assert q'.front == q.front;\n  assert q'.rear == [x] + q.rear;\n\n  ReverseAppend([x], q.rear);\n  assert reverse([x]) == [x];\n  assert reverse([x] + q.rear) == reverse(q.rear) + reverse([x]);\n  assert reverse([x] + q.rear) == reverse(q.rear) + [x];\n\n  calc == {\n    queueToSeq(q');\n    q'.front + reverse(q'.rear);\n    q.front + reverse([x] + q.rear);\n    q.front + (reverse(q.rear) + [x]);\n    { SeqAssoc(q.front, reverse(q.rear), [x]); }\n    (q.front + reverse(q.rear)) + [x];\n    queueToSeq(q) + [x];\n  }\n\n  QueueSizeProperty(q);\n  QueueSizeProperty(q');\n}\n\nlemma DequeueCorrect<T>(q: Queue<T>)\n  requires !queueIsEmpty(q)\n  ensures |queueToSeq(q)| > 0\n  ensures queueToSeq(dequeue(q)) == queueToSeq(q)[1..]\n  ensures queueFront(q) == queueToSeq(q)[0]\n{\n  if |q.front| > 0 {\n    assert queueToSeq(q) == q.front + reverse(q.rear);\n    assert queueToSeq(dequeue(q)) == q.front[1..] + reverse(q.rear);\n    assert queueFront(q) == q.front[0];\n  } else {\n    assert q.front == [];\n    assert |q.rear| > 0;\n    var rev := reverse(q.rear);\n    ReverseLength(q.rear);\n    assert |rev| == |q.rear|;\n    assert queueToSeq(q) == rev;\n    assert queueFront(q) == q.rear[|q.rear| - 1];\n\n    \n/*[CODE HERE]*/\n    assert rev[0] == q.rear[|q.rear| - 1];\n\n    if |q.rear| == 1 {\n      assert rev == [q.rear[0]];\n      assert queueToSeq(q) == [q.rear[0]];\n      assert queueFront(q) == q.rear[0];\n      assert queueToSeq(q)[0] == q.rear[0];\n    } else {\n      assert |rev| > 1;\n      assert queueToSeq(dequeue(q)) == rev[1..];\n      assert queueFront(q) == rev[0];\n    }\n  }\n}\n\nlemma SimpleQueueEquivalence<T>(sq: SimpleQueue<T>, q: Queue<T>)\n  requires sq.elements == queueToSeq(q)\n  ensures simpleQueueIsEmpty(sq) == queueIsEmpty(q)\n  ensures simpleQueueSize(sq) == queueSize(q)\n{\n  if queueIsEmpty(q) {\n    assert q.front == [] && q.rear == [];\n    assert queueToSeq(q) == [];\n    assert sq.elements == [];\n  }\n  QueueSizeProperty(q);\n}", "output": "ReverseFirst(q.rear);"}, {"id": "example_DequeueCorrect_9", "type": "assert", "program": "// Queue operations: enqueue, dequeue, isEmpty, size\n\ndatatype Queue<T> = Queue(front: seq<T>, rear: seq<T>)\n\nfunction {:spec} queueEmpty<T>(): Queue<T>\n{\n  Queue([], [])\n}\n\npredicate {:spec} queueIsEmpty<T>(q: Queue<T>)\n{\n  q.front == [] && q.rear == []\n}\n\nfunction {:spec} enqueue<T>(q: Queue<T>, x: T): Queue<T>\n{\n  Queue(q.front, [x] + q.rear)\n}\n\nfunction {:spec} dequeue<T>(q: Queue<T>): Queue<T>\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    Queue(q.front[1..], q.rear)\n  else\n    // Front is empty, so we reverse rear and put it in front\n    if |q.rear| == 1 then\n      Queue([], [])\n    else\n      Queue(reverse(q.rear)[1..], [])\n}\n\nfunction {:spec} queueFront<T>(q: Queue<T>): T\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    q.front[0]\n  else\n    // Front is empty, so the front element is the first element of rear (when reversed)\n    q.rear[|q.rear| - 1]\n}\n\nfunction {:spec} queueSize<T>(q: Queue<T>): nat\n{\n  |q.front| + |q.rear|\n}\n\nfunction {:spec} queueToSeq<T>(q: Queue<T>): seq<T>\n{\n  q.front + reverse(q.rear)\n}\n\nfunction reverse<T>(s: seq<T>): seq<T>\n{\n  if |s| == 0 then []\n  else reverse(s[1..]) + [s[0]]\n}\n\n// Alternative queue representation with invariant\ndatatype SimpleQueue<T> = SimpleQueue(elements: seq<T>)\n\nfunction {:spec} simpleQueueEmpty<T>(): SimpleQueue<T>\n{\n  SimpleQueue([])\n}\n\npredicate {:spec} simpleQueueIsEmpty<T>(q: SimpleQueue<T>)\n{\n  q.elements == []\n}\n\nfunction {:spec} simpleEnqueue<T>(q: SimpleQueue<T>, x: T): SimpleQueue<T>\n{\n  SimpleQueue(q.elements + [x])\n}\n\nfunction {:spec} simpleDequeue<T>(q: SimpleQueue<T>): SimpleQueue<T>\n  requires !simpleQueueIsEmpty(q)\n{\n  SimpleQueue(q.elements[1..])\n}\n\nfunction {:spec} simpleQueueFront<T>(q: SimpleQueue<T>): T\n  requires !simpleQueueIsEmpty(q)\n{\n  q.elements[0]\n}\n\nfunction {:spec} simpleQueueSize<T>(q: SimpleQueue<T>): nat\n{\n  |q.elements|\n}\n\nlemma ReverseLength<T>(s: seq<T>)\n  ensures |reverse(s)| == |s|\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseLength(s[1..]);\n    assert |reverse(s)| == |reverse(s[1..])| + 1;\n  }\n}\n\nlemma ReverseReverse<T>(s: seq<T>)\n  ensures reverse(reverse(s)) == s\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseReverse(s[1..]);\n    ReverseAppend(reverse(s[1..]), [s[0]]);\n    assert reverse(reverse(s)) == s;\n  }\n}\n\nlemma ReverseAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n  } else {\n    assert s1 + s2 == [s1[0]] + (s1[1..] + s2);\n    ReverseAppend(s1[1..], s2);\n  }\n}\n\nlemma ReverseFirst<T>(s: seq<T>)\n  requires |s| > 0\n  ensures |reverse(s)| == |s|\n  ensures reverse(s)[|reverse(s)| - 1] == s[0]\n  ensures reverse(s)[0] == s[|s| - 1]\n{\n  ReverseLength(s);\n  if |s| == 1 {\n    assert reverse(s) == [s[0]];\n  } else {\n    ReverseFirst(s[1..]);\n    assert reverse(s) == reverse(s[1..]) + [s[0]];\n    ReverseLength(s[1..]);\n    assert |reverse(s[1..])| == |s| - 1;\n  }\n}\n\nlemma SeqAssoc<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures a + (b + c) == (a + b) + c\n{\n  // Dafny proves this automatically\n}\n\nlemma QueueSizeProperty<T>(q: Queue<T>)\n  ensures queueSize(q) == |queueToSeq(q)|\n{\n  ReverseLength(q.rear);\n}\n\nlemma EnqueueCorrect<T>(q: Queue<T>, x: T)\n  ensures queueToSeq(enqueue(q, x)) == queueToSeq(q) + [x]\n  ensures queueSize(enqueue(q, x)) == queueSize(q) + 1\n{\n  var q' := enqueue(q, x);\n  assert q'.front == q.front;\n  assert q'.rear == [x] + q.rear;\n\n  ReverseAppend([x], q.rear);\n  assert reverse([x]) == [x];\n  assert reverse([x] + q.rear) == reverse(q.rear) + reverse([x]);\n  assert reverse([x] + q.rear) == reverse(q.rear) + [x];\n\n  calc == {\n    queueToSeq(q');\n    q'.front + reverse(q'.rear);\n    q.front + reverse([x] + q.rear);\n    q.front + (reverse(q.rear) + [x]);\n    { SeqAssoc(q.front, reverse(q.rear), [x]); }\n    (q.front + reverse(q.rear)) + [x];\n    queueToSeq(q) + [x];\n  }\n\n  QueueSizeProperty(q);\n  QueueSizeProperty(q');\n}\n\nlemma DequeueCorrect<T>(q: Queue<T>)\n  requires !queueIsEmpty(q)\n  ensures |queueToSeq(q)| > 0\n  ensures queueToSeq(dequeue(q)) == queueToSeq(q)[1..]\n  ensures queueFront(q) == queueToSeq(q)[0]\n{\n  if |q.front| > 0 {\n    assert queueToSeq(q) == q.front + reverse(q.rear);\n    assert queueToSeq(dequeue(q)) == q.front[1..] + reverse(q.rear);\n    assert queueFront(q) == q.front[0];\n  } else {\n    assert q.front == [];\n    assert |q.rear| > 0;\n    var rev := reverse(q.rear);\n    ReverseLength(q.rear);\n    assert |rev| == |q.rear|;\n    assert queueToSeq(q) == rev;\n    \n/*[CODE HERE]*/\n\n    ReverseFirst(q.rear);\n    assert rev[0] == q.rear[|q.rear| - 1];\n\n    if |q.rear| == 1 {\n      assert rev == [q.rear[0]];\n      assert queueToSeq(q) == [q.rear[0]];\n      assert queueFront(q) == q.rear[0];\n      assert queueToSeq(q)[0] == q.rear[0];\n    } else {\n      assert |rev| > 1;\n      assert queueToSeq(dequeue(q)) == rev[1..];\n      assert queueFront(q) == rev[0];\n    }\n  }\n}\n\nlemma SimpleQueueEquivalence<T>(sq: SimpleQueue<T>, q: Queue<T>)\n  requires sq.elements == queueToSeq(q)\n  ensures simpleQueueIsEmpty(sq) == queueIsEmpty(q)\n  ensures simpleQueueSize(sq) == queueSize(q)\n{\n  if queueIsEmpty(q) {\n    assert q.front == [] && q.rear == [];\n    assert queueToSeq(q) == [];\n    assert sq.elements == [];\n  }\n  QueueSizeProperty(q);\n}", "output": "assert queueFront(q) == q.rear[|q.rear| - 1];"}, {"id": "example_DequeueCorrect_10", "type": "assert", "program": "// Queue operations: enqueue, dequeue, isEmpty, size\n\ndatatype Queue<T> = Queue(front: seq<T>, rear: seq<T>)\n\nfunction {:spec} queueEmpty<T>(): Queue<T>\n{\n  Queue([], [])\n}\n\npredicate {:spec} queueIsEmpty<T>(q: Queue<T>)\n{\n  q.front == [] && q.rear == []\n}\n\nfunction {:spec} enqueue<T>(q: Queue<T>, x: T): Queue<T>\n{\n  Queue(q.front, [x] + q.rear)\n}\n\nfunction {:spec} dequeue<T>(q: Queue<T>): Queue<T>\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    Queue(q.front[1..], q.rear)\n  else\n    // Front is empty, so we reverse rear and put it in front\n    if |q.rear| == 1 then\n      Queue([], [])\n    else\n      Queue(reverse(q.rear)[1..], [])\n}\n\nfunction {:spec} queueFront<T>(q: Queue<T>): T\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    q.front[0]\n  else\n    // Front is empty, so the front element is the first element of rear (when reversed)\n    q.rear[|q.rear| - 1]\n}\n\nfunction {:spec} queueSize<T>(q: Queue<T>): nat\n{\n  |q.front| + |q.rear|\n}\n\nfunction {:spec} queueToSeq<T>(q: Queue<T>): seq<T>\n{\n  q.front + reverse(q.rear)\n}\n\nfunction reverse<T>(s: seq<T>): seq<T>\n{\n  if |s| == 0 then []\n  else reverse(s[1..]) + [s[0]]\n}\n\n// Alternative queue representation with invariant\ndatatype SimpleQueue<T> = SimpleQueue(elements: seq<T>)\n\nfunction {:spec} simpleQueueEmpty<T>(): SimpleQueue<T>\n{\n  SimpleQueue([])\n}\n\npredicate {:spec} simpleQueueIsEmpty<T>(q: SimpleQueue<T>)\n{\n  q.elements == []\n}\n\nfunction {:spec} simpleEnqueue<T>(q: SimpleQueue<T>, x: T): SimpleQueue<T>\n{\n  SimpleQueue(q.elements + [x])\n}\n\nfunction {:spec} simpleDequeue<T>(q: SimpleQueue<T>): SimpleQueue<T>\n  requires !simpleQueueIsEmpty(q)\n{\n  SimpleQueue(q.elements[1..])\n}\n\nfunction {:spec} simpleQueueFront<T>(q: SimpleQueue<T>): T\n  requires !simpleQueueIsEmpty(q)\n{\n  q.elements[0]\n}\n\nfunction {:spec} simpleQueueSize<T>(q: SimpleQueue<T>): nat\n{\n  |q.elements|\n}\n\nlemma ReverseLength<T>(s: seq<T>)\n  ensures |reverse(s)| == |s|\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseLength(s[1..]);\n    assert |reverse(s)| == |reverse(s[1..])| + 1;\n  }\n}\n\nlemma ReverseReverse<T>(s: seq<T>)\n  ensures reverse(reverse(s)) == s\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseReverse(s[1..]);\n    ReverseAppend(reverse(s[1..]), [s[0]]);\n    assert reverse(reverse(s)) == s;\n  }\n}\n\nlemma ReverseAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n  } else {\n    assert s1 + s2 == [s1[0]] + (s1[1..] + s2);\n    ReverseAppend(s1[1..], s2);\n  }\n}\n\nlemma ReverseFirst<T>(s: seq<T>)\n  requires |s| > 0\n  ensures |reverse(s)| == |s|\n  ensures reverse(s)[|reverse(s)| - 1] == s[0]\n  ensures reverse(s)[0] == s[|s| - 1]\n{\n  ReverseLength(s);\n  if |s| == 1 {\n    assert reverse(s) == [s[0]];\n  } else {\n    ReverseFirst(s[1..]);\n    assert reverse(s) == reverse(s[1..]) + [s[0]];\n    ReverseLength(s[1..]);\n    assert |reverse(s[1..])| == |s| - 1;\n  }\n}\n\nlemma SeqAssoc<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures a + (b + c) == (a + b) + c\n{\n  // Dafny proves this automatically\n}\n\nlemma QueueSizeProperty<T>(q: Queue<T>)\n  ensures queueSize(q) == |queueToSeq(q)|\n{\n  ReverseLength(q.rear);\n}\n\nlemma EnqueueCorrect<T>(q: Queue<T>, x: T)\n  ensures queueToSeq(enqueue(q, x)) == queueToSeq(q) + [x]\n  ensures queueSize(enqueue(q, x)) == queueSize(q) + 1\n{\n  var q' := enqueue(q, x);\n  assert q'.front == q.front;\n  assert q'.rear == [x] + q.rear;\n\n  ReverseAppend([x], q.rear);\n  assert reverse([x]) == [x];\n  assert reverse([x] + q.rear) == reverse(q.rear) + reverse([x]);\n  assert reverse([x] + q.rear) == reverse(q.rear) + [x];\n\n  calc == {\n    queueToSeq(q');\n    q'.front + reverse(q'.rear);\n    q.front + reverse([x] + q.rear);\n    q.front + (reverse(q.rear) + [x]);\n    { SeqAssoc(q.front, reverse(q.rear), [x]); }\n    (q.front + reverse(q.rear)) + [x];\n    queueToSeq(q) + [x];\n  }\n\n  QueueSizeProperty(q);\n  QueueSizeProperty(q');\n}\n\nlemma DequeueCorrect<T>(q: Queue<T>)\n  requires !queueIsEmpty(q)\n  ensures |queueToSeq(q)| > 0\n  ensures queueToSeq(dequeue(q)) == queueToSeq(q)[1..]\n  ensures queueFront(q) == queueToSeq(q)[0]\n{\n  if |q.front| > 0 {\n    assert queueToSeq(q) == q.front + reverse(q.rear);\n    assert queueToSeq(dequeue(q)) == q.front[1..] + reverse(q.rear);\n    assert queueFront(q) == q.front[0];\n  } else {\n    assert q.front == [];\n    assert |q.rear| > 0;\n    var rev := reverse(q.rear);\n    ReverseLength(q.rear);\n    assert |rev| == |q.rear|;\n    \n/*[CODE HERE]*/\n    assert queueFront(q) == q.rear[|q.rear| - 1];\n\n    ReverseFirst(q.rear);\n    assert rev[0] == q.rear[|q.rear| - 1];\n\n    if |q.rear| == 1 {\n      assert rev == [q.rear[0]];\n      assert queueToSeq(q) == [q.rear[0]];\n      assert queueFront(q) == q.rear[0];\n      assert queueToSeq(q)[0] == q.rear[0];\n    } else {\n      assert |rev| > 1;\n      assert queueToSeq(dequeue(q)) == rev[1..];\n      assert queueFront(q) == rev[0];\n    }\n  }\n}\n\nlemma SimpleQueueEquivalence<T>(sq: SimpleQueue<T>, q: Queue<T>)\n  requires sq.elements == queueToSeq(q)\n  ensures simpleQueueIsEmpty(sq) == queueIsEmpty(q)\n  ensures simpleQueueSize(sq) == queueSize(q)\n{\n  if queueIsEmpty(q) {\n    assert q.front == [] && q.rear == [];\n    assert queueToSeq(q) == [];\n    assert sq.elements == [];\n  }\n  QueueSizeProperty(q);\n}", "output": "assert queueToSeq(q) == rev;"}, {"id": "example_DequeueCorrect_11", "type": "assert", "program": "// Queue operations: enqueue, dequeue, isEmpty, size\n\ndatatype Queue<T> = Queue(front: seq<T>, rear: seq<T>)\n\nfunction {:spec} queueEmpty<T>(): Queue<T>\n{\n  Queue([], [])\n}\n\npredicate {:spec} queueIsEmpty<T>(q: Queue<T>)\n{\n  q.front == [] && q.rear == []\n}\n\nfunction {:spec} enqueue<T>(q: Queue<T>, x: T): Queue<T>\n{\n  Queue(q.front, [x] + q.rear)\n}\n\nfunction {:spec} dequeue<T>(q: Queue<T>): Queue<T>\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    Queue(q.front[1..], q.rear)\n  else\n    // Front is empty, so we reverse rear and put it in front\n    if |q.rear| == 1 then\n      Queue([], [])\n    else\n      Queue(reverse(q.rear)[1..], [])\n}\n\nfunction {:spec} queueFront<T>(q: Queue<T>): T\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    q.front[0]\n  else\n    // Front is empty, so the front element is the first element of rear (when reversed)\n    q.rear[|q.rear| - 1]\n}\n\nfunction {:spec} queueSize<T>(q: Queue<T>): nat\n{\n  |q.front| + |q.rear|\n}\n\nfunction {:spec} queueToSeq<T>(q: Queue<T>): seq<T>\n{\n  q.front + reverse(q.rear)\n}\n\nfunction reverse<T>(s: seq<T>): seq<T>\n{\n  if |s| == 0 then []\n  else reverse(s[1..]) + [s[0]]\n}\n\n// Alternative queue representation with invariant\ndatatype SimpleQueue<T> = SimpleQueue(elements: seq<T>)\n\nfunction {:spec} simpleQueueEmpty<T>(): SimpleQueue<T>\n{\n  SimpleQueue([])\n}\n\npredicate {:spec} simpleQueueIsEmpty<T>(q: SimpleQueue<T>)\n{\n  q.elements == []\n}\n\nfunction {:spec} simpleEnqueue<T>(q: SimpleQueue<T>, x: T): SimpleQueue<T>\n{\n  SimpleQueue(q.elements + [x])\n}\n\nfunction {:spec} simpleDequeue<T>(q: SimpleQueue<T>): SimpleQueue<T>\n  requires !simpleQueueIsEmpty(q)\n{\n  SimpleQueue(q.elements[1..])\n}\n\nfunction {:spec} simpleQueueFront<T>(q: SimpleQueue<T>): T\n  requires !simpleQueueIsEmpty(q)\n{\n  q.elements[0]\n}\n\nfunction {:spec} simpleQueueSize<T>(q: SimpleQueue<T>): nat\n{\n  |q.elements|\n}\n\nlemma ReverseLength<T>(s: seq<T>)\n  ensures |reverse(s)| == |s|\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseLength(s[1..]);\n    assert |reverse(s)| == |reverse(s[1..])| + 1;\n  }\n}\n\nlemma ReverseReverse<T>(s: seq<T>)\n  ensures reverse(reverse(s)) == s\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseReverse(s[1..]);\n    ReverseAppend(reverse(s[1..]), [s[0]]);\n    assert reverse(reverse(s)) == s;\n  }\n}\n\nlemma ReverseAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n  } else {\n    assert s1 + s2 == [s1[0]] + (s1[1..] + s2);\n    ReverseAppend(s1[1..], s2);\n  }\n}\n\nlemma ReverseFirst<T>(s: seq<T>)\n  requires |s| > 0\n  ensures |reverse(s)| == |s|\n  ensures reverse(s)[|reverse(s)| - 1] == s[0]\n  ensures reverse(s)[0] == s[|s| - 1]\n{\n  ReverseLength(s);\n  if |s| == 1 {\n    assert reverse(s) == [s[0]];\n  } else {\n    ReverseFirst(s[1..]);\n    assert reverse(s) == reverse(s[1..]) + [s[0]];\n    ReverseLength(s[1..]);\n    assert |reverse(s[1..])| == |s| - 1;\n  }\n}\n\nlemma SeqAssoc<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures a + (b + c) == (a + b) + c\n{\n  // Dafny proves this automatically\n}\n\nlemma QueueSizeProperty<T>(q: Queue<T>)\n  ensures queueSize(q) == |queueToSeq(q)|\n{\n  ReverseLength(q.rear);\n}\n\nlemma EnqueueCorrect<T>(q: Queue<T>, x: T)\n  ensures queueToSeq(enqueue(q, x)) == queueToSeq(q) + [x]\n  ensures queueSize(enqueue(q, x)) == queueSize(q) + 1\n{\n  var q' := enqueue(q, x);\n  assert q'.front == q.front;\n  assert q'.rear == [x] + q.rear;\n\n  ReverseAppend([x], q.rear);\n  assert reverse([x]) == [x];\n  assert reverse([x] + q.rear) == reverse(q.rear) + reverse([x]);\n  assert reverse([x] + q.rear) == reverse(q.rear) + [x];\n\n  calc == {\n    queueToSeq(q');\n    q'.front + reverse(q'.rear);\n    q.front + reverse([x] + q.rear);\n    q.front + (reverse(q.rear) + [x]);\n    { SeqAssoc(q.front, reverse(q.rear), [x]); }\n    (q.front + reverse(q.rear)) + [x];\n    queueToSeq(q) + [x];\n  }\n\n  QueueSizeProperty(q);\n  QueueSizeProperty(q');\n}\n\nlemma DequeueCorrect<T>(q: Queue<T>)\n  requires !queueIsEmpty(q)\n  ensures |queueToSeq(q)| > 0\n  ensures queueToSeq(dequeue(q)) == queueToSeq(q)[1..]\n  ensures queueFront(q) == queueToSeq(q)[0]\n{\n  if |q.front| > 0 {\n    assert queueToSeq(q) == q.front + reverse(q.rear);\n    assert queueToSeq(dequeue(q)) == q.front[1..] + reverse(q.rear);\n    assert queueFront(q) == q.front[0];\n  } else {\n    assert q.front == [];\n    assert |q.rear| > 0;\n    var rev := reverse(q.rear);\n    ReverseLength(q.rear);\n    \n/*[CODE HERE]*/\n    assert queueToSeq(q) == rev;\n    assert queueFront(q) == q.rear[|q.rear| - 1];\n\n    ReverseFirst(q.rear);\n    assert rev[0] == q.rear[|q.rear| - 1];\n\n    if |q.rear| == 1 {\n      assert rev == [q.rear[0]];\n      assert queueToSeq(q) == [q.rear[0]];\n      assert queueFront(q) == q.rear[0];\n      assert queueToSeq(q)[0] == q.rear[0];\n    } else {\n      assert |rev| > 1;\n      assert queueToSeq(dequeue(q)) == rev[1..];\n      assert queueFront(q) == rev[0];\n    }\n  }\n}\n\nlemma SimpleQueueEquivalence<T>(sq: SimpleQueue<T>, q: Queue<T>)\n  requires sq.elements == queueToSeq(q)\n  ensures simpleQueueIsEmpty(sq) == queueIsEmpty(q)\n  ensures simpleQueueSize(sq) == queueSize(q)\n{\n  if queueIsEmpty(q) {\n    assert q.front == [] && q.rear == [];\n    assert queueToSeq(q) == [];\n    assert sq.elements == [];\n  }\n  QueueSizeProperty(q);\n}", "output": "assert |rev| == |q.rear|;"}, {"id": "example_DequeueCorrect_12", "type": "call", "program": "// Queue operations: enqueue, dequeue, isEmpty, size\n\ndatatype Queue<T> = Queue(front: seq<T>, rear: seq<T>)\n\nfunction {:spec} queueEmpty<T>(): Queue<T>\n{\n  Queue([], [])\n}\n\npredicate {:spec} queueIsEmpty<T>(q: Queue<T>)\n{\n  q.front == [] && q.rear == []\n}\n\nfunction {:spec} enqueue<T>(q: Queue<T>, x: T): Queue<T>\n{\n  Queue(q.front, [x] + q.rear)\n}\n\nfunction {:spec} dequeue<T>(q: Queue<T>): Queue<T>\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    Queue(q.front[1..], q.rear)\n  else\n    // Front is empty, so we reverse rear and put it in front\n    if |q.rear| == 1 then\n      Queue([], [])\n    else\n      Queue(reverse(q.rear)[1..], [])\n}\n\nfunction {:spec} queueFront<T>(q: Queue<T>): T\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    q.front[0]\n  else\n    // Front is empty, so the front element is the first element of rear (when reversed)\n    q.rear[|q.rear| - 1]\n}\n\nfunction {:spec} queueSize<T>(q: Queue<T>): nat\n{\n  |q.front| + |q.rear|\n}\n\nfunction {:spec} queueToSeq<T>(q: Queue<T>): seq<T>\n{\n  q.front + reverse(q.rear)\n}\n\nfunction reverse<T>(s: seq<T>): seq<T>\n{\n  if |s| == 0 then []\n  else reverse(s[1..]) + [s[0]]\n}\n\n// Alternative queue representation with invariant\ndatatype SimpleQueue<T> = SimpleQueue(elements: seq<T>)\n\nfunction {:spec} simpleQueueEmpty<T>(): SimpleQueue<T>\n{\n  SimpleQueue([])\n}\n\npredicate {:spec} simpleQueueIsEmpty<T>(q: SimpleQueue<T>)\n{\n  q.elements == []\n}\n\nfunction {:spec} simpleEnqueue<T>(q: SimpleQueue<T>, x: T): SimpleQueue<T>\n{\n  SimpleQueue(q.elements + [x])\n}\n\nfunction {:spec} simpleDequeue<T>(q: SimpleQueue<T>): SimpleQueue<T>\n  requires !simpleQueueIsEmpty(q)\n{\n  SimpleQueue(q.elements[1..])\n}\n\nfunction {:spec} simpleQueueFront<T>(q: SimpleQueue<T>): T\n  requires !simpleQueueIsEmpty(q)\n{\n  q.elements[0]\n}\n\nfunction {:spec} simpleQueueSize<T>(q: SimpleQueue<T>): nat\n{\n  |q.elements|\n}\n\nlemma ReverseLength<T>(s: seq<T>)\n  ensures |reverse(s)| == |s|\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseLength(s[1..]);\n    assert |reverse(s)| == |reverse(s[1..])| + 1;\n  }\n}\n\nlemma ReverseReverse<T>(s: seq<T>)\n  ensures reverse(reverse(s)) == s\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseReverse(s[1..]);\n    ReverseAppend(reverse(s[1..]), [s[0]]);\n    assert reverse(reverse(s)) == s;\n  }\n}\n\nlemma ReverseAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n  } else {\n    assert s1 + s2 == [s1[0]] + (s1[1..] + s2);\n    ReverseAppend(s1[1..], s2);\n  }\n}\n\nlemma ReverseFirst<T>(s: seq<T>)\n  requires |s| > 0\n  ensures |reverse(s)| == |s|\n  ensures reverse(s)[|reverse(s)| - 1] == s[0]\n  ensures reverse(s)[0] == s[|s| - 1]\n{\n  ReverseLength(s);\n  if |s| == 1 {\n    assert reverse(s) == [s[0]];\n  } else {\n    ReverseFirst(s[1..]);\n    assert reverse(s) == reverse(s[1..]) + [s[0]];\n    ReverseLength(s[1..]);\n    assert |reverse(s[1..])| == |s| - 1;\n  }\n}\n\nlemma SeqAssoc<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures a + (b + c) == (a + b) + c\n{\n  // Dafny proves this automatically\n}\n\nlemma QueueSizeProperty<T>(q: Queue<T>)\n  ensures queueSize(q) == |queueToSeq(q)|\n{\n  ReverseLength(q.rear);\n}\n\nlemma EnqueueCorrect<T>(q: Queue<T>, x: T)\n  ensures queueToSeq(enqueue(q, x)) == queueToSeq(q) + [x]\n  ensures queueSize(enqueue(q, x)) == queueSize(q) + 1\n{\n  var q' := enqueue(q, x);\n  assert q'.front == q.front;\n  assert q'.rear == [x] + q.rear;\n\n  ReverseAppend([x], q.rear);\n  assert reverse([x]) == [x];\n  assert reverse([x] + q.rear) == reverse(q.rear) + reverse([x]);\n  assert reverse([x] + q.rear) == reverse(q.rear) + [x];\n\n  calc == {\n    queueToSeq(q');\n    q'.front + reverse(q'.rear);\n    q.front + reverse([x] + q.rear);\n    q.front + (reverse(q.rear) + [x]);\n    { SeqAssoc(q.front, reverse(q.rear), [x]); }\n    (q.front + reverse(q.rear)) + [x];\n    queueToSeq(q) + [x];\n  }\n\n  QueueSizeProperty(q);\n  QueueSizeProperty(q');\n}\n\nlemma DequeueCorrect<T>(q: Queue<T>)\n  requires !queueIsEmpty(q)\n  ensures |queueToSeq(q)| > 0\n  ensures queueToSeq(dequeue(q)) == queueToSeq(q)[1..]\n  ensures queueFront(q) == queueToSeq(q)[0]\n{\n  if |q.front| > 0 {\n    assert queueToSeq(q) == q.front + reverse(q.rear);\n    assert queueToSeq(dequeue(q)) == q.front[1..] + reverse(q.rear);\n    assert queueFront(q) == q.front[0];\n  } else {\n    assert q.front == [];\n    assert |q.rear| > 0;\n    var rev := reverse(q.rear);\n    \n/*[CODE HERE]*/\n    assert |rev| == |q.rear|;\n    assert queueToSeq(q) == rev;\n    assert queueFront(q) == q.rear[|q.rear| - 1];\n\n    ReverseFirst(q.rear);\n    assert rev[0] == q.rear[|q.rear| - 1];\n\n    if |q.rear| == 1 {\n      assert rev == [q.rear[0]];\n      assert queueToSeq(q) == [q.rear[0]];\n      assert queueFront(q) == q.rear[0];\n      assert queueToSeq(q)[0] == q.rear[0];\n    } else {\n      assert |rev| > 1;\n      assert queueToSeq(dequeue(q)) == rev[1..];\n      assert queueFront(q) == rev[0];\n    }\n  }\n}\n\nlemma SimpleQueueEquivalence<T>(sq: SimpleQueue<T>, q: Queue<T>)\n  requires sq.elements == queueToSeq(q)\n  ensures simpleQueueIsEmpty(sq) == queueIsEmpty(q)\n  ensures simpleQueueSize(sq) == queueSize(q)\n{\n  if queueIsEmpty(q) {\n    assert q.front == [] && q.rear == [];\n    assert queueToSeq(q) == [];\n    assert sq.elements == [];\n  }\n  QueueSizeProperty(q);\n}", "output": "ReverseLength(q.rear);"}, {"id": "example_DequeueCorrect_13", "type": "assert", "program": "// Queue operations: enqueue, dequeue, isEmpty, size\n\ndatatype Queue<T> = Queue(front: seq<T>, rear: seq<T>)\n\nfunction {:spec} queueEmpty<T>(): Queue<T>\n{\n  Queue([], [])\n}\n\npredicate {:spec} queueIsEmpty<T>(q: Queue<T>)\n{\n  q.front == [] && q.rear == []\n}\n\nfunction {:spec} enqueue<T>(q: Queue<T>, x: T): Queue<T>\n{\n  Queue(q.front, [x] + q.rear)\n}\n\nfunction {:spec} dequeue<T>(q: Queue<T>): Queue<T>\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    Queue(q.front[1..], q.rear)\n  else\n    // Front is empty, so we reverse rear and put it in front\n    if |q.rear| == 1 then\n      Queue([], [])\n    else\n      Queue(reverse(q.rear)[1..], [])\n}\n\nfunction {:spec} queueFront<T>(q: Queue<T>): T\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    q.front[0]\n  else\n    // Front is empty, so the front element is the first element of rear (when reversed)\n    q.rear[|q.rear| - 1]\n}\n\nfunction {:spec} queueSize<T>(q: Queue<T>): nat\n{\n  |q.front| + |q.rear|\n}\n\nfunction {:spec} queueToSeq<T>(q: Queue<T>): seq<T>\n{\n  q.front + reverse(q.rear)\n}\n\nfunction reverse<T>(s: seq<T>): seq<T>\n{\n  if |s| == 0 then []\n  else reverse(s[1..]) + [s[0]]\n}\n\n// Alternative queue representation with invariant\ndatatype SimpleQueue<T> = SimpleQueue(elements: seq<T>)\n\nfunction {:spec} simpleQueueEmpty<T>(): SimpleQueue<T>\n{\n  SimpleQueue([])\n}\n\npredicate {:spec} simpleQueueIsEmpty<T>(q: SimpleQueue<T>)\n{\n  q.elements == []\n}\n\nfunction {:spec} simpleEnqueue<T>(q: SimpleQueue<T>, x: T): SimpleQueue<T>\n{\n  SimpleQueue(q.elements + [x])\n}\n\nfunction {:spec} simpleDequeue<T>(q: SimpleQueue<T>): SimpleQueue<T>\n  requires !simpleQueueIsEmpty(q)\n{\n  SimpleQueue(q.elements[1..])\n}\n\nfunction {:spec} simpleQueueFront<T>(q: SimpleQueue<T>): T\n  requires !simpleQueueIsEmpty(q)\n{\n  q.elements[0]\n}\n\nfunction {:spec} simpleQueueSize<T>(q: SimpleQueue<T>): nat\n{\n  |q.elements|\n}\n\nlemma ReverseLength<T>(s: seq<T>)\n  ensures |reverse(s)| == |s|\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseLength(s[1..]);\n    assert |reverse(s)| == |reverse(s[1..])| + 1;\n  }\n}\n\nlemma ReverseReverse<T>(s: seq<T>)\n  ensures reverse(reverse(s)) == s\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseReverse(s[1..]);\n    ReverseAppend(reverse(s[1..]), [s[0]]);\n    assert reverse(reverse(s)) == s;\n  }\n}\n\nlemma ReverseAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n  } else {\n    assert s1 + s2 == [s1[0]] + (s1[1..] + s2);\n    ReverseAppend(s1[1..], s2);\n  }\n}\n\nlemma ReverseFirst<T>(s: seq<T>)\n  requires |s| > 0\n  ensures |reverse(s)| == |s|\n  ensures reverse(s)[|reverse(s)| - 1] == s[0]\n  ensures reverse(s)[0] == s[|s| - 1]\n{\n  ReverseLength(s);\n  if |s| == 1 {\n    assert reverse(s) == [s[0]];\n  } else {\n    ReverseFirst(s[1..]);\n    assert reverse(s) == reverse(s[1..]) + [s[0]];\n    ReverseLength(s[1..]);\n    assert |reverse(s[1..])| == |s| - 1;\n  }\n}\n\nlemma SeqAssoc<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures a + (b + c) == (a + b) + c\n{\n  // Dafny proves this automatically\n}\n\nlemma QueueSizeProperty<T>(q: Queue<T>)\n  ensures queueSize(q) == |queueToSeq(q)|\n{\n  ReverseLength(q.rear);\n}\n\nlemma EnqueueCorrect<T>(q: Queue<T>, x: T)\n  ensures queueToSeq(enqueue(q, x)) == queueToSeq(q) + [x]\n  ensures queueSize(enqueue(q, x)) == queueSize(q) + 1\n{\n  var q' := enqueue(q, x);\n  assert q'.front == q.front;\n  assert q'.rear == [x] + q.rear;\n\n  ReverseAppend([x], q.rear);\n  assert reverse([x]) == [x];\n  assert reverse([x] + q.rear) == reverse(q.rear) + reverse([x]);\n  assert reverse([x] + q.rear) == reverse(q.rear) + [x];\n\n  calc == {\n    queueToSeq(q');\n    q'.front + reverse(q'.rear);\n    q.front + reverse([x] + q.rear);\n    q.front + (reverse(q.rear) + [x]);\n    { SeqAssoc(q.front, reverse(q.rear), [x]); }\n    (q.front + reverse(q.rear)) + [x];\n    queueToSeq(q) + [x];\n  }\n\n  QueueSizeProperty(q);\n  QueueSizeProperty(q');\n}\n\nlemma DequeueCorrect<T>(q: Queue<T>)\n  requires !queueIsEmpty(q)\n  ensures |queueToSeq(q)| > 0\n  ensures queueToSeq(dequeue(q)) == queueToSeq(q)[1..]\n  ensures queueFront(q) == queueToSeq(q)[0]\n{\n  if |q.front| > 0 {\n    assert queueToSeq(q) == q.front + reverse(q.rear);\n    assert queueToSeq(dequeue(q)) == q.front[1..] + reverse(q.rear);\n    assert queueFront(q) == q.front[0];\n  } else {\n    assert q.front == [];\n    \n/*[CODE HERE]*/\n    var rev := reverse(q.rear);\n    ReverseLength(q.rear);\n    assert |rev| == |q.rear|;\n    assert queueToSeq(q) == rev;\n    assert queueFront(q) == q.rear[|q.rear| - 1];\n\n    ReverseFirst(q.rear);\n    assert rev[0] == q.rear[|q.rear| - 1];\n\n    if |q.rear| == 1 {\n      assert rev == [q.rear[0]];\n      assert queueToSeq(q) == [q.rear[0]];\n      assert queueFront(q) == q.rear[0];\n      assert queueToSeq(q)[0] == q.rear[0];\n    } else {\n      assert |rev| > 1;\n      assert queueToSeq(dequeue(q)) == rev[1..];\n      assert queueFront(q) == rev[0];\n    }\n  }\n}\n\nlemma SimpleQueueEquivalence<T>(sq: SimpleQueue<T>, q: Queue<T>)\n  requires sq.elements == queueToSeq(q)\n  ensures simpleQueueIsEmpty(sq) == queueIsEmpty(q)\n  ensures simpleQueueSize(sq) == queueSize(q)\n{\n  if queueIsEmpty(q) {\n    assert q.front == [] && q.rear == [];\n    assert queueToSeq(q) == [];\n    assert sq.elements == [];\n  }\n  QueueSizeProperty(q);\n}", "output": "assert |q.rear| > 0;"}, {"id": "example_DequeueCorrect_14", "type": "assert", "program": "// Queue operations: enqueue, dequeue, isEmpty, size\n\ndatatype Queue<T> = Queue(front: seq<T>, rear: seq<T>)\n\nfunction {:spec} queueEmpty<T>(): Queue<T>\n{\n  Queue([], [])\n}\n\npredicate {:spec} queueIsEmpty<T>(q: Queue<T>)\n{\n  q.front == [] && q.rear == []\n}\n\nfunction {:spec} enqueue<T>(q: Queue<T>, x: T): Queue<T>\n{\n  Queue(q.front, [x] + q.rear)\n}\n\nfunction {:spec} dequeue<T>(q: Queue<T>): Queue<T>\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    Queue(q.front[1..], q.rear)\n  else\n    // Front is empty, so we reverse rear and put it in front\n    if |q.rear| == 1 then\n      Queue([], [])\n    else\n      Queue(reverse(q.rear)[1..], [])\n}\n\nfunction {:spec} queueFront<T>(q: Queue<T>): T\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    q.front[0]\n  else\n    // Front is empty, so the front element is the first element of rear (when reversed)\n    q.rear[|q.rear| - 1]\n}\n\nfunction {:spec} queueSize<T>(q: Queue<T>): nat\n{\n  |q.front| + |q.rear|\n}\n\nfunction {:spec} queueToSeq<T>(q: Queue<T>): seq<T>\n{\n  q.front + reverse(q.rear)\n}\n\nfunction reverse<T>(s: seq<T>): seq<T>\n{\n  if |s| == 0 then []\n  else reverse(s[1..]) + [s[0]]\n}\n\n// Alternative queue representation with invariant\ndatatype SimpleQueue<T> = SimpleQueue(elements: seq<T>)\n\nfunction {:spec} simpleQueueEmpty<T>(): SimpleQueue<T>\n{\n  SimpleQueue([])\n}\n\npredicate {:spec} simpleQueueIsEmpty<T>(q: SimpleQueue<T>)\n{\n  q.elements == []\n}\n\nfunction {:spec} simpleEnqueue<T>(q: SimpleQueue<T>, x: T): SimpleQueue<T>\n{\n  SimpleQueue(q.elements + [x])\n}\n\nfunction {:spec} simpleDequeue<T>(q: SimpleQueue<T>): SimpleQueue<T>\n  requires !simpleQueueIsEmpty(q)\n{\n  SimpleQueue(q.elements[1..])\n}\n\nfunction {:spec} simpleQueueFront<T>(q: SimpleQueue<T>): T\n  requires !simpleQueueIsEmpty(q)\n{\n  q.elements[0]\n}\n\nfunction {:spec} simpleQueueSize<T>(q: SimpleQueue<T>): nat\n{\n  |q.elements|\n}\n\nlemma ReverseLength<T>(s: seq<T>)\n  ensures |reverse(s)| == |s|\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseLength(s[1..]);\n    assert |reverse(s)| == |reverse(s[1..])| + 1;\n  }\n}\n\nlemma ReverseReverse<T>(s: seq<T>)\n  ensures reverse(reverse(s)) == s\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseReverse(s[1..]);\n    ReverseAppend(reverse(s[1..]), [s[0]]);\n    assert reverse(reverse(s)) == s;\n  }\n}\n\nlemma ReverseAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n  } else {\n    assert s1 + s2 == [s1[0]] + (s1[1..] + s2);\n    ReverseAppend(s1[1..], s2);\n  }\n}\n\nlemma ReverseFirst<T>(s: seq<T>)\n  requires |s| > 0\n  ensures |reverse(s)| == |s|\n  ensures reverse(s)[|reverse(s)| - 1] == s[0]\n  ensures reverse(s)[0] == s[|s| - 1]\n{\n  ReverseLength(s);\n  if |s| == 1 {\n    assert reverse(s) == [s[0]];\n  } else {\n    ReverseFirst(s[1..]);\n    assert reverse(s) == reverse(s[1..]) + [s[0]];\n    ReverseLength(s[1..]);\n    assert |reverse(s[1..])| == |s| - 1;\n  }\n}\n\nlemma SeqAssoc<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures a + (b + c) == (a + b) + c\n{\n  // Dafny proves this automatically\n}\n\nlemma QueueSizeProperty<T>(q: Queue<T>)\n  ensures queueSize(q) == |queueToSeq(q)|\n{\n  ReverseLength(q.rear);\n}\n\nlemma EnqueueCorrect<T>(q: Queue<T>, x: T)\n  ensures queueToSeq(enqueue(q, x)) == queueToSeq(q) + [x]\n  ensures queueSize(enqueue(q, x)) == queueSize(q) + 1\n{\n  var q' := enqueue(q, x);\n  assert q'.front == q.front;\n  assert q'.rear == [x] + q.rear;\n\n  ReverseAppend([x], q.rear);\n  assert reverse([x]) == [x];\n  assert reverse([x] + q.rear) == reverse(q.rear) + reverse([x]);\n  assert reverse([x] + q.rear) == reverse(q.rear) + [x];\n\n  calc == {\n    queueToSeq(q');\n    q'.front + reverse(q'.rear);\n    q.front + reverse([x] + q.rear);\n    q.front + (reverse(q.rear) + [x]);\n    { SeqAssoc(q.front, reverse(q.rear), [x]); }\n    (q.front + reverse(q.rear)) + [x];\n    queueToSeq(q) + [x];\n  }\n\n  QueueSizeProperty(q);\n  QueueSizeProperty(q');\n}\n\nlemma DequeueCorrect<T>(q: Queue<T>)\n  requires !queueIsEmpty(q)\n  ensures |queueToSeq(q)| > 0\n  ensures queueToSeq(dequeue(q)) == queueToSeq(q)[1..]\n  ensures queueFront(q) == queueToSeq(q)[0]\n{\n  if |q.front| > 0 {\n    assert queueToSeq(q) == q.front + reverse(q.rear);\n    assert queueToSeq(dequeue(q)) == q.front[1..] + reverse(q.rear);\n    assert queueFront(q) == q.front[0];\n  } else {\n    \n/*[CODE HERE]*/\n    assert |q.rear| > 0;\n    var rev := reverse(q.rear);\n    ReverseLength(q.rear);\n    assert |rev| == |q.rear|;\n    assert queueToSeq(q) == rev;\n    assert queueFront(q) == q.rear[|q.rear| - 1];\n\n    ReverseFirst(q.rear);\n    assert rev[0] == q.rear[|q.rear| - 1];\n\n    if |q.rear| == 1 {\n      assert rev == [q.rear[0]];\n      assert queueToSeq(q) == [q.rear[0]];\n      assert queueFront(q) == q.rear[0];\n      assert queueToSeq(q)[0] == q.rear[0];\n    } else {\n      assert |rev| > 1;\n      assert queueToSeq(dequeue(q)) == rev[1..];\n      assert queueFront(q) == rev[0];\n    }\n  }\n}\n\nlemma SimpleQueueEquivalence<T>(sq: SimpleQueue<T>, q: Queue<T>)\n  requires sq.elements == queueToSeq(q)\n  ensures simpleQueueIsEmpty(sq) == queueIsEmpty(q)\n  ensures simpleQueueSize(sq) == queueSize(q)\n{\n  if queueIsEmpty(q) {\n    assert q.front == [] && q.rear == [];\n    assert queueToSeq(q) == [];\n    assert sq.elements == [];\n  }\n  QueueSizeProperty(q);\n}", "output": "assert q.front == [];"}, {"id": "example_DequeueCorrect_15", "type": "assert", "program": "// Queue operations: enqueue, dequeue, isEmpty, size\n\ndatatype Queue<T> = Queue(front: seq<T>, rear: seq<T>)\n\nfunction {:spec} queueEmpty<T>(): Queue<T>\n{\n  Queue([], [])\n}\n\npredicate {:spec} queueIsEmpty<T>(q: Queue<T>)\n{\n  q.front == [] && q.rear == []\n}\n\nfunction {:spec} enqueue<T>(q: Queue<T>, x: T): Queue<T>\n{\n  Queue(q.front, [x] + q.rear)\n}\n\nfunction {:spec} dequeue<T>(q: Queue<T>): Queue<T>\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    Queue(q.front[1..], q.rear)\n  else\n    // Front is empty, so we reverse rear and put it in front\n    if |q.rear| == 1 then\n      Queue([], [])\n    else\n      Queue(reverse(q.rear)[1..], [])\n}\n\nfunction {:spec} queueFront<T>(q: Queue<T>): T\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    q.front[0]\n  else\n    // Front is empty, so the front element is the first element of rear (when reversed)\n    q.rear[|q.rear| - 1]\n}\n\nfunction {:spec} queueSize<T>(q: Queue<T>): nat\n{\n  |q.front| + |q.rear|\n}\n\nfunction {:spec} queueToSeq<T>(q: Queue<T>): seq<T>\n{\n  q.front + reverse(q.rear)\n}\n\nfunction reverse<T>(s: seq<T>): seq<T>\n{\n  if |s| == 0 then []\n  else reverse(s[1..]) + [s[0]]\n}\n\n// Alternative queue representation with invariant\ndatatype SimpleQueue<T> = SimpleQueue(elements: seq<T>)\n\nfunction {:spec} simpleQueueEmpty<T>(): SimpleQueue<T>\n{\n  SimpleQueue([])\n}\n\npredicate {:spec} simpleQueueIsEmpty<T>(q: SimpleQueue<T>)\n{\n  q.elements == []\n}\n\nfunction {:spec} simpleEnqueue<T>(q: SimpleQueue<T>, x: T): SimpleQueue<T>\n{\n  SimpleQueue(q.elements + [x])\n}\n\nfunction {:spec} simpleDequeue<T>(q: SimpleQueue<T>): SimpleQueue<T>\n  requires !simpleQueueIsEmpty(q)\n{\n  SimpleQueue(q.elements[1..])\n}\n\nfunction {:spec} simpleQueueFront<T>(q: SimpleQueue<T>): T\n  requires !simpleQueueIsEmpty(q)\n{\n  q.elements[0]\n}\n\nfunction {:spec} simpleQueueSize<T>(q: SimpleQueue<T>): nat\n{\n  |q.elements|\n}\n\nlemma ReverseLength<T>(s: seq<T>)\n  ensures |reverse(s)| == |s|\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseLength(s[1..]);\n    assert |reverse(s)| == |reverse(s[1..])| + 1;\n  }\n}\n\nlemma ReverseReverse<T>(s: seq<T>)\n  ensures reverse(reverse(s)) == s\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseReverse(s[1..]);\n    ReverseAppend(reverse(s[1..]), [s[0]]);\n    assert reverse(reverse(s)) == s;\n  }\n}\n\nlemma ReverseAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n  } else {\n    assert s1 + s2 == [s1[0]] + (s1[1..] + s2);\n    ReverseAppend(s1[1..], s2);\n  }\n}\n\nlemma ReverseFirst<T>(s: seq<T>)\n  requires |s| > 0\n  ensures |reverse(s)| == |s|\n  ensures reverse(s)[|reverse(s)| - 1] == s[0]\n  ensures reverse(s)[0] == s[|s| - 1]\n{\n  ReverseLength(s);\n  if |s| == 1 {\n    assert reverse(s) == [s[0]];\n  } else {\n    ReverseFirst(s[1..]);\n    assert reverse(s) == reverse(s[1..]) + [s[0]];\n    ReverseLength(s[1..]);\n    assert |reverse(s[1..])| == |s| - 1;\n  }\n}\n\nlemma SeqAssoc<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures a + (b + c) == (a + b) + c\n{\n  // Dafny proves this automatically\n}\n\nlemma QueueSizeProperty<T>(q: Queue<T>)\n  ensures queueSize(q) == |queueToSeq(q)|\n{\n  ReverseLength(q.rear);\n}\n\nlemma EnqueueCorrect<T>(q: Queue<T>, x: T)\n  ensures queueToSeq(enqueue(q, x)) == queueToSeq(q) + [x]\n  ensures queueSize(enqueue(q, x)) == queueSize(q) + 1\n{\n  var q' := enqueue(q, x);\n  assert q'.front == q.front;\n  assert q'.rear == [x] + q.rear;\n\n  ReverseAppend([x], q.rear);\n  assert reverse([x]) == [x];\n  assert reverse([x] + q.rear) == reverse(q.rear) + reverse([x]);\n  assert reverse([x] + q.rear) == reverse(q.rear) + [x];\n\n  calc == {\n    queueToSeq(q');\n    q'.front + reverse(q'.rear);\n    q.front + reverse([x] + q.rear);\n    q.front + (reverse(q.rear) + [x]);\n    { SeqAssoc(q.front, reverse(q.rear), [x]); }\n    (q.front + reverse(q.rear)) + [x];\n    queueToSeq(q) + [x];\n  }\n\n  QueueSizeProperty(q);\n  QueueSizeProperty(q');\n}\n\nlemma DequeueCorrect<T>(q: Queue<T>)\n  requires !queueIsEmpty(q)\n  ensures |queueToSeq(q)| > 0\n  ensures queueToSeq(dequeue(q)) == queueToSeq(q)[1..]\n  ensures queueFront(q) == queueToSeq(q)[0]\n{\n  if |q.front| > 0 {\n    assert queueToSeq(q) == q.front + reverse(q.rear);\n    assert queueToSeq(dequeue(q)) == q.front[1..] + reverse(q.rear);\n    \n/*[CODE HERE]*/\n  } else {\n    assert q.front == [];\n    assert |q.rear| > 0;\n    var rev := reverse(q.rear);\n    ReverseLength(q.rear);\n    assert |rev| == |q.rear|;\n    assert queueToSeq(q) == rev;\n    assert queueFront(q) == q.rear[|q.rear| - 1];\n\n    ReverseFirst(q.rear);\n    assert rev[0] == q.rear[|q.rear| - 1];\n\n    if |q.rear| == 1 {\n      assert rev == [q.rear[0]];\n      assert queueToSeq(q) == [q.rear[0]];\n      assert queueFront(q) == q.rear[0];\n      assert queueToSeq(q)[0] == q.rear[0];\n    } else {\n      assert |rev| > 1;\n      assert queueToSeq(dequeue(q)) == rev[1..];\n      assert queueFront(q) == rev[0];\n    }\n  }\n}\n\nlemma SimpleQueueEquivalence<T>(sq: SimpleQueue<T>, q: Queue<T>)\n  requires sq.elements == queueToSeq(q)\n  ensures simpleQueueIsEmpty(sq) == queueIsEmpty(q)\n  ensures simpleQueueSize(sq) == queueSize(q)\n{\n  if queueIsEmpty(q) {\n    assert q.front == [] && q.rear == [];\n    assert queueToSeq(q) == [];\n    assert sq.elements == [];\n  }\n  QueueSizeProperty(q);\n}", "output": "assert queueFront(q) == q.front[0];"}, {"id": "example_DequeueCorrect_16", "type": "assert", "program": "// Queue operations: enqueue, dequeue, isEmpty, size\n\ndatatype Queue<T> = Queue(front: seq<T>, rear: seq<T>)\n\nfunction {:spec} queueEmpty<T>(): Queue<T>\n{\n  Queue([], [])\n}\n\npredicate {:spec} queueIsEmpty<T>(q: Queue<T>)\n{\n  q.front == [] && q.rear == []\n}\n\nfunction {:spec} enqueue<T>(q: Queue<T>, x: T): Queue<T>\n{\n  Queue(q.front, [x] + q.rear)\n}\n\nfunction {:spec} dequeue<T>(q: Queue<T>): Queue<T>\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    Queue(q.front[1..], q.rear)\n  else\n    // Front is empty, so we reverse rear and put it in front\n    if |q.rear| == 1 then\n      Queue([], [])\n    else\n      Queue(reverse(q.rear)[1..], [])\n}\n\nfunction {:spec} queueFront<T>(q: Queue<T>): T\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    q.front[0]\n  else\n    // Front is empty, so the front element is the first element of rear (when reversed)\n    q.rear[|q.rear| - 1]\n}\n\nfunction {:spec} queueSize<T>(q: Queue<T>): nat\n{\n  |q.front| + |q.rear|\n}\n\nfunction {:spec} queueToSeq<T>(q: Queue<T>): seq<T>\n{\n  q.front + reverse(q.rear)\n}\n\nfunction reverse<T>(s: seq<T>): seq<T>\n{\n  if |s| == 0 then []\n  else reverse(s[1..]) + [s[0]]\n}\n\n// Alternative queue representation with invariant\ndatatype SimpleQueue<T> = SimpleQueue(elements: seq<T>)\n\nfunction {:spec} simpleQueueEmpty<T>(): SimpleQueue<T>\n{\n  SimpleQueue([])\n}\n\npredicate {:spec} simpleQueueIsEmpty<T>(q: SimpleQueue<T>)\n{\n  q.elements == []\n}\n\nfunction {:spec} simpleEnqueue<T>(q: SimpleQueue<T>, x: T): SimpleQueue<T>\n{\n  SimpleQueue(q.elements + [x])\n}\n\nfunction {:spec} simpleDequeue<T>(q: SimpleQueue<T>): SimpleQueue<T>\n  requires !simpleQueueIsEmpty(q)\n{\n  SimpleQueue(q.elements[1..])\n}\n\nfunction {:spec} simpleQueueFront<T>(q: SimpleQueue<T>): T\n  requires !simpleQueueIsEmpty(q)\n{\n  q.elements[0]\n}\n\nfunction {:spec} simpleQueueSize<T>(q: SimpleQueue<T>): nat\n{\n  |q.elements|\n}\n\nlemma ReverseLength<T>(s: seq<T>)\n  ensures |reverse(s)| == |s|\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseLength(s[1..]);\n    assert |reverse(s)| == |reverse(s[1..])| + 1;\n  }\n}\n\nlemma ReverseReverse<T>(s: seq<T>)\n  ensures reverse(reverse(s)) == s\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseReverse(s[1..]);\n    ReverseAppend(reverse(s[1..]), [s[0]]);\n    assert reverse(reverse(s)) == s;\n  }\n}\n\nlemma ReverseAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n  } else {\n    assert s1 + s2 == [s1[0]] + (s1[1..] + s2);\n    ReverseAppend(s1[1..], s2);\n  }\n}\n\nlemma ReverseFirst<T>(s: seq<T>)\n  requires |s| > 0\n  ensures |reverse(s)| == |s|\n  ensures reverse(s)[|reverse(s)| - 1] == s[0]\n  ensures reverse(s)[0] == s[|s| - 1]\n{\n  ReverseLength(s);\n  if |s| == 1 {\n    assert reverse(s) == [s[0]];\n  } else {\n    ReverseFirst(s[1..]);\n    assert reverse(s) == reverse(s[1..]) + [s[0]];\n    ReverseLength(s[1..]);\n    assert |reverse(s[1..])| == |s| - 1;\n  }\n}\n\nlemma SeqAssoc<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures a + (b + c) == (a + b) + c\n{\n  // Dafny proves this automatically\n}\n\nlemma QueueSizeProperty<T>(q: Queue<T>)\n  ensures queueSize(q) == |queueToSeq(q)|\n{\n  ReverseLength(q.rear);\n}\n\nlemma EnqueueCorrect<T>(q: Queue<T>, x: T)\n  ensures queueToSeq(enqueue(q, x)) == queueToSeq(q) + [x]\n  ensures queueSize(enqueue(q, x)) == queueSize(q) + 1\n{\n  var q' := enqueue(q, x);\n  assert q'.front == q.front;\n  assert q'.rear == [x] + q.rear;\n\n  ReverseAppend([x], q.rear);\n  assert reverse([x]) == [x];\n  assert reverse([x] + q.rear) == reverse(q.rear) + reverse([x]);\n  assert reverse([x] + q.rear) == reverse(q.rear) + [x];\n\n  calc == {\n    queueToSeq(q');\n    q'.front + reverse(q'.rear);\n    q.front + reverse([x] + q.rear);\n    q.front + (reverse(q.rear) + [x]);\n    { SeqAssoc(q.front, reverse(q.rear), [x]); }\n    (q.front + reverse(q.rear)) + [x];\n    queueToSeq(q) + [x];\n  }\n\n  QueueSizeProperty(q);\n  QueueSizeProperty(q');\n}\n\nlemma DequeueCorrect<T>(q: Queue<T>)\n  requires !queueIsEmpty(q)\n  ensures |queueToSeq(q)| > 0\n  ensures queueToSeq(dequeue(q)) == queueToSeq(q)[1..]\n  ensures queueFront(q) == queueToSeq(q)[0]\n{\n  if |q.front| > 0 {\n    assert queueToSeq(q) == q.front + reverse(q.rear);\n    \n/*[CODE HERE]*/\n    assert queueFront(q) == q.front[0];\n  } else {\n    assert q.front == [];\n    assert |q.rear| > 0;\n    var rev := reverse(q.rear);\n    ReverseLength(q.rear);\n    assert |rev| == |q.rear|;\n    assert queueToSeq(q) == rev;\n    assert queueFront(q) == q.rear[|q.rear| - 1];\n\n    ReverseFirst(q.rear);\n    assert rev[0] == q.rear[|q.rear| - 1];\n\n    if |q.rear| == 1 {\n      assert rev == [q.rear[0]];\n      assert queueToSeq(q) == [q.rear[0]];\n      assert queueFront(q) == q.rear[0];\n      assert queueToSeq(q)[0] == q.rear[0];\n    } else {\n      assert |rev| > 1;\n      assert queueToSeq(dequeue(q)) == rev[1..];\n      assert queueFront(q) == rev[0];\n    }\n  }\n}\n\nlemma SimpleQueueEquivalence<T>(sq: SimpleQueue<T>, q: Queue<T>)\n  requires sq.elements == queueToSeq(q)\n  ensures simpleQueueIsEmpty(sq) == queueIsEmpty(q)\n  ensures simpleQueueSize(sq) == queueSize(q)\n{\n  if queueIsEmpty(q) {\n    assert q.front == [] && q.rear == [];\n    assert queueToSeq(q) == [];\n    assert sq.elements == [];\n  }\n  QueueSizeProperty(q);\n}", "output": "assert queueToSeq(dequeue(q)) == q.front[1..] + reverse(q.rear);"}, {"id": "example_DequeueCorrect_17", "type": "assert", "program": "// Queue operations: enqueue, dequeue, isEmpty, size\n\ndatatype Queue<T> = Queue(front: seq<T>, rear: seq<T>)\n\nfunction {:spec} queueEmpty<T>(): Queue<T>\n{\n  Queue([], [])\n}\n\npredicate {:spec} queueIsEmpty<T>(q: Queue<T>)\n{\n  q.front == [] && q.rear == []\n}\n\nfunction {:spec} enqueue<T>(q: Queue<T>, x: T): Queue<T>\n{\n  Queue(q.front, [x] + q.rear)\n}\n\nfunction {:spec} dequeue<T>(q: Queue<T>): Queue<T>\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    Queue(q.front[1..], q.rear)\n  else\n    // Front is empty, so we reverse rear and put it in front\n    if |q.rear| == 1 then\n      Queue([], [])\n    else\n      Queue(reverse(q.rear)[1..], [])\n}\n\nfunction {:spec} queueFront<T>(q: Queue<T>): T\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    q.front[0]\n  else\n    // Front is empty, so the front element is the first element of rear (when reversed)\n    q.rear[|q.rear| - 1]\n}\n\nfunction {:spec} queueSize<T>(q: Queue<T>): nat\n{\n  |q.front| + |q.rear|\n}\n\nfunction {:spec} queueToSeq<T>(q: Queue<T>): seq<T>\n{\n  q.front + reverse(q.rear)\n}\n\nfunction reverse<T>(s: seq<T>): seq<T>\n{\n  if |s| == 0 then []\n  else reverse(s[1..]) + [s[0]]\n}\n\n// Alternative queue representation with invariant\ndatatype SimpleQueue<T> = SimpleQueue(elements: seq<T>)\n\nfunction {:spec} simpleQueueEmpty<T>(): SimpleQueue<T>\n{\n  SimpleQueue([])\n}\n\npredicate {:spec} simpleQueueIsEmpty<T>(q: SimpleQueue<T>)\n{\n  q.elements == []\n}\n\nfunction {:spec} simpleEnqueue<T>(q: SimpleQueue<T>, x: T): SimpleQueue<T>\n{\n  SimpleQueue(q.elements + [x])\n}\n\nfunction {:spec} simpleDequeue<T>(q: SimpleQueue<T>): SimpleQueue<T>\n  requires !simpleQueueIsEmpty(q)\n{\n  SimpleQueue(q.elements[1..])\n}\n\nfunction {:spec} simpleQueueFront<T>(q: SimpleQueue<T>): T\n  requires !simpleQueueIsEmpty(q)\n{\n  q.elements[0]\n}\n\nfunction {:spec} simpleQueueSize<T>(q: SimpleQueue<T>): nat\n{\n  |q.elements|\n}\n\nlemma ReverseLength<T>(s: seq<T>)\n  ensures |reverse(s)| == |s|\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseLength(s[1..]);\n    assert |reverse(s)| == |reverse(s[1..])| + 1;\n  }\n}\n\nlemma ReverseReverse<T>(s: seq<T>)\n  ensures reverse(reverse(s)) == s\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseReverse(s[1..]);\n    ReverseAppend(reverse(s[1..]), [s[0]]);\n    assert reverse(reverse(s)) == s;\n  }\n}\n\nlemma ReverseAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n  } else {\n    assert s1 + s2 == [s1[0]] + (s1[1..] + s2);\n    ReverseAppend(s1[1..], s2);\n  }\n}\n\nlemma ReverseFirst<T>(s: seq<T>)\n  requires |s| > 0\n  ensures |reverse(s)| == |s|\n  ensures reverse(s)[|reverse(s)| - 1] == s[0]\n  ensures reverse(s)[0] == s[|s| - 1]\n{\n  ReverseLength(s);\n  if |s| == 1 {\n    assert reverse(s) == [s[0]];\n  } else {\n    ReverseFirst(s[1..]);\n    assert reverse(s) == reverse(s[1..]) + [s[0]];\n    ReverseLength(s[1..]);\n    assert |reverse(s[1..])| == |s| - 1;\n  }\n}\n\nlemma SeqAssoc<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures a + (b + c) == (a + b) + c\n{\n  // Dafny proves this automatically\n}\n\nlemma QueueSizeProperty<T>(q: Queue<T>)\n  ensures queueSize(q) == |queueToSeq(q)|\n{\n  ReverseLength(q.rear);\n}\n\nlemma EnqueueCorrect<T>(q: Queue<T>, x: T)\n  ensures queueToSeq(enqueue(q, x)) == queueToSeq(q) + [x]\n  ensures queueSize(enqueue(q, x)) == queueSize(q) + 1\n{\n  var q' := enqueue(q, x);\n  assert q'.front == q.front;\n  assert q'.rear == [x] + q.rear;\n\n  ReverseAppend([x], q.rear);\n  assert reverse([x]) == [x];\n  assert reverse([x] + q.rear) == reverse(q.rear) + reverse([x]);\n  assert reverse([x] + q.rear) == reverse(q.rear) + [x];\n\n  calc == {\n    queueToSeq(q');\n    q'.front + reverse(q'.rear);\n    q.front + reverse([x] + q.rear);\n    q.front + (reverse(q.rear) + [x]);\n    { SeqAssoc(q.front, reverse(q.rear), [x]); }\n    (q.front + reverse(q.rear)) + [x];\n    queueToSeq(q) + [x];\n  }\n\n  QueueSizeProperty(q);\n  QueueSizeProperty(q');\n}\n\nlemma DequeueCorrect<T>(q: Queue<T>)\n  requires !queueIsEmpty(q)\n  ensures |queueToSeq(q)| > 0\n  ensures queueToSeq(dequeue(q)) == queueToSeq(q)[1..]\n  ensures queueFront(q) == queueToSeq(q)[0]\n{\n  if |q.front| > 0 {\n    \n/*[CODE HERE]*/\n    assert queueToSeq(dequeue(q)) == q.front[1..] + reverse(q.rear);\n    assert queueFront(q) == q.front[0];\n  } else {\n    assert q.front == [];\n    assert |q.rear| > 0;\n    var rev := reverse(q.rear);\n    ReverseLength(q.rear);\n    assert |rev| == |q.rear|;\n    assert queueToSeq(q) == rev;\n    assert queueFront(q) == q.rear[|q.rear| - 1];\n\n    ReverseFirst(q.rear);\n    assert rev[0] == q.rear[|q.rear| - 1];\n\n    if |q.rear| == 1 {\n      assert rev == [q.rear[0]];\n      assert queueToSeq(q) == [q.rear[0]];\n      assert queueFront(q) == q.rear[0];\n      assert queueToSeq(q)[0] == q.rear[0];\n    } else {\n      assert |rev| > 1;\n      assert queueToSeq(dequeue(q)) == rev[1..];\n      assert queueFront(q) == rev[0];\n    }\n  }\n}\n\nlemma SimpleQueueEquivalence<T>(sq: SimpleQueue<T>, q: Queue<T>)\n  requires sq.elements == queueToSeq(q)\n  ensures simpleQueueIsEmpty(sq) == queueIsEmpty(q)\n  ensures simpleQueueSize(sq) == queueSize(q)\n{\n  if queueIsEmpty(q) {\n    assert q.front == [] && q.rear == [];\n    assert queueToSeq(q) == [];\n    assert sq.elements == [];\n  }\n  QueueSizeProperty(q);\n}", "output": "assert queueToSeq(q) == q.front + reverse(q.rear);"}, {"id": "example_SimpleQueueEquivalence_0", "type": "call", "program": "// Queue operations: enqueue, dequeue, isEmpty, size\n\ndatatype Queue<T> = Queue(front: seq<T>, rear: seq<T>)\n\nfunction {:spec} queueEmpty<T>(): Queue<T>\n{\n  Queue([], [])\n}\n\npredicate {:spec} queueIsEmpty<T>(q: Queue<T>)\n{\n  q.front == [] && q.rear == []\n}\n\nfunction {:spec} enqueue<T>(q: Queue<T>, x: T): Queue<T>\n{\n  Queue(q.front, [x] + q.rear)\n}\n\nfunction {:spec} dequeue<T>(q: Queue<T>): Queue<T>\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    Queue(q.front[1..], q.rear)\n  else\n    // Front is empty, so we reverse rear and put it in front\n    if |q.rear| == 1 then\n      Queue([], [])\n    else\n      Queue(reverse(q.rear)[1..], [])\n}\n\nfunction {:spec} queueFront<T>(q: Queue<T>): T\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    q.front[0]\n  else\n    // Front is empty, so the front element is the first element of rear (when reversed)\n    q.rear[|q.rear| - 1]\n}\n\nfunction {:spec} queueSize<T>(q: Queue<T>): nat\n{\n  |q.front| + |q.rear|\n}\n\nfunction {:spec} queueToSeq<T>(q: Queue<T>): seq<T>\n{\n  q.front + reverse(q.rear)\n}\n\nfunction reverse<T>(s: seq<T>): seq<T>\n{\n  if |s| == 0 then []\n  else reverse(s[1..]) + [s[0]]\n}\n\n// Alternative queue representation with invariant\ndatatype SimpleQueue<T> = SimpleQueue(elements: seq<T>)\n\nfunction {:spec} simpleQueueEmpty<T>(): SimpleQueue<T>\n{\n  SimpleQueue([])\n}\n\npredicate {:spec} simpleQueueIsEmpty<T>(q: SimpleQueue<T>)\n{\n  q.elements == []\n}\n\nfunction {:spec} simpleEnqueue<T>(q: SimpleQueue<T>, x: T): SimpleQueue<T>\n{\n  SimpleQueue(q.elements + [x])\n}\n\nfunction {:spec} simpleDequeue<T>(q: SimpleQueue<T>): SimpleQueue<T>\n  requires !simpleQueueIsEmpty(q)\n{\n  SimpleQueue(q.elements[1..])\n}\n\nfunction {:spec} simpleQueueFront<T>(q: SimpleQueue<T>): T\n  requires !simpleQueueIsEmpty(q)\n{\n  q.elements[0]\n}\n\nfunction {:spec} simpleQueueSize<T>(q: SimpleQueue<T>): nat\n{\n  |q.elements|\n}\n\nlemma ReverseLength<T>(s: seq<T>)\n  ensures |reverse(s)| == |s|\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseLength(s[1..]);\n    assert |reverse(s)| == |reverse(s[1..])| + 1;\n  }\n}\n\nlemma ReverseReverse<T>(s: seq<T>)\n  ensures reverse(reverse(s)) == s\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseReverse(s[1..]);\n    ReverseAppend(reverse(s[1..]), [s[0]]);\n    assert reverse(reverse(s)) == s;\n  }\n}\n\nlemma ReverseAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n  } else {\n    assert s1 + s2 == [s1[0]] + (s1[1..] + s2);\n    ReverseAppend(s1[1..], s2);\n  }\n}\n\nlemma ReverseFirst<T>(s: seq<T>)\n  requires |s| > 0\n  ensures |reverse(s)| == |s|\n  ensures reverse(s)[|reverse(s)| - 1] == s[0]\n  ensures reverse(s)[0] == s[|s| - 1]\n{\n  ReverseLength(s);\n  if |s| == 1 {\n    assert reverse(s) == [s[0]];\n  } else {\n    ReverseFirst(s[1..]);\n    assert reverse(s) == reverse(s[1..]) + [s[0]];\n    ReverseLength(s[1..]);\n    assert |reverse(s[1..])| == |s| - 1;\n  }\n}\n\nlemma SeqAssoc<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures a + (b + c) == (a + b) + c\n{\n  // Dafny proves this automatically\n}\n\nlemma QueueSizeProperty<T>(q: Queue<T>)\n  ensures queueSize(q) == |queueToSeq(q)|\n{\n  ReverseLength(q.rear);\n}\n\nlemma EnqueueCorrect<T>(q: Queue<T>, x: T)\n  ensures queueToSeq(enqueue(q, x)) == queueToSeq(q) + [x]\n  ensures queueSize(enqueue(q, x)) == queueSize(q) + 1\n{\n  var q' := enqueue(q, x);\n  assert q'.front == q.front;\n  assert q'.rear == [x] + q.rear;\n\n  ReverseAppend([x], q.rear);\n  assert reverse([x]) == [x];\n  assert reverse([x] + q.rear) == reverse(q.rear) + reverse([x]);\n  assert reverse([x] + q.rear) == reverse(q.rear) + [x];\n\n  calc == {\n    queueToSeq(q');\n    q'.front + reverse(q'.rear);\n    q.front + reverse([x] + q.rear);\n    q.front + (reverse(q.rear) + [x]);\n    { SeqAssoc(q.front, reverse(q.rear), [x]); }\n    (q.front + reverse(q.rear)) + [x];\n    queueToSeq(q) + [x];\n  }\n\n  QueueSizeProperty(q);\n  QueueSizeProperty(q');\n}\n\nlemma DequeueCorrect<T>(q: Queue<T>)\n  requires !queueIsEmpty(q)\n  ensures |queueToSeq(q)| > 0\n  ensures queueToSeq(dequeue(q)) == queueToSeq(q)[1..]\n  ensures queueFront(q) == queueToSeq(q)[0]\n{\n  if |q.front| > 0 {\n    assert queueToSeq(q) == q.front + reverse(q.rear);\n    assert queueToSeq(dequeue(q)) == q.front[1..] + reverse(q.rear);\n    assert queueFront(q) == q.front[0];\n  } else {\n    assert q.front == [];\n    assert |q.rear| > 0;\n    var rev := reverse(q.rear);\n    ReverseLength(q.rear);\n    assert |rev| == |q.rear|;\n    assert queueToSeq(q) == rev;\n    assert queueFront(q) == q.rear[|q.rear| - 1];\n\n    ReverseFirst(q.rear);\n    assert rev[0] == q.rear[|q.rear| - 1];\n\n    if |q.rear| == 1 {\n      assert rev == [q.rear[0]];\n      assert queueToSeq(q) == [q.rear[0]];\n      assert queueFront(q) == q.rear[0];\n      assert queueToSeq(q)[0] == q.rear[0];\n    } else {\n      assert |rev| > 1;\n      assert queueToSeq(dequeue(q)) == rev[1..];\n      assert queueFront(q) == rev[0];\n    }\n  }\n}\n\nlemma SimpleQueueEquivalence<T>(sq: SimpleQueue<T>, q: Queue<T>)\n  requires sq.elements == queueToSeq(q)\n  ensures simpleQueueIsEmpty(sq) == queueIsEmpty(q)\n  ensures simpleQueueSize(sq) == queueSize(q)\n{\n  if queueIsEmpty(q) {\n    assert q.front == [] && q.rear == [];\n    assert queueToSeq(q) == [];\n    assert sq.elements == [];\n  }\n  \n/*[CODE HERE]*/\n}", "output": "QueueSizeProperty(q);"}, {"id": "example_SimpleQueueEquivalence_1", "type": "assert", "program": "// Queue operations: enqueue, dequeue, isEmpty, size\n\ndatatype Queue<T> = Queue(front: seq<T>, rear: seq<T>)\n\nfunction {:spec} queueEmpty<T>(): Queue<T>\n{\n  Queue([], [])\n}\n\npredicate {:spec} queueIsEmpty<T>(q: Queue<T>)\n{\n  q.front == [] && q.rear == []\n}\n\nfunction {:spec} enqueue<T>(q: Queue<T>, x: T): Queue<T>\n{\n  Queue(q.front, [x] + q.rear)\n}\n\nfunction {:spec} dequeue<T>(q: Queue<T>): Queue<T>\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    Queue(q.front[1..], q.rear)\n  else\n    // Front is empty, so we reverse rear and put it in front\n    if |q.rear| == 1 then\n      Queue([], [])\n    else\n      Queue(reverse(q.rear)[1..], [])\n}\n\nfunction {:spec} queueFront<T>(q: Queue<T>): T\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    q.front[0]\n  else\n    // Front is empty, so the front element is the first element of rear (when reversed)\n    q.rear[|q.rear| - 1]\n}\n\nfunction {:spec} queueSize<T>(q: Queue<T>): nat\n{\n  |q.front| + |q.rear|\n}\n\nfunction {:spec} queueToSeq<T>(q: Queue<T>): seq<T>\n{\n  q.front + reverse(q.rear)\n}\n\nfunction reverse<T>(s: seq<T>): seq<T>\n{\n  if |s| == 0 then []\n  else reverse(s[1..]) + [s[0]]\n}\n\n// Alternative queue representation with invariant\ndatatype SimpleQueue<T> = SimpleQueue(elements: seq<T>)\n\nfunction {:spec} simpleQueueEmpty<T>(): SimpleQueue<T>\n{\n  SimpleQueue([])\n}\n\npredicate {:spec} simpleQueueIsEmpty<T>(q: SimpleQueue<T>)\n{\n  q.elements == []\n}\n\nfunction {:spec} simpleEnqueue<T>(q: SimpleQueue<T>, x: T): SimpleQueue<T>\n{\n  SimpleQueue(q.elements + [x])\n}\n\nfunction {:spec} simpleDequeue<T>(q: SimpleQueue<T>): SimpleQueue<T>\n  requires !simpleQueueIsEmpty(q)\n{\n  SimpleQueue(q.elements[1..])\n}\n\nfunction {:spec} simpleQueueFront<T>(q: SimpleQueue<T>): T\n  requires !simpleQueueIsEmpty(q)\n{\n  q.elements[0]\n}\n\nfunction {:spec} simpleQueueSize<T>(q: SimpleQueue<T>): nat\n{\n  |q.elements|\n}\n\nlemma ReverseLength<T>(s: seq<T>)\n  ensures |reverse(s)| == |s|\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseLength(s[1..]);\n    assert |reverse(s)| == |reverse(s[1..])| + 1;\n  }\n}\n\nlemma ReverseReverse<T>(s: seq<T>)\n  ensures reverse(reverse(s)) == s\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseReverse(s[1..]);\n    ReverseAppend(reverse(s[1..]), [s[0]]);\n    assert reverse(reverse(s)) == s;\n  }\n}\n\nlemma ReverseAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n  } else {\n    assert s1 + s2 == [s1[0]] + (s1[1..] + s2);\n    ReverseAppend(s1[1..], s2);\n  }\n}\n\nlemma ReverseFirst<T>(s: seq<T>)\n  requires |s| > 0\n  ensures |reverse(s)| == |s|\n  ensures reverse(s)[|reverse(s)| - 1] == s[0]\n  ensures reverse(s)[0] == s[|s| - 1]\n{\n  ReverseLength(s);\n  if |s| == 1 {\n    assert reverse(s) == [s[0]];\n  } else {\n    ReverseFirst(s[1..]);\n    assert reverse(s) == reverse(s[1..]) + [s[0]];\n    ReverseLength(s[1..]);\n    assert |reverse(s[1..])| == |s| - 1;\n  }\n}\n\nlemma SeqAssoc<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures a + (b + c) == (a + b) + c\n{\n  // Dafny proves this automatically\n}\n\nlemma QueueSizeProperty<T>(q: Queue<T>)\n  ensures queueSize(q) == |queueToSeq(q)|\n{\n  ReverseLength(q.rear);\n}\n\nlemma EnqueueCorrect<T>(q: Queue<T>, x: T)\n  ensures queueToSeq(enqueue(q, x)) == queueToSeq(q) + [x]\n  ensures queueSize(enqueue(q, x)) == queueSize(q) + 1\n{\n  var q' := enqueue(q, x);\n  assert q'.front == q.front;\n  assert q'.rear == [x] + q.rear;\n\n  ReverseAppend([x], q.rear);\n  assert reverse([x]) == [x];\n  assert reverse([x] + q.rear) == reverse(q.rear) + reverse([x]);\n  assert reverse([x] + q.rear) == reverse(q.rear) + [x];\n\n  calc == {\n    queueToSeq(q');\n    q'.front + reverse(q'.rear);\n    q.front + reverse([x] + q.rear);\n    q.front + (reverse(q.rear) + [x]);\n    { SeqAssoc(q.front, reverse(q.rear), [x]); }\n    (q.front + reverse(q.rear)) + [x];\n    queueToSeq(q) + [x];\n  }\n\n  QueueSizeProperty(q);\n  QueueSizeProperty(q');\n}\n\nlemma DequeueCorrect<T>(q: Queue<T>)\n  requires !queueIsEmpty(q)\n  ensures |queueToSeq(q)| > 0\n  ensures queueToSeq(dequeue(q)) == queueToSeq(q)[1..]\n  ensures queueFront(q) == queueToSeq(q)[0]\n{\n  if |q.front| > 0 {\n    assert queueToSeq(q) == q.front + reverse(q.rear);\n    assert queueToSeq(dequeue(q)) == q.front[1..] + reverse(q.rear);\n    assert queueFront(q) == q.front[0];\n  } else {\n    assert q.front == [];\n    assert |q.rear| > 0;\n    var rev := reverse(q.rear);\n    ReverseLength(q.rear);\n    assert |rev| == |q.rear|;\n    assert queueToSeq(q) == rev;\n    assert queueFront(q) == q.rear[|q.rear| - 1];\n\n    ReverseFirst(q.rear);\n    assert rev[0] == q.rear[|q.rear| - 1];\n\n    if |q.rear| == 1 {\n      assert rev == [q.rear[0]];\n      assert queueToSeq(q) == [q.rear[0]];\n      assert queueFront(q) == q.rear[0];\n      assert queueToSeq(q)[0] == q.rear[0];\n    } else {\n      assert |rev| > 1;\n      assert queueToSeq(dequeue(q)) == rev[1..];\n      assert queueFront(q) == rev[0];\n    }\n  }\n}\n\nlemma SimpleQueueEquivalence<T>(sq: SimpleQueue<T>, q: Queue<T>)\n  requires sq.elements == queueToSeq(q)\n  ensures simpleQueueIsEmpty(sq) == queueIsEmpty(q)\n  ensures simpleQueueSize(sq) == queueSize(q)\n{\n  if queueIsEmpty(q) {\n    assert q.front == [] && q.rear == [];\n    assert queueToSeq(q) == [];\n    \n/*[CODE HERE]*/\n  }\n  QueueSizeProperty(q);\n}", "output": "assert sq.elements == [];"}, {"id": "example_SimpleQueueEquivalence_2", "type": "assert", "program": "// Queue operations: enqueue, dequeue, isEmpty, size\n\ndatatype Queue<T> = Queue(front: seq<T>, rear: seq<T>)\n\nfunction {:spec} queueEmpty<T>(): Queue<T>\n{\n  Queue([], [])\n}\n\npredicate {:spec} queueIsEmpty<T>(q: Queue<T>)\n{\n  q.front == [] && q.rear == []\n}\n\nfunction {:spec} enqueue<T>(q: Queue<T>, x: T): Queue<T>\n{\n  Queue(q.front, [x] + q.rear)\n}\n\nfunction {:spec} dequeue<T>(q: Queue<T>): Queue<T>\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    Queue(q.front[1..], q.rear)\n  else\n    // Front is empty, so we reverse rear and put it in front\n    if |q.rear| == 1 then\n      Queue([], [])\n    else\n      Queue(reverse(q.rear)[1..], [])\n}\n\nfunction {:spec} queueFront<T>(q: Queue<T>): T\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    q.front[0]\n  else\n    // Front is empty, so the front element is the first element of rear (when reversed)\n    q.rear[|q.rear| - 1]\n}\n\nfunction {:spec} queueSize<T>(q: Queue<T>): nat\n{\n  |q.front| + |q.rear|\n}\n\nfunction {:spec} queueToSeq<T>(q: Queue<T>): seq<T>\n{\n  q.front + reverse(q.rear)\n}\n\nfunction reverse<T>(s: seq<T>): seq<T>\n{\n  if |s| == 0 then []\n  else reverse(s[1..]) + [s[0]]\n}\n\n// Alternative queue representation with invariant\ndatatype SimpleQueue<T> = SimpleQueue(elements: seq<T>)\n\nfunction {:spec} simpleQueueEmpty<T>(): SimpleQueue<T>\n{\n  SimpleQueue([])\n}\n\npredicate {:spec} simpleQueueIsEmpty<T>(q: SimpleQueue<T>)\n{\n  q.elements == []\n}\n\nfunction {:spec} simpleEnqueue<T>(q: SimpleQueue<T>, x: T): SimpleQueue<T>\n{\n  SimpleQueue(q.elements + [x])\n}\n\nfunction {:spec} simpleDequeue<T>(q: SimpleQueue<T>): SimpleQueue<T>\n  requires !simpleQueueIsEmpty(q)\n{\n  SimpleQueue(q.elements[1..])\n}\n\nfunction {:spec} simpleQueueFront<T>(q: SimpleQueue<T>): T\n  requires !simpleQueueIsEmpty(q)\n{\n  q.elements[0]\n}\n\nfunction {:spec} simpleQueueSize<T>(q: SimpleQueue<T>): nat\n{\n  |q.elements|\n}\n\nlemma ReverseLength<T>(s: seq<T>)\n  ensures |reverse(s)| == |s|\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseLength(s[1..]);\n    assert |reverse(s)| == |reverse(s[1..])| + 1;\n  }\n}\n\nlemma ReverseReverse<T>(s: seq<T>)\n  ensures reverse(reverse(s)) == s\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseReverse(s[1..]);\n    ReverseAppend(reverse(s[1..]), [s[0]]);\n    assert reverse(reverse(s)) == s;\n  }\n}\n\nlemma ReverseAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n  } else {\n    assert s1 + s2 == [s1[0]] + (s1[1..] + s2);\n    ReverseAppend(s1[1..], s2);\n  }\n}\n\nlemma ReverseFirst<T>(s: seq<T>)\n  requires |s| > 0\n  ensures |reverse(s)| == |s|\n  ensures reverse(s)[|reverse(s)| - 1] == s[0]\n  ensures reverse(s)[0] == s[|s| - 1]\n{\n  ReverseLength(s);\n  if |s| == 1 {\n    assert reverse(s) == [s[0]];\n  } else {\n    ReverseFirst(s[1..]);\n    assert reverse(s) == reverse(s[1..]) + [s[0]];\n    ReverseLength(s[1..]);\n    assert |reverse(s[1..])| == |s| - 1;\n  }\n}\n\nlemma SeqAssoc<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures a + (b + c) == (a + b) + c\n{\n  // Dafny proves this automatically\n}\n\nlemma QueueSizeProperty<T>(q: Queue<T>)\n  ensures queueSize(q) == |queueToSeq(q)|\n{\n  ReverseLength(q.rear);\n}\n\nlemma EnqueueCorrect<T>(q: Queue<T>, x: T)\n  ensures queueToSeq(enqueue(q, x)) == queueToSeq(q) + [x]\n  ensures queueSize(enqueue(q, x)) == queueSize(q) + 1\n{\n  var q' := enqueue(q, x);\n  assert q'.front == q.front;\n  assert q'.rear == [x] + q.rear;\n\n  ReverseAppend([x], q.rear);\n  assert reverse([x]) == [x];\n  assert reverse([x] + q.rear) == reverse(q.rear) + reverse([x]);\n  assert reverse([x] + q.rear) == reverse(q.rear) + [x];\n\n  calc == {\n    queueToSeq(q');\n    q'.front + reverse(q'.rear);\n    q.front + reverse([x] + q.rear);\n    q.front + (reverse(q.rear) + [x]);\n    { SeqAssoc(q.front, reverse(q.rear), [x]); }\n    (q.front + reverse(q.rear)) + [x];\n    queueToSeq(q) + [x];\n  }\n\n  QueueSizeProperty(q);\n  QueueSizeProperty(q');\n}\n\nlemma DequeueCorrect<T>(q: Queue<T>)\n  requires !queueIsEmpty(q)\n  ensures |queueToSeq(q)| > 0\n  ensures queueToSeq(dequeue(q)) == queueToSeq(q)[1..]\n  ensures queueFront(q) == queueToSeq(q)[0]\n{\n  if |q.front| > 0 {\n    assert queueToSeq(q) == q.front + reverse(q.rear);\n    assert queueToSeq(dequeue(q)) == q.front[1..] + reverse(q.rear);\n    assert queueFront(q) == q.front[0];\n  } else {\n    assert q.front == [];\n    assert |q.rear| > 0;\n    var rev := reverse(q.rear);\n    ReverseLength(q.rear);\n    assert |rev| == |q.rear|;\n    assert queueToSeq(q) == rev;\n    assert queueFront(q) == q.rear[|q.rear| - 1];\n\n    ReverseFirst(q.rear);\n    assert rev[0] == q.rear[|q.rear| - 1];\n\n    if |q.rear| == 1 {\n      assert rev == [q.rear[0]];\n      assert queueToSeq(q) == [q.rear[0]];\n      assert queueFront(q) == q.rear[0];\n      assert queueToSeq(q)[0] == q.rear[0];\n    } else {\n      assert |rev| > 1;\n      assert queueToSeq(dequeue(q)) == rev[1..];\n      assert queueFront(q) == rev[0];\n    }\n  }\n}\n\nlemma SimpleQueueEquivalence<T>(sq: SimpleQueue<T>, q: Queue<T>)\n  requires sq.elements == queueToSeq(q)\n  ensures simpleQueueIsEmpty(sq) == queueIsEmpty(q)\n  ensures simpleQueueSize(sq) == queueSize(q)\n{\n  if queueIsEmpty(q) {\n    assert q.front == [] && q.rear == [];\n    \n/*[CODE HERE]*/\n    assert sq.elements == [];\n  }\n  QueueSizeProperty(q);\n}", "output": "assert queueToSeq(q) == [];"}, {"id": "example_SimpleQueueEquivalence_3", "type": "assert", "program": "// Queue operations: enqueue, dequeue, isEmpty, size\n\ndatatype Queue<T> = Queue(front: seq<T>, rear: seq<T>)\n\nfunction {:spec} queueEmpty<T>(): Queue<T>\n{\n  Queue([], [])\n}\n\npredicate {:spec} queueIsEmpty<T>(q: Queue<T>)\n{\n  q.front == [] && q.rear == []\n}\n\nfunction {:spec} enqueue<T>(q: Queue<T>, x: T): Queue<T>\n{\n  Queue(q.front, [x] + q.rear)\n}\n\nfunction {:spec} dequeue<T>(q: Queue<T>): Queue<T>\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    Queue(q.front[1..], q.rear)\n  else\n    // Front is empty, so we reverse rear and put it in front\n    if |q.rear| == 1 then\n      Queue([], [])\n    else\n      Queue(reverse(q.rear)[1..], [])\n}\n\nfunction {:spec} queueFront<T>(q: Queue<T>): T\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    q.front[0]\n  else\n    // Front is empty, so the front element is the first element of rear (when reversed)\n    q.rear[|q.rear| - 1]\n}\n\nfunction {:spec} queueSize<T>(q: Queue<T>): nat\n{\n  |q.front| + |q.rear|\n}\n\nfunction {:spec} queueToSeq<T>(q: Queue<T>): seq<T>\n{\n  q.front + reverse(q.rear)\n}\n\nfunction reverse<T>(s: seq<T>): seq<T>\n{\n  if |s| == 0 then []\n  else reverse(s[1..]) + [s[0]]\n}\n\n// Alternative queue representation with invariant\ndatatype SimpleQueue<T> = SimpleQueue(elements: seq<T>)\n\nfunction {:spec} simpleQueueEmpty<T>(): SimpleQueue<T>\n{\n  SimpleQueue([])\n}\n\npredicate {:spec} simpleQueueIsEmpty<T>(q: SimpleQueue<T>)\n{\n  q.elements == []\n}\n\nfunction {:spec} simpleEnqueue<T>(q: SimpleQueue<T>, x: T): SimpleQueue<T>\n{\n  SimpleQueue(q.elements + [x])\n}\n\nfunction {:spec} simpleDequeue<T>(q: SimpleQueue<T>): SimpleQueue<T>\n  requires !simpleQueueIsEmpty(q)\n{\n  SimpleQueue(q.elements[1..])\n}\n\nfunction {:spec} simpleQueueFront<T>(q: SimpleQueue<T>): T\n  requires !simpleQueueIsEmpty(q)\n{\n  q.elements[0]\n}\n\nfunction {:spec} simpleQueueSize<T>(q: SimpleQueue<T>): nat\n{\n  |q.elements|\n}\n\nlemma ReverseLength<T>(s: seq<T>)\n  ensures |reverse(s)| == |s|\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseLength(s[1..]);\n    assert |reverse(s)| == |reverse(s[1..])| + 1;\n  }\n}\n\nlemma ReverseReverse<T>(s: seq<T>)\n  ensures reverse(reverse(s)) == s\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseReverse(s[1..]);\n    ReverseAppend(reverse(s[1..]), [s[0]]);\n    assert reverse(reverse(s)) == s;\n  }\n}\n\nlemma ReverseAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n  } else {\n    assert s1 + s2 == [s1[0]] + (s1[1..] + s2);\n    ReverseAppend(s1[1..], s2);\n  }\n}\n\nlemma ReverseFirst<T>(s: seq<T>)\n  requires |s| > 0\n  ensures |reverse(s)| == |s|\n  ensures reverse(s)[|reverse(s)| - 1] == s[0]\n  ensures reverse(s)[0] == s[|s| - 1]\n{\n  ReverseLength(s);\n  if |s| == 1 {\n    assert reverse(s) == [s[0]];\n  } else {\n    ReverseFirst(s[1..]);\n    assert reverse(s) == reverse(s[1..]) + [s[0]];\n    ReverseLength(s[1..]);\n    assert |reverse(s[1..])| == |s| - 1;\n  }\n}\n\nlemma SeqAssoc<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures a + (b + c) == (a + b) + c\n{\n  // Dafny proves this automatically\n}\n\nlemma QueueSizeProperty<T>(q: Queue<T>)\n  ensures queueSize(q) == |queueToSeq(q)|\n{\n  ReverseLength(q.rear);\n}\n\nlemma EnqueueCorrect<T>(q: Queue<T>, x: T)\n  ensures queueToSeq(enqueue(q, x)) == queueToSeq(q) + [x]\n  ensures queueSize(enqueue(q, x)) == queueSize(q) + 1\n{\n  var q' := enqueue(q, x);\n  assert q'.front == q.front;\n  assert q'.rear == [x] + q.rear;\n\n  ReverseAppend([x], q.rear);\n  assert reverse([x]) == [x];\n  assert reverse([x] + q.rear) == reverse(q.rear) + reverse([x]);\n  assert reverse([x] + q.rear) == reverse(q.rear) + [x];\n\n  calc == {\n    queueToSeq(q');\n    q'.front + reverse(q'.rear);\n    q.front + reverse([x] + q.rear);\n    q.front + (reverse(q.rear) + [x]);\n    { SeqAssoc(q.front, reverse(q.rear), [x]); }\n    (q.front + reverse(q.rear)) + [x];\n    queueToSeq(q) + [x];\n  }\n\n  QueueSizeProperty(q);\n  QueueSizeProperty(q');\n}\n\nlemma DequeueCorrect<T>(q: Queue<T>)\n  requires !queueIsEmpty(q)\n  ensures |queueToSeq(q)| > 0\n  ensures queueToSeq(dequeue(q)) == queueToSeq(q)[1..]\n  ensures queueFront(q) == queueToSeq(q)[0]\n{\n  if |q.front| > 0 {\n    assert queueToSeq(q) == q.front + reverse(q.rear);\n    assert queueToSeq(dequeue(q)) == q.front[1..] + reverse(q.rear);\n    assert queueFront(q) == q.front[0];\n  } else {\n    assert q.front == [];\n    assert |q.rear| > 0;\n    var rev := reverse(q.rear);\n    ReverseLength(q.rear);\n    assert |rev| == |q.rear|;\n    assert queueToSeq(q) == rev;\n    assert queueFront(q) == q.rear[|q.rear| - 1];\n\n    ReverseFirst(q.rear);\n    assert rev[0] == q.rear[|q.rear| - 1];\n\n    if |q.rear| == 1 {\n      assert rev == [q.rear[0]];\n      assert queueToSeq(q) == [q.rear[0]];\n      assert queueFront(q) == q.rear[0];\n      assert queueToSeq(q)[0] == q.rear[0];\n    } else {\n      assert |rev| > 1;\n      assert queueToSeq(dequeue(q)) == rev[1..];\n      assert queueFront(q) == rev[0];\n    }\n  }\n}\n\nlemma SimpleQueueEquivalence<T>(sq: SimpleQueue<T>, q: Queue<T>)\n  requires sq.elements == queueToSeq(q)\n  ensures simpleQueueIsEmpty(sq) == queueIsEmpty(q)\n  ensures simpleQueueSize(sq) == queueSize(q)\n{\n  if queueIsEmpty(q) {\n    \n/*[CODE HERE]*/\n    assert queueToSeq(q) == [];\n    assert sq.elements == [];\n  }\n  QueueSizeProperty(q);\n}", "output": "assert q.front == [] && q.rear == [];"}, {"id": "example_repeat_correct_0", "type": "assert", "program": "function repeat(x: int, n: nat): seq<int>\n{\n  if n == 0 then []\n  else [x] + repeat(x, n - 1)\n}\n\nlemma repeat_correct(x: int, n: nat)\n  ensures |repeat(x, n)| == n\n  ensures forall i :: 0 <= i < n ==> repeat(x, n)[i] == x\n{\n  if n == 0 {\n  } else {\n    repeat_correct(x, n - 1);\n    assert repeat(x, n) == [x] + repeat(x, n - 1);\n    assert |repeat(x, n)| == 1 + |repeat(x, n - 1)| == 1 + (n - 1) == n;\n    forall i | 0 <= i < n\n      ensures repeat(x, n)[i] == x\n    {\n      if i == 0 {\n        assert repeat(x, n)[0] == x;\n      } else {\n        \n/*[CODE HERE]*/\n      }\n    }\n  }\n}", "output": "assert repeat(x, n)[i] == repeat(x, n - 1)[i - 1] == x;"}, {"id": "example_repeat_correct_1", "type": "assert", "program": "function repeat(x: int, n: nat): seq<int>\n{\n  if n == 0 then []\n  else [x] + repeat(x, n - 1)\n}\n\nlemma repeat_correct(x: int, n: nat)\n  ensures |repeat(x, n)| == n\n  ensures forall i :: 0 <= i < n ==> repeat(x, n)[i] == x\n{\n  if n == 0 {\n  } else {\n    repeat_correct(x, n - 1);\n    assert repeat(x, n) == [x] + repeat(x, n - 1);\n    assert |repeat(x, n)| == 1 + |repeat(x, n - 1)| == 1 + (n - 1) == n;\n    forall i | 0 <= i < n\n      ensures repeat(x, n)[i] == x\n    {\n      if i == 0 {\n        \n/*[CODE HERE]*/\n      } else {\n        assert repeat(x, n)[i] == repeat(x, n - 1)[i - 1] == x;\n      }\n    }\n  }\n}", "output": "assert repeat(x, n)[0] == x;"}, {"id": "example_repeat_correct_2", "type": "assert", "program": "function repeat(x: int, n: nat): seq<int>\n{\n  if n == 0 then []\n  else [x] + repeat(x, n - 1)\n}\n\nlemma repeat_correct(x: int, n: nat)\n  ensures |repeat(x, n)| == n\n  ensures forall i :: 0 <= i < n ==> repeat(x, n)[i] == x\n{\n  if n == 0 {\n  } else {\n    repeat_correct(x, n - 1);\n    assert repeat(x, n) == [x] + repeat(x, n - 1);\n    \n/*[CODE HERE]*/\n    forall i | 0 <= i < n\n      ensures repeat(x, n)[i] == x\n    {\n      if i == 0 {\n        assert repeat(x, n)[0] == x;\n      } else {\n        assert repeat(x, n)[i] == repeat(x, n - 1)[i - 1] == x;\n      }\n    }\n  }\n}", "output": "assert |repeat(x, n)| == 1 + |repeat(x, n - 1)| == 1 + (n - 1) == n;"}, {"id": "example_repeat_correct_3", "type": "assert", "program": "function repeat(x: int, n: nat): seq<int>\n{\n  if n == 0 then []\n  else [x] + repeat(x, n - 1)\n}\n\nlemma repeat_correct(x: int, n: nat)\n  ensures |repeat(x, n)| == n\n  ensures forall i :: 0 <= i < n ==> repeat(x, n)[i] == x\n{\n  if n == 0 {\n  } else {\n    repeat_correct(x, n - 1);\n    \n/*[CODE HERE]*/\n    assert |repeat(x, n)| == 1 + |repeat(x, n - 1)| == 1 + (n - 1) == n;\n    forall i | 0 <= i < n\n      ensures repeat(x, n)[i] == x\n    {\n      if i == 0 {\n        assert repeat(x, n)[0] == x;\n      } else {\n        assert repeat(x, n)[i] == repeat(x, n - 1)[i - 1] == x;\n      }\n    }\n  }\n}", "output": "assert repeat(x, n) == [x] + repeat(x, n - 1);"}, {"id": "example_repeat_correct_4", "type": "call", "program": "function repeat(x: int, n: nat): seq<int>\n{\n  if n == 0 then []\n  else [x] + repeat(x, n - 1)\n}\n\nlemma repeat_correct(x: int, n: nat)\n  ensures |repeat(x, n)| == n\n  ensures forall i :: 0 <= i < n ==> repeat(x, n)[i] == x\n{\n  if n == 0 {\n  } else {\n    \n/*[CODE HERE]*/\n    assert repeat(x, n) == [x] + repeat(x, n - 1);\n    assert |repeat(x, n)| == 1 + |repeat(x, n - 1)| == 1 + (n - 1) == n;\n    forall i | 0 <= i < n\n      ensures repeat(x, n)[i] == x\n    {\n      if i == 0 {\n        assert repeat(x, n)[0] == x;\n      } else {\n        assert repeat(x, n)[i] == repeat(x, n - 1)[i - 1] == x;\n      }\n    }\n  }\n}", "output": "repeat_correct(x, n - 1);"}, {"id": "example_reverse_permutes_0", "type": "assert", "program": "function reverse<T>(l: seq<T>): seq<T>\n{\n  if |l| == 0 then []\n  else reverse(l[1..]) + [l[0]]\n}\n\nlemma reverse_permutes<T>(l: seq<T>)\n  ensures forall x :: x in l <==> x in reverse(l)\n{\n  if |l| == 0 {\n  } else {\n    reverse_permutes(l[1..]);\n    forall x\n      ensures x in l <==> x in reverse(l)\n    {\n      if x == l[0] {\n        assert x in reverse(l);\n      } else {\n        assert x in l <==> x in l[1..];\n        assert x in l[1..] <==> x in reverse(l[1..]);\n        \n/*[CODE HERE]*/\n      }\n    }\n  }\n}\n\nlemma reverse_append<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n    assert reverse(s2) + [] == reverse(s2);\n  } else {\n    assert s1 == [s1[0]] + s1[1..];\n    assert s1 + s2 == ([s1[0]] + s1[1..]) + s2 == [s1[0]] + (s1[1..] + s2);\n    \n    calc {\n      reverse(s1 + s2);\n      == reverse([s1[0]] + (s1[1..] + s2));\n      == reverse((s1[1..] + s2)) + [s1[0]];\n      == { reverse_append(s1[1..], s2); }\n      (reverse(s2) + reverse(s1[1..])) + [s1[0]];\n      == { assert (reverse(s2) + reverse(s1[1..])) + [s1[0]] == \n           reverse(s2) + (reverse(s1[1..]) + [s1[0]]); }\n      reverse(s2) + (reverse(s1[1..]) + [s1[0]]);\n      == reverse(s2) + reverse(s1);\n    }\n  }\n}\n\nlemma reverse_involutes<T>(l: seq<T>)\n  ensures reverse(reverse(l)) == l\n{\n  if |l| == 0 {\n  } else {\n    calc {\n      reverse(reverse(l));\n      == reverse(reverse(l[1..]) + [l[0]]);\n      == { reverse_append(reverse(l[1..]), [l[0]]); }\n      reverse([l[0]]) + reverse(reverse(l[1..]));\n      == [l[0]] + reverse(reverse(l[1..]));\n      == { reverse_involutes(l[1..]); }\n      [l[0]] + l[1..];\n      == l;\n    }\n  }\n}", "output": "assert x in reverse(l[1..]) ==> x in reverse(l[1..]) + [l[0]];"}, {"id": "example_reverse_permutes_1", "type": "assert", "program": "function reverse<T>(l: seq<T>): seq<T>\n{\n  if |l| == 0 then []\n  else reverse(l[1..]) + [l[0]]\n}\n\nlemma reverse_permutes<T>(l: seq<T>)\n  ensures forall x :: x in l <==> x in reverse(l)\n{\n  if |l| == 0 {\n  } else {\n    reverse_permutes(l[1..]);\n    forall x\n      ensures x in l <==> x in reverse(l)\n    {\n      if x == l[0] {\n        assert x in reverse(l);\n      } else {\n        assert x in l <==> x in l[1..];\n        \n/*[CODE HERE]*/\n        assert x in reverse(l[1..]) ==> x in reverse(l[1..]) + [l[0]];\n      }\n    }\n  }\n}\n\nlemma reverse_append<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n    assert reverse(s2) + [] == reverse(s2);\n  } else {\n    assert s1 == [s1[0]] + s1[1..];\n    assert s1 + s2 == ([s1[0]] + s1[1..]) + s2 == [s1[0]] + (s1[1..] + s2);\n    \n    calc {\n      reverse(s1 + s2);\n      == reverse([s1[0]] + (s1[1..] + s2));\n      == reverse((s1[1..] + s2)) + [s1[0]];\n      == { reverse_append(s1[1..], s2); }\n      (reverse(s2) + reverse(s1[1..])) + [s1[0]];\n      == { assert (reverse(s2) + reverse(s1[1..])) + [s1[0]] == \n           reverse(s2) + (reverse(s1[1..]) + [s1[0]]); }\n      reverse(s2) + (reverse(s1[1..]) + [s1[0]]);\n      == reverse(s2) + reverse(s1);\n    }\n  }\n}\n\nlemma reverse_involutes<T>(l: seq<T>)\n  ensures reverse(reverse(l)) == l\n{\n  if |l| == 0 {\n  } else {\n    calc {\n      reverse(reverse(l));\n      == reverse(reverse(l[1..]) + [l[0]]);\n      == { reverse_append(reverse(l[1..]), [l[0]]); }\n      reverse([l[0]]) + reverse(reverse(l[1..]));\n      == [l[0]] + reverse(reverse(l[1..]));\n      == { reverse_involutes(l[1..]); }\n      [l[0]] + l[1..];\n      == l;\n    }\n  }\n}", "output": "assert x in l[1..] <==> x in reverse(l[1..]);"}, {"id": "example_reverse_permutes_2", "type": "assert", "program": "function reverse<T>(l: seq<T>): seq<T>\n{\n  if |l| == 0 then []\n  else reverse(l[1..]) + [l[0]]\n}\n\nlemma reverse_permutes<T>(l: seq<T>)\n  ensures forall x :: x in l <==> x in reverse(l)\n{\n  if |l| == 0 {\n  } else {\n    reverse_permutes(l[1..]);\n    forall x\n      ensures x in l <==> x in reverse(l)\n    {\n      if x == l[0] {\n        assert x in reverse(l);\n      } else {\n        \n/*[CODE HERE]*/\n        assert x in l[1..] <==> x in reverse(l[1..]);\n        assert x in reverse(l[1..]) ==> x in reverse(l[1..]) + [l[0]];\n      }\n    }\n  }\n}\n\nlemma reverse_append<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n    assert reverse(s2) + [] == reverse(s2);\n  } else {\n    assert s1 == [s1[0]] + s1[1..];\n    assert s1 + s2 == ([s1[0]] + s1[1..]) + s2 == [s1[0]] + (s1[1..] + s2);\n    \n    calc {\n      reverse(s1 + s2);\n      == reverse([s1[0]] + (s1[1..] + s2));\n      == reverse((s1[1..] + s2)) + [s1[0]];\n      == { reverse_append(s1[1..], s2); }\n      (reverse(s2) + reverse(s1[1..])) + [s1[0]];\n      == { assert (reverse(s2) + reverse(s1[1..])) + [s1[0]] == \n           reverse(s2) + (reverse(s1[1..]) + [s1[0]]); }\n      reverse(s2) + (reverse(s1[1..]) + [s1[0]]);\n      == reverse(s2) + reverse(s1);\n    }\n  }\n}\n\nlemma reverse_involutes<T>(l: seq<T>)\n  ensures reverse(reverse(l)) == l\n{\n  if |l| == 0 {\n  } else {\n    calc {\n      reverse(reverse(l));\n      == reverse(reverse(l[1..]) + [l[0]]);\n      == { reverse_append(reverse(l[1..]), [l[0]]); }\n      reverse([l[0]]) + reverse(reverse(l[1..]));\n      == [l[0]] + reverse(reverse(l[1..]));\n      == { reverse_involutes(l[1..]); }\n      [l[0]] + l[1..];\n      == l;\n    }\n  }\n}", "output": "assert x in l <==> x in l[1..];"}, {"id": "example_reverse_permutes_3", "type": "assert", "program": "function reverse<T>(l: seq<T>): seq<T>\n{\n  if |l| == 0 then []\n  else reverse(l[1..]) + [l[0]]\n}\n\nlemma reverse_permutes<T>(l: seq<T>)\n  ensures forall x :: x in l <==> x in reverse(l)\n{\n  if |l| == 0 {\n  } else {\n    reverse_permutes(l[1..]);\n    forall x\n      ensures x in l <==> x in reverse(l)\n    {\n      if x == l[0] {\n        \n/*[CODE HERE]*/\n      } else {\n        assert x in l <==> x in l[1..];\n        assert x in l[1..] <==> x in reverse(l[1..]);\n        assert x in reverse(l[1..]) ==> x in reverse(l[1..]) + [l[0]];\n      }\n    }\n  }\n}\n\nlemma reverse_append<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n    assert reverse(s2) + [] == reverse(s2);\n  } else {\n    assert s1 == [s1[0]] + s1[1..];\n    assert s1 + s2 == ([s1[0]] + s1[1..]) + s2 == [s1[0]] + (s1[1..] + s2);\n    \n    calc {\n      reverse(s1 + s2);\n      == reverse([s1[0]] + (s1[1..] + s2));\n      == reverse((s1[1..] + s2)) + [s1[0]];\n      == { reverse_append(s1[1..], s2); }\n      (reverse(s2) + reverse(s1[1..])) + [s1[0]];\n      == { assert (reverse(s2) + reverse(s1[1..])) + [s1[0]] == \n           reverse(s2) + (reverse(s1[1..]) + [s1[0]]); }\n      reverse(s2) + (reverse(s1[1..]) + [s1[0]]);\n      == reverse(s2) + reverse(s1);\n    }\n  }\n}\n\nlemma reverse_involutes<T>(l: seq<T>)\n  ensures reverse(reverse(l)) == l\n{\n  if |l| == 0 {\n  } else {\n    calc {\n      reverse(reverse(l));\n      == reverse(reverse(l[1..]) + [l[0]]);\n      == { reverse_append(reverse(l[1..]), [l[0]]); }\n      reverse([l[0]]) + reverse(reverse(l[1..]));\n      == [l[0]] + reverse(reverse(l[1..]));\n      == { reverse_involutes(l[1..]); }\n      [l[0]] + l[1..];\n      == l;\n    }\n  }\n}", "output": "assert x in reverse(l);"}, {"id": "example_reverse_permutes_4", "type": "call", "program": "function reverse<T>(l: seq<T>): seq<T>\n{\n  if |l| == 0 then []\n  else reverse(l[1..]) + [l[0]]\n}\n\nlemma reverse_permutes<T>(l: seq<T>)\n  ensures forall x :: x in l <==> x in reverse(l)\n{\n  if |l| == 0 {\n  } else {\n    \n/*[CODE HERE]*/\n    forall x\n      ensures x in l <==> x in reverse(l)\n    {\n      if x == l[0] {\n        assert x in reverse(l);\n      } else {\n        assert x in l <==> x in l[1..];\n        assert x in l[1..] <==> x in reverse(l[1..]);\n        assert x in reverse(l[1..]) ==> x in reverse(l[1..]) + [l[0]];\n      }\n    }\n  }\n}\n\nlemma reverse_append<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n    assert reverse(s2) + [] == reverse(s2);\n  } else {\n    assert s1 == [s1[0]] + s1[1..];\n    assert s1 + s2 == ([s1[0]] + s1[1..]) + s2 == [s1[0]] + (s1[1..] + s2);\n    \n    calc {\n      reverse(s1 + s2);\n      == reverse([s1[0]] + (s1[1..] + s2));\n      == reverse((s1[1..] + s2)) + [s1[0]];\n      == { reverse_append(s1[1..], s2); }\n      (reverse(s2) + reverse(s1[1..])) + [s1[0]];\n      == { assert (reverse(s2) + reverse(s1[1..])) + [s1[0]] == \n           reverse(s2) + (reverse(s1[1..]) + [s1[0]]); }\n      reverse(s2) + (reverse(s1[1..]) + [s1[0]]);\n      == reverse(s2) + reverse(s1);\n    }\n  }\n}\n\nlemma reverse_involutes<T>(l: seq<T>)\n  ensures reverse(reverse(l)) == l\n{\n  if |l| == 0 {\n  } else {\n    calc {\n      reverse(reverse(l));\n      == reverse(reverse(l[1..]) + [l[0]]);\n      == { reverse_append(reverse(l[1..]), [l[0]]); }\n      reverse([l[0]]) + reverse(reverse(l[1..]));\n      == [l[0]] + reverse(reverse(l[1..]));\n      == { reverse_involutes(l[1..]); }\n      [l[0]] + l[1..];\n      == l;\n    }\n  }\n}", "output": "reverse_permutes(l[1..]);"}, {"id": "example_reverse_append_0", "type": "assert", "program": "function reverse<T>(l: seq<T>): seq<T>\n{\n  if |l| == 0 then []\n  else reverse(l[1..]) + [l[0]]\n}\n\nlemma reverse_permutes<T>(l: seq<T>)\n  ensures forall x :: x in l <==> x in reverse(l)\n{\n  if |l| == 0 {\n  } else {\n    reverse_permutes(l[1..]);\n    forall x\n      ensures x in l <==> x in reverse(l)\n    {\n      if x == l[0] {\n        assert x in reverse(l);\n      } else {\n        assert x in l <==> x in l[1..];\n        assert x in l[1..] <==> x in reverse(l[1..]);\n        assert x in reverse(l[1..]) ==> x in reverse(l[1..]) + [l[0]];\n      }\n    }\n  }\n}\n\nlemma reverse_append<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n    assert reverse(s2) + [] == reverse(s2);\n  } else {\n    assert s1 == [s1[0]] + s1[1..];\n    assert s1 + s2 == ([s1[0]] + s1[1..]) + s2 == [s1[0]] + (s1[1..] + s2);\n    \n    calc {\n      reverse(s1 + s2);\n      == reverse([s1[0]] + (s1[1..] + s2));\n      == reverse((s1[1..] + s2)) + [s1[0]];\n      == { reverse_append(s1[1..], s2); }\n      (reverse(s2) + reverse(s1[1..])) + [s1[0]];\n      == { \n/*[CODE HERE]*/\n}\n      reverse(s2) + (reverse(s1[1..]) + [s1[0]]);\n      == reverse(s2) + reverse(s1);\n    }\n  }\n}\n\nlemma reverse_involutes<T>(l: seq<T>)\n  ensures reverse(reverse(l)) == l\n{\n  if |l| == 0 {\n  } else {\n    calc {\n      reverse(reverse(l));\n      == reverse(reverse(l[1..]) + [l[0]]);\n      == { reverse_append(reverse(l[1..]), [l[0]]); }\n      reverse([l[0]]) + reverse(reverse(l[1..]));\n      == [l[0]] + reverse(reverse(l[1..]));\n      == { reverse_involutes(l[1..]); }\n      [l[0]] + l[1..];\n      == l;\n    }\n  }\n}", "output": "assert (reverse(s2) + reverse(s1[1..])) + [s1[0]] == \n           reverse(s2) + (reverse(s1[1..]) + [s1[0]]);"}, {"id": "example_reverse_append_1", "type": "call", "program": "function reverse<T>(l: seq<T>): seq<T>\n{\n  if |l| == 0 then []\n  else reverse(l[1..]) + [l[0]]\n}\n\nlemma reverse_permutes<T>(l: seq<T>)\n  ensures forall x :: x in l <==> x in reverse(l)\n{\n  if |l| == 0 {\n  } else {\n    reverse_permutes(l[1..]);\n    forall x\n      ensures x in l <==> x in reverse(l)\n    {\n      if x == l[0] {\n        assert x in reverse(l);\n      } else {\n        assert x in l <==> x in l[1..];\n        assert x in l[1..] <==> x in reverse(l[1..]);\n        assert x in reverse(l[1..]) ==> x in reverse(l[1..]) + [l[0]];\n      }\n    }\n  }\n}\n\nlemma reverse_append<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n    assert reverse(s2) + [] == reverse(s2);\n  } else {\n    assert s1 == [s1[0]] + s1[1..];\n    assert s1 + s2 == ([s1[0]] + s1[1..]) + s2 == [s1[0]] + (s1[1..] + s2);\n    \n    calc {\n      reverse(s1 + s2);\n      == reverse([s1[0]] + (s1[1..] + s2));\n      == reverse((s1[1..] + s2)) + [s1[0]];\n      == { \n/*[CODE HERE]*/\n}\n      (reverse(s2) + reverse(s1[1..])) + [s1[0]];\n      == { assert (reverse(s2) + reverse(s1[1..])) + [s1[0]] == \n           reverse(s2) + (reverse(s1[1..]) + [s1[0]]); }\n      reverse(s2) + (reverse(s1[1..]) + [s1[0]]);\n      == reverse(s2) + reverse(s1);\n    }\n  }\n}\n\nlemma reverse_involutes<T>(l: seq<T>)\n  ensures reverse(reverse(l)) == l\n{\n  if |l| == 0 {\n  } else {\n    calc {\n      reverse(reverse(l));\n      == reverse(reverse(l[1..]) + [l[0]]);\n      == { reverse_append(reverse(l[1..]), [l[0]]); }\n      reverse([l[0]]) + reverse(reverse(l[1..]));\n      == [l[0]] + reverse(reverse(l[1..]));\n      == { reverse_involutes(l[1..]); }\n      [l[0]] + l[1..];\n      == l;\n    }\n  }\n}", "output": "reverse_append(s1[1..], s2);"}, {"id": "example_reverse_append_2", "type": "assert", "program": "function reverse<T>(l: seq<T>): seq<T>\n{\n  if |l| == 0 then []\n  else reverse(l[1..]) + [l[0]]\n}\n\nlemma reverse_permutes<T>(l: seq<T>)\n  ensures forall x :: x in l <==> x in reverse(l)\n{\n  if |l| == 0 {\n  } else {\n    reverse_permutes(l[1..]);\n    forall x\n      ensures x in l <==> x in reverse(l)\n    {\n      if x == l[0] {\n        assert x in reverse(l);\n      } else {\n        assert x in l <==> x in l[1..];\n        assert x in l[1..] <==> x in reverse(l[1..]);\n        assert x in reverse(l[1..]) ==> x in reverse(l[1..]) + [l[0]];\n      }\n    }\n  }\n}\n\nlemma reverse_append<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n    assert reverse(s2) + [] == reverse(s2);\n  } else {\n    assert s1 == [s1[0]] + s1[1..];\n    \n/*[CODE HERE]*/\n    \n    calc {\n      reverse(s1 + s2);\n      == reverse([s1[0]] + (s1[1..] + s2));\n      == reverse((s1[1..] + s2)) + [s1[0]];\n      == { reverse_append(s1[1..], s2); }\n      (reverse(s2) + reverse(s1[1..])) + [s1[0]];\n      == { assert (reverse(s2) + reverse(s1[1..])) + [s1[0]] == \n           reverse(s2) + (reverse(s1[1..]) + [s1[0]]); }\n      reverse(s2) + (reverse(s1[1..]) + [s1[0]]);\n      == reverse(s2) + reverse(s1);\n    }\n  }\n}\n\nlemma reverse_involutes<T>(l: seq<T>)\n  ensures reverse(reverse(l)) == l\n{\n  if |l| == 0 {\n  } else {\n    calc {\n      reverse(reverse(l));\n      == reverse(reverse(l[1..]) + [l[0]]);\n      == { reverse_append(reverse(l[1..]), [l[0]]); }\n      reverse([l[0]]) + reverse(reverse(l[1..]));\n      == [l[0]] + reverse(reverse(l[1..]));\n      == { reverse_involutes(l[1..]); }\n      [l[0]] + l[1..];\n      == l;\n    }\n  }\n}", "output": "assert s1 + s2 == ([s1[0]] + s1[1..]) + s2 == [s1[0]] + (s1[1..] + s2);"}, {"id": "example_reverse_append_3", "type": "assert", "program": "function reverse<T>(l: seq<T>): seq<T>\n{\n  if |l| == 0 then []\n  else reverse(l[1..]) + [l[0]]\n}\n\nlemma reverse_permutes<T>(l: seq<T>)\n  ensures forall x :: x in l <==> x in reverse(l)\n{\n  if |l| == 0 {\n  } else {\n    reverse_permutes(l[1..]);\n    forall x\n      ensures x in l <==> x in reverse(l)\n    {\n      if x == l[0] {\n        assert x in reverse(l);\n      } else {\n        assert x in l <==> x in l[1..];\n        assert x in l[1..] <==> x in reverse(l[1..]);\n        assert x in reverse(l[1..]) ==> x in reverse(l[1..]) + [l[0]];\n      }\n    }\n  }\n}\n\nlemma reverse_append<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n    assert reverse(s2) + [] == reverse(s2);\n  } else {\n    \n/*[CODE HERE]*/\n    assert s1 + s2 == ([s1[0]] + s1[1..]) + s2 == [s1[0]] + (s1[1..] + s2);\n    \n    calc {\n      reverse(s1 + s2);\n      == reverse([s1[0]] + (s1[1..] + s2));\n      == reverse((s1[1..] + s2)) + [s1[0]];\n      == { reverse_append(s1[1..], s2); }\n      (reverse(s2) + reverse(s1[1..])) + [s1[0]];\n      == { assert (reverse(s2) + reverse(s1[1..])) + [s1[0]] == \n           reverse(s2) + (reverse(s1[1..]) + [s1[0]]); }\n      reverse(s2) + (reverse(s1[1..]) + [s1[0]]);\n      == reverse(s2) + reverse(s1);\n    }\n  }\n}\n\nlemma reverse_involutes<T>(l: seq<T>)\n  ensures reverse(reverse(l)) == l\n{\n  if |l| == 0 {\n  } else {\n    calc {\n      reverse(reverse(l));\n      == reverse(reverse(l[1..]) + [l[0]]);\n      == { reverse_append(reverse(l[1..]), [l[0]]); }\n      reverse([l[0]]) + reverse(reverse(l[1..]));\n      == [l[0]] + reverse(reverse(l[1..]));\n      == { reverse_involutes(l[1..]); }\n      [l[0]] + l[1..];\n      == l;\n    }\n  }\n}", "output": "assert s1 == [s1[0]] + s1[1..];"}, {"id": "example_reverse_append_4", "type": "assert", "program": "function reverse<T>(l: seq<T>): seq<T>\n{\n  if |l| == 0 then []\n  else reverse(l[1..]) + [l[0]]\n}\n\nlemma reverse_permutes<T>(l: seq<T>)\n  ensures forall x :: x in l <==> x in reverse(l)\n{\n  if |l| == 0 {\n  } else {\n    reverse_permutes(l[1..]);\n    forall x\n      ensures x in l <==> x in reverse(l)\n    {\n      if x == l[0] {\n        assert x in reverse(l);\n      } else {\n        assert x in l <==> x in l[1..];\n        assert x in l[1..] <==> x in reverse(l[1..]);\n        assert x in reverse(l[1..]) ==> x in reverse(l[1..]) + [l[0]];\n      }\n    }\n  }\n}\n\nlemma reverse_append<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n    \n/*[CODE HERE]*/\n  } else {\n    assert s1 == [s1[0]] + s1[1..];\n    assert s1 + s2 == ([s1[0]] + s1[1..]) + s2 == [s1[0]] + (s1[1..] + s2);\n    \n    calc {\n      reverse(s1 + s2);\n      == reverse([s1[0]] + (s1[1..] + s2));\n      == reverse((s1[1..] + s2)) + [s1[0]];\n      == { reverse_append(s1[1..], s2); }\n      (reverse(s2) + reverse(s1[1..])) + [s1[0]];\n      == { assert (reverse(s2) + reverse(s1[1..])) + [s1[0]] == \n           reverse(s2) + (reverse(s1[1..]) + [s1[0]]); }\n      reverse(s2) + (reverse(s1[1..]) + [s1[0]]);\n      == reverse(s2) + reverse(s1);\n    }\n  }\n}\n\nlemma reverse_involutes<T>(l: seq<T>)\n  ensures reverse(reverse(l)) == l\n{\n  if |l| == 0 {\n  } else {\n    calc {\n      reverse(reverse(l));\n      == reverse(reverse(l[1..]) + [l[0]]);\n      == { reverse_append(reverse(l[1..]), [l[0]]); }\n      reverse([l[0]]) + reverse(reverse(l[1..]));\n      == [l[0]] + reverse(reverse(l[1..]));\n      == { reverse_involutes(l[1..]); }\n      [l[0]] + l[1..];\n      == l;\n    }\n  }\n}", "output": "assert reverse(s2) + [] == reverse(s2);"}, {"id": "example_reverse_append_5", "type": "assert", "program": "function reverse<T>(l: seq<T>): seq<T>\n{\n  if |l| == 0 then []\n  else reverse(l[1..]) + [l[0]]\n}\n\nlemma reverse_permutes<T>(l: seq<T>)\n  ensures forall x :: x in l <==> x in reverse(l)\n{\n  if |l| == 0 {\n  } else {\n    reverse_permutes(l[1..]);\n    forall x\n      ensures x in l <==> x in reverse(l)\n    {\n      if x == l[0] {\n        assert x in reverse(l);\n      } else {\n        assert x in l <==> x in l[1..];\n        assert x in l[1..] <==> x in reverse(l[1..]);\n        assert x in reverse(l[1..]) ==> x in reverse(l[1..]) + [l[0]];\n      }\n    }\n  }\n}\n\nlemma reverse_append<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    \n/*[CODE HERE]*/\n    assert reverse(s2) + [] == reverse(s2);\n  } else {\n    assert s1 == [s1[0]] + s1[1..];\n    assert s1 + s2 == ([s1[0]] + s1[1..]) + s2 == [s1[0]] + (s1[1..] + s2);\n    \n    calc {\n      reverse(s1 + s2);\n      == reverse([s1[0]] + (s1[1..] + s2));\n      == reverse((s1[1..] + s2)) + [s1[0]];\n      == { reverse_append(s1[1..], s2); }\n      (reverse(s2) + reverse(s1[1..])) + [s1[0]];\n      == { assert (reverse(s2) + reverse(s1[1..])) + [s1[0]] == \n           reverse(s2) + (reverse(s1[1..]) + [s1[0]]); }\n      reverse(s2) + (reverse(s1[1..]) + [s1[0]]);\n      == reverse(s2) + reverse(s1);\n    }\n  }\n}\n\nlemma reverse_involutes<T>(l: seq<T>)\n  ensures reverse(reverse(l)) == l\n{\n  if |l| == 0 {\n  } else {\n    calc {\n      reverse(reverse(l));\n      == reverse(reverse(l[1..]) + [l[0]]);\n      == { reverse_append(reverse(l[1..]), [l[0]]); }\n      reverse([l[0]]) + reverse(reverse(l[1..]));\n      == [l[0]] + reverse(reverse(l[1..]));\n      == { reverse_involutes(l[1..]); }\n      [l[0]] + l[1..];\n      == l;\n    }\n  }\n}", "output": "assert reverse(s1) == [];"}, {"id": "example_reverse_append_6", "type": "assert", "program": "function reverse<T>(l: seq<T>): seq<T>\n{\n  if |l| == 0 then []\n  else reverse(l[1..]) + [l[0]]\n}\n\nlemma reverse_permutes<T>(l: seq<T>)\n  ensures forall x :: x in l <==> x in reverse(l)\n{\n  if |l| == 0 {\n  } else {\n    reverse_permutes(l[1..]);\n    forall x\n      ensures x in l <==> x in reverse(l)\n    {\n      if x == l[0] {\n        assert x in reverse(l);\n      } else {\n        assert x in l <==> x in l[1..];\n        assert x in l[1..] <==> x in reverse(l[1..]);\n        assert x in reverse(l[1..]) ==> x in reverse(l[1..]) + [l[0]];\n      }\n    }\n  }\n}\n\nlemma reverse_append<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    \n/*[CODE HERE]*/\n    assert reverse(s1) == [];\n    assert reverse(s2) + [] == reverse(s2);\n  } else {\n    assert s1 == [s1[0]] + s1[1..];\n    assert s1 + s2 == ([s1[0]] + s1[1..]) + s2 == [s1[0]] + (s1[1..] + s2);\n    \n    calc {\n      reverse(s1 + s2);\n      == reverse([s1[0]] + (s1[1..] + s2));\n      == reverse((s1[1..] + s2)) + [s1[0]];\n      == { reverse_append(s1[1..], s2); }\n      (reverse(s2) + reverse(s1[1..])) + [s1[0]];\n      == { assert (reverse(s2) + reverse(s1[1..])) + [s1[0]] == \n           reverse(s2) + (reverse(s1[1..]) + [s1[0]]); }\n      reverse(s2) + (reverse(s1[1..]) + [s1[0]]);\n      == reverse(s2) + reverse(s1);\n    }\n  }\n}\n\nlemma reverse_involutes<T>(l: seq<T>)\n  ensures reverse(reverse(l)) == l\n{\n  if |l| == 0 {\n  } else {\n    calc {\n      reverse(reverse(l));\n      == reverse(reverse(l[1..]) + [l[0]]);\n      == { reverse_append(reverse(l[1..]), [l[0]]); }\n      reverse([l[0]]) + reverse(reverse(l[1..]));\n      == [l[0]] + reverse(reverse(l[1..]));\n      == { reverse_involutes(l[1..]); }\n      [l[0]] + l[1..];\n      == l;\n    }\n  }\n}", "output": "assert s1 + s2 == s2;"}, {"id": "example_reverse_involutes_0", "type": "call", "program": "function reverse<T>(l: seq<T>): seq<T>\n{\n  if |l| == 0 then []\n  else reverse(l[1..]) + [l[0]]\n}\n\nlemma reverse_permutes<T>(l: seq<T>)\n  ensures forall x :: x in l <==> x in reverse(l)\n{\n  if |l| == 0 {\n  } else {\n    reverse_permutes(l[1..]);\n    forall x\n      ensures x in l <==> x in reverse(l)\n    {\n      if x == l[0] {\n        assert x in reverse(l);\n      } else {\n        assert x in l <==> x in l[1..];\n        assert x in l[1..] <==> x in reverse(l[1..]);\n        assert x in reverse(l[1..]) ==> x in reverse(l[1..]) + [l[0]];\n      }\n    }\n  }\n}\n\nlemma reverse_append<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n    assert reverse(s2) + [] == reverse(s2);\n  } else {\n    assert s1 == [s1[0]] + s1[1..];\n    assert s1 + s2 == ([s1[0]] + s1[1..]) + s2 == [s1[0]] + (s1[1..] + s2);\n    \n    calc {\n      reverse(s1 + s2);\n      == reverse([s1[0]] + (s1[1..] + s2));\n      == reverse((s1[1..] + s2)) + [s1[0]];\n      == { reverse_append(s1[1..], s2); }\n      (reverse(s2) + reverse(s1[1..])) + [s1[0]];\n      == { assert (reverse(s2) + reverse(s1[1..])) + [s1[0]] == \n           reverse(s2) + (reverse(s1[1..]) + [s1[0]]); }\n      reverse(s2) + (reverse(s1[1..]) + [s1[0]]);\n      == reverse(s2) + reverse(s1);\n    }\n  }\n}\n\nlemma reverse_involutes<T>(l: seq<T>)\n  ensures reverse(reverse(l)) == l\n{\n  if |l| == 0 {\n  } else {\n    calc {\n      reverse(reverse(l));\n      == reverse(reverse(l[1..]) + [l[0]]);\n      == { reverse_append(reverse(l[1..]), [l[0]]); }\n      reverse([l[0]]) + reverse(reverse(l[1..]));\n      == [l[0]] + reverse(reverse(l[1..]));\n      == { \n/*[CODE HERE]*/\n}\n      [l[0]] + l[1..];\n      == l;\n    }\n  }\n}", "output": "reverse_involutes(l[1..]);"}, {"id": "example_reverse_involutes_1", "type": "call", "program": "function reverse<T>(l: seq<T>): seq<T>\n{\n  if |l| == 0 then []\n  else reverse(l[1..]) + [l[0]]\n}\n\nlemma reverse_permutes<T>(l: seq<T>)\n  ensures forall x :: x in l <==> x in reverse(l)\n{\n  if |l| == 0 {\n  } else {\n    reverse_permutes(l[1..]);\n    forall x\n      ensures x in l <==> x in reverse(l)\n    {\n      if x == l[0] {\n        assert x in reverse(l);\n      } else {\n        assert x in l <==> x in l[1..];\n        assert x in l[1..] <==> x in reverse(l[1..]);\n        assert x in reverse(l[1..]) ==> x in reverse(l[1..]) + [l[0]];\n      }\n    }\n  }\n}\n\nlemma reverse_append<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n    assert reverse(s1) == [];\n    assert reverse(s2) + [] == reverse(s2);\n  } else {\n    assert s1 == [s1[0]] + s1[1..];\n    assert s1 + s2 == ([s1[0]] + s1[1..]) + s2 == [s1[0]] + (s1[1..] + s2);\n    \n    calc {\n      reverse(s1 + s2);\n      == reverse([s1[0]] + (s1[1..] + s2));\n      == reverse((s1[1..] + s2)) + [s1[0]];\n      == { reverse_append(s1[1..], s2); }\n      (reverse(s2) + reverse(s1[1..])) + [s1[0]];\n      == { assert (reverse(s2) + reverse(s1[1..])) + [s1[0]] == \n           reverse(s2) + (reverse(s1[1..]) + [s1[0]]); }\n      reverse(s2) + (reverse(s1[1..]) + [s1[0]]);\n      == reverse(s2) + reverse(s1);\n    }\n  }\n}\n\nlemma reverse_involutes<T>(l: seq<T>)\n  ensures reverse(reverse(l)) == l\n{\n  if |l| == 0 {\n  } else {\n    calc {\n      reverse(reverse(l));\n      == reverse(reverse(l[1..]) + [l[0]]);\n      == { \n/*[CODE HERE]*/\n}\n      reverse([l[0]]) + reverse(reverse(l[1..]));\n      == [l[0]] + reverse(reverse(l[1..]));\n      == { reverse_involutes(l[1..]); }\n      [l[0]] + l[1..];\n      == l;\n    }\n  }\n}", "output": "reverse_append(reverse(l[1..]), [l[0]]);"}, {"id": "example_encodeProducesValidRLE_0", "type": "assert", "program": "// Run-Length Encoding\n// RLE compresses consecutive identical characters into (count, char) pairs\n\ndatatype RLE = RLE(count: nat, ch: char)\n\npredicate {:spec} validRLE(encoded: seq<RLE>)\n{\n  forall i :: 0 <= i < |encoded| ==> \n    encoded[i].count > 0 &&\n    (i + 1 < |encoded| ==> encoded[i].ch != encoded[i+1].ch)\n}\n\nfunction {:spec} decode(encoded: seq<RLE>): seq<char>\n{\n  if |encoded| == 0 then []\n  else repeatChar(encoded[0].count, encoded[0].ch) + decode(encoded[1..])\n}\n\nfunction {:spec} repeatChar(n: nat, c: char): seq<char>\n{\n  if n == 0 then []\n  else [c] + repeatChar(n-1, c)\n}\n\nfunction encode(s: seq<char>): seq<RLE>\n{\n  if |s| == 0 then []\n  else if |s| == 1 then [RLE(1, s[0])]\n  else \n    var rest := encode(s[1..]);\n    if |rest| > 0 && rest[0].ch == s[0] then\n      [RLE(rest[0].count + 1, s[0])] + rest[1..]\n    else\n      [RLE(1, s[0])] + rest\n}\n\nlemma encodeProducesValidRLE(s: seq<char>)\n  ensures validRLE(encode(s))\n{\n  if |s| <= 1 {\n    // Base cases are trivial\n  } else {\n    var rest := encode(s[1..]);\n    encodeProducesValidRLE(s[1..]); // Recursive call for induction\n    if |rest| > 0 && rest[0].ch == s[0] {\n      // When merging, we maintain validity since we're just incrementing count\n      assert validRLE([RLE(rest[0].count + 1, s[0])] + rest[1..]);\n    } else {\n      // When not merging, s[0] != rest[0].ch (if rest is non-empty)\n      \n/*[CODE HERE]*/\n    }\n  }\n}\n\nlemma encodeDecodeRoundTrip(s: seq<char>)\n  ensures decode(encode(s)) == s\n{\n  if |s| == 0 {\n    // Base case: empty sequence\n  } else if |s| == 1 {\n    // Base case: single character\n    assert decode([RLE(1, s[0])]) == repeatChar(1, s[0]) == [s[0]] == s;\n  } else {\n    var rest := encode(s[1..]);\n    encodeDecodeRoundTrip(s[1..]); // Induction hypothesis\n    assert decode(rest) == s[1..];\n    \n    if |rest| > 0 && rest[0].ch == s[0] {\n      // Case: merging with first element of rest\n      var merged := [RLE(rest[0].count + 1, s[0])] + rest[1..];\n      assert decode(merged) == repeatChar(rest[0].count + 1, s[0]) + decode(rest[1..]);\n      assert repeatChar(rest[0].count + 1, s[0]) == [s[0]] + repeatChar(rest[0].count, s[0]);\n      assert decode(rest) == repeatChar(rest[0].count, rest[0].ch) + decode(rest[1..]);\n      assert s[0] == rest[0].ch;\n      assert decode(merged) == [s[0]] + decode(rest) == [s[0]] + s[1..] == s;\n    } else {\n      // Case: not merging\n      var result := [RLE(1, s[0])] + rest;\n      assert decode(result) == repeatChar(1, s[0]) + decode(rest);\n      assert repeatChar(1, s[0]) == [s[0]];\n      assert decode(result) == [s[0]] + s[1..] == s;\n    }\n  }\n}", "output": "assert validRLE([RLE(1, s[0])] + rest);"}, {"id": "example_encodeProducesValidRLE_1", "type": "assert", "program": "// Run-Length Encoding\n// RLE compresses consecutive identical characters into (count, char) pairs\n\ndatatype RLE = RLE(count: nat, ch: char)\n\npredicate {:spec} validRLE(encoded: seq<RLE>)\n{\n  forall i :: 0 <= i < |encoded| ==> \n    encoded[i].count > 0 &&\n    (i + 1 < |encoded| ==> encoded[i].ch != encoded[i+1].ch)\n}\n\nfunction {:spec} decode(encoded: seq<RLE>): seq<char>\n{\n  if |encoded| == 0 then []\n  else repeatChar(encoded[0].count, encoded[0].ch) + decode(encoded[1..])\n}\n\nfunction {:spec} repeatChar(n: nat, c: char): seq<char>\n{\n  if n == 0 then []\n  else [c] + repeatChar(n-1, c)\n}\n\nfunction encode(s: seq<char>): seq<RLE>\n{\n  if |s| == 0 then []\n  else if |s| == 1 then [RLE(1, s[0])]\n  else \n    var rest := encode(s[1..]);\n    if |rest| > 0 && rest[0].ch == s[0] then\n      [RLE(rest[0].count + 1, s[0])] + rest[1..]\n    else\n      [RLE(1, s[0])] + rest\n}\n\nlemma encodeProducesValidRLE(s: seq<char>)\n  ensures validRLE(encode(s))\n{\n  if |s| <= 1 {\n    // Base cases are trivial\n  } else {\n    var rest := encode(s[1..]);\n    encodeProducesValidRLE(s[1..]); // Recursive call for induction\n    if |rest| > 0 && rest[0].ch == s[0] {\n      // When merging, we maintain validity since we're just incrementing count\n      \n/*[CODE HERE]*/\n    } else {\n      // When not merging, s[0] != rest[0].ch (if rest is non-empty)\n      assert validRLE([RLE(1, s[0])] + rest);\n    }\n  }\n}\n\nlemma encodeDecodeRoundTrip(s: seq<char>)\n  ensures decode(encode(s)) == s\n{\n  if |s| == 0 {\n    // Base case: empty sequence\n  } else if |s| == 1 {\n    // Base case: single character\n    assert decode([RLE(1, s[0])]) == repeatChar(1, s[0]) == [s[0]] == s;\n  } else {\n    var rest := encode(s[1..]);\n    encodeDecodeRoundTrip(s[1..]); // Induction hypothesis\n    assert decode(rest) == s[1..];\n    \n    if |rest| > 0 && rest[0].ch == s[0] {\n      // Case: merging with first element of rest\n      var merged := [RLE(rest[0].count + 1, s[0])] + rest[1..];\n      assert decode(merged) == repeatChar(rest[0].count + 1, s[0]) + decode(rest[1..]);\n      assert repeatChar(rest[0].count + 1, s[0]) == [s[0]] + repeatChar(rest[0].count, s[0]);\n      assert decode(rest) == repeatChar(rest[0].count, rest[0].ch) + decode(rest[1..]);\n      assert s[0] == rest[0].ch;\n      assert decode(merged) == [s[0]] + decode(rest) == [s[0]] + s[1..] == s;\n    } else {\n      // Case: not merging\n      var result := [RLE(1, s[0])] + rest;\n      assert decode(result) == repeatChar(1, s[0]) + decode(rest);\n      assert repeatChar(1, s[0]) == [s[0]];\n      assert decode(result) == [s[0]] + s[1..] == s;\n    }\n  }\n}", "output": "assert validRLE([RLE(rest[0].count + 1, s[0])] + rest[1..]);"}, {"id": "example_encodeProducesValidRLE_2", "type": "call", "program": "// Run-Length Encoding\n// RLE compresses consecutive identical characters into (count, char) pairs\n\ndatatype RLE = RLE(count: nat, ch: char)\n\npredicate {:spec} validRLE(encoded: seq<RLE>)\n{\n  forall i :: 0 <= i < |encoded| ==> \n    encoded[i].count > 0 &&\n    (i + 1 < |encoded| ==> encoded[i].ch != encoded[i+1].ch)\n}\n\nfunction {:spec} decode(encoded: seq<RLE>): seq<char>\n{\n  if |encoded| == 0 then []\n  else repeatChar(encoded[0].count, encoded[0].ch) + decode(encoded[1..])\n}\n\nfunction {:spec} repeatChar(n: nat, c: char): seq<char>\n{\n  if n == 0 then []\n  else [c] + repeatChar(n-1, c)\n}\n\nfunction encode(s: seq<char>): seq<RLE>\n{\n  if |s| == 0 then []\n  else if |s| == 1 then [RLE(1, s[0])]\n  else \n    var rest := encode(s[1..]);\n    if |rest| > 0 && rest[0].ch == s[0] then\n      [RLE(rest[0].count + 1, s[0])] + rest[1..]\n    else\n      [RLE(1, s[0])] + rest\n}\n\nlemma encodeProducesValidRLE(s: seq<char>)\n  ensures validRLE(encode(s))\n{\n  if |s| <= 1 {\n    // Base cases are trivial\n  } else {\n    var rest := encode(s[1..]);\n    \n/*[CODE HERE]*/\n// Recursive call for induction\n    if |rest| > 0 && rest[0].ch == s[0] {\n      // When merging, we maintain validity since we're just incrementing count\n      assert validRLE([RLE(rest[0].count + 1, s[0])] + rest[1..]);\n    } else {\n      // When not merging, s[0] != rest[0].ch (if rest is non-empty)\n      assert validRLE([RLE(1, s[0])] + rest);\n    }\n  }\n}\n\nlemma encodeDecodeRoundTrip(s: seq<char>)\n  ensures decode(encode(s)) == s\n{\n  if |s| == 0 {\n    // Base case: empty sequence\n  } else if |s| == 1 {\n    // Base case: single character\n    assert decode([RLE(1, s[0])]) == repeatChar(1, s[0]) == [s[0]] == s;\n  } else {\n    var rest := encode(s[1..]);\n    encodeDecodeRoundTrip(s[1..]); // Induction hypothesis\n    assert decode(rest) == s[1..];\n    \n    if |rest| > 0 && rest[0].ch == s[0] {\n      // Case: merging with first element of rest\n      var merged := [RLE(rest[0].count + 1, s[0])] + rest[1..];\n      assert decode(merged) == repeatChar(rest[0].count + 1, s[0]) + decode(rest[1..]);\n      assert repeatChar(rest[0].count + 1, s[0]) == [s[0]] + repeatChar(rest[0].count, s[0]);\n      assert decode(rest) == repeatChar(rest[0].count, rest[0].ch) + decode(rest[1..]);\n      assert s[0] == rest[0].ch;\n      assert decode(merged) == [s[0]] + decode(rest) == [s[0]] + s[1..] == s;\n    } else {\n      // Case: not merging\n      var result := [RLE(1, s[0])] + rest;\n      assert decode(result) == repeatChar(1, s[0]) + decode(rest);\n      assert repeatChar(1, s[0]) == [s[0]];\n      assert decode(result) == [s[0]] + s[1..] == s;\n    }\n  }\n}", "output": "encodeProducesValidRLE(s[1..]);"}, {"id": "example_encodeDecodeRoundTrip_0", "type": "assert", "program": "// Run-Length Encoding\n// RLE compresses consecutive identical characters into (count, char) pairs\n\ndatatype RLE = RLE(count: nat, ch: char)\n\npredicate {:spec} validRLE(encoded: seq<RLE>)\n{\n  forall i :: 0 <= i < |encoded| ==> \n    encoded[i].count > 0 &&\n    (i + 1 < |encoded| ==> encoded[i].ch != encoded[i+1].ch)\n}\n\nfunction {:spec} decode(encoded: seq<RLE>): seq<char>\n{\n  if |encoded| == 0 then []\n  else repeatChar(encoded[0].count, encoded[0].ch) + decode(encoded[1..])\n}\n\nfunction {:spec} repeatChar(n: nat, c: char): seq<char>\n{\n  if n == 0 then []\n  else [c] + repeatChar(n-1, c)\n}\n\nfunction encode(s: seq<char>): seq<RLE>\n{\n  if |s| == 0 then []\n  else if |s| == 1 then [RLE(1, s[0])]\n  else \n    var rest := encode(s[1..]);\n    if |rest| > 0 && rest[0].ch == s[0] then\n      [RLE(rest[0].count + 1, s[0])] + rest[1..]\n    else\n      [RLE(1, s[0])] + rest\n}\n\nlemma encodeProducesValidRLE(s: seq<char>)\n  ensures validRLE(encode(s))\n{\n  if |s| <= 1 {\n    // Base cases are trivial\n  } else {\n    var rest := encode(s[1..]);\n    encodeProducesValidRLE(s[1..]); // Recursive call for induction\n    if |rest| > 0 && rest[0].ch == s[0] {\n      // When merging, we maintain validity since we're just incrementing count\n      assert validRLE([RLE(rest[0].count + 1, s[0])] + rest[1..]);\n    } else {\n      // When not merging, s[0] != rest[0].ch (if rest is non-empty)\n      assert validRLE([RLE(1, s[0])] + rest);\n    }\n  }\n}\n\nlemma encodeDecodeRoundTrip(s: seq<char>)\n  ensures decode(encode(s)) == s\n{\n  if |s| == 0 {\n    // Base case: empty sequence\n  } else if |s| == 1 {\n    // Base case: single character\n    assert decode([RLE(1, s[0])]) == repeatChar(1, s[0]) == [s[0]] == s;\n  } else {\n    var rest := encode(s[1..]);\n    encodeDecodeRoundTrip(s[1..]); // Induction hypothesis\n    assert decode(rest) == s[1..];\n    \n    if |rest| > 0 && rest[0].ch == s[0] {\n      // Case: merging with first element of rest\n      var merged := [RLE(rest[0].count + 1, s[0])] + rest[1..];\n      assert decode(merged) == repeatChar(rest[0].count + 1, s[0]) + decode(rest[1..]);\n      assert repeatChar(rest[0].count + 1, s[0]) == [s[0]] + repeatChar(rest[0].count, s[0]);\n      assert decode(rest) == repeatChar(rest[0].count, rest[0].ch) + decode(rest[1..]);\n      assert s[0] == rest[0].ch;\n      assert decode(merged) == [s[0]] + decode(rest) == [s[0]] + s[1..] == s;\n    } else {\n      // Case: not merging\n      var result := [RLE(1, s[0])] + rest;\n      assert decode(result) == repeatChar(1, s[0]) + decode(rest);\n      assert repeatChar(1, s[0]) == [s[0]];\n      \n/*[CODE HERE]*/\n    }\n  }\n}", "output": "assert decode(result) == [s[0]] + s[1..] == s;"}, {"id": "example_encodeDecodeRoundTrip_1", "type": "assert", "program": "// Run-Length Encoding\n// RLE compresses consecutive identical characters into (count, char) pairs\n\ndatatype RLE = RLE(count: nat, ch: char)\n\npredicate {:spec} validRLE(encoded: seq<RLE>)\n{\n  forall i :: 0 <= i < |encoded| ==> \n    encoded[i].count > 0 &&\n    (i + 1 < |encoded| ==> encoded[i].ch != encoded[i+1].ch)\n}\n\nfunction {:spec} decode(encoded: seq<RLE>): seq<char>\n{\n  if |encoded| == 0 then []\n  else repeatChar(encoded[0].count, encoded[0].ch) + decode(encoded[1..])\n}\n\nfunction {:spec} repeatChar(n: nat, c: char): seq<char>\n{\n  if n == 0 then []\n  else [c] + repeatChar(n-1, c)\n}\n\nfunction encode(s: seq<char>): seq<RLE>\n{\n  if |s| == 0 then []\n  else if |s| == 1 then [RLE(1, s[0])]\n  else \n    var rest := encode(s[1..]);\n    if |rest| > 0 && rest[0].ch == s[0] then\n      [RLE(rest[0].count + 1, s[0])] + rest[1..]\n    else\n      [RLE(1, s[0])] + rest\n}\n\nlemma encodeProducesValidRLE(s: seq<char>)\n  ensures validRLE(encode(s))\n{\n  if |s| <= 1 {\n    // Base cases are trivial\n  } else {\n    var rest := encode(s[1..]);\n    encodeProducesValidRLE(s[1..]); // Recursive call for induction\n    if |rest| > 0 && rest[0].ch == s[0] {\n      // When merging, we maintain validity since we're just incrementing count\n      assert validRLE([RLE(rest[0].count + 1, s[0])] + rest[1..]);\n    } else {\n      // When not merging, s[0] != rest[0].ch (if rest is non-empty)\n      assert validRLE([RLE(1, s[0])] + rest);\n    }\n  }\n}\n\nlemma encodeDecodeRoundTrip(s: seq<char>)\n  ensures decode(encode(s)) == s\n{\n  if |s| == 0 {\n    // Base case: empty sequence\n  } else if |s| == 1 {\n    // Base case: single character\n    assert decode([RLE(1, s[0])]) == repeatChar(1, s[0]) == [s[0]] == s;\n  } else {\n    var rest := encode(s[1..]);\n    encodeDecodeRoundTrip(s[1..]); // Induction hypothesis\n    assert decode(rest) == s[1..];\n    \n    if |rest| > 0 && rest[0].ch == s[0] {\n      // Case: merging with first element of rest\n      var merged := [RLE(rest[0].count + 1, s[0])] + rest[1..];\n      assert decode(merged) == repeatChar(rest[0].count + 1, s[0]) + decode(rest[1..]);\n      assert repeatChar(rest[0].count + 1, s[0]) == [s[0]] + repeatChar(rest[0].count, s[0]);\n      assert decode(rest) == repeatChar(rest[0].count, rest[0].ch) + decode(rest[1..]);\n      assert s[0] == rest[0].ch;\n      assert decode(merged) == [s[0]] + decode(rest) == [s[0]] + s[1..] == s;\n    } else {\n      // Case: not merging\n      var result := [RLE(1, s[0])] + rest;\n      assert decode(result) == repeatChar(1, s[0]) + decode(rest);\n      \n/*[CODE HERE]*/\n      assert decode(result) == [s[0]] + s[1..] == s;\n    }\n  }\n}", "output": "assert repeatChar(1, s[0]) == [s[0]];"}, {"id": "example_encodeDecodeRoundTrip_2", "type": "assert", "program": "// Run-Length Encoding\n// RLE compresses consecutive identical characters into (count, char) pairs\n\ndatatype RLE = RLE(count: nat, ch: char)\n\npredicate {:spec} validRLE(encoded: seq<RLE>)\n{\n  forall i :: 0 <= i < |encoded| ==> \n    encoded[i].count > 0 &&\n    (i + 1 < |encoded| ==> encoded[i].ch != encoded[i+1].ch)\n}\n\nfunction {:spec} decode(encoded: seq<RLE>): seq<char>\n{\n  if |encoded| == 0 then []\n  else repeatChar(encoded[0].count, encoded[0].ch) + decode(encoded[1..])\n}\n\nfunction {:spec} repeatChar(n: nat, c: char): seq<char>\n{\n  if n == 0 then []\n  else [c] + repeatChar(n-1, c)\n}\n\nfunction encode(s: seq<char>): seq<RLE>\n{\n  if |s| == 0 then []\n  else if |s| == 1 then [RLE(1, s[0])]\n  else \n    var rest := encode(s[1..]);\n    if |rest| > 0 && rest[0].ch == s[0] then\n      [RLE(rest[0].count + 1, s[0])] + rest[1..]\n    else\n      [RLE(1, s[0])] + rest\n}\n\nlemma encodeProducesValidRLE(s: seq<char>)\n  ensures validRLE(encode(s))\n{\n  if |s| <= 1 {\n    // Base cases are trivial\n  } else {\n    var rest := encode(s[1..]);\n    encodeProducesValidRLE(s[1..]); // Recursive call for induction\n    if |rest| > 0 && rest[0].ch == s[0] {\n      // When merging, we maintain validity since we're just incrementing count\n      assert validRLE([RLE(rest[0].count + 1, s[0])] + rest[1..]);\n    } else {\n      // When not merging, s[0] != rest[0].ch (if rest is non-empty)\n      assert validRLE([RLE(1, s[0])] + rest);\n    }\n  }\n}\n\nlemma encodeDecodeRoundTrip(s: seq<char>)\n  ensures decode(encode(s)) == s\n{\n  if |s| == 0 {\n    // Base case: empty sequence\n  } else if |s| == 1 {\n    // Base case: single character\n    assert decode([RLE(1, s[0])]) == repeatChar(1, s[0]) == [s[0]] == s;\n  } else {\n    var rest := encode(s[1..]);\n    encodeDecodeRoundTrip(s[1..]); // Induction hypothesis\n    assert decode(rest) == s[1..];\n    \n    if |rest| > 0 && rest[0].ch == s[0] {\n      // Case: merging with first element of rest\n      var merged := [RLE(rest[0].count + 1, s[0])] + rest[1..];\n      assert decode(merged) == repeatChar(rest[0].count + 1, s[0]) + decode(rest[1..]);\n      assert repeatChar(rest[0].count + 1, s[0]) == [s[0]] + repeatChar(rest[0].count, s[0]);\n      assert decode(rest) == repeatChar(rest[0].count, rest[0].ch) + decode(rest[1..]);\n      assert s[0] == rest[0].ch;\n      assert decode(merged) == [s[0]] + decode(rest) == [s[0]] + s[1..] == s;\n    } else {\n      // Case: not merging\n      var result := [RLE(1, s[0])] + rest;\n      \n/*[CODE HERE]*/\n      assert repeatChar(1, s[0]) == [s[0]];\n      assert decode(result) == [s[0]] + s[1..] == s;\n    }\n  }\n}", "output": "assert decode(result) == repeatChar(1, s[0]) + decode(rest);"}, {"id": "example_encodeDecodeRoundTrip_3", "type": "assert", "program": "// Run-Length Encoding\n// RLE compresses consecutive identical characters into (count, char) pairs\n\ndatatype RLE = RLE(count: nat, ch: char)\n\npredicate {:spec} validRLE(encoded: seq<RLE>)\n{\n  forall i :: 0 <= i < |encoded| ==> \n    encoded[i].count > 0 &&\n    (i + 1 < |encoded| ==> encoded[i].ch != encoded[i+1].ch)\n}\n\nfunction {:spec} decode(encoded: seq<RLE>): seq<char>\n{\n  if |encoded| == 0 then []\n  else repeatChar(encoded[0].count, encoded[0].ch) + decode(encoded[1..])\n}\n\nfunction {:spec} repeatChar(n: nat, c: char): seq<char>\n{\n  if n == 0 then []\n  else [c] + repeatChar(n-1, c)\n}\n\nfunction encode(s: seq<char>): seq<RLE>\n{\n  if |s| == 0 then []\n  else if |s| == 1 then [RLE(1, s[0])]\n  else \n    var rest := encode(s[1..]);\n    if |rest| > 0 && rest[0].ch == s[0] then\n      [RLE(rest[0].count + 1, s[0])] + rest[1..]\n    else\n      [RLE(1, s[0])] + rest\n}\n\nlemma encodeProducesValidRLE(s: seq<char>)\n  ensures validRLE(encode(s))\n{\n  if |s| <= 1 {\n    // Base cases are trivial\n  } else {\n    var rest := encode(s[1..]);\n    encodeProducesValidRLE(s[1..]); // Recursive call for induction\n    if |rest| > 0 && rest[0].ch == s[0] {\n      // When merging, we maintain validity since we're just incrementing count\n      assert validRLE([RLE(rest[0].count + 1, s[0])] + rest[1..]);\n    } else {\n      // When not merging, s[0] != rest[0].ch (if rest is non-empty)\n      assert validRLE([RLE(1, s[0])] + rest);\n    }\n  }\n}\n\nlemma encodeDecodeRoundTrip(s: seq<char>)\n  ensures decode(encode(s)) == s\n{\n  if |s| == 0 {\n    // Base case: empty sequence\n  } else if |s| == 1 {\n    // Base case: single character\n    assert decode([RLE(1, s[0])]) == repeatChar(1, s[0]) == [s[0]] == s;\n  } else {\n    var rest := encode(s[1..]);\n    encodeDecodeRoundTrip(s[1..]); // Induction hypothesis\n    assert decode(rest) == s[1..];\n    \n    if |rest| > 0 && rest[0].ch == s[0] {\n      // Case: merging with first element of rest\n      var merged := [RLE(rest[0].count + 1, s[0])] + rest[1..];\n      assert decode(merged) == repeatChar(rest[0].count + 1, s[0]) + decode(rest[1..]);\n      assert repeatChar(rest[0].count + 1, s[0]) == [s[0]] + repeatChar(rest[0].count, s[0]);\n      assert decode(rest) == repeatChar(rest[0].count, rest[0].ch) + decode(rest[1..]);\n      assert s[0] == rest[0].ch;\n      \n/*[CODE HERE]*/\n    } else {\n      // Case: not merging\n      var result := [RLE(1, s[0])] + rest;\n      assert decode(result) == repeatChar(1, s[0]) + decode(rest);\n      assert repeatChar(1, s[0]) == [s[0]];\n      assert decode(result) == [s[0]] + s[1..] == s;\n    }\n  }\n}", "output": "assert decode(merged) == [s[0]] + decode(rest) == [s[0]] + s[1..] == s;"}, {"id": "example_encodeDecodeRoundTrip_4", "type": "assert", "program": "// Run-Length Encoding\n// RLE compresses consecutive identical characters into (count, char) pairs\n\ndatatype RLE = RLE(count: nat, ch: char)\n\npredicate {:spec} validRLE(encoded: seq<RLE>)\n{\n  forall i :: 0 <= i < |encoded| ==> \n    encoded[i].count > 0 &&\n    (i + 1 < |encoded| ==> encoded[i].ch != encoded[i+1].ch)\n}\n\nfunction {:spec} decode(encoded: seq<RLE>): seq<char>\n{\n  if |encoded| == 0 then []\n  else repeatChar(encoded[0].count, encoded[0].ch) + decode(encoded[1..])\n}\n\nfunction {:spec} repeatChar(n: nat, c: char): seq<char>\n{\n  if n == 0 then []\n  else [c] + repeatChar(n-1, c)\n}\n\nfunction encode(s: seq<char>): seq<RLE>\n{\n  if |s| == 0 then []\n  else if |s| == 1 then [RLE(1, s[0])]\n  else \n    var rest := encode(s[1..]);\n    if |rest| > 0 && rest[0].ch == s[0] then\n      [RLE(rest[0].count + 1, s[0])] + rest[1..]\n    else\n      [RLE(1, s[0])] + rest\n}\n\nlemma encodeProducesValidRLE(s: seq<char>)\n  ensures validRLE(encode(s))\n{\n  if |s| <= 1 {\n    // Base cases are trivial\n  } else {\n    var rest := encode(s[1..]);\n    encodeProducesValidRLE(s[1..]); // Recursive call for induction\n    if |rest| > 0 && rest[0].ch == s[0] {\n      // When merging, we maintain validity since we're just incrementing count\n      assert validRLE([RLE(rest[0].count + 1, s[0])] + rest[1..]);\n    } else {\n      // When not merging, s[0] != rest[0].ch (if rest is non-empty)\n      assert validRLE([RLE(1, s[0])] + rest);\n    }\n  }\n}\n\nlemma encodeDecodeRoundTrip(s: seq<char>)\n  ensures decode(encode(s)) == s\n{\n  if |s| == 0 {\n    // Base case: empty sequence\n  } else if |s| == 1 {\n    // Base case: single character\n    assert decode([RLE(1, s[0])]) == repeatChar(1, s[0]) == [s[0]] == s;\n  } else {\n    var rest := encode(s[1..]);\n    encodeDecodeRoundTrip(s[1..]); // Induction hypothesis\n    assert decode(rest) == s[1..];\n    \n    if |rest| > 0 && rest[0].ch == s[0] {\n      // Case: merging with first element of rest\n      var merged := [RLE(rest[0].count + 1, s[0])] + rest[1..];\n      assert decode(merged) == repeatChar(rest[0].count + 1, s[0]) + decode(rest[1..]);\n      assert repeatChar(rest[0].count + 1, s[0]) == [s[0]] + repeatChar(rest[0].count, s[0]);\n      assert decode(rest) == repeatChar(rest[0].count, rest[0].ch) + decode(rest[1..]);\n      \n/*[CODE HERE]*/\n      assert decode(merged) == [s[0]] + decode(rest) == [s[0]] + s[1..] == s;\n    } else {\n      // Case: not merging\n      var result := [RLE(1, s[0])] + rest;\n      assert decode(result) == repeatChar(1, s[0]) + decode(rest);\n      assert repeatChar(1, s[0]) == [s[0]];\n      assert decode(result) == [s[0]] + s[1..] == s;\n    }\n  }\n}", "output": "assert s[0] == rest[0].ch;"}, {"id": "example_encodeDecodeRoundTrip_5", "type": "assert", "program": "// Run-Length Encoding\n// RLE compresses consecutive identical characters into (count, char) pairs\n\ndatatype RLE = RLE(count: nat, ch: char)\n\npredicate {:spec} validRLE(encoded: seq<RLE>)\n{\n  forall i :: 0 <= i < |encoded| ==> \n    encoded[i].count > 0 &&\n    (i + 1 < |encoded| ==> encoded[i].ch != encoded[i+1].ch)\n}\n\nfunction {:spec} decode(encoded: seq<RLE>): seq<char>\n{\n  if |encoded| == 0 then []\n  else repeatChar(encoded[0].count, encoded[0].ch) + decode(encoded[1..])\n}\n\nfunction {:spec} repeatChar(n: nat, c: char): seq<char>\n{\n  if n == 0 then []\n  else [c] + repeatChar(n-1, c)\n}\n\nfunction encode(s: seq<char>): seq<RLE>\n{\n  if |s| == 0 then []\n  else if |s| == 1 then [RLE(1, s[0])]\n  else \n    var rest := encode(s[1..]);\n    if |rest| > 0 && rest[0].ch == s[0] then\n      [RLE(rest[0].count + 1, s[0])] + rest[1..]\n    else\n      [RLE(1, s[0])] + rest\n}\n\nlemma encodeProducesValidRLE(s: seq<char>)\n  ensures validRLE(encode(s))\n{\n  if |s| <= 1 {\n    // Base cases are trivial\n  } else {\n    var rest := encode(s[1..]);\n    encodeProducesValidRLE(s[1..]); // Recursive call for induction\n    if |rest| > 0 && rest[0].ch == s[0] {\n      // When merging, we maintain validity since we're just incrementing count\n      assert validRLE([RLE(rest[0].count + 1, s[0])] + rest[1..]);\n    } else {\n      // When not merging, s[0] != rest[0].ch (if rest is non-empty)\n      assert validRLE([RLE(1, s[0])] + rest);\n    }\n  }\n}\n\nlemma encodeDecodeRoundTrip(s: seq<char>)\n  ensures decode(encode(s)) == s\n{\n  if |s| == 0 {\n    // Base case: empty sequence\n  } else if |s| == 1 {\n    // Base case: single character\n    assert decode([RLE(1, s[0])]) == repeatChar(1, s[0]) == [s[0]] == s;\n  } else {\n    var rest := encode(s[1..]);\n    encodeDecodeRoundTrip(s[1..]); // Induction hypothesis\n    assert decode(rest) == s[1..];\n    \n    if |rest| > 0 && rest[0].ch == s[0] {\n      // Case: merging with first element of rest\n      var merged := [RLE(rest[0].count + 1, s[0])] + rest[1..];\n      assert decode(merged) == repeatChar(rest[0].count + 1, s[0]) + decode(rest[1..]);\n      assert repeatChar(rest[0].count + 1, s[0]) == [s[0]] + repeatChar(rest[0].count, s[0]);\n      \n/*[CODE HERE]*/\n      assert s[0] == rest[0].ch;\n      assert decode(merged) == [s[0]] + decode(rest) == [s[0]] + s[1..] == s;\n    } else {\n      // Case: not merging\n      var result := [RLE(1, s[0])] + rest;\n      assert decode(result) == repeatChar(1, s[0]) + decode(rest);\n      assert repeatChar(1, s[0]) == [s[0]];\n      assert decode(result) == [s[0]] + s[1..] == s;\n    }\n  }\n}", "output": "assert decode(rest) == repeatChar(rest[0].count, rest[0].ch) + decode(rest[1..]);"}, {"id": "example_encodeDecodeRoundTrip_6", "type": "assert", "program": "// Run-Length Encoding\n// RLE compresses consecutive identical characters into (count, char) pairs\n\ndatatype RLE = RLE(count: nat, ch: char)\n\npredicate {:spec} validRLE(encoded: seq<RLE>)\n{\n  forall i :: 0 <= i < |encoded| ==> \n    encoded[i].count > 0 &&\n    (i + 1 < |encoded| ==> encoded[i].ch != encoded[i+1].ch)\n}\n\nfunction {:spec} decode(encoded: seq<RLE>): seq<char>\n{\n  if |encoded| == 0 then []\n  else repeatChar(encoded[0].count, encoded[0].ch) + decode(encoded[1..])\n}\n\nfunction {:spec} repeatChar(n: nat, c: char): seq<char>\n{\n  if n == 0 then []\n  else [c] + repeatChar(n-1, c)\n}\n\nfunction encode(s: seq<char>): seq<RLE>\n{\n  if |s| == 0 then []\n  else if |s| == 1 then [RLE(1, s[0])]\n  else \n    var rest := encode(s[1..]);\n    if |rest| > 0 && rest[0].ch == s[0] then\n      [RLE(rest[0].count + 1, s[0])] + rest[1..]\n    else\n      [RLE(1, s[0])] + rest\n}\n\nlemma encodeProducesValidRLE(s: seq<char>)\n  ensures validRLE(encode(s))\n{\n  if |s| <= 1 {\n    // Base cases are trivial\n  } else {\n    var rest := encode(s[1..]);\n    encodeProducesValidRLE(s[1..]); // Recursive call for induction\n    if |rest| > 0 && rest[0].ch == s[0] {\n      // When merging, we maintain validity since we're just incrementing count\n      assert validRLE([RLE(rest[0].count + 1, s[0])] + rest[1..]);\n    } else {\n      // When not merging, s[0] != rest[0].ch (if rest is non-empty)\n      assert validRLE([RLE(1, s[0])] + rest);\n    }\n  }\n}\n\nlemma encodeDecodeRoundTrip(s: seq<char>)\n  ensures decode(encode(s)) == s\n{\n  if |s| == 0 {\n    // Base case: empty sequence\n  } else if |s| == 1 {\n    // Base case: single character\n    assert decode([RLE(1, s[0])]) == repeatChar(1, s[0]) == [s[0]] == s;\n  } else {\n    var rest := encode(s[1..]);\n    encodeDecodeRoundTrip(s[1..]); // Induction hypothesis\n    assert decode(rest) == s[1..];\n    \n    if |rest| > 0 && rest[0].ch == s[0] {\n      // Case: merging with first element of rest\n      var merged := [RLE(rest[0].count + 1, s[0])] + rest[1..];\n      assert decode(merged) == repeatChar(rest[0].count + 1, s[0]) + decode(rest[1..]);\n      \n/*[CODE HERE]*/\n      assert decode(rest) == repeatChar(rest[0].count, rest[0].ch) + decode(rest[1..]);\n      assert s[0] == rest[0].ch;\n      assert decode(merged) == [s[0]] + decode(rest) == [s[0]] + s[1..] == s;\n    } else {\n      // Case: not merging\n      var result := [RLE(1, s[0])] + rest;\n      assert decode(result) == repeatChar(1, s[0]) + decode(rest);\n      assert repeatChar(1, s[0]) == [s[0]];\n      assert decode(result) == [s[0]] + s[1..] == s;\n    }\n  }\n}", "output": "assert repeatChar(rest[0].count + 1, s[0]) == [s[0]] + repeatChar(rest[0].count, s[0]);"}, {"id": "example_encodeDecodeRoundTrip_7", "type": "assert", "program": "// Run-Length Encoding\n// RLE compresses consecutive identical characters into (count, char) pairs\n\ndatatype RLE = RLE(count: nat, ch: char)\n\npredicate {:spec} validRLE(encoded: seq<RLE>)\n{\n  forall i :: 0 <= i < |encoded| ==> \n    encoded[i].count > 0 &&\n    (i + 1 < |encoded| ==> encoded[i].ch != encoded[i+1].ch)\n}\n\nfunction {:spec} decode(encoded: seq<RLE>): seq<char>\n{\n  if |encoded| == 0 then []\n  else repeatChar(encoded[0].count, encoded[0].ch) + decode(encoded[1..])\n}\n\nfunction {:spec} repeatChar(n: nat, c: char): seq<char>\n{\n  if n == 0 then []\n  else [c] + repeatChar(n-1, c)\n}\n\nfunction encode(s: seq<char>): seq<RLE>\n{\n  if |s| == 0 then []\n  else if |s| == 1 then [RLE(1, s[0])]\n  else \n    var rest := encode(s[1..]);\n    if |rest| > 0 && rest[0].ch == s[0] then\n      [RLE(rest[0].count + 1, s[0])] + rest[1..]\n    else\n      [RLE(1, s[0])] + rest\n}\n\nlemma encodeProducesValidRLE(s: seq<char>)\n  ensures validRLE(encode(s))\n{\n  if |s| <= 1 {\n    // Base cases are trivial\n  } else {\n    var rest := encode(s[1..]);\n    encodeProducesValidRLE(s[1..]); // Recursive call for induction\n    if |rest| > 0 && rest[0].ch == s[0] {\n      // When merging, we maintain validity since we're just incrementing count\n      assert validRLE([RLE(rest[0].count + 1, s[0])] + rest[1..]);\n    } else {\n      // When not merging, s[0] != rest[0].ch (if rest is non-empty)\n      assert validRLE([RLE(1, s[0])] + rest);\n    }\n  }\n}\n\nlemma encodeDecodeRoundTrip(s: seq<char>)\n  ensures decode(encode(s)) == s\n{\n  if |s| == 0 {\n    // Base case: empty sequence\n  } else if |s| == 1 {\n    // Base case: single character\n    assert decode([RLE(1, s[0])]) == repeatChar(1, s[0]) == [s[0]] == s;\n  } else {\n    var rest := encode(s[1..]);\n    encodeDecodeRoundTrip(s[1..]); // Induction hypothesis\n    assert decode(rest) == s[1..];\n    \n    if |rest| > 0 && rest[0].ch == s[0] {\n      // Case: merging with first element of rest\n      var merged := [RLE(rest[0].count + 1, s[0])] + rest[1..];\n      \n/*[CODE HERE]*/\n      assert repeatChar(rest[0].count + 1, s[0]) == [s[0]] + repeatChar(rest[0].count, s[0]);\n      assert decode(rest) == repeatChar(rest[0].count, rest[0].ch) + decode(rest[1..]);\n      assert s[0] == rest[0].ch;\n      assert decode(merged) == [s[0]] + decode(rest) == [s[0]] + s[1..] == s;\n    } else {\n      // Case: not merging\n      var result := [RLE(1, s[0])] + rest;\n      assert decode(result) == repeatChar(1, s[0]) + decode(rest);\n      assert repeatChar(1, s[0]) == [s[0]];\n      assert decode(result) == [s[0]] + s[1..] == s;\n    }\n  }\n}", "output": "assert decode(merged) == repeatChar(rest[0].count + 1, s[0]) + decode(rest[1..]);"}, {"id": "example_encodeDecodeRoundTrip_8", "type": "assert", "program": "// Run-Length Encoding\n// RLE compresses consecutive identical characters into (count, char) pairs\n\ndatatype RLE = RLE(count: nat, ch: char)\n\npredicate {:spec} validRLE(encoded: seq<RLE>)\n{\n  forall i :: 0 <= i < |encoded| ==> \n    encoded[i].count > 0 &&\n    (i + 1 < |encoded| ==> encoded[i].ch != encoded[i+1].ch)\n}\n\nfunction {:spec} decode(encoded: seq<RLE>): seq<char>\n{\n  if |encoded| == 0 then []\n  else repeatChar(encoded[0].count, encoded[0].ch) + decode(encoded[1..])\n}\n\nfunction {:spec} repeatChar(n: nat, c: char): seq<char>\n{\n  if n == 0 then []\n  else [c] + repeatChar(n-1, c)\n}\n\nfunction encode(s: seq<char>): seq<RLE>\n{\n  if |s| == 0 then []\n  else if |s| == 1 then [RLE(1, s[0])]\n  else \n    var rest := encode(s[1..]);\n    if |rest| > 0 && rest[0].ch == s[0] then\n      [RLE(rest[0].count + 1, s[0])] + rest[1..]\n    else\n      [RLE(1, s[0])] + rest\n}\n\nlemma encodeProducesValidRLE(s: seq<char>)\n  ensures validRLE(encode(s))\n{\n  if |s| <= 1 {\n    // Base cases are trivial\n  } else {\n    var rest := encode(s[1..]);\n    encodeProducesValidRLE(s[1..]); // Recursive call for induction\n    if |rest| > 0 && rest[0].ch == s[0] {\n      // When merging, we maintain validity since we're just incrementing count\n      assert validRLE([RLE(rest[0].count + 1, s[0])] + rest[1..]);\n    } else {\n      // When not merging, s[0] != rest[0].ch (if rest is non-empty)\n      assert validRLE([RLE(1, s[0])] + rest);\n    }\n  }\n}\n\nlemma encodeDecodeRoundTrip(s: seq<char>)\n  ensures decode(encode(s)) == s\n{\n  if |s| == 0 {\n    // Base case: empty sequence\n  } else if |s| == 1 {\n    // Base case: single character\n    assert decode([RLE(1, s[0])]) == repeatChar(1, s[0]) == [s[0]] == s;\n  } else {\n    var rest := encode(s[1..]);\n    encodeDecodeRoundTrip(s[1..]); // Induction hypothesis\n    \n/*[CODE HERE]*/\n    \n    if |rest| > 0 && rest[0].ch == s[0] {\n      // Case: merging with first element of rest\n      var merged := [RLE(rest[0].count + 1, s[0])] + rest[1..];\n      assert decode(merged) == repeatChar(rest[0].count + 1, s[0]) + decode(rest[1..]);\n      assert repeatChar(rest[0].count + 1, s[0]) == [s[0]] + repeatChar(rest[0].count, s[0]);\n      assert decode(rest) == repeatChar(rest[0].count, rest[0].ch) + decode(rest[1..]);\n      assert s[0] == rest[0].ch;\n      assert decode(merged) == [s[0]] + decode(rest) == [s[0]] + s[1..] == s;\n    } else {\n      // Case: not merging\n      var result := [RLE(1, s[0])] + rest;\n      assert decode(result) == repeatChar(1, s[0]) + decode(rest);\n      assert repeatChar(1, s[0]) == [s[0]];\n      assert decode(result) == [s[0]] + s[1..] == s;\n    }\n  }\n}", "output": "assert decode(rest) == s[1..];"}, {"id": "example_encodeDecodeRoundTrip_9", "type": "call", "program": "// Run-Length Encoding\n// RLE compresses consecutive identical characters into (count, char) pairs\n\ndatatype RLE = RLE(count: nat, ch: char)\n\npredicate {:spec} validRLE(encoded: seq<RLE>)\n{\n  forall i :: 0 <= i < |encoded| ==> \n    encoded[i].count > 0 &&\n    (i + 1 < |encoded| ==> encoded[i].ch != encoded[i+1].ch)\n}\n\nfunction {:spec} decode(encoded: seq<RLE>): seq<char>\n{\n  if |encoded| == 0 then []\n  else repeatChar(encoded[0].count, encoded[0].ch) + decode(encoded[1..])\n}\n\nfunction {:spec} repeatChar(n: nat, c: char): seq<char>\n{\n  if n == 0 then []\n  else [c] + repeatChar(n-1, c)\n}\n\nfunction encode(s: seq<char>): seq<RLE>\n{\n  if |s| == 0 then []\n  else if |s| == 1 then [RLE(1, s[0])]\n  else \n    var rest := encode(s[1..]);\n    if |rest| > 0 && rest[0].ch == s[0] then\n      [RLE(rest[0].count + 1, s[0])] + rest[1..]\n    else\n      [RLE(1, s[0])] + rest\n}\n\nlemma encodeProducesValidRLE(s: seq<char>)\n  ensures validRLE(encode(s))\n{\n  if |s| <= 1 {\n    // Base cases are trivial\n  } else {\n    var rest := encode(s[1..]);\n    encodeProducesValidRLE(s[1..]); // Recursive call for induction\n    if |rest| > 0 && rest[0].ch == s[0] {\n      // When merging, we maintain validity since we're just incrementing count\n      assert validRLE([RLE(rest[0].count + 1, s[0])] + rest[1..]);\n    } else {\n      // When not merging, s[0] != rest[0].ch (if rest is non-empty)\n      assert validRLE([RLE(1, s[0])] + rest);\n    }\n  }\n}\n\nlemma encodeDecodeRoundTrip(s: seq<char>)\n  ensures decode(encode(s)) == s\n{\n  if |s| == 0 {\n    // Base case: empty sequence\n  } else if |s| == 1 {\n    // Base case: single character\n    assert decode([RLE(1, s[0])]) == repeatChar(1, s[0]) == [s[0]] == s;\n  } else {\n    var rest := encode(s[1..]);\n    \n/*[CODE HERE]*/\n// Induction hypothesis\n    assert decode(rest) == s[1..];\n    \n    if |rest| > 0 && rest[0].ch == s[0] {\n      // Case: merging with first element of rest\n      var merged := [RLE(rest[0].count + 1, s[0])] + rest[1..];\n      assert decode(merged) == repeatChar(rest[0].count + 1, s[0]) + decode(rest[1..]);\n      assert repeatChar(rest[0].count + 1, s[0]) == [s[0]] + repeatChar(rest[0].count, s[0]);\n      assert decode(rest) == repeatChar(rest[0].count, rest[0].ch) + decode(rest[1..]);\n      assert s[0] == rest[0].ch;\n      assert decode(merged) == [s[0]] + decode(rest) == [s[0]] + s[1..] == s;\n    } else {\n      // Case: not merging\n      var result := [RLE(1, s[0])] + rest;\n      assert decode(result) == repeatChar(1, s[0]) + decode(rest);\n      assert repeatChar(1, s[0]) == [s[0]];\n      assert decode(result) == [s[0]] + s[1..] == s;\n    }\n  }\n}", "output": "encodeDecodeRoundTrip(s[1..]);"}, {"id": "example_encodeDecodeRoundTrip_10", "type": "assert", "program": "// Run-Length Encoding\n// RLE compresses consecutive identical characters into (count, char) pairs\n\ndatatype RLE = RLE(count: nat, ch: char)\n\npredicate {:spec} validRLE(encoded: seq<RLE>)\n{\n  forall i :: 0 <= i < |encoded| ==> \n    encoded[i].count > 0 &&\n    (i + 1 < |encoded| ==> encoded[i].ch != encoded[i+1].ch)\n}\n\nfunction {:spec} decode(encoded: seq<RLE>): seq<char>\n{\n  if |encoded| == 0 then []\n  else repeatChar(encoded[0].count, encoded[0].ch) + decode(encoded[1..])\n}\n\nfunction {:spec} repeatChar(n: nat, c: char): seq<char>\n{\n  if n == 0 then []\n  else [c] + repeatChar(n-1, c)\n}\n\nfunction encode(s: seq<char>): seq<RLE>\n{\n  if |s| == 0 then []\n  else if |s| == 1 then [RLE(1, s[0])]\n  else \n    var rest := encode(s[1..]);\n    if |rest| > 0 && rest[0].ch == s[0] then\n      [RLE(rest[0].count + 1, s[0])] + rest[1..]\n    else\n      [RLE(1, s[0])] + rest\n}\n\nlemma encodeProducesValidRLE(s: seq<char>)\n  ensures validRLE(encode(s))\n{\n  if |s| <= 1 {\n    // Base cases are trivial\n  } else {\n    var rest := encode(s[1..]);\n    encodeProducesValidRLE(s[1..]); // Recursive call for induction\n    if |rest| > 0 && rest[0].ch == s[0] {\n      // When merging, we maintain validity since we're just incrementing count\n      assert validRLE([RLE(rest[0].count + 1, s[0])] + rest[1..]);\n    } else {\n      // When not merging, s[0] != rest[0].ch (if rest is non-empty)\n      assert validRLE([RLE(1, s[0])] + rest);\n    }\n  }\n}\n\nlemma encodeDecodeRoundTrip(s: seq<char>)\n  ensures decode(encode(s)) == s\n{\n  if |s| == 0 {\n    // Base case: empty sequence\n  } else if |s| == 1 {\n    // Base case: single character\n    \n/*[CODE HERE]*/\n  } else {\n    var rest := encode(s[1..]);\n    encodeDecodeRoundTrip(s[1..]); // Induction hypothesis\n    assert decode(rest) == s[1..];\n    \n    if |rest| > 0 && rest[0].ch == s[0] {\n      // Case: merging with first element of rest\n      var merged := [RLE(rest[0].count + 1, s[0])] + rest[1..];\n      assert decode(merged) == repeatChar(rest[0].count + 1, s[0]) + decode(rest[1..]);\n      assert repeatChar(rest[0].count + 1, s[0]) == [s[0]] + repeatChar(rest[0].count, s[0]);\n      assert decode(rest) == repeatChar(rest[0].count, rest[0].ch) + decode(rest[1..]);\n      assert s[0] == rest[0].ch;\n      assert decode(merged) == [s[0]] + decode(rest) == [s[0]] + s[1..] == s;\n    } else {\n      // Case: not merging\n      var result := [RLE(1, s[0])] + rest;\n      assert decode(result) == repeatChar(1, s[0]) + decode(rest);\n      assert repeatChar(1, s[0]) == [s[0]];\n      assert decode(result) == [s[0]] + s[1..] == s;\n    }\n  }\n}", "output": "assert decode([RLE(1, s[0])]) == repeatChar(1, s[0]) == [s[0]] == s;"}, {"id": "example_PowersetSubsetProperty_0", "type": "call", "program": "// Set operations: union, intersection, difference, subset\n\nfunction {:spec} setUnion<T>(s1: set<T>, s2: set<T>): set<T>\n{\n  s1 + s2\n}\n\nfunction {:spec} setIntersection<T>(s1: set<T>, s2: set<T>): set<T>\n{\n  s1 * s2\n}\n\nfunction {:spec} setDifference<T>(s1: set<T>, s2: set<T>): set<T>\n{\n  s1 - s2\n}\n\npredicate {:spec} isSubset<T>(s1: set<T>, s2: set<T>)\n{\n  s1 <= s2\n}\n\npredicate {:spec} isProperSubset<T>(s1: set<T>, s2: set<T>)\n{\n  s1 < s2\n}\n\npredicate {:spec} areDisjoint<T>(s1: set<T>, s2: set<T>)\n{\n  s1 !! s2\n}\n\n// Powerset is defined as a ghost function since it's not compilable\n// due to the nondeterministic choice of element\nghost function {:spec} powerset<T>(s: set<T>): set<set<T>>\n  decreases s\n{\n  if s == {} then {{}}\n  else\n    var x :| x in s;\n    var rest := s - {x};\n    var restPower := powerset(rest);\n    restPower + set ps | ps in restPower :: ps + {x}\n}\n\nfunction {:spec} setSize<T>(s: set<T>): nat\n{\n  |s|\n}\n\npredicate {:spec} isEmpty<T>(s: set<T>)\n{\n  s == {}\n}\n\nfunction {:spec} setSingleton<T>(x: T): set<T>\n{\n  {x}\n}\n\nlemma UnionCommutative<T>(s1: set<T>, s2: set<T>)\n  ensures setUnion(s1, s2) == setUnion(s2, s1)\n{\n  // Dafny proves this automatically\n}\n\nlemma UnionAssociative<T>(s1: set<T>, s2: set<T>, s3: set<T>)\n  ensures setUnion(setUnion(s1, s2), s3) == setUnion(s1, setUnion(s2, s3))\n{\n  // Dafny proves this automatically\n}\n\nlemma UnionIdentity<T>(s: set<T>)\n  ensures setUnion(s, {}) == s\n  ensures setUnion({}, s) == s\n{\n  // Dafny proves this automatically\n}\n\nlemma IntersectionCommutative<T>(s1: set<T>, s2: set<T>)\n  ensures setIntersection(s1, s2) == setIntersection(s2, s1)\n{\n  // Dafny proves this automatically\n}\n\nlemma IntersectionAssociative<T>(s1: set<T>, s2: set<T>, s3: set<T>)\n  ensures setIntersection(setIntersection(s1, s2), s3) == setIntersection(s1, setIntersection(s2, s3))\n{\n  // Dafny proves this automatically\n}\n\nlemma IntersectionDistributive<T>(s1: set<T>, s2: set<T>, s3: set<T>)\n  ensures setIntersection(s1, setUnion(s2, s3)) == setUnion(setIntersection(s1, s2), setIntersection(s1, s3))\n{\n  // Dafny proves this automatically\n}\n\nlemma UnionDistributive<T>(s1: set<T>, s2: set<T>, s3: set<T>)\n  ensures setUnion(s1, setIntersection(s2, s3)) == setIntersection(setUnion(s1, s2), setUnion(s1, s3))\n{\n  // Dafny proves this automatically\n}\n\nlemma DifferenceProperties<T>(s1: set<T>, s2: set<T>)\n  ensures setDifference(s1, s2) <= s1\n  ensures areDisjoint(setDifference(s1, s2), s2)\n  ensures setUnion(setDifference(s1, s2), setIntersection(s1, s2)) == s1\n{\n  // Dafny proves this automatically\n}\n\nlemma SubsetTransitive<T>(s1: set<T>, s2: set<T>, s3: set<T>)\n  requires isSubset(s1, s2) && isSubset(s2, s3)\n  ensures isSubset(s1, s3)\n{\n  // Dafny proves this automatically\n}\n\nlemma SubsetAntisymmetric<T>(s1: set<T>, s2: set<T>)\n  requires isSubset(s1, s2) && isSubset(s2, s1)\n  ensures s1 == s2\n{\n  // Dafny proves this automatically\n}\n\nlemma PowersetEmpty<T>(s: set<T>)\n  requires s == {}\n  ensures powerset(s) == {{}}\n{\n  // By definition\n}\n\nlemma PowersetSubsetProperty<T>(s: set<T>)\n  ensures forall t :: t in powerset(s) ==> t <= s\n  decreases s\n{\n  if s == {} {\n    assert powerset(s) == {{}};\n  } else {\n    var x :| x in s;\n    var rest := s - {x};\n    \n/*[CODE HERE]*/\n  }\n}\n\nfunction Power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1\n  else base * Power(base, exp - 1)\n}\n\nlemma PowerProduct(base: nat, exp: nat)\n  requires exp > 0\n  ensures Power(base, exp) == base * Power(base, exp - 1)\n{\n  // By definition\n}\n\nlemma DeMorgan<T>(s1: set<T>, s2: set<T>, universe: set<T>)\n  requires s1 <= universe && s2 <= universe\n  ensures setDifference(universe, setUnion(s1, s2)) == setIntersection(setDifference(universe, s1), setDifference(universe, s2))\n  ensures setDifference(universe, setIntersection(s1, s2)) == setUnion(setDifference(universe, s1), setDifference(universe, s2))\n{\n  // Dafny proves this automatically\n}", "output": "PowersetSubsetProperty(rest);"}, {"id": "example_PowersetSubsetProperty_1", "type": "assert", "program": "// Set operations: union, intersection, difference, subset\n\nfunction {:spec} setUnion<T>(s1: set<T>, s2: set<T>): set<T>\n{\n  s1 + s2\n}\n\nfunction {:spec} setIntersection<T>(s1: set<T>, s2: set<T>): set<T>\n{\n  s1 * s2\n}\n\nfunction {:spec} setDifference<T>(s1: set<T>, s2: set<T>): set<T>\n{\n  s1 - s2\n}\n\npredicate {:spec} isSubset<T>(s1: set<T>, s2: set<T>)\n{\n  s1 <= s2\n}\n\npredicate {:spec} isProperSubset<T>(s1: set<T>, s2: set<T>)\n{\n  s1 < s2\n}\n\npredicate {:spec} areDisjoint<T>(s1: set<T>, s2: set<T>)\n{\n  s1 !! s2\n}\n\n// Powerset is defined as a ghost function since it's not compilable\n// due to the nondeterministic choice of element\nghost function {:spec} powerset<T>(s: set<T>): set<set<T>>\n  decreases s\n{\n  if s == {} then {{}}\n  else\n    var x :| x in s;\n    var rest := s - {x};\n    var restPower := powerset(rest);\n    restPower + set ps | ps in restPower :: ps + {x}\n}\n\nfunction {:spec} setSize<T>(s: set<T>): nat\n{\n  |s|\n}\n\npredicate {:spec} isEmpty<T>(s: set<T>)\n{\n  s == {}\n}\n\nfunction {:spec} setSingleton<T>(x: T): set<T>\n{\n  {x}\n}\n\nlemma UnionCommutative<T>(s1: set<T>, s2: set<T>)\n  ensures setUnion(s1, s2) == setUnion(s2, s1)\n{\n  // Dafny proves this automatically\n}\n\nlemma UnionAssociative<T>(s1: set<T>, s2: set<T>, s3: set<T>)\n  ensures setUnion(setUnion(s1, s2), s3) == setUnion(s1, setUnion(s2, s3))\n{\n  // Dafny proves this automatically\n}\n\nlemma UnionIdentity<T>(s: set<T>)\n  ensures setUnion(s, {}) == s\n  ensures setUnion({}, s) == s\n{\n  // Dafny proves this automatically\n}\n\nlemma IntersectionCommutative<T>(s1: set<T>, s2: set<T>)\n  ensures setIntersection(s1, s2) == setIntersection(s2, s1)\n{\n  // Dafny proves this automatically\n}\n\nlemma IntersectionAssociative<T>(s1: set<T>, s2: set<T>, s3: set<T>)\n  ensures setIntersection(setIntersection(s1, s2), s3) == setIntersection(s1, setIntersection(s2, s3))\n{\n  // Dafny proves this automatically\n}\n\nlemma IntersectionDistributive<T>(s1: set<T>, s2: set<T>, s3: set<T>)\n  ensures setIntersection(s1, setUnion(s2, s3)) == setUnion(setIntersection(s1, s2), setIntersection(s1, s3))\n{\n  // Dafny proves this automatically\n}\n\nlemma UnionDistributive<T>(s1: set<T>, s2: set<T>, s3: set<T>)\n  ensures setUnion(s1, setIntersection(s2, s3)) == setIntersection(setUnion(s1, s2), setUnion(s1, s3))\n{\n  // Dafny proves this automatically\n}\n\nlemma DifferenceProperties<T>(s1: set<T>, s2: set<T>)\n  ensures setDifference(s1, s2) <= s1\n  ensures areDisjoint(setDifference(s1, s2), s2)\n  ensures setUnion(setDifference(s1, s2), setIntersection(s1, s2)) == s1\n{\n  // Dafny proves this automatically\n}\n\nlemma SubsetTransitive<T>(s1: set<T>, s2: set<T>, s3: set<T>)\n  requires isSubset(s1, s2) && isSubset(s2, s3)\n  ensures isSubset(s1, s3)\n{\n  // Dafny proves this automatically\n}\n\nlemma SubsetAntisymmetric<T>(s1: set<T>, s2: set<T>)\n  requires isSubset(s1, s2) && isSubset(s2, s1)\n  ensures s1 == s2\n{\n  // Dafny proves this automatically\n}\n\nlemma PowersetEmpty<T>(s: set<T>)\n  requires s == {}\n  ensures powerset(s) == {{}}\n{\n  // By definition\n}\n\nlemma PowersetSubsetProperty<T>(s: set<T>)\n  ensures forall t :: t in powerset(s) ==> t <= s\n  decreases s\n{\n  if s == {} {\n    \n/*[CODE HERE]*/\n  } else {\n    var x :| x in s;\n    var rest := s - {x};\n    PowersetSubsetProperty(rest);\n  }\n}\n\nfunction Power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1\n  else base * Power(base, exp - 1)\n}\n\nlemma PowerProduct(base: nat, exp: nat)\n  requires exp > 0\n  ensures Power(base, exp) == base * Power(base, exp - 1)\n{\n  // By definition\n}\n\nlemma DeMorgan<T>(s1: set<T>, s2: set<T>, universe: set<T>)\n  requires s1 <= universe && s2 <= universe\n  ensures setDifference(universe, setUnion(s1, s2)) == setIntersection(setDifference(universe, s1), setDifference(universe, s2))\n  ensures setDifference(universe, setIntersection(s1, s2)) == setUnion(setDifference(universe, s1), setDifference(universe, s2))\n{\n  // Dafny proves this automatically\n}", "output": "assert powerset(s) == {{}};"}, {"id": "example_RevAcc_Helper_0", "type": "call", "program": "datatype List = Nil | Cons(head: int, tail: List)\n\npredicate SortedBetween(l: List, lo: int, hi: int)\n{\n  match l\n    case Nil => true\n    case Cons(x, xs) => lo <= x < hi && SortedBetween(xs, x, hi)\n}\n\nfunction insert(l: List, x: int): List {\n  match l\n    case Nil => Cons(x, Nil)\n    case Cons(y, ys) =>\n      if x < y then Cons(x, l) else Cons(y, insert(ys, x))\n}\n\nlemma InsertPreservesSortedBetween(l: List, x: int, lo: int, hi: int)\n  requires SortedBetween(l, lo, hi)\n  requires lo <= x < hi\n  ensures  SortedBetween(insert(l, x), lo, hi)\n{\n}\n\nfunction app(xs: List, ys: List): List {\n  match xs\n    case Nil => ys\n    case Cons(x, xs') => Cons(x, app(xs', ys))\n}\n\nfunction revAcc(xs: List, acc: List): List {\n  match xs\n    case Nil => acc\n    case Cons(x, xs') => revAcc(xs', Cons(x, acc))\n}\n\nlemma RevAcc_Helper(xs: List, acc: List)\n  ensures revAcc(xs, acc) == app(revAcc(xs, Nil), acc)\n{\n  match xs {\n    case Nil => \n      assert revAcc(Nil, acc) == acc;\n      assert revAcc(Nil, Nil) == Nil;\n      assert app(Nil, acc) == acc;\n    case Cons(x, xs') => \n      RevAcc_Helper(xs', Cons(x, acc));\n      RevAcc_Helper(xs', Cons(x, Nil));\n      \n/*[CODE HERE]*/\n  }\n}\n\nlemma AppendAssoc(xs: List, ys: List, zs: List)\n  ensures app(app(xs, ys), zs) == app(xs, app(ys, zs))\n{\n  match xs {\n    case Nil => \n    case Cons(x, xs') => \n      AppendAssoc(xs', ys, zs);\n  }\n}\n\nlemma RevAcc_Correct(xs: List, acc: List)\n  ensures revAcc(xs, acc) == app(revAcc(xs, Nil), acc)\n{\n  RevAcc_Helper(xs, acc);\n}", "output": "AppendAssoc(revAcc(xs', Nil), Cons(x, Nil), acc);"}, {"id": "example_RevAcc_Helper_1", "type": "call", "program": "datatype List = Nil | Cons(head: int, tail: List)\n\npredicate SortedBetween(l: List, lo: int, hi: int)\n{\n  match l\n    case Nil => true\n    case Cons(x, xs) => lo <= x < hi && SortedBetween(xs, x, hi)\n}\n\nfunction insert(l: List, x: int): List {\n  match l\n    case Nil => Cons(x, Nil)\n    case Cons(y, ys) =>\n      if x < y then Cons(x, l) else Cons(y, insert(ys, x))\n}\n\nlemma InsertPreservesSortedBetween(l: List, x: int, lo: int, hi: int)\n  requires SortedBetween(l, lo, hi)\n  requires lo <= x < hi\n  ensures  SortedBetween(insert(l, x), lo, hi)\n{\n}\n\nfunction app(xs: List, ys: List): List {\n  match xs\n    case Nil => ys\n    case Cons(x, xs') => Cons(x, app(xs', ys))\n}\n\nfunction revAcc(xs: List, acc: List): List {\n  match xs\n    case Nil => acc\n    case Cons(x, xs') => revAcc(xs', Cons(x, acc))\n}\n\nlemma RevAcc_Helper(xs: List, acc: List)\n  ensures revAcc(xs, acc) == app(revAcc(xs, Nil), acc)\n{\n  match xs {\n    case Nil => \n      assert revAcc(Nil, acc) == acc;\n      assert revAcc(Nil, Nil) == Nil;\n      assert app(Nil, acc) == acc;\n    case Cons(x, xs') => \n      RevAcc_Helper(xs', Cons(x, acc));\n      \n/*[CODE HERE]*/\n      AppendAssoc(revAcc(xs', Nil), Cons(x, Nil), acc);\n  }\n}\n\nlemma AppendAssoc(xs: List, ys: List, zs: List)\n  ensures app(app(xs, ys), zs) == app(xs, app(ys, zs))\n{\n  match xs {\n    case Nil => \n    case Cons(x, xs') => \n      AppendAssoc(xs', ys, zs);\n  }\n}\n\nlemma RevAcc_Correct(xs: List, acc: List)\n  ensures revAcc(xs, acc) == app(revAcc(xs, Nil), acc)\n{\n  RevAcc_Helper(xs, acc);\n}", "output": "RevAcc_Helper(xs', Cons(x, Nil));"}, {"id": "example_RevAcc_Helper_2", "type": "call", "program": "datatype List = Nil | Cons(head: int, tail: List)\n\npredicate SortedBetween(l: List, lo: int, hi: int)\n{\n  match l\n    case Nil => true\n    case Cons(x, xs) => lo <= x < hi && SortedBetween(xs, x, hi)\n}\n\nfunction insert(l: List, x: int): List {\n  match l\n    case Nil => Cons(x, Nil)\n    case Cons(y, ys) =>\n      if x < y then Cons(x, l) else Cons(y, insert(ys, x))\n}\n\nlemma InsertPreservesSortedBetween(l: List, x: int, lo: int, hi: int)\n  requires SortedBetween(l, lo, hi)\n  requires lo <= x < hi\n  ensures  SortedBetween(insert(l, x), lo, hi)\n{\n}\n\nfunction app(xs: List, ys: List): List {\n  match xs\n    case Nil => ys\n    case Cons(x, xs') => Cons(x, app(xs', ys))\n}\n\nfunction revAcc(xs: List, acc: List): List {\n  match xs\n    case Nil => acc\n    case Cons(x, xs') => revAcc(xs', Cons(x, acc))\n}\n\nlemma RevAcc_Helper(xs: List, acc: List)\n  ensures revAcc(xs, acc) == app(revAcc(xs, Nil), acc)\n{\n  match xs {\n    case Nil => \n      assert revAcc(Nil, acc) == acc;\n      assert revAcc(Nil, Nil) == Nil;\n      assert app(Nil, acc) == acc;\n    case Cons(x, xs') => \n      \n/*[CODE HERE]*/\n      RevAcc_Helper(xs', Cons(x, Nil));\n      AppendAssoc(revAcc(xs', Nil), Cons(x, Nil), acc);\n  }\n}\n\nlemma AppendAssoc(xs: List, ys: List, zs: List)\n  ensures app(app(xs, ys), zs) == app(xs, app(ys, zs))\n{\n  match xs {\n    case Nil => \n    case Cons(x, xs') => \n      AppendAssoc(xs', ys, zs);\n  }\n}\n\nlemma RevAcc_Correct(xs: List, acc: List)\n  ensures revAcc(xs, acc) == app(revAcc(xs, Nil), acc)\n{\n  RevAcc_Helper(xs, acc);\n}", "output": "RevAcc_Helper(xs', Cons(x, acc));"}, {"id": "example_RevAcc_Helper_3", "type": "assert", "program": "datatype List = Nil | Cons(head: int, tail: List)\n\npredicate SortedBetween(l: List, lo: int, hi: int)\n{\n  match l\n    case Nil => true\n    case Cons(x, xs) => lo <= x < hi && SortedBetween(xs, x, hi)\n}\n\nfunction insert(l: List, x: int): List {\n  match l\n    case Nil => Cons(x, Nil)\n    case Cons(y, ys) =>\n      if x < y then Cons(x, l) else Cons(y, insert(ys, x))\n}\n\nlemma InsertPreservesSortedBetween(l: List, x: int, lo: int, hi: int)\n  requires SortedBetween(l, lo, hi)\n  requires lo <= x < hi\n  ensures  SortedBetween(insert(l, x), lo, hi)\n{\n}\n\nfunction app(xs: List, ys: List): List {\n  match xs\n    case Nil => ys\n    case Cons(x, xs') => Cons(x, app(xs', ys))\n}\n\nfunction revAcc(xs: List, acc: List): List {\n  match xs\n    case Nil => acc\n    case Cons(x, xs') => revAcc(xs', Cons(x, acc))\n}\n\nlemma RevAcc_Helper(xs: List, acc: List)\n  ensures revAcc(xs, acc) == app(revAcc(xs, Nil), acc)\n{\n  match xs {\n    case Nil => \n      assert revAcc(Nil, acc) == acc;\n      assert revAcc(Nil, Nil) == Nil;\n      \n/*[CODE HERE]*/\n    case Cons(x, xs') => \n      RevAcc_Helper(xs', Cons(x, acc));\n      RevAcc_Helper(xs', Cons(x, Nil));\n      AppendAssoc(revAcc(xs', Nil), Cons(x, Nil), acc);\n  }\n}\n\nlemma AppendAssoc(xs: List, ys: List, zs: List)\n  ensures app(app(xs, ys), zs) == app(xs, app(ys, zs))\n{\n  match xs {\n    case Nil => \n    case Cons(x, xs') => \n      AppendAssoc(xs', ys, zs);\n  }\n}\n\nlemma RevAcc_Correct(xs: List, acc: List)\n  ensures revAcc(xs, acc) == app(revAcc(xs, Nil), acc)\n{\n  RevAcc_Helper(xs, acc);\n}", "output": "assert app(Nil, acc) == acc;"}, {"id": "example_RevAcc_Helper_4", "type": "assert", "program": "datatype List = Nil | Cons(head: int, tail: List)\n\npredicate SortedBetween(l: List, lo: int, hi: int)\n{\n  match l\n    case Nil => true\n    case Cons(x, xs) => lo <= x < hi && SortedBetween(xs, x, hi)\n}\n\nfunction insert(l: List, x: int): List {\n  match l\n    case Nil => Cons(x, Nil)\n    case Cons(y, ys) =>\n      if x < y then Cons(x, l) else Cons(y, insert(ys, x))\n}\n\nlemma InsertPreservesSortedBetween(l: List, x: int, lo: int, hi: int)\n  requires SortedBetween(l, lo, hi)\n  requires lo <= x < hi\n  ensures  SortedBetween(insert(l, x), lo, hi)\n{\n}\n\nfunction app(xs: List, ys: List): List {\n  match xs\n    case Nil => ys\n    case Cons(x, xs') => Cons(x, app(xs', ys))\n}\n\nfunction revAcc(xs: List, acc: List): List {\n  match xs\n    case Nil => acc\n    case Cons(x, xs') => revAcc(xs', Cons(x, acc))\n}\n\nlemma RevAcc_Helper(xs: List, acc: List)\n  ensures revAcc(xs, acc) == app(revAcc(xs, Nil), acc)\n{\n  match xs {\n    case Nil => \n      assert revAcc(Nil, acc) == acc;\n      \n/*[CODE HERE]*/\n      assert app(Nil, acc) == acc;\n    case Cons(x, xs') => \n      RevAcc_Helper(xs', Cons(x, acc));\n      RevAcc_Helper(xs', Cons(x, Nil));\n      AppendAssoc(revAcc(xs', Nil), Cons(x, Nil), acc);\n  }\n}\n\nlemma AppendAssoc(xs: List, ys: List, zs: List)\n  ensures app(app(xs, ys), zs) == app(xs, app(ys, zs))\n{\n  match xs {\n    case Nil => \n    case Cons(x, xs') => \n      AppendAssoc(xs', ys, zs);\n  }\n}\n\nlemma RevAcc_Correct(xs: List, acc: List)\n  ensures revAcc(xs, acc) == app(revAcc(xs, Nil), acc)\n{\n  RevAcc_Helper(xs, acc);\n}", "output": "assert revAcc(Nil, Nil) == Nil;"}, {"id": "example_RevAcc_Helper_5", "type": "assert", "program": "datatype List = Nil | Cons(head: int, tail: List)\n\npredicate SortedBetween(l: List, lo: int, hi: int)\n{\n  match l\n    case Nil => true\n    case Cons(x, xs) => lo <= x < hi && SortedBetween(xs, x, hi)\n}\n\nfunction insert(l: List, x: int): List {\n  match l\n    case Nil => Cons(x, Nil)\n    case Cons(y, ys) =>\n      if x < y then Cons(x, l) else Cons(y, insert(ys, x))\n}\n\nlemma InsertPreservesSortedBetween(l: List, x: int, lo: int, hi: int)\n  requires SortedBetween(l, lo, hi)\n  requires lo <= x < hi\n  ensures  SortedBetween(insert(l, x), lo, hi)\n{\n}\n\nfunction app(xs: List, ys: List): List {\n  match xs\n    case Nil => ys\n    case Cons(x, xs') => Cons(x, app(xs', ys))\n}\n\nfunction revAcc(xs: List, acc: List): List {\n  match xs\n    case Nil => acc\n    case Cons(x, xs') => revAcc(xs', Cons(x, acc))\n}\n\nlemma RevAcc_Helper(xs: List, acc: List)\n  ensures revAcc(xs, acc) == app(revAcc(xs, Nil), acc)\n{\n  match xs {\n    case Nil => \n      \n/*[CODE HERE]*/\n      assert revAcc(Nil, Nil) == Nil;\n      assert app(Nil, acc) == acc;\n    case Cons(x, xs') => \n      RevAcc_Helper(xs', Cons(x, acc));\n      RevAcc_Helper(xs', Cons(x, Nil));\n      AppendAssoc(revAcc(xs', Nil), Cons(x, Nil), acc);\n  }\n}\n\nlemma AppendAssoc(xs: List, ys: List, zs: List)\n  ensures app(app(xs, ys), zs) == app(xs, app(ys, zs))\n{\n  match xs {\n    case Nil => \n    case Cons(x, xs') => \n      AppendAssoc(xs', ys, zs);\n  }\n}\n\nlemma RevAcc_Correct(xs: List, acc: List)\n  ensures revAcc(xs, acc) == app(revAcc(xs, Nil), acc)\n{\n  RevAcc_Helper(xs, acc);\n}", "output": "assert revAcc(Nil, acc) == acc;"}, {"id": "example_AppendAssoc_0", "type": "call", "program": "datatype List = Nil | Cons(head: int, tail: List)\n\npredicate SortedBetween(l: List, lo: int, hi: int)\n{\n  match l\n    case Nil => true\n    case Cons(x, xs) => lo <= x < hi && SortedBetween(xs, x, hi)\n}\n\nfunction insert(l: List, x: int): List {\n  match l\n    case Nil => Cons(x, Nil)\n    case Cons(y, ys) =>\n      if x < y then Cons(x, l) else Cons(y, insert(ys, x))\n}\n\nlemma InsertPreservesSortedBetween(l: List, x: int, lo: int, hi: int)\n  requires SortedBetween(l, lo, hi)\n  requires lo <= x < hi\n  ensures  SortedBetween(insert(l, x), lo, hi)\n{\n}\n\nfunction app(xs: List, ys: List): List {\n  match xs\n    case Nil => ys\n    case Cons(x, xs') => Cons(x, app(xs', ys))\n}\n\nfunction revAcc(xs: List, acc: List): List {\n  match xs\n    case Nil => acc\n    case Cons(x, xs') => revAcc(xs', Cons(x, acc))\n}\n\nlemma RevAcc_Helper(xs: List, acc: List)\n  ensures revAcc(xs, acc) == app(revAcc(xs, Nil), acc)\n{\n  match xs {\n    case Nil => \n      assert revAcc(Nil, acc) == acc;\n      assert revAcc(Nil, Nil) == Nil;\n      assert app(Nil, acc) == acc;\n    case Cons(x, xs') => \n      RevAcc_Helper(xs', Cons(x, acc));\n      RevAcc_Helper(xs', Cons(x, Nil));\n      AppendAssoc(revAcc(xs', Nil), Cons(x, Nil), acc);\n  }\n}\n\nlemma AppendAssoc(xs: List, ys: List, zs: List)\n  ensures app(app(xs, ys), zs) == app(xs, app(ys, zs))\n{\n  match xs {\n    case Nil => \n    case Cons(x, xs') => \n      \n/*[CODE HERE]*/\n  }\n}\n\nlemma RevAcc_Correct(xs: List, acc: List)\n  ensures revAcc(xs, acc) == app(revAcc(xs, Nil), acc)\n{\n  RevAcc_Helper(xs, acc);\n}", "output": "AppendAssoc(xs', ys, zs);"}, {"id": "example_RevAcc_Correct_0", "type": "call", "program": "datatype List = Nil | Cons(head: int, tail: List)\n\npredicate SortedBetween(l: List, lo: int, hi: int)\n{\n  match l\n    case Nil => true\n    case Cons(x, xs) => lo <= x < hi && SortedBetween(xs, x, hi)\n}\n\nfunction insert(l: List, x: int): List {\n  match l\n    case Nil => Cons(x, Nil)\n    case Cons(y, ys) =>\n      if x < y then Cons(x, l) else Cons(y, insert(ys, x))\n}\n\nlemma InsertPreservesSortedBetween(l: List, x: int, lo: int, hi: int)\n  requires SortedBetween(l, lo, hi)\n  requires lo <= x < hi\n  ensures  SortedBetween(insert(l, x), lo, hi)\n{\n}\n\nfunction app(xs: List, ys: List): List {\n  match xs\n    case Nil => ys\n    case Cons(x, xs') => Cons(x, app(xs', ys))\n}\n\nfunction revAcc(xs: List, acc: List): List {\n  match xs\n    case Nil => acc\n    case Cons(x, xs') => revAcc(xs', Cons(x, acc))\n}\n\nlemma RevAcc_Helper(xs: List, acc: List)\n  ensures revAcc(xs, acc) == app(revAcc(xs, Nil), acc)\n{\n  match xs {\n    case Nil => \n      assert revAcc(Nil, acc) == acc;\n      assert revAcc(Nil, Nil) == Nil;\n      assert app(Nil, acc) == acc;\n    case Cons(x, xs') => \n      RevAcc_Helper(xs', Cons(x, acc));\n      RevAcc_Helper(xs', Cons(x, Nil));\n      AppendAssoc(revAcc(xs', Nil), Cons(x, Nil), acc);\n  }\n}\n\nlemma AppendAssoc(xs: List, ys: List, zs: List)\n  ensures app(app(xs, ys), zs) == app(xs, app(ys, zs))\n{\n  match xs {\n    case Nil => \n    case Cons(x, xs') => \n      AppendAssoc(xs', ys, zs);\n  }\n}\n\nlemma RevAcc_Correct(xs: List, acc: List)\n  ensures revAcc(xs, acc) == app(revAcc(xs, Nil), acc)\n{\n  \n/*[CODE HERE]*/\n}", "output": "RevAcc_Helper(xs, acc);"}, {"id": "example_PopPushNotIdentity_0", "type": "assert", "program": "// Stack operations: push, pop, peek, isEmpty with LIFO properties\n\ndatatype Stack<T> = Stack(elements: seq<T>)\n\nfunction {:spec} emptyStack<T>(): Stack<T>\n{\n  Stack([])\n}\n\npredicate {:spec} isEmpty<T>(s: Stack<T>)\n{\n  s.elements == []\n}\n\nfunction {:spec} push<T>(s: Stack<T>, x: T): Stack<T>\n{\n  Stack([x] + s.elements)\n}\n\nfunction {:spec} pop<T>(s: Stack<T>): Stack<T>\n  requires !isEmpty(s)\n{\n  Stack(s.elements[1..])\n}\n\nfunction {:spec} peek<T>(s: Stack<T>): T\n  requires !isEmpty(s)\n{\n  s.elements[0]\n}\n\nfunction {:spec} size<T>(s: Stack<T>): nat\n{\n  |s.elements|\n}\n\npredicate {:spec} contains<T(==)>(s: Stack<T>, x: T)\n{\n  x in s.elements\n}\n\nfunction {:spec} toSeq<T>(s: Stack<T>): seq<T>\n{\n  s.elements\n}\n\n// Stack from sequence\nfunction {:spec} fromSeq<T>(elements: seq<T>): Stack<T>\n{\n  Stack(elements)\n}\n\n// Multiple push operations\nfunction {:spec} pushAll<T>(s: Stack<T>, items: seq<T>): Stack<T>\n  decreases |items|\n{\n  if |items| == 0 then s\n  else pushAll(push(s, items[0]), items[1..])\n}\n\n// Multiple pop operations\nfunction {:spec} popN<T>(s: Stack<T>, n: nat): Stack<T>\n  requires n <= size(s)\n  decreases n\n{\n  if n == 0 then s\n  else popN(pop(s), n - 1)\n}\n\n// Get the nth element from top (0-indexed)\nfunction {:spec} nthFromTop<T>(s: Stack<T>, n: nat): T\n  requires n < size(s)\n{\n  s.elements[n]\n}\n\nlemma PushPopIdentity<T>(s: Stack<T>, x: T)\n  ensures pop(push(s, x)) == s\n  ensures peek(push(s, x)) == x\n{\n  // Automatic\n}\n\nlemma PopPushNotIdentity<T>(s: Stack<T>, x: T)\n  requires !isEmpty(s)\n  requires x != peek(s)\n  ensures push(pop(s), x) != s\n{\n  assert push(pop(s), x).elements[0] == x;\n  assert s.elements[0] == peek(s);\n  \n/*[CODE HERE]*/\n}\n\nlemma PushIncreaseSize<T>(s: Stack<T>, x: T)\n  ensures size(push(s, x)) == size(s) + 1\n{\n  // Automatic\n}\n\nlemma PopDecreaseSize<T>(s: Stack<T>)\n  requires !isEmpty(s)\n  ensures size(pop(s)) == size(s) - 1\n{\n  // Automatic\n}\n\nlemma EmptyStackProperties<T>(s: Stack<T>)\n  ensures isEmpty(s) <==> size(s) == 0\n  ensures isEmpty(s) <==> s.elements == []\n{\n  // Automatic\n}\n\nlemma LIFOProperty<T>(s: Stack<T>, x: T, y: T)\n  ensures peek(push(push(s, x), y)) == y\n  ensures peek(pop(push(push(s, x), y))) == x\n{\n  // Automatic - Last In First Out\n}\n\nlemma PushAllCorrect<T>(s: Stack<T>, items: seq<T>)\n  ensures size(pushAll(s, items)) == size(s) + |items|\n  decreases |items|\n{\n  if |items| == 0 {\n    // Base case\n  } else {\n    PushAllCorrect(push(s, items[0]), items[1..]);\n  }\n}\n\nlemma PopNCorrect<T>(s: Stack<T>, n: nat)\n  requires n <= size(s)\n  ensures size(popN(s, n)) == size(s) - n\n  decreases n\n{\n  if n == 0 {\n    // Base case\n  } else {\n    PopNCorrect(pop(s), n - 1);\n  }\n}\n\nlemma PushPreservesContains<T>(s: Stack<T>, x: T, y: T)\n  ensures contains(push(s, x), y) <==> (y == x || contains(s, y))\n{\n  // Automatic\n}\n\nlemma StackToFromSeq<T>(s: Stack<T>)\n  ensures fromSeq(toSeq(s)) == s\n  ensures toSeq(fromSeq(s.elements)) == s.elements\n{\n  // Automatic\n}\n\nlemma PushOrder<T>(s: Stack<T>, x: T, y: T)\n  ensures toSeq(push(push(s, x), y)) == [y, x] + toSeq(s)\n{\n  calc == {\n    toSeq(push(push(s, x), y));\n    push(push(s, x), y).elements;\n    [y] + push(s, x).elements;\n    [y] + ([x] + s.elements);\n    [y, x] + s.elements;\n    [y, x] + toSeq(s);\n  }\n}\n\nlemma NthFromTopCorrect<T>(s: Stack<T>, n: nat)\n  requires n < size(s)\n  ensures nthFromTop(s, n) == toSeq(s)[n]\n{\n  // Automatic\n}\n\nlemma StackInduction<T>(s: Stack<T>)\n  ensures s == emptyStack() || exists x, s' :: s == push(s', x)\n{\n  if isEmpty(s) {\n    assert s == emptyStack();\n  } else {\n    var s' := pop(s);\n    var x := peek(s);\n    assert s == push(s', x);\n  }\n}", "output": "assert x != peek(s);"}, {"id": "example_PopPushNotIdentity_1", "type": "assert", "program": "// Stack operations: push, pop, peek, isEmpty with LIFO properties\n\ndatatype Stack<T> = Stack(elements: seq<T>)\n\nfunction {:spec} emptyStack<T>(): Stack<T>\n{\n  Stack([])\n}\n\npredicate {:spec} isEmpty<T>(s: Stack<T>)\n{\n  s.elements == []\n}\n\nfunction {:spec} push<T>(s: Stack<T>, x: T): Stack<T>\n{\n  Stack([x] + s.elements)\n}\n\nfunction {:spec} pop<T>(s: Stack<T>): Stack<T>\n  requires !isEmpty(s)\n{\n  Stack(s.elements[1..])\n}\n\nfunction {:spec} peek<T>(s: Stack<T>): T\n  requires !isEmpty(s)\n{\n  s.elements[0]\n}\n\nfunction {:spec} size<T>(s: Stack<T>): nat\n{\n  |s.elements|\n}\n\npredicate {:spec} contains<T(==)>(s: Stack<T>, x: T)\n{\n  x in s.elements\n}\n\nfunction {:spec} toSeq<T>(s: Stack<T>): seq<T>\n{\n  s.elements\n}\n\n// Stack from sequence\nfunction {:spec} fromSeq<T>(elements: seq<T>): Stack<T>\n{\n  Stack(elements)\n}\n\n// Multiple push operations\nfunction {:spec} pushAll<T>(s: Stack<T>, items: seq<T>): Stack<T>\n  decreases |items|\n{\n  if |items| == 0 then s\n  else pushAll(push(s, items[0]), items[1..])\n}\n\n// Multiple pop operations\nfunction {:spec} popN<T>(s: Stack<T>, n: nat): Stack<T>\n  requires n <= size(s)\n  decreases n\n{\n  if n == 0 then s\n  else popN(pop(s), n - 1)\n}\n\n// Get the nth element from top (0-indexed)\nfunction {:spec} nthFromTop<T>(s: Stack<T>, n: nat): T\n  requires n < size(s)\n{\n  s.elements[n]\n}\n\nlemma PushPopIdentity<T>(s: Stack<T>, x: T)\n  ensures pop(push(s, x)) == s\n  ensures peek(push(s, x)) == x\n{\n  // Automatic\n}\n\nlemma PopPushNotIdentity<T>(s: Stack<T>, x: T)\n  requires !isEmpty(s)\n  requires x != peek(s)\n  ensures push(pop(s), x) != s\n{\n  assert push(pop(s), x).elements[0] == x;\n  \n/*[CODE HERE]*/\n  assert x != peek(s);\n}\n\nlemma PushIncreaseSize<T>(s: Stack<T>, x: T)\n  ensures size(push(s, x)) == size(s) + 1\n{\n  // Automatic\n}\n\nlemma PopDecreaseSize<T>(s: Stack<T>)\n  requires !isEmpty(s)\n  ensures size(pop(s)) == size(s) - 1\n{\n  // Automatic\n}\n\nlemma EmptyStackProperties<T>(s: Stack<T>)\n  ensures isEmpty(s) <==> size(s) == 0\n  ensures isEmpty(s) <==> s.elements == []\n{\n  // Automatic\n}\n\nlemma LIFOProperty<T>(s: Stack<T>, x: T, y: T)\n  ensures peek(push(push(s, x), y)) == y\n  ensures peek(pop(push(push(s, x), y))) == x\n{\n  // Automatic - Last In First Out\n}\n\nlemma PushAllCorrect<T>(s: Stack<T>, items: seq<T>)\n  ensures size(pushAll(s, items)) == size(s) + |items|\n  decreases |items|\n{\n  if |items| == 0 {\n    // Base case\n  } else {\n    PushAllCorrect(push(s, items[0]), items[1..]);\n  }\n}\n\nlemma PopNCorrect<T>(s: Stack<T>, n: nat)\n  requires n <= size(s)\n  ensures size(popN(s, n)) == size(s) - n\n  decreases n\n{\n  if n == 0 {\n    // Base case\n  } else {\n    PopNCorrect(pop(s), n - 1);\n  }\n}\n\nlemma PushPreservesContains<T>(s: Stack<T>, x: T, y: T)\n  ensures contains(push(s, x), y) <==> (y == x || contains(s, y))\n{\n  // Automatic\n}\n\nlemma StackToFromSeq<T>(s: Stack<T>)\n  ensures fromSeq(toSeq(s)) == s\n  ensures toSeq(fromSeq(s.elements)) == s.elements\n{\n  // Automatic\n}\n\nlemma PushOrder<T>(s: Stack<T>, x: T, y: T)\n  ensures toSeq(push(push(s, x), y)) == [y, x] + toSeq(s)\n{\n  calc == {\n    toSeq(push(push(s, x), y));\n    push(push(s, x), y).elements;\n    [y] + push(s, x).elements;\n    [y] + ([x] + s.elements);\n    [y, x] + s.elements;\n    [y, x] + toSeq(s);\n  }\n}\n\nlemma NthFromTopCorrect<T>(s: Stack<T>, n: nat)\n  requires n < size(s)\n  ensures nthFromTop(s, n) == toSeq(s)[n]\n{\n  // Automatic\n}\n\nlemma StackInduction<T>(s: Stack<T>)\n  ensures s == emptyStack() || exists x, s' :: s == push(s', x)\n{\n  if isEmpty(s) {\n    assert s == emptyStack();\n  } else {\n    var s' := pop(s);\n    var x := peek(s);\n    assert s == push(s', x);\n  }\n}", "output": "assert s.elements[0] == peek(s);"}, {"id": "example_PopPushNotIdentity_2", "type": "assert", "program": "// Stack operations: push, pop, peek, isEmpty with LIFO properties\n\ndatatype Stack<T> = Stack(elements: seq<T>)\n\nfunction {:spec} emptyStack<T>(): Stack<T>\n{\n  Stack([])\n}\n\npredicate {:spec} isEmpty<T>(s: Stack<T>)\n{\n  s.elements == []\n}\n\nfunction {:spec} push<T>(s: Stack<T>, x: T): Stack<T>\n{\n  Stack([x] + s.elements)\n}\n\nfunction {:spec} pop<T>(s: Stack<T>): Stack<T>\n  requires !isEmpty(s)\n{\n  Stack(s.elements[1..])\n}\n\nfunction {:spec} peek<T>(s: Stack<T>): T\n  requires !isEmpty(s)\n{\n  s.elements[0]\n}\n\nfunction {:spec} size<T>(s: Stack<T>): nat\n{\n  |s.elements|\n}\n\npredicate {:spec} contains<T(==)>(s: Stack<T>, x: T)\n{\n  x in s.elements\n}\n\nfunction {:spec} toSeq<T>(s: Stack<T>): seq<T>\n{\n  s.elements\n}\n\n// Stack from sequence\nfunction {:spec} fromSeq<T>(elements: seq<T>): Stack<T>\n{\n  Stack(elements)\n}\n\n// Multiple push operations\nfunction {:spec} pushAll<T>(s: Stack<T>, items: seq<T>): Stack<T>\n  decreases |items|\n{\n  if |items| == 0 then s\n  else pushAll(push(s, items[0]), items[1..])\n}\n\n// Multiple pop operations\nfunction {:spec} popN<T>(s: Stack<T>, n: nat): Stack<T>\n  requires n <= size(s)\n  decreases n\n{\n  if n == 0 then s\n  else popN(pop(s), n - 1)\n}\n\n// Get the nth element from top (0-indexed)\nfunction {:spec} nthFromTop<T>(s: Stack<T>, n: nat): T\n  requires n < size(s)\n{\n  s.elements[n]\n}\n\nlemma PushPopIdentity<T>(s: Stack<T>, x: T)\n  ensures pop(push(s, x)) == s\n  ensures peek(push(s, x)) == x\n{\n  // Automatic\n}\n\nlemma PopPushNotIdentity<T>(s: Stack<T>, x: T)\n  requires !isEmpty(s)\n  requires x != peek(s)\n  ensures push(pop(s), x) != s\n{\n  \n/*[CODE HERE]*/\n  assert s.elements[0] == peek(s);\n  assert x != peek(s);\n}\n\nlemma PushIncreaseSize<T>(s: Stack<T>, x: T)\n  ensures size(push(s, x)) == size(s) + 1\n{\n  // Automatic\n}\n\nlemma PopDecreaseSize<T>(s: Stack<T>)\n  requires !isEmpty(s)\n  ensures size(pop(s)) == size(s) - 1\n{\n  // Automatic\n}\n\nlemma EmptyStackProperties<T>(s: Stack<T>)\n  ensures isEmpty(s) <==> size(s) == 0\n  ensures isEmpty(s) <==> s.elements == []\n{\n  // Automatic\n}\n\nlemma LIFOProperty<T>(s: Stack<T>, x: T, y: T)\n  ensures peek(push(push(s, x), y)) == y\n  ensures peek(pop(push(push(s, x), y))) == x\n{\n  // Automatic - Last In First Out\n}\n\nlemma PushAllCorrect<T>(s: Stack<T>, items: seq<T>)\n  ensures size(pushAll(s, items)) == size(s) + |items|\n  decreases |items|\n{\n  if |items| == 0 {\n    // Base case\n  } else {\n    PushAllCorrect(push(s, items[0]), items[1..]);\n  }\n}\n\nlemma PopNCorrect<T>(s: Stack<T>, n: nat)\n  requires n <= size(s)\n  ensures size(popN(s, n)) == size(s) - n\n  decreases n\n{\n  if n == 0 {\n    // Base case\n  } else {\n    PopNCorrect(pop(s), n - 1);\n  }\n}\n\nlemma PushPreservesContains<T>(s: Stack<T>, x: T, y: T)\n  ensures contains(push(s, x), y) <==> (y == x || contains(s, y))\n{\n  // Automatic\n}\n\nlemma StackToFromSeq<T>(s: Stack<T>)\n  ensures fromSeq(toSeq(s)) == s\n  ensures toSeq(fromSeq(s.elements)) == s.elements\n{\n  // Automatic\n}\n\nlemma PushOrder<T>(s: Stack<T>, x: T, y: T)\n  ensures toSeq(push(push(s, x), y)) == [y, x] + toSeq(s)\n{\n  calc == {\n    toSeq(push(push(s, x), y));\n    push(push(s, x), y).elements;\n    [y] + push(s, x).elements;\n    [y] + ([x] + s.elements);\n    [y, x] + s.elements;\n    [y, x] + toSeq(s);\n  }\n}\n\nlemma NthFromTopCorrect<T>(s: Stack<T>, n: nat)\n  requires n < size(s)\n  ensures nthFromTop(s, n) == toSeq(s)[n]\n{\n  // Automatic\n}\n\nlemma StackInduction<T>(s: Stack<T>)\n  ensures s == emptyStack() || exists x, s' :: s == push(s', x)\n{\n  if isEmpty(s) {\n    assert s == emptyStack();\n  } else {\n    var s' := pop(s);\n    var x := peek(s);\n    assert s == push(s', x);\n  }\n}", "output": "assert push(pop(s), x).elements[0] == x;"}, {"id": "example_PushAllCorrect_0", "type": "call", "program": "// Stack operations: push, pop, peek, isEmpty with LIFO properties\n\ndatatype Stack<T> = Stack(elements: seq<T>)\n\nfunction {:spec} emptyStack<T>(): Stack<T>\n{\n  Stack([])\n}\n\npredicate {:spec} isEmpty<T>(s: Stack<T>)\n{\n  s.elements == []\n}\n\nfunction {:spec} push<T>(s: Stack<T>, x: T): Stack<T>\n{\n  Stack([x] + s.elements)\n}\n\nfunction {:spec} pop<T>(s: Stack<T>): Stack<T>\n  requires !isEmpty(s)\n{\n  Stack(s.elements[1..])\n}\n\nfunction {:spec} peek<T>(s: Stack<T>): T\n  requires !isEmpty(s)\n{\n  s.elements[0]\n}\n\nfunction {:spec} size<T>(s: Stack<T>): nat\n{\n  |s.elements|\n}\n\npredicate {:spec} contains<T(==)>(s: Stack<T>, x: T)\n{\n  x in s.elements\n}\n\nfunction {:spec} toSeq<T>(s: Stack<T>): seq<T>\n{\n  s.elements\n}\n\n// Stack from sequence\nfunction {:spec} fromSeq<T>(elements: seq<T>): Stack<T>\n{\n  Stack(elements)\n}\n\n// Multiple push operations\nfunction {:spec} pushAll<T>(s: Stack<T>, items: seq<T>): Stack<T>\n  decreases |items|\n{\n  if |items| == 0 then s\n  else pushAll(push(s, items[0]), items[1..])\n}\n\n// Multiple pop operations\nfunction {:spec} popN<T>(s: Stack<T>, n: nat): Stack<T>\n  requires n <= size(s)\n  decreases n\n{\n  if n == 0 then s\n  else popN(pop(s), n - 1)\n}\n\n// Get the nth element from top (0-indexed)\nfunction {:spec} nthFromTop<T>(s: Stack<T>, n: nat): T\n  requires n < size(s)\n{\n  s.elements[n]\n}\n\nlemma PushPopIdentity<T>(s: Stack<T>, x: T)\n  ensures pop(push(s, x)) == s\n  ensures peek(push(s, x)) == x\n{\n  // Automatic\n}\n\nlemma PopPushNotIdentity<T>(s: Stack<T>, x: T)\n  requires !isEmpty(s)\n  requires x != peek(s)\n  ensures push(pop(s), x) != s\n{\n  assert push(pop(s), x).elements[0] == x;\n  assert s.elements[0] == peek(s);\n  assert x != peek(s);\n}\n\nlemma PushIncreaseSize<T>(s: Stack<T>, x: T)\n  ensures size(push(s, x)) == size(s) + 1\n{\n  // Automatic\n}\n\nlemma PopDecreaseSize<T>(s: Stack<T>)\n  requires !isEmpty(s)\n  ensures size(pop(s)) == size(s) - 1\n{\n  // Automatic\n}\n\nlemma EmptyStackProperties<T>(s: Stack<T>)\n  ensures isEmpty(s) <==> size(s) == 0\n  ensures isEmpty(s) <==> s.elements == []\n{\n  // Automatic\n}\n\nlemma LIFOProperty<T>(s: Stack<T>, x: T, y: T)\n  ensures peek(push(push(s, x), y)) == y\n  ensures peek(pop(push(push(s, x), y))) == x\n{\n  // Automatic - Last In First Out\n}\n\nlemma PushAllCorrect<T>(s: Stack<T>, items: seq<T>)\n  ensures size(pushAll(s, items)) == size(s) + |items|\n  decreases |items|\n{\n  if |items| == 0 {\n    // Base case\n  } else {\n    \n/*[CODE HERE]*/\n  }\n}\n\nlemma PopNCorrect<T>(s: Stack<T>, n: nat)\n  requires n <= size(s)\n  ensures size(popN(s, n)) == size(s) - n\n  decreases n\n{\n  if n == 0 {\n    // Base case\n  } else {\n    PopNCorrect(pop(s), n - 1);\n  }\n}\n\nlemma PushPreservesContains<T>(s: Stack<T>, x: T, y: T)\n  ensures contains(push(s, x), y) <==> (y == x || contains(s, y))\n{\n  // Automatic\n}\n\nlemma StackToFromSeq<T>(s: Stack<T>)\n  ensures fromSeq(toSeq(s)) == s\n  ensures toSeq(fromSeq(s.elements)) == s.elements\n{\n  // Automatic\n}\n\nlemma PushOrder<T>(s: Stack<T>, x: T, y: T)\n  ensures toSeq(push(push(s, x), y)) == [y, x] + toSeq(s)\n{\n  calc == {\n    toSeq(push(push(s, x), y));\n    push(push(s, x), y).elements;\n    [y] + push(s, x).elements;\n    [y] + ([x] + s.elements);\n    [y, x] + s.elements;\n    [y, x] + toSeq(s);\n  }\n}\n\nlemma NthFromTopCorrect<T>(s: Stack<T>, n: nat)\n  requires n < size(s)\n  ensures nthFromTop(s, n) == toSeq(s)[n]\n{\n  // Automatic\n}\n\nlemma StackInduction<T>(s: Stack<T>)\n  ensures s == emptyStack() || exists x, s' :: s == push(s', x)\n{\n  if isEmpty(s) {\n    assert s == emptyStack();\n  } else {\n    var s' := pop(s);\n    var x := peek(s);\n    assert s == push(s', x);\n  }\n}", "output": "PushAllCorrect(push(s, items[0]), items[1..]);"}, {"id": "example_PopNCorrect_0", "type": "call", "program": "// Stack operations: push, pop, peek, isEmpty with LIFO properties\n\ndatatype Stack<T> = Stack(elements: seq<T>)\n\nfunction {:spec} emptyStack<T>(): Stack<T>\n{\n  Stack([])\n}\n\npredicate {:spec} isEmpty<T>(s: Stack<T>)\n{\n  s.elements == []\n}\n\nfunction {:spec} push<T>(s: Stack<T>, x: T): Stack<T>\n{\n  Stack([x] + s.elements)\n}\n\nfunction {:spec} pop<T>(s: Stack<T>): Stack<T>\n  requires !isEmpty(s)\n{\n  Stack(s.elements[1..])\n}\n\nfunction {:spec} peek<T>(s: Stack<T>): T\n  requires !isEmpty(s)\n{\n  s.elements[0]\n}\n\nfunction {:spec} size<T>(s: Stack<T>): nat\n{\n  |s.elements|\n}\n\npredicate {:spec} contains<T(==)>(s: Stack<T>, x: T)\n{\n  x in s.elements\n}\n\nfunction {:spec} toSeq<T>(s: Stack<T>): seq<T>\n{\n  s.elements\n}\n\n// Stack from sequence\nfunction {:spec} fromSeq<T>(elements: seq<T>): Stack<T>\n{\n  Stack(elements)\n}\n\n// Multiple push operations\nfunction {:spec} pushAll<T>(s: Stack<T>, items: seq<T>): Stack<T>\n  decreases |items|\n{\n  if |items| == 0 then s\n  else pushAll(push(s, items[0]), items[1..])\n}\n\n// Multiple pop operations\nfunction {:spec} popN<T>(s: Stack<T>, n: nat): Stack<T>\n  requires n <= size(s)\n  decreases n\n{\n  if n == 0 then s\n  else popN(pop(s), n - 1)\n}\n\n// Get the nth element from top (0-indexed)\nfunction {:spec} nthFromTop<T>(s: Stack<T>, n: nat): T\n  requires n < size(s)\n{\n  s.elements[n]\n}\n\nlemma PushPopIdentity<T>(s: Stack<T>, x: T)\n  ensures pop(push(s, x)) == s\n  ensures peek(push(s, x)) == x\n{\n  // Automatic\n}\n\nlemma PopPushNotIdentity<T>(s: Stack<T>, x: T)\n  requires !isEmpty(s)\n  requires x != peek(s)\n  ensures push(pop(s), x) != s\n{\n  assert push(pop(s), x).elements[0] == x;\n  assert s.elements[0] == peek(s);\n  assert x != peek(s);\n}\n\nlemma PushIncreaseSize<T>(s: Stack<T>, x: T)\n  ensures size(push(s, x)) == size(s) + 1\n{\n  // Automatic\n}\n\nlemma PopDecreaseSize<T>(s: Stack<T>)\n  requires !isEmpty(s)\n  ensures size(pop(s)) == size(s) - 1\n{\n  // Automatic\n}\n\nlemma EmptyStackProperties<T>(s: Stack<T>)\n  ensures isEmpty(s) <==> size(s) == 0\n  ensures isEmpty(s) <==> s.elements == []\n{\n  // Automatic\n}\n\nlemma LIFOProperty<T>(s: Stack<T>, x: T, y: T)\n  ensures peek(push(push(s, x), y)) == y\n  ensures peek(pop(push(push(s, x), y))) == x\n{\n  // Automatic - Last In First Out\n}\n\nlemma PushAllCorrect<T>(s: Stack<T>, items: seq<T>)\n  ensures size(pushAll(s, items)) == size(s) + |items|\n  decreases |items|\n{\n  if |items| == 0 {\n    // Base case\n  } else {\n    PushAllCorrect(push(s, items[0]), items[1..]);\n  }\n}\n\nlemma PopNCorrect<T>(s: Stack<T>, n: nat)\n  requires n <= size(s)\n  ensures size(popN(s, n)) == size(s) - n\n  decreases n\n{\n  if n == 0 {\n    // Base case\n  } else {\n    \n/*[CODE HERE]*/\n  }\n}\n\nlemma PushPreservesContains<T>(s: Stack<T>, x: T, y: T)\n  ensures contains(push(s, x), y) <==> (y == x || contains(s, y))\n{\n  // Automatic\n}\n\nlemma StackToFromSeq<T>(s: Stack<T>)\n  ensures fromSeq(toSeq(s)) == s\n  ensures toSeq(fromSeq(s.elements)) == s.elements\n{\n  // Automatic\n}\n\nlemma PushOrder<T>(s: Stack<T>, x: T, y: T)\n  ensures toSeq(push(push(s, x), y)) == [y, x] + toSeq(s)\n{\n  calc == {\n    toSeq(push(push(s, x), y));\n    push(push(s, x), y).elements;\n    [y] + push(s, x).elements;\n    [y] + ([x] + s.elements);\n    [y, x] + s.elements;\n    [y, x] + toSeq(s);\n  }\n}\n\nlemma NthFromTopCorrect<T>(s: Stack<T>, n: nat)\n  requires n < size(s)\n  ensures nthFromTop(s, n) == toSeq(s)[n]\n{\n  // Automatic\n}\n\nlemma StackInduction<T>(s: Stack<T>)\n  ensures s == emptyStack() || exists x, s' :: s == push(s', x)\n{\n  if isEmpty(s) {\n    assert s == emptyStack();\n  } else {\n    var s' := pop(s);\n    var x := peek(s);\n    assert s == push(s', x);\n  }\n}", "output": "PopNCorrect(pop(s), n - 1);"}, {"id": "example_StackInduction_0", "type": "assert", "program": "// Stack operations: push, pop, peek, isEmpty with LIFO properties\n\ndatatype Stack<T> = Stack(elements: seq<T>)\n\nfunction {:spec} emptyStack<T>(): Stack<T>\n{\n  Stack([])\n}\n\npredicate {:spec} isEmpty<T>(s: Stack<T>)\n{\n  s.elements == []\n}\n\nfunction {:spec} push<T>(s: Stack<T>, x: T): Stack<T>\n{\n  Stack([x] + s.elements)\n}\n\nfunction {:spec} pop<T>(s: Stack<T>): Stack<T>\n  requires !isEmpty(s)\n{\n  Stack(s.elements[1..])\n}\n\nfunction {:spec} peek<T>(s: Stack<T>): T\n  requires !isEmpty(s)\n{\n  s.elements[0]\n}\n\nfunction {:spec} size<T>(s: Stack<T>): nat\n{\n  |s.elements|\n}\n\npredicate {:spec} contains<T(==)>(s: Stack<T>, x: T)\n{\n  x in s.elements\n}\n\nfunction {:spec} toSeq<T>(s: Stack<T>): seq<T>\n{\n  s.elements\n}\n\n// Stack from sequence\nfunction {:spec} fromSeq<T>(elements: seq<T>): Stack<T>\n{\n  Stack(elements)\n}\n\n// Multiple push operations\nfunction {:spec} pushAll<T>(s: Stack<T>, items: seq<T>): Stack<T>\n  decreases |items|\n{\n  if |items| == 0 then s\n  else pushAll(push(s, items[0]), items[1..])\n}\n\n// Multiple pop operations\nfunction {:spec} popN<T>(s: Stack<T>, n: nat): Stack<T>\n  requires n <= size(s)\n  decreases n\n{\n  if n == 0 then s\n  else popN(pop(s), n - 1)\n}\n\n// Get the nth element from top (0-indexed)\nfunction {:spec} nthFromTop<T>(s: Stack<T>, n: nat): T\n  requires n < size(s)\n{\n  s.elements[n]\n}\n\nlemma PushPopIdentity<T>(s: Stack<T>, x: T)\n  ensures pop(push(s, x)) == s\n  ensures peek(push(s, x)) == x\n{\n  // Automatic\n}\n\nlemma PopPushNotIdentity<T>(s: Stack<T>, x: T)\n  requires !isEmpty(s)\n  requires x != peek(s)\n  ensures push(pop(s), x) != s\n{\n  assert push(pop(s), x).elements[0] == x;\n  assert s.elements[0] == peek(s);\n  assert x != peek(s);\n}\n\nlemma PushIncreaseSize<T>(s: Stack<T>, x: T)\n  ensures size(push(s, x)) == size(s) + 1\n{\n  // Automatic\n}\n\nlemma PopDecreaseSize<T>(s: Stack<T>)\n  requires !isEmpty(s)\n  ensures size(pop(s)) == size(s) - 1\n{\n  // Automatic\n}\n\nlemma EmptyStackProperties<T>(s: Stack<T>)\n  ensures isEmpty(s) <==> size(s) == 0\n  ensures isEmpty(s) <==> s.elements == []\n{\n  // Automatic\n}\n\nlemma LIFOProperty<T>(s: Stack<T>, x: T, y: T)\n  ensures peek(push(push(s, x), y)) == y\n  ensures peek(pop(push(push(s, x), y))) == x\n{\n  // Automatic - Last In First Out\n}\n\nlemma PushAllCorrect<T>(s: Stack<T>, items: seq<T>)\n  ensures size(pushAll(s, items)) == size(s) + |items|\n  decreases |items|\n{\n  if |items| == 0 {\n    // Base case\n  } else {\n    PushAllCorrect(push(s, items[0]), items[1..]);\n  }\n}\n\nlemma PopNCorrect<T>(s: Stack<T>, n: nat)\n  requires n <= size(s)\n  ensures size(popN(s, n)) == size(s) - n\n  decreases n\n{\n  if n == 0 {\n    // Base case\n  } else {\n    PopNCorrect(pop(s), n - 1);\n  }\n}\n\nlemma PushPreservesContains<T>(s: Stack<T>, x: T, y: T)\n  ensures contains(push(s, x), y) <==> (y == x || contains(s, y))\n{\n  // Automatic\n}\n\nlemma StackToFromSeq<T>(s: Stack<T>)\n  ensures fromSeq(toSeq(s)) == s\n  ensures toSeq(fromSeq(s.elements)) == s.elements\n{\n  // Automatic\n}\n\nlemma PushOrder<T>(s: Stack<T>, x: T, y: T)\n  ensures toSeq(push(push(s, x), y)) == [y, x] + toSeq(s)\n{\n  calc == {\n    toSeq(push(push(s, x), y));\n    push(push(s, x), y).elements;\n    [y] + push(s, x).elements;\n    [y] + ([x] + s.elements);\n    [y, x] + s.elements;\n    [y, x] + toSeq(s);\n  }\n}\n\nlemma NthFromTopCorrect<T>(s: Stack<T>, n: nat)\n  requires n < size(s)\n  ensures nthFromTop(s, n) == toSeq(s)[n]\n{\n  // Automatic\n}\n\nlemma StackInduction<T>(s: Stack<T>)\n  ensures s == emptyStack() || exists x, s' :: s == push(s', x)\n{\n  if isEmpty(s) {\n    assert s == emptyStack();\n  } else {\n    var s' := pop(s);\n    var x := peek(s);\n    \n/*[CODE HERE]*/\n  }\n}", "output": "assert s == push(s', x);"}, {"id": "example_StackInduction_1", "type": "assert", "program": "// Stack operations: push, pop, peek, isEmpty with LIFO properties\n\ndatatype Stack<T> = Stack(elements: seq<T>)\n\nfunction {:spec} emptyStack<T>(): Stack<T>\n{\n  Stack([])\n}\n\npredicate {:spec} isEmpty<T>(s: Stack<T>)\n{\n  s.elements == []\n}\n\nfunction {:spec} push<T>(s: Stack<T>, x: T): Stack<T>\n{\n  Stack([x] + s.elements)\n}\n\nfunction {:spec} pop<T>(s: Stack<T>): Stack<T>\n  requires !isEmpty(s)\n{\n  Stack(s.elements[1..])\n}\n\nfunction {:spec} peek<T>(s: Stack<T>): T\n  requires !isEmpty(s)\n{\n  s.elements[0]\n}\n\nfunction {:spec} size<T>(s: Stack<T>): nat\n{\n  |s.elements|\n}\n\npredicate {:spec} contains<T(==)>(s: Stack<T>, x: T)\n{\n  x in s.elements\n}\n\nfunction {:spec} toSeq<T>(s: Stack<T>): seq<T>\n{\n  s.elements\n}\n\n// Stack from sequence\nfunction {:spec} fromSeq<T>(elements: seq<T>): Stack<T>\n{\n  Stack(elements)\n}\n\n// Multiple push operations\nfunction {:spec} pushAll<T>(s: Stack<T>, items: seq<T>): Stack<T>\n  decreases |items|\n{\n  if |items| == 0 then s\n  else pushAll(push(s, items[0]), items[1..])\n}\n\n// Multiple pop operations\nfunction {:spec} popN<T>(s: Stack<T>, n: nat): Stack<T>\n  requires n <= size(s)\n  decreases n\n{\n  if n == 0 then s\n  else popN(pop(s), n - 1)\n}\n\n// Get the nth element from top (0-indexed)\nfunction {:spec} nthFromTop<T>(s: Stack<T>, n: nat): T\n  requires n < size(s)\n{\n  s.elements[n]\n}\n\nlemma PushPopIdentity<T>(s: Stack<T>, x: T)\n  ensures pop(push(s, x)) == s\n  ensures peek(push(s, x)) == x\n{\n  // Automatic\n}\n\nlemma PopPushNotIdentity<T>(s: Stack<T>, x: T)\n  requires !isEmpty(s)\n  requires x != peek(s)\n  ensures push(pop(s), x) != s\n{\n  assert push(pop(s), x).elements[0] == x;\n  assert s.elements[0] == peek(s);\n  assert x != peek(s);\n}\n\nlemma PushIncreaseSize<T>(s: Stack<T>, x: T)\n  ensures size(push(s, x)) == size(s) + 1\n{\n  // Automatic\n}\n\nlemma PopDecreaseSize<T>(s: Stack<T>)\n  requires !isEmpty(s)\n  ensures size(pop(s)) == size(s) - 1\n{\n  // Automatic\n}\n\nlemma EmptyStackProperties<T>(s: Stack<T>)\n  ensures isEmpty(s) <==> size(s) == 0\n  ensures isEmpty(s) <==> s.elements == []\n{\n  // Automatic\n}\n\nlemma LIFOProperty<T>(s: Stack<T>, x: T, y: T)\n  ensures peek(push(push(s, x), y)) == y\n  ensures peek(pop(push(push(s, x), y))) == x\n{\n  // Automatic - Last In First Out\n}\n\nlemma PushAllCorrect<T>(s: Stack<T>, items: seq<T>)\n  ensures size(pushAll(s, items)) == size(s) + |items|\n  decreases |items|\n{\n  if |items| == 0 {\n    // Base case\n  } else {\n    PushAllCorrect(push(s, items[0]), items[1..]);\n  }\n}\n\nlemma PopNCorrect<T>(s: Stack<T>, n: nat)\n  requires n <= size(s)\n  ensures size(popN(s, n)) == size(s) - n\n  decreases n\n{\n  if n == 0 {\n    // Base case\n  } else {\n    PopNCorrect(pop(s), n - 1);\n  }\n}\n\nlemma PushPreservesContains<T>(s: Stack<T>, x: T, y: T)\n  ensures contains(push(s, x), y) <==> (y == x || contains(s, y))\n{\n  // Automatic\n}\n\nlemma StackToFromSeq<T>(s: Stack<T>)\n  ensures fromSeq(toSeq(s)) == s\n  ensures toSeq(fromSeq(s.elements)) == s.elements\n{\n  // Automatic\n}\n\nlemma PushOrder<T>(s: Stack<T>, x: T, y: T)\n  ensures toSeq(push(push(s, x), y)) == [y, x] + toSeq(s)\n{\n  calc == {\n    toSeq(push(push(s, x), y));\n    push(push(s, x), y).elements;\n    [y] + push(s, x).elements;\n    [y] + ([x] + s.elements);\n    [y, x] + s.elements;\n    [y, x] + toSeq(s);\n  }\n}\n\nlemma NthFromTopCorrect<T>(s: Stack<T>, n: nat)\n  requires n < size(s)\n  ensures nthFromTop(s, n) == toSeq(s)[n]\n{\n  // Automatic\n}\n\nlemma StackInduction<T>(s: Stack<T>)\n  ensures s == emptyStack() || exists x, s' :: s == push(s', x)\n{\n  if isEmpty(s) {\n    \n/*[CODE HERE]*/\n  } else {\n    var s' := pop(s);\n    var x := peek(s);\n    assert s == push(s', x);\n  }\n}", "output": "assert s == emptyStack();"}, {"id": "example_sumToCorrect_0", "type": "assert", "program": "function sumTo(n: nat): nat\n{\n  n * (n + 1) / 2\n}\n\nfunction {:spec} sumToSpec(n: nat): nat\n{\n  if n == 0 then 0\n  else n + sumToSpec(n - 1)\n}\n\nlemma sumToCorrect(n: nat)\n  ensures sumTo(n) == sumToSpec(n)\n{\n  if n == 0 {\n    assert sumTo(0) == 0 * 1 / 2 == 0;\n    assert sumToSpec(0) == 0;\n  } else {\n    sumToCorrect(n - 1);\n    assert sumToSpec(n) == n + sumToSpec(n - 1);\n    assert sumToSpec(n - 1) == sumTo(n - 1);\n    assert sumTo(n - 1) == (n - 1) * n / 2;\n    \n    calc {\n      sumToSpec(n);\n      == n + sumToSpec(n - 1);\n      == n + sumTo(n - 1);\n      == n + (n - 1) * n / 2;\n      == { assert n + (n - 1) * n / 2 == (2 * n + (n - 1) * n) / 2; }\n      (2 * n + (n - 1) * n) / 2;\n      == { \n/*[CODE HERE]*/\n}\n      n * (n + 1) / 2;\n      == sumTo(n);\n    }\n  }\n}\n\nlemma sumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n}\n\nlemma sumToIncreasing(n: nat)\n  ensures sumTo(n + 1) == sumTo(n) + n + 1\n{\n  calc {\n    sumTo(n + 1);\n    == (n + 1) * (n + 2) / 2;\n    == { assert (n + 1) * (n + 2) == n * (n + 1) + 2 * (n + 1); }\n    (n * (n + 1) + 2 * (n + 1)) / 2;\n    == n * (n + 1) / 2 + 2 * (n + 1) / 2;\n    == n * (n + 1) / 2 + (n + 1);\n    == sumTo(n) + n + 1;\n  }\n}", "output": "assert 2 * n + (n - 1) * n == n * (2 + n - 1);"}, {"id": "example_sumToCorrect_1", "type": "assert", "program": "function sumTo(n: nat): nat\n{\n  n * (n + 1) / 2\n}\n\nfunction {:spec} sumToSpec(n: nat): nat\n{\n  if n == 0 then 0\n  else n + sumToSpec(n - 1)\n}\n\nlemma sumToCorrect(n: nat)\n  ensures sumTo(n) == sumToSpec(n)\n{\n  if n == 0 {\n    assert sumTo(0) == 0 * 1 / 2 == 0;\n    assert sumToSpec(0) == 0;\n  } else {\n    sumToCorrect(n - 1);\n    assert sumToSpec(n) == n + sumToSpec(n - 1);\n    assert sumToSpec(n - 1) == sumTo(n - 1);\n    assert sumTo(n - 1) == (n - 1) * n / 2;\n    \n    calc {\n      sumToSpec(n);\n      == n + sumToSpec(n - 1);\n      == n + sumTo(n - 1);\n      == n + (n - 1) * n / 2;\n      == { \n/*[CODE HERE]*/\n}\n      (2 * n + (n - 1) * n) / 2;\n      == { assert 2 * n + (n - 1) * n == n * (2 + n - 1); }\n      n * (n + 1) / 2;\n      == sumTo(n);\n    }\n  }\n}\n\nlemma sumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n}\n\nlemma sumToIncreasing(n: nat)\n  ensures sumTo(n + 1) == sumTo(n) + n + 1\n{\n  calc {\n    sumTo(n + 1);\n    == (n + 1) * (n + 2) / 2;\n    == { assert (n + 1) * (n + 2) == n * (n + 1) + 2 * (n + 1); }\n    (n * (n + 1) + 2 * (n + 1)) / 2;\n    == n * (n + 1) / 2 + 2 * (n + 1) / 2;\n    == n * (n + 1) / 2 + (n + 1);\n    == sumTo(n) + n + 1;\n  }\n}", "output": "assert n + (n - 1) * n / 2 == (2 * n + (n - 1) * n) / 2;"}, {"id": "example_sumToCorrect_2", "type": "assert", "program": "function sumTo(n: nat): nat\n{\n  n * (n + 1) / 2\n}\n\nfunction {:spec} sumToSpec(n: nat): nat\n{\n  if n == 0 then 0\n  else n + sumToSpec(n - 1)\n}\n\nlemma sumToCorrect(n: nat)\n  ensures sumTo(n) == sumToSpec(n)\n{\n  if n == 0 {\n    assert sumTo(0) == 0 * 1 / 2 == 0;\n    assert sumToSpec(0) == 0;\n  } else {\n    sumToCorrect(n - 1);\n    assert sumToSpec(n) == n + sumToSpec(n - 1);\n    assert sumToSpec(n - 1) == sumTo(n - 1);\n    \n/*[CODE HERE]*/\n    \n    calc {\n      sumToSpec(n);\n      == n + sumToSpec(n - 1);\n      == n + sumTo(n - 1);\n      == n + (n - 1) * n / 2;\n      == { assert n + (n - 1) * n / 2 == (2 * n + (n - 1) * n) / 2; }\n      (2 * n + (n - 1) * n) / 2;\n      == { assert 2 * n + (n - 1) * n == n * (2 + n - 1); }\n      n * (n + 1) / 2;\n      == sumTo(n);\n    }\n  }\n}\n\nlemma sumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n}\n\nlemma sumToIncreasing(n: nat)\n  ensures sumTo(n + 1) == sumTo(n) + n + 1\n{\n  calc {\n    sumTo(n + 1);\n    == (n + 1) * (n + 2) / 2;\n    == { assert (n + 1) * (n + 2) == n * (n + 1) + 2 * (n + 1); }\n    (n * (n + 1) + 2 * (n + 1)) / 2;\n    == n * (n + 1) / 2 + 2 * (n + 1) / 2;\n    == n * (n + 1) / 2 + (n + 1);\n    == sumTo(n) + n + 1;\n  }\n}", "output": "assert sumTo(n - 1) == (n - 1) * n / 2;"}, {"id": "example_sumToCorrect_3", "type": "assert", "program": "function sumTo(n: nat): nat\n{\n  n * (n + 1) / 2\n}\n\nfunction {:spec} sumToSpec(n: nat): nat\n{\n  if n == 0 then 0\n  else n + sumToSpec(n - 1)\n}\n\nlemma sumToCorrect(n: nat)\n  ensures sumTo(n) == sumToSpec(n)\n{\n  if n == 0 {\n    assert sumTo(0) == 0 * 1 / 2 == 0;\n    assert sumToSpec(0) == 0;\n  } else {\n    sumToCorrect(n - 1);\n    assert sumToSpec(n) == n + sumToSpec(n - 1);\n    \n/*[CODE HERE]*/\n    assert sumTo(n - 1) == (n - 1) * n / 2;\n    \n    calc {\n      sumToSpec(n);\n      == n + sumToSpec(n - 1);\n      == n + sumTo(n - 1);\n      == n + (n - 1) * n / 2;\n      == { assert n + (n - 1) * n / 2 == (2 * n + (n - 1) * n) / 2; }\n      (2 * n + (n - 1) * n) / 2;\n      == { assert 2 * n + (n - 1) * n == n * (2 + n - 1); }\n      n * (n + 1) / 2;\n      == sumTo(n);\n    }\n  }\n}\n\nlemma sumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n}\n\nlemma sumToIncreasing(n: nat)\n  ensures sumTo(n + 1) == sumTo(n) + n + 1\n{\n  calc {\n    sumTo(n + 1);\n    == (n + 1) * (n + 2) / 2;\n    == { assert (n + 1) * (n + 2) == n * (n + 1) + 2 * (n + 1); }\n    (n * (n + 1) + 2 * (n + 1)) / 2;\n    == n * (n + 1) / 2 + 2 * (n + 1) / 2;\n    == n * (n + 1) / 2 + (n + 1);\n    == sumTo(n) + n + 1;\n  }\n}", "output": "assert sumToSpec(n - 1) == sumTo(n - 1);"}, {"id": "example_sumToCorrect_4", "type": "assert", "program": "function sumTo(n: nat): nat\n{\n  n * (n + 1) / 2\n}\n\nfunction {:spec} sumToSpec(n: nat): nat\n{\n  if n == 0 then 0\n  else n + sumToSpec(n - 1)\n}\n\nlemma sumToCorrect(n: nat)\n  ensures sumTo(n) == sumToSpec(n)\n{\n  if n == 0 {\n    assert sumTo(0) == 0 * 1 / 2 == 0;\n    assert sumToSpec(0) == 0;\n  } else {\n    sumToCorrect(n - 1);\n    \n/*[CODE HERE]*/\n    assert sumToSpec(n - 1) == sumTo(n - 1);\n    assert sumTo(n - 1) == (n - 1) * n / 2;\n    \n    calc {\n      sumToSpec(n);\n      == n + sumToSpec(n - 1);\n      == n + sumTo(n - 1);\n      == n + (n - 1) * n / 2;\n      == { assert n + (n - 1) * n / 2 == (2 * n + (n - 1) * n) / 2; }\n      (2 * n + (n - 1) * n) / 2;\n      == { assert 2 * n + (n - 1) * n == n * (2 + n - 1); }\n      n * (n + 1) / 2;\n      == sumTo(n);\n    }\n  }\n}\n\nlemma sumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n}\n\nlemma sumToIncreasing(n: nat)\n  ensures sumTo(n + 1) == sumTo(n) + n + 1\n{\n  calc {\n    sumTo(n + 1);\n    == (n + 1) * (n + 2) / 2;\n    == { assert (n + 1) * (n + 2) == n * (n + 1) + 2 * (n + 1); }\n    (n * (n + 1) + 2 * (n + 1)) / 2;\n    == n * (n + 1) / 2 + 2 * (n + 1) / 2;\n    == n * (n + 1) / 2 + (n + 1);\n    == sumTo(n) + n + 1;\n  }\n}", "output": "assert sumToSpec(n) == n + sumToSpec(n - 1);"}, {"id": "example_sumToCorrect_5", "type": "call", "program": "function sumTo(n: nat): nat\n{\n  n * (n + 1) / 2\n}\n\nfunction {:spec} sumToSpec(n: nat): nat\n{\n  if n == 0 then 0\n  else n + sumToSpec(n - 1)\n}\n\nlemma sumToCorrect(n: nat)\n  ensures sumTo(n) == sumToSpec(n)\n{\n  if n == 0 {\n    assert sumTo(0) == 0 * 1 / 2 == 0;\n    assert sumToSpec(0) == 0;\n  } else {\n    \n/*[CODE HERE]*/\n    assert sumToSpec(n) == n + sumToSpec(n - 1);\n    assert sumToSpec(n - 1) == sumTo(n - 1);\n    assert sumTo(n - 1) == (n - 1) * n / 2;\n    \n    calc {\n      sumToSpec(n);\n      == n + sumToSpec(n - 1);\n      == n + sumTo(n - 1);\n      == n + (n - 1) * n / 2;\n      == { assert n + (n - 1) * n / 2 == (2 * n + (n - 1) * n) / 2; }\n      (2 * n + (n - 1) * n) / 2;\n      == { assert 2 * n + (n - 1) * n == n * (2 + n - 1); }\n      n * (n + 1) / 2;\n      == sumTo(n);\n    }\n  }\n}\n\nlemma sumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n}\n\nlemma sumToIncreasing(n: nat)\n  ensures sumTo(n + 1) == sumTo(n) + n + 1\n{\n  calc {\n    sumTo(n + 1);\n    == (n + 1) * (n + 2) / 2;\n    == { assert (n + 1) * (n + 2) == n * (n + 1) + 2 * (n + 1); }\n    (n * (n + 1) + 2 * (n + 1)) / 2;\n    == n * (n + 1) / 2 + 2 * (n + 1) / 2;\n    == n * (n + 1) / 2 + (n + 1);\n    == sumTo(n) + n + 1;\n  }\n}", "output": "sumToCorrect(n - 1);"}, {"id": "example_sumToCorrect_6", "type": "assert", "program": "function sumTo(n: nat): nat\n{\n  n * (n + 1) / 2\n}\n\nfunction {:spec} sumToSpec(n: nat): nat\n{\n  if n == 0 then 0\n  else n + sumToSpec(n - 1)\n}\n\nlemma sumToCorrect(n: nat)\n  ensures sumTo(n) == sumToSpec(n)\n{\n  if n == 0 {\n    assert sumTo(0) == 0 * 1 / 2 == 0;\n    \n/*[CODE HERE]*/\n  } else {\n    sumToCorrect(n - 1);\n    assert sumToSpec(n) == n + sumToSpec(n - 1);\n    assert sumToSpec(n - 1) == sumTo(n - 1);\n    assert sumTo(n - 1) == (n - 1) * n / 2;\n    \n    calc {\n      sumToSpec(n);\n      == n + sumToSpec(n - 1);\n      == n + sumTo(n - 1);\n      == n + (n - 1) * n / 2;\n      == { assert n + (n - 1) * n / 2 == (2 * n + (n - 1) * n) / 2; }\n      (2 * n + (n - 1) * n) / 2;\n      == { assert 2 * n + (n - 1) * n == n * (2 + n - 1); }\n      n * (n + 1) / 2;\n      == sumTo(n);\n    }\n  }\n}\n\nlemma sumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n}\n\nlemma sumToIncreasing(n: nat)\n  ensures sumTo(n + 1) == sumTo(n) + n + 1\n{\n  calc {\n    sumTo(n + 1);\n    == (n + 1) * (n + 2) / 2;\n    == { assert (n + 1) * (n + 2) == n * (n + 1) + 2 * (n + 1); }\n    (n * (n + 1) + 2 * (n + 1)) / 2;\n    == n * (n + 1) / 2 + 2 * (n + 1) / 2;\n    == n * (n + 1) / 2 + (n + 1);\n    == sumTo(n) + n + 1;\n  }\n}", "output": "assert sumToSpec(0) == 0;"}, {"id": "example_sumToCorrect_7", "type": "assert", "program": "function sumTo(n: nat): nat\n{\n  n * (n + 1) / 2\n}\n\nfunction {:spec} sumToSpec(n: nat): nat\n{\n  if n == 0 then 0\n  else n + sumToSpec(n - 1)\n}\n\nlemma sumToCorrect(n: nat)\n  ensures sumTo(n) == sumToSpec(n)\n{\n  if n == 0 {\n    \n/*[CODE HERE]*/\n    assert sumToSpec(0) == 0;\n  } else {\n    sumToCorrect(n - 1);\n    assert sumToSpec(n) == n + sumToSpec(n - 1);\n    assert sumToSpec(n - 1) == sumTo(n - 1);\n    assert sumTo(n - 1) == (n - 1) * n / 2;\n    \n    calc {\n      sumToSpec(n);\n      == n + sumToSpec(n - 1);\n      == n + sumTo(n - 1);\n      == n + (n - 1) * n / 2;\n      == { assert n + (n - 1) * n / 2 == (2 * n + (n - 1) * n) / 2; }\n      (2 * n + (n - 1) * n) / 2;\n      == { assert 2 * n + (n - 1) * n == n * (2 + n - 1); }\n      n * (n + 1) / 2;\n      == sumTo(n);\n    }\n  }\n}\n\nlemma sumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n}\n\nlemma sumToIncreasing(n: nat)\n  ensures sumTo(n + 1) == sumTo(n) + n + 1\n{\n  calc {\n    sumTo(n + 1);\n    == (n + 1) * (n + 2) / 2;\n    == { assert (n + 1) * (n + 2) == n * (n + 1) + 2 * (n + 1); }\n    (n * (n + 1) + 2 * (n + 1)) / 2;\n    == n * (n + 1) / 2 + 2 * (n + 1) / 2;\n    == n * (n + 1) / 2 + (n + 1);\n    == sumTo(n) + n + 1;\n  }\n}", "output": "assert sumTo(0) == 0 * 1 / 2 == 0;"}, {"id": "example_sumToIncreasing_0", "type": "assert", "program": "function sumTo(n: nat): nat\n{\n  n * (n + 1) / 2\n}\n\nfunction {:spec} sumToSpec(n: nat): nat\n{\n  if n == 0 then 0\n  else n + sumToSpec(n - 1)\n}\n\nlemma sumToCorrect(n: nat)\n  ensures sumTo(n) == sumToSpec(n)\n{\n  if n == 0 {\n    assert sumTo(0) == 0 * 1 / 2 == 0;\n    assert sumToSpec(0) == 0;\n  } else {\n    sumToCorrect(n - 1);\n    assert sumToSpec(n) == n + sumToSpec(n - 1);\n    assert sumToSpec(n - 1) == sumTo(n - 1);\n    assert sumTo(n - 1) == (n - 1) * n / 2;\n    \n    calc {\n      sumToSpec(n);\n      == n + sumToSpec(n - 1);\n      == n + sumTo(n - 1);\n      == n + (n - 1) * n / 2;\n      == { assert n + (n - 1) * n / 2 == (2 * n + (n - 1) * n) / 2; }\n      (2 * n + (n - 1) * n) / 2;\n      == { assert 2 * n + (n - 1) * n == n * (2 + n - 1); }\n      n * (n + 1) / 2;\n      == sumTo(n);\n    }\n  }\n}\n\nlemma sumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n}\n\nlemma sumToIncreasing(n: nat)\n  ensures sumTo(n + 1) == sumTo(n) + n + 1\n{\n  calc {\n    sumTo(n + 1);\n    == (n + 1) * (n + 2) / 2;\n    == { \n/*[CODE HERE]*/\n}\n    (n * (n + 1) + 2 * (n + 1)) / 2;\n    == n * (n + 1) / 2 + 2 * (n + 1) / 2;\n    == n * (n + 1) / 2 + (n + 1);\n    == sumTo(n) + n + 1;\n  }\n}", "output": "assert (n + 1) * (n + 2) == n * (n + 1) + 2 * (n + 1);"}, {"id": "example_check_activation_0", "type": "assert", "program": "datatype light = Red | Yellow | Green\n\nfunction activation(source: light, target: light): seq<light>\n{\n  if source == target then [source]\n  else if source == Yellow || target == Yellow then [source, target]\n  else [source, Yellow, target]\n}\n\npredicate adjacent_ok(l1: light, l2: light)\n{\n  !(l1 == Red && l2 == Green) && !(l1 == Green && l2 == Red)\n}\n\npredicate all_adjacent_ok(lights: seq<light>)\n{\n  forall i :: 0 <= i < |lights| - 1 ==> adjacent_ok(lights[i], lights[i+1])\n}\n\nlemma check_activation(source: light, target: light)\n  ensures all_adjacent_ok(activation(source, target))\n{\n  var result := activation(source, target);\n  \n  if source == target {\n    assert result == [source];\n    assert |result| == 1;\n    assert all_adjacent_ok(result);\n  } else if source == Yellow || target == Yellow {\n    assert result == [source, target];\n    assert |result| == 2;\n    if source == Yellow {\n      assert adjacent_ok(Yellow, target);\n    } else {\n      assert target == Yellow;\n      assert adjacent_ok(source, Yellow);\n    }\n  } else {\n    assert result == [source, Yellow, target];\n    assert |result| == 3;\n    assert source != Yellow && target != Yellow;\n    assert source != target;\n    assert adjacent_ok(source, Yellow);\n    \n/*[CODE HERE]*/\n  }\n}", "output": "assert adjacent_ok(Yellow, target);"}, {"id": "example_check_activation_1", "type": "assert", "program": "datatype light = Red | Yellow | Green\n\nfunction activation(source: light, target: light): seq<light>\n{\n  if source == target then [source]\n  else if source == Yellow || target == Yellow then [source, target]\n  else [source, Yellow, target]\n}\n\npredicate adjacent_ok(l1: light, l2: light)\n{\n  !(l1 == Red && l2 == Green) && !(l1 == Green && l2 == Red)\n}\n\npredicate all_adjacent_ok(lights: seq<light>)\n{\n  forall i :: 0 <= i < |lights| - 1 ==> adjacent_ok(lights[i], lights[i+1])\n}\n\nlemma check_activation(source: light, target: light)\n  ensures all_adjacent_ok(activation(source, target))\n{\n  var result := activation(source, target);\n  \n  if source == target {\n    assert result == [source];\n    assert |result| == 1;\n    assert all_adjacent_ok(result);\n  } else if source == Yellow || target == Yellow {\n    assert result == [source, target];\n    assert |result| == 2;\n    if source == Yellow {\n      assert adjacent_ok(Yellow, target);\n    } else {\n      assert target == Yellow;\n      assert adjacent_ok(source, Yellow);\n    }\n  } else {\n    assert result == [source, Yellow, target];\n    assert |result| == 3;\n    assert source != Yellow && target != Yellow;\n    assert source != target;\n    \n/*[CODE HERE]*/\n    assert adjacent_ok(Yellow, target);\n  }\n}", "output": "assert adjacent_ok(source, Yellow);"}, {"id": "example_check_activation_2", "type": "assert", "program": "datatype light = Red | Yellow | Green\n\nfunction activation(source: light, target: light): seq<light>\n{\n  if source == target then [source]\n  else if source == Yellow || target == Yellow then [source, target]\n  else [source, Yellow, target]\n}\n\npredicate adjacent_ok(l1: light, l2: light)\n{\n  !(l1 == Red && l2 == Green) && !(l1 == Green && l2 == Red)\n}\n\npredicate all_adjacent_ok(lights: seq<light>)\n{\n  forall i :: 0 <= i < |lights| - 1 ==> adjacent_ok(lights[i], lights[i+1])\n}\n\nlemma check_activation(source: light, target: light)\n  ensures all_adjacent_ok(activation(source, target))\n{\n  var result := activation(source, target);\n  \n  if source == target {\n    assert result == [source];\n    assert |result| == 1;\n    assert all_adjacent_ok(result);\n  } else if source == Yellow || target == Yellow {\n    assert result == [source, target];\n    assert |result| == 2;\n    if source == Yellow {\n      assert adjacent_ok(Yellow, target);\n    } else {\n      assert target == Yellow;\n      assert adjacent_ok(source, Yellow);\n    }\n  } else {\n    assert result == [source, Yellow, target];\n    assert |result| == 3;\n    assert source != Yellow && target != Yellow;\n    \n/*[CODE HERE]*/\n    assert adjacent_ok(source, Yellow);\n    assert adjacent_ok(Yellow, target);\n  }\n}", "output": "assert source != target;"}, {"id": "example_check_activation_3", "type": "assert", "program": "datatype light = Red | Yellow | Green\n\nfunction activation(source: light, target: light): seq<light>\n{\n  if source == target then [source]\n  else if source == Yellow || target == Yellow then [source, target]\n  else [source, Yellow, target]\n}\n\npredicate adjacent_ok(l1: light, l2: light)\n{\n  !(l1 == Red && l2 == Green) && !(l1 == Green && l2 == Red)\n}\n\npredicate all_adjacent_ok(lights: seq<light>)\n{\n  forall i :: 0 <= i < |lights| - 1 ==> adjacent_ok(lights[i], lights[i+1])\n}\n\nlemma check_activation(source: light, target: light)\n  ensures all_adjacent_ok(activation(source, target))\n{\n  var result := activation(source, target);\n  \n  if source == target {\n    assert result == [source];\n    assert |result| == 1;\n    assert all_adjacent_ok(result);\n  } else if source == Yellow || target == Yellow {\n    assert result == [source, target];\n    assert |result| == 2;\n    if source == Yellow {\n      assert adjacent_ok(Yellow, target);\n    } else {\n      assert target == Yellow;\n      assert adjacent_ok(source, Yellow);\n    }\n  } else {\n    assert result == [source, Yellow, target];\n    assert |result| == 3;\n    \n/*[CODE HERE]*/\n    assert source != target;\n    assert adjacent_ok(source, Yellow);\n    assert adjacent_ok(Yellow, target);\n  }\n}", "output": "assert source != Yellow && target != Yellow;"}, {"id": "example_check_activation_4", "type": "assert", "program": "datatype light = Red | Yellow | Green\n\nfunction activation(source: light, target: light): seq<light>\n{\n  if source == target then [source]\n  else if source == Yellow || target == Yellow then [source, target]\n  else [source, Yellow, target]\n}\n\npredicate adjacent_ok(l1: light, l2: light)\n{\n  !(l1 == Red && l2 == Green) && !(l1 == Green && l2 == Red)\n}\n\npredicate all_adjacent_ok(lights: seq<light>)\n{\n  forall i :: 0 <= i < |lights| - 1 ==> adjacent_ok(lights[i], lights[i+1])\n}\n\nlemma check_activation(source: light, target: light)\n  ensures all_adjacent_ok(activation(source, target))\n{\n  var result := activation(source, target);\n  \n  if source == target {\n    assert result == [source];\n    assert |result| == 1;\n    assert all_adjacent_ok(result);\n  } else if source == Yellow || target == Yellow {\n    assert result == [source, target];\n    assert |result| == 2;\n    if source == Yellow {\n      assert adjacent_ok(Yellow, target);\n    } else {\n      assert target == Yellow;\n      assert adjacent_ok(source, Yellow);\n    }\n  } else {\n    assert result == [source, Yellow, target];\n    \n/*[CODE HERE]*/\n    assert source != Yellow && target != Yellow;\n    assert source != target;\n    assert adjacent_ok(source, Yellow);\n    assert adjacent_ok(Yellow, target);\n  }\n}", "output": "assert |result| == 3;"}, {"id": "example_check_activation_5", "type": "assert", "program": "datatype light = Red | Yellow | Green\n\nfunction activation(source: light, target: light): seq<light>\n{\n  if source == target then [source]\n  else if source == Yellow || target == Yellow then [source, target]\n  else [source, Yellow, target]\n}\n\npredicate adjacent_ok(l1: light, l2: light)\n{\n  !(l1 == Red && l2 == Green) && !(l1 == Green && l2 == Red)\n}\n\npredicate all_adjacent_ok(lights: seq<light>)\n{\n  forall i :: 0 <= i < |lights| - 1 ==> adjacent_ok(lights[i], lights[i+1])\n}\n\nlemma check_activation(source: light, target: light)\n  ensures all_adjacent_ok(activation(source, target))\n{\n  var result := activation(source, target);\n  \n  if source == target {\n    assert result == [source];\n    assert |result| == 1;\n    assert all_adjacent_ok(result);\n  } else if source == Yellow || target == Yellow {\n    assert result == [source, target];\n    assert |result| == 2;\n    if source == Yellow {\n      assert adjacent_ok(Yellow, target);\n    } else {\n      assert target == Yellow;\n      assert adjacent_ok(source, Yellow);\n    }\n  } else {\n    \n/*[CODE HERE]*/\n    assert |result| == 3;\n    assert source != Yellow && target != Yellow;\n    assert source != target;\n    assert adjacent_ok(source, Yellow);\n    assert adjacent_ok(Yellow, target);\n  }\n}", "output": "assert result == [source, Yellow, target];"}, {"id": "example_check_activation_6", "type": "assert", "program": "datatype light = Red | Yellow | Green\n\nfunction activation(source: light, target: light): seq<light>\n{\n  if source == target then [source]\n  else if source == Yellow || target == Yellow then [source, target]\n  else [source, Yellow, target]\n}\n\npredicate adjacent_ok(l1: light, l2: light)\n{\n  !(l1 == Red && l2 == Green) && !(l1 == Green && l2 == Red)\n}\n\npredicate all_adjacent_ok(lights: seq<light>)\n{\n  forall i :: 0 <= i < |lights| - 1 ==> adjacent_ok(lights[i], lights[i+1])\n}\n\nlemma check_activation(source: light, target: light)\n  ensures all_adjacent_ok(activation(source, target))\n{\n  var result := activation(source, target);\n  \n  if source == target {\n    assert result == [source];\n    assert |result| == 1;\n    assert all_adjacent_ok(result);\n  } else if source == Yellow || target == Yellow {\n    assert result == [source, target];\n    assert |result| == 2;\n    if source == Yellow {\n      assert adjacent_ok(Yellow, target);\n    } else {\n      assert target == Yellow;\n      \n/*[CODE HERE]*/\n    }\n  } else {\n    assert result == [source, Yellow, target];\n    assert |result| == 3;\n    assert source != Yellow && target != Yellow;\n    assert source != target;\n    assert adjacent_ok(source, Yellow);\n    assert adjacent_ok(Yellow, target);\n  }\n}", "output": "assert adjacent_ok(source, Yellow);"}, {"id": "example_check_activation_7", "type": "assert", "program": "datatype light = Red | Yellow | Green\n\nfunction activation(source: light, target: light): seq<light>\n{\n  if source == target then [source]\n  else if source == Yellow || target == Yellow then [source, target]\n  else [source, Yellow, target]\n}\n\npredicate adjacent_ok(l1: light, l2: light)\n{\n  !(l1 == Red && l2 == Green) && !(l1 == Green && l2 == Red)\n}\n\npredicate all_adjacent_ok(lights: seq<light>)\n{\n  forall i :: 0 <= i < |lights| - 1 ==> adjacent_ok(lights[i], lights[i+1])\n}\n\nlemma check_activation(source: light, target: light)\n  ensures all_adjacent_ok(activation(source, target))\n{\n  var result := activation(source, target);\n  \n  if source == target {\n    assert result == [source];\n    assert |result| == 1;\n    assert all_adjacent_ok(result);\n  } else if source == Yellow || target == Yellow {\n    assert result == [source, target];\n    assert |result| == 2;\n    if source == Yellow {\n      assert adjacent_ok(Yellow, target);\n    } else {\n      \n/*[CODE HERE]*/\n      assert adjacent_ok(source, Yellow);\n    }\n  } else {\n    assert result == [source, Yellow, target];\n    assert |result| == 3;\n    assert source != Yellow && target != Yellow;\n    assert source != target;\n    assert adjacent_ok(source, Yellow);\n    assert adjacent_ok(Yellow, target);\n  }\n}", "output": "assert target == Yellow;"}, {"id": "example_check_activation_8", "type": "assert", "program": "datatype light = Red | Yellow | Green\n\nfunction activation(source: light, target: light): seq<light>\n{\n  if source == target then [source]\n  else if source == Yellow || target == Yellow then [source, target]\n  else [source, Yellow, target]\n}\n\npredicate adjacent_ok(l1: light, l2: light)\n{\n  !(l1 == Red && l2 == Green) && !(l1 == Green && l2 == Red)\n}\n\npredicate all_adjacent_ok(lights: seq<light>)\n{\n  forall i :: 0 <= i < |lights| - 1 ==> adjacent_ok(lights[i], lights[i+1])\n}\n\nlemma check_activation(source: light, target: light)\n  ensures all_adjacent_ok(activation(source, target))\n{\n  var result := activation(source, target);\n  \n  if source == target {\n    assert result == [source];\n    assert |result| == 1;\n    assert all_adjacent_ok(result);\n  } else if source == Yellow || target == Yellow {\n    assert result == [source, target];\n    assert |result| == 2;\n    if source == Yellow {\n      \n/*[CODE HERE]*/\n    } else {\n      assert target == Yellow;\n      assert adjacent_ok(source, Yellow);\n    }\n  } else {\n    assert result == [source, Yellow, target];\n    assert |result| == 3;\n    assert source != Yellow && target != Yellow;\n    assert source != target;\n    assert adjacent_ok(source, Yellow);\n    assert adjacent_ok(Yellow, target);\n  }\n}", "output": "assert adjacent_ok(Yellow, target);"}, {"id": "example_check_activation_9", "type": "assert", "program": "datatype light = Red | Yellow | Green\n\nfunction activation(source: light, target: light): seq<light>\n{\n  if source == target then [source]\n  else if source == Yellow || target == Yellow then [source, target]\n  else [source, Yellow, target]\n}\n\npredicate adjacent_ok(l1: light, l2: light)\n{\n  !(l1 == Red && l2 == Green) && !(l1 == Green && l2 == Red)\n}\n\npredicate all_adjacent_ok(lights: seq<light>)\n{\n  forall i :: 0 <= i < |lights| - 1 ==> adjacent_ok(lights[i], lights[i+1])\n}\n\nlemma check_activation(source: light, target: light)\n  ensures all_adjacent_ok(activation(source, target))\n{\n  var result := activation(source, target);\n  \n  if source == target {\n    assert result == [source];\n    assert |result| == 1;\n    assert all_adjacent_ok(result);\n  } else if source == Yellow || target == Yellow {\n    assert result == [source, target];\n    \n/*[CODE HERE]*/\n    if source == Yellow {\n      assert adjacent_ok(Yellow, target);\n    } else {\n      assert target == Yellow;\n      assert adjacent_ok(source, Yellow);\n    }\n  } else {\n    assert result == [source, Yellow, target];\n    assert |result| == 3;\n    assert source != Yellow && target != Yellow;\n    assert source != target;\n    assert adjacent_ok(source, Yellow);\n    assert adjacent_ok(Yellow, target);\n  }\n}", "output": "assert |result| == 2;"}, {"id": "example_check_activation_10", "type": "assert", "program": "datatype light = Red | Yellow | Green\n\nfunction activation(source: light, target: light): seq<light>\n{\n  if source == target then [source]\n  else if source == Yellow || target == Yellow then [source, target]\n  else [source, Yellow, target]\n}\n\npredicate adjacent_ok(l1: light, l2: light)\n{\n  !(l1 == Red && l2 == Green) && !(l1 == Green && l2 == Red)\n}\n\npredicate all_adjacent_ok(lights: seq<light>)\n{\n  forall i :: 0 <= i < |lights| - 1 ==> adjacent_ok(lights[i], lights[i+1])\n}\n\nlemma check_activation(source: light, target: light)\n  ensures all_adjacent_ok(activation(source, target))\n{\n  var result := activation(source, target);\n  \n  if source == target {\n    assert result == [source];\n    assert |result| == 1;\n    assert all_adjacent_ok(result);\n  } else if source == Yellow || target == Yellow {\n    \n/*[CODE HERE]*/\n    assert |result| == 2;\n    if source == Yellow {\n      assert adjacent_ok(Yellow, target);\n    } else {\n      assert target == Yellow;\n      assert adjacent_ok(source, Yellow);\n    }\n  } else {\n    assert result == [source, Yellow, target];\n    assert |result| == 3;\n    assert source != Yellow && target != Yellow;\n    assert source != target;\n    assert adjacent_ok(source, Yellow);\n    assert adjacent_ok(Yellow, target);\n  }\n}", "output": "assert result == [source, target];"}, {"id": "example_check_activation_11", "type": "assert", "program": "datatype light = Red | Yellow | Green\n\nfunction activation(source: light, target: light): seq<light>\n{\n  if source == target then [source]\n  else if source == Yellow || target == Yellow then [source, target]\n  else [source, Yellow, target]\n}\n\npredicate adjacent_ok(l1: light, l2: light)\n{\n  !(l1 == Red && l2 == Green) && !(l1 == Green && l2 == Red)\n}\n\npredicate all_adjacent_ok(lights: seq<light>)\n{\n  forall i :: 0 <= i < |lights| - 1 ==> adjacent_ok(lights[i], lights[i+1])\n}\n\nlemma check_activation(source: light, target: light)\n  ensures all_adjacent_ok(activation(source, target))\n{\n  var result := activation(source, target);\n  \n  if source == target {\n    assert result == [source];\n    assert |result| == 1;\n    \n/*[CODE HERE]*/\n  } else if source == Yellow || target == Yellow {\n    assert result == [source, target];\n    assert |result| == 2;\n    if source == Yellow {\n      assert adjacent_ok(Yellow, target);\n    } else {\n      assert target == Yellow;\n      assert adjacent_ok(source, Yellow);\n    }\n  } else {\n    assert result == [source, Yellow, target];\n    assert |result| == 3;\n    assert source != Yellow && target != Yellow;\n    assert source != target;\n    assert adjacent_ok(source, Yellow);\n    assert adjacent_ok(Yellow, target);\n  }\n}", "output": "assert all_adjacent_ok(result);"}, {"id": "example_check_activation_12", "type": "assert", "program": "datatype light = Red | Yellow | Green\n\nfunction activation(source: light, target: light): seq<light>\n{\n  if source == target then [source]\n  else if source == Yellow || target == Yellow then [source, target]\n  else [source, Yellow, target]\n}\n\npredicate adjacent_ok(l1: light, l2: light)\n{\n  !(l1 == Red && l2 == Green) && !(l1 == Green && l2 == Red)\n}\n\npredicate all_adjacent_ok(lights: seq<light>)\n{\n  forall i :: 0 <= i < |lights| - 1 ==> adjacent_ok(lights[i], lights[i+1])\n}\n\nlemma check_activation(source: light, target: light)\n  ensures all_adjacent_ok(activation(source, target))\n{\n  var result := activation(source, target);\n  \n  if source == target {\n    assert result == [source];\n    \n/*[CODE HERE]*/\n    assert all_adjacent_ok(result);\n  } else if source == Yellow || target == Yellow {\n    assert result == [source, target];\n    assert |result| == 2;\n    if source == Yellow {\n      assert adjacent_ok(Yellow, target);\n    } else {\n      assert target == Yellow;\n      assert adjacent_ok(source, Yellow);\n    }\n  } else {\n    assert result == [source, Yellow, target];\n    assert |result| == 3;\n    assert source != Yellow && target != Yellow;\n    assert source != target;\n    assert adjacent_ok(source, Yellow);\n    assert adjacent_ok(Yellow, target);\n  }\n}", "output": "assert |result| == 1;"}, {"id": "example_check_activation_13", "type": "assert", "program": "datatype light = Red | Yellow | Green\n\nfunction activation(source: light, target: light): seq<light>\n{\n  if source == target then [source]\n  else if source == Yellow || target == Yellow then [source, target]\n  else [source, Yellow, target]\n}\n\npredicate adjacent_ok(l1: light, l2: light)\n{\n  !(l1 == Red && l2 == Green) && !(l1 == Green && l2 == Red)\n}\n\npredicate all_adjacent_ok(lights: seq<light>)\n{\n  forall i :: 0 <= i < |lights| - 1 ==> adjacent_ok(lights[i], lights[i+1])\n}\n\nlemma check_activation(source: light, target: light)\n  ensures all_adjacent_ok(activation(source, target))\n{\n  var result := activation(source, target);\n  \n  if source == target {\n    \n/*[CODE HERE]*/\n    assert |result| == 1;\n    assert all_adjacent_ok(result);\n  } else if source == Yellow || target == Yellow {\n    assert result == [source, target];\n    assert |result| == 2;\n    if source == Yellow {\n      assert adjacent_ok(Yellow, target);\n    } else {\n      assert target == Yellow;\n      assert adjacent_ok(source, Yellow);\n    }\n  } else {\n    assert result == [source, Yellow, target];\n    assert |result| == 3;\n    assert source != Yellow && target != Yellow;\n    assert source != target;\n    assert adjacent_ok(source, Yellow);\n    assert adjacent_ok(Yellow, target);\n  }\n}", "output": "assert result == [source];"}, {"id": "example_InorderLength_0", "type": "assert", "program": "// Tree operations: size, height, inorder traversal\n\ndatatype BinaryTree<T> = Empty | Node(value: T, left: BinaryTree<T>, right: BinaryTree<T>)\n\nfunction {:spec} treeSize<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, l, r) => 1 + treeSize(l) + treeSize(r)\n}\n\nfunction {:spec} treeHeight<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, l, r) =>\n    var lh := treeHeight(l);\n    var rh := treeHeight(r);\n    1 + if lh > rh then lh else rh\n}\n\nfunction {:spec} inorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => inorder(l) + [v] + inorder(r)\n}\n\nfunction {:spec} preorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => [v] + preorder(l) + preorder(r)\n}\n\nfunction {:spec} postorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => postorder(l) + postorder(r) + [v]\n}\n\npredicate {:spec} isLeaf<T>(t: BinaryTree<T>)\n{\n  t.Node? && t.left == Empty && t.right == Empty\n}\n\nfunction {:spec} leafCount<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, Empty, Empty) => 1\n  case Node(_, l, r) => leafCount(l) + leafCount(r)\n}\n\npredicate {:spec} inTree<T(==)>(x: T, t: BinaryTree<T>)\n{\n  match t\n  case Empty => false\n  case Node(v, l, r) => v == x || inTree(x, l) || inTree(x, r)\n}\n\nfunction {:spec} mirror<T>(t: BinaryTree<T>): BinaryTree<T>\n{\n  match t\n  case Empty => Empty\n  case Node(v, l, r) => Node(v, mirror(r), mirror(l))\n}\n\npredicate {:spec} isBalanced<T>(t: BinaryTree<T>)\n{\n  match t\n  case Empty => true\n  case Node(_, l, r) =>\n    isBalanced(l) && isBalanced(r) &&\n    var diff := if treeHeight(l) > treeHeight(r)\n                then treeHeight(l) - treeHeight(r)\n                else treeHeight(r) - treeHeight(l);\n    diff <= 1\n}\n\nlemma InorderLength<T>(t: BinaryTree<T>)\n  ensures |inorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    InorderLength(l);\n    InorderLength(r);\n    \n/*[CODE HERE]*/\n}\n\nlemma PreorderLength<T>(t: BinaryTree<T>)\n  ensures |preorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    PreorderLength(l);\n    PreorderLength(r);\n}\n\nlemma PostorderLength<T>(t: BinaryTree<T>)\n  ensures |postorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    PostorderLength(l);\n    PostorderLength(r);\n}\n\nlemma MirrorTwice<T>(t: BinaryTree<T>)\n  ensures mirror(mirror(t)) == t\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorTwice(l);\n    MirrorTwice(r);\n}\n\nlemma MirrorSize<T>(t: BinaryTree<T>)\n  ensures treeSize(mirror(t)) == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorSize(l);\n    MirrorSize(r);\n}\n\nlemma MirrorHeight<T>(t: BinaryTree<T>)\n  ensures treeHeight(mirror(t)) == treeHeight(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorHeight(l);\n    MirrorHeight(r);\n    var lh := treeHeight(l);\n    var rh := treeHeight(r);\n    var mlh := treeHeight(mirror(r));\n    var mrh := treeHeight(mirror(l));\n    assert mlh == rh && mrh == lh;\n}\n\nlemma LeafCountBound<T>(t: BinaryTree<T>)\n  ensures leafCount(t) <= treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(_, l, r) =>\n    if l == Empty && r == Empty {\n      assert leafCount(t) == 1;\n      assert treeSize(t) == 1;\n    } else {\n      LeafCountBound(l);\n      LeafCountBound(r);\n    }\n}\n\nlemma InTreeInorder<T>(x: T, t: BinaryTree<T>)\n  ensures inTree(x, t) <==> x in inorder(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    InTreeInorder(x, l);\n    InTreeInorder(x, r);\n    if x == v {\n      assert x in inorder(t);\n    } else if inTree(x, l) {\n      assert x in inorder(l);\n      assert x in inorder(t);\n    } else if inTree(x, r) {\n      assert x in inorder(r);\n      assert x in inorder(t);\n    }\n}\n\nlemma HeightLogBound<T>(t: BinaryTree<T>)\n  requires isBalanced(t) && t != Empty\n  ensures treeHeight(t) <= treeSize(t)\n{\n  match t\n  case Node(_, l, r) =>\n    if l != Empty {\n      HeightLogBound(l);\n    }\n    if r != Empty {\n      HeightLogBound(r);\n    }\n}", "output": "assert |inorder(t)| == |inorder(l)| + 1 + |inorder(r)|;"}, {"id": "example_InorderLength_1", "type": "call", "program": "// Tree operations: size, height, inorder traversal\n\ndatatype BinaryTree<T> = Empty | Node(value: T, left: BinaryTree<T>, right: BinaryTree<T>)\n\nfunction {:spec} treeSize<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, l, r) => 1 + treeSize(l) + treeSize(r)\n}\n\nfunction {:spec} treeHeight<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, l, r) =>\n    var lh := treeHeight(l);\n    var rh := treeHeight(r);\n    1 + if lh > rh then lh else rh\n}\n\nfunction {:spec} inorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => inorder(l) + [v] + inorder(r)\n}\n\nfunction {:spec} preorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => [v] + preorder(l) + preorder(r)\n}\n\nfunction {:spec} postorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => postorder(l) + postorder(r) + [v]\n}\n\npredicate {:spec} isLeaf<T>(t: BinaryTree<T>)\n{\n  t.Node? && t.left == Empty && t.right == Empty\n}\n\nfunction {:spec} leafCount<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, Empty, Empty) => 1\n  case Node(_, l, r) => leafCount(l) + leafCount(r)\n}\n\npredicate {:spec} inTree<T(==)>(x: T, t: BinaryTree<T>)\n{\n  match t\n  case Empty => false\n  case Node(v, l, r) => v == x || inTree(x, l) || inTree(x, r)\n}\n\nfunction {:spec} mirror<T>(t: BinaryTree<T>): BinaryTree<T>\n{\n  match t\n  case Empty => Empty\n  case Node(v, l, r) => Node(v, mirror(r), mirror(l))\n}\n\npredicate {:spec} isBalanced<T>(t: BinaryTree<T>)\n{\n  match t\n  case Empty => true\n  case Node(_, l, r) =>\n    isBalanced(l) && isBalanced(r) &&\n    var diff := if treeHeight(l) > treeHeight(r)\n                then treeHeight(l) - treeHeight(r)\n                else treeHeight(r) - treeHeight(l);\n    diff <= 1\n}\n\nlemma InorderLength<T>(t: BinaryTree<T>)\n  ensures |inorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    InorderLength(l);\n    \n/*[CODE HERE]*/\n    assert |inorder(t)| == |inorder(l)| + 1 + |inorder(r)|;\n}\n\nlemma PreorderLength<T>(t: BinaryTree<T>)\n  ensures |preorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    PreorderLength(l);\n    PreorderLength(r);\n}\n\nlemma PostorderLength<T>(t: BinaryTree<T>)\n  ensures |postorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    PostorderLength(l);\n    PostorderLength(r);\n}\n\nlemma MirrorTwice<T>(t: BinaryTree<T>)\n  ensures mirror(mirror(t)) == t\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorTwice(l);\n    MirrorTwice(r);\n}\n\nlemma MirrorSize<T>(t: BinaryTree<T>)\n  ensures treeSize(mirror(t)) == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorSize(l);\n    MirrorSize(r);\n}\n\nlemma MirrorHeight<T>(t: BinaryTree<T>)\n  ensures treeHeight(mirror(t)) == treeHeight(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorHeight(l);\n    MirrorHeight(r);\n    var lh := treeHeight(l);\n    var rh := treeHeight(r);\n    var mlh := treeHeight(mirror(r));\n    var mrh := treeHeight(mirror(l));\n    assert mlh == rh && mrh == lh;\n}\n\nlemma LeafCountBound<T>(t: BinaryTree<T>)\n  ensures leafCount(t) <= treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(_, l, r) =>\n    if l == Empty && r == Empty {\n      assert leafCount(t) == 1;\n      assert treeSize(t) == 1;\n    } else {\n      LeafCountBound(l);\n      LeafCountBound(r);\n    }\n}\n\nlemma InTreeInorder<T>(x: T, t: BinaryTree<T>)\n  ensures inTree(x, t) <==> x in inorder(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    InTreeInorder(x, l);\n    InTreeInorder(x, r);\n    if x == v {\n      assert x in inorder(t);\n    } else if inTree(x, l) {\n      assert x in inorder(l);\n      assert x in inorder(t);\n    } else if inTree(x, r) {\n      assert x in inorder(r);\n      assert x in inorder(t);\n    }\n}\n\nlemma HeightLogBound<T>(t: BinaryTree<T>)\n  requires isBalanced(t) && t != Empty\n  ensures treeHeight(t) <= treeSize(t)\n{\n  match t\n  case Node(_, l, r) =>\n    if l != Empty {\n      HeightLogBound(l);\n    }\n    if r != Empty {\n      HeightLogBound(r);\n    }\n}", "output": "InorderLength(r);"}, {"id": "example_InorderLength_2", "type": "call", "program": "// Tree operations: size, height, inorder traversal\n\ndatatype BinaryTree<T> = Empty | Node(value: T, left: BinaryTree<T>, right: BinaryTree<T>)\n\nfunction {:spec} treeSize<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, l, r) => 1 + treeSize(l) + treeSize(r)\n}\n\nfunction {:spec} treeHeight<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, l, r) =>\n    var lh := treeHeight(l);\n    var rh := treeHeight(r);\n    1 + if lh > rh then lh else rh\n}\n\nfunction {:spec} inorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => inorder(l) + [v] + inorder(r)\n}\n\nfunction {:spec} preorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => [v] + preorder(l) + preorder(r)\n}\n\nfunction {:spec} postorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => postorder(l) + postorder(r) + [v]\n}\n\npredicate {:spec} isLeaf<T>(t: BinaryTree<T>)\n{\n  t.Node? && t.left == Empty && t.right == Empty\n}\n\nfunction {:spec} leafCount<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, Empty, Empty) => 1\n  case Node(_, l, r) => leafCount(l) + leafCount(r)\n}\n\npredicate {:spec} inTree<T(==)>(x: T, t: BinaryTree<T>)\n{\n  match t\n  case Empty => false\n  case Node(v, l, r) => v == x || inTree(x, l) || inTree(x, r)\n}\n\nfunction {:spec} mirror<T>(t: BinaryTree<T>): BinaryTree<T>\n{\n  match t\n  case Empty => Empty\n  case Node(v, l, r) => Node(v, mirror(r), mirror(l))\n}\n\npredicate {:spec} isBalanced<T>(t: BinaryTree<T>)\n{\n  match t\n  case Empty => true\n  case Node(_, l, r) =>\n    isBalanced(l) && isBalanced(r) &&\n    var diff := if treeHeight(l) > treeHeight(r)\n                then treeHeight(l) - treeHeight(r)\n                else treeHeight(r) - treeHeight(l);\n    diff <= 1\n}\n\nlemma InorderLength<T>(t: BinaryTree<T>)\n  ensures |inorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    \n/*[CODE HERE]*/\n    InorderLength(r);\n    assert |inorder(t)| == |inorder(l)| + 1 + |inorder(r)|;\n}\n\nlemma PreorderLength<T>(t: BinaryTree<T>)\n  ensures |preorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    PreorderLength(l);\n    PreorderLength(r);\n}\n\nlemma PostorderLength<T>(t: BinaryTree<T>)\n  ensures |postorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    PostorderLength(l);\n    PostorderLength(r);\n}\n\nlemma MirrorTwice<T>(t: BinaryTree<T>)\n  ensures mirror(mirror(t)) == t\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorTwice(l);\n    MirrorTwice(r);\n}\n\nlemma MirrorSize<T>(t: BinaryTree<T>)\n  ensures treeSize(mirror(t)) == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorSize(l);\n    MirrorSize(r);\n}\n\nlemma MirrorHeight<T>(t: BinaryTree<T>)\n  ensures treeHeight(mirror(t)) == treeHeight(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorHeight(l);\n    MirrorHeight(r);\n    var lh := treeHeight(l);\n    var rh := treeHeight(r);\n    var mlh := treeHeight(mirror(r));\n    var mrh := treeHeight(mirror(l));\n    assert mlh == rh && mrh == lh;\n}\n\nlemma LeafCountBound<T>(t: BinaryTree<T>)\n  ensures leafCount(t) <= treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(_, l, r) =>\n    if l == Empty && r == Empty {\n      assert leafCount(t) == 1;\n      assert treeSize(t) == 1;\n    } else {\n      LeafCountBound(l);\n      LeafCountBound(r);\n    }\n}\n\nlemma InTreeInorder<T>(x: T, t: BinaryTree<T>)\n  ensures inTree(x, t) <==> x in inorder(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    InTreeInorder(x, l);\n    InTreeInorder(x, r);\n    if x == v {\n      assert x in inorder(t);\n    } else if inTree(x, l) {\n      assert x in inorder(l);\n      assert x in inorder(t);\n    } else if inTree(x, r) {\n      assert x in inorder(r);\n      assert x in inorder(t);\n    }\n}\n\nlemma HeightLogBound<T>(t: BinaryTree<T>)\n  requires isBalanced(t) && t != Empty\n  ensures treeHeight(t) <= treeSize(t)\n{\n  match t\n  case Node(_, l, r) =>\n    if l != Empty {\n      HeightLogBound(l);\n    }\n    if r != Empty {\n      HeightLogBound(r);\n    }\n}", "output": "InorderLength(l);"}, {"id": "example_PreorderLength_0", "type": "call", "program": "// Tree operations: size, height, inorder traversal\n\ndatatype BinaryTree<T> = Empty | Node(value: T, left: BinaryTree<T>, right: BinaryTree<T>)\n\nfunction {:spec} treeSize<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, l, r) => 1 + treeSize(l) + treeSize(r)\n}\n\nfunction {:spec} treeHeight<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, l, r) =>\n    var lh := treeHeight(l);\n    var rh := treeHeight(r);\n    1 + if lh > rh then lh else rh\n}\n\nfunction {:spec} inorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => inorder(l) + [v] + inorder(r)\n}\n\nfunction {:spec} preorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => [v] + preorder(l) + preorder(r)\n}\n\nfunction {:spec} postorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => postorder(l) + postorder(r) + [v]\n}\n\npredicate {:spec} isLeaf<T>(t: BinaryTree<T>)\n{\n  t.Node? && t.left == Empty && t.right == Empty\n}\n\nfunction {:spec} leafCount<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, Empty, Empty) => 1\n  case Node(_, l, r) => leafCount(l) + leafCount(r)\n}\n\npredicate {:spec} inTree<T(==)>(x: T, t: BinaryTree<T>)\n{\n  match t\n  case Empty => false\n  case Node(v, l, r) => v == x || inTree(x, l) || inTree(x, r)\n}\n\nfunction {:spec} mirror<T>(t: BinaryTree<T>): BinaryTree<T>\n{\n  match t\n  case Empty => Empty\n  case Node(v, l, r) => Node(v, mirror(r), mirror(l))\n}\n\npredicate {:spec} isBalanced<T>(t: BinaryTree<T>)\n{\n  match t\n  case Empty => true\n  case Node(_, l, r) =>\n    isBalanced(l) && isBalanced(r) &&\n    var diff := if treeHeight(l) > treeHeight(r)\n                then treeHeight(l) - treeHeight(r)\n                else treeHeight(r) - treeHeight(l);\n    diff <= 1\n}\n\nlemma InorderLength<T>(t: BinaryTree<T>)\n  ensures |inorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    InorderLength(l);\n    InorderLength(r);\n    assert |inorder(t)| == |inorder(l)| + 1 + |inorder(r)|;\n}\n\nlemma PreorderLength<T>(t: BinaryTree<T>)\n  ensures |preorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    PreorderLength(l);\n    \n/*[CODE HERE]*/\n}\n\nlemma PostorderLength<T>(t: BinaryTree<T>)\n  ensures |postorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    PostorderLength(l);\n    PostorderLength(r);\n}\n\nlemma MirrorTwice<T>(t: BinaryTree<T>)\n  ensures mirror(mirror(t)) == t\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorTwice(l);\n    MirrorTwice(r);\n}\n\nlemma MirrorSize<T>(t: BinaryTree<T>)\n  ensures treeSize(mirror(t)) == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorSize(l);\n    MirrorSize(r);\n}\n\nlemma MirrorHeight<T>(t: BinaryTree<T>)\n  ensures treeHeight(mirror(t)) == treeHeight(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorHeight(l);\n    MirrorHeight(r);\n    var lh := treeHeight(l);\n    var rh := treeHeight(r);\n    var mlh := treeHeight(mirror(r));\n    var mrh := treeHeight(mirror(l));\n    assert mlh == rh && mrh == lh;\n}\n\nlemma LeafCountBound<T>(t: BinaryTree<T>)\n  ensures leafCount(t) <= treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(_, l, r) =>\n    if l == Empty && r == Empty {\n      assert leafCount(t) == 1;\n      assert treeSize(t) == 1;\n    } else {\n      LeafCountBound(l);\n      LeafCountBound(r);\n    }\n}\n\nlemma InTreeInorder<T>(x: T, t: BinaryTree<T>)\n  ensures inTree(x, t) <==> x in inorder(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    InTreeInorder(x, l);\n    InTreeInorder(x, r);\n    if x == v {\n      assert x in inorder(t);\n    } else if inTree(x, l) {\n      assert x in inorder(l);\n      assert x in inorder(t);\n    } else if inTree(x, r) {\n      assert x in inorder(r);\n      assert x in inorder(t);\n    }\n}\n\nlemma HeightLogBound<T>(t: BinaryTree<T>)\n  requires isBalanced(t) && t != Empty\n  ensures treeHeight(t) <= treeSize(t)\n{\n  match t\n  case Node(_, l, r) =>\n    if l != Empty {\n      HeightLogBound(l);\n    }\n    if r != Empty {\n      HeightLogBound(r);\n    }\n}", "output": "PreorderLength(r);"}, {"id": "example_PreorderLength_1", "type": "call", "program": "// Tree operations: size, height, inorder traversal\n\ndatatype BinaryTree<T> = Empty | Node(value: T, left: BinaryTree<T>, right: BinaryTree<T>)\n\nfunction {:spec} treeSize<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, l, r) => 1 + treeSize(l) + treeSize(r)\n}\n\nfunction {:spec} treeHeight<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, l, r) =>\n    var lh := treeHeight(l);\n    var rh := treeHeight(r);\n    1 + if lh > rh then lh else rh\n}\n\nfunction {:spec} inorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => inorder(l) + [v] + inorder(r)\n}\n\nfunction {:spec} preorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => [v] + preorder(l) + preorder(r)\n}\n\nfunction {:spec} postorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => postorder(l) + postorder(r) + [v]\n}\n\npredicate {:spec} isLeaf<T>(t: BinaryTree<T>)\n{\n  t.Node? && t.left == Empty && t.right == Empty\n}\n\nfunction {:spec} leafCount<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, Empty, Empty) => 1\n  case Node(_, l, r) => leafCount(l) + leafCount(r)\n}\n\npredicate {:spec} inTree<T(==)>(x: T, t: BinaryTree<T>)\n{\n  match t\n  case Empty => false\n  case Node(v, l, r) => v == x || inTree(x, l) || inTree(x, r)\n}\n\nfunction {:spec} mirror<T>(t: BinaryTree<T>): BinaryTree<T>\n{\n  match t\n  case Empty => Empty\n  case Node(v, l, r) => Node(v, mirror(r), mirror(l))\n}\n\npredicate {:spec} isBalanced<T>(t: BinaryTree<T>)\n{\n  match t\n  case Empty => true\n  case Node(_, l, r) =>\n    isBalanced(l) && isBalanced(r) &&\n    var diff := if treeHeight(l) > treeHeight(r)\n                then treeHeight(l) - treeHeight(r)\n                else treeHeight(r) - treeHeight(l);\n    diff <= 1\n}\n\nlemma InorderLength<T>(t: BinaryTree<T>)\n  ensures |inorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    InorderLength(l);\n    InorderLength(r);\n    assert |inorder(t)| == |inorder(l)| + 1 + |inorder(r)|;\n}\n\nlemma PreorderLength<T>(t: BinaryTree<T>)\n  ensures |preorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    \n/*[CODE HERE]*/\n    PreorderLength(r);\n}\n\nlemma PostorderLength<T>(t: BinaryTree<T>)\n  ensures |postorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    PostorderLength(l);\n    PostorderLength(r);\n}\n\nlemma MirrorTwice<T>(t: BinaryTree<T>)\n  ensures mirror(mirror(t)) == t\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorTwice(l);\n    MirrorTwice(r);\n}\n\nlemma MirrorSize<T>(t: BinaryTree<T>)\n  ensures treeSize(mirror(t)) == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorSize(l);\n    MirrorSize(r);\n}\n\nlemma MirrorHeight<T>(t: BinaryTree<T>)\n  ensures treeHeight(mirror(t)) == treeHeight(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorHeight(l);\n    MirrorHeight(r);\n    var lh := treeHeight(l);\n    var rh := treeHeight(r);\n    var mlh := treeHeight(mirror(r));\n    var mrh := treeHeight(mirror(l));\n    assert mlh == rh && mrh == lh;\n}\n\nlemma LeafCountBound<T>(t: BinaryTree<T>)\n  ensures leafCount(t) <= treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(_, l, r) =>\n    if l == Empty && r == Empty {\n      assert leafCount(t) == 1;\n      assert treeSize(t) == 1;\n    } else {\n      LeafCountBound(l);\n      LeafCountBound(r);\n    }\n}\n\nlemma InTreeInorder<T>(x: T, t: BinaryTree<T>)\n  ensures inTree(x, t) <==> x in inorder(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    InTreeInorder(x, l);\n    InTreeInorder(x, r);\n    if x == v {\n      assert x in inorder(t);\n    } else if inTree(x, l) {\n      assert x in inorder(l);\n      assert x in inorder(t);\n    } else if inTree(x, r) {\n      assert x in inorder(r);\n      assert x in inorder(t);\n    }\n}\n\nlemma HeightLogBound<T>(t: BinaryTree<T>)\n  requires isBalanced(t) && t != Empty\n  ensures treeHeight(t) <= treeSize(t)\n{\n  match t\n  case Node(_, l, r) =>\n    if l != Empty {\n      HeightLogBound(l);\n    }\n    if r != Empty {\n      HeightLogBound(r);\n    }\n}", "output": "PreorderLength(l);"}, {"id": "example_PostorderLength_0", "type": "call", "program": "// Tree operations: size, height, inorder traversal\n\ndatatype BinaryTree<T> = Empty | Node(value: T, left: BinaryTree<T>, right: BinaryTree<T>)\n\nfunction {:spec} treeSize<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, l, r) => 1 + treeSize(l) + treeSize(r)\n}\n\nfunction {:spec} treeHeight<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, l, r) =>\n    var lh := treeHeight(l);\n    var rh := treeHeight(r);\n    1 + if lh > rh then lh else rh\n}\n\nfunction {:spec} inorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => inorder(l) + [v] + inorder(r)\n}\n\nfunction {:spec} preorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => [v] + preorder(l) + preorder(r)\n}\n\nfunction {:spec} postorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => postorder(l) + postorder(r) + [v]\n}\n\npredicate {:spec} isLeaf<T>(t: BinaryTree<T>)\n{\n  t.Node? && t.left == Empty && t.right == Empty\n}\n\nfunction {:spec} leafCount<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, Empty, Empty) => 1\n  case Node(_, l, r) => leafCount(l) + leafCount(r)\n}\n\npredicate {:spec} inTree<T(==)>(x: T, t: BinaryTree<T>)\n{\n  match t\n  case Empty => false\n  case Node(v, l, r) => v == x || inTree(x, l) || inTree(x, r)\n}\n\nfunction {:spec} mirror<T>(t: BinaryTree<T>): BinaryTree<T>\n{\n  match t\n  case Empty => Empty\n  case Node(v, l, r) => Node(v, mirror(r), mirror(l))\n}\n\npredicate {:spec} isBalanced<T>(t: BinaryTree<T>)\n{\n  match t\n  case Empty => true\n  case Node(_, l, r) =>\n    isBalanced(l) && isBalanced(r) &&\n    var diff := if treeHeight(l) > treeHeight(r)\n                then treeHeight(l) - treeHeight(r)\n                else treeHeight(r) - treeHeight(l);\n    diff <= 1\n}\n\nlemma InorderLength<T>(t: BinaryTree<T>)\n  ensures |inorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    InorderLength(l);\n    InorderLength(r);\n    assert |inorder(t)| == |inorder(l)| + 1 + |inorder(r)|;\n}\n\nlemma PreorderLength<T>(t: BinaryTree<T>)\n  ensures |preorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    PreorderLength(l);\n    PreorderLength(r);\n}\n\nlemma PostorderLength<T>(t: BinaryTree<T>)\n  ensures |postorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    PostorderLength(l);\n    \n/*[CODE HERE]*/\n}\n\nlemma MirrorTwice<T>(t: BinaryTree<T>)\n  ensures mirror(mirror(t)) == t\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorTwice(l);\n    MirrorTwice(r);\n}\n\nlemma MirrorSize<T>(t: BinaryTree<T>)\n  ensures treeSize(mirror(t)) == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorSize(l);\n    MirrorSize(r);\n}\n\nlemma MirrorHeight<T>(t: BinaryTree<T>)\n  ensures treeHeight(mirror(t)) == treeHeight(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorHeight(l);\n    MirrorHeight(r);\n    var lh := treeHeight(l);\n    var rh := treeHeight(r);\n    var mlh := treeHeight(mirror(r));\n    var mrh := treeHeight(mirror(l));\n    assert mlh == rh && mrh == lh;\n}\n\nlemma LeafCountBound<T>(t: BinaryTree<T>)\n  ensures leafCount(t) <= treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(_, l, r) =>\n    if l == Empty && r == Empty {\n      assert leafCount(t) == 1;\n      assert treeSize(t) == 1;\n    } else {\n      LeafCountBound(l);\n      LeafCountBound(r);\n    }\n}\n\nlemma InTreeInorder<T>(x: T, t: BinaryTree<T>)\n  ensures inTree(x, t) <==> x in inorder(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    InTreeInorder(x, l);\n    InTreeInorder(x, r);\n    if x == v {\n      assert x in inorder(t);\n    } else if inTree(x, l) {\n      assert x in inorder(l);\n      assert x in inorder(t);\n    } else if inTree(x, r) {\n      assert x in inorder(r);\n      assert x in inorder(t);\n    }\n}\n\nlemma HeightLogBound<T>(t: BinaryTree<T>)\n  requires isBalanced(t) && t != Empty\n  ensures treeHeight(t) <= treeSize(t)\n{\n  match t\n  case Node(_, l, r) =>\n    if l != Empty {\n      HeightLogBound(l);\n    }\n    if r != Empty {\n      HeightLogBound(r);\n    }\n}", "output": "PostorderLength(r);"}, {"id": "example_PostorderLength_1", "type": "call", "program": "// Tree operations: size, height, inorder traversal\n\ndatatype BinaryTree<T> = Empty | Node(value: T, left: BinaryTree<T>, right: BinaryTree<T>)\n\nfunction {:spec} treeSize<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, l, r) => 1 + treeSize(l) + treeSize(r)\n}\n\nfunction {:spec} treeHeight<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, l, r) =>\n    var lh := treeHeight(l);\n    var rh := treeHeight(r);\n    1 + if lh > rh then lh else rh\n}\n\nfunction {:spec} inorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => inorder(l) + [v] + inorder(r)\n}\n\nfunction {:spec} preorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => [v] + preorder(l) + preorder(r)\n}\n\nfunction {:spec} postorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => postorder(l) + postorder(r) + [v]\n}\n\npredicate {:spec} isLeaf<T>(t: BinaryTree<T>)\n{\n  t.Node? && t.left == Empty && t.right == Empty\n}\n\nfunction {:spec} leafCount<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, Empty, Empty) => 1\n  case Node(_, l, r) => leafCount(l) + leafCount(r)\n}\n\npredicate {:spec} inTree<T(==)>(x: T, t: BinaryTree<T>)\n{\n  match t\n  case Empty => false\n  case Node(v, l, r) => v == x || inTree(x, l) || inTree(x, r)\n}\n\nfunction {:spec} mirror<T>(t: BinaryTree<T>): BinaryTree<T>\n{\n  match t\n  case Empty => Empty\n  case Node(v, l, r) => Node(v, mirror(r), mirror(l))\n}\n\npredicate {:spec} isBalanced<T>(t: BinaryTree<T>)\n{\n  match t\n  case Empty => true\n  case Node(_, l, r) =>\n    isBalanced(l) && isBalanced(r) &&\n    var diff := if treeHeight(l) > treeHeight(r)\n                then treeHeight(l) - treeHeight(r)\n                else treeHeight(r) - treeHeight(l);\n    diff <= 1\n}\n\nlemma InorderLength<T>(t: BinaryTree<T>)\n  ensures |inorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    InorderLength(l);\n    InorderLength(r);\n    assert |inorder(t)| == |inorder(l)| + 1 + |inorder(r)|;\n}\n\nlemma PreorderLength<T>(t: BinaryTree<T>)\n  ensures |preorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    PreorderLength(l);\n    PreorderLength(r);\n}\n\nlemma PostorderLength<T>(t: BinaryTree<T>)\n  ensures |postorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    \n/*[CODE HERE]*/\n    PostorderLength(r);\n}\n\nlemma MirrorTwice<T>(t: BinaryTree<T>)\n  ensures mirror(mirror(t)) == t\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorTwice(l);\n    MirrorTwice(r);\n}\n\nlemma MirrorSize<T>(t: BinaryTree<T>)\n  ensures treeSize(mirror(t)) == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorSize(l);\n    MirrorSize(r);\n}\n\nlemma MirrorHeight<T>(t: BinaryTree<T>)\n  ensures treeHeight(mirror(t)) == treeHeight(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorHeight(l);\n    MirrorHeight(r);\n    var lh := treeHeight(l);\n    var rh := treeHeight(r);\n    var mlh := treeHeight(mirror(r));\n    var mrh := treeHeight(mirror(l));\n    assert mlh == rh && mrh == lh;\n}\n\nlemma LeafCountBound<T>(t: BinaryTree<T>)\n  ensures leafCount(t) <= treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(_, l, r) =>\n    if l == Empty && r == Empty {\n      assert leafCount(t) == 1;\n      assert treeSize(t) == 1;\n    } else {\n      LeafCountBound(l);\n      LeafCountBound(r);\n    }\n}\n\nlemma InTreeInorder<T>(x: T, t: BinaryTree<T>)\n  ensures inTree(x, t) <==> x in inorder(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    InTreeInorder(x, l);\n    InTreeInorder(x, r);\n    if x == v {\n      assert x in inorder(t);\n    } else if inTree(x, l) {\n      assert x in inorder(l);\n      assert x in inorder(t);\n    } else if inTree(x, r) {\n      assert x in inorder(r);\n      assert x in inorder(t);\n    }\n}\n\nlemma HeightLogBound<T>(t: BinaryTree<T>)\n  requires isBalanced(t) && t != Empty\n  ensures treeHeight(t) <= treeSize(t)\n{\n  match t\n  case Node(_, l, r) =>\n    if l != Empty {\n      HeightLogBound(l);\n    }\n    if r != Empty {\n      HeightLogBound(r);\n    }\n}", "output": "PostorderLength(l);"}, {"id": "example_MirrorTwice_0", "type": "call", "program": "// Tree operations: size, height, inorder traversal\n\ndatatype BinaryTree<T> = Empty | Node(value: T, left: BinaryTree<T>, right: BinaryTree<T>)\n\nfunction {:spec} treeSize<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, l, r) => 1 + treeSize(l) + treeSize(r)\n}\n\nfunction {:spec} treeHeight<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, l, r) =>\n    var lh := treeHeight(l);\n    var rh := treeHeight(r);\n    1 + if lh > rh then lh else rh\n}\n\nfunction {:spec} inorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => inorder(l) + [v] + inorder(r)\n}\n\nfunction {:spec} preorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => [v] + preorder(l) + preorder(r)\n}\n\nfunction {:spec} postorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => postorder(l) + postorder(r) + [v]\n}\n\npredicate {:spec} isLeaf<T>(t: BinaryTree<T>)\n{\n  t.Node? && t.left == Empty && t.right == Empty\n}\n\nfunction {:spec} leafCount<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, Empty, Empty) => 1\n  case Node(_, l, r) => leafCount(l) + leafCount(r)\n}\n\npredicate {:spec} inTree<T(==)>(x: T, t: BinaryTree<T>)\n{\n  match t\n  case Empty => false\n  case Node(v, l, r) => v == x || inTree(x, l) || inTree(x, r)\n}\n\nfunction {:spec} mirror<T>(t: BinaryTree<T>): BinaryTree<T>\n{\n  match t\n  case Empty => Empty\n  case Node(v, l, r) => Node(v, mirror(r), mirror(l))\n}\n\npredicate {:spec} isBalanced<T>(t: BinaryTree<T>)\n{\n  match t\n  case Empty => true\n  case Node(_, l, r) =>\n    isBalanced(l) && isBalanced(r) &&\n    var diff := if treeHeight(l) > treeHeight(r)\n                then treeHeight(l) - treeHeight(r)\n                else treeHeight(r) - treeHeight(l);\n    diff <= 1\n}\n\nlemma InorderLength<T>(t: BinaryTree<T>)\n  ensures |inorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    InorderLength(l);\n    InorderLength(r);\n    assert |inorder(t)| == |inorder(l)| + 1 + |inorder(r)|;\n}\n\nlemma PreorderLength<T>(t: BinaryTree<T>)\n  ensures |preorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    PreorderLength(l);\n    PreorderLength(r);\n}\n\nlemma PostorderLength<T>(t: BinaryTree<T>)\n  ensures |postorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    PostorderLength(l);\n    PostorderLength(r);\n}\n\nlemma MirrorTwice<T>(t: BinaryTree<T>)\n  ensures mirror(mirror(t)) == t\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorTwice(l);\n    \n/*[CODE HERE]*/\n}\n\nlemma MirrorSize<T>(t: BinaryTree<T>)\n  ensures treeSize(mirror(t)) == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorSize(l);\n    MirrorSize(r);\n}\n\nlemma MirrorHeight<T>(t: BinaryTree<T>)\n  ensures treeHeight(mirror(t)) == treeHeight(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorHeight(l);\n    MirrorHeight(r);\n    var lh := treeHeight(l);\n    var rh := treeHeight(r);\n    var mlh := treeHeight(mirror(r));\n    var mrh := treeHeight(mirror(l));\n    assert mlh == rh && mrh == lh;\n}\n\nlemma LeafCountBound<T>(t: BinaryTree<T>)\n  ensures leafCount(t) <= treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(_, l, r) =>\n    if l == Empty && r == Empty {\n      assert leafCount(t) == 1;\n      assert treeSize(t) == 1;\n    } else {\n      LeafCountBound(l);\n      LeafCountBound(r);\n    }\n}\n\nlemma InTreeInorder<T>(x: T, t: BinaryTree<T>)\n  ensures inTree(x, t) <==> x in inorder(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    InTreeInorder(x, l);\n    InTreeInorder(x, r);\n    if x == v {\n      assert x in inorder(t);\n    } else if inTree(x, l) {\n      assert x in inorder(l);\n      assert x in inorder(t);\n    } else if inTree(x, r) {\n      assert x in inorder(r);\n      assert x in inorder(t);\n    }\n}\n\nlemma HeightLogBound<T>(t: BinaryTree<T>)\n  requires isBalanced(t) && t != Empty\n  ensures treeHeight(t) <= treeSize(t)\n{\n  match t\n  case Node(_, l, r) =>\n    if l != Empty {\n      HeightLogBound(l);\n    }\n    if r != Empty {\n      HeightLogBound(r);\n    }\n}", "output": "MirrorTwice(r);"}, {"id": "example_MirrorTwice_1", "type": "call", "program": "// Tree operations: size, height, inorder traversal\n\ndatatype BinaryTree<T> = Empty | Node(value: T, left: BinaryTree<T>, right: BinaryTree<T>)\n\nfunction {:spec} treeSize<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, l, r) => 1 + treeSize(l) + treeSize(r)\n}\n\nfunction {:spec} treeHeight<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, l, r) =>\n    var lh := treeHeight(l);\n    var rh := treeHeight(r);\n    1 + if lh > rh then lh else rh\n}\n\nfunction {:spec} inorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => inorder(l) + [v] + inorder(r)\n}\n\nfunction {:spec} preorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => [v] + preorder(l) + preorder(r)\n}\n\nfunction {:spec} postorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => postorder(l) + postorder(r) + [v]\n}\n\npredicate {:spec} isLeaf<T>(t: BinaryTree<T>)\n{\n  t.Node? && t.left == Empty && t.right == Empty\n}\n\nfunction {:spec} leafCount<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, Empty, Empty) => 1\n  case Node(_, l, r) => leafCount(l) + leafCount(r)\n}\n\npredicate {:spec} inTree<T(==)>(x: T, t: BinaryTree<T>)\n{\n  match t\n  case Empty => false\n  case Node(v, l, r) => v == x || inTree(x, l) || inTree(x, r)\n}\n\nfunction {:spec} mirror<T>(t: BinaryTree<T>): BinaryTree<T>\n{\n  match t\n  case Empty => Empty\n  case Node(v, l, r) => Node(v, mirror(r), mirror(l))\n}\n\npredicate {:spec} isBalanced<T>(t: BinaryTree<T>)\n{\n  match t\n  case Empty => true\n  case Node(_, l, r) =>\n    isBalanced(l) && isBalanced(r) &&\n    var diff := if treeHeight(l) > treeHeight(r)\n                then treeHeight(l) - treeHeight(r)\n                else treeHeight(r) - treeHeight(l);\n    diff <= 1\n}\n\nlemma InorderLength<T>(t: BinaryTree<T>)\n  ensures |inorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    InorderLength(l);\n    InorderLength(r);\n    assert |inorder(t)| == |inorder(l)| + 1 + |inorder(r)|;\n}\n\nlemma PreorderLength<T>(t: BinaryTree<T>)\n  ensures |preorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    PreorderLength(l);\n    PreorderLength(r);\n}\n\nlemma PostorderLength<T>(t: BinaryTree<T>)\n  ensures |postorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    PostorderLength(l);\n    PostorderLength(r);\n}\n\nlemma MirrorTwice<T>(t: BinaryTree<T>)\n  ensures mirror(mirror(t)) == t\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    \n/*[CODE HERE]*/\n    MirrorTwice(r);\n}\n\nlemma MirrorSize<T>(t: BinaryTree<T>)\n  ensures treeSize(mirror(t)) == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorSize(l);\n    MirrorSize(r);\n}\n\nlemma MirrorHeight<T>(t: BinaryTree<T>)\n  ensures treeHeight(mirror(t)) == treeHeight(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorHeight(l);\n    MirrorHeight(r);\n    var lh := treeHeight(l);\n    var rh := treeHeight(r);\n    var mlh := treeHeight(mirror(r));\n    var mrh := treeHeight(mirror(l));\n    assert mlh == rh && mrh == lh;\n}\n\nlemma LeafCountBound<T>(t: BinaryTree<T>)\n  ensures leafCount(t) <= treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(_, l, r) =>\n    if l == Empty && r == Empty {\n      assert leafCount(t) == 1;\n      assert treeSize(t) == 1;\n    } else {\n      LeafCountBound(l);\n      LeafCountBound(r);\n    }\n}\n\nlemma InTreeInorder<T>(x: T, t: BinaryTree<T>)\n  ensures inTree(x, t) <==> x in inorder(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    InTreeInorder(x, l);\n    InTreeInorder(x, r);\n    if x == v {\n      assert x in inorder(t);\n    } else if inTree(x, l) {\n      assert x in inorder(l);\n      assert x in inorder(t);\n    } else if inTree(x, r) {\n      assert x in inorder(r);\n      assert x in inorder(t);\n    }\n}\n\nlemma HeightLogBound<T>(t: BinaryTree<T>)\n  requires isBalanced(t) && t != Empty\n  ensures treeHeight(t) <= treeSize(t)\n{\n  match t\n  case Node(_, l, r) =>\n    if l != Empty {\n      HeightLogBound(l);\n    }\n    if r != Empty {\n      HeightLogBound(r);\n    }\n}", "output": "MirrorTwice(l);"}, {"id": "example_MirrorSize_0", "type": "call", "program": "// Tree operations: size, height, inorder traversal\n\ndatatype BinaryTree<T> = Empty | Node(value: T, left: BinaryTree<T>, right: BinaryTree<T>)\n\nfunction {:spec} treeSize<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, l, r) => 1 + treeSize(l) + treeSize(r)\n}\n\nfunction {:spec} treeHeight<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, l, r) =>\n    var lh := treeHeight(l);\n    var rh := treeHeight(r);\n    1 + if lh > rh then lh else rh\n}\n\nfunction {:spec} inorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => inorder(l) + [v] + inorder(r)\n}\n\nfunction {:spec} preorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => [v] + preorder(l) + preorder(r)\n}\n\nfunction {:spec} postorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => postorder(l) + postorder(r) + [v]\n}\n\npredicate {:spec} isLeaf<T>(t: BinaryTree<T>)\n{\n  t.Node? && t.left == Empty && t.right == Empty\n}\n\nfunction {:spec} leafCount<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, Empty, Empty) => 1\n  case Node(_, l, r) => leafCount(l) + leafCount(r)\n}\n\npredicate {:spec} inTree<T(==)>(x: T, t: BinaryTree<T>)\n{\n  match t\n  case Empty => false\n  case Node(v, l, r) => v == x || inTree(x, l) || inTree(x, r)\n}\n\nfunction {:spec} mirror<T>(t: BinaryTree<T>): BinaryTree<T>\n{\n  match t\n  case Empty => Empty\n  case Node(v, l, r) => Node(v, mirror(r), mirror(l))\n}\n\npredicate {:spec} isBalanced<T>(t: BinaryTree<T>)\n{\n  match t\n  case Empty => true\n  case Node(_, l, r) =>\n    isBalanced(l) && isBalanced(r) &&\n    var diff := if treeHeight(l) > treeHeight(r)\n                then treeHeight(l) - treeHeight(r)\n                else treeHeight(r) - treeHeight(l);\n    diff <= 1\n}\n\nlemma InorderLength<T>(t: BinaryTree<T>)\n  ensures |inorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    InorderLength(l);\n    InorderLength(r);\n    assert |inorder(t)| == |inorder(l)| + 1 + |inorder(r)|;\n}\n\nlemma PreorderLength<T>(t: BinaryTree<T>)\n  ensures |preorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    PreorderLength(l);\n    PreorderLength(r);\n}\n\nlemma PostorderLength<T>(t: BinaryTree<T>)\n  ensures |postorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    PostorderLength(l);\n    PostorderLength(r);\n}\n\nlemma MirrorTwice<T>(t: BinaryTree<T>)\n  ensures mirror(mirror(t)) == t\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorTwice(l);\n    MirrorTwice(r);\n}\n\nlemma MirrorSize<T>(t: BinaryTree<T>)\n  ensures treeSize(mirror(t)) == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorSize(l);\n    \n/*[CODE HERE]*/\n}\n\nlemma MirrorHeight<T>(t: BinaryTree<T>)\n  ensures treeHeight(mirror(t)) == treeHeight(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorHeight(l);\n    MirrorHeight(r);\n    var lh := treeHeight(l);\n    var rh := treeHeight(r);\n    var mlh := treeHeight(mirror(r));\n    var mrh := treeHeight(mirror(l));\n    assert mlh == rh && mrh == lh;\n}\n\nlemma LeafCountBound<T>(t: BinaryTree<T>)\n  ensures leafCount(t) <= treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(_, l, r) =>\n    if l == Empty && r == Empty {\n      assert leafCount(t) == 1;\n      assert treeSize(t) == 1;\n    } else {\n      LeafCountBound(l);\n      LeafCountBound(r);\n    }\n}\n\nlemma InTreeInorder<T>(x: T, t: BinaryTree<T>)\n  ensures inTree(x, t) <==> x in inorder(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    InTreeInorder(x, l);\n    InTreeInorder(x, r);\n    if x == v {\n      assert x in inorder(t);\n    } else if inTree(x, l) {\n      assert x in inorder(l);\n      assert x in inorder(t);\n    } else if inTree(x, r) {\n      assert x in inorder(r);\n      assert x in inorder(t);\n    }\n}\n\nlemma HeightLogBound<T>(t: BinaryTree<T>)\n  requires isBalanced(t) && t != Empty\n  ensures treeHeight(t) <= treeSize(t)\n{\n  match t\n  case Node(_, l, r) =>\n    if l != Empty {\n      HeightLogBound(l);\n    }\n    if r != Empty {\n      HeightLogBound(r);\n    }\n}", "output": "MirrorSize(r);"}, {"id": "example_MirrorSize_1", "type": "call", "program": "// Tree operations: size, height, inorder traversal\n\ndatatype BinaryTree<T> = Empty | Node(value: T, left: BinaryTree<T>, right: BinaryTree<T>)\n\nfunction {:spec} treeSize<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, l, r) => 1 + treeSize(l) + treeSize(r)\n}\n\nfunction {:spec} treeHeight<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, l, r) =>\n    var lh := treeHeight(l);\n    var rh := treeHeight(r);\n    1 + if lh > rh then lh else rh\n}\n\nfunction {:spec} inorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => inorder(l) + [v] + inorder(r)\n}\n\nfunction {:spec} preorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => [v] + preorder(l) + preorder(r)\n}\n\nfunction {:spec} postorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => postorder(l) + postorder(r) + [v]\n}\n\npredicate {:spec} isLeaf<T>(t: BinaryTree<T>)\n{\n  t.Node? && t.left == Empty && t.right == Empty\n}\n\nfunction {:spec} leafCount<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, Empty, Empty) => 1\n  case Node(_, l, r) => leafCount(l) + leafCount(r)\n}\n\npredicate {:spec} inTree<T(==)>(x: T, t: BinaryTree<T>)\n{\n  match t\n  case Empty => false\n  case Node(v, l, r) => v == x || inTree(x, l) || inTree(x, r)\n}\n\nfunction {:spec} mirror<T>(t: BinaryTree<T>): BinaryTree<T>\n{\n  match t\n  case Empty => Empty\n  case Node(v, l, r) => Node(v, mirror(r), mirror(l))\n}\n\npredicate {:spec} isBalanced<T>(t: BinaryTree<T>)\n{\n  match t\n  case Empty => true\n  case Node(_, l, r) =>\n    isBalanced(l) && isBalanced(r) &&\n    var diff := if treeHeight(l) > treeHeight(r)\n                then treeHeight(l) - treeHeight(r)\n                else treeHeight(r) - treeHeight(l);\n    diff <= 1\n}\n\nlemma InorderLength<T>(t: BinaryTree<T>)\n  ensures |inorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    InorderLength(l);\n    InorderLength(r);\n    assert |inorder(t)| == |inorder(l)| + 1 + |inorder(r)|;\n}\n\nlemma PreorderLength<T>(t: BinaryTree<T>)\n  ensures |preorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    PreorderLength(l);\n    PreorderLength(r);\n}\n\nlemma PostorderLength<T>(t: BinaryTree<T>)\n  ensures |postorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    PostorderLength(l);\n    PostorderLength(r);\n}\n\nlemma MirrorTwice<T>(t: BinaryTree<T>)\n  ensures mirror(mirror(t)) == t\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorTwice(l);\n    MirrorTwice(r);\n}\n\nlemma MirrorSize<T>(t: BinaryTree<T>)\n  ensures treeSize(mirror(t)) == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    \n/*[CODE HERE]*/\n    MirrorSize(r);\n}\n\nlemma MirrorHeight<T>(t: BinaryTree<T>)\n  ensures treeHeight(mirror(t)) == treeHeight(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorHeight(l);\n    MirrorHeight(r);\n    var lh := treeHeight(l);\n    var rh := treeHeight(r);\n    var mlh := treeHeight(mirror(r));\n    var mrh := treeHeight(mirror(l));\n    assert mlh == rh && mrh == lh;\n}\n\nlemma LeafCountBound<T>(t: BinaryTree<T>)\n  ensures leafCount(t) <= treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(_, l, r) =>\n    if l == Empty && r == Empty {\n      assert leafCount(t) == 1;\n      assert treeSize(t) == 1;\n    } else {\n      LeafCountBound(l);\n      LeafCountBound(r);\n    }\n}\n\nlemma InTreeInorder<T>(x: T, t: BinaryTree<T>)\n  ensures inTree(x, t) <==> x in inorder(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    InTreeInorder(x, l);\n    InTreeInorder(x, r);\n    if x == v {\n      assert x in inorder(t);\n    } else if inTree(x, l) {\n      assert x in inorder(l);\n      assert x in inorder(t);\n    } else if inTree(x, r) {\n      assert x in inorder(r);\n      assert x in inorder(t);\n    }\n}\n\nlemma HeightLogBound<T>(t: BinaryTree<T>)\n  requires isBalanced(t) && t != Empty\n  ensures treeHeight(t) <= treeSize(t)\n{\n  match t\n  case Node(_, l, r) =>\n    if l != Empty {\n      HeightLogBound(l);\n    }\n    if r != Empty {\n      HeightLogBound(r);\n    }\n}", "output": "MirrorSize(l);"}, {"id": "example_MirrorHeight_0", "type": "assert", "program": "// Tree operations: size, height, inorder traversal\n\ndatatype BinaryTree<T> = Empty | Node(value: T, left: BinaryTree<T>, right: BinaryTree<T>)\n\nfunction {:spec} treeSize<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, l, r) => 1 + treeSize(l) + treeSize(r)\n}\n\nfunction {:spec} treeHeight<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, l, r) =>\n    var lh := treeHeight(l);\n    var rh := treeHeight(r);\n    1 + if lh > rh then lh else rh\n}\n\nfunction {:spec} inorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => inorder(l) + [v] + inorder(r)\n}\n\nfunction {:spec} preorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => [v] + preorder(l) + preorder(r)\n}\n\nfunction {:spec} postorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => postorder(l) + postorder(r) + [v]\n}\n\npredicate {:spec} isLeaf<T>(t: BinaryTree<T>)\n{\n  t.Node? && t.left == Empty && t.right == Empty\n}\n\nfunction {:spec} leafCount<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, Empty, Empty) => 1\n  case Node(_, l, r) => leafCount(l) + leafCount(r)\n}\n\npredicate {:spec} inTree<T(==)>(x: T, t: BinaryTree<T>)\n{\n  match t\n  case Empty => false\n  case Node(v, l, r) => v == x || inTree(x, l) || inTree(x, r)\n}\n\nfunction {:spec} mirror<T>(t: BinaryTree<T>): BinaryTree<T>\n{\n  match t\n  case Empty => Empty\n  case Node(v, l, r) => Node(v, mirror(r), mirror(l))\n}\n\npredicate {:spec} isBalanced<T>(t: BinaryTree<T>)\n{\n  match t\n  case Empty => true\n  case Node(_, l, r) =>\n    isBalanced(l) && isBalanced(r) &&\n    var diff := if treeHeight(l) > treeHeight(r)\n                then treeHeight(l) - treeHeight(r)\n                else treeHeight(r) - treeHeight(l);\n    diff <= 1\n}\n\nlemma InorderLength<T>(t: BinaryTree<T>)\n  ensures |inorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    InorderLength(l);\n    InorderLength(r);\n    assert |inorder(t)| == |inorder(l)| + 1 + |inorder(r)|;\n}\n\nlemma PreorderLength<T>(t: BinaryTree<T>)\n  ensures |preorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    PreorderLength(l);\n    PreorderLength(r);\n}\n\nlemma PostorderLength<T>(t: BinaryTree<T>)\n  ensures |postorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    PostorderLength(l);\n    PostorderLength(r);\n}\n\nlemma MirrorTwice<T>(t: BinaryTree<T>)\n  ensures mirror(mirror(t)) == t\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorTwice(l);\n    MirrorTwice(r);\n}\n\nlemma MirrorSize<T>(t: BinaryTree<T>)\n  ensures treeSize(mirror(t)) == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorSize(l);\n    MirrorSize(r);\n}\n\nlemma MirrorHeight<T>(t: BinaryTree<T>)\n  ensures treeHeight(mirror(t)) == treeHeight(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorHeight(l);\n    MirrorHeight(r);\n    var lh := treeHeight(l);\n    var rh := treeHeight(r);\n    var mlh := treeHeight(mirror(r));\n    var mrh := treeHeight(mirror(l));\n    \n/*[CODE HERE]*/\n}\n\nlemma LeafCountBound<T>(t: BinaryTree<T>)\n  ensures leafCount(t) <= treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(_, l, r) =>\n    if l == Empty && r == Empty {\n      assert leafCount(t) == 1;\n      assert treeSize(t) == 1;\n    } else {\n      LeafCountBound(l);\n      LeafCountBound(r);\n    }\n}\n\nlemma InTreeInorder<T>(x: T, t: BinaryTree<T>)\n  ensures inTree(x, t) <==> x in inorder(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    InTreeInorder(x, l);\n    InTreeInorder(x, r);\n    if x == v {\n      assert x in inorder(t);\n    } else if inTree(x, l) {\n      assert x in inorder(l);\n      assert x in inorder(t);\n    } else if inTree(x, r) {\n      assert x in inorder(r);\n      assert x in inorder(t);\n    }\n}\n\nlemma HeightLogBound<T>(t: BinaryTree<T>)\n  requires isBalanced(t) && t != Empty\n  ensures treeHeight(t) <= treeSize(t)\n{\n  match t\n  case Node(_, l, r) =>\n    if l != Empty {\n      HeightLogBound(l);\n    }\n    if r != Empty {\n      HeightLogBound(r);\n    }\n}", "output": "assert mlh == rh && mrh == lh;"}, {"id": "example_MirrorHeight_1", "type": "call", "program": "// Tree operations: size, height, inorder traversal\n\ndatatype BinaryTree<T> = Empty | Node(value: T, left: BinaryTree<T>, right: BinaryTree<T>)\n\nfunction {:spec} treeSize<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, l, r) => 1 + treeSize(l) + treeSize(r)\n}\n\nfunction {:spec} treeHeight<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, l, r) =>\n    var lh := treeHeight(l);\n    var rh := treeHeight(r);\n    1 + if lh > rh then lh else rh\n}\n\nfunction {:spec} inorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => inorder(l) + [v] + inorder(r)\n}\n\nfunction {:spec} preorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => [v] + preorder(l) + preorder(r)\n}\n\nfunction {:spec} postorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => postorder(l) + postorder(r) + [v]\n}\n\npredicate {:spec} isLeaf<T>(t: BinaryTree<T>)\n{\n  t.Node? && t.left == Empty && t.right == Empty\n}\n\nfunction {:spec} leafCount<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, Empty, Empty) => 1\n  case Node(_, l, r) => leafCount(l) + leafCount(r)\n}\n\npredicate {:spec} inTree<T(==)>(x: T, t: BinaryTree<T>)\n{\n  match t\n  case Empty => false\n  case Node(v, l, r) => v == x || inTree(x, l) || inTree(x, r)\n}\n\nfunction {:spec} mirror<T>(t: BinaryTree<T>): BinaryTree<T>\n{\n  match t\n  case Empty => Empty\n  case Node(v, l, r) => Node(v, mirror(r), mirror(l))\n}\n\npredicate {:spec} isBalanced<T>(t: BinaryTree<T>)\n{\n  match t\n  case Empty => true\n  case Node(_, l, r) =>\n    isBalanced(l) && isBalanced(r) &&\n    var diff := if treeHeight(l) > treeHeight(r)\n                then treeHeight(l) - treeHeight(r)\n                else treeHeight(r) - treeHeight(l);\n    diff <= 1\n}\n\nlemma InorderLength<T>(t: BinaryTree<T>)\n  ensures |inorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    InorderLength(l);\n    InorderLength(r);\n    assert |inorder(t)| == |inorder(l)| + 1 + |inorder(r)|;\n}\n\nlemma PreorderLength<T>(t: BinaryTree<T>)\n  ensures |preorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    PreorderLength(l);\n    PreorderLength(r);\n}\n\nlemma PostorderLength<T>(t: BinaryTree<T>)\n  ensures |postorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    PostorderLength(l);\n    PostorderLength(r);\n}\n\nlemma MirrorTwice<T>(t: BinaryTree<T>)\n  ensures mirror(mirror(t)) == t\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorTwice(l);\n    MirrorTwice(r);\n}\n\nlemma MirrorSize<T>(t: BinaryTree<T>)\n  ensures treeSize(mirror(t)) == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorSize(l);\n    MirrorSize(r);\n}\n\nlemma MirrorHeight<T>(t: BinaryTree<T>)\n  ensures treeHeight(mirror(t)) == treeHeight(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorHeight(l);\n    \n/*[CODE HERE]*/\n    var lh := treeHeight(l);\n    var rh := treeHeight(r);\n    var mlh := treeHeight(mirror(r));\n    var mrh := treeHeight(mirror(l));\n    assert mlh == rh && mrh == lh;\n}\n\nlemma LeafCountBound<T>(t: BinaryTree<T>)\n  ensures leafCount(t) <= treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(_, l, r) =>\n    if l == Empty && r == Empty {\n      assert leafCount(t) == 1;\n      assert treeSize(t) == 1;\n    } else {\n      LeafCountBound(l);\n      LeafCountBound(r);\n    }\n}\n\nlemma InTreeInorder<T>(x: T, t: BinaryTree<T>)\n  ensures inTree(x, t) <==> x in inorder(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    InTreeInorder(x, l);\n    InTreeInorder(x, r);\n    if x == v {\n      assert x in inorder(t);\n    } else if inTree(x, l) {\n      assert x in inorder(l);\n      assert x in inorder(t);\n    } else if inTree(x, r) {\n      assert x in inorder(r);\n      assert x in inorder(t);\n    }\n}\n\nlemma HeightLogBound<T>(t: BinaryTree<T>)\n  requires isBalanced(t) && t != Empty\n  ensures treeHeight(t) <= treeSize(t)\n{\n  match t\n  case Node(_, l, r) =>\n    if l != Empty {\n      HeightLogBound(l);\n    }\n    if r != Empty {\n      HeightLogBound(r);\n    }\n}", "output": "MirrorHeight(r);"}, {"id": "example_MirrorHeight_2", "type": "call", "program": "// Tree operations: size, height, inorder traversal\n\ndatatype BinaryTree<T> = Empty | Node(value: T, left: BinaryTree<T>, right: BinaryTree<T>)\n\nfunction {:spec} treeSize<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, l, r) => 1 + treeSize(l) + treeSize(r)\n}\n\nfunction {:spec} treeHeight<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, l, r) =>\n    var lh := treeHeight(l);\n    var rh := treeHeight(r);\n    1 + if lh > rh then lh else rh\n}\n\nfunction {:spec} inorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => inorder(l) + [v] + inorder(r)\n}\n\nfunction {:spec} preorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => [v] + preorder(l) + preorder(r)\n}\n\nfunction {:spec} postorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => postorder(l) + postorder(r) + [v]\n}\n\npredicate {:spec} isLeaf<T>(t: BinaryTree<T>)\n{\n  t.Node? && t.left == Empty && t.right == Empty\n}\n\nfunction {:spec} leafCount<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, Empty, Empty) => 1\n  case Node(_, l, r) => leafCount(l) + leafCount(r)\n}\n\npredicate {:spec} inTree<T(==)>(x: T, t: BinaryTree<T>)\n{\n  match t\n  case Empty => false\n  case Node(v, l, r) => v == x || inTree(x, l) || inTree(x, r)\n}\n\nfunction {:spec} mirror<T>(t: BinaryTree<T>): BinaryTree<T>\n{\n  match t\n  case Empty => Empty\n  case Node(v, l, r) => Node(v, mirror(r), mirror(l))\n}\n\npredicate {:spec} isBalanced<T>(t: BinaryTree<T>)\n{\n  match t\n  case Empty => true\n  case Node(_, l, r) =>\n    isBalanced(l) && isBalanced(r) &&\n    var diff := if treeHeight(l) > treeHeight(r)\n                then treeHeight(l) - treeHeight(r)\n                else treeHeight(r) - treeHeight(l);\n    diff <= 1\n}\n\nlemma InorderLength<T>(t: BinaryTree<T>)\n  ensures |inorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    InorderLength(l);\n    InorderLength(r);\n    assert |inorder(t)| == |inorder(l)| + 1 + |inorder(r)|;\n}\n\nlemma PreorderLength<T>(t: BinaryTree<T>)\n  ensures |preorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    PreorderLength(l);\n    PreorderLength(r);\n}\n\nlemma PostorderLength<T>(t: BinaryTree<T>)\n  ensures |postorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    PostorderLength(l);\n    PostorderLength(r);\n}\n\nlemma MirrorTwice<T>(t: BinaryTree<T>)\n  ensures mirror(mirror(t)) == t\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorTwice(l);\n    MirrorTwice(r);\n}\n\nlemma MirrorSize<T>(t: BinaryTree<T>)\n  ensures treeSize(mirror(t)) == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorSize(l);\n    MirrorSize(r);\n}\n\nlemma MirrorHeight<T>(t: BinaryTree<T>)\n  ensures treeHeight(mirror(t)) == treeHeight(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    \n/*[CODE HERE]*/\n    MirrorHeight(r);\n    var lh := treeHeight(l);\n    var rh := treeHeight(r);\n    var mlh := treeHeight(mirror(r));\n    var mrh := treeHeight(mirror(l));\n    assert mlh == rh && mrh == lh;\n}\n\nlemma LeafCountBound<T>(t: BinaryTree<T>)\n  ensures leafCount(t) <= treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(_, l, r) =>\n    if l == Empty && r == Empty {\n      assert leafCount(t) == 1;\n      assert treeSize(t) == 1;\n    } else {\n      LeafCountBound(l);\n      LeafCountBound(r);\n    }\n}\n\nlemma InTreeInorder<T>(x: T, t: BinaryTree<T>)\n  ensures inTree(x, t) <==> x in inorder(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    InTreeInorder(x, l);\n    InTreeInorder(x, r);\n    if x == v {\n      assert x in inorder(t);\n    } else if inTree(x, l) {\n      assert x in inorder(l);\n      assert x in inorder(t);\n    } else if inTree(x, r) {\n      assert x in inorder(r);\n      assert x in inorder(t);\n    }\n}\n\nlemma HeightLogBound<T>(t: BinaryTree<T>)\n  requires isBalanced(t) && t != Empty\n  ensures treeHeight(t) <= treeSize(t)\n{\n  match t\n  case Node(_, l, r) =>\n    if l != Empty {\n      HeightLogBound(l);\n    }\n    if r != Empty {\n      HeightLogBound(r);\n    }\n}", "output": "MirrorHeight(l);"}, {"id": "example_LeafCountBound_0", "type": "call", "program": "// Tree operations: size, height, inorder traversal\n\ndatatype BinaryTree<T> = Empty | Node(value: T, left: BinaryTree<T>, right: BinaryTree<T>)\n\nfunction {:spec} treeSize<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, l, r) => 1 + treeSize(l) + treeSize(r)\n}\n\nfunction {:spec} treeHeight<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, l, r) =>\n    var lh := treeHeight(l);\n    var rh := treeHeight(r);\n    1 + if lh > rh then lh else rh\n}\n\nfunction {:spec} inorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => inorder(l) + [v] + inorder(r)\n}\n\nfunction {:spec} preorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => [v] + preorder(l) + preorder(r)\n}\n\nfunction {:spec} postorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => postorder(l) + postorder(r) + [v]\n}\n\npredicate {:spec} isLeaf<T>(t: BinaryTree<T>)\n{\n  t.Node? && t.left == Empty && t.right == Empty\n}\n\nfunction {:spec} leafCount<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, Empty, Empty) => 1\n  case Node(_, l, r) => leafCount(l) + leafCount(r)\n}\n\npredicate {:spec} inTree<T(==)>(x: T, t: BinaryTree<T>)\n{\n  match t\n  case Empty => false\n  case Node(v, l, r) => v == x || inTree(x, l) || inTree(x, r)\n}\n\nfunction {:spec} mirror<T>(t: BinaryTree<T>): BinaryTree<T>\n{\n  match t\n  case Empty => Empty\n  case Node(v, l, r) => Node(v, mirror(r), mirror(l))\n}\n\npredicate {:spec} isBalanced<T>(t: BinaryTree<T>)\n{\n  match t\n  case Empty => true\n  case Node(_, l, r) =>\n    isBalanced(l) && isBalanced(r) &&\n    var diff := if treeHeight(l) > treeHeight(r)\n                then treeHeight(l) - treeHeight(r)\n                else treeHeight(r) - treeHeight(l);\n    diff <= 1\n}\n\nlemma InorderLength<T>(t: BinaryTree<T>)\n  ensures |inorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    InorderLength(l);\n    InorderLength(r);\n    assert |inorder(t)| == |inorder(l)| + 1 + |inorder(r)|;\n}\n\nlemma PreorderLength<T>(t: BinaryTree<T>)\n  ensures |preorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    PreorderLength(l);\n    PreorderLength(r);\n}\n\nlemma PostorderLength<T>(t: BinaryTree<T>)\n  ensures |postorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    PostorderLength(l);\n    PostorderLength(r);\n}\n\nlemma MirrorTwice<T>(t: BinaryTree<T>)\n  ensures mirror(mirror(t)) == t\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorTwice(l);\n    MirrorTwice(r);\n}\n\nlemma MirrorSize<T>(t: BinaryTree<T>)\n  ensures treeSize(mirror(t)) == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorSize(l);\n    MirrorSize(r);\n}\n\nlemma MirrorHeight<T>(t: BinaryTree<T>)\n  ensures treeHeight(mirror(t)) == treeHeight(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorHeight(l);\n    MirrorHeight(r);\n    var lh := treeHeight(l);\n    var rh := treeHeight(r);\n    var mlh := treeHeight(mirror(r));\n    var mrh := treeHeight(mirror(l));\n    assert mlh == rh && mrh == lh;\n}\n\nlemma LeafCountBound<T>(t: BinaryTree<T>)\n  ensures leafCount(t) <= treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(_, l, r) =>\n    if l == Empty && r == Empty {\n      assert leafCount(t) == 1;\n      assert treeSize(t) == 1;\n    } else {\n      LeafCountBound(l);\n      \n/*[CODE HERE]*/\n    }\n}\n\nlemma InTreeInorder<T>(x: T, t: BinaryTree<T>)\n  ensures inTree(x, t) <==> x in inorder(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    InTreeInorder(x, l);\n    InTreeInorder(x, r);\n    if x == v {\n      assert x in inorder(t);\n    } else if inTree(x, l) {\n      assert x in inorder(l);\n      assert x in inorder(t);\n    } else if inTree(x, r) {\n      assert x in inorder(r);\n      assert x in inorder(t);\n    }\n}\n\nlemma HeightLogBound<T>(t: BinaryTree<T>)\n  requires isBalanced(t) && t != Empty\n  ensures treeHeight(t) <= treeSize(t)\n{\n  match t\n  case Node(_, l, r) =>\n    if l != Empty {\n      HeightLogBound(l);\n    }\n    if r != Empty {\n      HeightLogBound(r);\n    }\n}", "output": "LeafCountBound(r);"}, {"id": "example_LeafCountBound_1", "type": "call", "program": "// Tree operations: size, height, inorder traversal\n\ndatatype BinaryTree<T> = Empty | Node(value: T, left: BinaryTree<T>, right: BinaryTree<T>)\n\nfunction {:spec} treeSize<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, l, r) => 1 + treeSize(l) + treeSize(r)\n}\n\nfunction {:spec} treeHeight<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, l, r) =>\n    var lh := treeHeight(l);\n    var rh := treeHeight(r);\n    1 + if lh > rh then lh else rh\n}\n\nfunction {:spec} inorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => inorder(l) + [v] + inorder(r)\n}\n\nfunction {:spec} preorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => [v] + preorder(l) + preorder(r)\n}\n\nfunction {:spec} postorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => postorder(l) + postorder(r) + [v]\n}\n\npredicate {:spec} isLeaf<T>(t: BinaryTree<T>)\n{\n  t.Node? && t.left == Empty && t.right == Empty\n}\n\nfunction {:spec} leafCount<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, Empty, Empty) => 1\n  case Node(_, l, r) => leafCount(l) + leafCount(r)\n}\n\npredicate {:spec} inTree<T(==)>(x: T, t: BinaryTree<T>)\n{\n  match t\n  case Empty => false\n  case Node(v, l, r) => v == x || inTree(x, l) || inTree(x, r)\n}\n\nfunction {:spec} mirror<T>(t: BinaryTree<T>): BinaryTree<T>\n{\n  match t\n  case Empty => Empty\n  case Node(v, l, r) => Node(v, mirror(r), mirror(l))\n}\n\npredicate {:spec} isBalanced<T>(t: BinaryTree<T>)\n{\n  match t\n  case Empty => true\n  case Node(_, l, r) =>\n    isBalanced(l) && isBalanced(r) &&\n    var diff := if treeHeight(l) > treeHeight(r)\n                then treeHeight(l) - treeHeight(r)\n                else treeHeight(r) - treeHeight(l);\n    diff <= 1\n}\n\nlemma InorderLength<T>(t: BinaryTree<T>)\n  ensures |inorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    InorderLength(l);\n    InorderLength(r);\n    assert |inorder(t)| == |inorder(l)| + 1 + |inorder(r)|;\n}\n\nlemma PreorderLength<T>(t: BinaryTree<T>)\n  ensures |preorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    PreorderLength(l);\n    PreorderLength(r);\n}\n\nlemma PostorderLength<T>(t: BinaryTree<T>)\n  ensures |postorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    PostorderLength(l);\n    PostorderLength(r);\n}\n\nlemma MirrorTwice<T>(t: BinaryTree<T>)\n  ensures mirror(mirror(t)) == t\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorTwice(l);\n    MirrorTwice(r);\n}\n\nlemma MirrorSize<T>(t: BinaryTree<T>)\n  ensures treeSize(mirror(t)) == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorSize(l);\n    MirrorSize(r);\n}\n\nlemma MirrorHeight<T>(t: BinaryTree<T>)\n  ensures treeHeight(mirror(t)) == treeHeight(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorHeight(l);\n    MirrorHeight(r);\n    var lh := treeHeight(l);\n    var rh := treeHeight(r);\n    var mlh := treeHeight(mirror(r));\n    var mrh := treeHeight(mirror(l));\n    assert mlh == rh && mrh == lh;\n}\n\nlemma LeafCountBound<T>(t: BinaryTree<T>)\n  ensures leafCount(t) <= treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(_, l, r) =>\n    if l == Empty && r == Empty {\n      assert leafCount(t) == 1;\n      assert treeSize(t) == 1;\n    } else {\n      \n/*[CODE HERE]*/\n      LeafCountBound(r);\n    }\n}\n\nlemma InTreeInorder<T>(x: T, t: BinaryTree<T>)\n  ensures inTree(x, t) <==> x in inorder(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    InTreeInorder(x, l);\n    InTreeInorder(x, r);\n    if x == v {\n      assert x in inorder(t);\n    } else if inTree(x, l) {\n      assert x in inorder(l);\n      assert x in inorder(t);\n    } else if inTree(x, r) {\n      assert x in inorder(r);\n      assert x in inorder(t);\n    }\n}\n\nlemma HeightLogBound<T>(t: BinaryTree<T>)\n  requires isBalanced(t) && t != Empty\n  ensures treeHeight(t) <= treeSize(t)\n{\n  match t\n  case Node(_, l, r) =>\n    if l != Empty {\n      HeightLogBound(l);\n    }\n    if r != Empty {\n      HeightLogBound(r);\n    }\n}", "output": "LeafCountBound(l);"}, {"id": "example_LeafCountBound_2", "type": "assert", "program": "// Tree operations: size, height, inorder traversal\n\ndatatype BinaryTree<T> = Empty | Node(value: T, left: BinaryTree<T>, right: BinaryTree<T>)\n\nfunction {:spec} treeSize<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, l, r) => 1 + treeSize(l) + treeSize(r)\n}\n\nfunction {:spec} treeHeight<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, l, r) =>\n    var lh := treeHeight(l);\n    var rh := treeHeight(r);\n    1 + if lh > rh then lh else rh\n}\n\nfunction {:spec} inorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => inorder(l) + [v] + inorder(r)\n}\n\nfunction {:spec} preorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => [v] + preorder(l) + preorder(r)\n}\n\nfunction {:spec} postorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => postorder(l) + postorder(r) + [v]\n}\n\npredicate {:spec} isLeaf<T>(t: BinaryTree<T>)\n{\n  t.Node? && t.left == Empty && t.right == Empty\n}\n\nfunction {:spec} leafCount<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, Empty, Empty) => 1\n  case Node(_, l, r) => leafCount(l) + leafCount(r)\n}\n\npredicate {:spec} inTree<T(==)>(x: T, t: BinaryTree<T>)\n{\n  match t\n  case Empty => false\n  case Node(v, l, r) => v == x || inTree(x, l) || inTree(x, r)\n}\n\nfunction {:spec} mirror<T>(t: BinaryTree<T>): BinaryTree<T>\n{\n  match t\n  case Empty => Empty\n  case Node(v, l, r) => Node(v, mirror(r), mirror(l))\n}\n\npredicate {:spec} isBalanced<T>(t: BinaryTree<T>)\n{\n  match t\n  case Empty => true\n  case Node(_, l, r) =>\n    isBalanced(l) && isBalanced(r) &&\n    var diff := if treeHeight(l) > treeHeight(r)\n                then treeHeight(l) - treeHeight(r)\n                else treeHeight(r) - treeHeight(l);\n    diff <= 1\n}\n\nlemma InorderLength<T>(t: BinaryTree<T>)\n  ensures |inorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    InorderLength(l);\n    InorderLength(r);\n    assert |inorder(t)| == |inorder(l)| + 1 + |inorder(r)|;\n}\n\nlemma PreorderLength<T>(t: BinaryTree<T>)\n  ensures |preorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    PreorderLength(l);\n    PreorderLength(r);\n}\n\nlemma PostorderLength<T>(t: BinaryTree<T>)\n  ensures |postorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    PostorderLength(l);\n    PostorderLength(r);\n}\n\nlemma MirrorTwice<T>(t: BinaryTree<T>)\n  ensures mirror(mirror(t)) == t\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorTwice(l);\n    MirrorTwice(r);\n}\n\nlemma MirrorSize<T>(t: BinaryTree<T>)\n  ensures treeSize(mirror(t)) == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorSize(l);\n    MirrorSize(r);\n}\n\nlemma MirrorHeight<T>(t: BinaryTree<T>)\n  ensures treeHeight(mirror(t)) == treeHeight(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorHeight(l);\n    MirrorHeight(r);\n    var lh := treeHeight(l);\n    var rh := treeHeight(r);\n    var mlh := treeHeight(mirror(r));\n    var mrh := treeHeight(mirror(l));\n    assert mlh == rh && mrh == lh;\n}\n\nlemma LeafCountBound<T>(t: BinaryTree<T>)\n  ensures leafCount(t) <= treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(_, l, r) =>\n    if l == Empty && r == Empty {\n      assert leafCount(t) == 1;\n      \n/*[CODE HERE]*/\n    } else {\n      LeafCountBound(l);\n      LeafCountBound(r);\n    }\n}\n\nlemma InTreeInorder<T>(x: T, t: BinaryTree<T>)\n  ensures inTree(x, t) <==> x in inorder(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    InTreeInorder(x, l);\n    InTreeInorder(x, r);\n    if x == v {\n      assert x in inorder(t);\n    } else if inTree(x, l) {\n      assert x in inorder(l);\n      assert x in inorder(t);\n    } else if inTree(x, r) {\n      assert x in inorder(r);\n      assert x in inorder(t);\n    }\n}\n\nlemma HeightLogBound<T>(t: BinaryTree<T>)\n  requires isBalanced(t) && t != Empty\n  ensures treeHeight(t) <= treeSize(t)\n{\n  match t\n  case Node(_, l, r) =>\n    if l != Empty {\n      HeightLogBound(l);\n    }\n    if r != Empty {\n      HeightLogBound(r);\n    }\n}", "output": "assert treeSize(t) == 1;"}, {"id": "example_LeafCountBound_3", "type": "assert", "program": "// Tree operations: size, height, inorder traversal\n\ndatatype BinaryTree<T> = Empty | Node(value: T, left: BinaryTree<T>, right: BinaryTree<T>)\n\nfunction {:spec} treeSize<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, l, r) => 1 + treeSize(l) + treeSize(r)\n}\n\nfunction {:spec} treeHeight<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, l, r) =>\n    var lh := treeHeight(l);\n    var rh := treeHeight(r);\n    1 + if lh > rh then lh else rh\n}\n\nfunction {:spec} inorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => inorder(l) + [v] + inorder(r)\n}\n\nfunction {:spec} preorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => [v] + preorder(l) + preorder(r)\n}\n\nfunction {:spec} postorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => postorder(l) + postorder(r) + [v]\n}\n\npredicate {:spec} isLeaf<T>(t: BinaryTree<T>)\n{\n  t.Node? && t.left == Empty && t.right == Empty\n}\n\nfunction {:spec} leafCount<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, Empty, Empty) => 1\n  case Node(_, l, r) => leafCount(l) + leafCount(r)\n}\n\npredicate {:spec} inTree<T(==)>(x: T, t: BinaryTree<T>)\n{\n  match t\n  case Empty => false\n  case Node(v, l, r) => v == x || inTree(x, l) || inTree(x, r)\n}\n\nfunction {:spec} mirror<T>(t: BinaryTree<T>): BinaryTree<T>\n{\n  match t\n  case Empty => Empty\n  case Node(v, l, r) => Node(v, mirror(r), mirror(l))\n}\n\npredicate {:spec} isBalanced<T>(t: BinaryTree<T>)\n{\n  match t\n  case Empty => true\n  case Node(_, l, r) =>\n    isBalanced(l) && isBalanced(r) &&\n    var diff := if treeHeight(l) > treeHeight(r)\n                then treeHeight(l) - treeHeight(r)\n                else treeHeight(r) - treeHeight(l);\n    diff <= 1\n}\n\nlemma InorderLength<T>(t: BinaryTree<T>)\n  ensures |inorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    InorderLength(l);\n    InorderLength(r);\n    assert |inorder(t)| == |inorder(l)| + 1 + |inorder(r)|;\n}\n\nlemma PreorderLength<T>(t: BinaryTree<T>)\n  ensures |preorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    PreorderLength(l);\n    PreorderLength(r);\n}\n\nlemma PostorderLength<T>(t: BinaryTree<T>)\n  ensures |postorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    PostorderLength(l);\n    PostorderLength(r);\n}\n\nlemma MirrorTwice<T>(t: BinaryTree<T>)\n  ensures mirror(mirror(t)) == t\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorTwice(l);\n    MirrorTwice(r);\n}\n\nlemma MirrorSize<T>(t: BinaryTree<T>)\n  ensures treeSize(mirror(t)) == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorSize(l);\n    MirrorSize(r);\n}\n\nlemma MirrorHeight<T>(t: BinaryTree<T>)\n  ensures treeHeight(mirror(t)) == treeHeight(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorHeight(l);\n    MirrorHeight(r);\n    var lh := treeHeight(l);\n    var rh := treeHeight(r);\n    var mlh := treeHeight(mirror(r));\n    var mrh := treeHeight(mirror(l));\n    assert mlh == rh && mrh == lh;\n}\n\nlemma LeafCountBound<T>(t: BinaryTree<T>)\n  ensures leafCount(t) <= treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(_, l, r) =>\n    if l == Empty && r == Empty {\n      \n/*[CODE HERE]*/\n      assert treeSize(t) == 1;\n    } else {\n      LeafCountBound(l);\n      LeafCountBound(r);\n    }\n}\n\nlemma InTreeInorder<T>(x: T, t: BinaryTree<T>)\n  ensures inTree(x, t) <==> x in inorder(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    InTreeInorder(x, l);\n    InTreeInorder(x, r);\n    if x == v {\n      assert x in inorder(t);\n    } else if inTree(x, l) {\n      assert x in inorder(l);\n      assert x in inorder(t);\n    } else if inTree(x, r) {\n      assert x in inorder(r);\n      assert x in inorder(t);\n    }\n}\n\nlemma HeightLogBound<T>(t: BinaryTree<T>)\n  requires isBalanced(t) && t != Empty\n  ensures treeHeight(t) <= treeSize(t)\n{\n  match t\n  case Node(_, l, r) =>\n    if l != Empty {\n      HeightLogBound(l);\n    }\n    if r != Empty {\n      HeightLogBound(r);\n    }\n}", "output": "assert leafCount(t) == 1;"}, {"id": "example_InTreeInorder_0", "type": "assert", "program": "// Tree operations: size, height, inorder traversal\n\ndatatype BinaryTree<T> = Empty | Node(value: T, left: BinaryTree<T>, right: BinaryTree<T>)\n\nfunction {:spec} treeSize<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, l, r) => 1 + treeSize(l) + treeSize(r)\n}\n\nfunction {:spec} treeHeight<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, l, r) =>\n    var lh := treeHeight(l);\n    var rh := treeHeight(r);\n    1 + if lh > rh then lh else rh\n}\n\nfunction {:spec} inorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => inorder(l) + [v] + inorder(r)\n}\n\nfunction {:spec} preorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => [v] + preorder(l) + preorder(r)\n}\n\nfunction {:spec} postorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => postorder(l) + postorder(r) + [v]\n}\n\npredicate {:spec} isLeaf<T>(t: BinaryTree<T>)\n{\n  t.Node? && t.left == Empty && t.right == Empty\n}\n\nfunction {:spec} leafCount<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, Empty, Empty) => 1\n  case Node(_, l, r) => leafCount(l) + leafCount(r)\n}\n\npredicate {:spec} inTree<T(==)>(x: T, t: BinaryTree<T>)\n{\n  match t\n  case Empty => false\n  case Node(v, l, r) => v == x || inTree(x, l) || inTree(x, r)\n}\n\nfunction {:spec} mirror<T>(t: BinaryTree<T>): BinaryTree<T>\n{\n  match t\n  case Empty => Empty\n  case Node(v, l, r) => Node(v, mirror(r), mirror(l))\n}\n\npredicate {:spec} isBalanced<T>(t: BinaryTree<T>)\n{\n  match t\n  case Empty => true\n  case Node(_, l, r) =>\n    isBalanced(l) && isBalanced(r) &&\n    var diff := if treeHeight(l) > treeHeight(r)\n                then treeHeight(l) - treeHeight(r)\n                else treeHeight(r) - treeHeight(l);\n    diff <= 1\n}\n\nlemma InorderLength<T>(t: BinaryTree<T>)\n  ensures |inorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    InorderLength(l);\n    InorderLength(r);\n    assert |inorder(t)| == |inorder(l)| + 1 + |inorder(r)|;\n}\n\nlemma PreorderLength<T>(t: BinaryTree<T>)\n  ensures |preorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    PreorderLength(l);\n    PreorderLength(r);\n}\n\nlemma PostorderLength<T>(t: BinaryTree<T>)\n  ensures |postorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    PostorderLength(l);\n    PostorderLength(r);\n}\n\nlemma MirrorTwice<T>(t: BinaryTree<T>)\n  ensures mirror(mirror(t)) == t\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorTwice(l);\n    MirrorTwice(r);\n}\n\nlemma MirrorSize<T>(t: BinaryTree<T>)\n  ensures treeSize(mirror(t)) == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorSize(l);\n    MirrorSize(r);\n}\n\nlemma MirrorHeight<T>(t: BinaryTree<T>)\n  ensures treeHeight(mirror(t)) == treeHeight(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorHeight(l);\n    MirrorHeight(r);\n    var lh := treeHeight(l);\n    var rh := treeHeight(r);\n    var mlh := treeHeight(mirror(r));\n    var mrh := treeHeight(mirror(l));\n    assert mlh == rh && mrh == lh;\n}\n\nlemma LeafCountBound<T>(t: BinaryTree<T>)\n  ensures leafCount(t) <= treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(_, l, r) =>\n    if l == Empty && r == Empty {\n      assert leafCount(t) == 1;\n      assert treeSize(t) == 1;\n    } else {\n      LeafCountBound(l);\n      LeafCountBound(r);\n    }\n}\n\nlemma InTreeInorder<T>(x: T, t: BinaryTree<T>)\n  ensures inTree(x, t) <==> x in inorder(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    InTreeInorder(x, l);\n    InTreeInorder(x, r);\n    if x == v {\n      assert x in inorder(t);\n    } else if inTree(x, l) {\n      assert x in inorder(l);\n      assert x in inorder(t);\n    } else if inTree(x, r) {\n      assert x in inorder(r);\n      \n/*[CODE HERE]*/\n    }\n}\n\nlemma HeightLogBound<T>(t: BinaryTree<T>)\n  requires isBalanced(t) && t != Empty\n  ensures treeHeight(t) <= treeSize(t)\n{\n  match t\n  case Node(_, l, r) =>\n    if l != Empty {\n      HeightLogBound(l);\n    }\n    if r != Empty {\n      HeightLogBound(r);\n    }\n}", "output": "assert x in inorder(t);"}, {"id": "example_InTreeInorder_1", "type": "assert", "program": "// Tree operations: size, height, inorder traversal\n\ndatatype BinaryTree<T> = Empty | Node(value: T, left: BinaryTree<T>, right: BinaryTree<T>)\n\nfunction {:spec} treeSize<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, l, r) => 1 + treeSize(l) + treeSize(r)\n}\n\nfunction {:spec} treeHeight<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, l, r) =>\n    var lh := treeHeight(l);\n    var rh := treeHeight(r);\n    1 + if lh > rh then lh else rh\n}\n\nfunction {:spec} inorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => inorder(l) + [v] + inorder(r)\n}\n\nfunction {:spec} preorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => [v] + preorder(l) + preorder(r)\n}\n\nfunction {:spec} postorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => postorder(l) + postorder(r) + [v]\n}\n\npredicate {:spec} isLeaf<T>(t: BinaryTree<T>)\n{\n  t.Node? && t.left == Empty && t.right == Empty\n}\n\nfunction {:spec} leafCount<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, Empty, Empty) => 1\n  case Node(_, l, r) => leafCount(l) + leafCount(r)\n}\n\npredicate {:spec} inTree<T(==)>(x: T, t: BinaryTree<T>)\n{\n  match t\n  case Empty => false\n  case Node(v, l, r) => v == x || inTree(x, l) || inTree(x, r)\n}\n\nfunction {:spec} mirror<T>(t: BinaryTree<T>): BinaryTree<T>\n{\n  match t\n  case Empty => Empty\n  case Node(v, l, r) => Node(v, mirror(r), mirror(l))\n}\n\npredicate {:spec} isBalanced<T>(t: BinaryTree<T>)\n{\n  match t\n  case Empty => true\n  case Node(_, l, r) =>\n    isBalanced(l) && isBalanced(r) &&\n    var diff := if treeHeight(l) > treeHeight(r)\n                then treeHeight(l) - treeHeight(r)\n                else treeHeight(r) - treeHeight(l);\n    diff <= 1\n}\n\nlemma InorderLength<T>(t: BinaryTree<T>)\n  ensures |inorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    InorderLength(l);\n    InorderLength(r);\n    assert |inorder(t)| == |inorder(l)| + 1 + |inorder(r)|;\n}\n\nlemma PreorderLength<T>(t: BinaryTree<T>)\n  ensures |preorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    PreorderLength(l);\n    PreorderLength(r);\n}\n\nlemma PostorderLength<T>(t: BinaryTree<T>)\n  ensures |postorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    PostorderLength(l);\n    PostorderLength(r);\n}\n\nlemma MirrorTwice<T>(t: BinaryTree<T>)\n  ensures mirror(mirror(t)) == t\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorTwice(l);\n    MirrorTwice(r);\n}\n\nlemma MirrorSize<T>(t: BinaryTree<T>)\n  ensures treeSize(mirror(t)) == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorSize(l);\n    MirrorSize(r);\n}\n\nlemma MirrorHeight<T>(t: BinaryTree<T>)\n  ensures treeHeight(mirror(t)) == treeHeight(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorHeight(l);\n    MirrorHeight(r);\n    var lh := treeHeight(l);\n    var rh := treeHeight(r);\n    var mlh := treeHeight(mirror(r));\n    var mrh := treeHeight(mirror(l));\n    assert mlh == rh && mrh == lh;\n}\n\nlemma LeafCountBound<T>(t: BinaryTree<T>)\n  ensures leafCount(t) <= treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(_, l, r) =>\n    if l == Empty && r == Empty {\n      assert leafCount(t) == 1;\n      assert treeSize(t) == 1;\n    } else {\n      LeafCountBound(l);\n      LeafCountBound(r);\n    }\n}\n\nlemma InTreeInorder<T>(x: T, t: BinaryTree<T>)\n  ensures inTree(x, t) <==> x in inorder(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    InTreeInorder(x, l);\n    InTreeInorder(x, r);\n    if x == v {\n      assert x in inorder(t);\n    } else if inTree(x, l) {\n      assert x in inorder(l);\n      assert x in inorder(t);\n    } else if inTree(x, r) {\n      \n/*[CODE HERE]*/\n      assert x in inorder(t);\n    }\n}\n\nlemma HeightLogBound<T>(t: BinaryTree<T>)\n  requires isBalanced(t) && t != Empty\n  ensures treeHeight(t) <= treeSize(t)\n{\n  match t\n  case Node(_, l, r) =>\n    if l != Empty {\n      HeightLogBound(l);\n    }\n    if r != Empty {\n      HeightLogBound(r);\n    }\n}", "output": "assert x in inorder(r);"}, {"id": "example_InTreeInorder_2", "type": "assert", "program": "// Tree operations: size, height, inorder traversal\n\ndatatype BinaryTree<T> = Empty | Node(value: T, left: BinaryTree<T>, right: BinaryTree<T>)\n\nfunction {:spec} treeSize<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, l, r) => 1 + treeSize(l) + treeSize(r)\n}\n\nfunction {:spec} treeHeight<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, l, r) =>\n    var lh := treeHeight(l);\n    var rh := treeHeight(r);\n    1 + if lh > rh then lh else rh\n}\n\nfunction {:spec} inorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => inorder(l) + [v] + inorder(r)\n}\n\nfunction {:spec} preorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => [v] + preorder(l) + preorder(r)\n}\n\nfunction {:spec} postorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => postorder(l) + postorder(r) + [v]\n}\n\npredicate {:spec} isLeaf<T>(t: BinaryTree<T>)\n{\n  t.Node? && t.left == Empty && t.right == Empty\n}\n\nfunction {:spec} leafCount<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, Empty, Empty) => 1\n  case Node(_, l, r) => leafCount(l) + leafCount(r)\n}\n\npredicate {:spec} inTree<T(==)>(x: T, t: BinaryTree<T>)\n{\n  match t\n  case Empty => false\n  case Node(v, l, r) => v == x || inTree(x, l) || inTree(x, r)\n}\n\nfunction {:spec} mirror<T>(t: BinaryTree<T>): BinaryTree<T>\n{\n  match t\n  case Empty => Empty\n  case Node(v, l, r) => Node(v, mirror(r), mirror(l))\n}\n\npredicate {:spec} isBalanced<T>(t: BinaryTree<T>)\n{\n  match t\n  case Empty => true\n  case Node(_, l, r) =>\n    isBalanced(l) && isBalanced(r) &&\n    var diff := if treeHeight(l) > treeHeight(r)\n                then treeHeight(l) - treeHeight(r)\n                else treeHeight(r) - treeHeight(l);\n    diff <= 1\n}\n\nlemma InorderLength<T>(t: BinaryTree<T>)\n  ensures |inorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    InorderLength(l);\n    InorderLength(r);\n    assert |inorder(t)| == |inorder(l)| + 1 + |inorder(r)|;\n}\n\nlemma PreorderLength<T>(t: BinaryTree<T>)\n  ensures |preorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    PreorderLength(l);\n    PreorderLength(r);\n}\n\nlemma PostorderLength<T>(t: BinaryTree<T>)\n  ensures |postorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    PostorderLength(l);\n    PostorderLength(r);\n}\n\nlemma MirrorTwice<T>(t: BinaryTree<T>)\n  ensures mirror(mirror(t)) == t\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorTwice(l);\n    MirrorTwice(r);\n}\n\nlemma MirrorSize<T>(t: BinaryTree<T>)\n  ensures treeSize(mirror(t)) == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorSize(l);\n    MirrorSize(r);\n}\n\nlemma MirrorHeight<T>(t: BinaryTree<T>)\n  ensures treeHeight(mirror(t)) == treeHeight(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorHeight(l);\n    MirrorHeight(r);\n    var lh := treeHeight(l);\n    var rh := treeHeight(r);\n    var mlh := treeHeight(mirror(r));\n    var mrh := treeHeight(mirror(l));\n    assert mlh == rh && mrh == lh;\n}\n\nlemma LeafCountBound<T>(t: BinaryTree<T>)\n  ensures leafCount(t) <= treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(_, l, r) =>\n    if l == Empty && r == Empty {\n      assert leafCount(t) == 1;\n      assert treeSize(t) == 1;\n    } else {\n      LeafCountBound(l);\n      LeafCountBound(r);\n    }\n}\n\nlemma InTreeInorder<T>(x: T, t: BinaryTree<T>)\n  ensures inTree(x, t) <==> x in inorder(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    InTreeInorder(x, l);\n    InTreeInorder(x, r);\n    if x == v {\n      assert x in inorder(t);\n    } else if inTree(x, l) {\n      assert x in inorder(l);\n      \n/*[CODE HERE]*/\n    } else if inTree(x, r) {\n      assert x in inorder(r);\n      assert x in inorder(t);\n    }\n}\n\nlemma HeightLogBound<T>(t: BinaryTree<T>)\n  requires isBalanced(t) && t != Empty\n  ensures treeHeight(t) <= treeSize(t)\n{\n  match t\n  case Node(_, l, r) =>\n    if l != Empty {\n      HeightLogBound(l);\n    }\n    if r != Empty {\n      HeightLogBound(r);\n    }\n}", "output": "assert x in inorder(t);"}, {"id": "example_InTreeInorder_3", "type": "assert", "program": "// Tree operations: size, height, inorder traversal\n\ndatatype BinaryTree<T> = Empty | Node(value: T, left: BinaryTree<T>, right: BinaryTree<T>)\n\nfunction {:spec} treeSize<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, l, r) => 1 + treeSize(l) + treeSize(r)\n}\n\nfunction {:spec} treeHeight<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, l, r) =>\n    var lh := treeHeight(l);\n    var rh := treeHeight(r);\n    1 + if lh > rh then lh else rh\n}\n\nfunction {:spec} inorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => inorder(l) + [v] + inorder(r)\n}\n\nfunction {:spec} preorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => [v] + preorder(l) + preorder(r)\n}\n\nfunction {:spec} postorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => postorder(l) + postorder(r) + [v]\n}\n\npredicate {:spec} isLeaf<T>(t: BinaryTree<T>)\n{\n  t.Node? && t.left == Empty && t.right == Empty\n}\n\nfunction {:spec} leafCount<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, Empty, Empty) => 1\n  case Node(_, l, r) => leafCount(l) + leafCount(r)\n}\n\npredicate {:spec} inTree<T(==)>(x: T, t: BinaryTree<T>)\n{\n  match t\n  case Empty => false\n  case Node(v, l, r) => v == x || inTree(x, l) || inTree(x, r)\n}\n\nfunction {:spec} mirror<T>(t: BinaryTree<T>): BinaryTree<T>\n{\n  match t\n  case Empty => Empty\n  case Node(v, l, r) => Node(v, mirror(r), mirror(l))\n}\n\npredicate {:spec} isBalanced<T>(t: BinaryTree<T>)\n{\n  match t\n  case Empty => true\n  case Node(_, l, r) =>\n    isBalanced(l) && isBalanced(r) &&\n    var diff := if treeHeight(l) > treeHeight(r)\n                then treeHeight(l) - treeHeight(r)\n                else treeHeight(r) - treeHeight(l);\n    diff <= 1\n}\n\nlemma InorderLength<T>(t: BinaryTree<T>)\n  ensures |inorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    InorderLength(l);\n    InorderLength(r);\n    assert |inorder(t)| == |inorder(l)| + 1 + |inorder(r)|;\n}\n\nlemma PreorderLength<T>(t: BinaryTree<T>)\n  ensures |preorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    PreorderLength(l);\n    PreorderLength(r);\n}\n\nlemma PostorderLength<T>(t: BinaryTree<T>)\n  ensures |postorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    PostorderLength(l);\n    PostorderLength(r);\n}\n\nlemma MirrorTwice<T>(t: BinaryTree<T>)\n  ensures mirror(mirror(t)) == t\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorTwice(l);\n    MirrorTwice(r);\n}\n\nlemma MirrorSize<T>(t: BinaryTree<T>)\n  ensures treeSize(mirror(t)) == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorSize(l);\n    MirrorSize(r);\n}\n\nlemma MirrorHeight<T>(t: BinaryTree<T>)\n  ensures treeHeight(mirror(t)) == treeHeight(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorHeight(l);\n    MirrorHeight(r);\n    var lh := treeHeight(l);\n    var rh := treeHeight(r);\n    var mlh := treeHeight(mirror(r));\n    var mrh := treeHeight(mirror(l));\n    assert mlh == rh && mrh == lh;\n}\n\nlemma LeafCountBound<T>(t: BinaryTree<T>)\n  ensures leafCount(t) <= treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(_, l, r) =>\n    if l == Empty && r == Empty {\n      assert leafCount(t) == 1;\n      assert treeSize(t) == 1;\n    } else {\n      LeafCountBound(l);\n      LeafCountBound(r);\n    }\n}\n\nlemma InTreeInorder<T>(x: T, t: BinaryTree<T>)\n  ensures inTree(x, t) <==> x in inorder(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    InTreeInorder(x, l);\n    InTreeInorder(x, r);\n    if x == v {\n      assert x in inorder(t);\n    } else if inTree(x, l) {\n      \n/*[CODE HERE]*/\n      assert x in inorder(t);\n    } else if inTree(x, r) {\n      assert x in inorder(r);\n      assert x in inorder(t);\n    }\n}\n\nlemma HeightLogBound<T>(t: BinaryTree<T>)\n  requires isBalanced(t) && t != Empty\n  ensures treeHeight(t) <= treeSize(t)\n{\n  match t\n  case Node(_, l, r) =>\n    if l != Empty {\n      HeightLogBound(l);\n    }\n    if r != Empty {\n      HeightLogBound(r);\n    }\n}", "output": "assert x in inorder(l);"}, {"id": "example_InTreeInorder_4", "type": "assert", "program": "// Tree operations: size, height, inorder traversal\n\ndatatype BinaryTree<T> = Empty | Node(value: T, left: BinaryTree<T>, right: BinaryTree<T>)\n\nfunction {:spec} treeSize<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, l, r) => 1 + treeSize(l) + treeSize(r)\n}\n\nfunction {:spec} treeHeight<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, l, r) =>\n    var lh := treeHeight(l);\n    var rh := treeHeight(r);\n    1 + if lh > rh then lh else rh\n}\n\nfunction {:spec} inorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => inorder(l) + [v] + inorder(r)\n}\n\nfunction {:spec} preorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => [v] + preorder(l) + preorder(r)\n}\n\nfunction {:spec} postorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => postorder(l) + postorder(r) + [v]\n}\n\npredicate {:spec} isLeaf<T>(t: BinaryTree<T>)\n{\n  t.Node? && t.left == Empty && t.right == Empty\n}\n\nfunction {:spec} leafCount<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, Empty, Empty) => 1\n  case Node(_, l, r) => leafCount(l) + leafCount(r)\n}\n\npredicate {:spec} inTree<T(==)>(x: T, t: BinaryTree<T>)\n{\n  match t\n  case Empty => false\n  case Node(v, l, r) => v == x || inTree(x, l) || inTree(x, r)\n}\n\nfunction {:spec} mirror<T>(t: BinaryTree<T>): BinaryTree<T>\n{\n  match t\n  case Empty => Empty\n  case Node(v, l, r) => Node(v, mirror(r), mirror(l))\n}\n\npredicate {:spec} isBalanced<T>(t: BinaryTree<T>)\n{\n  match t\n  case Empty => true\n  case Node(_, l, r) =>\n    isBalanced(l) && isBalanced(r) &&\n    var diff := if treeHeight(l) > treeHeight(r)\n                then treeHeight(l) - treeHeight(r)\n                else treeHeight(r) - treeHeight(l);\n    diff <= 1\n}\n\nlemma InorderLength<T>(t: BinaryTree<T>)\n  ensures |inorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    InorderLength(l);\n    InorderLength(r);\n    assert |inorder(t)| == |inorder(l)| + 1 + |inorder(r)|;\n}\n\nlemma PreorderLength<T>(t: BinaryTree<T>)\n  ensures |preorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    PreorderLength(l);\n    PreorderLength(r);\n}\n\nlemma PostorderLength<T>(t: BinaryTree<T>)\n  ensures |postorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    PostorderLength(l);\n    PostorderLength(r);\n}\n\nlemma MirrorTwice<T>(t: BinaryTree<T>)\n  ensures mirror(mirror(t)) == t\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorTwice(l);\n    MirrorTwice(r);\n}\n\nlemma MirrorSize<T>(t: BinaryTree<T>)\n  ensures treeSize(mirror(t)) == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorSize(l);\n    MirrorSize(r);\n}\n\nlemma MirrorHeight<T>(t: BinaryTree<T>)\n  ensures treeHeight(mirror(t)) == treeHeight(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorHeight(l);\n    MirrorHeight(r);\n    var lh := treeHeight(l);\n    var rh := treeHeight(r);\n    var mlh := treeHeight(mirror(r));\n    var mrh := treeHeight(mirror(l));\n    assert mlh == rh && mrh == lh;\n}\n\nlemma LeafCountBound<T>(t: BinaryTree<T>)\n  ensures leafCount(t) <= treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(_, l, r) =>\n    if l == Empty && r == Empty {\n      assert leafCount(t) == 1;\n      assert treeSize(t) == 1;\n    } else {\n      LeafCountBound(l);\n      LeafCountBound(r);\n    }\n}\n\nlemma InTreeInorder<T>(x: T, t: BinaryTree<T>)\n  ensures inTree(x, t) <==> x in inorder(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    InTreeInorder(x, l);\n    InTreeInorder(x, r);\n    if x == v {\n      \n/*[CODE HERE]*/\n    } else if inTree(x, l) {\n      assert x in inorder(l);\n      assert x in inorder(t);\n    } else if inTree(x, r) {\n      assert x in inorder(r);\n      assert x in inorder(t);\n    }\n}\n\nlemma HeightLogBound<T>(t: BinaryTree<T>)\n  requires isBalanced(t) && t != Empty\n  ensures treeHeight(t) <= treeSize(t)\n{\n  match t\n  case Node(_, l, r) =>\n    if l != Empty {\n      HeightLogBound(l);\n    }\n    if r != Empty {\n      HeightLogBound(r);\n    }\n}", "output": "assert x in inorder(t);"}, {"id": "example_InTreeInorder_5", "type": "call", "program": "// Tree operations: size, height, inorder traversal\n\ndatatype BinaryTree<T> = Empty | Node(value: T, left: BinaryTree<T>, right: BinaryTree<T>)\n\nfunction {:spec} treeSize<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, l, r) => 1 + treeSize(l) + treeSize(r)\n}\n\nfunction {:spec} treeHeight<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, l, r) =>\n    var lh := treeHeight(l);\n    var rh := treeHeight(r);\n    1 + if lh > rh then lh else rh\n}\n\nfunction {:spec} inorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => inorder(l) + [v] + inorder(r)\n}\n\nfunction {:spec} preorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => [v] + preorder(l) + preorder(r)\n}\n\nfunction {:spec} postorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => postorder(l) + postorder(r) + [v]\n}\n\npredicate {:spec} isLeaf<T>(t: BinaryTree<T>)\n{\n  t.Node? && t.left == Empty && t.right == Empty\n}\n\nfunction {:spec} leafCount<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, Empty, Empty) => 1\n  case Node(_, l, r) => leafCount(l) + leafCount(r)\n}\n\npredicate {:spec} inTree<T(==)>(x: T, t: BinaryTree<T>)\n{\n  match t\n  case Empty => false\n  case Node(v, l, r) => v == x || inTree(x, l) || inTree(x, r)\n}\n\nfunction {:spec} mirror<T>(t: BinaryTree<T>): BinaryTree<T>\n{\n  match t\n  case Empty => Empty\n  case Node(v, l, r) => Node(v, mirror(r), mirror(l))\n}\n\npredicate {:spec} isBalanced<T>(t: BinaryTree<T>)\n{\n  match t\n  case Empty => true\n  case Node(_, l, r) =>\n    isBalanced(l) && isBalanced(r) &&\n    var diff := if treeHeight(l) > treeHeight(r)\n                then treeHeight(l) - treeHeight(r)\n                else treeHeight(r) - treeHeight(l);\n    diff <= 1\n}\n\nlemma InorderLength<T>(t: BinaryTree<T>)\n  ensures |inorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    InorderLength(l);\n    InorderLength(r);\n    assert |inorder(t)| == |inorder(l)| + 1 + |inorder(r)|;\n}\n\nlemma PreorderLength<T>(t: BinaryTree<T>)\n  ensures |preorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    PreorderLength(l);\n    PreorderLength(r);\n}\n\nlemma PostorderLength<T>(t: BinaryTree<T>)\n  ensures |postorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    PostorderLength(l);\n    PostorderLength(r);\n}\n\nlemma MirrorTwice<T>(t: BinaryTree<T>)\n  ensures mirror(mirror(t)) == t\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorTwice(l);\n    MirrorTwice(r);\n}\n\nlemma MirrorSize<T>(t: BinaryTree<T>)\n  ensures treeSize(mirror(t)) == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorSize(l);\n    MirrorSize(r);\n}\n\nlemma MirrorHeight<T>(t: BinaryTree<T>)\n  ensures treeHeight(mirror(t)) == treeHeight(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorHeight(l);\n    MirrorHeight(r);\n    var lh := treeHeight(l);\n    var rh := treeHeight(r);\n    var mlh := treeHeight(mirror(r));\n    var mrh := treeHeight(mirror(l));\n    assert mlh == rh && mrh == lh;\n}\n\nlemma LeafCountBound<T>(t: BinaryTree<T>)\n  ensures leafCount(t) <= treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(_, l, r) =>\n    if l == Empty && r == Empty {\n      assert leafCount(t) == 1;\n      assert treeSize(t) == 1;\n    } else {\n      LeafCountBound(l);\n      LeafCountBound(r);\n    }\n}\n\nlemma InTreeInorder<T>(x: T, t: BinaryTree<T>)\n  ensures inTree(x, t) <==> x in inorder(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    InTreeInorder(x, l);\n    \n/*[CODE HERE]*/\n    if x == v {\n      assert x in inorder(t);\n    } else if inTree(x, l) {\n      assert x in inorder(l);\n      assert x in inorder(t);\n    } else if inTree(x, r) {\n      assert x in inorder(r);\n      assert x in inorder(t);\n    }\n}\n\nlemma HeightLogBound<T>(t: BinaryTree<T>)\n  requires isBalanced(t) && t != Empty\n  ensures treeHeight(t) <= treeSize(t)\n{\n  match t\n  case Node(_, l, r) =>\n    if l != Empty {\n      HeightLogBound(l);\n    }\n    if r != Empty {\n      HeightLogBound(r);\n    }\n}", "output": "InTreeInorder(x, r);"}, {"id": "example_InTreeInorder_6", "type": "call", "program": "// Tree operations: size, height, inorder traversal\n\ndatatype BinaryTree<T> = Empty | Node(value: T, left: BinaryTree<T>, right: BinaryTree<T>)\n\nfunction {:spec} treeSize<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, l, r) => 1 + treeSize(l) + treeSize(r)\n}\n\nfunction {:spec} treeHeight<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, l, r) =>\n    var lh := treeHeight(l);\n    var rh := treeHeight(r);\n    1 + if lh > rh then lh else rh\n}\n\nfunction {:spec} inorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => inorder(l) + [v] + inorder(r)\n}\n\nfunction {:spec} preorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => [v] + preorder(l) + preorder(r)\n}\n\nfunction {:spec} postorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => postorder(l) + postorder(r) + [v]\n}\n\npredicate {:spec} isLeaf<T>(t: BinaryTree<T>)\n{\n  t.Node? && t.left == Empty && t.right == Empty\n}\n\nfunction {:spec} leafCount<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, Empty, Empty) => 1\n  case Node(_, l, r) => leafCount(l) + leafCount(r)\n}\n\npredicate {:spec} inTree<T(==)>(x: T, t: BinaryTree<T>)\n{\n  match t\n  case Empty => false\n  case Node(v, l, r) => v == x || inTree(x, l) || inTree(x, r)\n}\n\nfunction {:spec} mirror<T>(t: BinaryTree<T>): BinaryTree<T>\n{\n  match t\n  case Empty => Empty\n  case Node(v, l, r) => Node(v, mirror(r), mirror(l))\n}\n\npredicate {:spec} isBalanced<T>(t: BinaryTree<T>)\n{\n  match t\n  case Empty => true\n  case Node(_, l, r) =>\n    isBalanced(l) && isBalanced(r) &&\n    var diff := if treeHeight(l) > treeHeight(r)\n                then treeHeight(l) - treeHeight(r)\n                else treeHeight(r) - treeHeight(l);\n    diff <= 1\n}\n\nlemma InorderLength<T>(t: BinaryTree<T>)\n  ensures |inorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    InorderLength(l);\n    InorderLength(r);\n    assert |inorder(t)| == |inorder(l)| + 1 + |inorder(r)|;\n}\n\nlemma PreorderLength<T>(t: BinaryTree<T>)\n  ensures |preorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    PreorderLength(l);\n    PreorderLength(r);\n}\n\nlemma PostorderLength<T>(t: BinaryTree<T>)\n  ensures |postorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    PostorderLength(l);\n    PostorderLength(r);\n}\n\nlemma MirrorTwice<T>(t: BinaryTree<T>)\n  ensures mirror(mirror(t)) == t\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorTwice(l);\n    MirrorTwice(r);\n}\n\nlemma MirrorSize<T>(t: BinaryTree<T>)\n  ensures treeSize(mirror(t)) == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorSize(l);\n    MirrorSize(r);\n}\n\nlemma MirrorHeight<T>(t: BinaryTree<T>)\n  ensures treeHeight(mirror(t)) == treeHeight(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorHeight(l);\n    MirrorHeight(r);\n    var lh := treeHeight(l);\n    var rh := treeHeight(r);\n    var mlh := treeHeight(mirror(r));\n    var mrh := treeHeight(mirror(l));\n    assert mlh == rh && mrh == lh;\n}\n\nlemma LeafCountBound<T>(t: BinaryTree<T>)\n  ensures leafCount(t) <= treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(_, l, r) =>\n    if l == Empty && r == Empty {\n      assert leafCount(t) == 1;\n      assert treeSize(t) == 1;\n    } else {\n      LeafCountBound(l);\n      LeafCountBound(r);\n    }\n}\n\nlemma InTreeInorder<T>(x: T, t: BinaryTree<T>)\n  ensures inTree(x, t) <==> x in inorder(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    \n/*[CODE HERE]*/\n    InTreeInorder(x, r);\n    if x == v {\n      assert x in inorder(t);\n    } else if inTree(x, l) {\n      assert x in inorder(l);\n      assert x in inorder(t);\n    } else if inTree(x, r) {\n      assert x in inorder(r);\n      assert x in inorder(t);\n    }\n}\n\nlemma HeightLogBound<T>(t: BinaryTree<T>)\n  requires isBalanced(t) && t != Empty\n  ensures treeHeight(t) <= treeSize(t)\n{\n  match t\n  case Node(_, l, r) =>\n    if l != Empty {\n      HeightLogBound(l);\n    }\n    if r != Empty {\n      HeightLogBound(r);\n    }\n}", "output": "InTreeInorder(x, l);"}, {"id": "example_HeightLogBound_0", "type": "call", "program": "// Tree operations: size, height, inorder traversal\n\ndatatype BinaryTree<T> = Empty | Node(value: T, left: BinaryTree<T>, right: BinaryTree<T>)\n\nfunction {:spec} treeSize<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, l, r) => 1 + treeSize(l) + treeSize(r)\n}\n\nfunction {:spec} treeHeight<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, l, r) =>\n    var lh := treeHeight(l);\n    var rh := treeHeight(r);\n    1 + if lh > rh then lh else rh\n}\n\nfunction {:spec} inorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => inorder(l) + [v] + inorder(r)\n}\n\nfunction {:spec} preorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => [v] + preorder(l) + preorder(r)\n}\n\nfunction {:spec} postorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => postorder(l) + postorder(r) + [v]\n}\n\npredicate {:spec} isLeaf<T>(t: BinaryTree<T>)\n{\n  t.Node? && t.left == Empty && t.right == Empty\n}\n\nfunction {:spec} leafCount<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, Empty, Empty) => 1\n  case Node(_, l, r) => leafCount(l) + leafCount(r)\n}\n\npredicate {:spec} inTree<T(==)>(x: T, t: BinaryTree<T>)\n{\n  match t\n  case Empty => false\n  case Node(v, l, r) => v == x || inTree(x, l) || inTree(x, r)\n}\n\nfunction {:spec} mirror<T>(t: BinaryTree<T>): BinaryTree<T>\n{\n  match t\n  case Empty => Empty\n  case Node(v, l, r) => Node(v, mirror(r), mirror(l))\n}\n\npredicate {:spec} isBalanced<T>(t: BinaryTree<T>)\n{\n  match t\n  case Empty => true\n  case Node(_, l, r) =>\n    isBalanced(l) && isBalanced(r) &&\n    var diff := if treeHeight(l) > treeHeight(r)\n                then treeHeight(l) - treeHeight(r)\n                else treeHeight(r) - treeHeight(l);\n    diff <= 1\n}\n\nlemma InorderLength<T>(t: BinaryTree<T>)\n  ensures |inorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    InorderLength(l);\n    InorderLength(r);\n    assert |inorder(t)| == |inorder(l)| + 1 + |inorder(r)|;\n}\n\nlemma PreorderLength<T>(t: BinaryTree<T>)\n  ensures |preorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    PreorderLength(l);\n    PreorderLength(r);\n}\n\nlemma PostorderLength<T>(t: BinaryTree<T>)\n  ensures |postorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    PostorderLength(l);\n    PostorderLength(r);\n}\n\nlemma MirrorTwice<T>(t: BinaryTree<T>)\n  ensures mirror(mirror(t)) == t\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorTwice(l);\n    MirrorTwice(r);\n}\n\nlemma MirrorSize<T>(t: BinaryTree<T>)\n  ensures treeSize(mirror(t)) == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorSize(l);\n    MirrorSize(r);\n}\n\nlemma MirrorHeight<T>(t: BinaryTree<T>)\n  ensures treeHeight(mirror(t)) == treeHeight(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorHeight(l);\n    MirrorHeight(r);\n    var lh := treeHeight(l);\n    var rh := treeHeight(r);\n    var mlh := treeHeight(mirror(r));\n    var mrh := treeHeight(mirror(l));\n    assert mlh == rh && mrh == lh;\n}\n\nlemma LeafCountBound<T>(t: BinaryTree<T>)\n  ensures leafCount(t) <= treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(_, l, r) =>\n    if l == Empty && r == Empty {\n      assert leafCount(t) == 1;\n      assert treeSize(t) == 1;\n    } else {\n      LeafCountBound(l);\n      LeafCountBound(r);\n    }\n}\n\nlemma InTreeInorder<T>(x: T, t: BinaryTree<T>)\n  ensures inTree(x, t) <==> x in inorder(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    InTreeInorder(x, l);\n    InTreeInorder(x, r);\n    if x == v {\n      assert x in inorder(t);\n    } else if inTree(x, l) {\n      assert x in inorder(l);\n      assert x in inorder(t);\n    } else if inTree(x, r) {\n      assert x in inorder(r);\n      assert x in inorder(t);\n    }\n}\n\nlemma HeightLogBound<T>(t: BinaryTree<T>)\n  requires isBalanced(t) && t != Empty\n  ensures treeHeight(t) <= treeSize(t)\n{\n  match t\n  case Node(_, l, r) =>\n    if l != Empty {\n      HeightLogBound(l);\n    }\n    if r != Empty {\n      \n/*[CODE HERE]*/\n    }\n}", "output": "HeightLogBound(r);"}, {"id": "example_HeightLogBound_1", "type": "call", "program": "// Tree operations: size, height, inorder traversal\n\ndatatype BinaryTree<T> = Empty | Node(value: T, left: BinaryTree<T>, right: BinaryTree<T>)\n\nfunction {:spec} treeSize<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, l, r) => 1 + treeSize(l) + treeSize(r)\n}\n\nfunction {:spec} treeHeight<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, l, r) =>\n    var lh := treeHeight(l);\n    var rh := treeHeight(r);\n    1 + if lh > rh then lh else rh\n}\n\nfunction {:spec} inorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => inorder(l) + [v] + inorder(r)\n}\n\nfunction {:spec} preorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => [v] + preorder(l) + preorder(r)\n}\n\nfunction {:spec} postorder<T>(t: BinaryTree<T>): seq<T>\n{\n  match t\n  case Empty => []\n  case Node(v, l, r) => postorder(l) + postorder(r) + [v]\n}\n\npredicate {:spec} isLeaf<T>(t: BinaryTree<T>)\n{\n  t.Node? && t.left == Empty && t.right == Empty\n}\n\nfunction {:spec} leafCount<T>(t: BinaryTree<T>): nat\n{\n  match t\n  case Empty => 0\n  case Node(_, Empty, Empty) => 1\n  case Node(_, l, r) => leafCount(l) + leafCount(r)\n}\n\npredicate {:spec} inTree<T(==)>(x: T, t: BinaryTree<T>)\n{\n  match t\n  case Empty => false\n  case Node(v, l, r) => v == x || inTree(x, l) || inTree(x, r)\n}\n\nfunction {:spec} mirror<T>(t: BinaryTree<T>): BinaryTree<T>\n{\n  match t\n  case Empty => Empty\n  case Node(v, l, r) => Node(v, mirror(r), mirror(l))\n}\n\npredicate {:spec} isBalanced<T>(t: BinaryTree<T>)\n{\n  match t\n  case Empty => true\n  case Node(_, l, r) =>\n    isBalanced(l) && isBalanced(r) &&\n    var diff := if treeHeight(l) > treeHeight(r)\n                then treeHeight(l) - treeHeight(r)\n                else treeHeight(r) - treeHeight(l);\n    diff <= 1\n}\n\nlemma InorderLength<T>(t: BinaryTree<T>)\n  ensures |inorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    InorderLength(l);\n    InorderLength(r);\n    assert |inorder(t)| == |inorder(l)| + 1 + |inorder(r)|;\n}\n\nlemma PreorderLength<T>(t: BinaryTree<T>)\n  ensures |preorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    PreorderLength(l);\n    PreorderLength(r);\n}\n\nlemma PostorderLength<T>(t: BinaryTree<T>)\n  ensures |postorder(t)| == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    PostorderLength(l);\n    PostorderLength(r);\n}\n\nlemma MirrorTwice<T>(t: BinaryTree<T>)\n  ensures mirror(mirror(t)) == t\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorTwice(l);\n    MirrorTwice(r);\n}\n\nlemma MirrorSize<T>(t: BinaryTree<T>)\n  ensures treeSize(mirror(t)) == treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorSize(l);\n    MirrorSize(r);\n}\n\nlemma MirrorHeight<T>(t: BinaryTree<T>)\n  ensures treeHeight(mirror(t)) == treeHeight(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    MirrorHeight(l);\n    MirrorHeight(r);\n    var lh := treeHeight(l);\n    var rh := treeHeight(r);\n    var mlh := treeHeight(mirror(r));\n    var mrh := treeHeight(mirror(l));\n    assert mlh == rh && mrh == lh;\n}\n\nlemma LeafCountBound<T>(t: BinaryTree<T>)\n  ensures leafCount(t) <= treeSize(t)\n{\n  match t\n  case Empty =>\n  case Node(_, l, r) =>\n    if l == Empty && r == Empty {\n      assert leafCount(t) == 1;\n      assert treeSize(t) == 1;\n    } else {\n      LeafCountBound(l);\n      LeafCountBound(r);\n    }\n}\n\nlemma InTreeInorder<T>(x: T, t: BinaryTree<T>)\n  ensures inTree(x, t) <==> x in inorder(t)\n{\n  match t\n  case Empty =>\n  case Node(v, l, r) =>\n    InTreeInorder(x, l);\n    InTreeInorder(x, r);\n    if x == v {\n      assert x in inorder(t);\n    } else if inTree(x, l) {\n      assert x in inorder(l);\n      assert x in inorder(t);\n    } else if inTree(x, r) {\n      assert x in inorder(r);\n      assert x in inorder(t);\n    }\n}\n\nlemma HeightLogBound<T>(t: BinaryTree<T>)\n  requires isBalanced(t) && t != Empty\n  ensures treeHeight(t) <= treeSize(t)\n{\n  match t\n  case Node(_, l, r) =>\n    if l != Empty {\n      \n/*[CODE HERE]*/\n    }\n    if r != Empty {\n      HeightLogBound(r);\n    }\n}", "output": "HeightLogBound(l);"}]