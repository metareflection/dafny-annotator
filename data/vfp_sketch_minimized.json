[{"id": "binary_search_solution_binarySearchCorrect_sketch", "type": "sketch", "program": "predicate {:spec} sorted(s: seq<int>)\n{\n  forall i, j :: 0 <= i < j < |s| ==> s[i] <= s[j]\n}\n\nfunction binarySearch(s: seq<int>, key: int): int\n  requires sorted(s)\n{\n  binarySearchHelper(s, key, 0, |s|)\n}\n\nfunction binarySearchHelper(s: seq<int>, key: int, lo: int, hi: int): int\n  requires 0 <= lo <= hi <= |s|\n  requires sorted(s)\n  decreases hi - lo\n{\n  if lo >= hi then |s|\n  else\n    var mid := lo + (hi - lo) / 2;\n    if s[mid] == key then mid\n    else if s[mid] > key then binarySearchHelper(s, key, lo, mid)\n    else binarySearchHelper(s, key, mid + 1, hi)\n}\n\nlemma binarySearchCorrect(s: seq<int>, key: int)\n  requires sorted(s)\n  ensures var idx := binarySearch(s, key);\n    0 <= idx <= |s| &&\n    (idx < |s| ==> s[idx] == key) &&\n    (idx == |s| ==> key !in s)\n{\n/*[SKETCH HERE]*/\n}\n\nlemma binarySearchHelperCorrect(s: seq<int>, key: int, lo: int, hi: int)\n  requires 0 <= lo <= hi <= |s|\n  requires sorted(s)\n  ensures var idx := binarySearchHelper(s, key, lo, hi);\n    0 <= idx <= |s| &&\n    (idx < |s| ==> s[idx] == key) &&\n    (idx == |s| ==> (forall i :: lo <= i < hi ==> s[i] != key))\n  decreases hi - lo\n{\n}\n", "output": ""}, {"id": "bst_solution_Insert_InTree_Subset_sketch", "type": "sketch", "program": "datatype Tree = Leaf | Node(value: int, left: Tree, right: Tree)\n\nghost predicate {:spec} IsBST(t: Tree)\n  decreases t\n{\n  match t\n  case Leaf => true\n  case Node(v, l, r) =>\n    IsBST(l) && IsBST(r) &&\n    (forall x :: InTree(x, l) ==> x < v) &&\n    (forall x :: InTree(x, r) ==> x > v)\n}\n\npredicate {:spec} InTree(x: int, t: Tree)\n  decreases t\n{\n  match t\n  case Leaf => false\n  case Node(v, l, r) =>\n    x == v || InTree(x, l) || InTree(x, r)\n}\n\nfunction {:spec} Contains(t: Tree, key: int): bool\n  requires IsBST(t)\n  decreases t\n{\n  match t\n  case Leaf => false\n  case Node(v, l, r) =>\n    if key == v then true\n    else if (key < v) then Contains(l, key)\n    else Contains(r, key)\n}\n\nfunction {:spec} Insert(t: Tree, x: int): Tree\n  requires IsBST(t)\n  ensures InTree(x, Insert(t, x))\n{\n  match t\n  case Leaf => Node(x, Leaf, Leaf)\n  case Node(v, l, r) => \n      if (x == v) then t\n      else if (x < v) then Node(v, Insert(l, x), r)\n      else Node(v, l, Insert(r, x))\n}\n\nfunction {:spec} Min(t: Tree): int \n  requires IsBST(t)\n  requires t.Node?\n{\n  match t\n  case Node(v, Leaf, _) => v\n  case Node(v, l, _) => Min(l)\n}\n\nlemma Contains_Correct(t: Tree, k: int)\n  requires IsBST(t)\n  ensures Contains(t, k) <==> InTree(k, t)\n  decreases t\n{}\n\nlemma Insert_InTree_Subset(t: Tree, x: int, y: int)\n  requires IsBST(t)\n  ensures InTree(y, Insert(t, x)) ==> InTree(y, t) || y == x\n  decreases t\n{\n/*[SKETCH HERE]*/\n}\n\nlemma Insert_Preserves_BST(t: Tree, x: int)\n  requires IsBST(t)\n  ensures IsBST(Insert(t, x))\n{\n  match t\n  case Leaf => \n  case Node(v, l, r) =>\n    if x == v {\n    } else if x < v {\n      forall y | InTree(y, Insert(l, x))\n        ensures y < v\n      {\n        Insert_InTree_Subset(l, x, y);\n      }\n    } else {\n      forall y | InTree(y, Insert(r, x))\n        ensures y > v\n      {\n        Insert_InTree_Subset(r, x, y);\n      }\n    }\n}\n\nlemma Min_Absolute(t: Tree)\n  requires IsBST(t)\n  requires t.Node?\n  ensures forall v :: InTree(v, t) ==> Min(t) <= v\n  ensures InTree(Min(t), t)\n{}\n\nlemma Insert_Preserves_Node(t: Tree, x: int)\n  requires IsBST(t)\n  requires t.Node?\n  ensures Insert(t, x).Node?\n{}\n\nlemma Insert_New_Min(t: Tree, x: int)\n  requires IsBST(t)\n  requires t.Node?\n  requires !Contains(t, x)\n  requires x < Min(t)\n  requires IsBST(Insert(t, x))\n  ensures Min(Insert(t, x)) == x\n{\n  match t\n  case Node(v, l, r) =>\n    match l\n    case Leaf =>\n    case Node(_, _, _) =>\n      Min_Absolute(l);\n}\n", "output": "  match t\n  case Leaf =>\n  case Node(v, l, r) =>\n    if x == v {\n    } else if x < v {\n    } else {\n    }"}, {"id": "bst_solution_Insert_Preserves_BST_sketch", "type": "sketch", "program": "datatype Tree = Leaf | Node(value: int, left: Tree, right: Tree)\n\nghost predicate {:spec} IsBST(t: Tree)\n  decreases t\n{\n  match t\n  case Leaf => true\n  case Node(v, l, r) =>\n    IsBST(l) && IsBST(r) &&\n    (forall x :: InTree(x, l) ==> x < v) &&\n    (forall x :: InTree(x, r) ==> x > v)\n}\n\npredicate {:spec} InTree(x: int, t: Tree)\n  decreases t\n{\n  match t\n  case Leaf => false\n  case Node(v, l, r) =>\n    x == v || InTree(x, l) || InTree(x, r)\n}\n\nfunction {:spec} Contains(t: Tree, key: int): bool\n  requires IsBST(t)\n  decreases t\n{\n  match t\n  case Leaf => false\n  case Node(v, l, r) =>\n    if key == v then true\n    else if (key < v) then Contains(l, key)\n    else Contains(r, key)\n}\n\nfunction {:spec} Insert(t: Tree, x: int): Tree\n  requires IsBST(t)\n  ensures InTree(x, Insert(t, x))\n{\n  match t\n  case Leaf => Node(x, Leaf, Leaf)\n  case Node(v, l, r) => \n      if (x == v) then t\n      else if (x < v) then Node(v, Insert(l, x), r)\n      else Node(v, l, Insert(r, x))\n}\n\nfunction {:spec} Min(t: Tree): int \n  requires IsBST(t)\n  requires t.Node?\n{\n  match t\n  case Node(v, Leaf, _) => v\n  case Node(v, l, _) => Min(l)\n}\n\nlemma Contains_Correct(t: Tree, k: int)\n  requires IsBST(t)\n  ensures Contains(t, k) <==> InTree(k, t)\n  decreases t\n{}\n\nlemma Insert_InTree_Subset(t: Tree, x: int, y: int)\n  requires IsBST(t)\n  ensures InTree(y, Insert(t, x)) ==> InTree(y, t) || y == x\n  decreases t\n{\n  match t\n  case Leaf =>\n  case Node(v, l, r) =>\n    if x == v {\n    } else if x < v {\n      Insert_InTree_Subset(l, x, y);\n    } else {\n      Insert_InTree_Subset(r, x, y);\n    }\n}\n\nlemma Insert_Preserves_BST(t: Tree, x: int)\n  requires IsBST(t)\n  ensures IsBST(Insert(t, x))\n{\n/*[SKETCH HERE]*/\n}\n\nlemma Min_Absolute(t: Tree)\n  requires IsBST(t)\n  requires t.Node?\n  ensures forall v :: InTree(v, t) ==> Min(t) <= v\n  ensures InTree(Min(t), t)\n{}\n\nlemma Insert_Preserves_Node(t: Tree, x: int)\n  requires IsBST(t)\n  requires t.Node?\n  ensures Insert(t, x).Node?\n{}\n\nlemma Insert_New_Min(t: Tree, x: int)\n  requires IsBST(t)\n  requires t.Node?\n  requires !Contains(t, x)\n  requires x < Min(t)\n  requires IsBST(Insert(t, x))\n  ensures Min(Insert(t, x)) == x\n{\n  match t\n  case Node(v, l, r) =>\n    match l\n    case Leaf =>\n    case Node(_, _, _) =>\n      Min_Absolute(l);\n}\n", "output": "  match t\n  case Leaf => \n  case Node(v, l, r) =>\n    if x == v {\n    } else if x < v {\n      forall y | InTree(y, Insert(l, x))\n        ensures y < v\n      {\n      }\n    } else {\n      forall y | InTree(y, Insert(r, x))\n        ensures y > v\n      {\n      }\n    }"}, {"id": "bst_solution_Insert_New_Min_sketch", "type": "sketch", "program": "datatype Tree = Leaf | Node(value: int, left: Tree, right: Tree)\n\nghost predicate {:spec} IsBST(t: Tree)\n  decreases t\n{\n  match t\n  case Leaf => true\n  case Node(v, l, r) =>\n    IsBST(l) && IsBST(r) &&\n    (forall x :: InTree(x, l) ==> x < v) &&\n    (forall x :: InTree(x, r) ==> x > v)\n}\n\npredicate {:spec} InTree(x: int, t: Tree)\n  decreases t\n{\n  match t\n  case Leaf => false\n  case Node(v, l, r) =>\n    x == v || InTree(x, l) || InTree(x, r)\n}\n\nfunction {:spec} Contains(t: Tree, key: int): bool\n  requires IsBST(t)\n  decreases t\n{\n  match t\n  case Leaf => false\n  case Node(v, l, r) =>\n    if key == v then true\n    else if (key < v) then Contains(l, key)\n    else Contains(r, key)\n}\n\nfunction {:spec} Insert(t: Tree, x: int): Tree\n  requires IsBST(t)\n  ensures InTree(x, Insert(t, x))\n{\n  match t\n  case Leaf => Node(x, Leaf, Leaf)\n  case Node(v, l, r) => \n      if (x == v) then t\n      else if (x < v) then Node(v, Insert(l, x), r)\n      else Node(v, l, Insert(r, x))\n}\n\nfunction {:spec} Min(t: Tree): int \n  requires IsBST(t)\n  requires t.Node?\n{\n  match t\n  case Node(v, Leaf, _) => v\n  case Node(v, l, _) => Min(l)\n}\n\nlemma Contains_Correct(t: Tree, k: int)\n  requires IsBST(t)\n  ensures Contains(t, k) <==> InTree(k, t)\n  decreases t\n{}\n\nlemma Insert_InTree_Subset(t: Tree, x: int, y: int)\n  requires IsBST(t)\n  ensures InTree(y, Insert(t, x)) ==> InTree(y, t) || y == x\n  decreases t\n{\n  match t\n  case Leaf =>\n  case Node(v, l, r) =>\n    if x == v {\n    } else if x < v {\n      Insert_InTree_Subset(l, x, y);\n    } else {\n      Insert_InTree_Subset(r, x, y);\n    }\n}\n\nlemma Insert_Preserves_BST(t: Tree, x: int)\n  requires IsBST(t)\n  ensures IsBST(Insert(t, x))\n{\n  match t\n  case Leaf => \n  case Node(v, l, r) =>\n    if x == v {\n    } else if x < v {\n      forall y | InTree(y, Insert(l, x))\n        ensures y < v\n      {\n        Insert_InTree_Subset(l, x, y);\n      }\n    } else {\n      forall y | InTree(y, Insert(r, x))\n        ensures y > v\n      {\n        Insert_InTree_Subset(r, x, y);\n      }\n    }\n}\n\nlemma Min_Absolute(t: Tree)\n  requires IsBST(t)\n  requires t.Node?\n  ensures forall v :: InTree(v, t) ==> Min(t) <= v\n  ensures InTree(Min(t), t)\n{}\n\nlemma Insert_Preserves_Node(t: Tree, x: int)\n  requires IsBST(t)\n  requires t.Node?\n  ensures Insert(t, x).Node?\n{}\n\nlemma Insert_New_Min(t: Tree, x: int)\n  requires IsBST(t)\n  requires t.Node?\n  requires !Contains(t, x)\n  requires x < Min(t)\n  requires IsBST(Insert(t, x))\n  ensures Min(Insert(t, x)) == x\n{\n/*[SKETCH HERE]*/\n}\n", "output": "  match t\n  case Node(v, l, r) =>\n    match l\n    case Leaf =>\n    case Node(_, _, _) =>"}, {"id": "dedup_solution_dedupCorrect_sketch", "type": "sketch", "program": "function dedup(xs: seq<int>): seq<int>\n{\n  if |xs| == 0 then []\n  else if xs[0] in dedup(xs[1..]) then dedup(xs[1..])\n  else [xs[0]] + dedup(xs[1..])\n}\n\npredicate {:spec} noDuplicates(xs: seq<int>)\n{\n  forall i, j :: 0 <= i < j < |xs| ==> xs[i] != xs[j]\n}\n\nfunction {:spec} toSet(xs: seq<int>): set<int>\n{\n  set x | x in xs\n}\n\nlemma dedupCorrect(xs: seq<int>)\n  ensures noDuplicates(dedup(xs))\n  ensures toSet(dedup(xs)) == toSet(xs)\n{\n/*[SKETCH HERE]*/\n}\n", "output": "  if |xs| == 0 {\n  } else {\n    var rest := dedup(xs[1..]);\n    \n    if xs[0] in rest {\n    } else {\n      \n      forall i, j | 0 <= i < j < |dedup(xs)|\n        ensures dedup(xs)[i] != dedup(xs)[j]\n      {\n        if i == 0 {\n        } else {\n        }\n      }\n      \n    }\n  }"}, {"id": "fibonacci_solution_fibPairCorrect_sketch", "type": "sketch", "program": "function fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n-1) + fib(n-2)\n}\n\nfunction fibPair(n: nat): (nat, nat)\n{\n  if n == 0 then (0, 1)\n  else\n    var (a, b) := fibPair(n-1);\n    (b, a + b)\n}\n\nlemma fibCorrect(n: nat)\n  ensures fib(0) == 0\n  ensures fib(1) == 1\n  ensures n >= 2 ==> fib(n) == fib(n-1) + fib(n-2)\n{\n}\n\nlemma fibPairCorrect(n: nat)\n  ensures fibPair(n) == (fib(n), fib(n+1))\n{\n/*[SKETCH HERE]*/\n}\n\nlemma fibIncreasing(n: nat)\n  ensures fib(n) <= fib(n+1)\n{\n}\n", "output": "  if n == 0 {\n  } else {\n    var (a, b) := fibPair(n-1);\n    if n == 1 {\n    } else {\n    }\n  }"}, {"id": "flatten_solution_toMultisetAppend_sketch", "type": "sketch", "program": "datatype Tree<T> = Leaf(value: T) | Node(left: Tree<T>, right: Tree<T>)\n\nfunction flatten<T>(t: Tree<T>): seq<T>\n{\n  match t\n  case Leaf(v) => [v]\n  case Node(l, r) => flatten(l) + flatten(r)\n}\n\nfunction size<T>(t: Tree<T>): nat\n{\n  match t\n  case Leaf(_) => 1\n  case Node(l, r) => size(l) + size(r)\n}\n\nfunction toMultiset<T>(s: seq<T>): multiset<T>\n{\n  if |s| == 0 then multiset{}\n  else multiset{s[0]} + toMultiset(s[1..])\n}\n\nfunction treeToMultiset<T>(t: Tree<T>): multiset<T>\n{\n  match t\n  case Leaf(v) => multiset{v}\n  case Node(l, r) => treeToMultiset(l) + treeToMultiset(r)\n}\n\nlemma toMultisetAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures toMultiset(s1 + s2) == toMultiset(s1) + toMultiset(s2)\n{\n/*[SKETCH HERE]*/\n}\n\nlemma flattenCorrect<T>(t: Tree<T>)\n  ensures |flatten(t)| == size(t)\n  ensures toMultiset(flatten(t)) == treeToMultiset(t)\n{\n  match t\n  case Leaf(v) =>\n  case Node(l, r) =>\n    toMultisetAppend(flatten(l), flatten(r));\n}\n", "output": "  if |s1| == 0 {\n  } else {\n  }"}, {"id": "flatten_solution_flattenCorrect_sketch", "type": "sketch", "program": "datatype Tree<T> = Leaf(value: T) | Node(left: Tree<T>, right: Tree<T>)\n\nfunction flatten<T>(t: Tree<T>): seq<T>\n{\n  match t\n  case Leaf(v) => [v]\n  case Node(l, r) => flatten(l) + flatten(r)\n}\n\nfunction size<T>(t: Tree<T>): nat\n{\n  match t\n  case Leaf(_) => 1\n  case Node(l, r) => size(l) + size(r)\n}\n\nfunction toMultiset<T>(s: seq<T>): multiset<T>\n{\n  if |s| == 0 then multiset{}\n  else multiset{s[0]} + toMultiset(s[1..])\n}\n\nfunction treeToMultiset<T>(t: Tree<T>): multiset<T>\n{\n  match t\n  case Leaf(v) => multiset{v}\n  case Node(l, r) => treeToMultiset(l) + treeToMultiset(r)\n}\n\nlemma toMultisetAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures toMultiset(s1 + s2) == toMultiset(s1) + toMultiset(s2)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n  } else {\n    assert s1 + s2 == [s1[0]] + (s1[1..] + s2);\n  }\n}\n\nlemma flattenCorrect<T>(t: Tree<T>)\n  ensures |flatten(t)| == size(t)\n  ensures toMultiset(flatten(t)) == treeToMultiset(t)\n{\n/*[SKETCH HERE]*/\n}\n", "output": "  match t\n  case Leaf(v) =>\n  case Node(l, r) =>"}, {"id": "graph_operations_solution_DirectEdgeReachable_sketch", "type": "sketch", "program": "// Graph operations: path, reachable, cycle detection\n\ntype Node = nat\n\ndatatype Graph = Graph(nodes: set<Node>, edges: set<(Node, Node)>)\n\npredicate {:spec} validGraph(g: Graph)\n{\n  forall e :: e in g.edges ==> e.0 in g.nodes && e.1 in g.nodes\n}\n\npredicate {:spec} hasEdge(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n{\n  (from, to) in g.edges\n}\n\nfunction {:spec} neighbors(g: Graph, n: Node): set<Node>\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  set m | m in g.nodes && (n, m) in g.edges\n}\n\npredicate {:spec} isPath(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n{\n  |path| > 0 &&\n  (forall i :: 0 <= i < |path| ==> path[i] in g.nodes) &&\n  (forall i :: 0 <= i < |path| - 1 ==> hasEdge(g, path[i], path[i+1]))\n}\n\nghost predicate {:spec} reachable(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n{\n  exists path :: isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to\n}\n\nghost predicate {:spec} hasCycle(g: Graph)\n  requires validGraph(g)\n{\n  exists path :: isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1]\n}\n\nghost predicate {:spec} isAcyclic(g: Graph)\n  requires validGraph(g)\n{\n  !hasCycle(g)\n}\n\nghost predicate {:spec} isTree(g: Graph)\n  requires validGraph(g)\n{\n  isAcyclic(g) &&\n  |g.edges| == |g.nodes| - 1 &&\n  forall n, m :: n in g.nodes && m in g.nodes && n != m ==> reachable(g, n, m)\n}\n\nfunction {:spec} inDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |set m | m in g.nodes && (m, n) in g.edges|\n}\n\nfunction {:spec} outDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |neighbors(g, n)|\n}\n\nghost predicate {:spec} isConnected(g: Graph)\n  requires validGraph(g)\n{\n  forall n, m :: n in g.nodes && m in g.nodes ==> reachable(g, n, m)\n}\n\n// Simplified version without recursion\nghost function {:spec} graphDistance(g: Graph, from: Node, to: Node): nat\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n  requires reachable(g, from, to)\n{\n  var path :| isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to;\n  |path| - 1\n}\n\nlemma SelfReachable(g: Graph, n: Node)\n  requires validGraph(g)\n  requires n in g.nodes\n  ensures reachable(g, n, n)\n{\n  var path := [n];\n\n  // Show isPath\n  forall i | 0 <= i < |path|\n    ensures path[i] in g.nodes\n  {\n  }\n\n  forall i | 0 <= i < |path| - 1\n    ensures hasEdge(g, path[i], path[i+1])\n  {\n  }\n\n}\n\nlemma DirectEdgeReachable(g: Graph, a: Node, b: Node)\n  requires validGraph(g)\n  requires a in g.nodes && b in g.nodes\n  requires hasEdge(g, a, b)\n  ensures reachable(g, a, b)\n{\n/*[SKETCH HERE]*/\n}\n\nlemma PathOfLengthTwo(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n  requires isPath(g, path)\n  requires |path| == 2\n  ensures path[0] in g.nodes && path[1] in g.nodes\n  ensures hasEdge(g, path[0], path[1])\n{\n}\n\nlemma TreeNoCycle(g: Graph)\n  requires validGraph(g)\n  requires isTree(g)\n  ensures isAcyclic(g)\n{\n}\n\nlemma EmptyGraphAcyclic(g: Graph)\n  requires validGraph(g)\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  if hasCycle(g) {\n    var path :| isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1];\n    assert hasEdge(g, path[0], path[1]);\n  }\n}\n\nlemma SingleNodeAcyclic(g: Graph)\n  requires validGraph(g)\n  requires |g.nodes| == 1\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  EmptyGraphAcyclic(g);\n}\n\nlemma ValidGraphSubgraph(g: Graph, removed: Node)\n  requires validGraph(g)\n  requires removed in g.nodes\n  ensures validGraph(Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed))\n{\n}\n", "output": "  if a == b {\n  } else {\n    var path := [a, b];\n\n    // Show isPath\n    forall i | 0 <= i < |path|\n      ensures path[i] in g.nodes\n    {\n      if i == 0 { assert path[i] == a; }\n      else { assert path[i] == b; }\n    }\n\n    forall i | 0 <= i < |path| - 1\n      ensures hasEdge(g, path[i], path[i+1])\n    {\n    }\n\n  }"}, {"id": "graph_operations_solution_EmptyGraphAcyclic_sketch", "type": "sketch", "program": "// Graph operations: path, reachable, cycle detection\n\ntype Node = nat\n\ndatatype Graph = Graph(nodes: set<Node>, edges: set<(Node, Node)>)\n\npredicate {:spec} validGraph(g: Graph)\n{\n  forall e :: e in g.edges ==> e.0 in g.nodes && e.1 in g.nodes\n}\n\npredicate {:spec} hasEdge(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n{\n  (from, to) in g.edges\n}\n\nfunction {:spec} neighbors(g: Graph, n: Node): set<Node>\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  set m | m in g.nodes && (n, m) in g.edges\n}\n\npredicate {:spec} isPath(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n{\n  |path| > 0 &&\n  (forall i :: 0 <= i < |path| ==> path[i] in g.nodes) &&\n  (forall i :: 0 <= i < |path| - 1 ==> hasEdge(g, path[i], path[i+1]))\n}\n\nghost predicate {:spec} reachable(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n{\n  exists path :: isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to\n}\n\nghost predicate {:spec} hasCycle(g: Graph)\n  requires validGraph(g)\n{\n  exists path :: isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1]\n}\n\nghost predicate {:spec} isAcyclic(g: Graph)\n  requires validGraph(g)\n{\n  !hasCycle(g)\n}\n\nghost predicate {:spec} isTree(g: Graph)\n  requires validGraph(g)\n{\n  isAcyclic(g) &&\n  |g.edges| == |g.nodes| - 1 &&\n  forall n, m :: n in g.nodes && m in g.nodes && n != m ==> reachable(g, n, m)\n}\n\nfunction {:spec} inDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |set m | m in g.nodes && (m, n) in g.edges|\n}\n\nfunction {:spec} outDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |neighbors(g, n)|\n}\n\nghost predicate {:spec} isConnected(g: Graph)\n  requires validGraph(g)\n{\n  forall n, m :: n in g.nodes && m in g.nodes ==> reachable(g, n, m)\n}\n\n// Simplified version without recursion\nghost function {:spec} graphDistance(g: Graph, from: Node, to: Node): nat\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n  requires reachable(g, from, to)\n{\n  var path :| isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to;\n  |path| - 1\n}\n\nlemma SelfReachable(g: Graph, n: Node)\n  requires validGraph(g)\n  requires n in g.nodes\n  ensures reachable(g, n, n)\n{\n  var path := [n];\n\n  // Show isPath\n  forall i | 0 <= i < |path|\n    ensures path[i] in g.nodes\n  {\n  }\n\n  forall i | 0 <= i < |path| - 1\n    ensures hasEdge(g, path[i], path[i+1])\n  {\n  }\n\n}\n\nlemma DirectEdgeReachable(g: Graph, a: Node, b: Node)\n  requires validGraph(g)\n  requires a in g.nodes && b in g.nodes\n  requires hasEdge(g, a, b)\n  ensures reachable(g, a, b)\n{\n  if a == b {\n    SelfReachable(g, a);\n  } else {\n    var path := [a, b];\n\n    // Show isPath\n    forall i | 0 <= i < |path|\n      ensures path[i] in g.nodes\n    {\n      if i == 0 { assert path[i] == a; }\n      else { assert path[i] == b; }\n    }\n\n    forall i | 0 <= i < |path| - 1\n      ensures hasEdge(g, path[i], path[i+1])\n    {\n    }\n\n  }\n}\n\nlemma PathOfLengthTwo(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n  requires isPath(g, path)\n  requires |path| == 2\n  ensures path[0] in g.nodes && path[1] in g.nodes\n  ensures hasEdge(g, path[0], path[1])\n{\n}\n\nlemma TreeNoCycle(g: Graph)\n  requires validGraph(g)\n  requires isTree(g)\n  ensures isAcyclic(g)\n{\n}\n\nlemma EmptyGraphAcyclic(g: Graph)\n  requires validGraph(g)\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n/*[SKETCH HERE]*/\n}\n\nlemma SingleNodeAcyclic(g: Graph)\n  requires validGraph(g)\n  requires |g.nodes| == 1\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  EmptyGraphAcyclic(g);\n}\n\nlemma ValidGraphSubgraph(g: Graph, removed: Node)\n  requires validGraph(g)\n  requires removed in g.nodes\n  ensures validGraph(Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed))\n{\n}\n", "output": "  if hasCycle(g) {\n    var path :| isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1];\n  }"}, {"id": "graph_operations_solution_SingleNodeAcyclic_sketch", "type": "sketch", "program": "// Graph operations: path, reachable, cycle detection\n\ntype Node = nat\n\ndatatype Graph = Graph(nodes: set<Node>, edges: set<(Node, Node)>)\n\npredicate {:spec} validGraph(g: Graph)\n{\n  forall e :: e in g.edges ==> e.0 in g.nodes && e.1 in g.nodes\n}\n\npredicate {:spec} hasEdge(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n{\n  (from, to) in g.edges\n}\n\nfunction {:spec} neighbors(g: Graph, n: Node): set<Node>\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  set m | m in g.nodes && (n, m) in g.edges\n}\n\npredicate {:spec} isPath(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n{\n  |path| > 0 &&\n  (forall i :: 0 <= i < |path| ==> path[i] in g.nodes) &&\n  (forall i :: 0 <= i < |path| - 1 ==> hasEdge(g, path[i], path[i+1]))\n}\n\nghost predicate {:spec} reachable(g: Graph, from: Node, to: Node)\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n{\n  exists path :: isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to\n}\n\nghost predicate {:spec} hasCycle(g: Graph)\n  requires validGraph(g)\n{\n  exists path :: isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1]\n}\n\nghost predicate {:spec} isAcyclic(g: Graph)\n  requires validGraph(g)\n{\n  !hasCycle(g)\n}\n\nghost predicate {:spec} isTree(g: Graph)\n  requires validGraph(g)\n{\n  isAcyclic(g) &&\n  |g.edges| == |g.nodes| - 1 &&\n  forall n, m :: n in g.nodes && m in g.nodes && n != m ==> reachable(g, n, m)\n}\n\nfunction {:spec} inDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |set m | m in g.nodes && (m, n) in g.edges|\n}\n\nfunction {:spec} outDegree(g: Graph, n: Node): nat\n  requires validGraph(g)\n  requires n in g.nodes\n{\n  |neighbors(g, n)|\n}\n\nghost predicate {:spec} isConnected(g: Graph)\n  requires validGraph(g)\n{\n  forall n, m :: n in g.nodes && m in g.nodes ==> reachable(g, n, m)\n}\n\n// Simplified version without recursion\nghost function {:spec} graphDistance(g: Graph, from: Node, to: Node): nat\n  requires validGraph(g)\n  requires from in g.nodes && to in g.nodes\n  requires reachable(g, from, to)\n{\n  var path :| isPath(g, path) && |path| >= 1 &&\n    path[0] == from && path[|path| - 1] == to;\n  |path| - 1\n}\n\nlemma SelfReachable(g: Graph, n: Node)\n  requires validGraph(g)\n  requires n in g.nodes\n  ensures reachable(g, n, n)\n{\n  var path := [n];\n\n  // Show isPath\n  forall i | 0 <= i < |path|\n    ensures path[i] in g.nodes\n  {\n  }\n\n  forall i | 0 <= i < |path| - 1\n    ensures hasEdge(g, path[i], path[i+1])\n  {\n  }\n\n}\n\nlemma DirectEdgeReachable(g: Graph, a: Node, b: Node)\n  requires validGraph(g)\n  requires a in g.nodes && b in g.nodes\n  requires hasEdge(g, a, b)\n  ensures reachable(g, a, b)\n{\n  if a == b {\n    SelfReachable(g, a);\n  } else {\n    var path := [a, b];\n\n    // Show isPath\n    forall i | 0 <= i < |path|\n      ensures path[i] in g.nodes\n    {\n      if i == 0 { assert path[i] == a; }\n      else { assert path[i] == b; }\n    }\n\n    forall i | 0 <= i < |path| - 1\n      ensures hasEdge(g, path[i], path[i+1])\n    {\n    }\n\n  }\n}\n\nlemma PathOfLengthTwo(g: Graph, path: seq<Node>)\n  requires validGraph(g)\n  requires isPath(g, path)\n  requires |path| == 2\n  ensures path[0] in g.nodes && path[1] in g.nodes\n  ensures hasEdge(g, path[0], path[1])\n{\n}\n\nlemma TreeNoCycle(g: Graph)\n  requires validGraph(g)\n  requires isTree(g)\n  ensures isAcyclic(g)\n{\n}\n\nlemma EmptyGraphAcyclic(g: Graph)\n  requires validGraph(g)\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n  if hasCycle(g) {\n    var path :| isPath(g, path) && |path| > 1 && path[0] == path[|path| - 1];\n    assert hasEdge(g, path[0], path[1]);\n  }\n}\n\nlemma SingleNodeAcyclic(g: Graph)\n  requires validGraph(g)\n  requires |g.nodes| == 1\n  requires g.edges == {}\n  ensures isAcyclic(g)\n{\n/*[SKETCH HERE]*/\n}\n\nlemma ValidGraphSubgraph(g: Graph, removed: Node)\n  requires validGraph(g)\n  requires removed in g.nodes\n  ensures validGraph(Graph(g.nodes - {removed},\n    set e | e in g.edges && e.0 != removed && e.1 != removed))\n{\n}\n", "output": ""}, {"id": "heap_solution_MinHeapRootIsMinimum_sketch", "type": "sketch", "program": "// Min-heap operations: insert, extractMin, heapify with heap property\n\ndatatype Heap = Heap(elements: seq<int>)\n\n// Check if heap is empty\npredicate {:spec} heapIsEmpty(h: Heap)\n{\n  |h.elements| == 0\n}\n\n// Get heap size\nfunction {:spec} heapSize(h: Heap): nat\n{\n  |h.elements|\n}\n\n// Parent index in heap\nfunction {:spec} parent(i: nat): nat\n  requires i > 0\n{\n  (i - 1) / 2\n}\n\n// Left child index\nfunction {:spec} leftChild(i: nat): nat\n{\n  2 * i + 1\n}\n\n// Right child index\nfunction {:spec} rightChild(i: nat): nat\n{\n  2 * i + 2\n}\n\n// Check min-heap property\npredicate {:spec} isMinHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] <= h.elements[i]\n}\n\n// Check max-heap property\npredicate {:spec} isMaxHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] >= h.elements[i]\n}\n\n// Get minimum element (root of min-heap)\nfunction {:spec} getMin(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n{\n  h.elements[0]\n}\n\n// Get maximum element (root of max-heap)\nfunction {:spec} getMax(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n{\n  h.elements[0]\n}\n\n// Check if element exists in heap\npredicate {:spec} heapContains(h: Heap, x: int)\n{\n  x in h.elements\n}\n\n// Create empty heap\nfunction {:spec} emptyHeap(): Heap\n{\n  Heap([])\n}\n\n// Create heap from single element\nfunction {:spec} singletonHeap(x: int): Heap\n{\n  Heap([x])\n}\n\n// Swap two elements in sequence\nfunction {:spec} swap(s: seq<int>, i: nat, j: nat): seq<int>\n  requires i < |s| && j < |s|\n{\n  s[i := s[j]][j := s[i]]\n}\n\n// Check if heap is complete binary tree (always true for array representation)\npredicate {:spec} isComplete(h: Heap)\n{\n  true  // Array representation is always complete\n}\n\n// Get height of heap\nfunction {:spec} heapHeight(h: Heap): nat\n{\n  if |h.elements| == 0 then 0\n  else log2Floor(|h.elements|) + 1\n}\n\n// Floor of log base 2\nfunction {:spec} log2Floor(n: nat): nat\n  requires n > 0\n  decreases n\n{\n  if n == 1 then 0\n  else 1 + log2Floor(n / 2)\n}\n\n// Check if index is valid\npredicate {:spec} validIndex(h: Heap, i: nat)\n{\n  i < |h.elements|\n}\n\n// Get all elements at a given level\nfunction {:spec} getLevel(h: Heap, level: nat): seq<int>\n{\n  getLevelHelper(h, level, 0)\n}\n\nfunction getLevelHelper(h: Heap, targetLevel: nat, currentLevel: nat): seq<int>\n  decreases |h.elements| - currentLevel\n{\n  if currentLevel >= |h.elements| || currentLevel >= Power2(targetLevel) then []\n  else if currentLevel >= Power2(targetLevel) - 1 && currentLevel < Power2(targetLevel + 1) - 1 then\n    if currentLevel < |h.elements| then [h.elements[currentLevel]] + getLevelHelper(h, targetLevel, currentLevel + 1)\n    else []\n  else getLevelHelper(h, targetLevel, currentLevel + 1)\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1\n  else 2 * Power2(n - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma EmptyHeapIsMinHeap()\n  ensures isMinHeap(emptyHeap())\n{\n}\n\nlemma EmptyHeapIsMaxHeap()\n  ensures isMaxHeap(emptyHeap())\n{\n}\n\nlemma SingletonIsMinHeap(x: int)\n  ensures isMinHeap(singletonHeap(x))\n{\n}\n\nlemma SingletonIsMaxHeap(x: int)\n  ensures isMaxHeap(singletonHeap(x))\n{\n}\n\nlemma MinHeapRootIsMinimum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] <= h.elements[i]\n{\n/*[SKETCH HERE]*/\n}\n\nlemma MinHeapPathToRoot(h: Heap, i: nat)\n  requires isMinHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] <= h.elements[i]\n{\n  if parent(i) == 0 {\n  } else {\n    MinHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma MaxHeapRootIsMaximum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] >= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MaxHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MaxHeapPathToRoot(h: Heap, i: nat)\n  requires isMaxHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] >= h.elements[i]\n{\n  if parent(i) == 0 {\n  } else {\n    MaxHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma ParentChildRelation(i: nat)\n  requires i > 0\n  ensures leftChild(parent(i)) == i || rightChild(parent(i)) == i\n  ensures leftChild(parent(i)) == i <==> i % 2 == 1\n  ensures rightChild(parent(i)) == i <==> i % 2 == 0\n{\n}\n\nlemma HeapHeightBound(h: Heap)\n  ensures heapHeight(h) <= |h.elements|\n{\n  if |h.elements| == 0 {\n  } else {\n    Log2FloorBound(|h.elements|);\n  }\n}\n\nlemma Log2FloorBound(n: nat)\n  requires n > 0\n  ensures log2Floor(n) < n\n  decreases n\n{\n}\n\nlemma SwapPreservesMultiset(s: seq<int>, i: nat, j: nat)\n  requires i < |s| && j < |s|\n  ensures multiset(swap(s, i, j)) == multiset(s)\n{\n}\n", "output": "  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n      }\n    }\n  }"}, {"id": "heap_solution_MinHeapPathToRoot_sketch", "type": "sketch", "program": "// Min-heap operations: insert, extractMin, heapify with heap property\n\ndatatype Heap = Heap(elements: seq<int>)\n\n// Check if heap is empty\npredicate {:spec} heapIsEmpty(h: Heap)\n{\n  |h.elements| == 0\n}\n\n// Get heap size\nfunction {:spec} heapSize(h: Heap): nat\n{\n  |h.elements|\n}\n\n// Parent index in heap\nfunction {:spec} parent(i: nat): nat\n  requires i > 0\n{\n  (i - 1) / 2\n}\n\n// Left child index\nfunction {:spec} leftChild(i: nat): nat\n{\n  2 * i + 1\n}\n\n// Right child index\nfunction {:spec} rightChild(i: nat): nat\n{\n  2 * i + 2\n}\n\n// Check min-heap property\npredicate {:spec} isMinHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] <= h.elements[i]\n}\n\n// Check max-heap property\npredicate {:spec} isMaxHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] >= h.elements[i]\n}\n\n// Get minimum element (root of min-heap)\nfunction {:spec} getMin(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n{\n  h.elements[0]\n}\n\n// Get maximum element (root of max-heap)\nfunction {:spec} getMax(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n{\n  h.elements[0]\n}\n\n// Check if element exists in heap\npredicate {:spec} heapContains(h: Heap, x: int)\n{\n  x in h.elements\n}\n\n// Create empty heap\nfunction {:spec} emptyHeap(): Heap\n{\n  Heap([])\n}\n\n// Create heap from single element\nfunction {:spec} singletonHeap(x: int): Heap\n{\n  Heap([x])\n}\n\n// Swap two elements in sequence\nfunction {:spec} swap(s: seq<int>, i: nat, j: nat): seq<int>\n  requires i < |s| && j < |s|\n{\n  s[i := s[j]][j := s[i]]\n}\n\n// Check if heap is complete binary tree (always true for array representation)\npredicate {:spec} isComplete(h: Heap)\n{\n  true  // Array representation is always complete\n}\n\n// Get height of heap\nfunction {:spec} heapHeight(h: Heap): nat\n{\n  if |h.elements| == 0 then 0\n  else log2Floor(|h.elements|) + 1\n}\n\n// Floor of log base 2\nfunction {:spec} log2Floor(n: nat): nat\n  requires n > 0\n  decreases n\n{\n  if n == 1 then 0\n  else 1 + log2Floor(n / 2)\n}\n\n// Check if index is valid\npredicate {:spec} validIndex(h: Heap, i: nat)\n{\n  i < |h.elements|\n}\n\n// Get all elements at a given level\nfunction {:spec} getLevel(h: Heap, level: nat): seq<int>\n{\n  getLevelHelper(h, level, 0)\n}\n\nfunction getLevelHelper(h: Heap, targetLevel: nat, currentLevel: nat): seq<int>\n  decreases |h.elements| - currentLevel\n{\n  if currentLevel >= |h.elements| || currentLevel >= Power2(targetLevel) then []\n  else if currentLevel >= Power2(targetLevel) - 1 && currentLevel < Power2(targetLevel + 1) - 1 then\n    if currentLevel < |h.elements| then [h.elements[currentLevel]] + getLevelHelper(h, targetLevel, currentLevel + 1)\n    else []\n  else getLevelHelper(h, targetLevel, currentLevel + 1)\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1\n  else 2 * Power2(n - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma EmptyHeapIsMinHeap()\n  ensures isMinHeap(emptyHeap())\n{\n}\n\nlemma EmptyHeapIsMaxHeap()\n  ensures isMaxHeap(emptyHeap())\n{\n}\n\nlemma SingletonIsMinHeap(x: int)\n  ensures isMinHeap(singletonHeap(x))\n{\n}\n\nlemma SingletonIsMaxHeap(x: int)\n  ensures isMaxHeap(singletonHeap(x))\n{\n}\n\nlemma MinHeapRootIsMinimum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] <= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MinHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MinHeapPathToRoot(h: Heap, i: nat)\n  requires isMinHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] <= h.elements[i]\n{\n/*[SKETCH HERE]*/\n}\n\nlemma MaxHeapRootIsMaximum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] >= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MaxHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MaxHeapPathToRoot(h: Heap, i: nat)\n  requires isMaxHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] >= h.elements[i]\n{\n  if parent(i) == 0 {\n  } else {\n    MaxHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma ParentChildRelation(i: nat)\n  requires i > 0\n  ensures leftChild(parent(i)) == i || rightChild(parent(i)) == i\n  ensures leftChild(parent(i)) == i <==> i % 2 == 1\n  ensures rightChild(parent(i)) == i <==> i % 2 == 0\n{\n}\n\nlemma HeapHeightBound(h: Heap)\n  ensures heapHeight(h) <= |h.elements|\n{\n  if |h.elements| == 0 {\n  } else {\n    Log2FloorBound(|h.elements|);\n  }\n}\n\nlemma Log2FloorBound(n: nat)\n  requires n > 0\n  ensures log2Floor(n) < n\n  decreases n\n{\n}\n\nlemma SwapPreservesMultiset(s: seq<int>, i: nat, j: nat)\n  requires i < |s| && j < |s|\n  ensures multiset(swap(s, i, j)) == multiset(s)\n{\n}\n", "output": "  if parent(i) == 0 {\n  } else {\n  }"}, {"id": "heap_solution_MaxHeapRootIsMaximum_sketch", "type": "sketch", "program": "// Min-heap operations: insert, extractMin, heapify with heap property\n\ndatatype Heap = Heap(elements: seq<int>)\n\n// Check if heap is empty\npredicate {:spec} heapIsEmpty(h: Heap)\n{\n  |h.elements| == 0\n}\n\n// Get heap size\nfunction {:spec} heapSize(h: Heap): nat\n{\n  |h.elements|\n}\n\n// Parent index in heap\nfunction {:spec} parent(i: nat): nat\n  requires i > 0\n{\n  (i - 1) / 2\n}\n\n// Left child index\nfunction {:spec} leftChild(i: nat): nat\n{\n  2 * i + 1\n}\n\n// Right child index\nfunction {:spec} rightChild(i: nat): nat\n{\n  2 * i + 2\n}\n\n// Check min-heap property\npredicate {:spec} isMinHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] <= h.elements[i]\n}\n\n// Check max-heap property\npredicate {:spec} isMaxHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] >= h.elements[i]\n}\n\n// Get minimum element (root of min-heap)\nfunction {:spec} getMin(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n{\n  h.elements[0]\n}\n\n// Get maximum element (root of max-heap)\nfunction {:spec} getMax(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n{\n  h.elements[0]\n}\n\n// Check if element exists in heap\npredicate {:spec} heapContains(h: Heap, x: int)\n{\n  x in h.elements\n}\n\n// Create empty heap\nfunction {:spec} emptyHeap(): Heap\n{\n  Heap([])\n}\n\n// Create heap from single element\nfunction {:spec} singletonHeap(x: int): Heap\n{\n  Heap([x])\n}\n\n// Swap two elements in sequence\nfunction {:spec} swap(s: seq<int>, i: nat, j: nat): seq<int>\n  requires i < |s| && j < |s|\n{\n  s[i := s[j]][j := s[i]]\n}\n\n// Check if heap is complete binary tree (always true for array representation)\npredicate {:spec} isComplete(h: Heap)\n{\n  true  // Array representation is always complete\n}\n\n// Get height of heap\nfunction {:spec} heapHeight(h: Heap): nat\n{\n  if |h.elements| == 0 then 0\n  else log2Floor(|h.elements|) + 1\n}\n\n// Floor of log base 2\nfunction {:spec} log2Floor(n: nat): nat\n  requires n > 0\n  decreases n\n{\n  if n == 1 then 0\n  else 1 + log2Floor(n / 2)\n}\n\n// Check if index is valid\npredicate {:spec} validIndex(h: Heap, i: nat)\n{\n  i < |h.elements|\n}\n\n// Get all elements at a given level\nfunction {:spec} getLevel(h: Heap, level: nat): seq<int>\n{\n  getLevelHelper(h, level, 0)\n}\n\nfunction getLevelHelper(h: Heap, targetLevel: nat, currentLevel: nat): seq<int>\n  decreases |h.elements| - currentLevel\n{\n  if currentLevel >= |h.elements| || currentLevel >= Power2(targetLevel) then []\n  else if currentLevel >= Power2(targetLevel) - 1 && currentLevel < Power2(targetLevel + 1) - 1 then\n    if currentLevel < |h.elements| then [h.elements[currentLevel]] + getLevelHelper(h, targetLevel, currentLevel + 1)\n    else []\n  else getLevelHelper(h, targetLevel, currentLevel + 1)\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1\n  else 2 * Power2(n - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma EmptyHeapIsMinHeap()\n  ensures isMinHeap(emptyHeap())\n{\n}\n\nlemma EmptyHeapIsMaxHeap()\n  ensures isMaxHeap(emptyHeap())\n{\n}\n\nlemma SingletonIsMinHeap(x: int)\n  ensures isMinHeap(singletonHeap(x))\n{\n}\n\nlemma SingletonIsMaxHeap(x: int)\n  ensures isMaxHeap(singletonHeap(x))\n{\n}\n\nlemma MinHeapRootIsMinimum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] <= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MinHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MinHeapPathToRoot(h: Heap, i: nat)\n  requires isMinHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] <= h.elements[i]\n{\n  if parent(i) == 0 {\n  } else {\n    MinHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma MaxHeapRootIsMaximum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] >= h.elements[i]\n{\n/*[SKETCH HERE]*/\n}\n\nlemma MaxHeapPathToRoot(h: Heap, i: nat)\n  requires isMaxHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] >= h.elements[i]\n{\n  if parent(i) == 0 {\n  } else {\n    MaxHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma ParentChildRelation(i: nat)\n  requires i > 0\n  ensures leftChild(parent(i)) == i || rightChild(parent(i)) == i\n  ensures leftChild(parent(i)) == i <==> i % 2 == 1\n  ensures rightChild(parent(i)) == i <==> i % 2 == 0\n{\n}\n\nlemma HeapHeightBound(h: Heap)\n  ensures heapHeight(h) <= |h.elements|\n{\n  if |h.elements| == 0 {\n  } else {\n    Log2FloorBound(|h.elements|);\n  }\n}\n\nlemma Log2FloorBound(n: nat)\n  requires n > 0\n  ensures log2Floor(n) < n\n  decreases n\n{\n}\n\nlemma SwapPreservesMultiset(s: seq<int>, i: nat, j: nat)\n  requires i < |s| && j < |s|\n  ensures multiset(swap(s, i, j)) == multiset(s)\n{\n}\n", "output": "  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n      }\n    }\n  }"}, {"id": "heap_solution_MaxHeapPathToRoot_sketch", "type": "sketch", "program": "// Min-heap operations: insert, extractMin, heapify with heap property\n\ndatatype Heap = Heap(elements: seq<int>)\n\n// Check if heap is empty\npredicate {:spec} heapIsEmpty(h: Heap)\n{\n  |h.elements| == 0\n}\n\n// Get heap size\nfunction {:spec} heapSize(h: Heap): nat\n{\n  |h.elements|\n}\n\n// Parent index in heap\nfunction {:spec} parent(i: nat): nat\n  requires i > 0\n{\n  (i - 1) / 2\n}\n\n// Left child index\nfunction {:spec} leftChild(i: nat): nat\n{\n  2 * i + 1\n}\n\n// Right child index\nfunction {:spec} rightChild(i: nat): nat\n{\n  2 * i + 2\n}\n\n// Check min-heap property\npredicate {:spec} isMinHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] <= h.elements[i]\n}\n\n// Check max-heap property\npredicate {:spec} isMaxHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] >= h.elements[i]\n}\n\n// Get minimum element (root of min-heap)\nfunction {:spec} getMin(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n{\n  h.elements[0]\n}\n\n// Get maximum element (root of max-heap)\nfunction {:spec} getMax(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n{\n  h.elements[0]\n}\n\n// Check if element exists in heap\npredicate {:spec} heapContains(h: Heap, x: int)\n{\n  x in h.elements\n}\n\n// Create empty heap\nfunction {:spec} emptyHeap(): Heap\n{\n  Heap([])\n}\n\n// Create heap from single element\nfunction {:spec} singletonHeap(x: int): Heap\n{\n  Heap([x])\n}\n\n// Swap two elements in sequence\nfunction {:spec} swap(s: seq<int>, i: nat, j: nat): seq<int>\n  requires i < |s| && j < |s|\n{\n  s[i := s[j]][j := s[i]]\n}\n\n// Check if heap is complete binary tree (always true for array representation)\npredicate {:spec} isComplete(h: Heap)\n{\n  true  // Array representation is always complete\n}\n\n// Get height of heap\nfunction {:spec} heapHeight(h: Heap): nat\n{\n  if |h.elements| == 0 then 0\n  else log2Floor(|h.elements|) + 1\n}\n\n// Floor of log base 2\nfunction {:spec} log2Floor(n: nat): nat\n  requires n > 0\n  decreases n\n{\n  if n == 1 then 0\n  else 1 + log2Floor(n / 2)\n}\n\n// Check if index is valid\npredicate {:spec} validIndex(h: Heap, i: nat)\n{\n  i < |h.elements|\n}\n\n// Get all elements at a given level\nfunction {:spec} getLevel(h: Heap, level: nat): seq<int>\n{\n  getLevelHelper(h, level, 0)\n}\n\nfunction getLevelHelper(h: Heap, targetLevel: nat, currentLevel: nat): seq<int>\n  decreases |h.elements| - currentLevel\n{\n  if currentLevel >= |h.elements| || currentLevel >= Power2(targetLevel) then []\n  else if currentLevel >= Power2(targetLevel) - 1 && currentLevel < Power2(targetLevel + 1) - 1 then\n    if currentLevel < |h.elements| then [h.elements[currentLevel]] + getLevelHelper(h, targetLevel, currentLevel + 1)\n    else []\n  else getLevelHelper(h, targetLevel, currentLevel + 1)\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1\n  else 2 * Power2(n - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma EmptyHeapIsMinHeap()\n  ensures isMinHeap(emptyHeap())\n{\n}\n\nlemma EmptyHeapIsMaxHeap()\n  ensures isMaxHeap(emptyHeap())\n{\n}\n\nlemma SingletonIsMinHeap(x: int)\n  ensures isMinHeap(singletonHeap(x))\n{\n}\n\nlemma SingletonIsMaxHeap(x: int)\n  ensures isMaxHeap(singletonHeap(x))\n{\n}\n\nlemma MinHeapRootIsMinimum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] <= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MinHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MinHeapPathToRoot(h: Heap, i: nat)\n  requires isMinHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] <= h.elements[i]\n{\n  if parent(i) == 0 {\n  } else {\n    MinHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma MaxHeapRootIsMaximum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] >= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MaxHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MaxHeapPathToRoot(h: Heap, i: nat)\n  requires isMaxHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] >= h.elements[i]\n{\n/*[SKETCH HERE]*/\n}\n\nlemma ParentChildRelation(i: nat)\n  requires i > 0\n  ensures leftChild(parent(i)) == i || rightChild(parent(i)) == i\n  ensures leftChild(parent(i)) == i <==> i % 2 == 1\n  ensures rightChild(parent(i)) == i <==> i % 2 == 0\n{\n}\n\nlemma HeapHeightBound(h: Heap)\n  ensures heapHeight(h) <= |h.elements|\n{\n  if |h.elements| == 0 {\n  } else {\n    Log2FloorBound(|h.elements|);\n  }\n}\n\nlemma Log2FloorBound(n: nat)\n  requires n > 0\n  ensures log2Floor(n) < n\n  decreases n\n{\n}\n\nlemma SwapPreservesMultiset(s: seq<int>, i: nat, j: nat)\n  requires i < |s| && j < |s|\n  ensures multiset(swap(s, i, j)) == multiset(s)\n{\n}\n", "output": "  if parent(i) == 0 {\n  } else {\n  }"}, {"id": "heap_solution_HeapHeightBound_sketch", "type": "sketch", "program": "// Min-heap operations: insert, extractMin, heapify with heap property\n\ndatatype Heap = Heap(elements: seq<int>)\n\n// Check if heap is empty\npredicate {:spec} heapIsEmpty(h: Heap)\n{\n  |h.elements| == 0\n}\n\n// Get heap size\nfunction {:spec} heapSize(h: Heap): nat\n{\n  |h.elements|\n}\n\n// Parent index in heap\nfunction {:spec} parent(i: nat): nat\n  requires i > 0\n{\n  (i - 1) / 2\n}\n\n// Left child index\nfunction {:spec} leftChild(i: nat): nat\n{\n  2 * i + 1\n}\n\n// Right child index\nfunction {:spec} rightChild(i: nat): nat\n{\n  2 * i + 2\n}\n\n// Check min-heap property\npredicate {:spec} isMinHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] <= h.elements[i]\n}\n\n// Check max-heap property\npredicate {:spec} isMaxHeap(h: Heap)\n{\n  forall i :: 0 < i < |h.elements| ==> h.elements[parent(i)] >= h.elements[i]\n}\n\n// Get minimum element (root of min-heap)\nfunction {:spec} getMin(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n{\n  h.elements[0]\n}\n\n// Get maximum element (root of max-heap)\nfunction {:spec} getMax(h: Heap): int\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n{\n  h.elements[0]\n}\n\n// Check if element exists in heap\npredicate {:spec} heapContains(h: Heap, x: int)\n{\n  x in h.elements\n}\n\n// Create empty heap\nfunction {:spec} emptyHeap(): Heap\n{\n  Heap([])\n}\n\n// Create heap from single element\nfunction {:spec} singletonHeap(x: int): Heap\n{\n  Heap([x])\n}\n\n// Swap two elements in sequence\nfunction {:spec} swap(s: seq<int>, i: nat, j: nat): seq<int>\n  requires i < |s| && j < |s|\n{\n  s[i := s[j]][j := s[i]]\n}\n\n// Check if heap is complete binary tree (always true for array representation)\npredicate {:spec} isComplete(h: Heap)\n{\n  true  // Array representation is always complete\n}\n\n// Get height of heap\nfunction {:spec} heapHeight(h: Heap): nat\n{\n  if |h.elements| == 0 then 0\n  else log2Floor(|h.elements|) + 1\n}\n\n// Floor of log base 2\nfunction {:spec} log2Floor(n: nat): nat\n  requires n > 0\n  decreases n\n{\n  if n == 1 then 0\n  else 1 + log2Floor(n / 2)\n}\n\n// Check if index is valid\npredicate {:spec} validIndex(h: Heap, i: nat)\n{\n  i < |h.elements|\n}\n\n// Get all elements at a given level\nfunction {:spec} getLevel(h: Heap, level: nat): seq<int>\n{\n  getLevelHelper(h, level, 0)\n}\n\nfunction getLevelHelper(h: Heap, targetLevel: nat, currentLevel: nat): seq<int>\n  decreases |h.elements| - currentLevel\n{\n  if currentLevel >= |h.elements| || currentLevel >= Power2(targetLevel) then []\n  else if currentLevel >= Power2(targetLevel) - 1 && currentLevel < Power2(targetLevel + 1) - 1 then\n    if currentLevel < |h.elements| then [h.elements[currentLevel]] + getLevelHelper(h, targetLevel, currentLevel + 1)\n    else []\n  else getLevelHelper(h, targetLevel, currentLevel + 1)\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1\n  else 2 * Power2(n - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma EmptyHeapIsMinHeap()\n  ensures isMinHeap(emptyHeap())\n{\n}\n\nlemma EmptyHeapIsMaxHeap()\n  ensures isMaxHeap(emptyHeap())\n{\n}\n\nlemma SingletonIsMinHeap(x: int)\n  ensures isMinHeap(singletonHeap(x))\n{\n}\n\nlemma SingletonIsMaxHeap(x: int)\n  ensures isMaxHeap(singletonHeap(x))\n{\n}\n\nlemma MinHeapRootIsMinimum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMinHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] <= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] <= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MinHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MinHeapPathToRoot(h: Heap, i: nat)\n  requires isMinHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] <= h.elements[i]\n{\n  if parent(i) == 0 {\n  } else {\n    MinHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma MaxHeapRootIsMaximum(h: Heap)\n  requires !heapIsEmpty(h)\n  requires isMaxHeap(h)\n  ensures forall i :: 0 <= i < |h.elements| ==> h.elements[0] >= h.elements[i]\n{\n  if |h.elements| == 1 {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n    }\n  } else {\n    forall i | 0 <= i < |h.elements|\n      ensures h.elements[0] >= h.elements[i]\n    {\n      if i == 0 {\n        // Trivial\n      } else {\n        MaxHeapPathToRoot(h, i);\n      }\n    }\n  }\n}\n\nlemma MaxHeapPathToRoot(h: Heap, i: nat)\n  requires isMaxHeap(h)\n  requires 0 < i < |h.elements|\n  ensures h.elements[0] >= h.elements[i]\n{\n  if parent(i) == 0 {\n  } else {\n    MaxHeapPathToRoot(h, parent(i));\n  }\n}\n\nlemma ParentChildRelation(i: nat)\n  requires i > 0\n  ensures leftChild(parent(i)) == i || rightChild(parent(i)) == i\n  ensures leftChild(parent(i)) == i <==> i % 2 == 1\n  ensures rightChild(parent(i)) == i <==> i % 2 == 0\n{\n}\n\nlemma HeapHeightBound(h: Heap)\n  ensures heapHeight(h) <= |h.elements|\n{\n/*[SKETCH HERE]*/\n}\n\nlemma Log2FloorBound(n: nat)\n  requires n > 0\n  ensures log2Floor(n) < n\n  decreases n\n{\n}\n\nlemma SwapPreservesMultiset(s: seq<int>, i: nat, j: nat)\n  requires i < |s| && j < |s|\n  ensures multiset(swap(s, i, j)) == multiset(s)\n{\n}\n", "output": "  if |h.elements| == 0 {\n  } else {\n  }"}, {"id": "induction_solution_CompleteInduction_sketch", "type": "sketch", "program": "// Induction proofs with detailed reasoning steps\n\n// Sum of first n natural numbers\nfunction {:spec} sumTo(n: nat): nat\n{\n  if n == 0 then 0 else n + sumTo(n - 1)\n}\n\n// Sum of first n odd numbers\nfunction {:spec} sumOdds(n: nat): nat\n{\n  if n == 0 then 0 else (2 * n - 1) + sumOdds(n - 1)\n}\n\n// Sum of first n squares\nfunction {:spec} sumSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + sumSquares(n - 1)\n}\n\n// Power function\nfunction {:spec} power(base: nat, exp: nat): nat\n{\n  if exp == 0 then 1 else base * power(base, exp - 1)\n}\n\n// Fibonacci\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// --- Detailed Inductive Proofs ---\n\nlemma SumToFormula(n: nat)\n  ensures sumTo(n) == n * (n + 1) / 2\n{\n}\n\nlemma SumOddsIsSquare(n: nat)\n  ensures sumOdds(n) == n * n\n{\n}\n\nlemma SumSquaresFormula(n: nat)\n  ensures sumSquares(n) == n * (n + 1) * (2 * n + 1) / 6\n{\n}\n\nlemma PowerOfTwo(n: nat)\n  ensures power(2, n) >= n + 1\n{\n}\n\nlemma PowerMonotonic(base: nat, exp1: nat, exp2: nat)\n  requires base > 1\n  requires exp1 <= exp2\n  ensures power(base, exp1) <= power(base, exp2)\n{\n}\n\nlemma PowerPositive(base: nat, exp: nat)\n  requires base > 0\n  ensures power(base, exp) > 0\n{\n}\n\nlemma FibonacciInequality(n: nat)\n  requires n >= 1\n  ensures fib(n) <= power(2, n - 1)\n{\n}\n\nlemma StrongInduction(n: nat, P: nat -> bool)\n  requires forall k :: 0 <= k < n ==> P(k)\n  requires forall m :: m >= n && (forall j :: n <= j < m ==> P(j)) ==> P(m)\n  ensures P(n)\n{\n}\n\nlemma CompleteInduction(n: nat, P: nat -> bool)\n  requires P(0)\n  requires forall k: nat :: k > 0 && (forall j: nat :: j < k ==> P(j)) ==> P(k)\n  ensures P(n)\n{\n/*[SKETCH HERE]*/\n}\n", "output": "  if n == 0 {\n    // Base case\n  } else {\n    // Need to show all j < n satisfy P(j)\n    forall j: nat | j < n\n      ensures P(j)\n    {\n      if j == 0 {\n      } else {\n      }\n    }\n\n    // Now apply the inductive hypothesis\n  }"}, {"id": "linkedlist_solution_ReverseLength_sketch", "type": "sketch", "program": "// Linked list operations: insert, delete, reverse, cycle detection\n\ndatatype LinkedList<T> = Nil | Cons(head: T, tail: LinkedList<T>)\n\n// Length of linked list\nfunction {:spec} length<T>(list: LinkedList<T>): nat\n{\n  match list\n  case Nil => 0\n  case Cons(_, tail) => 1 + length(tail)\n}\n\n// Append two linked lists\nfunction {:spec} append<T>(l1: LinkedList<T>, l2: LinkedList<T>): LinkedList<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, append(t, l2))\n}\n\n// Reverse a linked list\nfunction {:spec} reverse<T>(list: LinkedList<T>): LinkedList<T>\n{\n  reverseHelper(list, Nil)\n}\n\nfunction reverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>): LinkedList<T>\n{\n  match list\n  case Nil => acc\n  case Cons(h, t) => reverseHelper(t, Cons(h, acc))\n}\n\n// Get nth element (0-indexed)\nfunction {:spec} nth<T>(list: LinkedList<T>, n: nat): T\n  requires n < length(list)\n{\n  match list\n  case Cons(h, t) => if n == 0 then h else nth(t, n - 1)\n}\n\n// Check if element exists in list\npredicate {:spec} contains<T(==)>(list: LinkedList<T>, x: T)\n{\n  match list\n  case Nil => false\n  case Cons(h, t) => h == x || contains(t, x)\n}\n\n// Remove first occurrence of element\nfunction {:spec} remove<T(==)>(list: LinkedList<T>, x: T): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => if h == x then t else Cons(h, remove(t, x))\n}\n\n// Insert at position\nfunction {:spec} insertAt<T>(list: LinkedList<T>, x: T, pos: nat): LinkedList<T>\n{\n  if pos == 0 then Cons(x, list)\n  else match list\n    case Nil => Cons(x, Nil)\n    case Cons(h, t) => Cons(h, insertAt(t, x, pos - 1))\n}\n\n// Convert to sequence\nfunction {:spec} toSeq<T>(list: LinkedList<T>): seq<T>\n{\n  match list\n  case Nil => []\n  case Cons(h, t) => [h] + toSeq(t)\n}\n\n// Convert from sequence\nfunction {:spec} fromSeq<T>(s: seq<T>): LinkedList<T>\n{\n  if |s| == 0 then Nil\n  else Cons(s[0], fromSeq(s[1..]))\n}\n\n// Map function over list\nfunction {:spec} listMap<T, U>(list: LinkedList<T>, f: T -> U): LinkedList<U>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => Cons(f(h), listMap(t, f))\n}\n\n// Filter list with predicate\nfunction {:spec} filter<T>(list: LinkedList<T>, p: T -> bool): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) =>\n    if p(h) then Cons(h, filter(t, p))\n    else filter(t, p)\n}\n\n// Take first n elements\nfunction {:spec} take<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n{\n  if n == 0 then Nil\n  else match list\n    case Nil => Nil\n    case Cons(h, t) => Cons(h, take(t, n - 1))\n}\n\n// Drop first n elements\nfunction {:spec} drop<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n  decreases list\n{\n  if n == 0 then list\n  else match list\n    case Nil => Nil\n    case Cons(_, t) => drop(t, n - 1)\n}\n\n// Check if list is palindrome\npredicate {:spec} isPalindrome<T(==)>(list: LinkedList<T>)\n{\n  toSeq(list) == toSeq(reverse(list))\n}\n\n// --- Lemmas for correctness ---\n\nlemma LengthAppend<T>(l1: LinkedList<T>, l2: LinkedList<T>)\n  ensures length(append(l1, l2)) == length(l1) + length(l2)\n{\n}\n\nlemma AppendNil<T>(list: LinkedList<T>)\n  ensures append(list, Nil) == list\n  ensures append(Nil, list) == list\n{\n}\n\nlemma AppendAssociative<T>(l1: LinkedList<T>, l2: LinkedList<T>, l3: LinkedList<T>)\n  ensures append(append(l1, l2), l3) == append(l1, append(l2, l3))\n{\n}\n\nlemma ReverseLength<T>(list: LinkedList<T>)\n  ensures length(reverse(list)) == length(list)\n{\n/*[SKETCH HERE]*/\n}\n\nlemma ReverseHelperLength<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures length(reverseHelper(list, acc)) == length(list) + length(acc)\n{\n}\n\nlemma ReverseReverse<T>(list: LinkedList<T>)\n  ensures reverse(reverse(list)) == list\n{\n  ReverseReverseHelper(list, Nil);\n}\n\nlemma ReverseReverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures reverseHelper(reverseHelper(list, acc), Nil) == reverseHelper(acc, list)\n{\n}\n\nlemma ToSeqFromSeq<T>(s: seq<T>)\n  ensures toSeq(fromSeq(s)) == s\n{\n}\n\nlemma FromSeqToSeq<T>(list: LinkedList<T>)\n  ensures fromSeq(toSeq(list)) == list\n{\n}\n\nlemma NthCorrect<T>(list: LinkedList<T>, n: nat)\n  requires n < length(list)\n  ensures |toSeq(list)| > n\n  ensures toSeq(list)[n] == nth(list, n)\n{\n  match list\n  case Cons(h, t) =>\n    if n == 0 {\n    } else {\n      NthCorrect(t, n - 1);\n    }\n}\n\nlemma MapLength<T, U>(list: LinkedList<T>, f: T -> U)\n  ensures length(listMap(list, f)) == length(list)\n{\n}\n\nlemma FilterSubset<T>(list: LinkedList<T>, p: T -> bool)\n  ensures length(filter(list, p)) <= length(list)\n{\n}\n\nlemma TakeDropConcat<T>(list: LinkedList<T>, n: nat)\n  ensures append(take(list, n), drop(list, n)) == list\n{\n}\n\nlemma RemoveDecreasesLength<T>(list: LinkedList<T>, x: T)\n  requires contains(list, x)\n  ensures length(remove(list, x)) == length(list) - 1\n{\n}\n\nlemma InsertAtLength<T>(list: LinkedList<T>, x: T, pos: nat)\n  ensures length(insertAt(list, x, pos)) == length(list) + 1\n{\n}\n", "output": ""}, {"id": "linkedlist_solution_ReverseReverse_sketch", "type": "sketch", "program": "// Linked list operations: insert, delete, reverse, cycle detection\n\ndatatype LinkedList<T> = Nil | Cons(head: T, tail: LinkedList<T>)\n\n// Length of linked list\nfunction {:spec} length<T>(list: LinkedList<T>): nat\n{\n  match list\n  case Nil => 0\n  case Cons(_, tail) => 1 + length(tail)\n}\n\n// Append two linked lists\nfunction {:spec} append<T>(l1: LinkedList<T>, l2: LinkedList<T>): LinkedList<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, append(t, l2))\n}\n\n// Reverse a linked list\nfunction {:spec} reverse<T>(list: LinkedList<T>): LinkedList<T>\n{\n  reverseHelper(list, Nil)\n}\n\nfunction reverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>): LinkedList<T>\n{\n  match list\n  case Nil => acc\n  case Cons(h, t) => reverseHelper(t, Cons(h, acc))\n}\n\n// Get nth element (0-indexed)\nfunction {:spec} nth<T>(list: LinkedList<T>, n: nat): T\n  requires n < length(list)\n{\n  match list\n  case Cons(h, t) => if n == 0 then h else nth(t, n - 1)\n}\n\n// Check if element exists in list\npredicate {:spec} contains<T(==)>(list: LinkedList<T>, x: T)\n{\n  match list\n  case Nil => false\n  case Cons(h, t) => h == x || contains(t, x)\n}\n\n// Remove first occurrence of element\nfunction {:spec} remove<T(==)>(list: LinkedList<T>, x: T): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => if h == x then t else Cons(h, remove(t, x))\n}\n\n// Insert at position\nfunction {:spec} insertAt<T>(list: LinkedList<T>, x: T, pos: nat): LinkedList<T>\n{\n  if pos == 0 then Cons(x, list)\n  else match list\n    case Nil => Cons(x, Nil)\n    case Cons(h, t) => Cons(h, insertAt(t, x, pos - 1))\n}\n\n// Convert to sequence\nfunction {:spec} toSeq<T>(list: LinkedList<T>): seq<T>\n{\n  match list\n  case Nil => []\n  case Cons(h, t) => [h] + toSeq(t)\n}\n\n// Convert from sequence\nfunction {:spec} fromSeq<T>(s: seq<T>): LinkedList<T>\n{\n  if |s| == 0 then Nil\n  else Cons(s[0], fromSeq(s[1..]))\n}\n\n// Map function over list\nfunction {:spec} listMap<T, U>(list: LinkedList<T>, f: T -> U): LinkedList<U>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => Cons(f(h), listMap(t, f))\n}\n\n// Filter list with predicate\nfunction {:spec} filter<T>(list: LinkedList<T>, p: T -> bool): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) =>\n    if p(h) then Cons(h, filter(t, p))\n    else filter(t, p)\n}\n\n// Take first n elements\nfunction {:spec} take<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n{\n  if n == 0 then Nil\n  else match list\n    case Nil => Nil\n    case Cons(h, t) => Cons(h, take(t, n - 1))\n}\n\n// Drop first n elements\nfunction {:spec} drop<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n  decreases list\n{\n  if n == 0 then list\n  else match list\n    case Nil => Nil\n    case Cons(_, t) => drop(t, n - 1)\n}\n\n// Check if list is palindrome\npredicate {:spec} isPalindrome<T(==)>(list: LinkedList<T>)\n{\n  toSeq(list) == toSeq(reverse(list))\n}\n\n// --- Lemmas for correctness ---\n\nlemma LengthAppend<T>(l1: LinkedList<T>, l2: LinkedList<T>)\n  ensures length(append(l1, l2)) == length(l1) + length(l2)\n{\n}\n\nlemma AppendNil<T>(list: LinkedList<T>)\n  ensures append(list, Nil) == list\n  ensures append(Nil, list) == list\n{\n}\n\nlemma AppendAssociative<T>(l1: LinkedList<T>, l2: LinkedList<T>, l3: LinkedList<T>)\n  ensures append(append(l1, l2), l3) == append(l1, append(l2, l3))\n{\n}\n\nlemma ReverseLength<T>(list: LinkedList<T>)\n  ensures length(reverse(list)) == length(list)\n{\n  ReverseHelperLength(list, Nil);\n}\n\nlemma ReverseHelperLength<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures length(reverseHelper(list, acc)) == length(list) + length(acc)\n{\n}\n\nlemma ReverseReverse<T>(list: LinkedList<T>)\n  ensures reverse(reverse(list)) == list\n{\n/*[SKETCH HERE]*/\n}\n\nlemma ReverseReverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures reverseHelper(reverseHelper(list, acc), Nil) == reverseHelper(acc, list)\n{\n}\n\nlemma ToSeqFromSeq<T>(s: seq<T>)\n  ensures toSeq(fromSeq(s)) == s\n{\n}\n\nlemma FromSeqToSeq<T>(list: LinkedList<T>)\n  ensures fromSeq(toSeq(list)) == list\n{\n}\n\nlemma NthCorrect<T>(list: LinkedList<T>, n: nat)\n  requires n < length(list)\n  ensures |toSeq(list)| > n\n  ensures toSeq(list)[n] == nth(list, n)\n{\n  match list\n  case Cons(h, t) =>\n    if n == 0 {\n    } else {\n      NthCorrect(t, n - 1);\n    }\n}\n\nlemma MapLength<T, U>(list: LinkedList<T>, f: T -> U)\n  ensures length(listMap(list, f)) == length(list)\n{\n}\n\nlemma FilterSubset<T>(list: LinkedList<T>, p: T -> bool)\n  ensures length(filter(list, p)) <= length(list)\n{\n}\n\nlemma TakeDropConcat<T>(list: LinkedList<T>, n: nat)\n  ensures append(take(list, n), drop(list, n)) == list\n{\n}\n\nlemma RemoveDecreasesLength<T>(list: LinkedList<T>, x: T)\n  requires contains(list, x)\n  ensures length(remove(list, x)) == length(list) - 1\n{\n}\n\nlemma InsertAtLength<T>(list: LinkedList<T>, x: T, pos: nat)\n  ensures length(insertAt(list, x, pos)) == length(list) + 1\n{\n}\n", "output": ""}, {"id": "linkedlist_solution_NthCorrect_sketch", "type": "sketch", "program": "// Linked list operations: insert, delete, reverse, cycle detection\n\ndatatype LinkedList<T> = Nil | Cons(head: T, tail: LinkedList<T>)\n\n// Length of linked list\nfunction {:spec} length<T>(list: LinkedList<T>): nat\n{\n  match list\n  case Nil => 0\n  case Cons(_, tail) => 1 + length(tail)\n}\n\n// Append two linked lists\nfunction {:spec} append<T>(l1: LinkedList<T>, l2: LinkedList<T>): LinkedList<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, append(t, l2))\n}\n\n// Reverse a linked list\nfunction {:spec} reverse<T>(list: LinkedList<T>): LinkedList<T>\n{\n  reverseHelper(list, Nil)\n}\n\nfunction reverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>): LinkedList<T>\n{\n  match list\n  case Nil => acc\n  case Cons(h, t) => reverseHelper(t, Cons(h, acc))\n}\n\n// Get nth element (0-indexed)\nfunction {:spec} nth<T>(list: LinkedList<T>, n: nat): T\n  requires n < length(list)\n{\n  match list\n  case Cons(h, t) => if n == 0 then h else nth(t, n - 1)\n}\n\n// Check if element exists in list\npredicate {:spec} contains<T(==)>(list: LinkedList<T>, x: T)\n{\n  match list\n  case Nil => false\n  case Cons(h, t) => h == x || contains(t, x)\n}\n\n// Remove first occurrence of element\nfunction {:spec} remove<T(==)>(list: LinkedList<T>, x: T): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => if h == x then t else Cons(h, remove(t, x))\n}\n\n// Insert at position\nfunction {:spec} insertAt<T>(list: LinkedList<T>, x: T, pos: nat): LinkedList<T>\n{\n  if pos == 0 then Cons(x, list)\n  else match list\n    case Nil => Cons(x, Nil)\n    case Cons(h, t) => Cons(h, insertAt(t, x, pos - 1))\n}\n\n// Convert to sequence\nfunction {:spec} toSeq<T>(list: LinkedList<T>): seq<T>\n{\n  match list\n  case Nil => []\n  case Cons(h, t) => [h] + toSeq(t)\n}\n\n// Convert from sequence\nfunction {:spec} fromSeq<T>(s: seq<T>): LinkedList<T>\n{\n  if |s| == 0 then Nil\n  else Cons(s[0], fromSeq(s[1..]))\n}\n\n// Map function over list\nfunction {:spec} listMap<T, U>(list: LinkedList<T>, f: T -> U): LinkedList<U>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) => Cons(f(h), listMap(t, f))\n}\n\n// Filter list with predicate\nfunction {:spec} filter<T>(list: LinkedList<T>, p: T -> bool): LinkedList<T>\n{\n  match list\n  case Nil => Nil\n  case Cons(h, t) =>\n    if p(h) then Cons(h, filter(t, p))\n    else filter(t, p)\n}\n\n// Take first n elements\nfunction {:spec} take<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n{\n  if n == 0 then Nil\n  else match list\n    case Nil => Nil\n    case Cons(h, t) => Cons(h, take(t, n - 1))\n}\n\n// Drop first n elements\nfunction {:spec} drop<T>(list: LinkedList<T>, n: nat): LinkedList<T>\n  decreases list\n{\n  if n == 0 then list\n  else match list\n    case Nil => Nil\n    case Cons(_, t) => drop(t, n - 1)\n}\n\n// Check if list is palindrome\npredicate {:spec} isPalindrome<T(==)>(list: LinkedList<T>)\n{\n  toSeq(list) == toSeq(reverse(list))\n}\n\n// --- Lemmas for correctness ---\n\nlemma LengthAppend<T>(l1: LinkedList<T>, l2: LinkedList<T>)\n  ensures length(append(l1, l2)) == length(l1) + length(l2)\n{\n}\n\nlemma AppendNil<T>(list: LinkedList<T>)\n  ensures append(list, Nil) == list\n  ensures append(Nil, list) == list\n{\n}\n\nlemma AppendAssociative<T>(l1: LinkedList<T>, l2: LinkedList<T>, l3: LinkedList<T>)\n  ensures append(append(l1, l2), l3) == append(l1, append(l2, l3))\n{\n}\n\nlemma ReverseLength<T>(list: LinkedList<T>)\n  ensures length(reverse(list)) == length(list)\n{\n  ReverseHelperLength(list, Nil);\n}\n\nlemma ReverseHelperLength<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures length(reverseHelper(list, acc)) == length(list) + length(acc)\n{\n}\n\nlemma ReverseReverse<T>(list: LinkedList<T>)\n  ensures reverse(reverse(list)) == list\n{\n  ReverseReverseHelper(list, Nil);\n}\n\nlemma ReverseReverseHelper<T>(list: LinkedList<T>, acc: LinkedList<T>)\n  ensures reverseHelper(reverseHelper(list, acc), Nil) == reverseHelper(acc, list)\n{\n}\n\nlemma ToSeqFromSeq<T>(s: seq<T>)\n  ensures toSeq(fromSeq(s)) == s\n{\n}\n\nlemma FromSeqToSeq<T>(list: LinkedList<T>)\n  ensures fromSeq(toSeq(list)) == list\n{\n}\n\nlemma NthCorrect<T>(list: LinkedList<T>, n: nat)\n  requires n < length(list)\n  ensures |toSeq(list)| > n\n  ensures toSeq(list)[n] == nth(list, n)\n{\n/*[SKETCH HERE]*/\n}\n\nlemma MapLength<T, U>(list: LinkedList<T>, f: T -> U)\n  ensures length(listMap(list, f)) == length(list)\n{\n}\n\nlemma FilterSubset<T>(list: LinkedList<T>, p: T -> bool)\n  ensures length(filter(list, p)) <= length(list)\n{\n}\n\nlemma TakeDropConcat<T>(list: LinkedList<T>, n: nat)\n  ensures append(take(list, n), drop(list, n)) == list\n{\n}\n\nlemma RemoveDecreasesLength<T>(list: LinkedList<T>, x: T)\n  requires contains(list, x)\n  ensures length(remove(list, x)) == length(list) - 1\n{\n}\n\nlemma InsertAtLength<T>(list: LinkedList<T>, x: T, pos: nat)\n  ensures length(insertAt(list, x, pos)) == length(list) + 1\n{\n}\n", "output": "  match list\n  case Cons(h, t) =>\n    if n == 0 {\n    } else {\n    }"}, {"id": "list_sum_solution_sumCorrect_sketch", "type": "sketch", "program": "function sum(xs: seq<int>): int\n{\n  if |xs| == 0 then 0\n  else xs[0] + sum(xs[1..])\n}\n\nfunction sumTail(xs: seq<int>, acc: int): int\n  decreases |xs|\n{\n  if |xs| == 0 then acc\n  else sumTail(xs[1..], acc + xs[0])\n}\n\nlemma sumCorrect(xs: seq<int>)\n  ensures sum(xs) == sumTail(xs, 0)\n{\n/*[SKETCH HERE]*/\n}\n\nlemma sumCorrectHelper(xs: seq<int>, acc: int)\n  ensures sumTail(xs, acc) == acc + sum(xs)\n{\n}\n\nlemma sumAppend(xs: seq<int>, ys: seq<int>)\n  ensures sum(xs + ys) == sum(xs) + sum(ys)\n{\n  if |xs| == 0 {\n    assert xs + ys == ys;\n  } else {\n    assert xs + ys == [xs[0]] + (xs[1..] + ys);\n    calc {\n      sum(xs + ys);\n      == xs[0] + sum((xs[1..] + ys));\n      == { sumAppend(xs[1..], ys); }\n      xs[0] + (sum(xs[1..]) + sum(ys));\n      == (xs[0] + sum(xs[1..])) + sum(ys);\n      == sum(xs) + sum(ys);\n    }\n  }\n}\n\nlemma sumDistributive(xs: seq<int>, c: int)\n  ensures sum(seq(|xs|, i requires 0 <= i < |xs| => c * xs[i])) == c * sum(xs)\n{\n  if |xs| == 0 {\n    // Base case: empty sequence\n  } else {\n    // Inductive case: non-empty sequence\n    var scaled_xs := seq(|xs|, i requires 0 <= i < |xs| => c * xs[i]);\n    assert scaled_xs == [c * xs[0]] + seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i]);\n    \n    calc {\n      sum(scaled_xs);\n      == sum([c * xs[0]] + seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i]));\n      == { sumAppend([c * xs[0]], seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i])); }\n      sum([c * xs[0]]) + sum(seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i]));\n      == c * xs[0] + sum(seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i]));\n      == { sumDistributive(xs[1..], c); }\n      c * xs[0] + c * sum(xs[1..]);\n      == c * (xs[0] + sum(xs[1..]));\n      == c * sum(xs);\n    }\n  }\n}\n", "output": ""}, {"id": "list_sum_solution_sumAppend_sketch", "type": "sketch", "program": "function sum(xs: seq<int>): int\n{\n  if |xs| == 0 then 0\n  else xs[0] + sum(xs[1..])\n}\n\nfunction sumTail(xs: seq<int>, acc: int): int\n  decreases |xs|\n{\n  if |xs| == 0 then acc\n  else sumTail(xs[1..], acc + xs[0])\n}\n\nlemma sumCorrect(xs: seq<int>)\n  ensures sum(xs) == sumTail(xs, 0)\n{\n  sumCorrectHelper(xs, 0);\n}\n\nlemma sumCorrectHelper(xs: seq<int>, acc: int)\n  ensures sumTail(xs, acc) == acc + sum(xs)\n{\n}\n\nlemma sumAppend(xs: seq<int>, ys: seq<int>)\n  ensures sum(xs + ys) == sum(xs) + sum(ys)\n{\n/*[SKETCH HERE]*/\n}\n\nlemma sumDistributive(xs: seq<int>, c: int)\n  ensures sum(seq(|xs|, i requires 0 <= i < |xs| => c * xs[i])) == c * sum(xs)\n{\n  if |xs| == 0 {\n    // Base case: empty sequence\n  } else {\n    // Inductive case: non-empty sequence\n    var scaled_xs := seq(|xs|, i requires 0 <= i < |xs| => c * xs[i]);\n    assert scaled_xs == [c * xs[0]] + seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i]);\n    \n    calc {\n      sum(scaled_xs);\n      == sum([c * xs[0]] + seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i]));\n      == { sumAppend([c * xs[0]], seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i])); }\n      sum([c * xs[0]]) + sum(seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i]));\n      == c * xs[0] + sum(seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i]));\n      == { sumDistributive(xs[1..], c); }\n      c * xs[0] + c * sum(xs[1..]);\n      == c * (xs[0] + sum(xs[1..]));\n      == c * sum(xs);\n    }\n  }\n}\n", "output": "  if |xs| == 0 {\n  } else {\n    calc {\n      sum(xs + ys);\n      == xs[0] + sum((xs[1..] + ys));\n      == { sumAppend(xs[1..], ys); }\n      xs[0] + (sum(xs[1..]) + sum(ys));\n      == (xs[0] + sum(xs[1..])) + sum(ys);\n      == sum(xs) + sum(ys);\n    }\n  }"}, {"id": "list_sum_solution_sumDistributive_sketch", "type": "sketch", "program": "function sum(xs: seq<int>): int\n{\n  if |xs| == 0 then 0\n  else xs[0] + sum(xs[1..])\n}\n\nfunction sumTail(xs: seq<int>, acc: int): int\n  decreases |xs|\n{\n  if |xs| == 0 then acc\n  else sumTail(xs[1..], acc + xs[0])\n}\n\nlemma sumCorrect(xs: seq<int>)\n  ensures sum(xs) == sumTail(xs, 0)\n{\n  sumCorrectHelper(xs, 0);\n}\n\nlemma sumCorrectHelper(xs: seq<int>, acc: int)\n  ensures sumTail(xs, acc) == acc + sum(xs)\n{\n}\n\nlemma sumAppend(xs: seq<int>, ys: seq<int>)\n  ensures sum(xs + ys) == sum(xs) + sum(ys)\n{\n  if |xs| == 0 {\n    assert xs + ys == ys;\n  } else {\n    assert xs + ys == [xs[0]] + (xs[1..] + ys);\n    calc {\n      sum(xs + ys);\n      == xs[0] + sum((xs[1..] + ys));\n      == { sumAppend(xs[1..], ys); }\n      xs[0] + (sum(xs[1..]) + sum(ys));\n      == (xs[0] + sum(xs[1..])) + sum(ys);\n      == sum(xs) + sum(ys);\n    }\n  }\n}\n\nlemma sumDistributive(xs: seq<int>, c: int)\n  ensures sum(seq(|xs|, i requires 0 <= i < |xs| => c * xs[i])) == c * sum(xs)\n{\n/*[SKETCH HERE]*/\n}\n", "output": "  if |xs| == 0 {\n    // Base case: empty sequence\n  } else {\n    // Inductive case: non-empty sequence\n    var scaled_xs := seq(|xs|, i requires 0 <= i < |xs| => c * xs[i]);\n    \n    calc {\n      sum(scaled_xs);\n      == sum([c * xs[0]] + seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i]));\n      == { sumAppend([c * xs[0]], seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i])); }\n      sum([c * xs[0]]) + sum(seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i]));\n      == c * xs[0] + sum(seq(|xs[1..]|, i requires 0 <= i < |xs[1..]| => c * xs[1..][i]));\n      == { sumDistributive(xs[1..], c); }\n      c * xs[0] + c * sum(xs[1..]);\n      == c * (xs[0] + sum(xs[1..]));\n      == c * sum(xs);\n    }\n  }"}, {"id": "math_operations_solution_GcdDividesBoth_sketch", "type": "sketch", "program": "// Mathematical operations: GCD, LCM, primes, modular arithmetic\n\n// Absolute value\nfunction {:spec} abs(x: int): nat\n{\n  if x < 0 then -x else x\n}\n\n// Greatest Common Divisor using Euclidean algorithm\nfunction {:spec} gcd(a: nat, b: nat): nat\n  decreases b\n{\n  if b == 0 then a\n  else gcd(b, a % b)\n}\n\n// Least Common Multiple\nfunction {:spec} lcm(a: nat, b: nat): nat\n  requires a > 0 && b > 0\n{\n  var g := gcd(a, b);\n  assert g > 0 by { GcdPositive(a, b); }\n  a / g * b  // Reordered to avoid overflow and ensure positive\n}\n\n// Check if a number divides another\npredicate {:spec} divides(d: nat, n: nat)\n  requires d > 0\n{\n  n % d == 0\n}\n\n// Check if a number is prime\npredicate {:spec} isPrime(n: nat)\n{\n  n > 1 && forall d :: 2 <= d < n ==> !divides(d, n)\n}\n\n// Check if two numbers are coprime (relatively prime)\npredicate {:spec} coprime(a: nat, b: nat)\n  requires a > 0 && b > 0\n{\n  gcd(a, b) == 1\n}\n\n// Modular exponentiation: (base^exp) mod m\nfunction {:spec} modPow(base: nat, exp: nat, m: nat): nat\n  requires m > 0\n  decreases exp\n{\n  if exp == 0 then 1 % m\n  else if exp % 2 == 0 then\n    var half := modPow(base, exp / 2, m);\n    (half * half) % m\n  else\n    ((base % m) * modPow(base, exp - 1, m)) % m\n}\n\n// Fibonacci function\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// Factorial function\nfunction {:spec} fact(n: nat): nat\n{\n  if n == 0 then 1\n  else n * fact(n - 1)\n}\n\n// Binomial coefficient (n choose k)\nfunction {:spec} binomial(n: nat, k: nat): nat\n  requires k <= n\n{\n  var denominator := fact(k) * fact(n - k);\n  if denominator == 0 then 0  // Can't happen but helps verifier\n  else fact(n) / denominator\n}\n\n// Sum of first n natural numbers\nfunction {:spec} sumToN(n: nat): nat\n{\n  if n == 0 then 0\n  else n + sumToN(n - 1)\n}\n\n// Check if a number is perfect (sum of divisors equals the number)\npredicate {:spec} isPerfect(n: nat)\n  requires n > 0\n{\n  sumOfDivisors(n) == 2 * n  // Including n itself\n}\n\nfunction {:spec} sumOfDivisors(n: nat): nat\n  requires n > 0\n{\n  sumOfDivisorsHelper(n, n)\n}\n\nfunction sumOfDivisorsHelper(n: nat, d: nat): nat\n  requires n > 0\n  requires d > 0\n  decreases d\n{\n  if d == 1 then 1\n  else if divides(d, n) then d + sumOfDivisorsHelper(n, d - 1)\n  else sumOfDivisorsHelper(n, d - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma GcdZero(a: nat)\n  ensures gcd(a, 0) == a\n{\n}\n\nlemma GcdPositive(a: nat, b: nat)\n  requires a > 0 || b > 0\n  ensures gcd(a, b) > 0\n  decreases b\n{\n}\n\nlemma GcdDividesBoth(a: nat, b: nat)\n  requires a > 0 && b > 0\n  ensures gcd(a, b) > 0\n{\n/*[SKETCH HERE]*/\n}\n\nlemma PrimeHasOnlyTwoDivisors(n: nat)\n  requires isPrime(n)\n  ensures divides(1, n) && divides(n, n)\n  ensures forall d: nat :: d > 0 && d < n && d != 1 ==> !divides(d, n)\n{\n}\n\nlemma TwoPrime()\n  ensures isPrime(2)\n{\n}\n\nlemma ThreePrime()\n  ensures isPrime(3)\n{\n}\n\nfunction Power(base: nat, exp: nat): nat\n  decreases exp\n{\n  if exp == 0 then 1\n  else base * Power(base, exp - 1)\n}\n\nlemma PowerSquare(base: nat)\n  ensures Power(base, 2) == base * base\n{\n}\n\nlemma PowerAddition(base: nat, exp1: nat, exp2: nat)\n  ensures Power(base, exp1 + exp2) == Power(base, exp1) * Power(base, exp2)\n  decreases exp1\n{\n  if exp1 == 0 {\n  } else {\n    PowerAddition(base, exp1 - 1, exp2);\n  }\n}\n\nlemma SumFormula(n: nat)\n  ensures sumToN(n) == n * (n + 1) / 2\n{\n}\n\nlemma FactorialPositive(n: nat)\n  ensures fact(n) > 0\n{\n}\n\nlemma FibonacciMonotonic(n: nat)\n  requires n > 0\n  ensures fib(n) <= fib(n + 1)\n{\n}\n\nlemma BinomialSymmetry(n: nat, k: nat)\n  requires k <= n\n  ensures binomial(n, k) == binomial(n, n - k)\n{\n}\n", "output": ""}, {"id": "math_operations_solution_PowerAddition_sketch", "type": "sketch", "program": "// Mathematical operations: GCD, LCM, primes, modular arithmetic\n\n// Absolute value\nfunction {:spec} abs(x: int): nat\n{\n  if x < 0 then -x else x\n}\n\n// Greatest Common Divisor using Euclidean algorithm\nfunction {:spec} gcd(a: nat, b: nat): nat\n  decreases b\n{\n  if b == 0 then a\n  else gcd(b, a % b)\n}\n\n// Least Common Multiple\nfunction {:spec} lcm(a: nat, b: nat): nat\n  requires a > 0 && b > 0\n{\n  var g := gcd(a, b);\n  assert g > 0 by { GcdPositive(a, b); }\n  a / g * b  // Reordered to avoid overflow and ensure positive\n}\n\n// Check if a number divides another\npredicate {:spec} divides(d: nat, n: nat)\n  requires d > 0\n{\n  n % d == 0\n}\n\n// Check if a number is prime\npredicate {:spec} isPrime(n: nat)\n{\n  n > 1 && forall d :: 2 <= d < n ==> !divides(d, n)\n}\n\n// Check if two numbers are coprime (relatively prime)\npredicate {:spec} coprime(a: nat, b: nat)\n  requires a > 0 && b > 0\n{\n  gcd(a, b) == 1\n}\n\n// Modular exponentiation: (base^exp) mod m\nfunction {:spec} modPow(base: nat, exp: nat, m: nat): nat\n  requires m > 0\n  decreases exp\n{\n  if exp == 0 then 1 % m\n  else if exp % 2 == 0 then\n    var half := modPow(base, exp / 2, m);\n    (half * half) % m\n  else\n    ((base % m) * modPow(base, exp - 1, m)) % m\n}\n\n// Fibonacci function\nfunction {:spec} fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else fib(n - 1) + fib(n - 2)\n}\n\n// Factorial function\nfunction {:spec} fact(n: nat): nat\n{\n  if n == 0 then 1\n  else n * fact(n - 1)\n}\n\n// Binomial coefficient (n choose k)\nfunction {:spec} binomial(n: nat, k: nat): nat\n  requires k <= n\n{\n  var denominator := fact(k) * fact(n - k);\n  if denominator == 0 then 0  // Can't happen but helps verifier\n  else fact(n) / denominator\n}\n\n// Sum of first n natural numbers\nfunction {:spec} sumToN(n: nat): nat\n{\n  if n == 0 then 0\n  else n + sumToN(n - 1)\n}\n\n// Check if a number is perfect (sum of divisors equals the number)\npredicate {:spec} isPerfect(n: nat)\n  requires n > 0\n{\n  sumOfDivisors(n) == 2 * n  // Including n itself\n}\n\nfunction {:spec} sumOfDivisors(n: nat): nat\n  requires n > 0\n{\n  sumOfDivisorsHelper(n, n)\n}\n\nfunction sumOfDivisorsHelper(n: nat, d: nat): nat\n  requires n > 0\n  requires d > 0\n  decreases d\n{\n  if d == 1 then 1\n  else if divides(d, n) then d + sumOfDivisorsHelper(n, d - 1)\n  else sumOfDivisorsHelper(n, d - 1)\n}\n\n// --- Lemmas for correctness ---\n\nlemma GcdZero(a: nat)\n  ensures gcd(a, 0) == a\n{\n}\n\nlemma GcdPositive(a: nat, b: nat)\n  requires a > 0 || b > 0\n  ensures gcd(a, b) > 0\n  decreases b\n{\n}\n\nlemma GcdDividesBoth(a: nat, b: nat)\n  requires a > 0 && b > 0\n  ensures gcd(a, b) > 0\n{\n  GcdPositive(a, b);\n}\n\nlemma PrimeHasOnlyTwoDivisors(n: nat)\n  requires isPrime(n)\n  ensures divides(1, n) && divides(n, n)\n  ensures forall d: nat :: d > 0 && d < n && d != 1 ==> !divides(d, n)\n{\n}\n\nlemma TwoPrime()\n  ensures isPrime(2)\n{\n}\n\nlemma ThreePrime()\n  ensures isPrime(3)\n{\n}\n\nfunction Power(base: nat, exp: nat): nat\n  decreases exp\n{\n  if exp == 0 then 1\n  else base * Power(base, exp - 1)\n}\n\nlemma PowerSquare(base: nat)\n  ensures Power(base, 2) == base * base\n{\n}\n\nlemma PowerAddition(base: nat, exp1: nat, exp2: nat)\n  ensures Power(base, exp1 + exp2) == Power(base, exp1) * Power(base, exp2)\n  decreases exp1\n{\n/*[SKETCH HERE]*/\n}\n\nlemma SumFormula(n: nat)\n  ensures sumToN(n) == n * (n + 1) / 2\n{\n}\n\nlemma FactorialPositive(n: nat)\n  ensures fact(n) > 0\n{\n}\n\nlemma FibonacciMonotonic(n: nat)\n  requires n > 0\n  ensures fib(n) <= fib(n + 1)\n{\n}\n\nlemma BinomialSymmetry(n: nat, k: nat)\n  requires k <= n\n  ensures binomial(n, k) == binomial(n, n - k)\n{\n}\n", "output": "  if exp1 == 0 {\n  } else {\n  }"}, {"id": "max_solution_maxIsCorrect_sketch", "type": "sketch", "program": "// Finding maximum element in a sequence\n\npredicate {:spec} isMax(s: seq<int>, m: int)\n{\n  m in s && forall x :: x in s ==> x <= m\n}\n\nfunction max(s: seq<int>): int\n  requires |s| > 0\n{\n  if |s| == 1 then s[0]\n  else \n    var restMax := max(s[1..]);\n    if s[0] >= restMax then s[0] else restMax\n}\n\nlemma maxIsCorrect(s: seq<int>)\n  requires |s| > 0\n  ensures isMax(s, max(s))\n{\n/*[SKETCH HERE]*/\n}\n", "output": "  if |s| == 1 {\n    // Base case is trivial\n  } else {\n    var restMax := max(s[1..]);\n    // We know isMax(s[1..], restMax)\n    // So restMax in s[1..] and forall x in s[1..] :: x <= restMax\n    \n    if s[0] >= restMax {\n      // max returns s[0]\n      // Need to show: s[0] in s (trivial) and forall x in s :: x <= s[0]\n      forall x | x in s\n        ensures x <= s[0]\n      {\n        if x == s[0] {\n          // x <= s[0] trivially\n        } else {\n          // x must be in s[1..]\n          // From induction hypothesis: x <= restMax\n          // We know s[0] >= restMax\n          // Therefore x <= s[0]\n        }\n      }\n    } else {\n      // max returns restMax\n      // Need to show: restMax in s and forall x in s :: x <= restMax\n      \n      forall x | x in s\n        ensures x <= restMax\n      {\n        if x == s[0] {\n          // We know s[0] < restMax\n        } else {\n          // x must be in s[1..]\n          // From induction hypothesis: x <= restMax\n        }\n      }\n    }\n  }"}, {"id": "optopt_solution_optimizeOptimal_sketch", "type": "sketch", "program": "datatype Expr =\n  | Const(value: int)\n  | Var(name: string)\n  | Add(left: Expr, right: Expr)\n\npredicate {:spec} optimal(e: Expr)\n{\n  match e\n  case Add(Const(0), _) => false\n  case Add(_, Const(0)) => false\n  case Add(e1, e2) => optimal(e1) && optimal(e2)\n  case _ => true\n}\n\nfunction optimize(e: Expr): Expr\n{\n  match e {\n  case Add(e1, e2) =>\n    match (optimize(e1), optimize(e2)) {\n    case (Const(0), oe2) => oe2\n    case (oe1, Const(0)) => oe1\n    case (oe1, oe2) => Add(oe1, oe2)\n    }\n  case _ => e\n  }\n}\n\nlemma optimizeOptimal(e: Expr)\nensures optimal(optimize(e))\n{\n/*[SKETCH HERE]*/\n}\n", "output": "  // Structural induction on e\n  match e {\n      case Const(value) => {\n      }\n      case Var(name) => {\n      }\n      case Add(left, right) => {\n      }\n  }"}, {"id": "palindrome_solution_reverseAppend_sketch", "type": "sketch", "program": "datatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction reverse<T>(xs: List<T>): List<T>\n{\n  match xs\n  case Nil => Nil\n  case Cons(h, t) => append(reverse(t), Cons(h, Nil))\n}\n\nfunction append<T>(xs: List<T>, ys: List<T>): List<T>\n{\n  match xs\n  case Nil => ys\n  case Cons(h, t) => Cons(h, append(t, ys))\n}\n\npredicate {:spec} isPalindrome<T(==)>(xs: List<T>)\n{\n  xs == reverse(xs)\n}\n\nfunction makePalindrome<T>(xs: List<T>): List<T>\n{\n  append(xs, reverse(xs))\n}\n\nlemma appendNilRight<T>(xs: List<T>)\n  ensures append(xs, Nil) == xs\n{\n}\n\nlemma appendAssoc<T>(xs: List<T>, ys: List<T>, zs: List<T>)\n  ensures append(append(xs, ys), zs) == append(xs, append(ys, zs))\n{\n}\n\nlemma reverseAppend<T>(xs: List<T>, ys: List<T>)\n  ensures reverse(append(xs, ys)) == append(reverse(ys), reverse(xs))\n{\n/*[SKETCH HERE]*/\n}\n\nlemma reverseReverse<T>(xs: List<T>)\n  ensures reverse(reverse(xs)) == xs\n{\n  match xs\n  case Nil =>\n  case Cons(h, t) =>\n    reverseAppend(reverse(t), Cons(h, Nil));\n}\n\nlemma makePalindromeCorrect<T>(xs: List<T>)\n  ensures isPalindrome(makePalindrome(xs))\n{\n  calc == {\n    reverse(makePalindrome(xs));\n    reverse(append(xs, reverse(xs)));\n    { reverseAppend(xs, reverse(xs)); }\n    append(reverse(reverse(xs)), reverse(xs));\n    { reverseReverse(xs); }\n    append(xs, reverse(xs));\n    makePalindrome(xs);\n  }\n}\n", "output": "  match xs\n  case Nil => \n  case Cons(h, t) =>"}, {"id": "palindrome_solution_reverseReverse_sketch", "type": "sketch", "program": "datatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction reverse<T>(xs: List<T>): List<T>\n{\n  match xs\n  case Nil => Nil\n  case Cons(h, t) => append(reverse(t), Cons(h, Nil))\n}\n\nfunction append<T>(xs: List<T>, ys: List<T>): List<T>\n{\n  match xs\n  case Nil => ys\n  case Cons(h, t) => Cons(h, append(t, ys))\n}\n\npredicate {:spec} isPalindrome<T(==)>(xs: List<T>)\n{\n  xs == reverse(xs)\n}\n\nfunction makePalindrome<T>(xs: List<T>): List<T>\n{\n  append(xs, reverse(xs))\n}\n\nlemma appendNilRight<T>(xs: List<T>)\n  ensures append(xs, Nil) == xs\n{\n}\n\nlemma appendAssoc<T>(xs: List<T>, ys: List<T>, zs: List<T>)\n  ensures append(append(xs, ys), zs) == append(xs, append(ys, zs))\n{\n}\n\nlemma reverseAppend<T>(xs: List<T>, ys: List<T>)\n  ensures reverse(append(xs, ys)) == append(reverse(ys), reverse(xs))\n{\n  match xs\n  case Nil => \n    appendNilRight(reverse(ys));\n  case Cons(h, t) =>\n    appendAssoc(reverse(ys), reverse(t), Cons(h, Nil));\n}\n\nlemma reverseReverse<T>(xs: List<T>)\n  ensures reverse(reverse(xs)) == xs\n{\n/*[SKETCH HERE]*/\n}\n\nlemma makePalindromeCorrect<T>(xs: List<T>)\n  ensures isPalindrome(makePalindrome(xs))\n{\n  calc == {\n    reverse(makePalindrome(xs));\n    reverse(append(xs, reverse(xs)));\n    { reverseAppend(xs, reverse(xs)); }\n    append(reverse(reverse(xs)), reverse(xs));\n    { reverseReverse(xs); }\n    append(xs, reverse(xs));\n    makePalindrome(xs);\n  }\n}\n", "output": "  match xs\n  case Nil =>\n  case Cons(h, t) =>"}, {"id": "partition_solution_partitionCorrect_sketch", "type": "sketch", "program": "function partition(s: seq<int>): (seq<int>, seq<int>)\n{\n  if |s| == 0 then ([], [])\n  else\n    var (evens, odds) := partition(s[1..]);\n    if isEven(s[0]) then ([s[0]] + evens, odds)\n    else (evens, [s[0]] + odds)\n}\n\npredicate {:spec} isEven(n: int)\n{\n  n % 2 == 0\n}\n\nlemma partitionCorrect(s: seq<int>)\n  ensures var (evens, odds) := partition(s);\n    (forall x :: x in evens ==> isEven(x)) &&\n    (forall x :: x in odds ==> !isEven(x)) &&\n    |evens| + |odds| == |s| &&\n    multiset(evens + odds) == multiset(s)\n{\n/*[SKETCH HERE]*/\n}\n", "output": "  if |s| == 0 {\n  } else {\n    var (evens, odds) := partition(s);\n    var (evens', odds') := partition(s[1..]);\n    \n    if isEven(s[0]) {\n    } else {\n    }\n  }"}, {"id": "queue_operations_solution_ReverseReverse_sketch", "type": "sketch", "program": "// Queue operations: enqueue, dequeue, isEmpty, size\n\ndatatype Queue<T> = Queue(front: seq<T>, rear: seq<T>)\n\nfunction {:spec} queueEmpty<T>(): Queue<T>\n{\n  Queue([], [])\n}\n\npredicate {:spec} queueIsEmpty<T>(q: Queue<T>)\n{\n  q.front == [] && q.rear == []\n}\n\nfunction {:spec} enqueue<T>(q: Queue<T>, x: T): Queue<T>\n{\n  Queue(q.front, [x] + q.rear)\n}\n\nfunction {:spec} dequeue<T>(q: Queue<T>): Queue<T>\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    Queue(q.front[1..], q.rear)\n  else\n    // Front is empty, so we reverse rear and put it in front\n    if |q.rear| == 1 then\n      Queue([], [])\n    else\n      Queue(reverse(q.rear)[1..], [])\n}\n\nfunction {:spec} queueFront<T>(q: Queue<T>): T\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    q.front[0]\n  else\n    // Front is empty, so the front element is the first element of rear (when reversed)\n    q.rear[|q.rear| - 1]\n}\n\nfunction {:spec} queueSize<T>(q: Queue<T>): nat\n{\n  |q.front| + |q.rear|\n}\n\nfunction {:spec} queueToSeq<T>(q: Queue<T>): seq<T>\n{\n  q.front + reverse(q.rear)\n}\n\nfunction reverse<T>(s: seq<T>): seq<T>\n{\n  if |s| == 0 then []\n  else reverse(s[1..]) + [s[0]]\n}\n\n// Alternative queue representation with invariant\ndatatype SimpleQueue<T> = SimpleQueue(elements: seq<T>)\n\nfunction {:spec} simpleQueueEmpty<T>(): SimpleQueue<T>\n{\n  SimpleQueue([])\n}\n\npredicate {:spec} simpleQueueIsEmpty<T>(q: SimpleQueue<T>)\n{\n  q.elements == []\n}\n\nfunction {:spec} simpleEnqueue<T>(q: SimpleQueue<T>, x: T): SimpleQueue<T>\n{\n  SimpleQueue(q.elements + [x])\n}\n\nfunction {:spec} simpleDequeue<T>(q: SimpleQueue<T>): SimpleQueue<T>\n  requires !simpleQueueIsEmpty(q)\n{\n  SimpleQueue(q.elements[1..])\n}\n\nfunction {:spec} simpleQueueFront<T>(q: SimpleQueue<T>): T\n  requires !simpleQueueIsEmpty(q)\n{\n  q.elements[0]\n}\n\nfunction {:spec} simpleQueueSize<T>(q: SimpleQueue<T>): nat\n{\n  |q.elements|\n}\n\nlemma ReverseLength<T>(s: seq<T>)\n  ensures |reverse(s)| == |s|\n{\n}\n\nlemma ReverseReverse<T>(s: seq<T>)\n  ensures reverse(reverse(s)) == s\n{\n/*[SKETCH HERE]*/\n}\n\nlemma ReverseAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n  } else {\n    assert s1 + s2 == [s1[0]] + (s1[1..] + s2);\n  }\n}\n\nlemma ReverseFirst<T>(s: seq<T>)\n  requires |s| > 0\n  ensures |reverse(s)| == |s|\n  ensures reverse(s)[|reverse(s)| - 1] == s[0]\n  ensures reverse(s)[0] == s[|s| - 1]\n{\n}\n\nlemma SeqAssoc<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures a + (b + c) == (a + b) + c\n{\n}\n\nlemma QueueSizeProperty<T>(q: Queue<T>)\n  ensures queueSize(q) == |queueToSeq(q)|\n{\n  ReverseLength(q.rear);\n}\n\nlemma EnqueueCorrect<T>(q: Queue<T>, x: T)\n  ensures queueToSeq(enqueue(q, x)) == queueToSeq(q) + [x]\n  ensures queueSize(enqueue(q, x)) == queueSize(q) + 1\n{\n}\n\nlemma DequeueCorrect<T>(q: Queue<T>)\n  requires !queueIsEmpty(q)\n  ensures |queueToSeq(q)| > 0\n  ensures queueToSeq(dequeue(q)) == queueToSeq(q)[1..]\n  ensures queueFront(q) == queueToSeq(q)[0]\n{\n  if |q.front| > 0 {\n  } else {\n    var rev := reverse(q.rear);\n\n    ReverseFirst(q.rear);\n\n    if |q.rear| == 1 {\n    } else {\n    }\n  }\n}\n\nlemma SimpleQueueEquivalence<T>(sq: SimpleQueue<T>, q: Queue<T>)\n  requires sq.elements == queueToSeq(q)\n  ensures simpleQueueIsEmpty(sq) == queueIsEmpty(q)\n  ensures simpleQueueSize(sq) == queueSize(q)\n{\n  if queueIsEmpty(q) {\n  }\n  QueueSizeProperty(q);\n}\n", "output": "  if |s| == 0 {\n    // Base case\n  } else {\n  }"}, {"id": "queue_operations_solution_ReverseAppend_sketch", "type": "sketch", "program": "// Queue operations: enqueue, dequeue, isEmpty, size\n\ndatatype Queue<T> = Queue(front: seq<T>, rear: seq<T>)\n\nfunction {:spec} queueEmpty<T>(): Queue<T>\n{\n  Queue([], [])\n}\n\npredicate {:spec} queueIsEmpty<T>(q: Queue<T>)\n{\n  q.front == [] && q.rear == []\n}\n\nfunction {:spec} enqueue<T>(q: Queue<T>, x: T): Queue<T>\n{\n  Queue(q.front, [x] + q.rear)\n}\n\nfunction {:spec} dequeue<T>(q: Queue<T>): Queue<T>\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    Queue(q.front[1..], q.rear)\n  else\n    // Front is empty, so we reverse rear and put it in front\n    if |q.rear| == 1 then\n      Queue([], [])\n    else\n      Queue(reverse(q.rear)[1..], [])\n}\n\nfunction {:spec} queueFront<T>(q: Queue<T>): T\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    q.front[0]\n  else\n    // Front is empty, so the front element is the first element of rear (when reversed)\n    q.rear[|q.rear| - 1]\n}\n\nfunction {:spec} queueSize<T>(q: Queue<T>): nat\n{\n  |q.front| + |q.rear|\n}\n\nfunction {:spec} queueToSeq<T>(q: Queue<T>): seq<T>\n{\n  q.front + reverse(q.rear)\n}\n\nfunction reverse<T>(s: seq<T>): seq<T>\n{\n  if |s| == 0 then []\n  else reverse(s[1..]) + [s[0]]\n}\n\n// Alternative queue representation with invariant\ndatatype SimpleQueue<T> = SimpleQueue(elements: seq<T>)\n\nfunction {:spec} simpleQueueEmpty<T>(): SimpleQueue<T>\n{\n  SimpleQueue([])\n}\n\npredicate {:spec} simpleQueueIsEmpty<T>(q: SimpleQueue<T>)\n{\n  q.elements == []\n}\n\nfunction {:spec} simpleEnqueue<T>(q: SimpleQueue<T>, x: T): SimpleQueue<T>\n{\n  SimpleQueue(q.elements + [x])\n}\n\nfunction {:spec} simpleDequeue<T>(q: SimpleQueue<T>): SimpleQueue<T>\n  requires !simpleQueueIsEmpty(q)\n{\n  SimpleQueue(q.elements[1..])\n}\n\nfunction {:spec} simpleQueueFront<T>(q: SimpleQueue<T>): T\n  requires !simpleQueueIsEmpty(q)\n{\n  q.elements[0]\n}\n\nfunction {:spec} simpleQueueSize<T>(q: SimpleQueue<T>): nat\n{\n  |q.elements|\n}\n\nlemma ReverseLength<T>(s: seq<T>)\n  ensures |reverse(s)| == |s|\n{\n}\n\nlemma ReverseReverse<T>(s: seq<T>)\n  ensures reverse(reverse(s)) == s\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseAppend(reverse(s[1..]), [s[0]]);\n  }\n}\n\nlemma ReverseAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n/*[SKETCH HERE]*/\n}\n\nlemma ReverseFirst<T>(s: seq<T>)\n  requires |s| > 0\n  ensures |reverse(s)| == |s|\n  ensures reverse(s)[|reverse(s)| - 1] == s[0]\n  ensures reverse(s)[0] == s[|s| - 1]\n{\n}\n\nlemma SeqAssoc<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures a + (b + c) == (a + b) + c\n{\n}\n\nlemma QueueSizeProperty<T>(q: Queue<T>)\n  ensures queueSize(q) == |queueToSeq(q)|\n{\n  ReverseLength(q.rear);\n}\n\nlemma EnqueueCorrect<T>(q: Queue<T>, x: T)\n  ensures queueToSeq(enqueue(q, x)) == queueToSeq(q) + [x]\n  ensures queueSize(enqueue(q, x)) == queueSize(q) + 1\n{\n}\n\nlemma DequeueCorrect<T>(q: Queue<T>)\n  requires !queueIsEmpty(q)\n  ensures |queueToSeq(q)| > 0\n  ensures queueToSeq(dequeue(q)) == queueToSeq(q)[1..]\n  ensures queueFront(q) == queueToSeq(q)[0]\n{\n  if |q.front| > 0 {\n  } else {\n    var rev := reverse(q.rear);\n\n    ReverseFirst(q.rear);\n\n    if |q.rear| == 1 {\n    } else {\n    }\n  }\n}\n\nlemma SimpleQueueEquivalence<T>(sq: SimpleQueue<T>, q: Queue<T>)\n  requires sq.elements == queueToSeq(q)\n  ensures simpleQueueIsEmpty(sq) == queueIsEmpty(q)\n  ensures simpleQueueSize(sq) == queueSize(q)\n{\n  if queueIsEmpty(q) {\n  }\n  QueueSizeProperty(q);\n}\n", "output": "  if |s1| == 0 {\n  } else {\n  }"}, {"id": "queue_operations_solution_QueueSizeProperty_sketch", "type": "sketch", "program": "// Queue operations: enqueue, dequeue, isEmpty, size\n\ndatatype Queue<T> = Queue(front: seq<T>, rear: seq<T>)\n\nfunction {:spec} queueEmpty<T>(): Queue<T>\n{\n  Queue([], [])\n}\n\npredicate {:spec} queueIsEmpty<T>(q: Queue<T>)\n{\n  q.front == [] && q.rear == []\n}\n\nfunction {:spec} enqueue<T>(q: Queue<T>, x: T): Queue<T>\n{\n  Queue(q.front, [x] + q.rear)\n}\n\nfunction {:spec} dequeue<T>(q: Queue<T>): Queue<T>\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    Queue(q.front[1..], q.rear)\n  else\n    // Front is empty, so we reverse rear and put it in front\n    if |q.rear| == 1 then\n      Queue([], [])\n    else\n      Queue(reverse(q.rear)[1..], [])\n}\n\nfunction {:spec} queueFront<T>(q: Queue<T>): T\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    q.front[0]\n  else\n    // Front is empty, so the front element is the first element of rear (when reversed)\n    q.rear[|q.rear| - 1]\n}\n\nfunction {:spec} queueSize<T>(q: Queue<T>): nat\n{\n  |q.front| + |q.rear|\n}\n\nfunction {:spec} queueToSeq<T>(q: Queue<T>): seq<T>\n{\n  q.front + reverse(q.rear)\n}\n\nfunction reverse<T>(s: seq<T>): seq<T>\n{\n  if |s| == 0 then []\n  else reverse(s[1..]) + [s[0]]\n}\n\n// Alternative queue representation with invariant\ndatatype SimpleQueue<T> = SimpleQueue(elements: seq<T>)\n\nfunction {:spec} simpleQueueEmpty<T>(): SimpleQueue<T>\n{\n  SimpleQueue([])\n}\n\npredicate {:spec} simpleQueueIsEmpty<T>(q: SimpleQueue<T>)\n{\n  q.elements == []\n}\n\nfunction {:spec} simpleEnqueue<T>(q: SimpleQueue<T>, x: T): SimpleQueue<T>\n{\n  SimpleQueue(q.elements + [x])\n}\n\nfunction {:spec} simpleDequeue<T>(q: SimpleQueue<T>): SimpleQueue<T>\n  requires !simpleQueueIsEmpty(q)\n{\n  SimpleQueue(q.elements[1..])\n}\n\nfunction {:spec} simpleQueueFront<T>(q: SimpleQueue<T>): T\n  requires !simpleQueueIsEmpty(q)\n{\n  q.elements[0]\n}\n\nfunction {:spec} simpleQueueSize<T>(q: SimpleQueue<T>): nat\n{\n  |q.elements|\n}\n\nlemma ReverseLength<T>(s: seq<T>)\n  ensures |reverse(s)| == |s|\n{\n}\n\nlemma ReverseReverse<T>(s: seq<T>)\n  ensures reverse(reverse(s)) == s\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseAppend(reverse(s[1..]), [s[0]]);\n  }\n}\n\nlemma ReverseAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n  } else {\n    assert s1 + s2 == [s1[0]] + (s1[1..] + s2);\n  }\n}\n\nlemma ReverseFirst<T>(s: seq<T>)\n  requires |s| > 0\n  ensures |reverse(s)| == |s|\n  ensures reverse(s)[|reverse(s)| - 1] == s[0]\n  ensures reverse(s)[0] == s[|s| - 1]\n{\n}\n\nlemma SeqAssoc<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures a + (b + c) == (a + b) + c\n{\n}\n\nlemma QueueSizeProperty<T>(q: Queue<T>)\n  ensures queueSize(q) == |queueToSeq(q)|\n{\n/*[SKETCH HERE]*/\n}\n\nlemma EnqueueCorrect<T>(q: Queue<T>, x: T)\n  ensures queueToSeq(enqueue(q, x)) == queueToSeq(q) + [x]\n  ensures queueSize(enqueue(q, x)) == queueSize(q) + 1\n{\n}\n\nlemma DequeueCorrect<T>(q: Queue<T>)\n  requires !queueIsEmpty(q)\n  ensures |queueToSeq(q)| > 0\n  ensures queueToSeq(dequeue(q)) == queueToSeq(q)[1..]\n  ensures queueFront(q) == queueToSeq(q)[0]\n{\n  if |q.front| > 0 {\n  } else {\n    var rev := reverse(q.rear);\n\n    ReverseFirst(q.rear);\n\n    if |q.rear| == 1 {\n    } else {\n    }\n  }\n}\n\nlemma SimpleQueueEquivalence<T>(sq: SimpleQueue<T>, q: Queue<T>)\n  requires sq.elements == queueToSeq(q)\n  ensures simpleQueueIsEmpty(sq) == queueIsEmpty(q)\n  ensures simpleQueueSize(sq) == queueSize(q)\n{\n  if queueIsEmpty(q) {\n  }\n  QueueSizeProperty(q);\n}\n", "output": ""}, {"id": "queue_operations_solution_DequeueCorrect_sketch", "type": "sketch", "program": "// Queue operations: enqueue, dequeue, isEmpty, size\n\ndatatype Queue<T> = Queue(front: seq<T>, rear: seq<T>)\n\nfunction {:spec} queueEmpty<T>(): Queue<T>\n{\n  Queue([], [])\n}\n\npredicate {:spec} queueIsEmpty<T>(q: Queue<T>)\n{\n  q.front == [] && q.rear == []\n}\n\nfunction {:spec} enqueue<T>(q: Queue<T>, x: T): Queue<T>\n{\n  Queue(q.front, [x] + q.rear)\n}\n\nfunction {:spec} dequeue<T>(q: Queue<T>): Queue<T>\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    Queue(q.front[1..], q.rear)\n  else\n    // Front is empty, so we reverse rear and put it in front\n    if |q.rear| == 1 then\n      Queue([], [])\n    else\n      Queue(reverse(q.rear)[1..], [])\n}\n\nfunction {:spec} queueFront<T>(q: Queue<T>): T\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    q.front[0]\n  else\n    // Front is empty, so the front element is the first element of rear (when reversed)\n    q.rear[|q.rear| - 1]\n}\n\nfunction {:spec} queueSize<T>(q: Queue<T>): nat\n{\n  |q.front| + |q.rear|\n}\n\nfunction {:spec} queueToSeq<T>(q: Queue<T>): seq<T>\n{\n  q.front + reverse(q.rear)\n}\n\nfunction reverse<T>(s: seq<T>): seq<T>\n{\n  if |s| == 0 then []\n  else reverse(s[1..]) + [s[0]]\n}\n\n// Alternative queue representation with invariant\ndatatype SimpleQueue<T> = SimpleQueue(elements: seq<T>)\n\nfunction {:spec} simpleQueueEmpty<T>(): SimpleQueue<T>\n{\n  SimpleQueue([])\n}\n\npredicate {:spec} simpleQueueIsEmpty<T>(q: SimpleQueue<T>)\n{\n  q.elements == []\n}\n\nfunction {:spec} simpleEnqueue<T>(q: SimpleQueue<T>, x: T): SimpleQueue<T>\n{\n  SimpleQueue(q.elements + [x])\n}\n\nfunction {:spec} simpleDequeue<T>(q: SimpleQueue<T>): SimpleQueue<T>\n  requires !simpleQueueIsEmpty(q)\n{\n  SimpleQueue(q.elements[1..])\n}\n\nfunction {:spec} simpleQueueFront<T>(q: SimpleQueue<T>): T\n  requires !simpleQueueIsEmpty(q)\n{\n  q.elements[0]\n}\n\nfunction {:spec} simpleQueueSize<T>(q: SimpleQueue<T>): nat\n{\n  |q.elements|\n}\n\nlemma ReverseLength<T>(s: seq<T>)\n  ensures |reverse(s)| == |s|\n{\n}\n\nlemma ReverseReverse<T>(s: seq<T>)\n  ensures reverse(reverse(s)) == s\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseAppend(reverse(s[1..]), [s[0]]);\n  }\n}\n\nlemma ReverseAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n  } else {\n    assert s1 + s2 == [s1[0]] + (s1[1..] + s2);\n  }\n}\n\nlemma ReverseFirst<T>(s: seq<T>)\n  requires |s| > 0\n  ensures |reverse(s)| == |s|\n  ensures reverse(s)[|reverse(s)| - 1] == s[0]\n  ensures reverse(s)[0] == s[|s| - 1]\n{\n}\n\nlemma SeqAssoc<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures a + (b + c) == (a + b) + c\n{\n}\n\nlemma QueueSizeProperty<T>(q: Queue<T>)\n  ensures queueSize(q) == |queueToSeq(q)|\n{\n  ReverseLength(q.rear);\n}\n\nlemma EnqueueCorrect<T>(q: Queue<T>, x: T)\n  ensures queueToSeq(enqueue(q, x)) == queueToSeq(q) + [x]\n  ensures queueSize(enqueue(q, x)) == queueSize(q) + 1\n{\n}\n\nlemma DequeueCorrect<T>(q: Queue<T>)\n  requires !queueIsEmpty(q)\n  ensures |queueToSeq(q)| > 0\n  ensures queueToSeq(dequeue(q)) == queueToSeq(q)[1..]\n  ensures queueFront(q) == queueToSeq(q)[0]\n{\n/*[SKETCH HERE]*/\n}\n\nlemma SimpleQueueEquivalence<T>(sq: SimpleQueue<T>, q: Queue<T>)\n  requires sq.elements == queueToSeq(q)\n  ensures simpleQueueIsEmpty(sq) == queueIsEmpty(q)\n  ensures simpleQueueSize(sq) == queueSize(q)\n{\n  if queueIsEmpty(q) {\n  }\n  QueueSizeProperty(q);\n}\n", "output": "  if |q.front| > 0 {\n  } else {\n    var rev := reverse(q.rear);\n\n\n    if |q.rear| == 1 {\n    } else {\n    }\n  }"}, {"id": "queue_operations_solution_SimpleQueueEquivalence_sketch", "type": "sketch", "program": "// Queue operations: enqueue, dequeue, isEmpty, size\n\ndatatype Queue<T> = Queue(front: seq<T>, rear: seq<T>)\n\nfunction {:spec} queueEmpty<T>(): Queue<T>\n{\n  Queue([], [])\n}\n\npredicate {:spec} queueIsEmpty<T>(q: Queue<T>)\n{\n  q.front == [] && q.rear == []\n}\n\nfunction {:spec} enqueue<T>(q: Queue<T>, x: T): Queue<T>\n{\n  Queue(q.front, [x] + q.rear)\n}\n\nfunction {:spec} dequeue<T>(q: Queue<T>): Queue<T>\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    Queue(q.front[1..], q.rear)\n  else\n    // Front is empty, so we reverse rear and put it in front\n    if |q.rear| == 1 then\n      Queue([], [])\n    else\n      Queue(reverse(q.rear)[1..], [])\n}\n\nfunction {:spec} queueFront<T>(q: Queue<T>): T\n  requires !queueIsEmpty(q)\n{\n  if |q.front| > 0 then\n    q.front[0]\n  else\n    // Front is empty, so the front element is the first element of rear (when reversed)\n    q.rear[|q.rear| - 1]\n}\n\nfunction {:spec} queueSize<T>(q: Queue<T>): nat\n{\n  |q.front| + |q.rear|\n}\n\nfunction {:spec} queueToSeq<T>(q: Queue<T>): seq<T>\n{\n  q.front + reverse(q.rear)\n}\n\nfunction reverse<T>(s: seq<T>): seq<T>\n{\n  if |s| == 0 then []\n  else reverse(s[1..]) + [s[0]]\n}\n\n// Alternative queue representation with invariant\ndatatype SimpleQueue<T> = SimpleQueue(elements: seq<T>)\n\nfunction {:spec} simpleQueueEmpty<T>(): SimpleQueue<T>\n{\n  SimpleQueue([])\n}\n\npredicate {:spec} simpleQueueIsEmpty<T>(q: SimpleQueue<T>)\n{\n  q.elements == []\n}\n\nfunction {:spec} simpleEnqueue<T>(q: SimpleQueue<T>, x: T): SimpleQueue<T>\n{\n  SimpleQueue(q.elements + [x])\n}\n\nfunction {:spec} simpleDequeue<T>(q: SimpleQueue<T>): SimpleQueue<T>\n  requires !simpleQueueIsEmpty(q)\n{\n  SimpleQueue(q.elements[1..])\n}\n\nfunction {:spec} simpleQueueFront<T>(q: SimpleQueue<T>): T\n  requires !simpleQueueIsEmpty(q)\n{\n  q.elements[0]\n}\n\nfunction {:spec} simpleQueueSize<T>(q: SimpleQueue<T>): nat\n{\n  |q.elements|\n}\n\nlemma ReverseLength<T>(s: seq<T>)\n  ensures |reverse(s)| == |s|\n{\n}\n\nlemma ReverseReverse<T>(s: seq<T>)\n  ensures reverse(reverse(s)) == s\n{\n  if |s| == 0 {\n    // Base case\n  } else {\n    ReverseAppend(reverse(s[1..]), [s[0]]);\n  }\n}\n\nlemma ReverseAppend<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n  if |s1| == 0 {\n    assert s1 + s2 == s2;\n  } else {\n    assert s1 + s2 == [s1[0]] + (s1[1..] + s2);\n  }\n}\n\nlemma ReverseFirst<T>(s: seq<T>)\n  requires |s| > 0\n  ensures |reverse(s)| == |s|\n  ensures reverse(s)[|reverse(s)| - 1] == s[0]\n  ensures reverse(s)[0] == s[|s| - 1]\n{\n}\n\nlemma SeqAssoc<T>(a: seq<T>, b: seq<T>, c: seq<T>)\n  ensures a + (b + c) == (a + b) + c\n{\n}\n\nlemma QueueSizeProperty<T>(q: Queue<T>)\n  ensures queueSize(q) == |queueToSeq(q)|\n{\n  ReverseLength(q.rear);\n}\n\nlemma EnqueueCorrect<T>(q: Queue<T>, x: T)\n  ensures queueToSeq(enqueue(q, x)) == queueToSeq(q) + [x]\n  ensures queueSize(enqueue(q, x)) == queueSize(q) + 1\n{\n}\n\nlemma DequeueCorrect<T>(q: Queue<T>)\n  requires !queueIsEmpty(q)\n  ensures |queueToSeq(q)| > 0\n  ensures queueToSeq(dequeue(q)) == queueToSeq(q)[1..]\n  ensures queueFront(q) == queueToSeq(q)[0]\n{\n  if |q.front| > 0 {\n  } else {\n    var rev := reverse(q.rear);\n\n    ReverseFirst(q.rear);\n\n    if |q.rear| == 1 {\n    } else {\n    }\n  }\n}\n\nlemma SimpleQueueEquivalence<T>(sq: SimpleQueue<T>, q: Queue<T>)\n  requires sq.elements == queueToSeq(q)\n  ensures simpleQueueIsEmpty(sq) == queueIsEmpty(q)\n  ensures simpleQueueSize(sq) == queueSize(q)\n{\n/*[SKETCH HERE]*/\n}\n", "output": "  if queueIsEmpty(q) {\n  }"}, {"id": "reverse_list_solution_reverse_append_sketch", "type": "sketch", "program": "function reverse<T>(l: seq<T>): seq<T>\n{\n  if |l| == 0 then []\n  else reverse(l[1..]) + [l[0]]\n}\n\nlemma reverse_permutes<T>(l: seq<T>)\n  ensures forall x :: x in l <==> x in reverse(l)\n{\n}\n\nlemma reverse_append<T>(s1: seq<T>, s2: seq<T>)\n  ensures reverse(s1 + s2) == reverse(s2) + reverse(s1)\n{\n/*[SKETCH HERE]*/\n}\n\nlemma reverse_involutes<T>(l: seq<T>)\n  ensures reverse(reverse(l)) == l\n{\n  if |l| == 0 {\n  } else {\n    calc {\n      reverse(reverse(l));\n      == reverse(reverse(l[1..]) + [l[0]]);\n      == { reverse_append(reverse(l[1..]), [l[0]]); }\n      reverse([l[0]]) + reverse(reverse(l[1..]));\n      == [l[0]] + reverse(reverse(l[1..]));\n      == { reverse_involutes(l[1..]); }\n      [l[0]] + l[1..];\n      == l;\n    }\n  }\n}\n", "output": "  if |s1| == 0 {\n  } else {\n    \n    calc {\n      reverse(s1 + s2);\n      == reverse([s1[0]] + (s1[1..] + s2));\n      == reverse((s1[1..] + s2)) + [s1[0]];\n      == { reverse_append(s1[1..], s2); }\n      (reverse(s2) + reverse(s1[1..])) + [s1[0]];\n      == { assert (reverse(s2) + reverse(s1[1..])) + [s1[0]] == \n           reverse(s2) + (reverse(s1[1..]) + [s1[0]]); }\n      reverse(s2) + (reverse(s1[1..]) + [s1[0]]);\n      == reverse(s2) + reverse(s1);\n    }\n  }"}, {"id": "rle_solution_encodeDecodeRoundTrip_sketch", "type": "sketch", "program": "// Run-Length Encoding\n// RLE compresses consecutive identical characters into (count, char) pairs\n\ndatatype RLE = RLE(count: nat, ch: char)\n\npredicate {:spec} validRLE(encoded: seq<RLE>)\n{\n  forall i :: 0 <= i < |encoded| ==> \n    encoded[i].count > 0 &&\n    (i + 1 < |encoded| ==> encoded[i].ch != encoded[i+1].ch)\n}\n\nfunction {:spec} decode(encoded: seq<RLE>): seq<char>\n{\n  if |encoded| == 0 then []\n  else repeatChar(encoded[0].count, encoded[0].ch) + decode(encoded[1..])\n}\n\nfunction {:spec} repeatChar(n: nat, c: char): seq<char>\n{\n  if n == 0 then []\n  else [c] + repeatChar(n-1, c)\n}\n\nfunction encode(s: seq<char>): seq<RLE>\n{\n  if |s| == 0 then []\n  else if |s| == 1 then [RLE(1, s[0])]\n  else \n    var rest := encode(s[1..]);\n    if |rest| > 0 && rest[0].ch == s[0] then\n      [RLE(rest[0].count + 1, s[0])] + rest[1..]\n    else\n      [RLE(1, s[0])] + rest\n}\n\nlemma encodeProducesValidRLE(s: seq<char>)\n  ensures validRLE(encode(s))\n{\n}\n\nlemma encodeDecodeRoundTrip(s: seq<char>)\n  ensures decode(encode(s)) == s\n{\n/*[SKETCH HERE]*/\n}\n", "output": "  if |s| == 0 {\n    // Base case: empty sequence\n  } else if |s| == 1 {\n    // Base case: single character\n  } else {\n    var rest := encode(s[1..]);\n    \n    if |rest| > 0 && rest[0].ch == s[0] {\n      // Case: merging with first element of rest\n      var merged := [RLE(rest[0].count + 1, s[0])] + rest[1..];\n    } else {\n      // Case: not merging\n      var result := [RLE(1, s[0])] + rest;\n    }\n  }"}, {"id": "sortedlist_solution_RevAcc_Helper_sketch", "type": "sketch", "program": "datatype List = Nil | Cons(head: int, tail: List)\n\npredicate SortedBetween(l: List, lo: int, hi: int)\n{\n  match l\n    case Nil => true\n    case Cons(x, xs) => lo <= x < hi && SortedBetween(xs, x, hi)\n}\n\nfunction insert(l: List, x: int): List {\n  match l\n    case Nil => Cons(x, Nil)\n    case Cons(y, ys) =>\n      if x < y then Cons(x, l) else Cons(y, insert(ys, x))\n}\n\nlemma InsertPreservesSortedBetween(l: List, x: int, lo: int, hi: int)\n  requires SortedBetween(l, lo, hi)\n  requires lo <= x < hi\n  ensures  SortedBetween(insert(l, x), lo, hi)\n{\n}\n\nfunction app(xs: List, ys: List): List {\n  match xs\n    case Nil => ys\n    case Cons(x, xs') => Cons(x, app(xs', ys))\n}\n\nfunction revAcc(xs: List, acc: List): List {\n  match xs\n    case Nil => acc\n    case Cons(x, xs') => revAcc(xs', Cons(x, acc))\n}\n\nlemma RevAcc_Helper(xs: List, acc: List)\n  ensures revAcc(xs, acc) == app(revAcc(xs, Nil), acc)\n{\n/*[SKETCH HERE]*/\n}\n\nlemma AppendAssoc(xs: List, ys: List, zs: List)\n  ensures app(app(xs, ys), zs) == app(xs, app(ys, zs))\n{\n}\n\nlemma RevAcc_Correct(xs: List, acc: List)\n  ensures revAcc(xs, acc) == app(revAcc(xs, Nil), acc)\n{\n  RevAcc_Helper(xs, acc);\n}\n", "output": "  match xs {\n    case Nil => \n    case Cons(x, xs') => \n  }"}, {"id": "sortedlist_solution_RevAcc_Correct_sketch", "type": "sketch", "program": "datatype List = Nil | Cons(head: int, tail: List)\n\npredicate SortedBetween(l: List, lo: int, hi: int)\n{\n  match l\n    case Nil => true\n    case Cons(x, xs) => lo <= x < hi && SortedBetween(xs, x, hi)\n}\n\nfunction insert(l: List, x: int): List {\n  match l\n    case Nil => Cons(x, Nil)\n    case Cons(y, ys) =>\n      if x < y then Cons(x, l) else Cons(y, insert(ys, x))\n}\n\nlemma InsertPreservesSortedBetween(l: List, x: int, lo: int, hi: int)\n  requires SortedBetween(l, lo, hi)\n  requires lo <= x < hi\n  ensures  SortedBetween(insert(l, x), lo, hi)\n{\n}\n\nfunction app(xs: List, ys: List): List {\n  match xs\n    case Nil => ys\n    case Cons(x, xs') => Cons(x, app(xs', ys))\n}\n\nfunction revAcc(xs: List, acc: List): List {\n  match xs\n    case Nil => acc\n    case Cons(x, xs') => revAcc(xs', Cons(x, acc))\n}\n\nlemma RevAcc_Helper(xs: List, acc: List)\n  ensures revAcc(xs, acc) == app(revAcc(xs, Nil), acc)\n{\n  match xs {\n    case Nil => \n    case Cons(x, xs') => \n      AppendAssoc(revAcc(xs', Nil), Cons(x, Nil), acc);\n  }\n}\n\nlemma AppendAssoc(xs: List, ys: List, zs: List)\n  ensures app(app(xs, ys), zs) == app(xs, app(ys, zs))\n{\n}\n\nlemma RevAcc_Correct(xs: List, acc: List)\n  ensures revAcc(xs, acc) == app(revAcc(xs, Nil), acc)\n{\n/*[SKETCH HERE]*/\n}\n", "output": ""}, {"id": "stack_operations_solution_StackInduction_sketch", "type": "sketch", "program": "// Stack operations: push, pop, peek, isEmpty with LIFO properties\n\ndatatype Stack<T> = Stack(elements: seq<T>)\n\nfunction {:spec} emptyStack<T>(): Stack<T>\n{\n  Stack([])\n}\n\npredicate {:spec} isEmpty<T>(s: Stack<T>)\n{\n  s.elements == []\n}\n\nfunction {:spec} push<T>(s: Stack<T>, x: T): Stack<T>\n{\n  Stack([x] + s.elements)\n}\n\nfunction {:spec} pop<T>(s: Stack<T>): Stack<T>\n  requires !isEmpty(s)\n{\n  Stack(s.elements[1..])\n}\n\nfunction {:spec} peek<T>(s: Stack<T>): T\n  requires !isEmpty(s)\n{\n  s.elements[0]\n}\n\nfunction {:spec} size<T>(s: Stack<T>): nat\n{\n  |s.elements|\n}\n\npredicate {:spec} contains<T(==)>(s: Stack<T>, x: T)\n{\n  x in s.elements\n}\n\nfunction {:spec} toSeq<T>(s: Stack<T>): seq<T>\n{\n  s.elements\n}\n\n// Stack from sequence\nfunction {:spec} fromSeq<T>(elements: seq<T>): Stack<T>\n{\n  Stack(elements)\n}\n\n// Multiple push operations\nfunction {:spec} pushAll<T>(s: Stack<T>, items: seq<T>): Stack<T>\n  decreases |items|\n{\n  if |items| == 0 then s\n  else pushAll(push(s, items[0]), items[1..])\n}\n\n// Multiple pop operations\nfunction {:spec} popN<T>(s: Stack<T>, n: nat): Stack<T>\n  requires n <= size(s)\n  decreases n\n{\n  if n == 0 then s\n  else popN(pop(s), n - 1)\n}\n\n// Get the nth element from top (0-indexed)\nfunction {:spec} nthFromTop<T>(s: Stack<T>, n: nat): T\n  requires n < size(s)\n{\n  s.elements[n]\n}\n\nlemma PushPopIdentity<T>(s: Stack<T>, x: T)\n  ensures pop(push(s, x)) == s\n  ensures peek(push(s, x)) == x\n{\n}\n\nlemma PopPushNotIdentity<T>(s: Stack<T>, x: T)\n  requires !isEmpty(s)\n  requires x != peek(s)\n  ensures push(pop(s), x) != s\n{\n}\n\nlemma PushIncreaseSize<T>(s: Stack<T>, x: T)\n  ensures size(push(s, x)) == size(s) + 1\n{\n}\n\nlemma PopDecreaseSize<T>(s: Stack<T>)\n  requires !isEmpty(s)\n  ensures size(pop(s)) == size(s) - 1\n{\n}\n\nlemma EmptyStackProperties<T>(s: Stack<T>)\n  ensures isEmpty(s) <==> size(s) == 0\n  ensures isEmpty(s) <==> s.elements == []\n{\n}\n\nlemma LIFOProperty<T>(s: Stack<T>, x: T, y: T)\n  ensures peek(push(push(s, x), y)) == y\n  ensures peek(pop(push(push(s, x), y))) == x\n{\n}\n\nlemma PushAllCorrect<T>(s: Stack<T>, items: seq<T>)\n  ensures size(pushAll(s, items)) == size(s) + |items|\n  decreases |items|\n{\n}\n\nlemma PopNCorrect<T>(s: Stack<T>, n: nat)\n  requires n <= size(s)\n  ensures size(popN(s, n)) == size(s) - n\n  decreases n\n{\n}\n\nlemma PushPreservesContains<T>(s: Stack<T>, x: T, y: T)\n  ensures contains(push(s, x), y) <==> (y == x || contains(s, y))\n{\n}\n\nlemma StackToFromSeq<T>(s: Stack<T>)\n  ensures fromSeq(toSeq(s)) == s\n  ensures toSeq(fromSeq(s.elements)) == s.elements\n{\n}\n\nlemma PushOrder<T>(s: Stack<T>, x: T, y: T)\n  ensures toSeq(push(push(s, x), y)) == [y, x] + toSeq(s)\n{\n}\n\nlemma NthFromTopCorrect<T>(s: Stack<T>, n: nat)\n  requires n < size(s)\n  ensures nthFromTop(s, n) == toSeq(s)[n]\n{\n}\n\nlemma StackInduction<T>(s: Stack<T>)\n  ensures s == emptyStack() || exists x, s' :: s == push(s', x)\n{\n/*[SKETCH HERE]*/\n}\n", "output": "  if isEmpty(s) {\n  } else {\n    var s' := pop(s);\n    var x := peek(s);\n  }"}]