{
    "nodes": [
        {
            "id": "idea_0",
            "type": "idea",
            "content": "1. Implement a Dafny program that calculates the greatest common divisor (GCD) of two positive integers using the Euclidean algorithm, with formal proofs of correctness and termination.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_1",
            "type": "idea",
            "content": "2. Develop a program that models a simple bank account system, ensuring that any withdrawal does not result in a negative balance by verifying preconditions and postconditions.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_2",
            "type": "idea",
            "content": "3. Create a recursive function to compute the nth Fibonacci number, including proofs to verify correctness and to prevent stack overflow through proper use of decreases clauses.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_3",
            "type": "idea",
            "content": "4. Design a Dafny program that sorts a list of integers using the bubble sort algorithm, with annotations to prove that the output list is sorted and that all original elements are present.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_4",
            "type": "idea",
            "content": "5. Implement a linked list data structure with methods for insertion and deletion, verifying that list integrity and order are maintained after each operation.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_5",
            "type": "idea",
            "content": "6. Construct a binary search tree with insert and find methods, ensuring that the tree properties are preserved and that search operations correctly identify the presence or absence of elements.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_6",
            "type": "idea",
            "content": "7. Write a program to solve the Tower of Hanoi puzzle for any number of disks, verifying that the solution is correct and uses the minimal number of moves.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_7",
            "type": "idea",
            "content": "8. Develop a matrix multiplication program that checks for dimension compatibility and verifies the correctness of the resulting matrix through formal proofs.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_8",
            "type": "idea",
            "content": "9. Create a function that determines whether a given string is a palindrome, with proofs to verify that the function correctly identifies palindromic and non-palindromic strings.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_9",
            "type": "idea",
            "content": "10. Implement the Sieve of Eratosthenes algorithm to generate all prime numbers up to a specified limit, including proofs that all numbers identified are indeed prime.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_10",
            "type": "idea",
            "content": "11. Design a Dafny program that computes the factorial of a non-negative integer using both iterative and recursive methods, verifying correctness and termination in both cases.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_11",
            "type": "idea",
            "content": "12. Develop a program that models a simple queue data structure, verifying that enqueue and dequeue operations behave correctly and maintain the queue's FIFO properties.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_12",
            "type": "idea",
            "content": "13. Create a function that checks whether a given binary tree is balanced, including proofs that the function correctly assesses the balance of any binary tree.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_13",
            "type": "idea",
            "content": "14. Implement Dijkstra's algorithm for finding the shortest path in a weighted graph, with proofs to verify that the shortest paths are correctly identified.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_14",
            "type": "idea",
            "content": "15. Write a program that performs binary search on a sorted array, verifying that the search correctly finds the target element or determines its absence.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_15",
            "type": "idea",
            "content": "16. Develop a sorting algorithm that sorts a list of integers using quicksort, including annotations to prove that the output is sorted and contains all original elements.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_16",
            "type": "idea",
            "content": "17. Create a program that models a stack data structure, verifying that push and pop operations function correctly and maintain the stack's LIFO properties.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_17",
            "type": "idea",
            "content": "18. Implement a function to check if a number is a perfect number (equal to the sum of its proper divisors), with proofs to verify correctness.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_18",
            "type": "idea",
            "content": "19. Design a program that simulates a basic vending machine, ensuring that item selection and change dispensing are handled correctly through formal verification.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_19",
            "type": "idea",
            "content": "20. Develop a function that computes the power of a number using exponentiation by squaring, including proofs of correctness and efficiency.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_20",
            "type": "idea",
            "content": "21. Create a program that validates Sudoku puzzles, verifying that the solution meets all Sudoku rules.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_21",
            "type": "idea",
            "content": "22. Implement a function that calculates the nth Catalan number recursively, including proofs to ensure correctness and proper termination.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_22",
            "type": "idea",
            "content": "23. Write a program that simulates a simple traffic light system, verifying that the state transitions occur correctly and avoid invalid states.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_23",
            "type": "idea",
            "content": "24. Develop a function to compute the transpose of a matrix, with proofs to verify that the transposed matrix is correct.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_24",
            "type": "idea",
            "content": "25. Create a program that models a priority queue, verifying that elements are dequeued in the correct order based on their priority.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_25",
            "type": "idea",
            "content": "26. Implement the merge sort algorithm to sort a list of integers, including proofs that the output list is sorted and contains all the original elements.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_26",
            "type": "idea",
            "content": "27. Design a program that checks whether a given year is a leap year, verifying the correctness of the leap year calculation rules.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_27",
            "type": "idea",
            "content": "28. Develop a function that computes the greatest common divisor (GCD) and least common multiple (LCM) of two integers, including proofs of correctness.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_28",
            "type": "idea",
            "content": "29. Create a program that simulates a simple elevator system, verifying that the elevator responds correctly to floor requests and maintains safety constraints.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_29",
            "type": "idea",
            "content": "30. Implement a function to reverse a linked list, with proofs to verify that the list is correctly reversed.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_30",
            "type": "idea",
            "content": "31. Write a program that performs Huffman coding for data compression, verifying that the encoding and decoding processes are correct.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_31",
            "type": "idea",
            "content": "32. Develop a function to compute combinations (n choose k), including proofs to ensure correct calculation and handling of edge cases.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_32",
            "type": "idea",
            "content": "33. Create a program that models a simple voting system, verifying that votes are counted correctly and that the winner is accurately determined.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_33",
            "type": "idea",
            "content": "34. Implement a function to detect cycles in a graph using depth-first search, with proofs to verify that cycles are correctly identified.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_34",
            "type": "idea",
            "content": "35. Design a program that simulates a basic calculator, verifying that operations like addition, subtraction, multiplication, and division are performed correctly.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_35",
            "type": "idea",
            "content": "36. Develop a function to solve linear equations using Gaussian elimination, including proofs to verify that the solution is correct.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_36",
            "type": "idea",
            "content": "37. Create a program that models a simple bookstore inventory system, verifying that stock levels are updated correctly after sales and restocking.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_37",
            "type": "idea",
            "content": "38. Implement a function to find the longest common subsequence between two strings, with proofs to verify correctness.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_38",
            "type": "idea",
            "content": "39. Write a program that simulates Conway's Game of Life, verifying that the rules are correctly applied to each generation.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_39",
            "type": "idea",
            "content": "40. Develop a function to perform polynomial addition and multiplication, including proofs to ensure that the results are correct.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_40",
            "type": "idea",
            "content": "41. Create a program that models a basic login system, verifying that authentication succeeds only with correct credentials and fails otherwise.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_41",
            "type": "idea",
            "content": "42. Implement a function to perform integer division without using the division operator, with proofs to verify correctness.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_42",
            "type": "idea",
            "content": "43. Design a program that simulates a basic thermostat system, verifying that temperature adjustments are made correctly based on setpoints.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_43",
            "type": "idea",
            "content": "44. Develop a function to compute the sum of a geometric series, including proofs to verify correctness for both finite and infinite series within convergence criteria.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_44",
            "type": "idea",
            "content": "45. Create a program that models a simple alarm clock, verifying that alarms trigger at the correct times and can be set and canceled properly.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_45",
            "type": "idea",
            "content": "46. Implement a function to solve the knapsack problem using dynamic programming, with proofs to verify that the optimal solution is found.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_46",
            "type": "idea",
            "content": "47. Write a program that simulates a simple blockchain ledger, verifying that transactions are recorded correctly and the chain integrity is maintained.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_47",
            "type": "idea",
            "content": "48. Develop a function to compute the edit distance between two strings, including proofs to ensure correctness.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_48",
            "type": "idea",
            "content": "49. Create a program that models a basic recipe manager, verifying that ingredient lists are generated correctly based on selected recipes.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_49",
            "type": "idea",
            "content": "50. Implement a function to convert numbers between different bases (e.g., binary, decimal, hexadecimal), with proofs to verify correctness.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_50",
            "type": "idea",
            "content": "51. Design a program that simulates a simple chat application, verifying that messages are correctly sent and received between users.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_51",
            "type": "idea",
            "content": "52. Develop a function to compute the determinant of a matrix, including proofs to ensure correctness.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_52",
            "type": "idea",
            "content": "53. Create a program that models a library checkout system, verifying that books are correctly issued and returned, and that overdue fees are calculated properly.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_53",
            "type": "idea",
            "content": "54. Implement a function to find all permutations of a given list, with proofs to verify that all permutations are generated without duplicates.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_54",
            "type": "idea",
            "content": "55. Write a program that simulates a simple email system, verifying that emails are correctly sent, received, and stored.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_55",
            "type": "idea",
            "content": "56. Develop a function to compute the convex hull of a set of points, including proofs to ensure the correctness of the computed hull.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_56",
            "type": "idea",
            "content": "57. Create a program that models a basic payroll system, verifying that salaries are calculated correctly based on hours worked and pay rates.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_57",
            "type": "idea",
            "content": "58. Implement a function to perform integer square root calculation, with proofs to verify correctness and handle edge cases.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_58",
            "type": "idea",
            "content": "59. Design a program that simulates a tic-tac-toe game, verifying that win conditions are correctly identified and that illegal moves are prevented.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_59",
            "type": "idea",
            "content": "60. Develop a function to perform image convolution operations, including proofs to verify that the convolution is applied correctly.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_60",
            "type": "idea",
            "content": "61. Create a program that models a basic weather monitoring system, verifying that data is collected and reported accurately.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_61",
            "type": "idea",
            "content": "62. Implement a function to perform fast Fourier transform (FFT) on a set of data, with proofs to verify correctness.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_62",
            "type": "idea",
            "content": "63. Write a program that simulates a simple shopping cart system, verifying that items are added and removed correctly, and totals are calculated properly.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_63",
            "type": "idea",
            "content": "64. Develop a function to solve quadratic equations, including proofs to verify that all real solutions are found correctly.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_64",
            "type": "idea",
            "content": "65. Create a program that models a basic task scheduler, verifying that tasks are executed in the correct order based on priority and dependencies.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_65",
            "type": "idea",
            "content": "66. Implement a function to generate Pascal's Triangle up to a given number of rows, with proofs to verify correctness.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_66",
            "type": "idea",
            "content": "67. Design a program that simulates a basic hotel reservation system, verifying that room bookings are handled correctly and overbooking is prevented.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_67",
            "type": "idea",
            "content": "68. Develop a function to perform radix sort on a list of integers, including proofs to ensure that the output is correctly sorted.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_68",
            "type": "idea",
            "content": "69. Create a program that models a simple file system, verifying that file operations like create, read, update, and delete function correctly.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_69",
            "type": "idea",
            "content": "70. Implement a function to compute the number of ways to make change for a given amount using dynamic programming, with proofs to verify correctness.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_70",
            "type": "idea",
            "content": "71. Write a program that simulates a basic peer-to-peer network, verifying that data packets are correctly routed and received.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_71",
            "type": "idea",
            "content": "72. Develop a function to perform matrix inversion, including proofs to verify that the inverted matrix is correct.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_72",
            "type": "idea",
            "content": "73. Create a program that models a basic stock trading system, verifying that transactions are executed correctly and account balances are updated properly.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_73",
            "type": "idea",
            "content": "74. Implement a function to solve the traveling salesman problem using a heuristic approach, with proofs to verify that a valid tour is produced.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_74",
            "type": "idea",
            "content": "75. Design a program that simulates a basic air traffic control system, verifying that aircraft are correctly managed to prevent conflicts.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_75",
            "type": "idea",
            "content": "76. Develop a function to compute the eigenvalues and eigenvectors of a matrix, including proofs to ensure correctness.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_76",
            "type": "idea",
            "content": "77. Create a program that models a basic encryption and decryption system using simple ciphers, verifying that messages are correctly transformed.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_77",
            "type": "idea",
            "content": "78. Implement a function to perform collision detection between geometric shapes, with proofs to verify correctness.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_78",
            "type": "idea",
            "content": "79. Write a program that simulates a basic recommendation system, verifying that suggestions are generated based on user preferences.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_79",
            "type": "idea",
            "content": "80. Develop a function to compute the shortest path in a maze using breadth-first search, including proofs to verify that the path found is indeed the shortest.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_80",
            "type": "idea",
            "content": "81. Create a program that models a basic content management system, verifying that content is correctly created, edited, and displayed.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_81",
            "type": "idea",
            "content": "82. Implement a function to perform numerical integration using the trapezoidal rule, with proofs to verify correctness.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_82",
            "type": "idea",
            "content": "83. Design a program that simulates a basic spell checker, verifying that misspelled words are correctly identified and suggestions are provided.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_83",
            "type": "idea",
            "content": "84. Develop a function to compute the median of a data set efficiently, including proofs to ensure correctness.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_84",
            "type": "idea",
            "content": "85. Create a program that models a basic logistics system, verifying that deliveries are scheduled and routed correctly.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_85",
            "type": "idea",
            "content": "86. Implement a function to perform polynomial interpolation, with proofs to verify that the interpolated values are correct.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_86",
            "type": "idea",
            "content": "87. Write a program that simulates a basic inventory management system, verifying that stock levels are accurate after sales and restocking.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_87",
            "type": "idea",
            "content": "88. Develop a function to solve systems of linear inequalities, including proofs to verify that the solution set is correct.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_88",
            "type": "idea",
            "content": "89. Create a program that models a basic currency converter, verifying that conversions are calculated accurately using up-to-date exchange rates.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_89",
            "type": "idea",
            "content": "90. Implement a function to perform string pattern matching using the Knuth-Morris-Pratt algorithm, with proofs to verify correctness.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_90",
            "type": "idea",
            "content": "91. Design a program that simulates a basic flight booking system, verifying that seat assignments are handled correctly and overbooking is prevented.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_91",
            "type": "idea",
            "content": "92. Develop a function to compute the area under a curve using Simpson's rule, including proofs to verify correctness.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_92",
            "type": "idea",
            "content": "93. Create a program that models a basic chat bot, verifying that user inputs are correctly interpreted and appropriate responses are generated.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_93",
            "type": "idea",
            "content": "94. Implement a function to solve the subset sum problem using dynamic programming, with proofs to verify that a correct subset is found when one exists.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_94",
            "type": "idea",
            "content": "95. Write a program that simulates a basic vehicle navigation system, verifying that the shortest routes are calculated correctly.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_95",
            "type": "idea",
            "content": "96. Develop a function to compute the inverse of a function numerically, including proofs to ensure correctness within a specified tolerance.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_96",
            "type": "idea",
            "content": "97. Create a program that models a basic tournament bracket generator, verifying that matchups are scheduled correctly based on seeding.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_97",
            "type": "idea",
            "content": "98. Implement a function to perform data compression using run-length encoding, with proofs to verify that compression and decompression are correct.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_98",
            "type": "idea",
            "content": "99. Design a program that simulates a basic energy consumption tracker, verifying that usage data is collected and reported accurately.",
            "parents": [],
            "diff": null
        },
        {
            "id": "idea_99",
            "type": "idea",
            "content": "100. Develop a function to compute the solution to a system of differential equations using Euler's method, including proofs to verify correctness within a specified tolerance.",
            "parents": [],
            "diff": null
        },
        {
            "id": "node_100",
            "type": "program",
            "content": "class Point {\n    var x: int;\n    var y: int;\n    constructor(x: int, y: int)\n        ensures this.x == x && this.y == y\n    {\n        this.x := x;\n        this.y := y;\n    }\n}\nclass Rectangle {\n    var topLeft: Point;\n    var bottomRight: Point;\n    constructor(topLeft: Point, bottomRight: Point)\n        requires topLeft.x <= bottomRight.x && topLeft.y <= bottomRight.y\n        ensures this.topLeft == topLeft && this.bottomRight == bottomRight\n    {\n        this.topLeft := topLeft;\n        this.bottomRight := bottomRight;\n    }\n    method Intersects(other: Rectangle) returns (intersects: bool)\n        ensures intersects == (this.topLeft.x < other.bottomRight.x && this.bottomRight.x > other.topLeft.x &&\n                               this.topLeft.y < other.bottomRight.y && this.bottomRight.y > other.topLeft.y)\n    {\n        intersects := this.topLeft.x < other.bottomRight.x && this.bottomRight.x > other.topLeft.x &&\n                      this.topLeft.y < other.bottomRight.y && this.bottomRight.y > other.topLeft.y;\n    }\n}",
            "parents": [
                "idea_77"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\n\nclass Point {\n    var x: int;\n    var y: int;\n\n    constructor(x: int, y: int)\n        ensures this.x == x && this.y == y\n    {\n        this.x := x;\n        this.y := y;\n    }\n}\n\nclass Rectangle {\n    var topLeft: Point;\n    var bottomRight: Point;\n\n    constructor(topLeft: Point, bottomRight: Point)\n        requires topLeft.x <= bottomRight.x && topLeft.y <= bottomRight.y\n        ensures this.topLeft == topLeft && this.bottomRight == bottomRight\n    {\n        this.topLeft := topLeft;\n        this.bottomRight := bottomRight;\n    }\n\n    method Intersects(other: Rectangle) returns (intersects: bool)\n        ensures intersects == (this.topLeft.x < other.bottomRight.x && this.bottomRight.x > other.topLeft.x &&\n                               this.topLeft.y < other.bottomRight.y && this.bottomRight.y > other.topLeft.y)\n    {\n        intersects := this.topLeft.x < other.bottomRight.x && this.bottomRight.x > other.topLeft.x &&\n                      this.topLeft.y < other.bottomRight.y && this.bottomRight.y > other.topLeft.y;\n    }\n}\n\n// END DAFNY\n```\n"
        },
        {
            "id": "node_101",
            "type": "program",
            "content": "class Matrix2x2 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    constructor(a: int, b: int, c: int, d: int)\n        ensures this.a == a && this.b == b && this.c == c && this.d == d\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n    }\n    method Determinant() returns (det: int)\n        ensures det == a * d - b * c\n    {\n        det := a * d - b * c;\n    }\n}\nmethod TestDeterminant()\n{\n    var m := new Matrix2x2(1, 2, 3, 4);\n    var det := m.Determinant();\n    assert det == -2; // 1*4 - 2*3 = -2\n}",
            "parents": [
                "idea_51"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\nclass Matrix2x2 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n\n    constructor(a: int, b: int, c: int, d: int)\n        ensures this.a == a && this.b == b && this.c == c && this.d == d\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n    }\n\n    method Determinant() returns (det: int)\n        ensures det == a * d - b * c\n    {\n        det := a * d - b * c;\n    }\n}\n\nmethod TestDeterminant()\n{\n    var m := new Matrix2x2(1, 2, 3, 4);\n    var det := m.Determinant();\n    assert det == -2; // 1*4 - 2*3 = -2\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_102",
            "type": "program",
            "content": "class LinearInequality {\n    var a: int;\n    var b: int;\n    var c: int;\n    constructor(a: int, b: int, c: int)\n        ensures this.a == a && this.b == b && this.c == c\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n    }\n    method IsSolution(x: int, y: int) returns (isSol: bool)\n        ensures isSol == (a * x + b * y <= c)\n    {\n        isSol := a * x + b * y <= c;\n    }\n}\nmethod TestIsSolution()\n{\n    var inequality := new LinearInequality(1, 2, 3);\n    var result := inequality.IsSolution(1, 1);\n    assert result == true; // 1*1 + 2*1 <= 3 is true\n    result := inequality.IsSolution(2, 2);\n    assert result == false; // 1*2 + 2*2 <= 3 is false\n}",
            "parents": [
                "idea_87"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\nclass LinearInequality {\n    var a: int;\n    var b: int;\n    var c: int;\n\n    constructor(a: int, b: int, c: int)\n        ensures this.a == a && this.b == b && this.c == c\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n    }\n\n    method IsSolution(x: int, y: int) returns (isSol: bool)\n        ensures isSol == (a * x + b * y <= c)\n    {\n        isSol := a * x + b * y <= c;\n    }\n}\n\nmethod TestIsSolution()\n{\n    var inequality := new LinearInequality(1, 2, 3);\n    var result := inequality.IsSolution(1, 1);\n    assert result == true; // 1*1 + 2*1 <= 3 is true\n    result := inequality.IsSolution(2, 2);\n    assert result == false; // 1*2 + 2*2 <= 3 is false\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_103",
            "type": "program",
            "content": "class SudokuValidator {\n    var grid: array2<int>;\n    constructor(grid: array2<int>)\n        requires grid.Length0 == 9 && grid.Length1 == 9\n        ensures this.grid == grid\n    {\n        this.grid := grid;\n    }\n    method IsRowValid(row: int) returns (isValid: bool)\n        requires 0 <= row < 9\n        ensures isValid == (forall i, j :: 0 <= i < j < 9 ==> grid[row, i] != grid[row, j])\n    {\n        var seen := new bool[10];\n        isValid := true;\n        for i := 0 to 8 {\n            if grid[row, i] < 1 || grid[row, i] > 9 || seen[grid[row, i]] {\n                isValid := false;\n                return;\n            }\n            seen[grid[row, i]] := true;\n        }\n    }\n    method IsColumnValid(col: int) returns (isValid: bool)\n        requires 0 <= col < 9\n        ensures isValid == (forall i, j :: 0 <= i < j < 9 ==> grid[i, col] != grid[j, col])\n    {\n        var seen := new bool[10];\n        isValid := true;\n        for i := 0 to 8 {\n            if grid[i, col] < 1 || grid[i, col] > 9 || seen[grid[i, col]] {\n                isValid := false;\n                return;\n            }\n            seen[grid[i, col]] := true;\n        }\n    }\n}",
            "parents": [
                "idea_20"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\nclass SudokuValidator {\n    var grid: array2<int>;\n\n    constructor(grid: array2<int>)\n        requires grid.Length0 == 9 && grid.Length1 == 9\n        ensures this.grid == grid\n    {\n        this.grid := grid;\n    }\n\n    method IsRowValid(row: int) returns (isValid: bool)\n        requires 0 <= row < 9\n        ensures isValid == (forall i, j :: 0 <= i < j < 9 ==> grid[row, i] != grid[row, j])\n    {\n        var seen := new bool[10];\n        isValid := true;\n        for i := 0 to 8 {\n            if grid[row, i] < 1 || grid[row, i] > 9 || seen[grid[row, i]] {\n                isValid := false;\n                return;\n            }\n            seen[grid[row, i]] := true;\n        }\n    }\n\n    method IsColumnValid(col: int) returns (isValid: bool)\n        requires 0 <= col < 9\n        ensures isValid == (forall i, j :: 0 <= i < j < 9 ==> grid[i, col] != grid[j, col])\n    {\n        var seen := new bool[10];\n        isValid := true;\n        for i := 0 to 8 {\n            if grid[i, col] < 1 || grid[i, col] > 9 || seen[grid[i, col]] {\n                isValid := false;\n                return;\n            }\n            seen[grid[i, col]] := true;\n        }\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_104",
            "type": "program",
            "content": "class VotingSystem {\n    var votes: array<int>;\n    var candidates: int;\n    constructor(candidates: int)\n        requires candidates > 0\n        ensures votes.Length == candidates\n    {\n        this.candidates := candidates;\n        this.votes := new int[candidates];\n    }\n    method CastVote(candidate: int)\n        requires 0 <= candidate < candidates\n        modifies votes\n        ensures votes[candidate] == old(votes[candidate]) + 1\n    {\n        votes[candidate] := votes[candidate] + 1;\n    }\n    method GetWinner() returns (winner: int)\n        ensures 0 <= winner < candidates\n        ensures forall i :: 0 <= i < candidates ==> votes[winner] >= votes[i]\n    {\n        var maxVotes := -1;\n        winner := -1;\n        for i := 0 to candidates - 1 {\n            if votes[i] > maxVotes {\n                maxVotes := votes[i];\n                winner := i;\n            }\n        }\n    }\n}",
            "parents": [
                "idea_32"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\n\nclass VotingSystem {\n    var votes: array<int>;\n    var candidates: int;\n\n    constructor(candidates: int)\n        requires candidates > 0\n        ensures votes.Length == candidates\n    {\n        this.candidates := candidates;\n        this.votes := new int[candidates];\n    }\n\n    method CastVote(candidate: int)\n        requires 0 <= candidate < candidates\n        modifies votes\n        ensures votes[candidate] == old(votes[candidate]) + 1\n    {\n        votes[candidate] := votes[candidate] + 1;\n    }\n\n    method GetWinner() returns (winner: int)\n        ensures 0 <= winner < candidates\n        ensures forall i :: 0 <= i < candidates ==> votes[winner] >= votes[i]\n    {\n        var maxVotes := -1;\n        winner := -1;\n        for i := 0 to candidates - 1 {\n            if votes[i] > maxVotes {\n                maxVotes := votes[i];\n                winner := i;\n            }\n        }\n    }\n}\n\n// END DAFNY\n```"
        },
        {
            "id": "node_105",
            "type": "program",
            "content": "class LoginSystem {\n    var username: string;\n    var password: string;\n    constructor(username: string, password: string)\n        ensures this.username == username && this.password == password\n    {\n        this.username := username;\n        this.password := password;\n    }\n    method Authenticate(inputUsername: string, inputPassword: string) returns (isAuthenticated: bool)\n        ensures isAuthenticated == (inputUsername == username && inputPassword == password)\n    {\n        isAuthenticated := inputUsername == username && inputPassword == password;\n    }\n}\nmethod TestAuthenticate()\n{\n    var system := new LoginSystem(\"user\", \"pass123\");\n    var result := system.Authenticate(\"user\", \"pass123\");\n    assert result == true; // Correct credentials\n    result := system.Authenticate(\"user\", \"wrongpass\");\n    assert result == false; // Incorrect password\n    result := system.Authenticate(\"wronguser\", \"pass123\");\n    assert result == false; // Incorrect username\n}",
            "parents": [
                "idea_40"
            ],
            "diff": "```\n// BEGIN DAFNY\nclass LoginSystem {\n    var username: string;\n    var password: string;\n\n    constructor(username: string, password: string)\n        ensures this.username == username && this.password == password\n    {\n        this.username := username;\n        this.password := password;\n    }\n\n    method Authenticate(inputUsername: string, inputPassword: string) returns (isAuthenticated: bool)\n        ensures isAuthenticated == (inputUsername == username && inputPassword == password)\n    {\n        isAuthenticated := inputUsername == username && inputPassword == password;\n    }\n}\n\nmethod TestAuthenticate()\n{\n    var system := new LoginSystem(\"user\", \"pass123\");\n    var result := system.Authenticate(\"user\", \"pass123\");\n    assert result == true; // Correct credentials\n\n    result := system.Authenticate(\"user\", \"wrongpass\");\n    assert result == false; // Incorrect password\n\n    result := system.Authenticate(\"wronguser\", \"pass123\");\n    assert result == false; // Incorrect username\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_106",
            "type": "program",
            "content": "class SimpleChatBot {\n    var greeting: string;\n    var farewell: string;\n    constructor(greeting: string, farewell: string)\n        ensures this.greeting == greeting && this.farewell == farewell\n    {\n        this.greeting := greeting;\n        this.farewell := farewell;\n    }\n    method RespondToInput(input: string) returns (response: string)\n        ensures response == if input == \"hello\" then greeting else if input == \"bye\" then farewell else \"I don't understand\"\n    {\n        if input == \"hello\" {\n            response := greeting;\n        } else if input == \"bye\" {\n            response := farewell;\n        } else {\n            response := \"I don't understand\";\n        }\n    }\n}\nmethod TestChatBotResponses()\n{\n    var bot := new SimpleChatBot(\"Hi there!\", \"Goodbye!\");\n    var response := bot.RespondToInput(\"hello\");\n    assert response == \"Hi there!\"; // Correct response to \"hello\"\n    response := bot.RespondToInput(\"bye\");\n    assert response == \"Goodbye!\"; // Correct response to \"bye\"\n    response := bot.RespondToInput(\"how are you?\");\n    assert response == \"I don't understand\"; // Unrecognized input\n}",
            "parents": [
                "idea_92"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\nclass SimpleChatBot {\n    var greeting: string;\n    var farewell: string;\n\n    constructor(greeting: string, farewell: string)\n        ensures this.greeting == greeting && this.farewell == farewell\n    {\n        this.greeting := greeting;\n        this.farewell := farewell;\n    }\n\n    method RespondToInput(input: string) returns (response: string)\n        ensures response == if input == \"hello\" then greeting else if input == \"bye\" then farewell else \"I don't understand\"\n    {\n        if input == \"hello\" {\n            response := greeting;\n        } else if input == \"bye\" {\n            response := farewell;\n        } else {\n            response := \"I don't understand\";\n        }\n    }\n}\n\nmethod TestChatBotResponses()\n{\n    var bot := new SimpleChatBot(\"Hi there!\", \"Goodbye!\");\n    var response := bot.RespondToInput(\"hello\");\n    assert response == \"Hi there!\"; // Correct response to \"hello\"\n\n    response := bot.RespondToInput(\"bye\");\n    assert response == \"Goodbye!\"; // Correct response to \"bye\"\n\n    response := bot.RespondToInput(\"how are you?\");\n    assert response == \"I don't understand\"; // Unrecognized input\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_107",
            "type": "program",
            "content": "class Matrix2x2 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    constructor(a: int, b: int, c: int, d: int)\n        ensures this.a == a && this.b == b && this.c == c && this.d == d\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n    }\n    method Determinant() returns (det: int)\n        ensures det == a * d - b * c\n    {\n        det := a * d - b * c;\n    }\n}\nmethod TestDeterminantWithZeroMatrix()\n{\n    var m := new Matrix2x2(0, 0, 0, 0);\n    var det := m.Determinant();\n    assert det == 0; // 0*0 - 0*0 = 0\n}\nmethod TestDeterminantWithIdentityMatrix()\n{\n    var m := new Matrix2x2(1, 0, 0, 1);\n    var det := m.Determinant();\n    assert det == 1; // 1*1 - 0*0 = 1\n}",
            "parents": [
                "node_101"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 19\nmethod TestDeterminantWithZeroMatrix()\n{\n    var m := new Matrix2x2(0, 0, 0, 0);\n    var det := m.Determinant();\n    assert det == 0; // 0*0 - 0*0 = 0\n}\n\nmethod TestDeterminantWithIdentityMatrix()\n{\n    var m := new Matrix2x2(1, 0, 0, 1);\n    var det := m.Determinant();\n    assert det == 1; // 1*1 - 0*0 = 1\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_108",
            "type": "program",
            "content": "class Matrix2x2 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    constructor(a: int, b: int, c: int, d: int)\n        ensures this.a == a && this.b == b && this.c == c && this.d == d\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n    }\n    method Transpose() returns (transposed: Matrix2x2)\n        ensures transposed.a == a && transposed.b == c && transposed.c == b && transposed.d == d\n    {\n        transposed := new Matrix2x2(a, c, b, d);\n    }\n}\nmethod TestTransposeWithZeroMatrix()\n{\n    var m := new Matrix2x2(0, 0, 0, 0);\n    var transposed := m.Transpose();\n    assert transposed.a == 0 && transposed.b == 0 && transposed.c == 0 && transposed.d == 0;\n}\nmethod TestTransposeWithIdentityMatrix()\n{\n    var m := new Matrix2x2(1, 0, 0, 1);\n    var transposed := m.Transpose();\n    assert transposed.a == 1 && transposed.b == 0 && transposed.c == 0 && transposed.d == 1;\n}",
            "parents": [
                "idea_23"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\nclass Matrix2x2 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n\n    constructor(a: int, b: int, c: int, d: int)\n        ensures this.a == a && this.b == b && this.c == c && this.d == d\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n    }\n\n    method Transpose() returns (transposed: Matrix2x2)\n        ensures transposed.a == a && transposed.b == c && transposed.c == b && transposed.d == d\n    {\n        transposed := new Matrix2x2(a, c, b, d);\n    }\n}\n\nmethod TestTransposeWithZeroMatrix()\n{\n    var m := new Matrix2x2(0, 0, 0, 0);\n    var transposed := m.Transpose();\n    assert transposed.a == 0 && transposed.b == 0 && transposed.c == 0 && transposed.d == 0;\n}\n\nmethod TestTransposeWithIdentityMatrix()\n{\n    var m := new Matrix2x2(1, 0, 0, 1);\n    var transposed := m.Transpose();\n    assert transposed.a == 1 && transposed.b == 0 && transposed.c == 0 && transposed.d == 1;\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_109",
            "type": "program",
            "content": "class FlightBookingSystem {\n    var totalSeats: nat;\n    var bookedSeats: nat;\n    constructor(totalSeats: nat)\n        requires totalSeats > 0\n        ensures this.totalSeats == totalSeats && this.bookedSeats == 0\n    {\n        this.totalSeats := totalSeats;\n        this.bookedSeats := 0;\n    }\n    method BookSeat() returns (success: bool)\n        ensures success ==> bookedSeats <= totalSeats\n        ensures !success ==> bookedSeats == totalSeats\n    {\n        if bookedSeats < totalSeats {\n            bookedSeats := bookedSeats + 1;\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n    method CancelSeat() returns (success: bool)\n        ensures success ==> bookedSeats >= 0\n        ensures !success ==> bookedSeats == 0\n    {\n        if bookedSeats > 0 {\n            bookedSeats := bookedSeats - 1;\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n}\nmethod TestFlightBookingSystem()\n{\n    var flight := new FlightBookingSystem(2);\n    var success := flight.BookSeat();\n    assert success; // First booking should succeed\n    success := flight.BookSeat();\n    assert success; // Second booking should succeed\n    success := flight.BookSeat();\n    assert !success; // Third booking should fail, as seats are full\n    success := flight.CancelSeat();\n    assert success; // Cancel one seat, should succeed\n    success := flight.BookSeat();\n    assert success; // Booking should succeed again after cancellation\n}",
            "parents": [
                "idea_90"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\nclass FlightBookingSystem {\n    var totalSeats: nat;\n    var bookedSeats: nat;\n\n    constructor(totalSeats: nat)\n        requires totalSeats > 0\n        ensures this.totalSeats == totalSeats && this.bookedSeats == 0\n    {\n        this.totalSeats := totalSeats;\n        this.bookedSeats := 0;\n    }\n\n    method BookSeat() returns (success: bool)\n        ensures success ==> bookedSeats <= totalSeats\n        ensures !success ==> bookedSeats == totalSeats\n    {\n        if bookedSeats < totalSeats {\n            bookedSeats := bookedSeats + 1;\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n\n    method CancelSeat() returns (success: bool)\n        ensures success ==> bookedSeats >= 0\n        ensures !success ==> bookedSeats == 0\n    {\n        if bookedSeats > 0 {\n            bookedSeats := bookedSeats - 1;\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n}\n\nmethod TestFlightBookingSystem()\n{\n    var flight := new FlightBookingSystem(2);\n    var success := flight.BookSeat();\n    assert success; // First booking should succeed\n    success := flight.BookSeat();\n    assert success; // Second booking should succeed\n    success := flight.BookSeat();\n    assert !success; // Third booking should fail, as seats are full\n\n    success := flight.CancelSeat();\n    assert success; // Cancel one seat, should succeed\n    success := flight.BookSeat();\n    assert success; // Booking should succeed again after cancellation\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_110",
            "type": "program",
            "content": "class Matrix3x3 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    var e: int;\n    var f: int;\n    var g: int;\n    var h: int;\n    var i: int;\n    constructor(a: int, b: int, c: int, d: int, e: int, f: int, g: int, h: int, i: int)\n        ensures this.a == a && this.b == b && this.c == c\n        ensures this.d == d && this.e == e && this.f == f\n        ensures this.g == g && this.h == h && this.i == i\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n        this.e := e;\n        this.f := f;\n        this.g := g;\n        this.h := h;\n        this.i := i;\n    }\n    method Determinant() returns (det: int)\n        ensures det == a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g)\n    {\n        det := a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g);\n    }\n}\nmethod TestDeterminantWithZeroMatrix3x3()\n{\n    var m := new Matrix3x3(0, 0, 0, 0, 0, 0, 0, 0, 0);\n    var det := m.Determinant();\n    assert det == 0; // 0 determinant for zero matrix\n}\nmethod TestDeterminantWithIdentityMatrix3x3()\n{\n    var m := new Matrix3x3(1, 0, 0, 0, 1, 0, 0, 0, 1);\n    var det := m.Determinant();\n    assert det == 1; // 1 determinant for identity matrix\n}",
            "parents": [
                "idea_51"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\nclass Matrix3x3 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    var e: int;\n    var f: int;\n    var g: int;\n    var h: int;\n    var i: int;\n\n    constructor(a: int, b: int, c: int, d: int, e: int, f: int, g: int, h: int, i: int)\n        ensures this.a == a && this.b == b && this.c == c\n        ensures this.d == d && this.e == e && this.f == f\n        ensures this.g == g && this.h == h && this.i == i\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n        this.e := e;\n        this.f := f;\n        this.g := g;\n        this.h := h;\n        this.i := i;\n    }\n\n    method Determinant() returns (det: int)\n        ensures det == a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g)\n    {\n        det := a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g);\n    }\n}\n\nmethod TestDeterminantWithZeroMatrix3x3()\n{\n    var m := new Matrix3x3(0, 0, 0, 0, 0, 0, 0, 0, 0);\n    var det := m.Determinant();\n    assert det == 0; // 0 determinant for zero matrix\n}\n\nmethod TestDeterminantWithIdentityMatrix3x3()\n{\n    var m := new Matrix3x3(1, 0, 0, 0, 1, 0, 0, 0, 1);\n    var det := m.Determinant();\n    assert det == 1; // 1 determinant for identity matrix\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_111",
            "type": "program",
            "content": "method QuickSort(a: array<int>) \n    requires a != null\n    modifies a\n    ensures forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n    ensures multiset(a[..]) == multiset(old(a[..]))\n{\n    QuickSortHelper(a, 0, a.Length - 1);\n}\nmethod QuickSortHelper(a: array<int>, low: int, high: int)\n    requires a != null && 0 <= low <= high + 1 <= a.Length\n    modifies a\n    ensures forall i, j :: low <= i < j <= high ==> a[i] <= a[j]\n    ensures multiset(a[low..high+1]) == multiset(old(a[low..high+1]))\n{\n    if low < high {\n        var pivotIndex := Partition(a, low, high);\n        QuickSortHelper(a, low, pivotIndex - 1);\n        QuickSortHelper(a, pivotIndex + 1, high);\n    }\n}\nmethod Partition(a: array<int>, low: int, high: int) returns (pivotIndex: int)\n    requires a != null && 0 <= low <= high < a.Length\n    modifies a\n    ensures low <= pivotIndex <= high\n    ensures forall i :: low <= i < pivotIndex ==> a[i] <= a[pivotIndex]\n    ensures forall i :: pivotIndex < i <= high ==> a[pivotIndex] <= a[i]\n    ensures multiset(a[low..high+1]) == multiset(old(a[low..high+1]))\n{\n    var pivot := a[high];\n    var i := low - 1;\n    for j := low to high - 1 {\n        if a[j] <= pivot {\n            i := i + 1;\n            var temp := a[i];\n            a[i] := a[j];\n            a[j] := temp;\n        }\n    }\n    var temp := a[i + 1];\n    a[i + 1] := a[high];\n    a[high] := temp;\n    pivotIndex := i + 1;\n}",
            "parents": [
                "idea_15"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\nmethod QuickSort(a: array<int>) \n    requires a != null\n    modifies a\n    ensures forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n    ensures multiset(a[..]) == multiset(old(a[..]))\n{\n    QuickSortHelper(a, 0, a.Length - 1);\n}\n\nmethod QuickSortHelper(a: array<int>, low: int, high: int)\n    requires a != null && 0 <= low <= high + 1 <= a.Length\n    modifies a\n    ensures forall i, j :: low <= i < j <= high ==> a[i] <= a[j]\n    ensures multiset(a[low..high+1]) == multiset(old(a[low..high+1]))\n{\n    if low < high {\n        var pivotIndex := Partition(a, low, high);\n        QuickSortHelper(a, low, pivotIndex - 1);\n        QuickSortHelper(a, pivotIndex + 1, high);\n    }\n}\n\nmethod Partition(a: array<int>, low: int, high: int) returns (pivotIndex: int)\n    requires a != null && 0 <= low <= high < a.Length\n    modifies a\n    ensures low <= pivotIndex <= high\n    ensures forall i :: low <= i < pivotIndex ==> a[i] <= a[pivotIndex]\n    ensures forall i :: pivotIndex < i <= high ==> a[pivotIndex] <= a[i]\n    ensures multiset(a[low..high+1]) == multiset(old(a[low..high+1]))\n{\n    var pivot := a[high];\n    var i := low - 1;\n    for j := low to high - 1 {\n        if a[j] <= pivot {\n            i := i + 1;\n            var temp := a[i];\n            a[i] := a[j];\n            a[j] := temp;\n        }\n    }\n    var temp := a[i + 1];\n    a[i + 1] := a[high];\n    a[high] := temp;\n    pivotIndex := i + 1;\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_112",
            "type": "program",
            "content": "module PalindromeChecker {\n  method IsPalindrome(s: seq<char>) returns (result: bool)\n    ensures result <==> (forall i :: 0 <= i < |s| / 2 ==> s[i] == s[|s| - i - 1])\n  {\n    var n := |s|;\n    result := true;\n    var i := 0;\n    while i < n / 2\n      invariant 0 <= i <= n / 2\n      invariant result ==> (forall j :: 0 <= j < i ==> s[j] == s[n - j - 1])\n    {\n      if s[i] != s[n - i - 1] {\n        result := false;\n        break;\n      }\n      i := i + 1;\n    }\n  }\n}",
            "parents": [
                "idea_8"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\nmodule PalindromeChecker {\n\n  method IsPalindrome(s: seq<char>) returns (result: bool)\n    ensures result <==> (forall i :: 0 <= i < |s| / 2 ==> s[i] == s[|s| - i - 1])\n  {\n    var n := |s|;\n    result := true;\n    var i := 0;\n    while i < n / 2\n      invariant 0 <= i <= n / 2\n      invariant result ==> (forall j :: 0 <= j < i ==> s[j] == s[n - j - 1])\n    {\n      if s[i] != s[n - i - 1] {\n        result := false;\n        break;\n      }\n      i := i + 1;\n    }\n  }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_113",
            "type": "program",
            "content": "class Year {\n    var year: int;\n    constructor(year: int)\n        ensures this.year == year\n    {\n        this.year := year;\n    }\n    method IsLeapYear() returns (isLeap: bool)\n        ensures isLeap == ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)\n    {\n        if year % 4 == 0 {\n            if year % 100 == 0 {\n                if year % 400 == 0 {\n                    isLeap := true;\n                } else {\n                    isLeap := false;\n                }\n            } else {\n                isLeap := true;\n            }\n        } else {\n            isLeap := false;\n        }\n    }\n}\nmethod TestLeapYear()\n{\n    var y := new Year(2000);\n    var isLeap := y.IsLeapYear();\n    assert isLeap; // 2000 is a leap year\n    y := new Year(1900);\n    isLeap := y.IsLeapYear();\n    assert !isLeap; // 1900 is not a leap year\n    y := new Year(2024);\n    isLeap := y.IsLeapYear();\n    assert isLeap; // 2024 is a leap year\n    y := new Year(2023);\n    isLeap := y.IsLeapYear();\n    assert !isLeap; // 2023 is not a leap year\n}",
            "parents": [
                "idea_26"
            ],
            "diff": "```\n// BEGIN DAFNY\nclass Year {\n    var year: int;\n\n    constructor(year: int)\n        ensures this.year == year\n    {\n        this.year := year;\n    }\n\n    method IsLeapYear() returns (isLeap: bool)\n        ensures isLeap == ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)\n    {\n        if year % 4 == 0 {\n            if year % 100 == 0 {\n                if year % 400 == 0 {\n                    isLeap := true;\n                } else {\n                    isLeap := false;\n                }\n            } else {\n                isLeap := true;\n            }\n        } else {\n            isLeap := false;\n        }\n    }\n}\n\nmethod TestLeapYear()\n{\n    var y := new Year(2000);\n    var isLeap := y.IsLeapYear();\n    assert isLeap; // 2000 is a leap year\n\n    y := new Year(1900);\n    isLeap := y.IsLeapYear();\n    assert !isLeap; // 1900 is not a leap year\n\n    y := new Year(2024);\n    isLeap := y.IsLeapYear();\n    assert isLeap; // 2024 is a leap year\n\n    y := new Year(2023);\n    isLeap := y.IsLeapYear();\n    assert !isLeap; // 2023 is not a leap year\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_114",
            "type": "program",
            "content": "class ChatBot {\n    var responses: map<string, string>;\n    constructor() {\n        responses := map[\n            \"hello\" := \"Hi there!\",\n            \"how are you\" := \"I'm just a bot, but I'm doing fine!\",\n            \"bye\" := \"Goodbye!\"\n        ];\n    }\n    method GetResponse(input: string) returns (response: string)\n        ensures response == if input in responses then responses[input] else \"I don't understand.\"\n    {\n        if input in responses {\n            response := responses[input];\n        } else {\n            response := \"I don't understand.\";\n        }\n    }\n}",
            "parents": [
                "idea_92"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\n\nclass ChatBot {\n    var responses: map<string, string>;\n\n    constructor() {\n        responses := map[\n            \"hello\" := \"Hi there!\",\n            \"how are you\" := \"I'm just a bot, but I'm doing fine!\",\n            \"bye\" := \"Goodbye!\"\n        ];\n    }\n\n    method GetResponse(input: string) returns (response: string)\n        ensures response == if input in responses then responses[input] else \"I don't understand.\"\n    {\n        if input in responses {\n            response := responses[input];\n        } else {\n            response := \"I don't understand.\";\n        }\n    }\n}\n\n// END DAFNY\n```"
        },
        {
            "id": "node_115",
            "type": "program",
            "content": "class Rectangle {\n    var x: int;\n    var y: int;\n    var width: int;\n    var height: int;\n    constructor(x: int, y: int, width: int, height: int)\n        requires width > 0 && height > 0\n        ensures this.x == x && this.y == y\n        ensures this.width == width && this.height == height\n    {\n        this.x := x;\n        this.y := y;\n        this.width := width;\n        this.height := height;\n    }\n    method Intersects(other: Rectangle) returns (intersects: bool)\n        ensures intersects == ((this.x < other.x + other.width) && (this.x + this.width > other.x) &&\n                               (this.y < other.y + other.height) && (this.y + this.height > other.y))\n    {\n        intersects := (this.x < other.x + other.width) && (this.x + this.width > other.x) &&\n                      (this.y < other.y + other.height) && (this.y + this.height > other.y);\n    }\n}",
            "parents": [
                "idea_77"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\n\nclass Rectangle {\n    var x: int;\n    var y: int;\n    var width: int;\n    var height: int;\n\n    constructor(x: int, y: int, width: int, height: int)\n        requires width > 0 && height > 0\n        ensures this.x == x && this.y == y\n        ensures this.width == width && this.height == height\n    {\n        this.x := x;\n        this.y := y;\n        this.width := width;\n        this.height := height;\n    }\n\n    method Intersects(other: Rectangle) returns (intersects: bool)\n        ensures intersects == ((this.x < other.x + other.width) && (this.x + this.width > other.x) &&\n                               (this.y < other.y + other.height) && (this.y + this.height > other.y))\n    {\n        intersects := (this.x < other.x + other.width) && (this.x + this.width > other.x) &&\n                      (this.y < other.y + other.height) && (this.y + this.height > other.y);\n    }\n}\n\n// END DAFNY\n```\n"
        },
        {
            "id": "node_116",
            "type": "program",
            "content": "class EulerSolver {\n    var stepSize: real;\n    constructor(stepSize: real)\n        requires stepSize > 0.0\n        ensures this.stepSize == stepSize\n    {\n        this.stepSize := stepSize;\n    }\n    method EulerStep(y: real, dydx: real) returns (yNext: real)\n        ensures yNext == y + stepSize * dydx\n    {\n        yNext := y + stepSize * dydx;\n    }\n}\nmethod TestEulerStep()\n{\n    var solver := new EulerSolver(0.1);\n    var y := 1.0;\n    var dydx := 2.0; // dy/dx = 2, simple linear growth\n    var yNext := solver.EulerStep(y, dydx);\n    assert yNext == 1.2; // y + stepSize * dydx = 1.0 + 0.1 * 2.0 = 1.2\n}",
            "parents": [
                "idea_99"
            ],
            "diff": "```\n// BEGIN DAFNY\n\nclass EulerSolver {\n    var stepSize: real;\n\n    constructor(stepSize: real)\n        requires stepSize > 0.0\n        ensures this.stepSize == stepSize\n    {\n        this.stepSize := stepSize;\n    }\n\n    method EulerStep(y: real, dydx: real) returns (yNext: real)\n        ensures yNext == y + stepSize * dydx\n    {\n        yNext := y + stepSize * dydx;\n    }\n}\n\nmethod TestEulerStep()\n{\n    var solver := new EulerSolver(0.1);\n    var y := 1.0;\n    var dydx := 2.0; // dy/dx = 2, simple linear growth\n    var yNext := solver.EulerStep(y, dydx);\n    assert yNext == 1.2; // y + stepSize * dydx = 1.0 + 0.1 * 2.0 = 1.2\n}\n\n// END DAFNY\n```"
        },
        {
            "id": "node_117",
            "type": "program",
            "content": "module LongestCommonSubsequence {\n  method LongestCommonSubsequenceLength(a: seq<char>, b: seq<char>) returns (length: int)\n    ensures 0 <= length <= |a| && 0 <= length <= |b|\n    ensures length == (if |a| == 0 || |b| == 0 then 0 else length)\n  {\n    var m := |a|;\n    var n := |b|;\n    var dp := new int[m + 1, n + 1];\n    for i := 0 to m {\n      for j := 0 to n {\n        if i == 0 || j == 0 {\n          dp[i, j] := 0;\n        } else if a[i - 1] == b[j - 1] {\n          dp[i, j] := dp[i - 1, j - 1] + 1;\n        } else {\n          dp[i, j] := if dp[i - 1, j] > dp[i, j - 1] then dp[i - 1, j] else dp[i, j - 1];\n        }\n      }\n    }\n    length := dp[m, n];\n  }\n}",
            "parents": [
                "idea_37"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\nmodule LongestCommonSubsequence {\n  method LongestCommonSubsequenceLength(a: seq<char>, b: seq<char>) returns (length: int)\n    ensures 0 <= length <= |a| && 0 <= length <= |b|\n    ensures length == (if |a| == 0 || |b| == 0 then 0 else length)\n  {\n    var m := |a|;\n    var n := |b|;\n    var dp := new int[m + 1, n + 1];\n\n    for i := 0 to m {\n      for j := 0 to n {\n        if i == 0 || j == 0 {\n          dp[i, j] := 0;\n        } else if a[i - 1] == b[j - 1] {\n          dp[i, j] := dp[i - 1, j - 1] + 1;\n        } else {\n          dp[i, j] := if dp[i - 1, j] > dp[i, j - 1] then dp[i - 1, j] else dp[i, j - 1];\n        }\n      }\n    }\n    length := dp[m, n];\n  }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_118",
            "type": "program",
            "content": "class Employee {\n    var hoursWorked: int;\n    var payRate: int;\n    constructor(hoursWorked: int, payRate: int)\n        ensures this.hoursWorked == hoursWorked && this.payRate == payRate\n    {\n        this.hoursWorked := hoursWorked;\n        this.payRate := payRate;\n    }\n    method CalculateSalary() returns (salary: int)\n        ensures salary == hoursWorked * payRate\n    {\n        salary := hoursWorked * payRate;\n    }\n}\nmethod TestCalculateSalaryWithZeroHours()\n{\n    var e := new Employee(0, 20);\n    var salary := e.CalculateSalary();\n    assert salary == 0;\n}\nmethod TestCalculateSalaryWithRegularHours()\n{\n    var e := new Employee(40, 15);\n    var salary := e.CalculateSalary();\n    assert salary == 600;\n}",
            "parents": [
                "idea_56"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\nclass Employee {\n    var hoursWorked: int;\n    var payRate: int;\n\n    constructor(hoursWorked: int, payRate: int)\n        ensures this.hoursWorked == hoursWorked && this.payRate == payRate\n    {\n        this.hoursWorked := hoursWorked;\n        this.payRate := payRate;\n    }\n\n    method CalculateSalary() returns (salary: int)\n        ensures salary == hoursWorked * payRate\n    {\n        salary := hoursWorked * payRate;\n    }\n}\n\nmethod TestCalculateSalaryWithZeroHours()\n{\n    var e := new Employee(0, 20);\n    var salary := e.CalculateSalary();\n    assert salary == 0;\n}\n\nmethod TestCalculateSalaryWithRegularHours()\n{\n    var e := new Employee(40, 15);\n    var salary := e.CalculateSalary();\n    assert salary == 600;\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_119",
            "type": "program",
            "content": "class CurrencyConverter {\n    var exchangeRate: real;\n    constructor(rate: real)\n        requires rate > 0.0\n        ensures this.exchangeRate == rate\n    {\n        this.exchangeRate := rate;\n    }\n    method Convert(amount: real) returns (convertedAmount: real)\n        requires amount >= 0.0\n        ensures convertedAmount == amount * exchangeRate\n    {\n        convertedAmount := amount * exchangeRate;\n    }\n}\nmethod TestCurrencyConverter()\n{\n    var converter := new CurrencyConverter(1.2);\n    var result := converter.Convert(100.0);\n    assert result == 120.0; // 100 * 1.2 = 120\n    result := converter.Convert(50.0);\n    assert result == 60.0; // 50 * 1.2 = 60\n}",
            "parents": [
                "idea_88"
            ],
            "diff": "```\n// BEGIN DAFNY\nclass CurrencyConverter {\n    var exchangeRate: real;\n\n    constructor(rate: real)\n        requires rate > 0.0\n        ensures this.exchangeRate == rate\n    {\n        this.exchangeRate := rate;\n    }\n\n    method Convert(amount: real) returns (convertedAmount: real)\n        requires amount >= 0.0\n        ensures convertedAmount == amount * exchangeRate\n    {\n        convertedAmount := amount * exchangeRate;\n    }\n}\n\nmethod TestCurrencyConverter()\n{\n    var converter := new CurrencyConverter(1.2);\n    var result := converter.Convert(100.0);\n    assert result == 120.0; // 100 * 1.2 = 120\n\n    result := converter.Convert(50.0);\n    assert result == 60.0; // 50 * 1.2 = 60\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_120",
            "type": "program",
            "content": "class NavigationSystem {\n    var distances: map<(string, string), int>;\n    constructor()\n        ensures distances == map[]\n    {\n        distances := map[];\n    }\n    method AddRoute(city1: string, city2: string, distance: int)\n        requires distance > 0\n        ensures distances[(city1, city2)] == distance\n        ensures distances[(city2, city1)] == distance\n    {\n        distances := distances[(city1, city2) := distance];\n        distances := distances[(city2, city1) := distance];\n    }\n    method ShortestRoute(city1: string, city2: string) returns (shortest: int)\n        requires city1 != city2\n        ensures shortest == distances[(city1, city2)]\n    {\n        if (city1, city2) in distances {\n            shortest := distances[(city1, city2)];\n        } else {\n            shortest := -1; // Indicates no direct route\n        }\n    }\n}\nmethod TestNavigationSystem()\n{\n    var nav := new NavigationSystem();\n    nav.AddRoute(\"A\", \"B\", 10);\n    nav.AddRoute(\"B\", \"C\", 15);\n    var shortest := nav.ShortestRoute(\"A\", \"B\");\n    assert shortest == 10; // Direct route exists\n    shortest := nav.ShortestRoute(\"A\", \"C\");\n    assert shortest == -1; // No direct route\n}",
            "parents": [
                "idea_94"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\nclass NavigationSystem {\n    var distances: map<(string, string), int>;\n\n    constructor()\n        ensures distances == map[]\n    {\n        distances := map[];\n    }\n\n    method AddRoute(city1: string, city2: string, distance: int)\n        requires distance > 0\n        ensures distances[(city1, city2)] == distance\n        ensures distances[(city2, city1)] == distance\n    {\n        distances := distances[(city1, city2) := distance];\n        distances := distances[(city2, city1) := distance];\n    }\n\n    method ShortestRoute(city1: string, city2: string) returns (shortest: int)\n        requires city1 != city2\n        ensures shortest == distances[(city1, city2)]\n    {\n        if (city1, city2) in distances {\n            shortest := distances[(city1, city2)];\n        } else {\n            shortest := -1; // Indicates no direct route\n        }\n    }\n}\n\nmethod TestNavigationSystem()\n{\n    var nav := new NavigationSystem();\n    nav.AddRoute(\"A\", \"B\", 10);\n    nav.AddRoute(\"B\", \"C\", 15);\n    var shortest := nav.ShortestRoute(\"A\", \"B\");\n    assert shortest == 10; // Direct route exists\n    shortest := nav.ShortestRoute(\"A\", \"C\");\n    assert shortest == -1; // No direct route\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_121",
            "type": "program",
            "content": "class KnapsackSolver {\n    method MaxValue(weights: array<int>, values: array<int>, capacity: int) returns (maxValue: int)\n        requires weights.Length == values.Length\n        requires capacity >= 0\n        ensures maxValue >= 0\n    {\n        var n := weights.Length;\n        var dp := new int[n + 1, capacity + 1];\n        for i := 0 to n {\n            for w := 0 to capacity {\n                if i == 0 || w == 0 {\n                    dp[i, w] := 0;\n                } else if weights[i - 1] <= w {\n                    dp[i, w] := max(dp[i - 1, w], values[i - 1] + dp[i - 1, w - weights[i - 1]]);\n                } else {\n                    dp[i, w] := dp[i - 1, w];\n                }\n            }\n        }\n        maxValue := dp[n, capacity];\n    }\n    function max(a: int, b: int): int\n        ensures max(a, b) == (if a > b then a else b)\n    {\n        if a > b then a else b\n    }\n}",
            "parents": [
                "idea_45"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\nclass KnapsackSolver {\n    method MaxValue(weights: array<int>, values: array<int>, capacity: int) returns (maxValue: int)\n        requires weights.Length == values.Length\n        requires capacity >= 0\n        ensures maxValue >= 0\n    {\n        var n := weights.Length;\n        var dp := new int[n + 1, capacity + 1];\n\n        for i := 0 to n {\n            for w := 0 to capacity {\n                if i == 0 || w == 0 {\n                    dp[i, w] := 0;\n                } else if weights[i - 1] <= w {\n                    dp[i, w] := max(dp[i - 1, w], values[i - 1] + dp[i - 1, w - weights[i - 1]]);\n                } else {\n                    dp[i, w] := dp[i - 1, w];\n                }\n            }\n        }\n        maxValue := dp[n, capacity];\n    }\n\n    function max(a: int, b: int): int\n        ensures max(a, b) == (if a > b then a else b)\n    {\n        if a > b then a else b\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_122",
            "type": "program",
            "content": "class RecommendationSystem {\n    method Recommend(preferences: array<int>, items: array<int>) returns (suggestions: seq<int>)\n        requires preferences.Length == items.Length\n        ensures |suggestions| <= preferences.Length\n    {\n        var n := preferences.Length;\n        var recommendedItems := new bool[n];\n        suggestions := [];\n        for i := 0 to n - 1 {\n            if preferences[i] > 0 {\n                recommendedItems[i] := true;\n            }\n        }\n        for i := 0 to n - 1 {\n            if recommendedItems[i] {\n                suggestions := suggestions + [items[i]];\n            }\n        }\n    }\n}",
            "parents": [
                "idea_78"
            ],
            "diff": "```\n// BEGIN DAFNY\nclass RecommendationSystem {\n    method Recommend(preferences: array<int>, items: array<int>) returns (suggestions: seq<int>)\n        requires preferences.Length == items.Length\n        ensures |suggestions| <= preferences.Length\n    {\n        var n := preferences.Length;\n        var recommendedItems := new bool[n];\n        suggestions := [];\n\n        for i := 0 to n - 1 {\n            if preferences[i] > 0 {\n                recommendedItems[i] := true;\n            }\n        }\n\n        for i := 0 to n - 1 {\n            if recommendedItems[i] {\n                suggestions := suggestions + [items[i]];\n            }\n        }\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_123",
            "type": "program",
            "content": "class PayrollSystem {\n    method CalculateSalary(hoursWorked: int, payRate: int) returns (salary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        ensures salary >= 0\n    {\n        salary := hoursWorked * payRate;\n    }\n    method CalculateOvertimeSalary(hoursWorked: int, payRate: int, overtimeRate: int) returns (totalSalary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        requires overtimeRate >= payRate\n        ensures totalSalary >= 0\n    {\n        var regularHours := if hoursWorked > 40 then 40 else hoursWorked;\n        var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n        var regularSalary := regularHours * payRate;\n        var overtimeSalary := overtimeHours * overtimeRate;\n        totalSalary := regularSalary + overtimeSalary;\n    }\n}",
            "parents": [
                "idea_56"
            ],
            "diff": "```\n// BEGIN DAFNY\n\nclass PayrollSystem {\n    method CalculateSalary(hoursWorked: int, payRate: int) returns (salary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        ensures salary >= 0\n    {\n        salary := hoursWorked * payRate;\n    }\n\n    method CalculateOvertimeSalary(hoursWorked: int, payRate: int, overtimeRate: int) returns (totalSalary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        requires overtimeRate >= payRate\n        ensures totalSalary >= 0\n    {\n        var regularHours := if hoursWorked > 40 then 40 else hoursWorked;\n        var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n        var regularSalary := regularHours * payRate;\n        var overtimeSalary := overtimeHours * overtimeRate;\n        totalSalary := regularSalary + overtimeSalary;\n    }\n}\n\n// END DAFNY\n```"
        },
        {
            "id": "node_124",
            "type": "program",
            "content": "class SimpleChatBot {\n    var responses: map<string, string>;\n    constructor() {\n        responses := map[\n            \"hello\" := \"Hi there!\",\n            \"how are you\" := \"I'm just a bot, but I'm doing great!\",\n            \"bye\" := \"Goodbye!\"\n        ];\n    }\n    method GetResponse(input: string) returns (response: string)\n        ensures response == if input in responses then responses[input] else \"I don't understand.\"\n    {\n        if input in responses {\n            response := responses[input];\n        } else {\n            response := \"I don't understand.\";\n        }\n    }\n}",
            "parents": [
                "idea_92"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\n\nclass SimpleChatBot {\n    var responses: map<string, string>;\n\n    constructor() {\n        responses := map[\n            \"hello\" := \"Hi there!\",\n            \"how are you\" := \"I'm just a bot, but I'm doing great!\",\n            \"bye\" := \"Goodbye!\"\n        ];\n    }\n\n    method GetResponse(input: string) returns (response: string)\n        ensures response == if input in responses then responses[input] else \"I don't understand.\"\n    {\n        if input in responses {\n            response := responses[input];\n        } else {\n            response := \"I don't understand.\";\n        }\n    }\n}\n\n// END DAFNY\n```"
        },
        {
            "id": "node_125",
            "type": "program",
            "content": "class Recipe {\n    var name: string;\n    var ingredients: seq<string>;\n    constructor(name: string, ingredients: seq<string>)\n        ensures this.name == name\n        ensures this.ingredients == ingredients\n    {\n        this.name := name;\n        this.ingredients := ingredients;\n    }\n    method GetIngredients() returns (ingList: seq<string>)\n        ensures ingList == ingredients\n    {\n        ingList := ingredients;\n    }\n}\nmethod TestRecipe()\n{\n    var pancake := new Recipe(\"Pancake\", [\"Flour\", \"Eggs\", \"Milk\", \"Sugar\"]);\n    var ingredients := pancake.GetIngredients();\n    assert ingredients == [\"Flour\", \"Eggs\", \"Milk\", \"Sugar\"];\n}",
            "parents": [
                "idea_48"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\nclass Recipe {\n    var name: string;\n    var ingredients: seq<string>;\n\n    constructor(name: string, ingredients: seq<string>)\n        ensures this.name == name\n        ensures this.ingredients == ingredients\n    {\n        this.name := name;\n        this.ingredients := ingredients;\n    }\n\n    method GetIngredients() returns (ingList: seq<string>)\n        ensures ingList == ingredients\n    {\n        ingList := ingredients;\n    }\n}\n\nmethod TestRecipe()\n{\n    var pancake := new Recipe(\"Pancake\", [\"Flour\", \"Eggs\", \"Milk\", \"Sugar\"]);\n    var ingredients := pancake.GetIngredients();\n    assert ingredients == [\"Flour\", \"Eggs\", \"Milk\", \"Sugar\"];\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_126",
            "type": "program",
            "content": "class Point {\n    var x: int;\n    var y: int;\n    constructor(x: int, y: int)\n        ensures this.x == x && this.y == y\n    {\n        this.x := x;\n        this.y := y;\n    }\n}\nmethod CrossProduct(p1: Point, p2: Point, p3: Point) returns (result: int)\n    ensures result == (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x)\n{\n    result := (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x);\n}\nmethod TestCrossProduct()\n{\n    var p1 := new Point(0, 0);\n    var p2 := new Point(1, 1);\n    var p3 := new Point(2, 2);\n    var result := CrossProduct(p1, p2, p3);\n    assert result == 0; // Collinear points\n    var p4 := new Point(0, 0);\n    var p5 := new Point(1, 0);\n    var p6 := new Point(0, 1);\n    result := CrossProduct(p4, p5, p6);\n    assert result == 1; // Counter-clockwise turn\n}",
            "parents": [
                "idea_55"
            ],
            "diff": "```\n// BEGIN DAFNY\nclass Point {\n    var x: int;\n    var y: int;\n\n    constructor(x: int, y: int)\n        ensures this.x == x && this.y == y\n    {\n        this.x := x;\n        this.y := y;\n    }\n}\n\nmethod CrossProduct(p1: Point, p2: Point, p3: Point) returns (result: int)\n    ensures result == (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x)\n{\n    result := (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x);\n}\n\nmethod TestCrossProduct()\n{\n    var p1 := new Point(0, 0);\n    var p2 := new Point(1, 1);\n    var p3 := new Point(2, 2);\n    var result := CrossProduct(p1, p2, p3);\n    assert result == 0; // Collinear points\n\n    var p4 := new Point(0, 0);\n    var p5 := new Point(1, 0);\n    var p6 := new Point(0, 1);\n    result := CrossProduct(p4, p5, p6);\n    assert result == 1; // Counter-clockwise turn\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_127",
            "type": "program",
            "content": "class BasicLoginSystem {\n    var storedUsername: string;\n    var storedPassword: string;\n    constructor(username: string, password: string) \n        requires username != \"\" && password != \"\"\n    {\n        storedUsername := username;\n        storedPassword := password;\n    }\n    method Authenticate(inputUsername: string, inputPassword: string) returns (isAuthenticated: bool)\n        ensures isAuthenticated == (inputUsername == storedUsername && inputPassword == storedPassword)\n    {\n        if inputUsername == storedUsername && inputPassword == storedPassword {\n            isAuthenticated := true;\n        } else {\n            isAuthenticated := false;\n        }\n    }\n}",
            "parents": [
                "idea_40"
            ],
            "diff": "```\n// BEGIN DAFNY\n\nclass BasicLoginSystem {\n    var storedUsername: string;\n    var storedPassword: string;\n\n    constructor(username: string, password: string) \n        requires username != \"\" && password != \"\"\n    {\n        storedUsername := username;\n        storedPassword := password;\n    }\n\n    method Authenticate(inputUsername: string, inputPassword: string) returns (isAuthenticated: bool)\n        ensures isAuthenticated == (inputUsername == storedUsername && inputPassword == storedPassword)\n    {\n        if inputUsername == storedUsername && inputPassword == storedPassword {\n            isAuthenticated := true;\n        } else {\n            isAuthenticated := false;\n        }\n    }\n}\n\n// END DAFNY\n```"
        },
        {
            "id": "node_128",
            "type": "program",
            "content": "class Employee {\n    var hoursWorked: int;\n    var payRate: int;\n    constructor(hoursWorked: int, payRate: int)\n        ensures this.hoursWorked == hoursWorked && this.payRate == payRate\n    {\n        this.hoursWorked := hoursWorked;\n        this.payRate := payRate;\n    }\n    method CalculateSalary() returns (salary: int)\n        ensures salary == hoursWorked * payRate\n    {\n        salary := hoursWorked * payRate;\n    }\n}\nmethod TestCalculateSalaryWithOvertime()\n{\n    var e := new Employee(45, 20);\n    var salary := e.CalculateSalary();\n    assert salary == 900;\n}",
            "parents": [
                "node_118"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 15\nmethod TestCalculateSalaryWithOvertime()\n{\n    var e := new Employee(45, 20);\n    var salary := e.CalculateSalary();\n    assert salary == 900;\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_129",
            "type": "program",
            "content": "class Geometry {\n    method AreRectanglesColliding(x1: int, y1: int, w1: int, h1: int, x2: int, y2: int, w2: int, h2: int) returns (colliding: bool)\n        requires w1 > 0 && h1 > 0 && w2 > 0 && h2 > 0\n        ensures colliding == ((x1 < x2 + w2) && (x2 < x1 + w1) && (y1 < y2 + h2) && (y2 < y1 + h1))\n    {\n        colliding := (x1 < x2 + w2) && (x2 < x1 + w1) && (y1 < y2 + h2) && (y2 < y1 + h1);\n    }\n}",
            "parents": [
                "idea_77"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\n\nclass Geometry {\n    method AreRectanglesColliding(x1: int, y1: int, w1: int, h1: int, x2: int, y2: int, w2: int, h2: int) returns (colliding: bool)\n        requires w1 > 0 && h1 > 0 && w2 > 0 && h2 > 0\n        ensures colliding == ((x1 < x2 + w2) && (x2 < x1 + w1) && (y1 < y2 + h2) && (y2 < y1 + h1))\n    {\n        colliding := (x1 < x2 + w2) && (x2 < x1 + w1) && (y1 < y2 + h2) && (y2 < y1 + h1);\n    }\n}\n\n// END DAFNY\n```\n"
        },
        {
            "id": "node_130",
            "type": "program",
            "content": "class Matrix2x2 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    constructor(a: int, b: int, c: int, d: int)\n        ensures this.a == a && this.b == b && this.c == c && this.d == d\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n    }\n    method Determinant() returns (det: int)\n        ensures det == a * d - b * c\n    {\n        det := a * d - b * c;\n    }\n}\nmethod TestDeterminantWithNegativeMatrix()\n{\n    var m := new Matrix2x2(-1, -2, -3, -4);\n    var det := m.Determinant();\n    assert det == -2; // (-1)*(-4) - (-2)*(-3) = 4 - 6 = -2\n}",
            "parents": [
                "node_107"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 19\nmethod TestDeterminantWithNegativeMatrix()\n{\n    var m := new Matrix2x2(-1, -2, -3, -4);\n    var det := m.Determinant();\n    assert det == -2; // (-1)*(-4) - (-2)*(-3) = 4 - 6 = -2\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_131",
            "type": "program",
            "content": "class EulerSolver {\n    var stepSize: real;\n    constructor(stepSize: real)\n        requires stepSize > 0.0\n        ensures this.stepSize == stepSize\n    {\n        this.stepSize := stepSize;\n    }\n    method EulerStep(y: real, dydx: real) returns (yNext: real)\n        ensures yNext == y + stepSize * dydx\n    {\n        yNext := y + stepSize * dydx;\n    }\n}\nmethod TestEulerStepWithNegativeSlope()\n{\n    var solver := new EulerSolver(0.1);\n    var y := 1.0;\n    var dydx := -2.0; // dy/dx = -2, simple linear decay\n    var yNext := solver.EulerStep(y, dydx);\n    assert yNext == 0.8; // y + stepSize * dydx = 1.0 + 0.1 * (-2.0) = 0.8\n}",
            "parents": [
                "node_116"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 14\nmethod TestEulerStepWithNegativeSlope()\n{\n    var solver := new EulerSolver(0.1);\n    var y := 1.0;\n    var dydx := -2.0; // dy/dx = -2, simple linear decay\n    var yNext := solver.EulerStep(y, dydx);\n    assert yNext == 0.8; // y + stepSize * dydx = 1.0 + 0.1 * (-2.0) = 0.8\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_132",
            "type": "program",
            "content": "class PayrollSystem {\n    var hourlyRate: real;\n    var hoursWorked: real;\n    constructor(rate: real, hours: real)\n        requires rate >= 0.0 && hours >= 0.0\n    {\n        hourlyRate := rate;\n        hoursWorked := hours;\n    }\n    method CalculateSalary() returns (salary: real)\n        ensures salary == hourlyRate * hoursWorked\n    {\n        salary := hourlyRate * hoursWorked;\n    }\n}",
            "parents": [
                "idea_56"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\nclass PayrollSystem {\n    var hourlyRate: real;\n    var hoursWorked: real;\n\n    constructor(rate: real, hours: real)\n        requires rate >= 0.0 && hours >= 0.0\n    {\n        hourlyRate := rate;\n        hoursWorked := hours;\n    }\n\n    method CalculateSalary() returns (salary: real)\n        ensures salary == hourlyRate * hoursWorked\n    {\n        salary := hourlyRate * hoursWorked;\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_133",
            "type": "program",
            "content": "class VotingSystem {\n    var votes: array<int>;\n    constructor(n: int)\n        requires n > 0\n        ensures votes.Length == n\n        ensures forall i :: 0 <= i < n ==> votes[i] == 0\n    {\n        votes := new int[n];\n    }\n    method CastVote(candidate: int)\n        requires 0 <= candidate < votes.Length\n        modifies votes\n        ensures votes[candidate] == old(votes[candidate]) + 1\n    {\n        votes[candidate] := votes[candidate] + 1;\n    }\n    method GetWinner() returns (winner: int)\n        requires votes.Length > 0\n        ensures 0 <= winner < votes.Length\n        ensures forall i :: 0 <= i < votes.Length ==> votes[winner] >= votes[i]\n    {\n        var maxVotes := votes[0];\n        winner := 0;\n        for i := 1 to votes.Length - 1 {\n            if votes[i] > maxVotes {\n                maxVotes := votes[i];\n                winner := i;\n            }\n        }\n    }\n}",
            "parents": [
                "idea_32"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\n\nclass VotingSystem {\n    var votes: array<int>;\n\n    constructor(n: int)\n        requires n > 0\n        ensures votes.Length == n\n        ensures forall i :: 0 <= i < n ==> votes[i] == 0\n    {\n        votes := new int[n];\n    }\n\n    method CastVote(candidate: int)\n        requires 0 <= candidate < votes.Length\n        modifies votes\n        ensures votes[candidate] == old(votes[candidate]) + 1\n    {\n        votes[candidate] := votes[candidate] + 1;\n    }\n\n    method GetWinner() returns (winner: int)\n        requires votes.Length > 0\n        ensures 0 <= winner < votes.Length\n        ensures forall i :: 0 <= i < votes.Length ==> votes[winner] >= votes[i]\n    {\n        var maxVotes := votes[0];\n        winner := 0;\n        for i := 1 to votes.Length - 1 {\n            if votes[i] > maxVotes {\n                maxVotes := votes[i];\n                winner := i;\n            }\n        }\n    }\n}\n\n// END DAFNY\n```"
        },
        {
            "id": "node_134",
            "type": "program",
            "content": "class Task {\n    var priority: int;\n    var description: string;\n    constructor(priority: int, description: string)\n        ensures this.priority == priority && this.description == description\n    {\n        this.priority := priority;\n        this.description := description;\n    }\n}\nclass TaskScheduler {\n    var tasks: seq<Task>;\n    constructor()\n        ensures tasks == []\n    {\n        tasks := [];\n    }\n    method AddTask(t: Task)\n        modifies tasks\n        ensures tasks == old(tasks) + [t]\n    {\n        tasks := tasks + [t];\n    }\n    method GetNextTask() returns (nextTask: Task?)\n        requires |tasks| > 0\n        ensures nextTask != null ==> forall t: Task :: t in tasks ==> nextTask.priority <= t.priority\n    {\n        var highestPriority := tasks[0].priority;\n        var index := 0;\n        for i := 1 to |tasks| {\n            if tasks[i].priority < highestPriority {\n                highestPriority := tasks[i].priority;\n                index := i;\n            }\n        }\n        nextTask := tasks[index];\n    }\n}\nmethod TestTaskScheduler()\n{\n    var scheduler := new TaskScheduler();\n    var task1 := new Task(2, \"Write report\");\n    var task2 := new Task(1, \"Fix bug\");\n    scheduler.AddTask(task1);\n    scheduler.AddTask(task2);\n    var nextTask := scheduler.GetNextTask();\n    assert nextTask != null && nextTask.description == \"Fix bug\";\n}",
            "parents": [
                "idea_64"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\nclass Task {\n    var priority: int;\n    var description: string;\n\n    constructor(priority: int, description: string)\n        ensures this.priority == priority && this.description == description\n    {\n        this.priority := priority;\n        this.description := description;\n    }\n}\n\nclass TaskScheduler {\n    var tasks: seq<Task>;\n\n    constructor()\n        ensures tasks == []\n    {\n        tasks := [];\n    }\n\n    method AddTask(t: Task)\n        modifies tasks\n        ensures tasks == old(tasks) + [t]\n    {\n        tasks := tasks + [t];\n    }\n\n    method GetNextTask() returns (nextTask: Task?)\n        requires |tasks| > 0\n        ensures nextTask != null ==> forall t: Task :: t in tasks ==> nextTask.priority <= t.priority\n    {\n        var highestPriority := tasks[0].priority;\n        var index := 0;\n        for i := 1 to |tasks| {\n            if tasks[i].priority < highestPriority {\n                highestPriority := tasks[i].priority;\n                index := i;\n            }\n        }\n        nextTask := tasks[index];\n    }\n}\n\nmethod TestTaskScheduler()\n{\n    var scheduler := new TaskScheduler();\n    var task1 := new Task(2, \"Write report\");\n    var task2 := new Task(1, \"Fix bug\");\n    scheduler.AddTask(task1);\n    scheduler.AddTask(task2);\n    var nextTask := scheduler.GetNextTask();\n    assert nextTask != null && nextTask.description == \"Fix bug\";\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_135",
            "type": "program",
            "content": "class Matrix2x2 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    constructor(a: int, b: int, c: int, d: int)\n        ensures this.a == a && this.b == b && this.c == c && this.d == d\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n    }\n    method Transpose() returns (transposed: Matrix2x2)\n        ensures transposed.a == a && transposed.b == c && transposed.c == b && transposed.d == d\n    {\n        transposed := new Matrix2x2(a, c, b, d);\n    }\n}\nmethod TestTransposeWithGeneralMatrix()\n{\n    var m := new Matrix2x2(1, 2, 3, 4);\n    var transposed := m.Transpose();\n    assert transposed.a == 1 && transposed.b == 3 && transposed.c == 2 && transposed.d == 4;\n}",
            "parents": [
                "node_108"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 19\nmethod TestTransposeWithGeneralMatrix()\n{\n    var m := new Matrix2x2(1, 2, 3, 4);\n    var transposed := m.Transpose();\n    assert transposed.a == 1 && transposed.b == 3 && transposed.c == 2 && transposed.d == 4;\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_136",
            "type": "program",
            "content": "class QuadraticSolver {\n    method SolveQuadratic(a: real, b: real, c: real) returns (roots: seq<real>)\n        requires a != 0.0\n        ensures |roots| <= 2\n        ensures forall r :: r in roots ==> a * r * r + b * r + c == 0.0\n    {\n        var discriminant := b * b - 4.0 * a * c;\n        if discriminant < 0.0 {\n            roots := [];\n        } else if discriminant == 0.0 {\n            var root := -b / (2.0 * a);\n            roots := [root];\n        } else {\n            var sqrtDisc := sqrt(discriminant);\n            var root1 := (-b + sqrtDisc) / (2.0 * a);\n            var root2 := (-b - sqrtDisc) / (2.0 * a);\n            roots := [root1, root2];\n        }\n    }\n    function sqrt(x: real): real\n        requires x >= 0.0\n        ensures 0.0 <= sqrt(x)\n        ensures sqrt(x) * sqrt(x) == x\n    {\n        // Placeholder implementation for square root\n        x\n    }\n}",
            "parents": [
                "idea_63"
            ],
            "diff": "```\n// BEGIN DAFNY\nclass QuadraticSolver {\n    method SolveQuadratic(a: real, b: real, c: real) returns (roots: seq<real>)\n        requires a != 0.0\n        ensures |roots| <= 2\n        ensures forall r :: r in roots ==> a * r * r + b * r + c == 0.0\n    {\n        var discriminant := b * b - 4.0 * a * c;\n        if discriminant < 0.0 {\n            roots := [];\n        } else if discriminant == 0.0 {\n            var root := -b / (2.0 * a);\n            roots := [root];\n        } else {\n            var sqrtDisc := sqrt(discriminant);\n            var root1 := (-b + sqrtDisc) / (2.0 * a);\n            var root2 := (-b - sqrtDisc) / (2.0 * a);\n            roots := [root1, root2];\n        }\n    }\n\n    function sqrt(x: real): real\n        requires x >= 0.0\n        ensures 0.0 <= sqrt(x)\n        ensures sqrt(x) * sqrt(x) == x\n    {\n        // Placeholder implementation for square root\n        x\n    }\n}\n// END DAFNY\n```\n\nThis program defines a `QuadraticSolver` class with a method `SolveQuadratic` that calculates the roots of a quadratic equation. It includes a placeholder `sqrt` function, which is assumed to correctly compute the square root of a non-negative real number. The method ensures that the roots satisfy the quadratic equation and handles cases based on the discriminant value."
        },
        {
            "id": "node_137",
            "type": "program",
            "content": "method GCD(a: nat, b: nat) returns (gcd: nat)\n    requires a > 0 && b > 0\n    ensures gcd > 0\n    ensures a % gcd == 0 && b % gcd == 0\n    ensures forall d: nat :: d > 0 && a % d == 0 && b % d == 0 ==> gcd >= d\n{\n    var x := a;\n    var y := b;\n    while y != 0\n        invariant x > 0\n        invariant y >= 0\n        invariant x % gcd == 0 && b % gcd == 0\n    {\n        var temp := y;\n        y := x % y;\n        x := temp;\n    }\n    gcd := x;\n}",
            "parents": [
                "idea_0"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\nmethod GCD(a: nat, b: nat) returns (gcd: nat)\n    requires a > 0 && b > 0\n    ensures gcd > 0\n    ensures a % gcd == 0 && b % gcd == 0\n    ensures forall d: nat :: d > 0 && a % d == 0 && b % d == 0 ==> gcd >= d\n{\n    var x := a;\n    var y := b;\n    while y != 0\n        invariant x > 0\n        invariant y >= 0\n        invariant x % gcd == 0 && b % gcd == 0\n    {\n        var temp := y;\n        y := x % y;\n        x := temp;\n    }\n    gcd := x;\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_138",
            "type": "program",
            "content": "class Thermostat {\n    var currentTemperature: int;\n    var setpoint: int;\n    constructor(initTemp: int, setpoint: int)\n        ensures this.currentTemperature == initTemp\n        ensures this.setpoint == setpoint\n    {\n        this.currentTemperature := initTemp;\n        this.setpoint := setpoint;\n    }\n    method AdjustTemperature() returns (adjustment: int)\n        ensures adjustment == if currentTemperature < setpoint then 1 else if currentTemperature > setpoint then -1 else 0\n    {\n        if currentTemperature < setpoint {\n            adjustment := 1;\n        } else if currentTemperature > setpoint {\n            adjustment := -1;\n        } else {\n            adjustment := 0;\n        }\n    }\n}\nmethod TestThermostatAdjustment()\n{\n    var thermostat := new Thermostat(18, 20);\n    var adjustment := thermostat.AdjustTemperature();\n    assert adjustment == 1; // Should increase temperature\n    thermostat := new Thermostat(22, 20);\n    adjustment := thermostat.AdjustTemperature();\n    assert adjustment == -1; // Should decrease temperature\n    thermostat := new Thermostat(20, 20);\n    adjustment := thermostat.AdjustTemperature();\n    assert adjustment == 0; // No adjustment needed\n}",
            "parents": [
                "idea_42"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\nclass Thermostat {\n    var currentTemperature: int;\n    var setpoint: int;\n\n    constructor(initTemp: int, setpoint: int)\n        ensures this.currentTemperature == initTemp\n        ensures this.setpoint == setpoint\n    {\n        this.currentTemperature := initTemp;\n        this.setpoint := setpoint;\n    }\n\n    method AdjustTemperature() returns (adjustment: int)\n        ensures adjustment == if currentTemperature < setpoint then 1 else if currentTemperature > setpoint then -1 else 0\n    {\n        if currentTemperature < setpoint {\n            adjustment := 1;\n        } else if currentTemperature > setpoint {\n            adjustment := -1;\n        } else {\n            adjustment := 0;\n        }\n    }\n}\n\nmethod TestThermostatAdjustment()\n{\n    var thermostat := new Thermostat(18, 20);\n    var adjustment := thermostat.AdjustTemperature();\n    assert adjustment == 1; // Should increase temperature\n\n    thermostat := new Thermostat(22, 20);\n    adjustment := thermostat.AdjustTemperature();\n    assert adjustment == -1; // Should decrease temperature\n\n    thermostat := new Thermostat(20, 20);\n    adjustment := thermostat.AdjustTemperature();\n    assert adjustment == 0; // No adjustment needed\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_139",
            "type": "program",
            "content": "class Matrix3x3 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    var e: int;\n    var f: int;\n    var g: int;\n    var h: int;\n    var i: int;\n    constructor(a: int, b: int, c: int, d: int, e: int, f: int, g: int, h: int, i: int)\n        ensures this.a == a && this.b == b && this.c == c\n        ensures this.d == d && this.e == e && this.f == f\n        ensures this.g == g && this.h == h && this.i == i\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n        this.e := e;\n        this.f := f;\n        this.g := g;\n        this.h := h;\n        this.i := i;\n    }\n    method Transpose() returns (transposed: Matrix3x3)\n        ensures transposed.a == a && transposed.b == d && transposed.c == g\n        ensures transposed.d == b && transposed.e == e && transposed.f == h\n        ensures transposed.g == c && transposed.h == f && transposed.i == i\n    {\n        transposed := new Matrix3x3(a, d, g, b, e, h, c, f, i);\n    }\n}\nmethod TestTransposeWith3x3Matrix()\n{\n    var m := new Matrix3x3(1, 2, 3, 4, 5, 6, 7, 8, 9);\n    var transposed := m.Transpose();\n    assert transposed.a == 1 && transposed.b == 4 && transposed.c == 7;\n    assert transposed.d == 2 && transposed.e == 5 && transposed.f == 8;\n    assert transposed.g == 3 && transposed.h == 6 && transposed.i == 9;\n}",
            "parents": [
                "idea_23"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\nclass Matrix3x3 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    var e: int;\n    var f: int;\n    var g: int;\n    var h: int;\n    var i: int;\n\n    constructor(a: int, b: int, c: int, d: int, e: int, f: int, g: int, h: int, i: int)\n        ensures this.a == a && this.b == b && this.c == c\n        ensures this.d == d && this.e == e && this.f == f\n        ensures this.g == g && this.h == h && this.i == i\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n        this.e := e;\n        this.f := f;\n        this.g := g;\n        this.h := h;\n        this.i := i;\n    }\n\n    method Transpose() returns (transposed: Matrix3x3)\n        ensures transposed.a == a && transposed.b == d && transposed.c == g\n        ensures transposed.d == b && transposed.e == e && transposed.f == h\n        ensures transposed.g == c && transposed.h == f && transposed.i == i\n    {\n        transposed := new Matrix3x3(a, d, g, b, e, h, c, f, i);\n    }\n}\n\nmethod TestTransposeWith3x3Matrix()\n{\n    var m := new Matrix3x3(1, 2, 3, 4, 5, 6, 7, 8, 9);\n    var transposed := m.Transpose();\n    assert transposed.a == 1 && transposed.b == 4 && transposed.c == 7;\n    assert transposed.d == 2 && transposed.e == 5 && transposed.f == 8;\n    assert transposed.g == 3 && transposed.h == 6 && transposed.i == 9;\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_140",
            "type": "program",
            "content": "class ImageProcessor {\n    method Convolve(image: array2<int>, kernel: array2<int>) returns (result: array2<int>)\n        requires image.Length0 > 0 && image.Length1 > 0\n        requires kernel.Length0 > 0 && kernel.Length1 > 0\n        requires kernel.Length0 % 2 == 1 && kernel.Length1 % 2 == 1\n        ensures result.Length0 == image.Length0\n        ensures result.Length1 == image.Length1\n    {\n        var rows := image.Length0;\n        var cols := image.Length1;\n        var kRows := kernel.Length0;\n        var kCols := kernel.Length1;\n        var kCenterX := kCols / 2;\n        var kCenterY := kRows / 2;\n        result := new int[rows, cols];\n        for i := 0 to rows - 1 {\n            for j := 0 to cols - 1 {\n                var sum := 0;\n                for m := 0 to kRows - 1 {\n                    for n := 0 to kCols - 1 {\n                        var ii := i + m - kCenterY;\n                        var jj := j + n - kCenterX;\n                        if 0 <= ii < rows && 0 <= jj < cols {\n                            sum := sum + image[ii, jj] * kernel[m, n];\n                        }\n                    }\n                }\n                result[i, j] := sum;\n            }\n        }\n    }\n}",
            "parents": [
                "idea_59"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\n\nclass ImageProcessor {\n    method Convolve(image: array2<int>, kernel: array2<int>) returns (result: array2<int>)\n        requires image.Length0 > 0 && image.Length1 > 0\n        requires kernel.Length0 > 0 && kernel.Length1 > 0\n        requires kernel.Length0 % 2 == 1 && kernel.Length1 % 2 == 1\n        ensures result.Length0 == image.Length0\n        ensures result.Length1 == image.Length1\n    {\n        var rows := image.Length0;\n        var cols := image.Length1;\n        var kRows := kernel.Length0;\n        var kCols := kernel.Length1;\n        var kCenterX := kCols / 2;\n        var kCenterY := kRows / 2;\n\n        result := new int[rows, cols];\n\n        for i := 0 to rows - 1 {\n            for j := 0 to cols - 1 {\n                var sum := 0;\n                for m := 0 to kRows - 1 {\n                    for n := 0 to kCols - 1 {\n                        var ii := i + m - kCenterY;\n                        var jj := j + n - kCenterX;\n                        if 0 <= ii < rows && 0 <= jj < cols {\n                            sum := sum + image[ii, jj] * kernel[m, n];\n                        }\n                    }\n                }\n                result[i, j] := sum;\n            }\n        }\n    }\n}\n\n// END DAFNY\n```\n"
        },
        {
            "id": "node_141",
            "type": "program",
            "content": "class PayrollSystem {\n    method CalculateSalary(hoursWorked: int, payRate: int) returns (salary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        ensures salary >= 0\n    {\n        salary := hoursWorked * payRate;\n    }\n    method CalculateOvertimeSalary(hoursWorked: int, payRate: int, overtimeRate: int) returns (totalSalary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        requires overtimeRate >= payRate\n        ensures totalSalary >= 0\n    {\n        var regularHours := if hoursWorked > 40 then 40 else hoursWorked;\n        var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n        var regularSalary := regularHours * payRate;\n        var overtimeSalary := overtimeHours * overtimeRate;\n        totalSalary := regularSalary + overtimeSalary;\n    }\n}\n    method CalculateBonus(hoursWorked: int, payRate: int, bonusRate: int) returns (bonus: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        requires bonusRate >= 0\n        ensures bonus >= 0\n    {\n        var bonusHours := if hoursWorked > 50 then hoursWorked - 50 else 0;\n        bonus := bonusHours * bonusRate;\n    }",
            "parents": [
                "node_123"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 21\n    method CalculateBonus(hoursWorked: int, payRate: int, bonusRate: int) returns (bonus: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        requires bonusRate >= 0\n        ensures bonus >= 0\n    {\n        var bonusHours := if hoursWorked > 50 then hoursWorked - 50 else 0;\n        bonus := bonusHours * bonusRate;\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_142",
            "type": "program",
            "content": "class Book {\n    var title: string;\n    var isCheckedOut: bool;\n    constructor(title: string)\n        ensures this.title == title && !this.isCheckedOut\n    {\n        this.title := title;\n        this.isCheckedOut := false;\n    }\n    method CheckOut()\n        requires !isCheckedOut\n        ensures isCheckedOut\n    {\n        isCheckedOut := true;\n    }\n    method ReturnBook()\n        requires isCheckedOut\n        ensures !isCheckedOut\n    {\n        isCheckedOut := false;\n    }\n}\nclass Library {\n    var books: seq<Book>;\n    constructor()\n        ensures books == []\n    {\n        books := [];\n    }\n    method AddBook(b: Book)\n        ensures books == old(books) + [b]\n    {\n        books := books + [b];\n    }\n    method CheckOutBook(title: string) returns (success: bool)\n        ensures success ==> exists b: Book :: b in books && b.title == title && b.isCheckedOut\n        ensures !success ==> forall b: Book :: b in books && b.title == title ==> !b.isCheckedOut\n    {\n        success := false;\n        for i := 0 to |books| - 1\n            invariant 0 <= i <= |books|\n            invariant forall j: int :: 0 <= j < i ==> books[j].title != title || books[j].isCheckedOut\n        {\n            if books[i].title == title && !books[i].isCheckedOut {\n                books[i].CheckOut();\n                success := true;\n                return;\n            }\n        }\n    }\n}",
            "parents": [
                "idea_52"
            ],
            "diff": "```\n// BEGIN DAFNY\nclass Book {\n    var title: string;\n    var isCheckedOut: bool;\n\n    constructor(title: string)\n        ensures this.title == title && !this.isCheckedOut\n    {\n        this.title := title;\n        this.isCheckedOut := false;\n    }\n\n    method CheckOut()\n        requires !isCheckedOut\n        ensures isCheckedOut\n    {\n        isCheckedOut := true;\n    }\n\n    method ReturnBook()\n        requires isCheckedOut\n        ensures !isCheckedOut\n    {\n        isCheckedOut := false;\n    }\n}\n\nclass Library {\n    var books: seq<Book>;\n\n    constructor()\n        ensures books == []\n    {\n        books := [];\n    }\n\n    method AddBook(b: Book)\n        ensures books == old(books) + [b]\n    {\n        books := books + [b];\n    }\n\n    method CheckOutBook(title: string) returns (success: bool)\n        ensures success ==> exists b: Book :: b in books && b.title == title && b.isCheckedOut\n        ensures !success ==> forall b: Book :: b in books && b.title == title ==> !b.isCheckedOut\n    {\n        success := false;\n        for i := 0 to |books| - 1\n            invariant 0 <= i <= |books|\n            invariant forall j: int :: 0 <= j < i ==> books[j].title != title || books[j].isCheckedOut\n        {\n            if books[i].title == title && !books[i].isCheckedOut {\n                books[i].CheckOut();\n                success := true;\n                return;\n            }\n        }\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_143",
            "type": "program",
            "content": "class GameOfLife {\n    var grid: array2<bool>;\n    constructor(rows: nat, cols: nat)\n        requires rows > 0 && cols > 0\n        ensures grid.Length0 == rows && grid.Length1 == cols\n    {\n        grid := new bool[rows, cols];\n    }\n    method SetCellAlive(row: nat, col: nat)\n        requires 0 <= row < grid.Length0 && 0 <= col < grid.Length1\n        ensures grid[row, col] == true\n    {\n        grid[row, col] := true;\n    }\n    method CountAliveNeighbors(row: nat, col: nat) returns (count: nat)\n        requires 0 <= row < grid.Length0 && 0 <= col < grid.Length1\n        ensures count <= 8\n    {\n        count := 0;\n        for i := -1 to 1 {\n            for j := -1 to 1 {\n                if i == 0 && j == 0 {\n                    continue;\n                }\n                var newRow := row + i;\n                var newCol := col + j;\n                if 0 <= newRow < grid.Length0 && 0 <= newCol < grid.Length1 {\n                    if grid[newRow, newCol] {\n                        count := count + 1;\n                    }\n                }\n            }\n        }\n    }\n}\nmethod TestGameOfLife()\n{\n    var game := new GameOfLife(3, 3);\n    game.SetCellAlive(1, 1);\n    game.SetCellAlive(0, 1);\n    game.SetCellAlive(1, 0);\n    var count := game.CountAliveNeighbors(1, 1);\n    assert count == 2; // The cell (1,1) has two alive neighbors\n}",
            "parents": [
                "idea_38"
            ],
            "diff": "```\n// BEGIN DAFNY\nclass GameOfLife {\n    var grid: array2<bool>;\n\n    constructor(rows: nat, cols: nat)\n        requires rows > 0 && cols > 0\n        ensures grid.Length0 == rows && grid.Length1 == cols\n    {\n        grid := new bool[rows, cols];\n    }\n\n    method SetCellAlive(row: nat, col: nat)\n        requires 0 <= row < grid.Length0 && 0 <= col < grid.Length1\n        ensures grid[row, col] == true\n    {\n        grid[row, col] := true;\n    }\n\n    method CountAliveNeighbors(row: nat, col: nat) returns (count: nat)\n        requires 0 <= row < grid.Length0 && 0 <= col < grid.Length1\n        ensures count <= 8\n    {\n        count := 0;\n        for i := -1 to 1 {\n            for j := -1 to 1 {\n                if i == 0 && j == 0 {\n                    continue;\n                }\n                var newRow := row + i;\n                var newCol := col + j;\n                if 0 <= newRow < grid.Length0 && 0 <= newCol < grid.Length1 {\n                    if grid[newRow, newCol] {\n                        count := count + 1;\n                    }\n                }\n            }\n        }\n    }\n}\n\nmethod TestGameOfLife()\n{\n    var game := new GameOfLife(3, 3);\n    game.SetCellAlive(1, 1);\n    game.SetCellAlive(0, 1);\n    game.SetCellAlive(1, 0);\n    var count := game.CountAliveNeighbors(1, 1);\n    assert count == 2; // The cell (1,1) has two alive neighbors\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_144",
            "type": "program",
            "content": "class MatrixOperations {\n    method Transpose(matrix: array2<int>) returns (transposed: array2<int>)\n        requires matrix.Length0 > 0 && matrix.Length1 > 0\n        ensures transposed.Length0 == matrix.Length1 && transposed.Length1 == matrix.Length0\n        ensures forall i: int, j: int :: 0 <= i < matrix.Length0 && 0 <= j < matrix.Length1 ==> transposed[j, i] == matrix[i, j]\n    {\n        var rows := matrix.Length0;\n        var cols := matrix.Length1;\n        transposed := new int[cols, rows];\n        for i := 0 to rows - 1 {\n            for j := 0 to cols - 1 {\n                transposed[j, i] := matrix[i, j];\n            }\n        }\n    }\n}",
            "parents": [
                "idea_71"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\n\nclass MatrixOperations {\n    method Transpose(matrix: array2<int>) returns (transposed: array2<int>)\n        requires matrix.Length0 > 0 && matrix.Length1 > 0\n        ensures transposed.Length0 == matrix.Length1 && transposed.Length1 == matrix.Length0\n        ensures forall i: int, j: int :: 0 <= i < matrix.Length0 && 0 <= j < matrix.Length1 ==> transposed[j, i] == matrix[i, j]\n    {\n        var rows := matrix.Length0;\n        var cols := matrix.Length1;\n        transposed := new int[cols, rows];\n        for i := 0 to rows - 1 {\n            for j := 0 to cols - 1 {\n                transposed[j, i] := matrix[i, j];\n            }\n        }\n    }\n}\n\n// END DAFNY\n```\n"
        },
        {
            "id": "node_145",
            "type": "program",
            "content": "module PalindromeChecker {\n  method IsPalindrome(s: string) returns (isPalin: bool)\n    ensures isPalin <==> (forall i :: 0 <= i < |s| / 2 ==> s[i] == s[|s| - i - 1])\n  {\n    var n := |s|;\n    isPalin := true;\n    for i := 0 to n / 2 - 1 {\n      if s[i] != s[n - i - 1] {\n        isPalin := false;\n        break;\n      }\n    }\n  }\n}",
            "parents": [
                "idea_8"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\nmodule PalindromeChecker {\n\n  method IsPalindrome(s: string) returns (isPalin: bool)\n    ensures isPalin <==> (forall i :: 0 <= i < |s| / 2 ==> s[i] == s[|s| - i - 1])\n  {\n    var n := |s|;\n    isPalin := true;\n    for i := 0 to n / 2 - 1 {\n      if s[i] != s[n - i - 1] {\n        isPalin := false;\n        break;\n      }\n    }\n  }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_146",
            "type": "program",
            "content": "class Matrix2x2 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    constructor(a: int, b: int, c: int, d: int)\n        ensures this.a == a && this.b == b && this.c == c && this.d == d\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n    }\n    method Transpose() returns (transposed: Matrix2x2)\n        ensures transposed.a == a && transposed.b == c && transposed.c == b && transposed.d == d\n    {\n        transposed := new Matrix2x2(a, c, b, d);\n    }\n}\nmethod TestTransposeWithIdentityMatrix()\n{\n    var identity := new Matrix2x2(1, 0, 0, 1);\n    var transposed := identity.Transpose();\n    assert transposed.a == 1 && transposed.b == 0 && transposed.c == 0 && transposed.d == 1;\n}",
            "parents": [
                "node_135"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 19\nmethod TestTransposeWithIdentityMatrix()\n{\n    var identity := new Matrix2x2(1, 0, 0, 1);\n    var transposed := identity.Transpose();\n    assert transposed.a == 1 && transposed.b == 0 && transposed.c == 0 && transposed.d == 1;\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_147",
            "type": "program",
            "content": "class LinearInequalitySolver {\n    method SolveInequality(a: int, b: int, c: int) returns (x: int)\n        requires a != 0\n        ensures a * x + b <= c\n    {\n        // A simple approach to find a solution for ax + b <= c\n        x := (c - b) / a;\n        if a * x + b > c {\n            x := x - 1;\n        }\n    }\n    method VerifySolution(a: int, b: int, c: int, x: int) returns (isValid: bool)\n        ensures isValid == (a * x + b <= c)\n    {\n        isValid := a * x + b <= c;\n    }\n}",
            "parents": [
                "idea_87"
            ],
            "diff": "```\n// BEGIN DAFNY\n\nclass LinearInequalitySolver {\n    method SolveInequality(a: int, b: int, c: int) returns (x: int)\n        requires a != 0\n        ensures a * x + b <= c\n    {\n        // A simple approach to find a solution for ax + b <= c\n        x := (c - b) / a;\n        if a * x + b > c {\n            x := x - 1;\n        }\n    }\n\n    method VerifySolution(a: int, b: int, c: int, x: int) returns (isValid: bool)\n        ensures isValid == (a * x + b <= c)\n    {\n        isValid := a * x + b <= c;\n    }\n}\n\n// END DAFNY\n```\n\nThis small Dafny program defines a class `LinearInequalitySolver` with two methods. The `SolveInequality` method attempts to find an integer solution `x` for the inequality `ax + b <= c`, assuming `a` is non-zero. The `VerifySolution` method checks if a given `x` satisfies the inequality. This program provides a basic framework for solving and verifying linear inequalities."
        },
        {
            "id": "node_148",
            "type": "program",
            "content": "class QuadraticEquation {\n    var a: real;\n    var b: real;\n    var c: real;\n    constructor(a: real, b: real, c: real)\n        ensures this.a == a && this.b == b && this.c == c\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n    }\n    method HasRealSolutions() returns (hasSolutions: bool)\n        ensures hasSolutions == (b * b - 4.0 * a * c >= 0.0)\n    {\n        hasSolutions := b * b - 4.0 * a * c >= 0.0;\n    }\n    method Discriminant() returns (D: real)\n        ensures D == b * b - 4.0 * a * c\n    {\n        D := b * b - 4.0 * a * c;\n    }\n}\nmethod TestQuadraticEquation()\n{\n    var equation := new QuadraticEquation(1.0, -3.0, 2.0);\n    var hasSolutions := equation.HasRealSolutions();\n    assert hasSolutions == true; // Discriminant is 1, so there are real solutions\n    var D := equation.Discriminant();\n    assert D == 1.0; // b^2 - 4ac = 1\n}",
            "parents": [
                "idea_63"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\nclass QuadraticEquation {\n    var a: real;\n    var b: real;\n    var c: real;\n\n    constructor(a: real, b: real, c: real)\n        ensures this.a == a && this.b == b && this.c == c\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n    }\n\n    method HasRealSolutions() returns (hasSolutions: bool)\n        ensures hasSolutions == (b * b - 4.0 * a * c >= 0.0)\n    {\n        hasSolutions := b * b - 4.0 * a * c >= 0.0;\n    }\n\n    method Discriminant() returns (D: real)\n        ensures D == b * b - 4.0 * a * c\n    {\n        D := b * b - 4.0 * a * c;\n    }\n}\n\nmethod TestQuadraticEquation()\n{\n    var equation := new QuadraticEquation(1.0, -3.0, 2.0);\n    var hasSolutions := equation.HasRealSolutions();\n    assert hasSolutions == true; // Discriminant is 1, so there are real solutions\n\n    var D := equation.Discriminant();\n    assert D == 1.0; // b^2 - 4ac = 1\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_149",
            "type": "program",
            "content": "class SimpleChatBot {\n    var greeting: string;\n    var farewell: string;\n    constructor(greeting: string, farewell: string)\n        ensures this.greeting == greeting && this.farewell == farewell\n    {\n        this.greeting := greeting;\n        this.farewell := farewell;\n    }\n    method RespondToInput(input: string) returns (response: string)\n        ensures response == if input == \"hello\" then greeting\n                           else if input == \"bye\" then farewell\n                           else \"I don't understand\"\n    {\n        if input == \"hello\" {\n            response := greeting;\n        } else if input == \"bye\" {\n            response := farewell;\n        } else {\n            response := \"I don't understand\";\n        }\n    }\n}\nmethod TestChatBotResponses()\n{\n    var bot := new SimpleChatBot(\"Hi there!\", \"Goodbye!\");\n    var response := bot.RespondToInput(\"hello\");\n    assert response == \"Hi there!\"; // Correct response to \"hello\"\n    response := bot.RespondToInput(\"bye\");\n    assert response == \"Goodbye!\"; // Correct response to \"bye\"\n    response := bot.RespondToInput(\"how are you?\");\n    assert response == \"I don't understand\"; // Unrecognized input\n}",
            "parents": [
                "idea_92"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\nclass SimpleChatBot {\n    var greeting: string;\n    var farewell: string;\n\n    constructor(greeting: string, farewell: string)\n        ensures this.greeting == greeting && this.farewell == farewell\n    {\n        this.greeting := greeting;\n        this.farewell := farewell;\n    }\n\n    method RespondToInput(input: string) returns (response: string)\n        ensures response == if input == \"hello\" then greeting\n                           else if input == \"bye\" then farewell\n                           else \"I don't understand\"\n    {\n        if input == \"hello\" {\n            response := greeting;\n        } else if input == \"bye\" {\n            response := farewell;\n        } else {\n            response := \"I don't understand\";\n        }\n    }\n}\n\nmethod TestChatBotResponses()\n{\n    var bot := new SimpleChatBot(\"Hi there!\", \"Goodbye!\");\n    var response := bot.RespondToInput(\"hello\");\n    assert response == \"Hi there!\"; // Correct response to \"hello\"\n\n    response := bot.RespondToInput(\"bye\");\n    assert response == \"Goodbye!\"; // Correct response to \"bye\"\n\n    response := bot.RespondToInput(\"how are you?\");\n    assert response == \"I don't understand\"; // Unrecognized input\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_150",
            "type": "program",
            "content": "class PayrollSystem {\n    method CalculateSalary(hoursWorked: int, payRate: int) returns (salary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        ensures salary >= 0\n    {\n        salary := hoursWorked * payRate;\n    }\n    method CalculateOvertimeSalary(hoursWorked: int, payRate: int, overtimeRate: int) returns (totalSalary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        requires overtimeRate >= payRate\n        ensures totalSalary >= 0\n    {\n        var regularHours := if hoursWorked > 40 then 40 else hoursWorked;\n        var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n        var regularSalary := regularHours * payRate;\n        var overtimeSalary := overtimeHours * overtimeRate;\n        totalSalary := regularSalary + overtimeSalary;\n    }\n}\n    method CalculateBonus(hoursWorked: int, payRate: int, bonusRate: int) returns (bonus: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        requires bonusRate >= 0\n        ensures bonus >= 0\n    {\n        var bonusHours := if hoursWorked > 50 then hoursWorked - 50 else 0;\n        bonus := bonusHours * bonusRate;\n    }",
            "parents": [
                "node_123"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 21\n    method CalculateBonus(hoursWorked: int, payRate: int, bonusRate: int) returns (bonus: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        requires bonusRate >= 0\n        ensures bonus >= 0\n    {\n        var bonusHours := if hoursWorked > 50 then hoursWorked - 50 else 0;\n        bonus := bonusHours * bonusRate;\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_151",
            "type": "program",
            "content": "class Matrix2x2 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    constructor(a: int, b: int, c: int, d: int)\n        ensures this.a == a && this.b == b && this.c == c && this.d == d\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n    }\n    method Transpose() returns (transposed: Matrix2x2)\n        ensures transposed.a == a && transposed.b == c && transposed.c == b && transposed.d == d\n    {\n        transposed := new Matrix2x2(a, c, b, d);\n    }\n}\nmethod TestTransposeWithArbitraryMatrix()\n{\n    var m := new Matrix2x2(2, 3, 4, 5);\n    var transposed := m.Transpose();\n    assert transposed.a == 2 && transposed.b == 4 && transposed.c == 3 && transposed.d == 5;\n}",
            "parents": [
                "node_108"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 19\nmethod TestTransposeWithArbitraryMatrix()\n{\n    var m := new Matrix2x2(2, 3, 4, 5);\n    var transposed := m.Transpose();\n    assert transposed.a == 2 && transposed.b == 4 && transposed.c == 3 && transposed.d == 5;\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_152",
            "type": "program",
            "content": "class Employee {\n    var hoursWorked: int;\n    var payRate: int;\n    constructor(hoursWorked: int, payRate: int)\n        ensures this.hoursWorked == hoursWorked && this.payRate == payRate\n    {\n        this.hoursWorked := hoursWorked;\n        this.payRate := payRate;\n    }\n    method CalculateSalary() returns (salary: int)\n        ensures salary == hoursWorked * payRate\n    {\n        salary := hoursWorked * payRate;\n    }\n}\nmethod TestCalculateSalaryWithOvertime()\n{\n    var e := new Employee(45, 20);\n    var salary := e.CalculateSalary();\n    assert salary == 900;\n}",
            "parents": [
                "node_118"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 15\nmethod TestCalculateSalaryWithOvertime()\n{\n    var e := new Employee(45, 20);\n    var salary := e.CalculateSalary();\n    assert salary == 900;\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_153",
            "type": "program",
            "content": "class Matrix3x3 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    var e: int;\n    var f: int;\n    var g: int;\n    var h: int;\n    var i: int;\n    constructor(a: int, b: int, c: int, d: int, e: int, f: int, g: int, h: int, i: int)\n        ensures this.a == a && this.b == b && this.c == c\n        ensures this.d == d && this.e == e && this.f == f\n        ensures this.g == g && this.h == h && this.i == i\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n        this.e := e;\n        this.f := f;\n        this.g := g;\n        this.h := h;\n        this.i := i;\n    }\n    method Determinant() returns (det: int)\n        ensures det == a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g)\n    {\n        det := a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g);\n    }\n}\nmethod TestDeterminantWithDiagonalMatrix3x3()\n{\n    var m := new Matrix3x3(2, 0, 0, 0, 3, 0, 0, 0, 4);\n    var det := m.Determinant();\n    assert det == 24; // Determinant for diagonal matrix is product of diagonal elements\n}",
            "parents": [
                "node_110"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 31\nmethod TestDeterminantWithDiagonalMatrix3x3()\n{\n    var m := new Matrix3x3(2, 0, 0, 0, 3, 0, 0, 0, 4);\n    var det := m.Determinant();\n    assert det == 24; // Determinant for diagonal matrix is product of diagonal elements\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_154",
            "type": "program",
            "content": "class TowerOfHanoi {\n    var numDisks: int;\n    constructor(numDisks: int)\n        requires numDisks > 0\n        ensures this.numDisks == numDisks\n    {\n        this.numDisks := numDisks;\n    }\n    method SolveHanoi(n: int, source: char, target: char, auxiliary: char)\n        requires n >= 0\n        ensures n == 0 ==> true\n        ensures n > 0 ==> true\n    {\n        if n > 0 {\n            SolveHanoi(n - 1, source, auxiliary, target);\n            PrintMove(source, target);\n            SolveHanoi(n - 1, auxiliary, target, source);\n        }\n    }\n    method PrintMove(from: char, to: char)\n        ensures true\n    {\n        // In a real implementation, this would output the move\n        // For now, we just ensure the method is well-formed\n    }\n}\nmethod TestTowerOfHanoi()\n{\n    var hanoi := new TowerOfHanoi(3);\n    hanoi.SolveHanoi(3, 'A', 'C', 'B');\n    // The solution should move all disks from A to C using B as auxiliary\n}",
            "parents": [
                "idea_6"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\nclass TowerOfHanoi {\n    var numDisks: int;\n\n    constructor(numDisks: int)\n        requires numDisks > 0\n        ensures this.numDisks == numDisks\n    {\n        this.numDisks := numDisks;\n    }\n\n    method SolveHanoi(n: int, source: char, target: char, auxiliary: char)\n        requires n >= 0\n        ensures n == 0 ==> true\n        ensures n > 0 ==> true\n    {\n        if n > 0 {\n            SolveHanoi(n - 1, source, auxiliary, target);\n            PrintMove(source, target);\n            SolveHanoi(n - 1, auxiliary, target, source);\n        }\n    }\n\n    method PrintMove(from: char, to: char)\n        ensures true\n    {\n        // In a real implementation, this would output the move\n        // For now, we just ensure the method is well-formed\n    }\n}\n\nmethod TestTowerOfHanoi()\n{\n    var hanoi := new TowerOfHanoi(3);\n    hanoi.SolveHanoi(3, 'A', 'C', 'B');\n    // The solution should move all disks from A to C using B as auxiliary\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_155",
            "type": "program",
            "content": "class Matrix3x3 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    var e: int;\n    var f: int;\n    var g: int;\n    var h: int;\n    var i: int;\n    constructor(a: int, b: int, c: int, d: int, e: int, f: int, g: int, h: int, i: int)\n        ensures this.a == a && this.b == b && this.c == c\n        ensures this.d == d && this.e == e && this.f == f\n        ensures this.g == g && this.h == h && this.i == i\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n        this.e := e;\n        this.f := f;\n        this.g := g;\n        this.h := h;\n        this.i := i;\n    }\n    method Determinant() returns (det: int)\n        ensures det == a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g)\n    {\n        det := a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g);\n    }\n}\nmethod TestDeterminantWithZeroMatrix3x3()\n{\n    var m := new Matrix3x3(0, 0, 0, 0, 0, 0, 0, 0, 0);\n    var det := m.Determinant();\n    assert det == 0; // 0 determinant for zero matrix\n}\nmethod TestDeterminantWithIdentityMatrix3x3()\n{\n    var m := new Matrix3x3(1, 0, 0, 0, 1, 0, 0, 0, 1);\n    var det := m.Determinant();\n    assert det == 1; // 1 determinant for identity matrix\n}\nmethod TestDeterminantWithDiagonalMatrix3x3()\n{\n    var m := new Matrix3x3(2, 0, 0, 0, 3, 0, 0, 0, 4);\n    var det := m.Determinant();\n    assert det == 24; // Determinant for diagonal matrix is product of diagonal elements\n}\nmethod TestDeterminantWithSingularMatrix3x3()\n{\n    var m := new Matrix3x3(1, 2, 3, 4, 5, 6, 7, 8, 9);\n    var det := m.Determinant();\n    assert det == 0; // Singular matrix has a determinant of 0\n}",
            "parents": [
                "node_110"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 44\nmethod TestDeterminantWithDiagonalMatrix3x3()\n{\n    var m := new Matrix3x3(2, 0, 0, 0, 3, 0, 0, 0, 4);\n    var det := m.Determinant();\n    assert det == 24; // Determinant for diagonal matrix is product of diagonal elements\n}\n\nmethod TestDeterminantWithSingularMatrix3x3()\n{\n    var m := new Matrix3x3(1, 2, 3, 4, 5, 6, 7, 8, 9);\n    var det := m.Determinant();\n    assert det == 0; // Singular matrix has a determinant of 0\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_156",
            "type": "program",
            "content": "class BasicCalculator {\n    method Add(a: int, b: int) returns (sum: int)\n        ensures sum == a + b\n    {\n        sum := a + b;\n    }\n    method Subtract(a: int, b: int) returns (difference: int)\n        ensures difference == a - b\n    {\n        difference := a - b;\n    }\n    method Multiply(a: int, b: int) returns (product: int)\n        ensures product == a * b\n    {\n        product := a * b;\n    }\n    method Divide(a: int, b: int) returns (quotient: int)\n        requires b != 0\n        ensures quotient == a / b\n    {\n        quotient := a / b;\n    }\n}",
            "parents": [
                "idea_34"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\nclass BasicCalculator {\n    method Add(a: int, b: int) returns (sum: int)\n        ensures sum == a + b\n    {\n        sum := a + b;\n    }\n\n    method Subtract(a: int, b: int) returns (difference: int)\n        ensures difference == a - b\n    {\n        difference := a - b;\n    }\n\n    method Multiply(a: int, b: int) returns (product: int)\n        ensures product == a * b\n    {\n        product := a * b;\n    }\n\n    method Divide(a: int, b: int) returns (quotient: int)\n        requires b != 0\n        ensures quotient == a / b\n    {\n        quotient := a / b;\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_157",
            "type": "program",
            "content": "class TournamentBracket {\n    method GenerateBracket(seeds: seq<int>) returns (matchups: seq<(int, int)>)\n        requires |seeds| > 0 && |seeds| % 2 == 0\n        ensures |matchups| == |seeds| / 2\n        ensures forall i :: 0 <= i < |matchups| ==> matchups[i].0 != matchups[i].1\n    {\n        var n := |seeds|;\n        matchups := [];\n        for i := 0 to n / 2 - 1 {\n            var team1 := seeds[i];\n            var team2 := seeds[n - i - 1];\n            matchups := matchups + [(team1, team2)];\n        }\n    }\n}",
            "parents": [
                "idea_96"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\n\nclass TournamentBracket {\n    method GenerateBracket(seeds: seq<int>) returns (matchups: seq<(int, int)>)\n        requires |seeds| > 0 && |seeds| % 2 == 0\n        ensures |matchups| == |seeds| / 2\n        ensures forall i :: 0 <= i < |matchups| ==> matchups[i].0 != matchups[i].1\n    {\n        var n := |seeds|;\n        matchups := [];\n        for i := 0 to n / 2 - 1 {\n            var team1 := seeds[i];\n            var team2 := seeds[n - i - 1];\n            matchups := matchups + [(team1, team2)];\n        }\n    }\n}\n\n// END DAFNY\n```\n"
        },
        {
            "id": "node_158",
            "type": "program",
            "content": "class City {\n    var id: int;\n    constructor(id: int)\n        ensures this.id == id\n    {\n        this.id := id;\n    }\n}\nclass Tour {\n    var cities: seq<City>;\n    constructor(cities: seq<City>)\n        ensures this.cities == cities\n    {\n        this.cities := cities;\n    }\n    method IsValidTour() returns (isValid: bool)\n        ensures isValid == (|cities| > 1 && cities[0] == cities[|cities| - 1])\n    {\n        if |cities| > 1 && cities[0] == cities[|cities| - 1] {\n            isValid := true;\n        } else {\n            isValid := false;\n        }\n    }\n}\nmethod TestTourValidity()\n{\n    var city1 := new City(1);\n    var city2 := new City(2);\n    var city3 := new City(3);\n    var tour := new Tour([city1, city2, city3, city1]);\n    var isValid := tour.IsValidTour();\n    assert isValid; // The tour is valid\n    var invalidTour := new Tour([city1, city2, city3]);\n    isValid := invalidTour.IsValidTour();\n    assert !isValid; // The tour is not valid\n}",
            "parents": [
                "idea_73"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\n\nclass City {\n    var id: int;\n    constructor(id: int)\n        ensures this.id == id\n    {\n        this.id := id;\n    }\n}\n\nclass Tour {\n    var cities: seq<City>;\n    \n    constructor(cities: seq<City>)\n        ensures this.cities == cities\n    {\n        this.cities := cities;\n    }\n\n    method IsValidTour() returns (isValid: bool)\n        ensures isValid == (|cities| > 1 && cities[0] == cities[|cities| - 1])\n    {\n        if |cities| > 1 && cities[0] == cities[|cities| - 1] {\n            isValid := true;\n        } else {\n            isValid := false;\n        }\n    }\n}\n\nmethod TestTourValidity()\n{\n    var city1 := new City(1);\n    var city2 := new City(2);\n    var city3 := new City(3);\n\n    var tour := new Tour([city1, city2, city3, city1]);\n    var isValid := tour.IsValidTour();\n    assert isValid; // The tour is valid\n\n    var invalidTour := new Tour([city1, city2, city3]);\n    isValid := invalidTour.IsValidTour();\n    assert !isValid; // The tour is not valid\n}\n\n// END DAFNY\n```"
        },
        {
            "id": "node_159",
            "type": "program",
            "content": "class LinearInequalitySolver {\n    method SolveInequality(a: int, b: int, c: int) returns (x: int)\n        requires a != 0\n        ensures a * x + b <= c\n    {\n        // A simple approach to find a solution for ax + b <= c\n        x := (c - b) / a;\n        if a * x + b > c {\n            x := x - 1;\n        }\n    }\n    method VerifySolution(a: int, b: int, c: int, x: int) returns (isValid: bool)\n        ensures isValid == (a * x + b <= c)\n    {\n        isValid := a * x + b <= c;\n    }\n}\n    method SolveStrictInequality(a: int, b: int, c: int) returns (x: int)\n        requires a != 0\n        ensures a * x + b < c\n    {\n        // A simple approach to find a solution for ax + b < c\n        x := (c - b) / a;\n        if a * x + b >= c {\n            x := x - 1;\n        }\n    }\n    method VerifyStrictSolution(a: int, b: int, c: int, x: int) returns (isValid: bool)\n        ensures isValid == (a * x + b < c)\n    {\n        isValid := a * x + b < c;\n    }",
            "parents": [
                "node_147"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 17\n    method SolveStrictInequality(a: int, b: int, c: int) returns (x: int)\n        requires a != 0\n        ensures a * x + b < c\n    {\n        // A simple approach to find a solution for ax + b < c\n        x := (c - b) / a;\n        if a * x + b >= c {\n            x := x - 1;\n        }\n    }\n\n    method VerifyStrictSolution(a: int, b: int, c: int, x: int) returns (isValid: bool)\n        ensures isValid == (a * x + b < c)\n    {\n        isValid := a * x + b < c;\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_160",
            "type": "program",
            "content": "class Employee {\n    var hoursWorked: int;\n    var payRate: int;\n    constructor(hoursWorked: int, payRate: int)\n        ensures this.hoursWorked == hoursWorked && this.payRate == payRate\n    {\n        this.hoursWorked := hoursWorked;\n        this.payRate := payRate;\n    }\n    method CalculateSalary() returns (salary: int)\n        ensures salary == hoursWorked * payRate\n    {\n        salary := hoursWorked * payRate;\n    }\n}\nmethod TestCalculateSalaryWithOvertime()\n{\n    var e := new Employee(45, 20);\n    var salary := e.CalculateSalary();\n    assert salary == 900;\n}",
            "parents": [
                "node_118"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 15\nmethod TestCalculateSalaryWithOvertime()\n{\n    var e := new Employee(45, 20);\n    var salary := e.CalculateSalary();\n    assert salary == 900;\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_161",
            "type": "program",
            "content": "class Permutations {\n    method GeneratePermutations(arr: seq<int>) returns (perms: set<seq<int>>)\n        ensures forall p: seq<int> :: p in perms ==> |p| == |arr|\n        ensures forall p: seq<int> :: p in perms ==> multiset(p) == multiset(arr)\n    {\n        perms := {};\n        if |arr| == 0 {\n            perms := perms + {[]};\n        } else {\n            for i := 0 to |arr| - 1 {\n                var rest := arr[..i] + arr[i+1..];\n                var subPerms := GeneratePermutations(rest);\n                perms := perms + set p: seq<int> | p in subPerms :: [arr[i]] + p;\n            }\n        }\n    }\n}",
            "parents": [
                "idea_53"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\nclass Permutations {\n    method GeneratePermutations(arr: seq<int>) returns (perms: set<seq<int>>)\n        ensures forall p: seq<int> :: p in perms ==> |p| == |arr|\n        ensures forall p: seq<int> :: p in perms ==> multiset(p) == multiset(arr)\n    {\n        perms := {};\n        if |arr| == 0 {\n            perms := perms + {[]};\n        } else {\n            for i := 0 to |arr| - 1 {\n                var rest := arr[..i] + arr[i+1..];\n                var subPerms := GeneratePermutations(rest);\n                perms := perms + set p: seq<int> | p in subPerms :: [arr[i]] + p;\n            }\n        }\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_162",
            "type": "program",
            "content": "class Matrix2x2 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    constructor(a: int, b: int, c: int, d: int)\n        ensures this.a == a && this.b == b && this.c == c && this.d == d\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n    }\n    method Determinant() returns (det: int)\n        ensures det == a * d - b * c\n    {\n        det := a * d - b * c;\n    }\n}\nmethod TestDeterminantWithZeroMatrix()\n{\n    var m := new Matrix2x2(0, 0, 0, 0);\n    var det := m.Determinant();\n    assert det == 0; // 0*0 - 0*0 = 0\n}\nmethod TestDeterminantWithIdentityMatrix()\n{\n    var m := new Matrix2x2(1, 0, 0, 1);\n    var det := m.Determinant();\n    assert det == 1; // 1*1 - 0*0 = 1\n}",
            "parents": [
                "node_130"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 19\nmethod TestDeterminantWithZeroMatrix()\n{\n    var m := new Matrix2x2(0, 0, 0, 0);\n    var det := m.Determinant();\n    assert det == 0; // 0*0 - 0*0 = 0\n}\n\nmethod TestDeterminantWithIdentityMatrix()\n{\n    var m := new Matrix2x2(1, 0, 0, 1);\n    var det := m.Determinant();\n    assert det == 1; // 1*1 - 0*0 = 1\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_163",
            "type": "program",
            "content": "class EulerSolver {\n    var stepSize: real;\n    constructor(stepSize: real)\n        requires stepSize > 0.0\n        ensures this.stepSize == stepSize\n    {\n        this.stepSize := stepSize;\n    }\n    method EulerStep(y: real, dydx: real) returns (yNext: real)\n        ensures yNext == y + stepSize * dydx\n    {\n        yNext := y + stepSize * dydx;\n    }\n}\nmethod TestEulerStepWithPositiveSlope()\n{\n    var solver := new EulerSolver(0.1);\n    var y := 1.0;\n    var dydx := 2.0; // dy/dx = 2, simple linear growth\n    var yNext := solver.EulerStep(y, dydx);\n    assert yNext == 1.2; // y + stepSize * dydx = 1.0 + 0.1 * 2.0 = 1.2\n}",
            "parents": [
                "node_131"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 14\nmethod TestEulerStepWithPositiveSlope()\n{\n    var solver := new EulerSolver(0.1);\n    var y := 1.0;\n    var dydx := 2.0; // dy/dx = 2, simple linear growth\n    var yNext := solver.EulerStep(y, dydx);\n    assert yNext == 1.2; // y + stepSize * dydx = 1.0 + 0.1 * 2.0 = 1.2\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_164",
            "type": "program",
            "content": "class Matrix2x2 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    constructor(a: int, b: int, c: int, d: int)\n        ensures this.a == a && this.b == b && this.c == c && this.d == d\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n    }\n    method Determinant() returns (det: int)\n        ensures det == a * d - b * c\n    {\n        det := a * d - b * c;\n    }\n}\nmethod TestDeterminantWithNegativeMatrix()\n{\n    var m := new Matrix2x2(-1, -2, -3, -4);\n    var det := m.Determinant();\n    assert det == -2; // (-1)*(-4) - (-2)*(-3) = 4 - 6 = -2\n}",
            "parents": [
                "node_107"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 19\nmethod TestDeterminantWithNegativeMatrix()\n{\n    var m := new Matrix2x2(-1, -2, -3, -4);\n    var det := m.Determinant();\n    assert det == -2; // (-1)*(-4) - (-2)*(-3) = 4 - 6 = -2\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_165",
            "type": "program",
            "content": "class PayrollSystem {\n    method CalculateSalary(hoursWorked: int, payRate: int) returns (salary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        ensures salary >= 0\n        ensures salary == hoursWorked * payRate\n    {\n        salary := hoursWorked * payRate;\n    }\n    method CalculateOvertimeSalary(hoursWorked: int, payRate: int, overtimeRate: int) returns (totalSalary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        requires overtimeRate >= payRate\n        ensures totalSalary >= 0\n    {\n        var regularHours := if hoursWorked > 40 then 40 else hoursWorked;\n        var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n        var regularSalary := regularHours * payRate;\n        var overtimeSalary := overtimeHours * overtimeRate;\n        totalSalary := regularSalary + overtimeSalary;\n    }\n}",
            "parents": [
                "idea_56"
            ],
            "diff": "```\n// BEGIN DAFNY\n\nclass PayrollSystem {\n    method CalculateSalary(hoursWorked: int, payRate: int) returns (salary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        ensures salary >= 0\n        ensures salary == hoursWorked * payRate\n    {\n        salary := hoursWorked * payRate;\n    }\n\n    method CalculateOvertimeSalary(hoursWorked: int, payRate: int, overtimeRate: int) returns (totalSalary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        requires overtimeRate >= payRate\n        ensures totalSalary >= 0\n    {\n        var regularHours := if hoursWorked > 40 then 40 else hoursWorked;\n        var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n        var regularSalary := regularHours * payRate;\n        var overtimeSalary := overtimeHours * overtimeRate;\n        totalSalary := regularSalary + overtimeSalary;\n    }\n}\n\n// END DAFNY\n```"
        },
        {
            "id": "node_166",
            "type": "program",
            "content": "class EulerSolver {\n    var stepSize: real;\n    constructor(stepSize: real)\n        requires stepSize > 0.0\n        ensures this.stepSize == stepSize\n    {\n        this.stepSize := stepSize;\n    }\n    method EulerStep(y: real, dydx: real) returns (yNext: real)\n        ensures yNext == y + stepSize * dydx\n    {\n        yNext := y + stepSize * dydx;\n    }\n}\nmethod TestEulerStepWithNegativeSlope()\n{\n    var solver := new EulerSolver(0.1);\n    var y := 1.0;\n    var dydx := -2.0; // dy/dx = -2, simple linear decay\n    var yNext := solver.EulerStep(y, dydx);\n    assert yNext == 0.8; // y + stepSize * dydx = 1.0 + 0.1 * (-2.0) = 0.8\n}",
            "parents": [
                "node_116"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 14\nmethod TestEulerStepWithNegativeSlope()\n{\n    var solver := new EulerSolver(0.1);\n    var y := 1.0;\n    var dydx := -2.0; // dy/dx = -2, simple linear decay\n    var yNext := solver.EulerStep(y, dydx);\n    assert yNext == 0.8; // y + stepSize * dydx = 1.0 + 0.1 * (-2.0) = 0.8\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_167",
            "type": "program",
            "content": "class Book {\n    var title: string;\n    var isCheckedOut: bool;\n    constructor(title: string)\n        ensures this.title == title && !this.isCheckedOut\n    {\n        this.title := title;\n        this.isCheckedOut := false;\n    }\n    method Checkout()\n        requires !isCheckedOut\n        modifies this\n        ensures isCheckedOut\n    {\n        isCheckedOut := true;\n    }\n    method Return()\n        requires isCheckedOut\n        modifies this\n        ensures !isCheckedOut\n    {\n        isCheckedOut := false;\n    }\n}\nclass Library {\n    var books: map<string, Book>;\n    constructor()\n        ensures books == map[]\n    {\n        books := map[];\n    }\n    method AddBook(title: string)\n        modifies this\n        ensures books[title].title == title && !books[title].isCheckedOut\n    {\n        var book := new Book(title);\n        books := books[title := book];\n    }\n    method CheckoutBook(title: string) returns (success: bool)\n        requires title in books\n        modifies this\n        ensures success <==> books[title].isCheckedOut\n    {\n        if (!books[title].isCheckedOut) {\n            books[title].Checkout();\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n    method ReturnBook(title: string) returns (success: bool)\n        requires title in books\n        modifies this\n        ensures success <==> !books[title].isCheckedOut\n    {\n        if (books[title].isCheckedOut) {\n            books[title].Return();\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n}",
            "parents": [
                "idea_52"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\nclass Book {\n    var title: string;\n    var isCheckedOut: bool;\n\n    constructor(title: string)\n        ensures this.title == title && !this.isCheckedOut\n    {\n        this.title := title;\n        this.isCheckedOut := false;\n    }\n\n    method Checkout()\n        requires !isCheckedOut\n        modifies this\n        ensures isCheckedOut\n    {\n        isCheckedOut := true;\n    }\n\n    method Return()\n        requires isCheckedOut\n        modifies this\n        ensures !isCheckedOut\n    {\n        isCheckedOut := false;\n    }\n}\n\nclass Library {\n    var books: map<string, Book>;\n\n    constructor()\n        ensures books == map[]\n    {\n        books := map[];\n    }\n\n    method AddBook(title: string)\n        modifies this\n        ensures books[title].title == title && !books[title].isCheckedOut\n    {\n        var book := new Book(title);\n        books := books[title := book];\n    }\n\n    method CheckoutBook(title: string) returns (success: bool)\n        requires title in books\n        modifies this\n        ensures success <==> books[title].isCheckedOut\n    {\n        if (!books[title].isCheckedOut) {\n            books[title].Checkout();\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n\n    method ReturnBook(title: string) returns (success: bool)\n        requires title in books\n        modifies this\n        ensures success <==> !books[title].isCheckedOut\n    {\n        if (books[title].isCheckedOut) {\n            books[title].Return();\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_168",
            "type": "program",
            "content": "module BasicCalculator {\n  method Add(a: int, b: int) returns (sum: int)\n    ensures sum == a + b\n  {\n    sum := a + b;\n  }\n  method Subtract(a: int, b: int) returns (difference: int)\n    ensures difference == a - b\n  {\n    difference := a - b;\n  }\n  method Multiply(a: int, b: int) returns (product: int)\n    ensures product == a * b\n  {\n    product := a * b;\n  }\n  method Divide(a: int, b: int) returns (quotient: int)\n    requires b != 0\n    ensures quotient == a / b\n  {\n    quotient := a / b;\n  }\n}",
            "parents": [
                "idea_34"
            ],
            "diff": "```\n// BEGIN DAFNY\nmodule BasicCalculator {\n  method Add(a: int, b: int) returns (sum: int)\n    ensures sum == a + b\n  {\n    sum := a + b;\n  }\n\n  method Subtract(a: int, b: int) returns (difference: int)\n    ensures difference == a - b\n  {\n    difference := a - b;\n  }\n\n  method Multiply(a: int, b: int) returns (product: int)\n    ensures product == a * b\n  {\n    product := a * b;\n  }\n\n  method Divide(a: int, b: int) returns (quotient: int)\n    requires b != 0\n    ensures quotient == a / b\n  {\n    quotient := a / b;\n  }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_169",
            "type": "program",
            "content": "class LinearInequalitySolver {\n    method SolveInequality(a: int, b: int, c: int) returns (x: int)\n        requires a != 0\n        ensures a * x + b <= c\n    {\n        // A simple approach to find a solution for ax + b <= c\n        x := (c - b) / a;\n        if a * x + b > c {\n            x := x - 1;\n        }\n    }\n    method VerifySolution(a: int, b: int, c: int, x: int) returns (isValid: bool)\n        ensures isValid == (a * x + b <= c)\n    {\n        isValid := a * x + b <= c;\n    }\n}\n    method SolveStrictInequality(a: int, b: int, c: int) returns (x: int)\n        requires a != 0\n        ensures a * x + b < c\n    {\n        // A simple approach to find a solution for ax + b < c\n        x := (c - b) / a;\n        if a * x + b >= c {\n            x := x - 1;\n        }\n    }\n    method VerifyStrictSolution(a: int, b: int, c: int, x: int) returns (isValid: bool)\n        ensures isValid == (a * x + b < c)\n    {\n        isValid := a * x + b < c;\n    }",
            "parents": [
                "node_147"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 17\n    method SolveStrictInequality(a: int, b: int, c: int) returns (x: int)\n        requires a != 0\n        ensures a * x + b < c\n    {\n        // A simple approach to find a solution for ax + b < c\n        x := (c - b) / a;\n        if a * x + b >= c {\n            x := x - 1;\n        }\n    }\n\n    method VerifyStrictSolution(a: int, b: int, c: int, x: int) returns (isValid: bool)\n        ensures isValid == (a * x + b < c)\n    {\n        isValid := a * x + b < c;\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_170",
            "type": "program",
            "content": "class Graph {\n    var edges: map<(int, int), int>\n    constructor() {\n        edges := map[];\n    }\n    method AddEdge(u: int, v: int, weight: int)\n        requires u != v && weight > 0\n    {\n        edges := edges[(u, v) := weight];\n    }\n    method GetWeight(u: int, v: int) returns (weight: int)\n        requires (u, v) in edges\n        ensures weight == edges[(u, v)]\n    {\n        weight := edges[(u, v)];\n    }\n}\nmethod ShortestPath(graph: Graph, start: int, end: int) returns (path: seq<int>, totalWeight: int)\n    requires start != end\n    ensures path[0] == start && path[|path| - 1] == end\n    ensures totalWeight >= 0\n{\n    // This is a placeholder for the actual implementation of Dijkstra's algorithm.\n    // For now, we return an empty path and zero weight.\n    path := [];\n    totalWeight := 0;\n}",
            "parents": [
                "idea_13"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\n\nclass Graph {\n    var edges: map<(int, int), int>\n\n    constructor() {\n        edges := map[];\n    }\n\n    method AddEdge(u: int, v: int, weight: int)\n        requires u != v && weight > 0\n    {\n        edges := edges[(u, v) := weight];\n    }\n\n    method GetWeight(u: int, v: int) returns (weight: int)\n        requires (u, v) in edges\n        ensures weight == edges[(u, v)]\n    {\n        weight := edges[(u, v)];\n    }\n}\n\nmethod ShortestPath(graph: Graph, start: int, end: int) returns (path: seq<int>, totalWeight: int)\n    requires start != end\n    ensures path[0] == start && path[|path| - 1] == end\n    ensures totalWeight >= 0\n{\n    // This is a placeholder for the actual implementation of Dijkstra's algorithm.\n    // For now, we return an empty path and zero weight.\n    path := [];\n    totalWeight := 0;\n}\n\n// END DAFNY\n```\n"
        },
        {
            "id": "node_171",
            "type": "program",
            "content": "class Node {\n    var value: int;\n    var next: Node?;\n    constructor(v: int)\n        ensures this.value == v && this.next == null\n    {\n        value := v;\n        next := null;\n    }\n}\nclass LinkedList {\n    var head: Node?;\n    constructor()\n        ensures head == null\n    {\n        head := null;\n    }\n    method InsertAtHead(v: int)\n        modifies this\n        ensures head != null && head.value == v\n    {\n        var newNode := new Node(v);\n        newNode.next := head;\n        head := newNode;\n    }\n    method DeleteFromHead() returns (success: bool)\n        modifies this\n        ensures success ==> head != null\n    {\n        if (head != null) {\n            head := head.next;\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n}",
            "parents": [
                "idea_4"
            ],
            "diff": "```\n// BEGIN DAFNY\n\nclass Node {\n    var value: int;\n    var next: Node?;\n    \n    constructor(v: int)\n        ensures this.value == v && this.next == null\n    {\n        value := v;\n        next := null;\n    }\n}\n\nclass LinkedList {\n    var head: Node?;\n    \n    constructor()\n        ensures head == null\n    {\n        head := null;\n    }\n    \n    method InsertAtHead(v: int)\n        modifies this\n        ensures head != null && head.value == v\n    {\n        var newNode := new Node(v);\n        newNode.next := head;\n        head := newNode;\n    }\n    \n    method DeleteFromHead() returns (success: bool)\n        modifies this\n        ensures success ==> head != null\n    {\n        if (head != null) {\n            head := head.next;\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n}\n\n// END DAFNY\n```"
        },
        {
            "id": "node_172",
            "type": "program",
            "content": "class Matrix2x2 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    constructor(a: int, b: int, c: int, d: int)\n        ensures this.a == a && this.b == b && this.c == c && this.d == d\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n    }\n    method Determinant() returns (det: int)\n        ensures det == a * d - b * c\n    {\n        det := a * d - b * c;\n    }\n}\nmethod TestDeterminantWithZeroMatrix()\n{\n    var m := new Matrix2x2(0, 0, 0, 0);\n    var det := m.Determinant();\n    assert det == 0; // 0*0 - 0*0 = 0\n}\nmethod TestDeterminantWithIdentityMatrix()\n{\n    var m := new Matrix2x2(1, 0, 0, 1);\n    var det := m.Determinant();\n    assert det == 1; // 1*1 - 0*0 = 1\n}",
            "parents": [
                "node_164"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 19\nmethod TestDeterminantWithZeroMatrix()\n{\n    var m := new Matrix2x2(0, 0, 0, 0);\n    var det := m.Determinant();\n    assert det == 0; // 0*0 - 0*0 = 0\n}\n\nmethod TestDeterminantWithIdentityMatrix()\n{\n    var m := new Matrix2x2(1, 0, 0, 1);\n    var det := m.Determinant();\n    assert det == 1; // 1*1 - 0*0 = 1\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_173",
            "type": "program",
            "content": "class Matrix2x2 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    constructor(a: int, b: int, c: int, d: int)\n        ensures this.a == a && this.b == b && this.c == c && this.d == d\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n    }\n    method Transpose() returns (transposed: Matrix2x2)\n        ensures transposed.a == a && transposed.b == c && transposed.c == b && transposed.d == d\n    {\n        transposed := new Matrix2x2(a, c, b, d);\n    }\n}\nmethod TestTransposeWithArbitraryMatrix()\n{\n    var m := new Matrix2x2(2, 3, 4, 5);\n    var transposed := m.Transpose();\n    assert transposed.a == 2 && transposed.b == 4 && transposed.c == 3 && transposed.d == 5;\n}",
            "parents": [
                "node_108"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 19\nmethod TestTransposeWithArbitraryMatrix()\n{\n    var m := new Matrix2x2(2, 3, 4, 5);\n    var transposed := m.Transpose();\n    assert transposed.a == 2 && transposed.b == 4 && transposed.c == 3 && transposed.d == 5;\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_174",
            "type": "program",
            "content": "class Book {\n    var title: string;\n    var isCheckedOut: bool;\n    constructor(title: string)\n        ensures this.title == title && !this.isCheckedOut\n    {\n        this.title := title;\n        this.isCheckedOut := false;\n    }\n    method Checkout()\n        requires !isCheckedOut\n        modifies this\n        ensures isCheckedOut\n    {\n        isCheckedOut := true;\n    }\n    method Return()\n        requires isCheckedOut\n        modifies this\n        ensures !isCheckedOut\n    {\n        isCheckedOut := false;\n    }\n}\nclass Library {\n    var books: map<string, Book>;\n    var checkedOutCount: nat;\n    constructor()\n        ensures books == map[] && checkedOutCount == 0\n    {\n        books := map[];\n        checkedOutCount := 0;\n    }\n    method AddBook(title: string)\n        modifies this\n        ensures books[title].title == title && !books[title].isCheckedOut && checkedOutCount == old(checkedOutCount)\n    {\n        var book := new Book(title);\n        books := books[title := book];\n    }\n    method CheckoutBook(title: string) returns (success: bool)\n        requires title in books\n        modifies this\n        ensures success <==> books[title].isCheckedOut && checkedOutCount == old(checkedOutCount) + (if success then 1 else 0)\n    {\n        if (!books[title].isCheckedOut) {\n            books[title].Checkout();\n            success := true;\n            checkedOutCount := checkedOutCount + 1;\n        } else {\n            success := false;\n        }\n    }\n    method ReturnBook(title: string) returns (success: bool)\n        requires title in books\n        modifies this\n        ensures success <==> !books[title].isCheckedOut && checkedOutCount == old(checkedOutCount) - (if success then 1 else 0)\n    {\n        if (books[title].isCheckedOut) {\n            books[title].Return();\n            success := true;\n            checkedOutCount := checkedOutCount - 1;\n        } else {\n            success := false;\n        }\n    }\n    method GetCheckedOutCount() returns (count: nat)\n        ensures count == checkedOutCount\n    {\n        return checkedOutCount;\n    }\n}",
            "parents": [
                "node_167"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 24\nclass Library {\n    var books: map<string, Book>;\n    var checkedOutCount: nat;\n\n    constructor()\n        ensures books == map[] && checkedOutCount == 0\n    {\n        books := map[];\n        checkedOutCount := 0;\n    }\n\n    method AddBook(title: string)\n        modifies this\n        ensures books[title].title == title && !books[title].isCheckedOut && checkedOutCount == old(checkedOutCount)\n    {\n        var book := new Book(title);\n        books := books[title := book];\n    }\n\n    method CheckoutBook(title: string) returns (success: bool)\n        requires title in books\n        modifies this\n        ensures success <==> books[title].isCheckedOut && checkedOutCount == old(checkedOutCount) + (if success then 1 else 0)\n    {\n        if (!books[title].isCheckedOut) {\n            books[title].Checkout();\n            success := true;\n            checkedOutCount := checkedOutCount + 1;\n        } else {\n            success := false;\n        }\n    }\n\n    method ReturnBook(title: string) returns (success: bool)\n        requires title in books\n        modifies this\n        ensures success <==> !books[title].isCheckedOut && checkedOutCount == old(checkedOutCount) - (if success then 1 else 0)\n    {\n        if (books[title].isCheckedOut) {\n            books[title].Return();\n            success := true;\n            checkedOutCount := checkedOutCount - 1;\n        } else {\n            success := false;\n        }\n    }\n\n    method GetCheckedOutCount() returns (count: nat)\n        ensures count == checkedOutCount\n    {\n        return checkedOutCount;\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_175",
            "type": "program",
            "content": "class LeapYearChecker {\n    method IsLeapYear(year: int) returns (isLeap: bool)\n        ensures isLeap == ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)\n    {\n        if year % 4 == 0 {\n            if year % 100 == 0 {\n                if year % 400 == 0 {\n                    isLeap := true;\n                } else {\n                    isLeap := false;\n                }\n            } else {\n                isLeap := true;\n            }\n        } else {\n            isLeap := false;\n        }\n    }\n    method VerifyLeapYear(year: int, isLeap: bool) returns (isValid: bool)\n        ensures isValid == (isLeap == ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0))\n    {\n        isValid := isLeap == ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0);\n    }\n}",
            "parents": [
                "idea_26"
            ],
            "diff": "```\n// BEGIN DAFNY\nclass LeapYearChecker {\n    method IsLeapYear(year: int) returns (isLeap: bool)\n        ensures isLeap == ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)\n    {\n        if year % 4 == 0 {\n            if year % 100 == 0 {\n                if year % 400 == 0 {\n                    isLeap := true;\n                } else {\n                    isLeap := false;\n                }\n            } else {\n                isLeap := true;\n            }\n        } else {\n            isLeap := false;\n        }\n    }\n\n    method VerifyLeapYear(year: int, isLeap: bool) returns (isValid: bool)\n        ensures isValid == (isLeap == ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0))\n    {\n        isValid := isLeap == ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0);\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_176",
            "type": "program",
            "content": "class LinearInequalitySolver {\n    method SolveInequality(a: int, b: int, c: int) returns (x: int)\n        requires a != 0\n        ensures a * x + b <= c\n    {\n        // A simple approach to find a solution for ax + b <= c\n        x := (c - b) / a;\n        if a * x + b > c {\n            x := x - 1;\n        }\n    }\n    method VerifySolution(a: int, b: int, c: int, x: int) returns (isValid: bool)\n        ensures isValid == (a * x + b <= c)\n    {\n        isValid := a * x + b <= c;\n    }\n}\n    method SolveInequalityWithStep(a: int, b: int, c: int, step: int) returns (x: int)\n        requires a != 0\n        requires step > 0\n        ensures a * x + b <= c\n    {\n        // A modified approach to find a solution for ax + b <= c with a step\n        x := (c - b) / a;\n        while a * x + b > c {\n            x := x - step;\n        }\n    }\n    method VerifySolutionWithStep(a: int, b: int, c: int, x: int, step: int) returns (isValid: bool)\n        requires step > 0\n        ensures isValid == (a * x + b <= c)\n    {\n        isValid := a * x + b <= c;\n    }",
            "parents": [
                "node_159"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 17\n    method SolveInequalityWithStep(a: int, b: int, c: int, step: int) returns (x: int)\n        requires a != 0\n        requires step > 0\n        ensures a * x + b <= c\n    {\n        // A modified approach to find a solution for ax + b <= c with a step\n        x := (c - b) / a;\n        while a * x + b > c {\n            x := x - step;\n        }\n    }\n\n    method VerifySolutionWithStep(a: int, b: int, c: int, x: int, step: int) returns (isValid: bool)\n        requires step > 0\n        ensures isValid == (a * x + b <= c)\n    {\n        isValid := a * x + b <= c;\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_177",
            "type": "program",
            "content": "module VotingSystem {\n  class Candidate {\n    var name: string;\n    var votes: int;\n    constructor(name: string) {\n      this.name := name;\n      this.votes := 0;\n    }\n    method AddVote() {\n      votes := votes + 1;\n    }\n  }\n  method DetermineWinner(candidates: seq<Candidate>) returns (winner: Candidate)\n    requires |candidates| > 0\n    ensures forall c: Candidate :: c in candidates ==> c.votes <= winner.votes\n  {\n    var maxVotes := -1;\n    var winnerIndex := 0;\n    for i := 0 to |candidates| - 1 {\n      if candidates[i].votes > maxVotes {\n        maxVotes := candidates[i].votes;\n        winnerIndex := i;\n      }\n    }\n    winner := candidates[winnerIndex];\n  }\n}",
            "parents": [
                "idea_32"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\nmodule VotingSystem {\n  class Candidate {\n    var name: string;\n    var votes: int;\n\n    constructor(name: string) {\n      this.name := name;\n      this.votes := 0;\n    }\n\n    method AddVote() {\n      votes := votes + 1;\n    }\n  }\n\n  method DetermineWinner(candidates: seq<Candidate>) returns (winner: Candidate)\n    requires |candidates| > 0\n    ensures forall c: Candidate :: c in candidates ==> c.votes <= winner.votes\n  {\n    var maxVotes := -1;\n    var winnerIndex := 0;\n    for i := 0 to |candidates| - 1 {\n      if candidates[i].votes > maxVotes {\n        maxVotes := candidates[i].votes;\n        winnerIndex := i;\n      }\n    }\n    winner := candidates[winnerIndex];\n  }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_178",
            "type": "program",
            "content": "class Employee {\n    var hoursWorked: int;\n    var payRate: int;\n    constructor(hoursWorked: int, payRate: int)\n        ensures this.hoursWorked == hoursWorked && this.payRate == payRate\n    {\n        this.hoursWorked := hoursWorked;\n        this.payRate := payRate;\n    }\n    method CalculateSalary() returns (salary: int)\n        ensures salary == hoursWorked * payRate\n    {\n        salary := hoursWorked * payRate;\n    }\n}\nmethod TestCalculateSalaryWithOvertime()\n{\n    var e := new Employee(45, 20);\n    var salary := e.CalculateSalary();\n    assert salary == 900;\n}",
            "parents": [
                "node_118"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 15\nmethod TestCalculateSalaryWithOvertime()\n{\n    var e := new Employee(45, 20);\n    var salary := e.CalculateSalary();\n    assert salary == 900;\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_179",
            "type": "program",
            "content": "class CurrencyConverter {\n    var exchangeRate: real;\n    constructor(rate: real)\n        requires rate > 0.0\n        ensures this.exchangeRate == rate\n    {\n        this.exchangeRate := rate;\n    }\n    method Convert(amount: real) returns (convertedAmount: real)\n        requires amount >= 0.0\n        ensures convertedAmount == amount * exchangeRate\n    {\n        convertedAmount := amount * exchangeRate;\n    }\n}\nmethod TestCurrencyConverter()\n{\n    var converter := new CurrencyConverter(1.2);\n    var converted := converter.Convert(100.0);\n    assert converted == 120.0; // 100 * 1.2 = 120\n}",
            "parents": [
                "idea_88"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\nclass CurrencyConverter {\n    var exchangeRate: real;\n\n    constructor(rate: real)\n        requires rate > 0.0\n        ensures this.exchangeRate == rate\n    {\n        this.exchangeRate := rate;\n    }\n\n    method Convert(amount: real) returns (convertedAmount: real)\n        requires amount >= 0.0\n        ensures convertedAmount == amount * exchangeRate\n    {\n        convertedAmount := amount * exchangeRate;\n    }\n}\n\nmethod TestCurrencyConverter()\n{\n    var converter := new CurrencyConverter(1.2);\n    var converted := converter.Convert(100.0);\n    assert converted == 120.0; // 100 * 1.2 = 120\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_180",
            "type": "program",
            "content": "class Hotel {\n    var rooms: array<bool>;\n    constructor(numRooms: int)\n        requires numRooms > 0\n        ensures rooms.Length == numRooms\n        ensures forall i :: 0 <= i < numRooms ==> !rooms[i]\n    {\n        rooms := new bool[numRooms];\n    }\n    method BookRoom(roomNumber: int) returns (success: bool)\n        requires 0 <= roomNumber < rooms.Length\n        ensures success ==> rooms[roomNumber]\n        ensures !success ==> !rooms[roomNumber]\n    {\n        if (!rooms[roomNumber]) {\n            rooms[roomNumber] := true;\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n    method CancelBooking(roomNumber: int) returns (success: bool)\n        requires 0 <= roomNumber < rooms.Length\n        ensures success ==> !rooms[roomNumber]\n        ensures !success ==> rooms[roomNumber]\n    {\n        if (rooms[roomNumber]) {\n            rooms[roomNumber] := false;\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n}",
            "parents": [
                "idea_66"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\n\nclass Hotel {\n    var rooms: array<bool>;\n\n    constructor(numRooms: int)\n        requires numRooms > 0\n        ensures rooms.Length == numRooms\n        ensures forall i :: 0 <= i < numRooms ==> !rooms[i]\n    {\n        rooms := new bool[numRooms];\n    }\n\n    method BookRoom(roomNumber: int) returns (success: bool)\n        requires 0 <= roomNumber < rooms.Length\n        ensures success ==> rooms[roomNumber]\n        ensures !success ==> !rooms[roomNumber]\n    {\n        if (!rooms[roomNumber]) {\n            rooms[roomNumber] := true;\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n\n    method CancelBooking(roomNumber: int) returns (success: bool)\n        requires 0 <= roomNumber < rooms.Length\n        ensures success ==> !rooms[roomNumber]\n        ensures !success ==> rooms[roomNumber]\n    {\n        if (rooms[roomNumber]) {\n            rooms[roomNumber] := false;\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n}\n\n// END DAFNY\n```"
        },
        {
            "id": "node_181",
            "type": "program",
            "content": "class LinearInequalitySolver {\n    method SolveInequality(a: int, b: int, c: int) returns (x: int)\n        requires a != 0\n        ensures a * x + b <= c\n    {\n        // A simple approach to find a solution for ax + b <= c\n        x := (c - b) / a;\n        if a * x + b > c {\n            x := x - 1;\n        }\n    }\n    method VerifySolution(a: int, b: int, c: int, x: int) returns (isValid: bool)\n        ensures isValid == (a * x + b <= c)\n    {\n        isValid := a * x + b <= c;\n    }\n}\n    method SolveInequalityWithOffset(a: int, b: int, c: int, offset: int) returns (x: int)\n        requires a != 0\n        ensures a * x + b <= c + offset\n    {\n        // A simple approach to find a solution for ax + b <= c + offset\n        x := (c + offset - b) / a;\n        if a * x + b > c + offset {\n            x := x - 1;\n        }\n    }\n    method VerifySolutionWithOffset(a: int, b: int, c: int, x: int, offset: int) returns (isValid: bool)\n        ensures isValid == (a * x + b <= c + offset)\n    {\n        isValid := a * x + b <= c + offset;\n    }",
            "parents": [
                "node_159"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 17\n    method SolveInequalityWithOffset(a: int, b: int, c: int, offset: int) returns (x: int)\n        requires a != 0\n        ensures a * x + b <= c + offset\n    {\n        // A simple approach to find a solution for ax + b <= c + offset\n        x := (c + offset - b) / a;\n        if a * x + b > c + offset {\n            x := x - 1;\n        }\n    }\n\n    method VerifySolutionWithOffset(a: int, b: int, c: int, x: int, offset: int) returns (isValid: bool)\n        ensures isValid == (a * x + b <= c + offset)\n    {\n        isValid := a * x + b <= c + offset;\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_182",
            "type": "program",
            "content": "class LinearInequalitySolver {\n    method SolveInequality(a: int, b: int, c: int) returns (x: int)\n        requires a != 0\n        ensures a * x + b <= c\n    {\n        // A simple approach to find a solution for ax + b <= c\n        x := (c - b) / a;\n        if a * x + b > c {\n            x := x - 1;\n        }\n    }\n    method VerifySolution(a: int, b: int, c: int, x: int) returns (isValid: bool)\n        ensures isValid == (a * x + b <= c)\n    {\n        isValid := a * x + b <= c;\n    }\n}\n    method SolveInequalityWithOffset(a: int, b: int, c: int, offset: int) returns (x: int)\n        requires a != 0\n        ensures a * x + b <= c + offset\n    {\n        // A simple approach to find a solution for ax + b <= c + offset\n        x := (c + offset - b) / a;\n        if a * x + b > c + offset {\n            x := x - 1;\n        }\n    }\n    method VerifySolutionWithOffset(a: int, b: int, c: int, x: int, offset: int) returns (isValid: bool)\n        ensures isValid == (a * x + b <= c + offset)\n    {\n        isValid := a * x + b <= c + offset;\n    }",
            "parents": [
                "node_169"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 17\n    method SolveInequalityWithOffset(a: int, b: int, c: int, offset: int) returns (x: int)\n        requires a != 0\n        ensures a * x + b <= c + offset\n    {\n        // A simple approach to find a solution for ax + b <= c + offset\n        x := (c + offset - b) / a;\n        if a * x + b > c + offset {\n            x := x - 1;\n        }\n    }\n\n    method VerifySolutionWithOffset(a: int, b: int, c: int, x: int, offset: int) returns (isValid: bool)\n        ensures isValid == (a * x + b <= c + offset)\n    {\n        isValid := a * x + b <= c + offset;\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_183",
            "type": "program",
            "content": "class Matrix2x2 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    constructor(a: int, b: int, c: int, d: int)\n        ensures this.a == a && this.b == b && this.c == c && this.d == d\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n    }\n    method Transpose() returns (transposed: Matrix2x2)\n        ensures transposed.a == a && transposed.b == c && transposed.c == b && transposed.d == d\n    {\n        transposed := new Matrix2x2(a, c, b, d);\n    }\n}\nmethod TestTransposeWithGeneralMatrix()\n{\n    var m := new Matrix2x2(1, 2, 3, 4);\n    var transposed := m.Transpose();\n    assert transposed.a == 1 && transposed.b == 3 && transposed.c == 2 && transposed.d == 4;\n}",
            "parents": [
                "node_108"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 19\nmethod TestTransposeWithGeneralMatrix()\n{\n    var m := new Matrix2x2(1, 2, 3, 4);\n    var transposed := m.Transpose();\n    assert transposed.a == 1 && transposed.b == 3 && transposed.c == 2 && transposed.d == 4;\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_184",
            "type": "program",
            "content": "class SimpleBlockchain {\n    var chain: seq<nat>;\n    constructor()\n        ensures chain == [0]\n    {\n        chain := [0]; // Genesis block\n    }\n    method AddBlock(previousHash: nat, newHash: nat) returns (success: bool)\n        requires previousHash == chain[|chain| - 1]\n        ensures success ==> chain == old(chain) + [newHash]\n        ensures !success ==> chain == old(chain)\n    {\n        if previousHash == chain[|chain| - 1] {\n            chain := chain + [newHash];\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n    method VerifyChain() returns (isValid: bool)\n        ensures isValid == (forall i :: 1 <= i < |chain| ==> chain[i - 1] == chain[i] - 1)\n    {\n        isValid := true;\n        for i := 1 to |chain| - 1 {\n            if chain[i - 1] != chain[i] - 1 {\n                isValid := false;\n                break;\n            }\n        }\n    }\n}",
            "parents": [
                "idea_46"
            ],
            "diff": "```\n// BEGIN DAFNY\nclass SimpleBlockchain {\n    var chain: seq<nat>;\n    constructor()\n        ensures chain == [0]\n    {\n        chain := [0]; // Genesis block\n    }\n\n    method AddBlock(previousHash: nat, newHash: nat) returns (success: bool)\n        requires previousHash == chain[|chain| - 1]\n        ensures success ==> chain == old(chain) + [newHash]\n        ensures !success ==> chain == old(chain)\n    {\n        if previousHash == chain[|chain| - 1] {\n            chain := chain + [newHash];\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n\n    method VerifyChain() returns (isValid: bool)\n        ensures isValid == (forall i :: 1 <= i < |chain| ==> chain[i - 1] == chain[i] - 1)\n    {\n        isValid := true;\n        for i := 1 to |chain| - 1 {\n            if chain[i - 1] != chain[i] - 1 {\n                isValid := false;\n                break;\n            }\n        }\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_185",
            "type": "program",
            "content": "class Matrix3x3 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    var e: int;\n    var f: int;\n    var g: int;\n    var h: int;\n    var i: int;\n    constructor(a: int, b: int, c: int, d: int, e: int, f: int, g: int, h: int, i: int)\n        ensures this.a == a && this.b == b && this.c == c\n        ensures this.d == d && this.e == e && this.f == f\n        ensures this.g == g && this.h == h && this.i == i\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n        this.e := e;\n        this.f := f;\n        this.g := g;\n        this.h := h;\n        this.i := i;\n    }\n    method Determinant() returns (det: int)\n        ensures det == a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g)\n    {\n        det := a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g);\n    }\n}\nmethod TestDeterminantWithZeroMatrix3x3()\n{\n    var m := new Matrix3x3(0, 0, 0, 0, 0, 0, 0, 0, 0);\n    var det := m.Determinant();\n    assert det == 0; // Determinant for zero matrix should be zero\n}",
            "parents": [
                "node_153"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 31\nmethod TestDeterminantWithZeroMatrix3x3()\n{\n    var m := new Matrix3x3(0, 0, 0, 0, 0, 0, 0, 0, 0);\n    var det := m.Determinant();\n    assert det == 0; // Determinant for zero matrix should be zero\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_186",
            "type": "program",
            "content": "class EulerSolver {\n    var stepSize: real;\n    constructor(stepSize: real)\n        requires stepSize > 0.0\n        ensures this.stepSize == stepSize\n    {\n        this.stepSize := stepSize;\n    }\n    method EulerStep(y: real, dydx: real) returns (yNext: real)\n        ensures yNext == y + stepSize * dydx\n    {\n        yNext := y + stepSize * dydx;\n    }\n}\nmethod TestEulerStepWithZeroSlope()\n{\n    var solver := new EulerSolver(0.1);\n    var y := 1.0;\n    var dydx := 0.0; // dy/dx = 0, no change expected\n    var yNext := solver.EulerStep(y, dydx);\n    assert yNext == 1.0; // y + stepSize * dydx = 1.0 + 0.1 * 0.0 = 1.0\n}",
            "parents": [
                "node_166"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 14\nmethod TestEulerStepWithZeroSlope()\n{\n    var solver := new EulerSolver(0.1);\n    var y := 1.0;\n    var dydx := 0.0; // dy/dx = 0, no change expected\n    var yNext := solver.EulerStep(y, dydx);\n    assert yNext == 1.0; // y + stepSize * dydx = 1.0 + 0.1 * 0.0 = 1.0\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_187",
            "type": "program",
            "content": "class Book {\n    var title: string;\n    var isCheckedOut: bool;\n    constructor(title: string) \n        ensures this.title == title\n        ensures !this.isCheckedOut\n    {\n        this.title := title;\n        this.isCheckedOut := false;\n    }\n    method CheckOut() \n        requires !isCheckedOut\n        modifies this\n        ensures isCheckedOut\n    {\n        isCheckedOut := true;\n    }\n    method ReturnBook() \n        requires isCheckedOut\n        modifies this\n        ensures !isCheckedOut\n    {\n        isCheckedOut := false;\n    }\n}\nclass Library {\n    var books: seq<Book>;\n    constructor() \n        ensures books == []\n    {\n        books := [];\n    }\n    method AddBook(b: Book) \n        modifies this\n        ensures books == old(books) + [b]\n    {\n        books := books + [b];\n    }\n    method CheckOutBook(title: string) returns (success: bool)\n        modifies this\n        ensures success ==> exists b: Book :: b in books && b.title == title && b.isCheckedOut\n        ensures !success ==> forall b: Book :: b in books && b.title == title ==> !b.isCheckedOut\n    {\n        success := false;\n        for i := 0 to |books| - 1 {\n            if books[i].title == title && !books[i].isCheckedOut {\n                books[i].CheckOut();\n                success := true;\n                return;\n            }\n        }\n    }\n    method ReturnBook(title: string) returns (success: bool)\n        modifies this\n        ensures success ==> exists b: Book :: b in books && b.title == title && !b.isCheckedOut\n        ensures !success ==> forall b: Book :: b in books && b.title == title ==> b.isCheckedOut\n    {\n        success := false;\n        for i := 0 to |books| - 1 {\n            if books[i].title == title && books[i].isCheckedOut {\n                books[i].ReturnBook();\n                success := true;\n                return;\n            }\n        }\n    }\n}",
            "parents": [
                "idea_52"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\n\nclass Book {\n    var title: string;\n    var isCheckedOut: bool;\n\n    constructor(title: string) \n        ensures this.title == title\n        ensures !this.isCheckedOut\n    {\n        this.title := title;\n        this.isCheckedOut := false;\n    }\n\n    method CheckOut() \n        requires !isCheckedOut\n        modifies this\n        ensures isCheckedOut\n    {\n        isCheckedOut := true;\n    }\n\n    method ReturnBook() \n        requires isCheckedOut\n        modifies this\n        ensures !isCheckedOut\n    {\n        isCheckedOut := false;\n    }\n}\n\nclass Library {\n    var books: seq<Book>;\n\n    constructor() \n        ensures books == []\n    {\n        books := [];\n    }\n\n    method AddBook(b: Book) \n        modifies this\n        ensures books == old(books) + [b]\n    {\n        books := books + [b];\n    }\n\n    method CheckOutBook(title: string) returns (success: bool)\n        modifies this\n        ensures success ==> exists b: Book :: b in books && b.title == title && b.isCheckedOut\n        ensures !success ==> forall b: Book :: b in books && b.title == title ==> !b.isCheckedOut\n    {\n        success := false;\n        for i := 0 to |books| - 1 {\n            if books[i].title == title && !books[i].isCheckedOut {\n                books[i].CheckOut();\n                success := true;\n                return;\n            }\n        }\n    }\n\n    method ReturnBook(title: string) returns (success: bool)\n        modifies this\n        ensures success ==> exists b: Book :: b in books && b.title == title && !b.isCheckedOut\n        ensures !success ==> forall b: Book :: b in books && b.title == title ==> b.isCheckedOut\n    {\n        success := false;\n        for i := 0 to |books| - 1 {\n            if books[i].title == title && books[i].isCheckedOut {\n                books[i].ReturnBook();\n                success := true;\n                return;\n            }\n        }\n    }\n}\n\n// END DAFNY\n```"
        },
        {
            "id": "node_188",
            "type": "program",
            "content": "class Matrix2x2 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    constructor(a: int, b: int, c: int, d: int)\n        ensures this.a == a && this.b == b && this.c == c && this.d == d\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n    }\n    method Determinant() returns (det: int)\n        ensures det == a * d - b * c\n    {\n        det := a * d - b * c;\n    }\n}\nmethod TestDeterminantWithZeroMatrix()\n{\n    var m := new Matrix2x2(0, 0, 0, 0);\n    var det := m.Determinant();\n    assert det == 0; // 0*0 - 0*0 = 0\n}\nmethod TestDeterminantWithIdentityMatrix()\n{\n    var m := new Matrix2x2(1, 0, 0, 1);\n    var det := m.Determinant();\n    assert det == 1; // 1*1 - 0*0 = 1\n}",
            "parents": [
                "node_130"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 19\nmethod TestDeterminantWithZeroMatrix()\n{\n    var m := new Matrix2x2(0, 0, 0, 0);\n    var det := m.Determinant();\n    assert det == 0; // 0*0 - 0*0 = 0\n}\n\nmethod TestDeterminantWithIdentityMatrix()\n{\n    var m := new Matrix2x2(1, 0, 0, 1);\n    var det := m.Determinant();\n    assert det == 1; // 1*1 - 0*0 = 1\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_189",
            "type": "program",
            "content": "class EulerSolver {\n    var stepSize: real;\n    constructor(stepSize: real)\n        requires stepSize > 0.0\n        ensures this.stepSize == stepSize\n    {\n        this.stepSize := stepSize;\n    }\n    method EulerStep(y: real, dydx: real) returns (yNext: real)\n        ensures yNext == y + stepSize * dydx\n    {\n        yNext := y + stepSize * dydx;\n    }\n}\nmethod TestEulerStepWithNegativeSlope()\n{\n    var solver := new EulerSolver(0.1);\n    var y := 1.0;\n    var dydx := -2.0; // dy/dx = -2, simple linear decay\n    var yNext := solver.EulerStep(y, dydx);\n    assert yNext == 0.8; // y + stepSize * dydx = 1.0 + 0.1 * (-2.0) = 0.8\n}",
            "parents": [
                "node_163"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 14\nmethod TestEulerStepWithNegativeSlope()\n{\n    var solver := new EulerSolver(0.1);\n    var y := 1.0;\n    var dydx := -2.0; // dy/dx = -2, simple linear decay\n    var yNext := solver.EulerStep(y, dydx);\n    assert yNext == 0.8; // y + stepSize * dydx = 1.0 + 0.1 * (-2.0) = 0.8\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_190",
            "type": "program",
            "content": "class Matrix2x2 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    constructor(a: int, b: int, c: int, d: int)\n        ensures this.a == a && this.b == b && this.c == c && this.d == d\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n    }\n    method Determinant() returns (det: int)\n        ensures det == a * d - b * c\n    {\n        det := a * d - b * c;\n    }\n}\nmethod TestDeterminantWithNegativeMatrix()\n{\n    var m := new Matrix2x2(-1, -2, -3, -4);\n    var det := m.Determinant();\n    assert det == -2; // (-1)*(-4) - (-2)*(-3) = 4 - 6 = -2\n}",
            "parents": [
                "node_172"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 19\nmethod TestDeterminantWithNegativeMatrix()\n{\n    var m := new Matrix2x2(-1, -2, -3, -4);\n    var det := m.Determinant();\n    assert det == -2; // (-1)*(-4) - (-2)*(-3) = 4 - 6 = -2\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_191",
            "type": "program",
            "content": "class LinearInequalitiesSolver {\n    method SolveSingleInequality(a: int, b: int, c: int) returns (solution: bool)\n        requires a != 0\n        ensures solution == (c >= b / a)\n    {\n        if a > 0 {\n            solution := c >= b / a;\n        } else {\n            solution := c <= b / a;\n        }\n    }\n    method VerifySolution(a: int, b: int, c: int, x: int) returns (isValid: bool)\n        requires a != 0\n        ensures isValid == (a * x + b <= c)\n    {\n        isValid := a * x + b <= c;\n    }\n}",
            "parents": [
                "idea_87"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\nclass LinearInequalitiesSolver {\n    method SolveSingleInequality(a: int, b: int, c: int) returns (solution: bool)\n        requires a != 0\n        ensures solution == (c >= b / a)\n    {\n        if a > 0 {\n            solution := c >= b / a;\n        } else {\n            solution := c <= b / a;\n        }\n    }\n\n    method VerifySolution(a: int, b: int, c: int, x: int) returns (isValid: bool)\n        requires a != 0\n        ensures isValid == (a * x + b <= c)\n    {\n        isValid := a * x + b <= c;\n    }\n}\n// END DAFNY\n```\n\nThis small Dafny program defines a class `LinearInequalitiesSolver` with two methods. The `SolveSingleInequality` method checks if a given inequality `ax + b <= c` has a solution for `x` when `a` is non-zero. The `VerifySolution` method verifies if a given value `x` satisfies the inequality. This is a basic starting point for solving and verifying linear inequalities."
        },
        {
            "id": "node_192",
            "type": "program",
            "content": "module KnapsackSolver {\n  method Knapsack(values: seq<int>, weights: seq<int>, capacity: int) returns (maxValue: int)\n    requires |values| == |weights|\n    requires capacity >= 0\n    ensures maxValue >= 0\n  {\n    var n := |values|;\n    var dp := new int[capacity + 1];\n    for i := 0 to n - 1 {\n      var v := values[i];\n      var w := weights[i];\n      if w <= capacity {\n        for c := capacity downto w {\n          dp[c] := if dp[c] > dp[c - w] + v then dp[c] else dp[c - w] + v;\n        }\n      }\n    }\n    maxValue := dp[capacity];\n  }\n}",
            "parents": [
                "idea_45"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\nmodule KnapsackSolver {\n  method Knapsack(values: seq<int>, weights: seq<int>, capacity: int) returns (maxValue: int)\n    requires |values| == |weights|\n    requires capacity >= 0\n    ensures maxValue >= 0\n  {\n    var n := |values|;\n    var dp := new int[capacity + 1];\n    \n    for i := 0 to n - 1 {\n      var v := values[i];\n      var w := weights[i];\n      if w <= capacity {\n        for c := capacity downto w {\n          dp[c] := if dp[c] > dp[c - w] + v then dp[c] else dp[c - w] + v;\n        }\n      }\n    }\n    \n    maxValue := dp[capacity];\n  }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_193",
            "type": "program",
            "content": "class VotingSystem {\n    var votes: array<int>;\n    constructor (numCandidates: int)\n        requires numCandidates > 0\n    {\n        votes := new int[numCandidates];\n    }\n    method Vote(candidate: int)\n        requires 0 <= candidate < votes.Length\n        modifies votes\n        ensures votes[candidate] == old(votes[candidate]) + 1\n    {\n        votes[candidate] := votes[candidate] + 1;\n    }\n    method GetWinner() returns (winner: int)\n        requires votes.Length > 0\n        ensures 0 <= winner < votes.Length\n        ensures forall i: int :: 0 <= i < votes.Length ==> votes[winner] >= votes[i]\n    {\n        var maxVotes := votes[0];\n        winner := 0;\n        for i := 1 to votes.Length - 1 {\n            if votes[i] > maxVotes {\n                maxVotes := votes[i];\n                winner := i;\n            }\n        }\n    }\n}",
            "parents": [
                "idea_32"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\nclass VotingSystem {\n    var votes: array<int>;\n\n    constructor (numCandidates: int)\n        requires numCandidates > 0\n    {\n        votes := new int[numCandidates];\n    }\n\n    method Vote(candidate: int)\n        requires 0 <= candidate < votes.Length\n        modifies votes\n        ensures votes[candidate] == old(votes[candidate]) + 1\n    {\n        votes[candidate] := votes[candidate] + 1;\n    }\n\n    method GetWinner() returns (winner: int)\n        requires votes.Length > 0\n        ensures 0 <= winner < votes.Length\n        ensures forall i: int :: 0 <= i < votes.Length ==> votes[winner] >= votes[i]\n    {\n        var maxVotes := votes[0];\n        winner := 0;\n        for i := 1 to votes.Length - 1 {\n            if votes[i] > maxVotes {\n                maxVotes := votes[i];\n                winner := i;\n            }\n        }\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_194",
            "type": "program",
            "content": "class EulerSolver {\n    var stepSize: real;\n    constructor(stepSize: real)\n        requires stepSize > 0.0\n        ensures this.stepSize == stepSize\n    {\n        this.stepSize := stepSize;\n    }\n    method EulerStep(y: real, dydx: real) returns (yNext: real)\n        ensures yNext == y + stepSize * dydx\n    {\n        yNext := y + stepSize * dydx;\n    }\n}\nmethod TestEulerStepWithNegativeSlope()\n{\n    var solver := new EulerSolver(0.1);\n    var y := 1.0;\n    var dydx := -0.5; // dy/dx = -0.5, expect decrease\n    var yNext := solver.EulerStep(y, dydx);\n    assert yNext == 0.95; // y + stepSize * dydx = 1.0 + 0.1 * -0.5 = 0.95\n}",
            "parents": [
                "node_186"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 14\nmethod TestEulerStepWithNegativeSlope()\n{\n    var solver := new EulerSolver(0.1);\n    var y := 1.0;\n    var dydx := -0.5; // dy/dx = -0.5, expect decrease\n    var yNext := solver.EulerStep(y, dydx);\n    assert yNext == 0.95; // y + stepSize * dydx = 1.0 + 0.1 * -0.5 = 0.95\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_195",
            "type": "program",
            "content": "module EditDistanceCalculator {\n  method ComputeEditDistance(s1: string, s2: string) returns (distance: int)\n    ensures distance >= 0\n    ensures distance <= |s1| + |s2|\n  {\n    var m := |s1|;\n    var n := |s2|;\n    var dp := new int[m + 1, n + 1];\n    for i := 0 to m {\n      dp[i, 0] := i;\n    }\n    for j := 0 to n {\n      dp[0, j] := j;\n    }\n    for i := 1 to m {\n      for j := 1 to n {\n        if s1[i - 1] == s2[j - 1] {\n          dp[i, j] := dp[i - 1, j - 1];\n        } else {\n          dp[i, j] := 1 + min(dp[i - 1, j], dp[i, j - 1], dp[i - 1, j - 1]);\n        }\n      }\n    }\n    distance := dp[m, n];\n  }\n  function min(a: int, b: int, c: int): int {\n    if a < b && a < c then a\n    else if b < c then b\n    else c\n  }\n}",
            "parents": [
                "idea_47"
            ],
            "diff": "```\n// BEGIN DAFNY\nmodule EditDistanceCalculator {\n  method ComputeEditDistance(s1: string, s2: string) returns (distance: int)\n    ensures distance >= 0\n    ensures distance <= |s1| + |s2|\n  {\n    var m := |s1|;\n    var n := |s2|;\n    var dp := new int[m + 1, n + 1];\n\n    for i := 0 to m {\n      dp[i, 0] := i;\n    }\n    for j := 0 to n {\n      dp[0, j] := j;\n    }\n\n    for i := 1 to m {\n      for j := 1 to n {\n        if s1[i - 1] == s2[j - 1] {\n          dp[i, j] := dp[i - 1, j - 1];\n        } else {\n          dp[i, j] := 1 + min(dp[i - 1, j], dp[i, j - 1], dp[i - 1, j - 1]);\n        }\n      }\n    }\n\n    distance := dp[m, n];\n  }\n\n  function min(a: int, b: int, c: int): int {\n    if a < b && a < c then a\n    else if b < c then b\n    else c\n  }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_196",
            "type": "program",
            "content": "class Sudoku {\n    var grid: array2<int>;\n    constructor(grid: array2<int>)\n        requires grid.Length0 == 9 && grid.Length1 == 9\n        ensures this.grid == grid\n    {\n        this.grid := grid;\n    }\n    method IsValidRow(row: int) returns (isValid: bool)\n        requires 0 <= row < 9\n        ensures isValid ==> (forall i, j :: 0 <= i < j < 9 ==> grid[row, i] != grid[row, j])\n    {\n        var seen := new bool[10];\n        isValid := true;\n        for i := 0 to 8 {\n            var num := grid[row, i];\n            if num < 1 || num > 9 || seen[num] {\n                isValid := false;\n                return;\n            }\n            seen[num] := true;\n        }\n    }\n    method IsValidColumn(col: int) returns (isValid: bool)\n        requires 0 <= col < 9\n        ensures isValid ==> (forall i, j :: 0 <= i < j < 9 ==> grid[i, col] != grid[j, col])\n    {\n        var seen := new bool[10];\n        isValid := true;\n        for i := 0 to 8 {\n            var num := grid[i, col];\n            if num < 1 || num > 9 || seen[num] {\n                isValid := false;\n                return;\n            }\n            seen[num] := true;\n        }\n    }\n}",
            "parents": [
                "idea_20"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\n\nclass Sudoku {\n    var grid: array2<int>;\n\n    constructor(grid: array2<int>)\n        requires grid.Length0 == 9 && grid.Length1 == 9\n        ensures this.grid == grid\n    {\n        this.grid := grid;\n    }\n\n    method IsValidRow(row: int) returns (isValid: bool)\n        requires 0 <= row < 9\n        ensures isValid ==> (forall i, j :: 0 <= i < j < 9 ==> grid[row, i] != grid[row, j])\n    {\n        var seen := new bool[10];\n        isValid := true;\n        for i := 0 to 8 {\n            var num := grid[row, i];\n            if num < 1 || num > 9 || seen[num] {\n                isValid := false;\n                return;\n            }\n            seen[num] := true;\n        }\n    }\n\n    method IsValidColumn(col: int) returns (isValid: bool)\n        requires 0 <= col < 9\n        ensures isValid ==> (forall i, j :: 0 <= i < j < 9 ==> grid[i, col] != grid[j, col])\n    {\n        var seen := new bool[10];\n        isValid := true;\n        for i := 0 to 8 {\n            var num := grid[i, col];\n            if num < 1 || num > 9 || seen[num] {\n                isValid := false;\n                return;\n            }\n            seen[num] := true;\n        }\n    }\n}\n\n// END DAFNY\n```\n"
        },
        {
            "id": "node_197",
            "type": "program",
            "content": "class Team {\n    var name: string;\n    var seed: int;\n    constructor(name: string, seed: int)\n        ensures this.name == name && this.seed == seed\n    {\n        this.name := name;\n        this.seed := seed;\n    }\n}\nclass Matchup {\n    var team1: Team;\n    var team2: Team;\n    constructor(team1: Team, team2: Team)\n        requires team1.seed != team2.seed\n        ensures this.team1 == team1 && this.team2 == team2\n    {\n        this.team1 := team1;\n        this.team2 := team2;\n    }\n    method IsValidMatchup() returns (valid: bool)\n        ensures valid == (team1.seed != team2.seed)\n    {\n        valid := team1.seed != team2.seed;\n    }\n}",
            "parents": [
                "idea_96"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\nclass Team {\n    var name: string;\n    var seed: int;\n\n    constructor(name: string, seed: int)\n        ensures this.name == name && this.seed == seed\n    {\n        this.name := name;\n        this.seed := seed;\n    }\n}\n\nclass Matchup {\n    var team1: Team;\n    var team2: Team;\n\n    constructor(team1: Team, team2: Team)\n        requires team1.seed != team2.seed\n        ensures this.team1 == team1 && this.team2 == team2\n    {\n        this.team1 := team1;\n        this.team2 := team2;\n    }\n\n    method IsValidMatchup() returns (valid: bool)\n        ensures valid == (team1.seed != team2.seed)\n    {\n        valid := team1.seed != team2.seed;\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_198",
            "type": "program",
            "content": "class City {\n    var id: int;\n    constructor(id: int)\n        ensures this.id == id\n    {\n        this.id := id;\n    }\n}\nclass Tour {\n    var cities: seq<City>;\n    constructor(cities: seq<City>)\n        ensures this.cities == cities\n    {\n        this.cities := cities;\n    }\n    method IsValidTour() returns (isValid: bool)\n        ensures isValid == (|cities| > 1 && cities[0] == cities[|cities| - 1])\n    {\n        if |cities| > 1 && cities[0] == cities[|cities| - 1] {\n            isValid := true;\n        } else {\n            isValid := false;\n        }\n    }\n    method TotalCities() returns (count: int)\n        ensures count == |cities|\n    {\n        count := |cities|;\n    }\n}",
            "parents": [
                "node_158"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 8\nclass Tour {\n    var cities: seq<City>;\n    constructor(cities: seq<City>)\n        ensures this.cities == cities\n    {\n        this.cities := cities;\n    }\n\n    method IsValidTour() returns (isValid: bool)\n        ensures isValid == (|cities| > 1 && cities[0] == cities[|cities| - 1])\n    {\n        if |cities| > 1 && cities[0] == cities[|cities| - 1] {\n            isValid := true;\n        } else {\n            isValid := false;\n        }\n    }\n\n    method TotalCities() returns (count: int)\n        ensures count == |cities|\n    {\n        count := |cities|;\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_199",
            "type": "program",
            "content": "class Matrix2x2 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    constructor(a: int, b: int, c: int, d: int)\n        ensures this.a == a && this.b == b && this.c == c && this.d == d\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n    }\n    method Determinant() returns (det: int)\n        ensures det == a * d - b * c\n    {\n        det := a * d - b * c;\n    }\n}\nmethod TestDeterminantWithNegativeMatrix()\n{\n    var m := new Matrix2x2(-1, -2, -3, -4);\n    var det := m.Determinant();\n    assert det == -2; // (-1)*(-4) - (-2)*(-3) = 4 - 6 = -2\n}",
            "parents": [
                "node_107"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 19\nmethod TestDeterminantWithNegativeMatrix()\n{\n    var m := new Matrix2x2(-1, -2, -3, -4);\n    var det := m.Determinant();\n    assert det == -2; // (-1)*(-4) - (-2)*(-3) = 4 - 6 = -2\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_200",
            "type": "program",
            "content": "class Matrix3x3 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    var e: int;\n    var f: int;\n    var g: int;\n    var h: int;\n    var i: int;\n    constructor(a: int, b: int, c: int, d: int, e: int, f: int, g: int, h: int, i: int)\n        ensures this.a == a && this.b == b && this.c == c\n        ensures this.d == d && this.e == e && this.f == f\n        ensures this.g == g && this.h == h && this.i == i\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n        this.e := e;\n        this.f := f;\n        this.g := g;\n        this.h := h;\n        this.i := i;\n    }\n    method Determinant() returns (det: int)\n        ensures det == a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g)\n    {\n        det := a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g);\n    }\n}\nmethod TestDeterminantWithZeroMatrix3x3()\n{\n    var m := new Matrix3x3(0, 0, 0, 0, 0, 0, 0, 0, 0);\n    var det := m.Determinant();\n    assert det == 0; // 0 determinant for zero matrix\n}\nmethod TestDeterminantWithIdentityMatrix3x3()\n{\n    var m := new Matrix3x3(1, 0, 0, 0, 1, 0, 0, 0, 1);\n    var det := m.Determinant();\n    assert det == 1; // 1 determinant for identity matrix\n}\nmethod TestDeterminantWithDiagonalMatrix3x3()\n{\n    var m := new Matrix3x3(2, 0, 0, 0, 3, 0, 0, 0, 4);\n    var det := m.Determinant();\n    assert det == 24; // Determinant for diagonal matrix is product of diagonal elements\n}\nmethod TestDeterminantWithSingularMatrix3x3()\n{\n    var m := new Matrix3x3(1, 2, 3, 4, 5, 6, 7, 8, 9);\n    var det := m.Determinant();\n    assert det == 0; // Singular matrix has a determinant of 0\n}\nmethod TestDeterminantWithNegativeMatrix3x3()\n{\n    var m := new Matrix3x3(-1, -2, -3, -4, -5, -6, -7, -8, -9);\n    var det := m.Determinant();\n    assert det == 0; // Negative matrix with linearly dependent rows has a determinant of 0\n}\nmethod TestDeterminantWithPermutationMatrix3x3()\n{\n    var m := new Matrix3x3(0, 1, 0, 1, 0, 0, 0, 0, 1);\n    var det := m.Determinant();\n    assert det == -1; // Determinant of a permutation matrix with one swap is -1\n}",
            "parents": [
                "node_155"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 56\nmethod TestDeterminantWithNegativeMatrix3x3()\n{\n    var m := new Matrix3x3(-1, -2, -3, -4, -5, -6, -7, -8, -9);\n    var det := m.Determinant();\n    assert det == 0; // Negative matrix with linearly dependent rows has a determinant of 0\n}\n\nmethod TestDeterminantWithPermutationMatrix3x3()\n{\n    var m := new Matrix3x3(0, 1, 0, 1, 0, 0, 0, 0, 1);\n    var det := m.Determinant();\n    assert det == -1; // Determinant of a permutation matrix with one swap is -1\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_201",
            "type": "program",
            "content": "class Matrix2x2 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    constructor(a: int, b: int, c: int, d: int)\n        ensures this.a == a && this.b == b && this.c == c && this.d == d\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n    }\n    method Determinant() returns (det: int)\n        ensures det == a * d - b * c\n    {\n        det := a * d - b * c;\n    }\n}\nmethod TestDeterminantWithZeroMatrix()\n{\n    var m := new Matrix2x2(0, 0, 0, 0);\n    var det := m.Determinant();\n    assert det == 0; // 0*0 - 0*0 = 0\n}\nmethod TestDeterminantWithIdentityMatrix()\n{\n    var m := new Matrix2x2(1, 0, 0, 1);\n    var det := m.Determinant();\n    assert det == 1; // 1*1 - 0*0 = 1\n}",
            "parents": [
                "node_190"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 19\nmethod TestDeterminantWithZeroMatrix()\n{\n    var m := new Matrix2x2(0, 0, 0, 0);\n    var det := m.Determinant();\n    assert det == 0; // 0*0 - 0*0 = 0\n}\n\nmethod TestDeterminantWithIdentityMatrix()\n{\n    var m := new Matrix2x2(1, 0, 0, 1);\n    var det := m.Determinant();\n    assert det == 1; // 1*1 - 0*0 = 1\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_202",
            "type": "program",
            "content": "class Matrix2x2 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    constructor(a: int, b: int, c: int, d: int)\n        ensures this.a == a && this.b == b && this.c == c && this.d == d\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n    }\n    method Determinant() returns (det: int)\n        ensures det == a * d - b * c\n    {\n        det := a * d - b * c;\n    }\n}\nmethod TestDeterminantWithNegativeMatrix()\n{\n    var m := new Matrix2x2(-1, -2, -3, -4);\n    var det := m.Determinant();\n    assert det == (-1) * (-4) - (-2) * (-3); // 4 - 6 = -2\n}\nmethod TestDeterminantWithSwappedMatrix()\n{\n    var m := new Matrix2x2(2, 1, 1, 2);\n    var det := m.Determinant();\n    assert det == 2 * 2 - 1 * 1; // 4 - 1 = 3\n}",
            "parents": [
                "node_172"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 19\nmethod TestDeterminantWithNegativeMatrix()\n{\n    var m := new Matrix2x2(-1, -2, -3, -4);\n    var det := m.Determinant();\n    assert det == (-1) * (-4) - (-2) * (-3); // 4 - 6 = -2\n}\n\nmethod TestDeterminantWithSwappedMatrix()\n{\n    var m := new Matrix2x2(2, 1, 1, 2);\n    var det := m.Determinant();\n    assert det == 2 * 2 - 1 * 1; // 4 - 1 = 3\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_203",
            "type": "program",
            "content": "class MatrixOperations {\n    method Transpose(matrix: array2<int>) returns (transposed: array2<int>)\n        requires matrix.Length0 > 0 && matrix.Length1 > 0\n        ensures transposed.Length0 == matrix.Length1 && transposed.Length1 == matrix.Length0\n        ensures forall i: int, j: int :: 0 <= i < matrix.Length0 && 0 <= j < matrix.Length1 ==> transposed[j, i] == matrix[i, j]\n    {\n        var rows := matrix.Length0;\n        var cols := matrix.Length1;\n        transposed := new int[cols, rows];\n        for i := 0 to rows - 1 {\n            for j := 0 to cols - 1 {\n                transposed[j, i] := matrix[i, j];\n            }\n        }\n    }\n}\nmethod AddMatrices(matrixA: array2<int>, matrixB: array2<int>) returns (sumMatrix: array2<int>)\n    requires matrixA.Length0 == matrixB.Length0 && matrixA.Length1 == matrixB.Length1\n    ensures sumMatrix.Length0 == matrixA.Length0 && sumMatrix.Length1 == matrixA.Length1\n    ensures forall i: int, j: int :: 0 <= i < matrixA.Length0 && 0 <= j < matrixA.Length1 ==> sumMatrix[i, j] == matrixA[i, j] + matrixB[i, j]\n{\n    var rows := matrixA.Length0;\n    var cols := matrixA.Length1;\n    sumMatrix := new int[rows, cols];\n    for i := 0 to rows - 1 {\n        for j := 0 to cols - 1 {\n            sumMatrix[i, j] := matrixA[i, j] + matrixB[i, j];\n        }\n    }\n}",
            "parents": [
                "node_144"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 17\nmethod AddMatrices(matrixA: array2<int>, matrixB: array2<int>) returns (sumMatrix: array2<int>)\n    requires matrixA.Length0 == matrixB.Length0 && matrixA.Length1 == matrixB.Length1\n    ensures sumMatrix.Length0 == matrixA.Length0 && sumMatrix.Length1 == matrixA.Length1\n    ensures forall i: int, j: int :: 0 <= i < matrixA.Length0 && 0 <= j < matrixA.Length1 ==> sumMatrix[i, j] == matrixA[i, j] + matrixB[i, j]\n{\n    var rows := matrixA.Length0;\n    var cols := matrixA.Length1;\n    sumMatrix := new int[rows, cols];\n    for i := 0 to rows - 1 {\n        for j := 0 to cols - 1 {\n            sumMatrix[i, j] := matrixA[i, j] + matrixB[i, j];\n        }\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_204",
            "type": "program",
            "content": "class EulerSolver {\n    var stepSize: real;\n    constructor(stepSize: real)\n        requires stepSize > 0.0\n        ensures this.stepSize == stepSize\n    {\n        this.stepSize := stepSize;\n    }\n    method EulerStep(y: real, dydx: real) returns (yNext: real)\n        ensures yNext == y + stepSize * dydx\n    {\n        yNext := y + stepSize * dydx;\n    }\n}\nmethod TestEulerStepWithNegativeSlope()\n{\n    var solver := new EulerSolver(0.1);\n    var y := 1.0;\n    var dydx := -2.0; // dy/dx = -2, simple linear decay\n    var yNext := solver.EulerStep(y, dydx);\n    assert yNext == 0.8; // y + stepSize * dydx = 1.0 + 0.1 * -2.0 = 0.8\n}",
            "parents": [
                "node_116"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 14\nmethod TestEulerStepWithNegativeSlope()\n{\n    var solver := new EulerSolver(0.1);\n    var y := 1.0;\n    var dydx := -2.0; // dy/dx = -2, simple linear decay\n    var yNext := solver.EulerStep(y, dydx);\n    assert yNext == 0.8; // y + stepSize * dydx = 1.0 + 0.1 * -2.0 = 0.8\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_205",
            "type": "program",
            "content": "class LinearInequalitySolver {\n    method SolveInequality(a: int, b: int, c: int) returns (x: int)\n        requires a != 0\n        ensures a * x + b <= c\n    {\n        // A simple approach to find a solution for ax + b <= c\n        x := (c - b) / a;\n        if a * x + b > c {\n            x := x - 1;\n        }\n    }\n    method VerifySolution(a: int, b: int, c: int, x: int) returns (isValid: bool)\n        ensures isValid == (a * x + b <= c)\n    {\n        isValid := a * x + b <= c;\n    }\n}\n    method SolveStrictInequality(a: int, b: int, c: int) returns (x: int)\n        requires a != 0\n        ensures a * x + b < c\n    {\n        // A simple approach to find a solution for ax + b < c\n        x := (c - b) / a;\n        if a * x + b >= c {\n            x := x - 1;\n        }\n    }\n    method VerifyStrictSolution(a: int, b: int, c: int, x: int) returns (isValid: bool)\n        ensures isValid == (a * x + b < c)\n    {\n        isValid := a * x + b < c;\n    }\n    method SolveInequalityWithLoop(a: int, b: int, c: int) returns (x: int)\n        requires a != 0\n        ensures a * x + b <= c\n    {\n        var lowerBound := (c - b) / a;\n        x := lowerBound;\n        while a * x + b > c\n            invariant a * x + b > c\n            decreases x\n        {\n            x := x - 1;\n        }\n    }",
            "parents": [
                "node_169"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 33\n    method SolveInequalityWithLoop(a: int, b: int, c: int) returns (x: int)\n        requires a != 0\n        ensures a * x + b <= c\n    {\n        var lowerBound := (c - b) / a;\n        x := lowerBound;\n        while a * x + b > c\n            invariant a * x + b > c\n            decreases x\n        {\n            x := x - 1;\n        }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_206",
            "type": "program",
            "content": "class Employee {\n    var hoursWorked: int;\n    var payRate: int;\n    constructor(hoursWorked: int, payRate: int)\n        ensures this.hoursWorked == hoursWorked && this.payRate == payRate\n    {\n        this.hoursWorked := hoursWorked;\n        this.payRate := payRate;\n    }\n    method CalculateSalary() returns (salary: int)\n        ensures salary == hoursWorked * payRate\n    {\n        salary := hoursWorked * payRate;\n    }\n}\nmethod CalculateOvertimeSalary(overtimeHours: int, overtimeRate: int) returns (overtimeSalary: int)\n    requires overtimeHours >= 0 && overtimeRate >= 0\n    ensures overtimeSalary == overtimeHours * overtimeRate\n{\n    var i := 0;\n    overtimeSalary := 0;\n    while i < overtimeHours\n        invariant 0 <= i <= overtimeHours\n        invariant overtimeSalary == i * overtimeRate\n    {\n        overtimeSalary := overtimeSalary + overtimeRate;\n        i := i + 1;\n    }\n}",
            "parents": [
                "node_118"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 15\nmethod CalculateOvertimeSalary(overtimeHours: int, overtimeRate: int) returns (overtimeSalary: int)\n    requires overtimeHours >= 0 && overtimeRate >= 0\n    ensures overtimeSalary == overtimeHours * overtimeRate\n{\n    var i := 0;\n    overtimeSalary := 0;\n    while i < overtimeHours\n        invariant 0 <= i <= overtimeHours\n        invariant overtimeSalary == i * overtimeRate\n    {\n        overtimeSalary := overtimeSalary + overtimeRate;\n        i := i + 1;\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_207",
            "type": "program",
            "content": "class PayrollSystem {\n    method CalculateSalary(hoursWorked: int, payRate: int) returns (salary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        ensures salary >= 0\n    {\n        salary := hoursWorked * payRate;\n    }\n    method CalculateOvertimeSalary(hoursWorked: int, payRate: int, overtimeRate: int) returns (totalSalary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        requires overtimeRate >= payRate\n        ensures totalSalary >= 0\n    {\n        var regularHours := if hoursWorked > 40 then 40 else hoursWorked;\n        var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n        var regularSalary := regularHours * payRate;\n        var overtimeSalary := overtimeHours * overtimeRate;\n        totalSalary := regularSalary + overtimeSalary;\n    }\n}\n    method CalculateWeeklySalary(hoursWorked: int, payRate: int, overtimeRate: int) returns (weeklySalary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        requires overtimeRate >= payRate\n        ensures weeklySalary >= 0\n    {\n        var totalSalary := 0;\n        var weekHours := 0;\n        while (weekHours < hoursWorked)\n            invariant 0 <= weekHours <= hoursWorked\n            invariant totalSalary >= 0\n        {\n            if (weekHours < 40) {\n                totalSalary := totalSalary + payRate;\n            } else {\n                totalSalary := totalSalary + overtimeRate;\n            }\n            weekHours := weekHours + 1;\n        }\n        weeklySalary := totalSalary;\n    }",
            "parents": [
                "node_123"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 22\n    method CalculateWeeklySalary(hoursWorked: int, payRate: int, overtimeRate: int) returns (weeklySalary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        requires overtimeRate >= payRate\n        ensures weeklySalary >= 0\n    {\n        var totalSalary := 0;\n        var weekHours := 0;\n        while (weekHours < hoursWorked)\n            invariant 0 <= weekHours <= hoursWorked\n            invariant totalSalary >= 0\n        {\n            if (weekHours < 40) {\n                totalSalary := totalSalary + payRate;\n            } else {\n                totalSalary := totalSalary + overtimeRate;\n            }\n            weekHours := weekHours + 1;\n        }\n        weeklySalary := totalSalary;\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_208",
            "type": "program",
            "content": "class LinearInequalitiesSolver {\n    method SolveSingleInequality(a: int, b: int, c: int) returns (solution: bool)\n        requires a != 0\n        ensures solution == (c >= b / a)\n    {\n        if a > 0 {\n            solution := c >= b / a;\n        } else {\n            solution := c <= b / a;\n        }\n    }\n    method VerifySolution(a: int, b: int, c: int, x: int) returns (isValid: bool)\n        requires a != 0\n        ensures isValid == (a * x + b <= c)\n    {\n        isValid := a * x + b <= c;\n    }\n}\n    method SolveMultipleInequalities(a: seq<int>, b: seq<int>, c: seq<int>) returns (solutions: seq<bool>)\n        requires |a| == |b| && |b| == |c|\n        requires forall i :: 0 <= i < |a| ==> a[i] != 0\n        ensures |solutions| == |a|\n        ensures forall i :: 0 <= i < |solutions| ==> solutions[i] == (if a[i] > 0 then c[i] >= b[i] / a[i] else c[i] <= b[i] / a[i])\n    {\n        solutions := [];\n        var i := 0;\n        while i < |a|\n            invariant 0 <= i <= |a|\n            invariant |solutions| == i\n            invariant forall j :: 0 <= j < i ==> solutions[j] == (if a[j] > 0 then c[j] >= b[j] / a[j] else c[j] <= b[j] / a[j])\n        {\n            if a[i] > 0 {\n                solutions := solutions + [c[i] >= b[i] / a[i]];\n            } else {\n                solutions := solutions + [c[i] <= b[i] / a[i]];\n            }\n            i := i + 1;\n        }\n    }",
            "parents": [
                "node_191"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 18\n    method SolveMultipleInequalities(a: seq<int>, b: seq<int>, c: seq<int>) returns (solutions: seq<bool>)\n        requires |a| == |b| && |b| == |c|\n        requires forall i :: 0 <= i < |a| ==> a[i] != 0\n        ensures |solutions| == |a|\n        ensures forall i :: 0 <= i < |solutions| ==> solutions[i] == (if a[i] > 0 then c[i] >= b[i] / a[i] else c[i] <= b[i] / a[i])\n    {\n        solutions := [];\n        var i := 0;\n        while i < |a|\n            invariant 0 <= i <= |a|\n            invariant |solutions| == i\n            invariant forall j :: 0 <= j < i ==> solutions[j] == (if a[j] > 0 then c[j] >= b[j] / a[j] else c[j] <= b[j] / a[j])\n        {\n            if a[i] > 0 {\n                solutions := solutions + [c[i] >= b[i] / a[i]];\n            } else {\n                solutions := solutions + [c[i] <= b[i] / a[i]];\n            }\n            i := i + 1;\n        }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_209",
            "type": "program",
            "content": "class Geometry {\n    method IsPointInsideRectangle(px: int, py: int, rx: int, ry: int, rw: int, rh: int) returns (inside: bool)\n        requires rw >= 0 && rh >= 0\n        ensures inside == ((px >= rx) && (px <= rx + rw) && (py >= ry) && (py <= ry + rh))\n    {\n        inside := (px >= rx) && (px <= rx + rw) && (py >= ry) && (py <= ry + rh);\n    }\n    method DoRectanglesOverlap(r1x: int, r1y: int, r1w: int, r1h: int, r2x: int, r2y: int, r2w: int, r2h: int) returns (overlap: bool)\n        requires r1w >= 0 && r1h >= 0 && r2w >= 0 && r2h >= 0\n        ensures overlap == ((r1x < r2x + r2w) && (r1x + r1w > r2x) && (r1y < r2y + r2h) && (r1y + r1h > r2y))\n    {\n        overlap := (r1x < r2x + r2w) && (r1x + r1w > r2x) && (r1y < r2y + r2h) && (r1y + r1h > r2y);\n    }\n}",
            "parents": [
                "idea_77"
            ],
            "diff": "```\n// BEGIN DAFNY\nclass Geometry {\n    method IsPointInsideRectangle(px: int, py: int, rx: int, ry: int, rw: int, rh: int) returns (inside: bool)\n        requires rw >= 0 && rh >= 0\n        ensures inside == ((px >= rx) && (px <= rx + rw) && (py >= ry) && (py <= ry + rh))\n    {\n        inside := (px >= rx) && (px <= rx + rw) && (py >= ry) && (py <= ry + rh);\n    }\n\n    method DoRectanglesOverlap(r1x: int, r1y: int, r1w: int, r1h: int, r2x: int, r2y: int, r2w: int, r2h: int) returns (overlap: bool)\n        requires r1w >= 0 && r1h >= 0 && r2w >= 0 && r2h >= 0\n        ensures overlap == ((r1x < r2x + r2w) && (r1x + r1w > r2x) && (r1y < r2y + r2h) && (r1y + r1h > r2y))\n    {\n        overlap := (r1x < r2x + r2w) && (r1x + r1w > r2x) && (r1y < r2y + r2h) && (r1y + r1h > r2y);\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_210",
            "type": "program",
            "content": "class GameOfLife {\n    method NextGeneration(grid: array2<bool>) returns (newGrid: array2<bool>)\n        requires grid.Length0 > 0 && grid.Length1 > 0\n        ensures newGrid.Length0 == grid.Length0 && newGrid.Length1 == grid.Length1\n    {\n        var rows := grid.Length0;\n        var cols := grid.Length1;\n        newGrid := new bool[rows, cols];\n        for i := 0 to rows - 1\n            invariant 0 <= i <= rows\n            invariant newGrid.Length0 == rows && newGrid.Length1 == cols\n        {\n            for j := 0 to cols - 1\n                invariant 0 <= j <= cols\n                invariant newGrid.Length0 == rows && newGrid.Length1 == cols\n            {\n                var liveNeighbors := CountLiveNeighbors(grid, i, j);\n                if grid[i, j] {\n                    newGrid[i, j] := liveNeighbors == 2 || liveNeighbors == 3;\n                } else {\n                    newGrid[i, j] := liveNeighbors == 3;\n                }\n            }\n        }\n    }\n    method CountLiveNeighbors(grid: array2<bool>, row: int, col: int) returns (count: int)\n        requires 0 <= row < grid.Length0 && 0 <= col < grid.Length1\n        ensures 0 <= count <= 8\n    {\n        count := 0;\n        for di := -1 to 1\n            invariant -1 <= di <= 1\n        {\n            for dj := -1 to 1\n                invariant -1 <= dj <= 1\n            {\n                if di == 0 && dj == 0 {\n                    continue;\n                }\n                var ni := row + di;\n                var nj := col + dj;\n                if 0 <= ni < grid.Length0 && 0 <= nj < grid.Length1 && grid[ni, nj] {\n                    count := count + 1;\n                }\n            }\n        }\n    }\n}",
            "parents": [
                "idea_38"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\n\nclass GameOfLife {\n    method NextGeneration(grid: array2<bool>) returns (newGrid: array2<bool>)\n        requires grid.Length0 > 0 && grid.Length1 > 0\n        ensures newGrid.Length0 == grid.Length0 && newGrid.Length1 == grid.Length1\n    {\n        var rows := grid.Length0;\n        var cols := grid.Length1;\n        newGrid := new bool[rows, cols];\n\n        for i := 0 to rows - 1\n            invariant 0 <= i <= rows\n            invariant newGrid.Length0 == rows && newGrid.Length1 == cols\n        {\n            for j := 0 to cols - 1\n                invariant 0 <= j <= cols\n                invariant newGrid.Length0 == rows && newGrid.Length1 == cols\n            {\n                var liveNeighbors := CountLiveNeighbors(grid, i, j);\n                if grid[i, j] {\n                    newGrid[i, j] := liveNeighbors == 2 || liveNeighbors == 3;\n                } else {\n                    newGrid[i, j] := liveNeighbors == 3;\n                }\n            }\n        }\n    }\n\n    method CountLiveNeighbors(grid: array2<bool>, row: int, col: int) returns (count: int)\n        requires 0 <= row < grid.Length0 && 0 <= col < grid.Length1\n        ensures 0 <= count <= 8\n    {\n        count := 0;\n        for di := -1 to 1\n            invariant -1 <= di <= 1\n        {\n            for dj := -1 to 1\n                invariant -1 <= dj <= 1\n            {\n                if di == 0 && dj == 0 {\n                    continue;\n                }\n                var ni := row + di;\n                var nj := col + dj;\n                if 0 <= ni < grid.Length0 && 0 <= nj < grid.Length1 && grid[ni, nj] {\n                    count := count + 1;\n                }\n            }\n        }\n    }\n}\n\n// END DAFNY\n```"
        },
        {
            "id": "node_211",
            "type": "program",
            "content": "method GaussianElimination(a: array2<int>, b: array<int>) returns (x: array<int>)\n    requires a.Length0 == a.Length1 && a.Length0 == b.Length\n    ensures forall i :: 0 <= i < a.Length0 ==> a[i, i] * x[i] == b[i]\n{\n    var n := a.Length0;\n    x := new int[n];\n    // Forward elimination\n    for k := 0 to n - 1\n        invariant 0 <= k <= n\n        invariant forall i, j :: 0 <= i < k && 0 <= j < n ==> a[i, j] == 0\n    {\n        // Find the pivot\n        var max := k;\n        for i := k + 1 to n - 1\n            invariant k <= max < n\n            invariant forall j :: k <= j < i ==> a[max, k] >= a[j, k]\n        {\n            if a[i, k] > a[max, k] {\n                max := i;\n            }\n        }\n        // Swap rows\n        for j := 0 to n - 1\n            invariant 0 <= j <= n\n            invariant forall i :: 0 <= i < j ==> a[k, i] == a[max, i] && a[max, i] == a[k, i]\n        {\n            var temp := a[k, j];\n            a[k, j] := a[max, j];\n            a[max, j] := temp;\n        }\n        var tempB := b[k];\n        b[k] := b[max];\n        b[max] := tempB;\n        // Eliminate column\n        for i := k + 1 to n - 1\n            invariant k < i <= n\n            invariant forall j :: 0 <= j < n ==> a[i, j] == 0 || j >= k\n        {\n            var factor := a[i, k] / a[k, k];\n            b[i] := b[i] - factor * b[k];\n            for j := k to n - 1\n                invariant k <= j <= n\n                invariant forall l :: k <= l < j ==> a[i, l] == 0\n            {\n                a[i, j] := a[i, j] - factor * a[k, j];\n            }\n        }\n    }\n    // Back substitution\n    for i := n - 1 downto 0\n        invariant -1 <= i < n\n        invariant forall j :: i < j < n ==> x[j] * a[i, j] == b[i]\n    {\n        var sum := b[i];\n        for j := i + 1 to n - 1\n            invariant i < j <= n\n            invariant sum == b[i] - (j - i - 1) * x[j] * a[i, j]\n        {\n            sum := sum - a[i, j] * x[j];\n        }\n        x[i] := sum / a[i, i];\n    }\n}",
            "parents": [
                "idea_35"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\nmethod GaussianElimination(a: array2<int>, b: array<int>) returns (x: array<int>)\n    requires a.Length0 == a.Length1 && a.Length0 == b.Length\n    ensures forall i :: 0 <= i < a.Length0 ==> a[i, i] * x[i] == b[i]\n{\n    var n := a.Length0;\n    x := new int[n];\n\n    // Forward elimination\n    for k := 0 to n - 1\n        invariant 0 <= k <= n\n        invariant forall i, j :: 0 <= i < k && 0 <= j < n ==> a[i, j] == 0\n    {\n        // Find the pivot\n        var max := k;\n        for i := k + 1 to n - 1\n            invariant k <= max < n\n            invariant forall j :: k <= j < i ==> a[max, k] >= a[j, k]\n        {\n            if a[i, k] > a[max, k] {\n                max := i;\n            }\n        }\n\n        // Swap rows\n        for j := 0 to n - 1\n            invariant 0 <= j <= n\n            invariant forall i :: 0 <= i < j ==> a[k, i] == a[max, i] && a[max, i] == a[k, i]\n        {\n            var temp := a[k, j];\n            a[k, j] := a[max, j];\n            a[max, j] := temp;\n        }\n        var tempB := b[k];\n        b[k] := b[max];\n        b[max] := tempB;\n\n        // Eliminate column\n        for i := k + 1 to n - 1\n            invariant k < i <= n\n            invariant forall j :: 0 <= j < n ==> a[i, j] == 0 || j >= k\n        {\n            var factor := a[i, k] / a[k, k];\n            b[i] := b[i] - factor * b[k];\n            for j := k to n - 1\n                invariant k <= j <= n\n                invariant forall l :: k <= l < j ==> a[i, l] == 0\n            {\n                a[i, j] := a[i, j] - factor * a[k, j];\n            }\n        }\n    }\n\n    // Back substitution\n    for i := n - 1 downto 0\n        invariant -1 <= i < n\n        invariant forall j :: i < j < n ==> x[j] * a[i, j] == b[i]\n    {\n        var sum := b[i];\n        for j := i + 1 to n - 1\n            invariant i < j <= n\n            invariant sum == b[i] - (j - i - 1) * x[j] * a[i, j]\n        {\n            sum := sum - a[i, j] * x[j];\n        }\n        x[i] := sum / a[i, i];\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_212",
            "type": "program",
            "content": "method Median(a: array<int>) returns (median: int)\n    requires a != null && a.Length > 0\n    ensures 0 <= median < a.Length\n    ensures forall i: int :: 0 <= i < a.Length ==> a[median] <= a[i] || a[median] >= a[i]\n{\n    var n := a.Length;\n    var sorted := new int[n];\n    // Copy the array\n    for i := 0 to n - 1\n        invariant 0 <= i <= n\n        invariant forall j: int :: 0 <= j < i ==> sorted[j] == a[j]\n    {\n        sorted[i] := a[i];\n    }\n    // Sort the array (simple insertion sort for demonstration)\n    for i := 1 to n - 1\n        invariant 1 <= i <= n\n        invariant forall j: int :: 0 <= j < i ==> sorted[j] <= sorted[j + 1]\n    {\n        var key := sorted[i];\n        var j := i - 1;\n        while j >= 0 && sorted[j] > key\n            invariant -1 <= j < i\n            invariant forall k: int :: 0 <= k <= j ==> sorted[k] <= key\n            invariant forall k: int :: j < k < i ==> sorted[k] == sorted[k + 1]\n        {\n            sorted[j + 1] := sorted[j];\n            j := j - 1;\n        }\n        sorted[j + 1] := key;\n    }\n    // Return the median\n    if n % 2 == 1 {\n        median := sorted[n / 2];\n    } else {\n        median := sorted[n / 2 - 1]; // For simplicity, return the lower median\n    }\n}",
            "parents": [
                "idea_83"
            ],
            "diff": "```\n// BEGIN DAFNY\nmethod Median(a: array<int>) returns (median: int)\n    requires a != null && a.Length > 0\n    ensures 0 <= median < a.Length\n    ensures forall i: int :: 0 <= i < a.Length ==> a[median] <= a[i] || a[median] >= a[i]\n{\n    var n := a.Length;\n    var sorted := new int[n];\n    // Copy the array\n    for i := 0 to n - 1\n        invariant 0 <= i <= n\n        invariant forall j: int :: 0 <= j < i ==> sorted[j] == a[j]\n    {\n        sorted[i] := a[i];\n    }\n    // Sort the array (simple insertion sort for demonstration)\n    for i := 1 to n - 1\n        invariant 1 <= i <= n\n        invariant forall j: int :: 0 <= j < i ==> sorted[j] <= sorted[j + 1]\n    {\n        var key := sorted[i];\n        var j := i - 1;\n        while j >= 0 && sorted[j] > key\n            invariant -1 <= j < i\n            invariant forall k: int :: 0 <= k <= j ==> sorted[k] <= key\n            invariant forall k: int :: j < k < i ==> sorted[k] == sorted[k + 1]\n        {\n            sorted[j + 1] := sorted[j];\n            j := j - 1;\n        }\n        sorted[j + 1] := key;\n    }\n    // Return the median\n    if n % 2 == 1 {\n        median := sorted[n / 2];\n    } else {\n        median := sorted[n / 2 - 1]; // For simplicity, return the lower median\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_213",
            "type": "program",
            "content": "class SpellChecker {\n    var dictionary: set<string>;\n    constructor(words: set<string>)\n        ensures dictionary == words\n    {\n        dictionary := words;\n    }\n    method IsMisspelled(word: string) returns (misspelled: bool)\n        ensures misspelled == !(word in dictionary)\n    {\n        misspelled := !(word in dictionary);\n    }\n    method SuggestCorrections(word: string) returns (suggestions: set<string>)\n        ensures forall s :: s in suggestions ==> |s| == |word|\n    {\n        var tempSuggestions: set<string> := {};\n        var alphabet: seq<char> := \"abcdefghijklmnopqrstuvwxyz\";\n        // Loop through each position in the word\n        var i: int := 0;\n        while i < |word|\n            invariant 0 <= i <= |word|\n            invariant forall s :: s in tempSuggestions ==> |s| == |word|\n        {\n            // Try replacing each character with every letter in the alphabet\n            var j: int := 0;\n            while j < |alphabet|\n                invariant 0 <= j <= |alphabet|\n                invariant forall s :: s in tempSuggestions ==> |s| == |word|\n            {\n                var newWord := word[..i] + [alphabet[j]] + word[i+1..];\n                if newWord in dictionary {\n                    tempSuggestions := tempSuggestions + {newWord};\n                }\n                j := j + 1;\n            }\n            i := i + 1;\n        }\n        suggestions := tempSuggestions;\n    }\n}",
            "parents": [
                "idea_82"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\nclass SpellChecker {\n    var dictionary: set<string>;\n\n    constructor(words: set<string>)\n        ensures dictionary == words\n    {\n        dictionary := words;\n    }\n\n    method IsMisspelled(word: string) returns (misspelled: bool)\n        ensures misspelled == !(word in dictionary)\n    {\n        misspelled := !(word in dictionary);\n    }\n\n    method SuggestCorrections(word: string) returns (suggestions: set<string>)\n        ensures forall s :: s in suggestions ==> |s| == |word|\n    {\n        var tempSuggestions: set<string> := {};\n        var alphabet: seq<char> := \"abcdefghijklmnopqrstuvwxyz\";\n\n        // Loop through each position in the word\n        var i: int := 0;\n        while i < |word|\n            invariant 0 <= i <= |word|\n            invariant forall s :: s in tempSuggestions ==> |s| == |word|\n        {\n            // Try replacing each character with every letter in the alphabet\n            var j: int := 0;\n            while j < |alphabet|\n                invariant 0 <= j <= |alphabet|\n                invariant forall s :: s in tempSuggestions ==> |s| == |word|\n            {\n                var newWord := word[..i] + [alphabet[j]] + word[i+1..];\n                if newWord in dictionary {\n                    tempSuggestions := tempSuggestions + {newWord};\n                }\n                j := j + 1;\n            }\n            i := i + 1;\n        }\n        suggestions := tempSuggestions;\n    }\n}\n// END DAFNY\n```\n"
        },
        {
            "id": "node_214",
            "type": "program",
            "content": "method GaussianElimination(a: array2<int>, b: array<int>) returns (x: array<int>)\n    requires a.Length0 == a.Length1 && a.Length0 == b.Length\n    ensures forall i :: 0 <= i < a.Length0 ==> a[i, i] * x[i] == b[i]\n{\n    var n := a.Length0;\n    x := new int[n];\n    // Forward elimination\n    for k := 0 to n - 1\n        invariant 0 <= k <= n\n        invariant forall i, j :: 0 <= i < k && 0 <= j < n ==> a[i, j] == 0\n    {\n        // Find the pivot\n        var max := k;\n        for i := k + 1 to n - 1\n            invariant k <= max < n\n            invariant forall j :: k <= j < i ==> a[max, k] >= a[j, k]\n        {\n            if a[i, k] > a[max, k] {\n                max := i;\n            }\n        }\n        // Swap rows\n        for j := 0 to n - 1\n            invariant 0 <= j <= n\n            invariant forall i :: 0 <= i < j ==> a[k, i] == a[max, i] && a[max, i] == a[k, i]\n        {\n            var temp := a[k, j];\n            a[k, j] := a[max, j];\n            a[max, j] := temp;\n        }\n        var tempB := b[k];\n        b[k] := b[max];\n        b[max] := tempB;\n        // Eliminate column\n        for i := k + 1 to n - 1\n            invariant k < i <= n\n            invariant forall j :: 0 <= j < n ==> (j < k ==> a[i, j] == 0) && (j >= k ==> a[i, j] == a[i, j])\n        {\n            var factor := a[i, k] / a[k, k];\n            b[i] := b[i] - factor * b[k];\n            for j := k to n - 1\n                invariant k <= j <= n\n                invariant forall l :: k <= l < j ==> a[i, l] == a[i, l]\n            {\n                a[i, j] := a[i, j] - factor * a[k, j];\n            }\n        }\n}\n}",
            "parents": [
                "node_211"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 35\n        for i := k + 1 to n - 1\n            invariant k < i <= n\n            invariant forall j :: 0 <= j < n ==> (j < k ==> a[i, j] == 0) && (j >= k ==> a[i, j] == a[i, j])\n        {\n            var factor := a[i, k] / a[k, k];\n            b[i] := b[i] - factor * b[k];\n            for j := k to n - 1\n                invariant k <= j <= n\n                invariant forall l :: k <= l < j ==> a[i, l] == a[i, l]\n            {\n                a[i, j] := a[i, j] - factor * a[k, j];\n            }\n        }\n// END DAFNY\n```"
        },
        {
            "id": "node_215",
            "type": "program",
            "content": "class FlightBookingSystem {\n    var totalSeats: nat;\n    var bookedSeats: nat;\n    constructor(totalSeats: nat)\n        requires totalSeats > 0\n        ensures this.totalSeats == totalSeats && this.bookedSeats == 0\n    {\n        this.totalSeats := totalSeats;\n        this.bookedSeats := 0;\n    }\n    method BookSeat() returns (success: bool)\n        ensures success ==> bookedSeats <= totalSeats\n        ensures !success ==> bookedSeats == totalSeats\n    {\n        if bookedSeats < totalSeats {\n            bookedSeats := bookedSeats + 1;\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n    method CancelSeat() returns (success: bool)\n        ensures success ==> bookedSeats >= 0\n        ensures !success ==> bookedSeats == 0\n    {\n        if bookedSeats > 0 {\n            bookedSeats := bookedSeats - 1;\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n    method BookMultipleSeats(n: nat) returns (success: bool)\n        requires n > 0\n        ensures success ==> bookedSeats <= totalSeats\n        ensures !success ==> bookedSeats + n > totalSeats\n    {\n        var i: nat := 0;\n        success := true;\n        while i < n\n            invariant 0 <= i <= n\n            invariant bookedSeats <= totalSeats\n        {\n            if bookedSeats < totalSeats {\n                bookedSeats := bookedSeats + 1;\n            } else {\n                success := false;\n                break;\n            }\n            i := i + 1;\n        }\n    }\n}",
            "parents": [
                "node_109"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 22\n    method CancelSeat() returns (success: bool)\n        ensures success ==> bookedSeats >= 0\n        ensures !success ==> bookedSeats == 0\n    {\n        if bookedSeats > 0 {\n            bookedSeats := bookedSeats - 1;\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n\n    method BookMultipleSeats(n: nat) returns (success: bool)\n        requires n > 0\n        ensures success ==> bookedSeats <= totalSeats\n        ensures !success ==> bookedSeats + n > totalSeats\n    {\n        var i: nat := 0;\n        success := true;\n        while i < n\n            invariant 0 <= i <= n\n            invariant bookedSeats <= totalSeats\n        {\n            if bookedSeats < totalSeats {\n                bookedSeats := bookedSeats + 1;\n            } else {\n                success := false;\n                break;\n            }\n            i := i + 1;\n        }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_216",
            "type": "program",
            "content": "class Employee {\n    var hoursWorked: int;\n    var payRate: int;\n    constructor(hoursWorked: int, payRate: int)\n        ensures this.hoursWorked == hoursWorked && this.payRate == payRate\n    {\n        this.hoursWorked := hoursWorked;\n        this.payRate := payRate;\n    }\nmethod CalculateSalaryWithOvertime() returns (salary: int)\n    ensures salary == hoursWorked * payRate + (if hoursWorked > 40 then (hoursWorked - 40) * payRate / 2 else 0)\n{\n    var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n    var regularHours := hoursWorked - overtimeHours;\n    salary := regularHours * payRate + overtimeHours * payRate / 2;\n}\n}",
            "parents": [
                "node_160"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 10\nmethod CalculateSalaryWithOvertime() returns (salary: int)\n    ensures salary == hoursWorked * payRate + (if hoursWorked > 40 then (hoursWorked - 40) * payRate / 2 else 0)\n{\n    var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n    var regularHours := hoursWorked - overtimeHours;\n    salary := regularHours * payRate + overtimeHours * payRate / 2;\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_217",
            "type": "program",
            "content": "class GameOfLife {\n    method NextGeneration(grid: array2<bool>) returns (newGrid: array2<bool>)\n        requires grid.Length0 > 0 && grid.Length1 > 0\n        ensures newGrid.Length0 == grid.Length0 && newGrid.Length1 == grid.Length1\n    {\n        var rows := grid.Length0;\n        var cols := grid.Length1;\n        newGrid := new bool[rows, cols];\n        for i := 0 to rows - 1\n            invariant 0 <= i <= rows\n            invariant newGrid.Length0 == rows && newGrid.Length1 == cols\n        {\n            for j := 0 to cols - 1\n                invariant 0 <= j <= cols\n                invariant newGrid.Length0 == rows && newGrid.Length1 == cols\n            {\n                var liveNeighbors := CountLiveNeighbors(grid, i, j);\n                if grid[i, j] {\n                    newGrid[i, j] := liveNeighbors == 2 || liveNeighbors == 3;\n                } else {\n                    newGrid[i, j] := liveNeighbors == 3;\n                }\n            }\n        }\n    }\n    method CountLiveNeighbors(grid: array2<bool>, row: int, col: int) returns (count: int)\n        requires 0 <= row < grid.Length0 && 0 <= col < grid.Length1\n        ensures 0 <= count <= 8\n    {\n        count := 0;\n        for di := -1 to 1\n            invariant -1 <= di <= 1\n            invariant 0 <= count <= 8\n        {\n}\n}\n}",
            "parents": [
                "node_210"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 31\n        for di := -1 to 1\n            invariant -1 <= di <= 1\n            invariant 0 <= count <= 8\n        {\n// END DAFNY\n```"
        },
        {
            "id": "node_218",
            "type": "program",
            "content": "class City {\n    var id: int;\n    constructor(id: int)\n        ensures this.id == id\n    {\n        this.id := id;\n    }\n}\nclass Tour {\n    var cities: seq<City>;\n    constructor(cities: seq<City>)\n        ensures this.cities == cities\n    {\n        this.cities := cities;\n    }\nmethod IsValidTour() returns (isValid: bool)\n    ensures isValid == (|cities| > 1 && cities[0] == cities[|cities| - 1])\n{\n    isValid := false;\n    if |cities| > 1 {\n        var i := 0;\n        while i < |cities| - 1\n            invariant 0 <= i <= |cities| - 1\n            invariant cities[0] == cities[|cities| - 1] ==> isValid\n        {\n            if cities[i] == cities[|cities| - 1] {\n                isValid := true;\n                break;\n            }\n            i := i + 1;\n        }\n    }\n}\n}",
            "parents": [
                "node_158"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 16\nmethod IsValidTour() returns (isValid: bool)\n    ensures isValid == (|cities| > 1 && cities[0] == cities[|cities| - 1])\n{\n    isValid := false;\n    if |cities| > 1 {\n        var i := 0;\n        while i < |cities| - 1\n            invariant 0 <= i <= |cities| - 1\n            invariant cities[0] == cities[|cities| - 1] ==> isValid\n        {\n            if cities[i] == cities[|cities| - 1] {\n                isValid := true;\n                break;\n            }\n            i := i + 1;\n        }\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_219",
            "type": "program",
            "content": "method QuickSort(a: array<int>) \n    requires a != null\n    modifies a\n    ensures forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n    ensures multiset(a[..]) == multiset(old(a[..]))\n{\n    QuickSortHelper(a, 0, a.Length - 1);\n}\nmethod QuickSortHelper(a: array<int>, low: int, high: int)\n    requires a != null && 0 <= low <= high + 1 <= a.Length\n    modifies a\n    ensures forall i, j :: low <= i < j <= high ==> a[i] <= a[j]\n    ensures multiset(a[low..high+1]) == multiset(old(a[low..high+1]))\n{\n    if low < high {\n        var pivotIndex := Partition(a, low, high);\n        QuickSortHelper(a, low, pivotIndex - 1);\n        QuickSortHelper(a, pivotIndex + 1, high);\n    }\n}\nmethod Partition(a: array<int>, low: int, high: int) returns (pivotIndex: int)\n    requires a != null && 0 <= low <= high < a.Length\n    modifies a\n    ensures low <= pivotIndex <= high\n    ensures forall i :: low <= i < pivotIndex ==> a[i] <= a[pivotIndex]\n    ensures forall i :: pivotIndex < i <= high ==> a[pivotIndex] <= a[i]\n    ensures multiset(a[low..high+1]) == multiset(old(a[low..high+1]))\n{\n    var pivot := a[high];\n    var i := low - 1;\n    for j := low to high - 1\n        invariant low <= j <= high\n        invariant low - 1 <= i < j\n        invariant forall k :: low <= k <= i ==> a[k] <= pivot\n        invariant forall k :: i < k < j ==> a[k] > pivot\n    {\n        if a[j] <= pivot {\n            i := i + 1;\n            var temp := a[i];\n            a[i] := a[j];\n            a[j] := temp;\n        }\n    }\n}",
            "parents": [
                "node_111"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 31\n    for j := low to high - 1\n        invariant low <= j <= high\n        invariant low - 1 <= i < j\n        invariant forall k :: low <= k <= i ==> a[k] <= pivot\n        invariant forall k :: i < k < j ==> a[k] > pivot\n    {\n        if a[j] <= pivot {\n            i := i + 1;\n            var temp := a[i];\n            a[i] := a[j];\n            a[j] := temp;\n        }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_220",
            "type": "program",
            "content": "class VotingSystem {\n    var votes: array<int>;\n    constructor(n: int)\n        requires n > 0\n        ensures votes.Length == n\n        ensures forall i :: 0 <= i < n ==> votes[i] == 0\n    {\n        votes := new int[n];\n    }\n    method CastVote(candidate: int)\n        requires 0 <= candidate < votes.Length\n        modifies votes\n        ensures votes[candidate] == old(votes[candidate]) + 1\n    {\n        votes[candidate] := votes[candidate] + 1;\n    }\n    method GetWinner() returns (winner: int)\n        requires votes.Length > 0\n        ensures 0 <= winner < votes.Length\n        ensures forall i :: 0 <= i < votes.Length ==> votes[winner] >= votes[i]\n    {\n        var maxVotes := votes[0];\n        winner := 0;\n        for i := 1 to votes.Length - 1\n            invariant 0 <= winner < votes.Length\n            invariant 0 <= i <= votes.Length\n            invariant forall j :: 0 <= j < i ==> votes[winner] >= votes[j]\n        {\n            if votes[i] > maxVotes {\n                maxVotes := votes[i];\n                winner := i;\n            }\n        }\n}\n}",
            "parents": [
                "node_133"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 24\n        for i := 1 to votes.Length - 1\n            invariant 0 <= winner < votes.Length\n            invariant 0 <= i <= votes.Length\n            invariant forall j :: 0 <= j < i ==> votes[winner] >= votes[j]\n        {\n            if votes[i] > maxVotes {\n                maxVotes := votes[i];\n                winner := i;\n            }\n        }\n// END DAFNY\n```"
        },
        {
            "id": "node_221",
            "type": "program",
            "content": "module GCDModule {\n    method EuclideanGCD(a: nat, b: nat) returns (gcd: nat)\n        requires a > 0 && b > 0\n        ensures gcd > 0\n        ensures a % gcd == 0 && b % gcd == 0\n        ensures forall d: nat :: d > 0 && a % d == 0 && b % d == 0 ==> gcd % d == 0\n    {\n        var x := a;\n        var y := b;\n        while y != 0\n            invariant x > 0\n            invariant y >= 0\n            invariant x % gcd == 0 && b % gcd == 0\n            invariant forall d: nat :: d > 0 && a % d == 0 && b % d == 0 ==> gcd % d == 0\n        {\n            var temp := y;\n            y := x % y;\n            x := temp;\n        }\n        gcd := x;\n    }\n}",
            "parents": [
                "idea_0"
            ],
            "diff": "```\n// BEGIN DAFNY\nmodule GCDModule {\n    method EuclideanGCD(a: nat, b: nat) returns (gcd: nat)\n        requires a > 0 && b > 0\n        ensures gcd > 0\n        ensures a % gcd == 0 && b % gcd == 0\n        ensures forall d: nat :: d > 0 && a % d == 0 && b % d == 0 ==> gcd % d == 0\n    {\n        var x := a;\n        var y := b;\n        while y != 0\n            invariant x > 0\n            invariant y >= 0\n            invariant x % gcd == 0 && b % gcd == 0\n            invariant forall d: nat :: d > 0 && a % d == 0 && b % d == 0 ==> gcd % d == 0\n        {\n            var temp := y;\n            y := x % y;\n            x := temp;\n        }\n        gcd := x;\n    }\n}\n// END DAFNY\n```\n\nThis program defines a method `EuclideanGCD` that calculates the greatest common divisor (GCD) of two positive integers using the Euclidean algorithm. The method includes formal specifications for correctness and termination, with loop invariants to ensure the properties of the GCD are maintained throughout the computation."
        },
        {
            "id": "node_222",
            "type": "program",
            "content": "class Matrix2x2 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    constructor(a: int, b: int, c: int, d: int)\n        ensures this.a == a && this.b == b && this.c == c && this.d == d\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n    }\n    method Determinant() returns (det: int)\n        ensures det == a * d - b * c\n    {\n        det := a * d - b * c;\n    }\nmethod MultiplyByScalar(scalar: int) returns (result: Matrix2x2)\n    ensures result.a == this.a * scalar\n    ensures result.b == this.b * scalar\n    ensures result.c == this.c * scalar\n    ensures result.d == this.d * scalar\n{\n    result := new Matrix2x2(this.a * scalar, this.b * scalar, this.c * scalar, this.d * scalar);\n}\nmethod Transpose() returns (result: Matrix2x2)\n    ensures result.a == this.a\n    ensures result.b == this.c\n    ensures result.c == this.b\n    ensures result.d == this.d\n{\n    result := new Matrix2x2(this.a, this.c, this.b, this.d);\n}\n}",
            "parents": [
                "node_199"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 19\nmethod MultiplyByScalar(scalar: int) returns (result: Matrix2x2)\n    ensures result.a == this.a * scalar\n    ensures result.b == this.b * scalar\n    ensures result.c == this.c * scalar\n    ensures result.d == this.d * scalar\n{\n    result := new Matrix2x2(this.a * scalar, this.b * scalar, this.c * scalar, this.d * scalar);\n}\n\nmethod Transpose() returns (result: Matrix2x2)\n    ensures result.a == this.a\n    ensures result.b == this.c\n    ensures result.c == this.b\n    ensures result.d == this.d\n{\n    result := new Matrix2x2(this.a, this.c, this.b, this.d);\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_223",
            "type": "program",
            "content": "class Matrix2x2 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    constructor(a: int, b: int, c: int, d: int)\n        ensures this.a == a && this.b == b && this.c == c && this.d == d\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n    }\n    method Transpose() returns (transposed: Matrix2x2)\n        ensures transposed.a == a && transposed.b == c && transposed.c == b && transposed.d == d\n    {\n        transposed := new Matrix2x2(a, c, b, d);\n    }\nmethod Multiply(other: Matrix2x2) returns (product: Matrix2x2)\n    ensures product.a == a * other.a + b * other.c\n    ensures product.b == a * other.b + b * other.d\n    ensures product.c == c * other.a + d * other.c\n    ensures product.d == c * other.b + d * other.d\n{\n    product := new Matrix2x2(\n        a * other.a + b * other.c,\n        a * other.b + b * other.d,\n        c * other.a + d * other.c,\n        c * other.b + d * other.d\n    );\n}\n}",
            "parents": [
                "node_146"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 19\nmethod Multiply(other: Matrix2x2) returns (product: Matrix2x2)\n    ensures product.a == a * other.a + b * other.c\n    ensures product.b == a * other.b + b * other.d\n    ensures product.c == c * other.a + d * other.c\n    ensures product.d == c * other.b + d * other.d\n{\n    product := new Matrix2x2(\n        a * other.a + b * other.c,\n        a * other.b + b * other.d,\n        c * other.a + d * other.c,\n        c * other.b + d * other.d\n    );\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_224",
            "type": "program",
            "content": "class Employee {\n    var hoursWorked: int;\n    var payRate: int;\n    constructor(hoursWorked: int, payRate: int)\n        ensures this.hoursWorked == hoursWorked && this.payRate == payRate\n    {\n        this.hoursWorked := hoursWorked;\n        this.payRate := payRate;\n    }\nmethod CalculateSalaryWithOvertime() returns (salary: int)\n    ensures salary >= hoursWorked * payRate\n{\n    var regularHours := if hoursWorked > 40 then 40 else hoursWorked;\n    var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n    var overtimeRate := payRate * 3 / 2;\n    salary := 0;\n    var i := 0;\n    while i < regularHours\n        invariant 0 <= i <= regularHours\n        invariant salary == i * payRate\n    {\n        salary := salary + payRate;\n        i := i + 1;\n    }\n    i := 0;\n    while i < overtimeHours\n        invariant 0 <= i <= overtimeHours\n        invariant salary == regularHours * payRate + i * overtimeRate\n    {\n        salary := salary + overtimeRate;\n        i := i + 1;\n    }\n}\n}",
            "parents": [
                "node_160"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 10\nmethod CalculateSalaryWithOvertime() returns (salary: int)\n    ensures salary >= hoursWorked * payRate\n{\n    var regularHours := if hoursWorked > 40 then 40 else hoursWorked;\n    var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n    var overtimeRate := payRate * 3 / 2;\n    salary := 0;\n    var i := 0;\n    while i < regularHours\n        invariant 0 <= i <= regularHours\n        invariant salary == i * payRate\n    {\n        salary := salary + payRate;\n        i := i + 1;\n    }\n    i := 0;\n    while i < overtimeHours\n        invariant 0 <= i <= overtimeHours\n        invariant salary == regularHours * payRate + i * overtimeRate\n    {\n        salary := salary + overtimeRate;\n        i := i + 1;\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_225",
            "type": "program",
            "content": "class VotingSystem {\n    var votes: array<int>;\n    constructor(n: int)\n        requires n > 0\n        ensures votes.Length == n\n        ensures forall i :: 0 <= i < n ==> votes[i] == 0\n    {\n        votes := new int[n];\n    }\n    method CastVote(candidate: int)\n        requires 0 <= candidate < votes.Length\n        modifies votes\n        ensures votes[candidate] == old(votes[candidate]) + 1\n    {\n        votes[candidate] := votes[candidate] + 1;\n    }\n    method GetWinner() returns (winner: int)\n        requires votes.Length > 0\n        ensures 0 <= winner < votes.Length\n        ensures forall i :: 0 <= i < votes.Length ==> votes[winner] >= votes[i]\n    {\n        var maxVotes := votes[0];\n        winner := 0;\n        for i := 1 to votes.Length - 1\n            invariant 0 <= winner < votes.Length\n            invariant 0 <= i <= votes.Length\n            invariant forall j :: 0 <= j < i ==> votes[winner] >= votes[j]\n        {\n            if votes[i] > maxVotes {\n                maxVotes := votes[i];\n                winner := i;\n            }\n        }\n}\n}",
            "parents": [
                "node_133"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 24\n        for i := 1 to votes.Length - 1\n            invariant 0 <= winner < votes.Length\n            invariant 0 <= i <= votes.Length\n            invariant forall j :: 0 <= j < i ==> votes[winner] >= votes[j]\n        {\n            if votes[i] > maxVotes {\n                maxVotes := votes[i];\n                winner := i;\n            }\n        }\n// END DAFNY\n```"
        },
        {
            "id": "node_226",
            "type": "program",
            "content": "module MatrixOperations {\n  method Determinant2x2(matrix: array2<real>) returns (det: real)\n    requires matrix.Length0 == 2 && matrix.Length1 == 2\n    ensures det == matrix[0, 0] * matrix[1, 1] - matrix[0, 1] * matrix[1, 0]\n  {\n    det := matrix[0, 0] * matrix[1, 1] - matrix[0, 1] * matrix[1, 0];\n  }\n  method Determinant3x3(matrix: array2<real>) returns (det: real)\n    requires matrix.Length0 == 3 && matrix.Length1 == 3\n    ensures det == matrix[0, 0] * (matrix[1, 1] * matrix[2, 2] - matrix[1, 2] * matrix[2, 1])\n                  - matrix[0, 1] * (matrix[1, 0] * matrix[2, 2] - matrix[1, 2] * matrix[2, 0])\n                  + matrix[0, 2] * (matrix[1, 0] * matrix[2, 1] - matrix[1, 1] * matrix[2, 0])\n  {\n    var a := matrix[0, 0];\n    var b := matrix[0, 1];\n    var c := matrix[0, 2];\n    var d := matrix[1, 0];\n    var e := matrix[1, 1];\n    var f := matrix[1, 2];\n    var g := matrix[2, 0];\n    var h := matrix[2, 1];\n    var i := matrix[2, 2];\n    det := a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g);\n  }\n}",
            "parents": [
                "idea_51"
            ],
            "diff": "```\n// BEGIN DAFNY\nmodule MatrixOperations {\n\n  method Determinant2x2(matrix: array2<real>) returns (det: real)\n    requires matrix.Length0 == 2 && matrix.Length1 == 2\n    ensures det == matrix[0, 0] * matrix[1, 1] - matrix[0, 1] * matrix[1, 0]\n  {\n    det := matrix[0, 0] * matrix[1, 1] - matrix[0, 1] * matrix[1, 0];\n  }\n\n  method Determinant3x3(matrix: array2<real>) returns (det: real)\n    requires matrix.Length0 == 3 && matrix.Length1 == 3\n    ensures det == matrix[0, 0] * (matrix[1, 1] * matrix[2, 2] - matrix[1, 2] * matrix[2, 1])\n                  - matrix[0, 1] * (matrix[1, 0] * matrix[2, 2] - matrix[1, 2] * matrix[2, 0])\n                  + matrix[0, 2] * (matrix[1, 0] * matrix[2, 1] - matrix[1, 1] * matrix[2, 0])\n  {\n    var a := matrix[0, 0];\n    var b := matrix[0, 1];\n    var c := matrix[0, 2];\n    var d := matrix[1, 0];\n    var e := matrix[1, 1];\n    var f := matrix[1, 2];\n    var g := matrix[2, 0];\n    var h := matrix[2, 1];\n    var i := matrix[2, 2];\n\n    det := a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g);\n  }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_227",
            "type": "program",
            "content": "class Matrix2x2 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    constructor(a: int, b: int, c: int, d: int)\n        ensures this.a == a && this.b == b && this.c == c && this.d == d\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n    }\n    method Determinant() returns (det: int)\n        ensures det == a * d - b * c\n    {\n        det := a * d - b * c;\n    }\nmethod MultiplyWithScalar(scalar: int) returns (result: Matrix2x2)\n    ensures result.a == a * scalar && result.b == b * scalar\n    ensures result.c == c * scalar && result.d == d * scalar\n{\n    result := new Matrix2x2(a * scalar, b * scalar, c * scalar, d * scalar);\n}\nmethod Transpose() returns (result: Matrix2x2)\n    ensures result.a == a && result.b == c\n    ensures result.c == b && result.d == d\n{\n    result := new Matrix2x2(a, c, b, d);\n}\nmethod IsIdentity() returns (isIdentity: bool)\n    ensures isIdentity == (a == 1 && b == 0 && c == 0 && d == 1)\n{\n    isIdentity := (a == 1 && b == 0 && c == 0 && d == 1);\n}\n}",
            "parents": [
                "node_201"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 19\nmethod MultiplyWithScalar(scalar: int) returns (result: Matrix2x2)\n    ensures result.a == a * scalar && result.b == b * scalar\n    ensures result.c == c * scalar && result.d == d * scalar\n{\n    result := new Matrix2x2(a * scalar, b * scalar, c * scalar, d * scalar);\n}\n\nmethod Transpose() returns (result: Matrix2x2)\n    ensures result.a == a && result.b == c\n    ensures result.c == b && result.d == d\n{\n    result := new Matrix2x2(a, c, b, d);\n}\n\nmethod IsIdentity() returns (isIdentity: bool)\n    ensures isIdentity == (a == 1 && b == 0 && c == 0 && d == 1)\n{\n    isIdentity := (a == 1 && b == 0 && c == 0 && d == 1);\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_228",
            "type": "program",
            "content": "class Matrix3x3 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    var e: int;\n    var f: int;\n    var g: int;\n    var h: int;\n    var i: int;\n    constructor(a: int, b: int, c: int, d: int, e: int, f: int, g: int, h: int, i: int)\n        ensures this.a == a && this.b == b && this.c == c\n        ensures this.d == d && this.e == e && this.f == f\n        ensures this.g == g && this.h == h && this.i == i\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n        this.e := e;\n        this.f := f;\n        this.g := g;\n        this.h := h;\n        this.i := i;\n    }\n    method Determinant() returns (det: int)\n        ensures det == a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g)\n    {\n        det := a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g);\n    }\nmethod Transpose() returns (transposed: Matrix3x3)\n    ensures transposed.a == this.a && transposed.b == this.d && transposed.c == this.g\n    ensures transposed.d == this.b && transposed.e == this.e && transposed.f == this.h\n    ensures transposed.g == this.c && transposed.h == this.f && transposed.i == this.i\n{\n    transposed := new Matrix3x3(this.a, this.d, this.g, this.b, this.e, this.h, this.c, this.f, this.i);\n}\nmethod IsSymmetric() returns (symmetric: bool)\n    ensures symmetric == (this.a == this.a && this.b == this.d && this.c == this.g && this.e == this.e && this.f == this.h && this.i == this.i)\n{\n    symmetric := (this.a == this.a && this.b == this.d && this.c == this.g && this.e == this.e && this.f == this.h && this.i == this.i);\n}\n}",
            "parents": [
                "node_200"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 31\nmethod Transpose() returns (transposed: Matrix3x3)\n    ensures transposed.a == this.a && transposed.b == this.d && transposed.c == this.g\n    ensures transposed.d == this.b && transposed.e == this.e && transposed.f == this.h\n    ensures transposed.g == this.c && transposed.h == this.f && transposed.i == this.i\n{\n    transposed := new Matrix3x3(this.a, this.d, this.g, this.b, this.e, this.h, this.c, this.f, this.i);\n}\n\nmethod IsSymmetric() returns (symmetric: bool)\n    ensures symmetric == (this.a == this.a && this.b == this.d && this.c == this.g && this.e == this.e && this.f == this.h && this.i == this.i)\n{\n    symmetric := (this.a == this.a && this.b == this.d && this.c == this.g && this.e == this.e && this.f == this.h && this.i == this.i);\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_229",
            "type": "program",
            "content": "class VotingSystem {\n    var votes: array<int>;\n    constructor (numCandidates: int)\n        requires numCandidates > 0\n    {\n        votes := new int[numCandidates];\n    }\n    method Vote(candidate: int)\n        requires 0 <= candidate < votes.Length\n        modifies votes\n        ensures votes[candidate] == old(votes[candidate]) + 1\n    {\n        votes[candidate] := votes[candidate] + 1;\n    }\n    method GetWinner() returns (winner: int)\n        requires votes.Length > 0\n        ensures 0 <= winner < votes.Length\n        ensures forall i: int :: 0 <= i < votes.Length ==> votes[winner] >= votes[i]\n    {\n        var maxVotes := votes[0];\n        winner := 0;\n        for i := 1 to votes.Length - 1\n            invariant 0 <= winner < votes.Length\n            invariant 0 <= i <= votes.Length\n            invariant forall j: int :: 0 <= j < i ==> votes[winner] >= votes[j]\n        {\n            if votes[i] > maxVotes {\n                maxVotes := votes[i];\n                winner := i;\n            }\n        }\n}\n}",
            "parents": [
                "node_193"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 22\n        for i := 1 to votes.Length - 1\n            invariant 0 <= winner < votes.Length\n            invariant 0 <= i <= votes.Length\n            invariant forall j: int :: 0 <= j < i ==> votes[winner] >= votes[j]\n        {\n            if votes[i] > maxVotes {\n                maxVotes := votes[i];\n                winner := i;\n            }\n        }\n// END DAFNY\n```"
        },
        {
            "id": "node_230",
            "type": "program",
            "content": "class Matrix2x2 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    constructor(a: int, b: int, c: int, d: int)\n        ensures this.a == a && this.b == b && this.c == c && this.d == d\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n    }\n    method Determinant() returns (det: int)\n        ensures det == a * d - b * c\n    {\n        det := a * d - b * c;\n    }\nmethod MultiplyByScalar(scalar: int) returns (result: Matrix2x2)\n    ensures result.a == this.a * scalar\n    ensures result.b == this.b * scalar\n    ensures result.c == this.c * scalar\n    ensures result.d == this.d * scalar\n{\n    result := new Matrix2x2(this.a * scalar, this.b * scalar, this.c * scalar, this.d * scalar);\n}\nmethod Transpose() returns (transposed: Matrix2x2)\n    ensures transposed.a == this.a\n    ensures transposed.b == this.c\n    ensures transposed.c == this.b\n    ensures transposed.d == this.d\n{\n    transposed := new Matrix2x2(this.a, this.c, this.b, this.d);\n}\n}",
            "parents": [
                "node_172"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 19\nmethod MultiplyByScalar(scalar: int) returns (result: Matrix2x2)\n    ensures result.a == this.a * scalar\n    ensures result.b == this.b * scalar\n    ensures result.c == this.c * scalar\n    ensures result.d == this.d * scalar\n{\n    result := new Matrix2x2(this.a * scalar, this.b * scalar, this.c * scalar, this.d * scalar);\n}\n\nmethod Transpose() returns (transposed: Matrix2x2)\n    ensures transposed.a == this.a\n    ensures transposed.b == this.c\n    ensures transposed.c == this.b\n    ensures transposed.d == this.d\n{\n    transposed := new Matrix2x2(this.a, this.c, this.b, this.d);\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_231",
            "type": "program",
            "content": "class LinearInequalitySolver {\n    method SolveInequality(a: int, b: int, c: int) returns (x: int)\n        requires a != 0\n        ensures a * x + b <= c\n    {\n        // A simple approach to find a solution for ax + b <= c\n        x := (c - b) / a;\n        if a * x + b > c {\n            x := x - 1;\n        }\n    }\n    method VerifySolution(a: int, b: int, c: int, x: int) returns (isValid: bool)\n        ensures isValid == (a * x + b <= c)\n    {\n        isValid := a * x + b <= c;\n    }\n}\n    method SolveStrictInequality(a: int, b: int, c: int) returns (x: int)\n        requires a != 0\n        ensures a * x + b < c\n    {\n        // A simple approach to find a solution for ax + b < c\n        x := (c - b) / a;\n        if a * x + b >= c {\n            x := x - 1;\n        }\n    }\n    method VerifyStrictSolution(a: int, b: int, c: int, x: int) returns (isValid: bool)\n        ensures isValid == (a * x + b < c)\n    {\n        isValid := a * x + b < c;\n    }\n    method SolveInequalityWithLoop(a: int, b: int, c: int) returns (x: int)\n        requires a != 0\n        ensures a * x + b <= c\n    {\n        var lowerBound := (c - b) / a;\n        x := lowerBound;\n        while a * x + b > c\n            invariant a * x + b > c\n            invariant x <= lowerBound\n            decreases x\n        {\n            x := x - 1;\n        }\n    }\n    method SolveStrictInequalityWithLoop(a: int, b: int, c: int) returns (x: int)\n        requires a != 0\n        ensures a * x + b < c\n    {\n        var lowerBound := (c - b) / a;\n        x := lowerBound;\n        while a * x + b >= c\n            invariant a * x + b >= c\n            invariant x <= lowerBound\n            decreases x\n        {\n            x := x - 1;\n        }\n    }",
            "parents": [
                "node_205"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 33\n    method SolveInequalityWithLoop(a: int, b: int, c: int) returns (x: int)\n        requires a != 0\n        ensures a * x + b <= c\n    {\n        var lowerBound := (c - b) / a;\n        x := lowerBound;\n        while a * x + b > c\n            invariant a * x + b > c\n            invariant x <= lowerBound\n            decreases x\n        {\n            x := x - 1;\n        }\n    }\n\n    method SolveStrictInequalityWithLoop(a: int, b: int, c: int) returns (x: int)\n        requires a != 0\n        ensures a * x + b < c\n    {\n        var lowerBound := (c - b) / a;\n        x := lowerBound;\n        while a * x + b >= c\n            invariant a * x + b >= c\n            invariant x <= lowerBound\n            decreases x\n        {\n            x := x - 1;\n        }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_232",
            "type": "program",
            "content": "class TrafficLight {\n    var state: string;\n    constructor()\n        ensures state == \"Red\"\n    {\n        state := \"Red\";\n    }\n    method NextState()\n        modifies this\n        ensures (old(state) == \"Red\" ==> state == \"Green\") &&\n                (old(state) == \"Green\" ==> state == \"Yellow\") &&\n                (old(state) == \"Yellow\" ==> state == \"Red\")\n    {\n        if state == \"Red\" {\n            state := \"Green\";\n        } else if state == \"Green\" {\n            state := \"Yellow\";\n        } else if state == \"Yellow\" {\n            state := \"Red\";\n        }\n    }\n}\nmethod SimulateTrafficLight(steps: nat)\n    requires steps > 0\n    ensures true\n{\n    var light := new TrafficLight();\n    var i := 0;\n    while i < steps\n        invariant 0 <= i <= steps\n        invariant light.state == \"Red\" || light.state == \"Green\" || light.state == \"Yellow\"\n    {\n        light.NextState();\n        i := i + 1;\n    }\n}",
            "parents": [
                "idea_22"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\nclass TrafficLight {\n    var state: string;\n\n    constructor()\n        ensures state == \"Red\"\n    {\n        state := \"Red\";\n    }\n\n    method NextState()\n        modifies this\n        ensures (old(state) == \"Red\" ==> state == \"Green\") &&\n                (old(state) == \"Green\" ==> state == \"Yellow\") &&\n                (old(state) == \"Yellow\" ==> state == \"Red\")\n    {\n        if state == \"Red\" {\n            state := \"Green\";\n        } else if state == \"Green\" {\n            state := \"Yellow\";\n        } else if state == \"Yellow\" {\n            state := \"Red\";\n        }\n    }\n}\n\nmethod SimulateTrafficLight(steps: nat)\n    requires steps > 0\n    ensures true\n{\n    var light := new TrafficLight();\n    var i := 0;\n    while i < steps\n        invariant 0 <= i <= steps\n        invariant light.state == \"Red\" || light.state == \"Green\" || light.state == \"Yellow\"\n    {\n        light.NextState();\n        i := i + 1;\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_233",
            "type": "program",
            "content": "class VotingSystem {\n    var votes: array<int>;\n    constructor (numCandidates: int)\n        requires numCandidates > 0\n    {\n        votes := new int[numCandidates];\n    }\n    method Vote(candidate: int)\n        requires 0 <= candidate < votes.Length\n        modifies votes\n        ensures votes[candidate] == old(votes[candidate]) + 1\n    {\n        votes[candidate] := votes[candidate] + 1;\n    }\n    method GetWinner() returns (winner: int)\n        requires votes.Length > 0\n        ensures 0 <= winner < votes.Length\n        ensures forall i: int :: 0 <= i < votes.Length ==> votes[winner] >= votes[i]\n    {\n        var maxVotes := votes[0];\n        winner := 0;\n        for i := 1 to votes.Length - 1\n            invariant 0 <= winner < votes.Length\n            invariant 0 <= i <= votes.Length\n            invariant forall j: int :: 0 <= j < i ==> votes[winner] >= votes[j]\n        {\n            if votes[i] > maxVotes {\n                maxVotes := votes[i];\n                winner := i;\n            }\n        }\n}\n}",
            "parents": [
                "node_193"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 22\n        for i := 1 to votes.Length - 1\n            invariant 0 <= winner < votes.Length\n            invariant 0 <= i <= votes.Length\n            invariant forall j: int :: 0 <= j < i ==> votes[winner] >= votes[j]\n        {\n            if votes[i] > maxVotes {\n                maxVotes := votes[i];\n                winner := i;\n            }\n        }\n// END DAFNY\n```"
        },
        {
            "id": "node_234",
            "type": "program",
            "content": "class Employee {\n    var hoursWorked: int;\n    var payRate: int;\n    constructor(hoursWorked: int, payRate: int)\n        ensures this.hoursWorked == hoursWorked && this.payRate == payRate\n    {\n        this.hoursWorked := hoursWorked;\n        this.payRate := payRate;\n    }\nmethod CalculateSalaryWithOvertime() returns (salary: int)\n    ensures salary == hoursWorked * payRate + (if hoursWorked > 40 then (hoursWorked - 40) * payRate / 2 else 0)\n{\n    var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n    var regularHours := hoursWorked - overtimeHours;\n    salary := 0;\n    var i := 0;\n    while i < regularHours\n        invariant 0 <= i <= regularHours\n        invariant salary == i * payRate\n    {\n        salary := salary + payRate;\n        i := i + 1;\n    }\n    i := 0;\n    while i < overtimeHours\n        invariant 0 <= i <= overtimeHours\n        invariant salary == regularHours * payRate + i * payRate / 2\n    {\n        salary := salary + payRate / 2;\n        i := i + 1;\n    }\n}\n}",
            "parents": [
                "node_216"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 10\nmethod CalculateSalaryWithOvertime() returns (salary: int)\n    ensures salary == hoursWorked * payRate + (if hoursWorked > 40 then (hoursWorked - 40) * payRate / 2 else 0)\n{\n    var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n    var regularHours := hoursWorked - overtimeHours;\n    salary := 0;\n    var i := 0;\n    while i < regularHours\n        invariant 0 <= i <= regularHours\n        invariant salary == i * payRate\n    {\n        salary := salary + payRate;\n        i := i + 1;\n    }\n    i := 0;\n    while i < overtimeHours\n        invariant 0 <= i <= overtimeHours\n        invariant salary == regularHours * payRate + i * payRate / 2\n    {\n        salary := salary + payRate / 2;\n        i := i + 1;\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_235",
            "type": "program",
            "content": "class SudokuValidator {\n    var grid: array2<int>;\n    constructor(grid: array2<int>)\n        requires grid.Length0 == 9 && grid.Length1 == 9\n        ensures this.grid == grid\n    {\n        this.grid := grid;\n    }\n    method IsRowValid(row: int) returns (isValid: bool)\n        requires 0 <= row < 9\n        ensures isValid == (forall i, j :: 0 <= i < j < 9 ==> grid[row, i] != grid[row, j])\n    {\n        var seen := new bool[10];\n        isValid := true;\n        for i := 0 to 8 {\n            if grid[row, i] < 1 || grid[row, i] > 9 || seen[grid[row, i]] {\n                isValid := false;\n                return;\n            }\n            seen[grid[row, i]] := true;\n        }\n    }\n    method IsColumnValid(col: int) returns (isValid: bool)\n        requires 0 <= col < 9\n        ensures isValid == (forall i, j :: 0 <= i < j < 9 ==> grid[i, col] != grid[j, col])\n    {\n        var seen := new bool[10];\n        isValid := true;\n        for i := 0 to 8 {\n            if grid[i, col] < 1 || grid[i, col] > 9 || seen[grid[i, col]] {\n                isValid := false;\n                return;\n            }\n            seen[grid[i, col]] := true;\n        }\n    }\n    method IsSubgridValid(subgridRow: int, subgridCol: int) returns (isValid: bool)\n        requires 0 <= subgridRow < 3 && 0 <= subgridCol < 3\n        ensures isValid == (forall i, j :: 0 <= i < j < 9 ==> grid[subgridRow * 3 + i / 3, subgridCol * 3 + i % 3] != grid[subgridRow * 3 + j / 3, subgridCol * 3 + j % 3])\n    {\n        var seen := new bool[10];\n        isValid := true;\n        for i := 0 to 8\n            invariant 0 <= i <= 9\n            invariant forall k :: 0 <= k < i ==> 1 <= grid[subgridRow * 3 + k / 3, subgridCol * 3 + k % 3] <= 9\n            invariant forall k :: 0 <= k < i ==> !seen[grid[subgridRow * 3 + k / 3, subgridCol * 3 + k % 3]]\n        {\n            var value := grid[subgridRow * 3 + i / 3, subgridCol * 3 + i % 3];\n            if value < 1 || value > 9 || seen[value] {\n                isValid := false;\n                return;\n            }\n            seen[value] := true;\n        }\n    }\n}",
            "parents": [
                "node_103"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 37\n    method IsSubgridValid(subgridRow: int, subgridCol: int) returns (isValid: bool)\n        requires 0 <= subgridRow < 3 && 0 <= subgridCol < 3\n        ensures isValid == (forall i, j :: 0 <= i < j < 9 ==> grid[subgridRow * 3 + i / 3, subgridCol * 3 + i % 3] != grid[subgridRow * 3 + j / 3, subgridCol * 3 + j % 3])\n    {\n        var seen := new bool[10];\n        isValid := true;\n        for i := 0 to 8\n            invariant 0 <= i <= 9\n            invariant forall k :: 0 <= k < i ==> 1 <= grid[subgridRow * 3 + k / 3, subgridCol * 3 + k % 3] <= 9\n            invariant forall k :: 0 <= k < i ==> !seen[grid[subgridRow * 3 + k / 3, subgridCol * 3 + k % 3]]\n        {\n            var value := grid[subgridRow * 3 + i / 3, subgridCol * 3 + i % 3];\n            if value < 1 || value > 9 || seen[value] {\n                isValid := false;\n                return;\n            }\n            seen[value] := true;\n        }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_236",
            "type": "program",
            "content": "class Matrix2x2 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    constructor(a: int, b: int, c: int, d: int)\n        ensures this.a == a && this.b == b && this.c == c && this.d == d\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n    }\n    method Transpose() returns (transposed: Matrix2x2)\n        ensures transposed.a == a && transposed.b == c && transposed.c == b && transposed.d == d\n    {\n        transposed := new Matrix2x2(a, c, b, d);\n    }\nmethod Multiply(other: Matrix2x2) returns (product: Matrix2x2)\n    ensures product.a == a * other.a + b * other.c\n    ensures product.b == a * other.b + b * other.d\n    ensures product.c == c * other.a + d * other.c\n    ensures product.d == c * other.b + d * other.d\n{\n    product := new Matrix2x2(\n        a * other.a + b * other.c,\n        a * other.b + b * other.d,\n        c * other.a + d * other.c,\n        c * other.b + d * other.d\n    );\n}\n}",
            "parents": [
                "node_135"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 19\nmethod Multiply(other: Matrix2x2) returns (product: Matrix2x2)\n    ensures product.a == a * other.a + b * other.c\n    ensures product.b == a * other.b + b * other.d\n    ensures product.c == c * other.a + d * other.c\n    ensures product.d == c * other.b + d * other.d\n{\n    product := new Matrix2x2(\n        a * other.a + b * other.c,\n        a * other.b + b * other.d,\n        c * other.a + d * other.c,\n        c * other.b + d * other.d\n    );\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_237",
            "type": "program",
            "content": "class PayrollSystem {\n    method CalculateSalary(hoursWorked: int, payRate: int) returns (salary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        ensures salary >= 0\n    {\n        salary := hoursWorked * payRate;\n    }\n    method CalculateOvertimeSalary(hoursWorked: int, payRate: int, overtimeRate: int) returns (totalSalary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        requires overtimeRate >= payRate\n        ensures totalSalary >= 0\n    {\n        var regularHours := if hoursWorked > 40 then 40 else hoursWorked;\n        var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n        var regularSalary := regularHours * payRate;\n        var overtimeSalary := overtimeHours * overtimeRate;\n        totalSalary := regularSalary + overtimeSalary;\n    }\n    method CalculateWeeklySalary(hoursWorked: int, payRate: int, overtimeRate: int) returns (weeklySalary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        requires overtimeRate >= payRate\n        ensures weeklySalary >= 0\n    {\n        var totalHours := hoursWorked;\n        var totalSalary := 0;\n        while totalHours > 0\n            invariant totalHours >= 0\n            invariant totalSalary >= 0\n        {\n            if totalHours > 40 {\n                totalSalary := totalSalary + (40 * payRate) + ((totalHours - 40) * overtimeRate);\n                totalHours := 0;\n            } else {\n                totalSalary := totalSalary + (totalHours * payRate);\n                totalHours := 0;\n            }\n        }\n        weeklySalary := totalSalary;\n    }\n}",
            "parents": [
                "node_123"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 21\n    method CalculateWeeklySalary(hoursWorked: int, payRate: int, overtimeRate: int) returns (weeklySalary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        requires overtimeRate >= payRate\n        ensures weeklySalary >= 0\n    {\n        var totalHours := hoursWorked;\n        var totalSalary := 0;\n        while totalHours > 0\n            invariant totalHours >= 0\n            invariant totalSalary >= 0\n        {\n            if totalHours > 40 {\n                totalSalary := totalSalary + (40 * payRate) + ((totalHours - 40) * overtimeRate);\n                totalHours := 0;\n            } else {\n                totalSalary := totalSalary + (totalHours * payRate);\n                totalHours := 0;\n            }\n        }\n        weeklySalary := totalSalary;\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_238",
            "type": "program",
            "content": "method Median(a: array<int>) returns (median: int)\n    requires a != null && a.Length > 0\n    ensures 0 <= median < a.Length\n    ensures forall i: int :: 0 <= i < a.Length ==> a[median] <= a[i] || a[median] >= a[i]\n{\n    var n := a.Length;\n    var sorted := new int[n];\n    // Copy the array\n    for i := 0 to n - 1\n        invariant 0 <= i <= n\n        invariant forall j: int :: 0 <= j < i ==> sorted[j] == a[j]\n    {\n        sorted[i] := a[i];\n    }\n    // Sort the array (simple insertion sort for demonstration)\n    for i := 1 to n - 1\n        invariant 1 <= i <= n\n        invariant forall j: int, k: int :: 0 <= j < k < i ==> sorted[j] <= sorted[k]\n}",
            "parents": [
                "node_212"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 18\n        invariant forall j: int, k: int :: 0 <= j < k < i ==> sorted[j] <= sorted[k]\n// END DAFNY\n```"
        },
        {
            "id": "node_239",
            "type": "program",
            "content": "class BasicSpellChecker {\n    var dictionary: seq<string>;\n    constructor(words: seq<string>)\n        ensures dictionary == words\n    {\n        dictionary := words;\n    }\n    method IsWordCorrect(word: string) returns (isCorrect: bool)\n        ensures isCorrect == (word in dictionary)\n    {\n        isCorrect := word in dictionary;\n    }\n    method SuggestCorrections(word: string) returns (suggestions: seq<string>)\n        ensures forall s :: s in suggestions ==> |s| == |word| && (s in dictionary)\n    {\n        suggestions := [];\n        var wordLength := |word|;\n        // Loop through the dictionary to find words of the same length\n        var i: int := 0;\n        while i < |dictionary|\n            invariant 0 <= i <= |dictionary|\n            invariant forall j :: 0 <= j < i ==> |dictionary[j]| == wordLength ==> dictionary[j] in suggestions\n        {\n            if |dictionary[i]| == wordLength {\n                suggestions := suggestions + [dictionary[i]];\n            }\n            i := i + 1;\n        }\n    }\n}",
            "parents": [
                "idea_82"
            ],
            "diff": "```\n// BEGIN DAFNY\nclass BasicSpellChecker {\n    var dictionary: seq<string>;\n\n    constructor(words: seq<string>)\n        ensures dictionary == words\n    {\n        dictionary := words;\n    }\n\n    method IsWordCorrect(word: string) returns (isCorrect: bool)\n        ensures isCorrect == (word in dictionary)\n    {\n        isCorrect := word in dictionary;\n    }\n\n    method SuggestCorrections(word: string) returns (suggestions: seq<string>)\n        ensures forall s :: s in suggestions ==> |s| == |word| && (s in dictionary)\n    {\n        suggestions := [];\n        var wordLength := |word|;\n\n        // Loop through the dictionary to find words of the same length\n        var i: int := 0;\n        while i < |dictionary|\n            invariant 0 <= i <= |dictionary|\n            invariant forall j :: 0 <= j < i ==> |dictionary[j]| == wordLength ==> dictionary[j] in suggestions\n        {\n            if |dictionary[i]| == wordLength {\n                suggestions := suggestions + [dictionary[i]];\n            }\n            i := i + 1;\n        }\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_240",
            "type": "program",
            "content": "method GCD(a: nat, b: nat) returns (gcd: nat)\n    requires a > 0 && b > 0\n    ensures gcd > 0\n    ensures a % gcd == 0 && b % gcd == 0\n    ensures forall d: nat :: d > 0 && a % d == 0 && b % d == 0 ==> gcd >= d\n{\n    var x := a;\n    var y := b;\n    while y != 0\n        invariant x > 0\n        invariant y >= 0\n        invariant x % gcd == 0 && y % gcd == 0\n}",
            "parents": [
                "node_137"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 12\n        invariant x % gcd == 0 && y % gcd == 0\n// END DAFNY\n```"
        },
        {
            "id": "node_241",
            "type": "program",
            "content": "class Employee {\n    var hoursWorked: int;\n    var payRate: int;\n    constructor(hoursWorked: int, payRate: int)\n        ensures this.hoursWorked == hoursWorked && this.payRate == payRate\n    {\n        this.hoursWorked := hoursWorked;\n        this.payRate := payRate;\n    }\n    method CalculateSalary() returns (salary: int)\n        ensures salary == hoursWorked * payRate\n    {\n        salary := hoursWorked * payRate;\n    }\nmethod CalculateOvertimeSalary(overtimeRate: int) returns (overtimeSalary: int)\n    requires overtimeRate > payRate\n    ensures overtimeSalary == (hoursWorked * payRate) + ((hoursWorked - 40) * (overtimeRate - payRate))\n{\n    if hoursWorked > 40 {\n        var regularSalary := 40 * payRate;\n        var overtimeHours := hoursWorked - 40;\n        overtimeSalary := regularSalary + (overtimeHours * overtimeRate);\n    } else {\n        overtimeSalary := hoursWorked * payRate;\n    }\n}\n}",
            "parents": [
                "node_118"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 15\nmethod CalculateOvertimeSalary(overtimeRate: int) returns (overtimeSalary: int)\n    requires overtimeRate > payRate\n    ensures overtimeSalary == (hoursWorked * payRate) + ((hoursWorked - 40) * (overtimeRate - payRate))\n{\n    if hoursWorked > 40 {\n        var regularSalary := 40 * payRate;\n        var overtimeHours := hoursWorked - 40;\n        overtimeSalary := regularSalary + (overtimeHours * overtimeRate);\n    } else {\n        overtimeSalary := hoursWorked * payRate;\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_242",
            "type": "program",
            "content": "class Matrix2x2 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    constructor(a: int, b: int, c: int, d: int)\n        ensures this.a == a && this.b == b && this.c == c && this.d == d\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n    }\n    method Determinant() returns (det: int)\n        ensures det == a * d - b * c\n    {\n        det := a * d - b * c;\n    }\nmethod MultiplyByScalar(scalar: int) returns (result: Matrix2x2)\n    ensures result.a == this.a * scalar\n    ensures result.b == this.b * scalar\n    ensures result.c == this.c * scalar\n    ensures result.d == this.d * scalar\n{\n    result := new Matrix2x2(this.a * scalar, this.b * scalar, this.c * scalar, this.d * scalar);\n}\nmethod Transpose() returns (transposed: Matrix2x2)\n    ensures transposed.a == this.a\n    ensures transposed.b == this.c\n    ensures transposed.c == this.b\n    ensures transposed.d == this.d\n{\n    transposed := new Matrix2x2(this.a, this.c, this.b, this.d);\n}\n}",
            "parents": [
                "node_190"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 19\nmethod MultiplyByScalar(scalar: int) returns (result: Matrix2x2)\n    ensures result.a == this.a * scalar\n    ensures result.b == this.b * scalar\n    ensures result.c == this.c * scalar\n    ensures result.d == this.d * scalar\n{\n    result := new Matrix2x2(this.a * scalar, this.b * scalar, this.c * scalar, this.d * scalar);\n}\n\nmethod Transpose() returns (transposed: Matrix2x2)\n    ensures transposed.a == this.a\n    ensures transposed.b == this.c\n    ensures transposed.c == this.b\n    ensures transposed.d == this.d\n{\n    transposed := new Matrix2x2(this.a, this.c, this.b, this.d);\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_243",
            "type": "program",
            "content": "class Matrix3x3 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    var e: int;\n    var f: int;\n    var g: int;\n    var h: int;\n    var i: int;\n    constructor(a: int, b: int, c: int, d: int, e: int, f: int, g: int, h: int, i: int)\n        ensures this.a == a && this.b == b && this.c == c\n        ensures this.d == d && this.e == e && this.f == f\n        ensures this.g == g && this.h == h && this.i == i\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n        this.e := e;\n        this.f := f;\n        this.g := g;\n        this.h := h;\n        this.i := i;\n    }\n    method Transpose() returns (transposed: Matrix3x3)\n        ensures transposed.a == a && transposed.b == d && transposed.c == g\n        ensures transposed.d == b && transposed.e == e && transposed.f == h\n        ensures transposed.g == c && transposed.h == f && transposed.i == i\n    {\n        transposed := new Matrix3x3(a, d, g, b, e, h, c, f, i);\n    }\nmethod Multiply(other: Matrix3x3) returns (product: Matrix3x3)\n    ensures product.a == a * other.a + b * other.d + c * other.g\n    ensures product.b == a * other.b + b * other.e + c * other.h\n    ensures product.c == a * other.c + b * other.f + c * other.i\n    ensures product.d == d * other.a + e * other.d + f * other.g\n    ensures product.e == d * other.b + e * other.e + f * other.h\n    ensures product.f == d * other.c + e * other.f + f * other.i\n    ensures product.g == g * other.a + h * other.d + i * other.g\n    ensures product.h == g * other.b + h * other.e + i * other.h\n    ensures product.i == g * other.c + h * other.f + i * other.i\n{\n    var p_a := a * other.a + b * other.d + c * other.g;\n    var p_b := a * other.b + b * other.e + c * other.h;\n    var p_c := a * other.c + b * other.f + c * other.i;\n    var p_d := d * other.a + e * other.d + f * other.g;\n    var p_e := d * other.b + e * other.e + f * other.h;\n    var p_f := d * other.c + e * other.f + f * other.i;\n    var p_g := g * other.a + h * other.d + i * other.g;\n    var p_h := g * other.b + h * other.e + i * other.h;\n    var p_i := g * other.c + h * other.f + i * other.i;\n    product := new Matrix3x3(p_a, p_b, p_c, p_d, p_e, p_f, p_g, p_h, p_i);\n}\n}",
            "parents": [
                "node_139"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 33\nmethod Multiply(other: Matrix3x3) returns (product: Matrix3x3)\n    ensures product.a == a * other.a + b * other.d + c * other.g\n    ensures product.b == a * other.b + b * other.e + c * other.h\n    ensures product.c == a * other.c + b * other.f + c * other.i\n    ensures product.d == d * other.a + e * other.d + f * other.g\n    ensures product.e == d * other.b + e * other.e + f * other.h\n    ensures product.f == d * other.c + e * other.f + f * other.i\n    ensures product.g == g * other.a + h * other.d + i * other.g\n    ensures product.h == g * other.b + h * other.e + i * other.h\n    ensures product.i == g * other.c + h * other.f + i * other.i\n{\n    var p_a := a * other.a + b * other.d + c * other.g;\n    var p_b := a * other.b + b * other.e + c * other.h;\n    var p_c := a * other.c + b * other.f + c * other.i;\n    var p_d := d * other.a + e * other.d + f * other.g;\n    var p_e := d * other.b + e * other.e + f * other.h;\n    var p_f := d * other.c + e * other.f + f * other.i;\n    var p_g := g * other.a + h * other.d + i * other.g;\n    var p_h := g * other.b + h * other.e + i * other.h;\n    var p_i := g * other.c + h * other.f + i * other.i;\n\n    product := new Matrix3x3(p_a, p_b, p_c, p_d, p_e, p_f, p_g, p_h, p_i);\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_244",
            "type": "program",
            "content": "class City {\n    var id: int;\n    constructor(id: int)\n        ensures this.id == id\n    {\n        this.id := id;\n    }\n}\nclass Tour {\n    var cities: seq<City>;\n    constructor(cities: seq<City>)\n        ensures this.cities == cities\n    {\n        this.cities := cities;\n    }\n    method IsValidTour() returns (isValid: bool)\n        ensures isValid == (|cities| > 1 && cities[0] == cities[|cities| - 1])\n    {\n        isValid := false;\n        if |cities| > 1 {\n            var i := 0;\n            while i < |cities| - 1\n                invariant 0 <= i <= |cities| - 1\n                invariant forall j :: 0 <= j < i ==> cities[j] != cities[|cities| - 1]\n            {\n                if cities[i] == cities[|cities| - 1] {\n                    isValid := true;\n                    break;\n                }\n                i := i + 1;\n            }\n        }\n    }\n}",
            "parents": [
                "node_158"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 16\n    method IsValidTour() returns (isValid: bool)\n        ensures isValid == (|cities| > 1 && cities[0] == cities[|cities| - 1])\n    {\n        isValid := false;\n        if |cities| > 1 {\n            var i := 0;\n            while i < |cities| - 1\n                invariant 0 <= i <= |cities| - 1\n                invariant forall j :: 0 <= j < i ==> cities[j] != cities[|cities| - 1]\n            {\n                if cities[i] == cities[|cities| - 1] {\n                    isValid := true;\n                    break;\n                }\n                i := i + 1;\n            }\n        }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_245",
            "type": "program",
            "content": "class Matrix2x2 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    constructor(a: int, b: int, c: int, d: int)\n        ensures this.a == a && this.b == b && this.c == c && this.d == d\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n    }\n    method Determinant() returns (det: int)\n        ensures det == a * d - b * c\n    {\n        det := a * d - b * c;\n    }\nmethod MultiplyByScalar(scalar: int) returns (result: Matrix2x2)\n    ensures result.a == this.a * scalar\n    ensures result.b == this.b * scalar\n    ensures result.c == this.c * scalar\n    ensures result.d == this.d * scalar\n{\n    result := new Matrix2x2(this.a * scalar, this.b * scalar, this.c * scalar, this.d * scalar);\n}\nmethod Transpose() returns (result: Matrix2x2)\n    ensures result.a == this.a\n    ensures result.b == this.c\n    ensures result.c == this.b\n    ensures result.d == this.d\n{\n    result := new Matrix2x2(this.a, this.c, this.b, this.d);\n}\n}",
            "parents": [
                "node_190"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 19\nmethod MultiplyByScalar(scalar: int) returns (result: Matrix2x2)\n    ensures result.a == this.a * scalar\n    ensures result.b == this.b * scalar\n    ensures result.c == this.c * scalar\n    ensures result.d == this.d * scalar\n{\n    result := new Matrix2x2(this.a * scalar, this.b * scalar, this.c * scalar, this.d * scalar);\n}\n\nmethod Transpose() returns (result: Matrix2x2)\n    ensures result.a == this.a\n    ensures result.b == this.c\n    ensures result.c == this.b\n    ensures result.d == this.d\n{\n    result := new Matrix2x2(this.a, this.c, this.b, this.d);\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_246",
            "type": "program",
            "content": "class FlightBookingSystem {\n    var totalSeats: nat;\n    var bookedSeats: nat;\n    constructor(totalSeats: nat)\n        requires totalSeats > 0\n        ensures this.totalSeats == totalSeats && this.bookedSeats == 0\n    {\n        this.totalSeats := totalSeats;\n        this.bookedSeats := 0;\n    }\n    method BookSeat() returns (success: bool)\n        ensures success ==> bookedSeats <= totalSeats\n        ensures !success ==> bookedSeats == totalSeats\n    {\n        if bookedSeats < totalSeats {\n            bookedSeats := bookedSeats + 1;\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n    method CancelSeat() returns (success: bool)\n        ensures success ==> bookedSeats >= 0\n        ensures !success ==> bookedSeats == 0\n    {\n        if bookedSeats > 0 {\n            bookedSeats := bookedSeats - 1;\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n    method BookMultipleSeats(n: nat) returns (success: bool)\n        requires n > 0\n        ensures success ==> bookedSeats <= totalSeats\n        ensures !success ==> bookedSeats + n > totalSeats\n    {\n        var i: nat := 0;\n        success := true;\n        while i < n\n            invariant 0 <= i <= n\n            invariant bookedSeats <= totalSeats\n            invariant success ==> bookedSeats + (n - i) <= totalSeats\n        {\n            if bookedSeats < totalSeats {\n                bookedSeats := bookedSeats + 1;\n            } else {\n                success := false;\n                break;\n            }\n            i := i + 1;\n        }\n    }\n}",
            "parents": [
                "node_215"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 33\n    method BookMultipleSeats(n: nat) returns (success: bool)\n        requires n > 0\n        ensures success ==> bookedSeats <= totalSeats\n        ensures !success ==> bookedSeats + n > totalSeats\n    {\n        var i: nat := 0;\n        success := true;\n        while i < n\n            invariant 0 <= i <= n\n            invariant bookedSeats <= totalSeats\n            invariant success ==> bookedSeats + (n - i) <= totalSeats\n        {\n            if bookedSeats < totalSeats {\n                bookedSeats := bookedSeats + 1;\n            } else {\n                success := false;\n                break;\n            }\n            i := i + 1;\n        }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_247",
            "type": "program",
            "content": "method QuickSort(a: array<int>) \n    requires a != null\n    modifies a\n    ensures forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n    ensures multiset(a[..]) == multiset(old(a[..]))\n{\n    QuickSortHelper(a, 0, a.Length - 1);\n}\nmethod QuickSortHelper(a: array<int>, low: int, high: int)\n    requires a != null && 0 <= low <= high + 1 <= a.Length\n    modifies a\n    ensures forall i, j :: low <= i < j <= high ==> a[i] <= a[j]\n    ensures multiset(a[low..high+1]) == multiset(old(a[low..high+1]))\n{\n    if low < high {\n        var pivotIndex := Partition(a, low, high);\n        QuickSortHelper(a, low, pivotIndex - 1);\n        QuickSortHelper(a, pivotIndex + 1, high);\n    }\n}\nmethod Partition(a: array<int>, low: int, high: int) returns (pivotIndex: int)\n    requires a != null && 0 <= low <= high < a.Length\n    modifies a\n    ensures low <= pivotIndex <= high\n    ensures forall i :: low <= i < pivotIndex ==> a[i] <= a[pivotIndex]\n    ensures forall i :: pivotIndex < i <= high ==> a[pivotIndex] <= a[i]\n    ensures multiset(a[low..high+1]) == multiset(old(a[low..high+1]))\n{\n    var pivot := a[high];\n    var i := low - 1;\n    for j := low to high - 1\n        invariant low <= j <= high\n        invariant low - 1 <= i < j\n        invariant forall k :: low <= k <= i ==> a[k] <= pivot\n        invariant forall k :: i < k < j ==> a[k] > pivot\n    {\n        if a[j] <= pivot {\n            i := i + 1;\n            var temp := a[i];\n            a[i] := a[j];\n            a[j] := temp;\n        }\n    }\n    i := i + 1;\n    var temp := a[i];\n    a[i] := a[high];\n    a[high] := temp;\n    return i;\n}",
            "parents": [
                "node_219"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 44\n    i := i + 1;\n    var temp := a[i];\n    a[i] := a[high];\n    a[high] := temp;\n    return i;\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_248",
            "type": "program",
            "content": "class LinearInequalitiesSolver {\n    method SolveSingleInequality(a: int, b: int, c: int) returns (solution: bool)\n        requires a != 0\n        ensures solution == (c >= b / a)\n    {\n        if a > 0 {\n            solution := c >= b / a;\n        } else {\n            solution := c <= b / a;\n        }\n    }\n    method VerifySolution(a: int, b: int, c: int, x: int) returns (isValid: bool)\n        requires a != 0\n        ensures isValid == (a * x + b <= c)\n    {\n        isValid := a * x + b <= c;\n    }\n    method SolveMultipleInequalitiesWithThreshold(a: seq<int>, b: seq<int>, c: seq<int>, threshold: int) returns (solutions: seq<bool>)\n        requires |a| == |b| && |b| == |c|\n        requires forall i :: 0 <= i < |a| ==> a[i] != 0\n        ensures |solutions| == |a|\n        ensures forall i :: 0 <= i < |solutions| ==> solutions[i] == (if a[i] > 0 then c[i] >= b[i] / a[i] + threshold else c[i] <= b[i] / a[i] - threshold)\n    {\n        solutions := [];\n        var i := 0;\n        while i < |a|\n            invariant 0 <= i <= |a|\n            invariant |solutions| == i\n            invariant forall j :: 0 <= j < i ==> solutions[j] == (if a[j] > 0 then c[j] >= b[j] / a[j] + threshold else c[j] <= b[j] / a[j] - threshold)\n        {\n            if a[i] > 0 {\n                solutions := solutions + [c[i] >= b[i] / a[i] + threshold];\n            } else {\n                solutions := solutions + [c[i] <= b[i] / a[i] - threshold];\n            }\n            i := i + 1;\n        }\n    }\n}",
            "parents": [
                "node_208"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 18\n    method SolveMultipleInequalitiesWithThreshold(a: seq<int>, b: seq<int>, c: seq<int>, threshold: int) returns (solutions: seq<bool>)\n        requires |a| == |b| && |b| == |c|\n        requires forall i :: 0 <= i < |a| ==> a[i] != 0\n        ensures |solutions| == |a|\n        ensures forall i :: 0 <= i < |solutions| ==> solutions[i] == (if a[i] > 0 then c[i] >= b[i] / a[i] + threshold else c[i] <= b[i] / a[i] - threshold)\n    {\n        solutions := [];\n        var i := 0;\n        while i < |a|\n            invariant 0 <= i <= |a|\n            invariant |solutions| == i\n            invariant forall j :: 0 <= j < i ==> solutions[j] == (if a[j] > 0 then c[j] >= b[j] / a[j] + threshold else c[j] <= b[j] / a[j] - threshold)\n        {\n            if a[i] > 0 {\n                solutions := solutions + [c[i] >= b[i] / a[i] + threshold];\n            } else {\n                solutions := solutions + [c[i] <= b[i] / a[i] - threshold];\n            }\n            i := i + 1;\n        }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_249",
            "type": "program",
            "content": "class Node {\n    var value: int;\n    var next: Node?;\n    constructor(v: int)\n        ensures this.value == v && this.next == null\n    {\n        value := v;\n        next := null;\n    }\n}\nclass LinkedList {\n    var head: Node?;\n    constructor()\n        ensures head == null\n    {\n        head := null;\n    }\n    method InsertAtHead(v: int)\n        modifies this\n        ensures head != null && head.value == v\n    {\n        var newNode := new Node(v);\n        newNode.next := head;\n        head := newNode;\n    }\n    method DeleteFromHead() returns (success: bool)\n        modifies this\n        ensures success ==> head != null\n    {\n        if (head != null) {\n            head := head.next;\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n    method Find(value: int) returns (found: bool)\n        ensures found ==> head != null\n    {\n        var current := head;\n        found := false;\n        while (current != null)\n            invariant current != null ==> head != null\n            invariant current != null ==> current.value != value ==> current.next != null || current.next == null\n        {\n            if (current.value == value) {\n                found := true;\n                return;\n            }\n            current := current.next;\n        }\n    }\n}",
            "parents": [
                "node_171"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 37\n    method Find(value: int) returns (found: bool)\n        ensures found ==> head != null\n    {\n        var current := head;\n        found := false;\n        while (current != null)\n            invariant current != null ==> head != null\n            invariant current != null ==> current.value != value ==> current.next != null || current.next == null\n        {\n            if (current.value == value) {\n                found := true;\n                return;\n            }\n            current := current.next;\n        }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_250",
            "type": "program",
            "content": "class FlightBookingSystem {\n    var totalSeats: nat;\n    var bookedSeats: nat;\n    constructor(totalSeats: nat)\n        requires totalSeats > 0\n        ensures this.totalSeats == totalSeats && this.bookedSeats == 0\n    {\n        this.totalSeats := totalSeats;\n        this.bookedSeats := 0;\n    }\n    method BookSeat() returns (success: bool)\n        ensures success ==> bookedSeats <= totalSeats\n        ensures !success ==> bookedSeats == totalSeats\n    {\n        if bookedSeats < totalSeats {\n            bookedSeats := bookedSeats + 1;\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n    method CancelSeat() returns (success: bool)\n        ensures success ==> bookedSeats >= 0\n        ensures !success ==> bookedSeats == 0\n    {\n        if bookedSeats > 0 {\n            bookedSeats := bookedSeats - 1;\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n    method BookMultipleSeats(n: nat) returns (success: bool)\n        requires n > 0\n        ensures success ==> bookedSeats <= totalSeats\n        ensures !success ==> bookedSeats + n > totalSeats\n    {\n        var i := 0;\n        success := true;\n        while i < n\n            invariant 0 <= i <= n\n            invariant bookedSeats <= totalSeats\n            invariant success ==> bookedSeats + i <= totalSeats\n        {\n            if bookedSeats < totalSeats {\n                bookedSeats := bookedSeats + 1;\n            } else {\n                success := false;\n                break;\n            }\n            i := i + 1;\n        }\n    }\n}",
            "parents": [
                "node_109"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 22\n    method CancelSeat() returns (success: bool)\n        ensures success ==> bookedSeats >= 0\n        ensures !success ==> bookedSeats == 0\n    {\n        if bookedSeats > 0 {\n            bookedSeats := bookedSeats - 1;\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n\n    method BookMultipleSeats(n: nat) returns (success: bool)\n        requires n > 0\n        ensures success ==> bookedSeats <= totalSeats\n        ensures !success ==> bookedSeats + n > totalSeats\n    {\n        var i := 0;\n        success := true;\n        while i < n\n            invariant 0 <= i <= n\n            invariant bookedSeats <= totalSeats\n            invariant success ==> bookedSeats + i <= totalSeats\n        {\n            if bookedSeats < totalSeats {\n                bookedSeats := bookedSeats + 1;\n            } else {\n                success := false;\n                break;\n            }\n            i := i + 1;\n        }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_251",
            "type": "program",
            "content": "class Matrix2x2 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    constructor(a: int, b: int, c: int, d: int)\n        ensures this.a == a && this.b == b && this.c == c && this.d == d\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n    }\n    method Transpose() returns (transposed: Matrix2x2)\n        ensures transposed.a == a && transposed.b == c && transposed.c == b && transposed.d == d\n    {\n        transposed := new Matrix2x2(a, c, b, d);\n    }\nmethod Multiply(other: Matrix2x2) returns (product: Matrix2x2)\n    ensures product.a == a * other.a + b * other.c\n    ensures product.b == a * other.b + b * other.d\n    ensures product.c == c * other.a + d * other.c\n    ensures product.d == c * other.b + d * other.d\n{\n    product := new Matrix2x2(\n        a * other.a + b * other.c,\n        a * other.b + b * other.d,\n        c * other.a + d * other.c,\n        c * other.b + d * other.d\n    );\n}\n}",
            "parents": [
                "node_173"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 19\nmethod Multiply(other: Matrix2x2) returns (product: Matrix2x2)\n    ensures product.a == a * other.a + b * other.c\n    ensures product.b == a * other.b + b * other.d\n    ensures product.c == c * other.a + d * other.c\n    ensures product.d == c * other.b + d * other.d\n{\n    product := new Matrix2x2(\n        a * other.a + b * other.c,\n        a * other.b + b * other.d,\n        c * other.a + d * other.c,\n        c * other.b + d * other.d\n    );\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_252",
            "type": "program",
            "content": "method GaussianElimination(a: array2<int>, b: array<int>) returns (x: array<int>)\n    requires a.Length0 == a.Length1 && a.Length0 == b.Length\n    ensures forall i :: 0 <= i < a.Length0 ==> a[i, i] * x[i] == b[i]\n{\n    var n := a.Length0;\n    x := new int[n];\n    // Forward elimination\n    for k := 0 to n - 1\n        invariant 0 <= k <= n\n        invariant forall i, j :: 0 <= i < k && 0 <= j < n ==> a[i, j] == 0\n    {\n        // Find the pivot\n        var max := k;\n        for i := k + 1 to n - 1\n            invariant k <= max < n\n            invariant forall j :: k <= j < i ==> a[max, k] >= a[j, k]\n        {\n            if a[i, k] > a[max, k] {\n                max := i;\n            }\n        }\n        // Swap rows\n        for j := 0 to n - 1\n            invariant 0 <= j <= n\n            invariant forall i :: 0 <= i < j ==> a[k, i] == a[max, i] && a[max, i] == a[k, i]\n        {\n            var temp := a[k, j];\n            a[k, j] := a[max, j];\n            a[max, j] := temp;\n        }\n        var tempB := b[k];\n        b[k] := b[max];\n        b[max] := tempB;\n        // Eliminate column\n        // Eliminate column\n        for i := k + 1 to n - 1\n            invariant k < i <= n\n            invariant forall j :: 0 <= j < n ==> (j < k ==> a[i, j] == 0) && (j >= k ==> a[i, j] == a[i, j])\n            invariant b[i] == b[i] - (a[i, k] / a[k, k]) * b[k]\n        {\n            var factor := a[i, k] / a[k, k];\n            b[i] := b[i] - factor * b[k];\n            for j := k to n - 1\n                invariant k <= j <= n\n                invariant forall l :: k <= l < j ==> a[i, l] == a[i, l]\n                invariant a[i, j] == a[i, j] - factor * a[k, j]\n            {\n                a[i, j] := a[i, j] - factor * a[k, j];\n            }\n        }\n}\n}",
            "parents": [
                "node_214"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 35\n        // Eliminate column\n        for i := k + 1 to n - 1\n            invariant k < i <= n\n            invariant forall j :: 0 <= j < n ==> (j < k ==> a[i, j] == 0) && (j >= k ==> a[i, j] == a[i, j])\n            invariant b[i] == b[i] - (a[i, k] / a[k, k]) * b[k]\n        {\n            var factor := a[i, k] / a[k, k];\n            b[i] := b[i] - factor * b[k];\n            for j := k to n - 1\n                invariant k <= j <= n\n                invariant forall l :: k <= l < j ==> a[i, l] == a[i, l]\n                invariant a[i, j] == a[i, j] - factor * a[k, j]\n            {\n                a[i, j] := a[i, j] - factor * a[k, j];\n            }\n        }\n// END DAFNY\n```"
        },
        {
            "id": "node_253",
            "type": "program",
            "content": "class Matrix2x2 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    constructor(a: int, b: int, c: int, d: int)\n        ensures this.a == a && this.b == b && this.c == c && this.d == d\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n    }\n    method Determinant() returns (det: int)\n        ensures det == a * d - b * c\n    {\n        det := a * d - b * c;\n    }\nmethod MultiplyByScalar(scalar: int) returns (result: Matrix2x2)\n    ensures result.a == this.a * scalar\n    ensures result.b == this.b * scalar\n    ensures result.c == this.c * scalar\n    ensures result.d == this.d * scalar\n{\n    result := new Matrix2x2(this.a * scalar, this.b * scalar, this.c * scalar, this.d * scalar);\n}\nmethod Transpose() returns (transposed: Matrix2x2)\n    ensures transposed.a == this.a\n    ensures transposed.b == this.c\n    ensures transposed.c == this.b\n    ensures transposed.d == this.d\n{\n    transposed := new Matrix2x2(this.a, this.c, this.b, this.d);\n}\n}",
            "parents": [
                "node_199"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 19\nmethod MultiplyByScalar(scalar: int) returns (result: Matrix2x2)\n    ensures result.a == this.a * scalar\n    ensures result.b == this.b * scalar\n    ensures result.c == this.c * scalar\n    ensures result.d == this.d * scalar\n{\n    result := new Matrix2x2(this.a * scalar, this.b * scalar, this.c * scalar, this.d * scalar);\n}\n\nmethod Transpose() returns (transposed: Matrix2x2)\n    ensures transposed.a == this.a\n    ensures transposed.b == this.c\n    ensures transposed.c == this.b\n    ensures transposed.d == this.d\n{\n    transposed := new Matrix2x2(this.a, this.c, this.b, this.d);\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_254",
            "type": "program",
            "content": "class SudokuValidator {\n    var grid: array2<int>;\n    constructor(grid: array2<int>)\n        requires grid.Length0 == 9 && grid.Length1 == 9\n        ensures this.grid == grid\n    {\n        this.grid := grid;\n    }\n    method IsRowValid(row: int) returns (isValid: bool)\n        requires 0 <= row < 9\n        ensures isValid == (forall i, j :: 0 <= i < j < 9 ==> grid[row, i] != grid[row, j])\n    {\n        var seen := new bool[10];\n        isValid := true;\n        for i := 0 to 8 {\n            if grid[row, i] < 1 || grid[row, i] > 9 || seen[grid[row, i]] {\n                isValid := false;\n                return;\n            }\n            seen[grid[row, i]] := true;\n        }\n    }\n    method IsColumnValid(col: int) returns (isValid: bool)\n        requires 0 <= col < 9\n        ensures isValid == (forall i, j :: 0 <= i < j < 9 ==> grid[i, col] != grid[j, col])\n    {\n        var seen := new bool[10];\n        isValid := true;\n        for i := 0 to 8 {\n            if grid[i, col] < 1 || grid[i, col] > 9 || seen[grid[i, col]] {\n                isValid := false;\n                return;\n            }\n            seen[grid[i, col]] := true;\n        }\n    }\n    method IsSubgridValid(subgridRow: int, subgridCol: int) returns (isValid: bool)\n        requires 0 <= subgridRow < 3 && 0 <= subgridCol < 3\n        ensures isValid == (forall i, j :: 0 <= i < j < 9 ==> grid[subgridRow * 3 + i / 3, subgridCol * 3 + i % 3] != grid[subgridRow * 3 + j / 3, subgridCol * 3 + j % 3])\n    {\n        var seen := new bool[10];\n        isValid := true;\n        for i := 0 to 8\n            invariant 0 <= i <= 9\n            invariant forall k :: 0 <= k < i ==> 1 <= grid[subgridRow * 3 + k / 3, subgridCol * 3 + k % 3] <= 9\n            invariant forall k :: 0 <= k < i ==> !seen[grid[subgridRow * 3 + k / 3, subgridCol * 3 + k % 3]]\n        {\n            var value := grid[subgridRow * 3 + i / 3, subgridCol * 3 + i % 3];\n            if value < 1 || value > 9 || seen[value] {\n                isValid := false;\n                return;\n            }\n            seen[value] := true;\n        }\n    }\n}",
            "parents": [
                "node_103"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 37\n    method IsSubgridValid(subgridRow: int, subgridCol: int) returns (isValid: bool)\n        requires 0 <= subgridRow < 3 && 0 <= subgridCol < 3\n        ensures isValid == (forall i, j :: 0 <= i < j < 9 ==> grid[subgridRow * 3 + i / 3, subgridCol * 3 + i % 3] != grid[subgridRow * 3 + j / 3, subgridCol * 3 + j % 3])\n    {\n        var seen := new bool[10];\n        isValid := true;\n        for i := 0 to 8\n            invariant 0 <= i <= 9\n            invariant forall k :: 0 <= k < i ==> 1 <= grid[subgridRow * 3 + k / 3, subgridCol * 3 + k % 3] <= 9\n            invariant forall k :: 0 <= k < i ==> !seen[grid[subgridRow * 3 + k / 3, subgridCol * 3 + k % 3]]\n        {\n            var value := grid[subgridRow * 3 + i / 3, subgridCol * 3 + i % 3];\n            if value < 1 || value > 9 || seen[value] {\n                isValid := false;\n                return;\n            }\n            seen[value] := true;\n        }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_255",
            "type": "program",
            "content": "class Matrix3x3 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    var e: int;\n    var f: int;\n    var g: int;\n    var h: int;\n    var i: int;\n    constructor(a: int, b: int, c: int, d: int, e: int, f: int, g: int, h: int, i: int)\n        ensures this.a == a && this.b == b && this.c == c\n        ensures this.d == d && this.e == e && this.f == f\n        ensures this.g == g && this.h == h && this.i == i\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n        this.e := e;\n        this.f := f;\n        this.g := g;\n        this.h := h;\n        this.i := i;\n    }\n    method Determinant() returns (det: int)\n        ensures det == a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g)\n    {\n        det := a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g);\n    }\nmethod Transpose() returns (transposed: Matrix3x3)\n    ensures transposed.a == this.a && transposed.b == this.d && transposed.c == this.g\n    ensures transposed.d == this.b && transposed.e == this.e && transposed.f == this.h\n    ensures transposed.g == this.c && transposed.h == this.f && transposed.i == this.i\n{\n    transposed := new Matrix3x3(\n        this.a, this.d, this.g,\n        this.b, this.e, this.h,\n        this.c, this.f, this.i\n    );\n}\n}",
            "parents": [
                "node_200"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 31\nmethod Transpose() returns (transposed: Matrix3x3)\n    ensures transposed.a == this.a && transposed.b == this.d && transposed.c == this.g\n    ensures transposed.d == this.b && transposed.e == this.e && transposed.f == this.h\n    ensures transposed.g == this.c && transposed.h == this.f && transposed.i == this.i\n{\n    transposed := new Matrix3x3(\n        this.a, this.d, this.g,\n        this.b, this.e, this.h,\n        this.c, this.f, this.i\n    );\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_256",
            "type": "program",
            "content": "class VotingSystem {\n    var votes: array<int>;\n    constructor (numCandidates: int)\n        requires numCandidates > 0\n    {\n        votes := new int[numCandidates];\n    }\n    method Vote(candidate: int)\n        requires 0 <= candidate < votes.Length\n        modifies votes\n        ensures votes[candidate] == old(votes[candidate]) + 1\n    {\n        votes[candidate] := votes[candidate] + 1;\n    }\n    method GetWinner() returns (winner: int)\n        requires votes.Length > 0\n        ensures 0 <= winner < votes.Length\n        ensures forall i: int :: 0 <= i < votes.Length ==> votes[winner] >= votes[i]\n        ensures exists i: int :: 0 <= i < votes.Length && votes[i] == votes[winner]\n    {\n        var maxVotes := votes[0];\n        winner := 0;\n        for i := 1 to votes.Length - 1\n            invariant 0 <= winner < votes.Length\n            invariant 0 <= i <= votes.Length\n            invariant forall j: int :: 0 <= j < i ==> votes[winner] >= votes[j]\n            invariant exists j: int :: 0 <= j < i && votes[j] == maxVotes\n        {\n            if votes[i] > maxVotes {\n                maxVotes := votes[i];\n                winner := i;\n            }\n        }\n    }\n}",
            "parents": [
                "node_233"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 15\n    method GetWinner() returns (winner: int)\n        requires votes.Length > 0\n        ensures 0 <= winner < votes.Length\n        ensures forall i: int :: 0 <= i < votes.Length ==> votes[winner] >= votes[i]\n        ensures exists i: int :: 0 <= i < votes.Length && votes[i] == votes[winner]\n    {\n        var maxVotes := votes[0];\n        winner := 0;\n        for i := 1 to votes.Length - 1\n            invariant 0 <= winner < votes.Length\n            invariant 0 <= i <= votes.Length\n            invariant forall j: int :: 0 <= j < i ==> votes[winner] >= votes[j]\n            invariant exists j: int :: 0 <= j < i && votes[j] == maxVotes\n        {\n            if votes[i] > maxVotes {\n                maxVotes := votes[i];\n                winner := i;\n            }\n        }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_257",
            "type": "program",
            "content": "class TournamentBracket {\n    method GenerateBracket(seeds: seq<int>) returns (matchups: seq<(int, int)>)\n        requires |seeds| > 0 && |seeds| % 2 == 0\n        ensures |matchups| == |seeds| / 2\n        ensures forall i :: 0 <= i < |matchups| ==> matchups[i].0 != matchups[i].1\n    {\n        var n := |seeds|;\n        matchups := [];\n        for i := 0 to n / 2 - 1\n            invariant 0 <= i <= n / 2\n            invariant |matchups| == i\n            invariant forall j :: 0 <= j < i ==> matchups[j].0 != matchups[j].1\n        {\n            var team1 := seeds[i];\n            var team2 := seeds[n - i - 1];\n            matchups := matchups + [(team1, team2)];\n        }\n}\n}",
            "parents": [
                "node_157"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 9\n        for i := 0 to n / 2 - 1\n            invariant 0 <= i <= n / 2\n            invariant |matchups| == i\n            invariant forall j :: 0 <= j < i ==> matchups[j].0 != matchups[j].1\n        {\n            var team1 := seeds[i];\n            var team2 := seeds[n - i - 1];\n            matchups := matchups + [(team1, team2)];\n        }\n// END DAFNY\n```"
        },
        {
            "id": "node_258",
            "type": "program",
            "content": "class Employee {\n    var hoursWorked: int;\n    var payRate: int;\n    constructor(hoursWorked: int, payRate: int)\n        ensures this.hoursWorked == hoursWorked && this.payRate == payRate\n    {\n        this.hoursWorked := hoursWorked;\n        this.payRate := payRate;\n    }\n    method CalculateSalary() returns (salary: int)\n        ensures salary == hoursWorked * payRate\n    {\n        salary := hoursWorked * payRate;\n    }\nmethod CalculateOvertimeSalary(overtimeRate: int) returns (overtimeSalary: int)\n    requires overtimeRate > payRate\n    ensures overtimeSalary == (hoursWorked - 40) * overtimeRate\n    ensures hoursWorked > 40 ==> overtimeSalary > 0\n    ensures hoursWorked <= 40 ==> overtimeSalary == 0\n{\n    if hoursWorked > 40 {\n        var overtimeHours := hoursWorked - 40;\n        overtimeSalary := 0;\n        var i := 0;\n        while i < overtimeHours\n            invariant 0 <= i <= overtimeHours\n            invariant overtimeSalary == i * overtimeRate\n        {\n            overtimeSalary := overtimeSalary + overtimeRate;\n            i := i + 1;\n        }\n    } else {\n        overtimeSalary := 0;\n    }\n}\n}",
            "parents": [
                "node_118"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 15\nmethod CalculateOvertimeSalary(overtimeRate: int) returns (overtimeSalary: int)\n    requires overtimeRate > payRate\n    ensures overtimeSalary == (hoursWorked - 40) * overtimeRate\n    ensures hoursWorked > 40 ==> overtimeSalary > 0\n    ensures hoursWorked <= 40 ==> overtimeSalary == 0\n{\n    if hoursWorked > 40 {\n        var overtimeHours := hoursWorked - 40;\n        overtimeSalary := 0;\n        var i := 0;\n        while i < overtimeHours\n            invariant 0 <= i <= overtimeHours\n            invariant overtimeSalary == i * overtimeRate\n        {\n            overtimeSalary := overtimeSalary + overtimeRate;\n            i := i + 1;\n        }\n    } else {\n        overtimeSalary := 0;\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_259",
            "type": "program",
            "content": "class Matrix3x3 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    var e: int;\n    var f: int;\n    var g: int;\n    var h: int;\n    var i: int;\n    constructor(a: int, b: int, c: int, d: int, e: int, f: int, g: int, h: int, i: int)\n        ensures this.a == a && this.b == b && this.c == c\n        ensures this.d == d && this.e == e && this.f == f\n        ensures this.g == g && this.h == h && this.i == i\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n        this.e := e;\n        this.f := f;\n        this.g := g;\n        this.h := h;\n        this.i := i;\n    }\n    method Determinant() returns (det: int)\n        ensures det == a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g)\n    {\n        det := a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g);\n    }\nmethod Transpose() returns (t: Matrix3x3)\n    ensures t.a == a && t.b == d && t.c == g\n    ensures t.d == b && t.e == e && t.f == h\n    ensures t.g == c && t.h == f && t.i == i\n{\n    t := new Matrix3x3(a, d, g, b, e, h, c, f, i);\n}\nmethod MultiplyByScalar(scalar: int) returns (result: Matrix3x3)\n    ensures result.a == a * scalar && result.b == b * scalar && result.c == c * scalar\n    ensures result.d == d * scalar && result.e == e * scalar && result.f == f * scalar\n    ensures result.g == g * scalar && result.h == h * scalar && result.i == i * scalar\n{\n    result := new Matrix3x3(a * scalar, b * scalar, c * scalar, d * scalar, e * scalar, f * scalar, g * scalar, h * scalar, i * scalar);\n}\n}",
            "parents": [
                "node_200"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 31\nmethod Transpose() returns (t: Matrix3x3)\n    ensures t.a == a && t.b == d && t.c == g\n    ensures t.d == b && t.e == e && t.f == h\n    ensures t.g == c && t.h == f && t.i == i\n{\n    t := new Matrix3x3(a, d, g, b, e, h, c, f, i);\n}\n\nmethod MultiplyByScalar(scalar: int) returns (result: Matrix3x3)\n    ensures result.a == a * scalar && result.b == b * scalar && result.c == c * scalar\n    ensures result.d == d * scalar && result.e == e * scalar && result.f == f * scalar\n    ensures result.g == g * scalar && result.h == h * scalar && result.i == i * scalar\n{\n    result := new Matrix3x3(a * scalar, b * scalar, c * scalar, d * scalar, e * scalar, f * scalar, g * scalar, h * scalar, i * scalar);\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_260",
            "type": "program",
            "content": "class Point {\n    var x: int;\n    var y: int;\n    constructor(x: int, y: int)\n        ensures this.x == x && this.y == y\n    {\n        this.x := x;\n        this.y := y;\n    }\n}\nmethod CrossProduct(p1: Point, p2: Point, p3: Point) returns (result: int)\n    ensures result == (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x)\n{\n    result := (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x);\n}\nmethod CrossProductWithLoop(p1: Point, p2: Point, p3: Point) returns (result: int)\n    ensures result == (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x)\n{\n    var dx1 := p2.x - p1.x;\n    var dy1 := p2.y - p1.y;\n    var dx2 := p3.x - p1.x;\n    var dy2 := p3.y - p1.y;\n    result := 0;\n    var i := 0;\n    while i < 2\n        invariant 0 <= i <= 2\n        invariant result == i * (dx1 * dy2 - dy1 * dx2)\n    {\n        result := dx1 * dy2 - dy1 * dx2;\n        i := i + 1;\n    }\n}",
            "parents": [
                "node_126"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 16\nmethod CrossProductWithLoop(p1: Point, p2: Point, p3: Point) returns (result: int)\n    ensures result == (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x)\n{\n    var dx1 := p2.x - p1.x;\n    var dy1 := p2.y - p1.y;\n    var dx2 := p3.x - p1.x;\n    var dy2 := p3.y - p1.y;\n    result := 0;\n    var i := 0;\n    while i < 2\n        invariant 0 <= i <= 2\n        invariant result == i * (dx1 * dy2 - dy1 * dx2)\n    {\n        result := dx1 * dy2 - dy1 * dx2;\n        i := i + 1;\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_261",
            "type": "program",
            "content": "class LeapYearChecker {\n    method IsLeapYear(year: int) returns (isLeap: bool)\n        requires year > 0\n        ensures isLeap == ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)\n    {\n        if year % 4 == 0 {\n            if year % 100 == 0 {\n                if year % 400 == 0 {\n                    isLeap := true;\n                } else {\n                    isLeap := false;\n                }\n            } else {\n                isLeap := true;\n            }\n        } else {\n            isLeap := false;\n        }\n    }\n}",
            "parents": [
                "idea_26"
            ],
            "diff": "```\n// BEGIN DAFNY\n\nclass LeapYearChecker {\n    method IsLeapYear(year: int) returns (isLeap: bool)\n        requires year > 0\n        ensures isLeap == ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)\n    {\n        if year % 4 == 0 {\n            if year % 100 == 0 {\n                if year % 400 == 0 {\n                    isLeap := true;\n                } else {\n                    isLeap := false;\n                }\n            } else {\n                isLeap := true;\n            }\n        } else {\n            isLeap := false;\n        }\n    }\n}\n\n// END DAFNY\n```"
        },
        {
            "id": "node_262",
            "type": "program",
            "content": "class Matrix3x3 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    var e: int;\n    var f: int;\n    var g: int;\n    var h: int;\n    var i: int;\n    constructor(a: int, b: int, c: int, d: int, e: int, f: int, g: int, h: int, i: int)\n        ensures this.a == a && this.b == b && this.c == c\n        ensures this.d == d && this.e == e && this.f == f\n        ensures this.g == g && this.h == h && this.i == i\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n        this.e := e;\n        this.f := f;\n        this.g := g;\n        this.h := h;\n        this.i := i;\n    }\n    method Determinant() returns (det: int)\n        ensures det == a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g)\n    {\n        det := a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g);\n    }\nmethod Transpose() returns (transposed: Matrix3x3)\n    ensures transposed.a == this.a && transposed.b == this.d && transposed.c == this.g\n    ensures transposed.d == this.b && transposed.e == this.e && transposed.f == this.h\n    ensures transposed.g == this.c && transposed.h == this.f && transposed.i == this.i\n{\n    transposed := new Matrix3x3(this.a, this.d, this.g, this.b, this.e, this.h, this.c, this.f, this.i);\n}\n}",
            "parents": [
                "node_155"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 31\nmethod Transpose() returns (transposed: Matrix3x3)\n    ensures transposed.a == this.a && transposed.b == this.d && transposed.c == this.g\n    ensures transposed.d == this.b && transposed.e == this.e && transposed.f == this.h\n    ensures transposed.g == this.c && transposed.h == this.f && transposed.i == this.i\n{\n    transposed := new Matrix3x3(this.a, this.d, this.g, this.b, this.e, this.h, this.c, this.f, this.i);\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_263",
            "type": "program",
            "content": "class PayrollSystem {\n    var hourlyRate: real;\n    var hoursWorked: real;\n    constructor(rate: real, hours: real)\n        requires rate >= 0.0 && hours >= 0.0\n    {\n        hourlyRate := rate;\n        hoursWorked := hours;\n    }\n    method CalculateSalaryWithOvertime() returns (salary: real)\n        ensures salary >= hourlyRate * hoursWorked\n    {\n        var regularHours := if hoursWorked > 40.0 then 40.0 else hoursWorked;\n        var overtimeHours := if hoursWorked > 40.0 then hoursWorked - 40.0 else 0.0;\n        var overtimeRate := 1.5 * hourlyRate;\n        salary := hourlyRate * regularHours + overtimeRate * overtimeHours;\n    }\n}",
            "parents": [
                "node_132"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 10\n    method CalculateSalaryWithOvertime() returns (salary: real)\n        ensures salary >= hourlyRate * hoursWorked\n    {\n        var regularHours := if hoursWorked > 40.0 then 40.0 else hoursWorked;\n        var overtimeHours := if hoursWorked > 40.0 then hoursWorked - 40.0 else 0.0;\n        var overtimeRate := 1.5 * hourlyRate;\n        salary := hourlyRate * regularHours + overtimeRate * overtimeHours;\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_264",
            "type": "program",
            "content": "method GaussianElimination(a: array2<int>, b: array<int>) returns (x: array<int>)\n    requires a.Length0 == a.Length1 && a.Length0 == b.Length\n    ensures forall i :: 0 <= i < a.Length0 ==> a[i, i] * x[i] == b[i]\n{\n    var n := a.Length0;\n    x := new int[n];\n    // Forward elimination\n    for k := 0 to n - 1\n        invariant 0 <= k <= n\n        invariant forall i, j :: 0 <= i < k && 0 <= j < n ==> a[i, j] == 0\n    {\n        // Find the pivot\n        var max := k;\n        for i := k + 1 to n - 1\n            invariant k <= max < n\n            invariant forall j :: k <= j < i ==> a[max, k] >= a[j, k]\n        {\n            if a[i, k] > a[max, k] {\n                max := i;\n            }\n        }\n        // Swap rows\n        for j := 0 to n - 1\n            invariant 0 <= j <= n\n            invariant forall i :: 0 <= i < j ==> a[k, i] == a[max, i] && a[max, i] == a[k, i]\n        {\n            var temp := a[k, j];\n            a[k, j] := a[max, j];\n            a[max, j] := temp;\n        }\n        var tempB := b[k];\n        b[k] := b[max];\n        b[max] := tempB;\n        // Eliminate column\n        for i := k + 1 to n - 1\n            invariant k < i <= n\n            invariant forall j :: 0 <= j < n ==> (j < k ==> a[i, j] == 0) && (j >= k ==> a[i, j] == a[i, j])\n        {\n            var factor := a[i, k] / a[k, k];\n            b[i] := b[i] - factor * b[k];\n            for j := k to n - 1\n                invariant k <= j <= n\n                invariant forall l :: k <= l < j ==> a[i, l] == a[i, l] - factor * a[k, l]\n            {\n                a[i, j] := a[i, j] - factor * a[k, j];\n            }\n        }\n}\n}",
            "parents": [
                "node_211"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 35\n        for i := k + 1 to n - 1\n            invariant k < i <= n\n            invariant forall j :: 0 <= j < n ==> (j < k ==> a[i, j] == 0) && (j >= k ==> a[i, j] == a[i, j])\n        {\n            var factor := a[i, k] / a[k, k];\n            b[i] := b[i] - factor * b[k];\n            for j := k to n - 1\n                invariant k <= j <= n\n                invariant forall l :: k <= l < j ==> a[i, l] == a[i, l] - factor * a[k, l]\n            {\n                a[i, j] := a[i, j] - factor * a[k, j];\n            }\n        }\n// END DAFNY\n```"
        },
        {
            "id": "node_265",
            "type": "program",
            "content": "class Employee {\n    var hoursWorked: int;\n    var payRate: int;\n    constructor(hoursWorked: int, payRate: int)\n        ensures this.hoursWorked == hoursWorked && this.payRate == payRate\n    {\n        this.hoursWorked := hoursWorked;\n        this.payRate := payRate;\n    }\nmethod CalculateSalaryWithOvertime() returns (salary: int)\n    ensures salary == hoursWorked * payRate + (if hoursWorked > 40 then (hoursWorked - 40) * payRate / 2 else 0)\n{\n    var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n    var baseSalary := hoursWorked * payRate;\n    var overtimePay := overtimeHours * payRate / 2;\n    salary := baseSalary + overtimePay;\n}\n}",
            "parents": [
                "node_128"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 10\nmethod CalculateSalaryWithOvertime() returns (salary: int)\n    ensures salary == hoursWorked * payRate + (if hoursWorked > 40 then (hoursWorked - 40) * payRate / 2 else 0)\n{\n    var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n    var baseSalary := hoursWorked * payRate;\n    var overtimePay := overtimeHours * payRate / 2;\n    salary := baseSalary + overtimePay;\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_266",
            "type": "program",
            "content": "class LinearInequalitiesSolver {\n    method SolveSingleInequality(a: int, b: int, c: int) returns (solution: bool)\n        requires a != 0\n        ensures solution == (c >= b / a)\n    {\n        if a > 0 {\n            solution := c >= b / a;\n        } else {\n            solution := c <= b / a;\n        }\n    }\n    method VerifySolution(a: int, b: int, c: int, x: int) returns (isValid: bool)\n        requires a != 0\n        ensures isValid == (a * x + b <= c)\n    {\n        isValid := a * x + b <= c;\n    }\n    method SolveMultipleInequalities(a: seq<int>, b: seq<int>, c: seq<int>) returns (solutions: seq<bool>)\n        requires |a| == |b| && |b| == |c|\n        requires forall i :: 0 <= i < |a| ==> a[i] != 0\n        ensures |solutions| == |a|\n        ensures forall i :: 0 <= i < |a| ==> solutions[i] == (if a[i] > 0 then c[i] >= b[i] / a[i] else c[i] <= b[i] / a[i])\n    {\n        solutions := [];\n        var i := 0;\n        while i < |a|\n            invariant 0 <= i <= |a|\n            invariant |solutions| == i\n            invariant forall j :: 0 <= j < i ==> solutions[j] == (if a[j] > 0 then c[j] >= b[j] / a[j] else c[j] <= b[j] / a[j])\n        {\n            if a[i] > 0 {\n                solutions := solutions + [c[i] >= b[i] / a[i]];\n            } else {\n                solutions := solutions + [c[i] <= b[i] / a[i]];\n            }\n            i := i + 1;\n        }\n    }\n}",
            "parents": [
                "node_191"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 18\n    method SolveMultipleInequalities(a: seq<int>, b: seq<int>, c: seq<int>) returns (solutions: seq<bool>)\n        requires |a| == |b| && |b| == |c|\n        requires forall i :: 0 <= i < |a| ==> a[i] != 0\n        ensures |solutions| == |a|\n        ensures forall i :: 0 <= i < |a| ==> solutions[i] == (if a[i] > 0 then c[i] >= b[i] / a[i] else c[i] <= b[i] / a[i])\n    {\n        solutions := [];\n        var i := 0;\n        while i < |a|\n            invariant 0 <= i <= |a|\n            invariant |solutions| == i\n            invariant forall j :: 0 <= j < i ==> solutions[j] == (if a[j] > 0 then c[j] >= b[j] / a[j] else c[j] <= b[j] / a[j])\n        {\n            if a[i] > 0 {\n                solutions := solutions + [c[i] >= b[i] / a[i]];\n            } else {\n                solutions := solutions + [c[i] <= b[i] / a[i]];\n            }\n            i := i + 1;\n        }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_267",
            "type": "program",
            "content": "class Matrix2x2 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    constructor(a: int, b: int, c: int, d: int)\n        ensures this.a == a && this.b == b && this.c == c && this.d == d\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n    }\n    method Determinant() returns (det: int)\n        ensures det == a * d - b * c\n    {\n        det := a * d - b * c;\n    }\nmethod MultiplyByScalar(scalar: int) returns (result: Matrix2x2)\n    ensures result.a == this.a * scalar && result.b == this.b * scalar\n    ensures result.c == this.c * scalar && result.d == this.d * scalar\n{\n    result := new Matrix2x2(this.a * scalar, this.b * scalar, this.c * scalar, this.d * scalar);\n}\nmethod Transpose() returns (result: Matrix2x2)\n    ensures result.a == this.a && result.b == this.c\n    ensures result.c == this.b && result.d == this.d\n{\n    result := new Matrix2x2(this.a, this.c, this.b, this.d);\n}\n}",
            "parents": [
                "node_201"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 19\nmethod MultiplyByScalar(scalar: int) returns (result: Matrix2x2)\n    ensures result.a == this.a * scalar && result.b == this.b * scalar\n    ensures result.c == this.c * scalar && result.d == this.d * scalar\n{\n    result := new Matrix2x2(this.a * scalar, this.b * scalar, this.c * scalar, this.d * scalar);\n}\n\nmethod Transpose() returns (result: Matrix2x2)\n    ensures result.a == this.a && result.b == this.c\n    ensures result.c == this.b && result.d == this.d\n{\n    result := new Matrix2x2(this.a, this.c, this.b, this.d);\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_268",
            "type": "program",
            "content": "class MatrixOperations {\n    method Transpose(matrix: array2<int>) returns (transposed: array2<int>)\n        requires matrix.Length0 > 0 && matrix.Length1 > 0\n        ensures transposed.Length0 == matrix.Length1 && transposed.Length1 == matrix.Length0\n        ensures forall i: int, j: int :: 0 <= i < matrix.Length0 && 0 <= j < matrix.Length1 ==> transposed[j, i] == matrix[i, j]\n    {\n        var rows := matrix.Length0;\n        var cols := matrix.Length1;\n        transposed := new int[cols, rows];\n        for i := 0 to rows - 1\n            invariant 0 <= i <= rows\n            invariant forall k: int, l: int :: 0 <= k < i && 0 <= l < cols ==> transposed[l, k] == matrix[k, l]\n        {\n            for j := 0 to cols - 1\n                invariant 0 <= j <= cols\n                invariant forall l: int :: 0 <= l < j ==> transposed[l, i] == matrix[i, l]\n            {\n                transposed[j, i] := matrix[i, j];\n            }\n        }\n}\n}",
            "parents": [
                "node_144"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 10\n        for i := 0 to rows - 1\n            invariant 0 <= i <= rows\n            invariant forall k: int, l: int :: 0 <= k < i && 0 <= l < cols ==> transposed[l, k] == matrix[k, l]\n        {\n            for j := 0 to cols - 1\n                invariant 0 <= j <= cols\n                invariant forall l: int :: 0 <= l < j ==> transposed[l, i] == matrix[i, l]\n            {\n                transposed[j, i] := matrix[i, j];\n            }\n        }\n// END DAFNY\n```"
        },
        {
            "id": "node_269",
            "type": "program",
            "content": "class PayrollSystem {\n    method CalculateSalary(hoursWorked: int, payRate: int) returns (salary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        ensures salary >= 0\n    {\n        salary := hoursWorked * payRate;\n    }\n    method CalculateOvertimeSalary(hoursWorked: int, payRate: int, overtimeRate: int) returns (totalSalary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        requires overtimeRate >= payRate\n        ensures totalSalary >= 0\n    {\n        var regularHours := if hoursWorked > 40 then 40 else hoursWorked;\n        var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n        var regularSalary := regularHours * payRate;\n        var overtimeSalary := overtimeHours * overtimeRate;\n        totalSalary := regularSalary + overtimeSalary;\n    }\n    method CalculateTotalEarnings(hoursWorked: int, payRate: int, overtimeRate: int, bonusRate: int) returns (totalEarnings: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        requires overtimeRate >= payRate\n        requires bonusRate >= 0\n        ensures totalEarnings >= 0\n    {\n        var regularHours := if hoursWorked > 40 then 40 else hoursWorked;\n        var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n        var bonusHours := if hoursWorked > 50 then hoursWorked - 50 else 0;\n        var regularSalary := regularHours * payRate;\n        var overtimeSalary := overtimeHours * overtimeRate;\n        var bonus := bonusHours * bonusRate;\n        totalEarnings := regularSalary + overtimeSalary + bonus;\n    }\n}",
            "parents": [
                "node_150"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 21\n    method CalculateTotalEarnings(hoursWorked: int, payRate: int, overtimeRate: int, bonusRate: int) returns (totalEarnings: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        requires overtimeRate >= payRate\n        requires bonusRate >= 0\n        ensures totalEarnings >= 0\n    {\n        var regularHours := if hoursWorked > 40 then 40 else hoursWorked;\n        var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n        var bonusHours := if hoursWorked > 50 then hoursWorked - 50 else 0;\n\n        var regularSalary := regularHours * payRate;\n        var overtimeSalary := overtimeHours * overtimeRate;\n        var bonus := bonusHours * bonusRate;\n\n        totalEarnings := regularSalary + overtimeSalary + bonus;\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_270",
            "type": "program",
            "content": "class Geometry {\n    method AreRectanglesColliding(x1: int, y1: int, w1: int, h1: int, x2: int, y2: int, w2: int, h2: int) returns (colliding: bool)\n        requires w1 > 0 && h1 > 0 && w2 > 0 && h2 > 0\n        ensures colliding == ((x1 < x2 + w2) && (x2 < x1 + w1) && (y1 < y2 + h2) && (y2 < y1 + h1))\n    {\n        colliding := (x1 < x2 + w2) && (x2 < x1 + w1) && (y1 < y2 + h2) && (y2 < y1 + h1);\n    }\n    method TranslateRectangle(x: int, y: int, dx: int, dy: int) returns (newX: int, newY: int)\n        ensures newX == x + dx && newY == y + dy\n    {\n        newX := x + dx;\n        newY := y + dy;\n    }\n    method ScaleRectangle(x: int, y: int, w: int, h: int, factor: int) returns (newW: int, newH: int)\n        requires factor > 0\n        ensures newW == w * factor && newH == h * factor\n    {\n        newW := w * factor;\n        newH := h * factor;\n    }\n    method IsPointInsideRectangle(px: int, py: int, x: int, y: int, w: int, h: int) returns (inside: bool)\n        ensures inside == (px >= x && px < x + w && py >= y && py < y + h)\n    {\n        inside := (px >= x && px < x + w && py >= y && py < y + h);\n    }\n}",
            "parents": [
                "node_129"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 8\n    method TranslateRectangle(x: int, y: int, dx: int, dy: int) returns (newX: int, newY: int)\n        ensures newX == x + dx && newY == y + dy\n    {\n        newX := x + dx;\n        newY := y + dy;\n    }\n\n    method ScaleRectangle(x: int, y: int, w: int, h: int, factor: int) returns (newW: int, newH: int)\n        requires factor > 0\n        ensures newW == w * factor && newH == h * factor\n    {\n        newW := w * factor;\n        newH := h * factor;\n    }\n\n    method IsPointInsideRectangle(px: int, py: int, x: int, y: int, w: int, h: int) returns (inside: bool)\n        ensures inside == (px >= x && px < x + w && py >= y && py < y + h)\n    {\n        inside := (px >= x && px < x + w && py >= y && py < y + h);\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_271",
            "type": "program",
            "content": "class LoginSystem {\n    var storedUsername: string;\n    var storedPassword: string;\n    constructor(username: string, password: string) \n        ensures storedUsername == username\n        ensures storedPassword == password\n    {\n        storedUsername := username;\n        storedPassword := password;\n    }\n    method Authenticate(inputUsername: string, inputPassword: string) returns (isAuthenticated: bool)\n        ensures isAuthenticated == (inputUsername == storedUsername && inputPassword == storedPassword)\n    {\n        isAuthenticated := false;\n        if inputUsername == storedUsername && inputPassword == storedPassword {\n            isAuthenticated := true;\n        }\n    }\n    method ChangePassword(oldPassword: string, newPassword: string) returns (isChanged: bool)\n        ensures isChanged ==> storedPassword == newPassword\n        ensures !isChanged ==> storedPassword == oldPassword\n    {\n        isChanged := false;\n        if oldPassword == storedPassword {\n            storedPassword := newPassword;\n            isChanged := true;\n        }\n    }\n}",
            "parents": [
                "idea_40"
            ],
            "diff": "```\n// BEGIN DAFNY\nclass LoginSystem {\n    var storedUsername: string;\n    var storedPassword: string;\n\n    constructor(username: string, password: string) \n        ensures storedUsername == username\n        ensures storedPassword == password\n    {\n        storedUsername := username;\n        storedPassword := password;\n    }\n\n    method Authenticate(inputUsername: string, inputPassword: string) returns (isAuthenticated: bool)\n        ensures isAuthenticated == (inputUsername == storedUsername && inputPassword == storedPassword)\n    {\n        isAuthenticated := false;\n        if inputUsername == storedUsername && inputPassword == storedPassword {\n            isAuthenticated := true;\n        }\n    }\n\n    method ChangePassword(oldPassword: string, newPassword: string) returns (isChanged: bool)\n        ensures isChanged ==> storedPassword == newPassword\n        ensures !isChanged ==> storedPassword == oldPassword\n    {\n        isChanged := false;\n        if oldPassword == storedPassword {\n            storedPassword := newPassword;\n            isChanged := true;\n        }\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_272",
            "type": "program",
            "content": "class Matrix2x2 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    constructor(a: int, b: int, c: int, d: int)\n        ensures this.a == a && this.b == b && this.c == c && this.d == d\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n    }\n    method Determinant() returns (det: int)\n        ensures det == a * d - b * c\n    {\n        det := a * d - b * c;\n    }\nmethod MultiplyByScalar(scalar: int) returns (result: Matrix2x2)\n    ensures result.a == this.a * scalar\n    ensures result.b == this.b * scalar\n    ensures result.c == this.c * scalar\n    ensures result.d == this.d * scalar\n{\n    result := new Matrix2x2(this.a * scalar, this.b * scalar, this.c * scalar, this.d * scalar);\n}\nmethod Transpose() returns (result: Matrix2x2)\n    ensures result.a == this.a\n    ensures result.b == this.c\n    ensures result.c == this.b\n    ensures result.d == this.d\n{\n    result := new Matrix2x2(this.a, this.c, this.b, this.d);\n}\n}",
            "parents": [
                "node_199"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 19\nmethod MultiplyByScalar(scalar: int) returns (result: Matrix2x2)\n    ensures result.a == this.a * scalar\n    ensures result.b == this.b * scalar\n    ensures result.c == this.c * scalar\n    ensures result.d == this.d * scalar\n{\n    result := new Matrix2x2(this.a * scalar, this.b * scalar, this.c * scalar, this.d * scalar);\n}\n\nmethod Transpose() returns (result: Matrix2x2)\n    ensures result.a == this.a\n    ensures result.b == this.c\n    ensures result.c == this.b\n    ensures result.d == this.d\n{\n    result := new Matrix2x2(this.a, this.c, this.b, this.d);\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_273",
            "type": "program",
            "content": "class Employee {\n    var hoursWorked: int;\n    var payRate: int;\n    constructor(hoursWorked: int, payRate: int)\n        ensures this.hoursWorked == hoursWorked && this.payRate == payRate\n    {\n        this.hoursWorked := hoursWorked;\n        this.payRate := payRate;\n    }\nmethod CalculateSalaryWithOvertime() returns (salary: int)\n    ensures salary == hoursWorked * payRate + (if hoursWorked > 40 then (hoursWorked - 40) * payRate / 2 else 0)\n{\n    var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n    var regularHours := hoursWorked - overtimeHours;\n    salary := 0;\n    var i := 0;\n    while i < regularHours\n        invariant 0 <= i <= regularHours\n        invariant salary == i * payRate\n    {\n        salary := salary + payRate;\n        i := i + 1;\n    }\n    i := 0;\n    while i < overtimeHours\n        invariant 0 <= i <= overtimeHours\n        invariant salary == regularHours * payRate + i * payRate / 2\n        invariant salary == (regularHours + i) * payRate - i * payRate / 2\n    {\n        salary := salary + payRate / 2;\n        i := i + 1;\n    }\n}\n}",
            "parents": [
                "node_234"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 10\nmethod CalculateSalaryWithOvertime() returns (salary: int)\n    ensures salary == hoursWorked * payRate + (if hoursWorked > 40 then (hoursWorked - 40) * payRate / 2 else 0)\n{\n    var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n    var regularHours := hoursWorked - overtimeHours;\n    salary := 0;\n    var i := 0;\n    while i < regularHours\n        invariant 0 <= i <= regularHours\n        invariant salary == i * payRate\n    {\n        salary := salary + payRate;\n        i := i + 1;\n    }\n    i := 0;\n    while i < overtimeHours\n        invariant 0 <= i <= overtimeHours\n        invariant salary == regularHours * payRate + i * payRate / 2\n        invariant salary == (regularHours + i) * payRate - i * payRate / 2\n    {\n        salary := salary + payRate / 2;\n        i := i + 1;\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_274",
            "type": "program",
            "content": "method Median(a: array<int>) returns (median: int)\n    requires a != null && a.Length > 0\n    ensures 0 <= median < a.Length\n    ensures forall i: int :: 0 <= i < a.Length ==> a[median] <= a[i] || a[median] >= a[i]\n{\n    var n := a.Length;\n    var sorted := new int[n];\n    // Copy the array\n    for i := 0 to n - 1\n        invariant 0 <= i <= n\n        invariant forall j: int :: 0 <= j < i ==> sorted[j] == a[j]\n    {\n        sorted[i] := a[i];\n    }\n    // Sort the array (simple insertion sort for demonstration)\n    for i := 1 to n - 1\n        invariant 1 <= i <= n\n        invariant forall j: int :: 0 <= j < i - 1 ==> sorted[j] <= sorted[j + 1]\n}",
            "parents": [
                "node_212"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 18\n        invariant forall j: int :: 0 <= j < i - 1 ==> sorted[j] <= sorted[j + 1]\n// END DAFNY\n```"
        },
        {
            "id": "node_275",
            "type": "program",
            "content": "class Matrix3x3 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    var e: int;\n    var f: int;\n    var g: int;\n    var h: int;\n    var i: int;\n    constructor(a: int, b: int, c: int, d: int, e: int, f: int, g: int, h: int, i: int)\n        ensures this.a == a && this.b == b && this.c == c\n        ensures this.d == d && this.e == e && this.f == f\n        ensures this.g == g && this.h == h && this.i == i\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n        this.e := e;\n        this.f := f;\n        this.g := g;\n        this.h := h;\n        this.i := i;\n    }\n    method Determinant() returns (det: int)\n        ensures det == a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g)\n    {\n        det := a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g);\n    }\nmethod Transpose() returns (transposed: Matrix3x3)\n    ensures transposed.a == this.a && transposed.b == this.d && transposed.c == this.g\n    ensures transposed.d == this.b && transposed.e == this.e && transposed.f == this.h\n    ensures transposed.g == this.c && transposed.h == this.f && transposed.i == this.i\n{\n    transposed := new Matrix3x3(\n        this.a, this.d, this.g,\n        this.b, this.e, this.h,\n        this.c, this.f, this.i\n    );\n}\nmethod Multiply(other: Matrix3x3) returns (product: Matrix3x3)\n    ensures product.a == this.a * other.a + this.b * other.d + this.c * other.g\n    ensures product.b == this.a * other.b + this.b * other.e + this.c * other.h\n    ensures product.c == this.a * other.c + this.b * other.f + this.c * other.i\n    ensures product.d == this.d * other.a + this.e * other.d + this.f * other.g\n    ensures product.e == this.d * other.b + this.e * other.e + this.f * other.h\n    ensures product.f == this.d * other.c + this.e * other.f + this.f * other.i\n    ensures product.g == this.g * other.a + this.h * other.d + this.i * other.g\n    ensures product.h == this.g * other.b + this.h * other.e + this.i * other.h\n    ensures product.i == this.g * other.c + this.h * other.f + this.i * other.i\n{\n    var newA := this.a * other.a + this.b * other.d + this.c * other.g;\n    var newB := this.a * other.b + this.b * other.e + this.c * other.h;\n    var newC := this.a * other.c + this.b * other.f + this.c * other.i;\n    var newD := this.d * other.a + this.e * other.d + this.f * other.g;\n    var newE := this.d * other.b + this.e * other.e + this.f * other.h;\n    var newF := this.d * other.c + this.e * other.f + this.f * other.i;\n    var newG := this.g * other.a + this.h * other.d + this.i * other.g;\n    var newH := this.g * other.b + this.h * other.e + this.i * other.h;\n    var newI := this.g * other.c + this.h * other.f + this.i * other.i;\n    product := new Matrix3x3(newA, newB, newC, newD, newE, newF, newG, newH, newI);\n}\n}",
            "parents": [
                "node_255"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 42\nmethod Multiply(other: Matrix3x3) returns (product: Matrix3x3)\n    ensures product.a == this.a * other.a + this.b * other.d + this.c * other.g\n    ensures product.b == this.a * other.b + this.b * other.e + this.c * other.h\n    ensures product.c == this.a * other.c + this.b * other.f + this.c * other.i\n    ensures product.d == this.d * other.a + this.e * other.d + this.f * other.g\n    ensures product.e == this.d * other.b + this.e * other.e + this.f * other.h\n    ensures product.f == this.d * other.c + this.e * other.f + this.f * other.i\n    ensures product.g == this.g * other.a + this.h * other.d + this.i * other.g\n    ensures product.h == this.g * other.b + this.h * other.e + this.i * other.h\n    ensures product.i == this.g * other.c + this.h * other.f + this.i * other.i\n{\n    var newA := this.a * other.a + this.b * other.d + this.c * other.g;\n    var newB := this.a * other.b + this.b * other.e + this.c * other.h;\n    var newC := this.a * other.c + this.b * other.f + this.c * other.i;\n    var newD := this.d * other.a + this.e * other.d + this.f * other.g;\n    var newE := this.d * other.b + this.e * other.e + this.f * other.h;\n    var newF := this.d * other.c + this.e * other.f + this.f * other.i;\n    var newG := this.g * other.a + this.h * other.d + this.i * other.g;\n    var newH := this.g * other.b + this.h * other.e + this.i * other.h;\n    var newI := this.g * other.c + this.h * other.f + this.i * other.i;\n\n    product := new Matrix3x3(newA, newB, newC, newD, newE, newF, newG, newH, newI);\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_276",
            "type": "program",
            "content": "class City {\n    var id: int;\n    constructor(id: int)\n        ensures this.id == id\n    {\n        this.id := id;\n    }\n}\nclass Tour {\n    var cities: seq<City>;\n    constructor(cities: seq<City>)\n        ensures this.cities == cities\n    {\n        this.cities := cities;\n    }\nmethod IsValidTour() returns (isValid: bool)\n    ensures isValid == (|cities| > 1 && cities[0] == cities[|cities| - 1])\n{\n    isValid := false;\n    if |cities| > 1 {\n        var i := 0;\n        while i < |cities| - 1\n            invariant 0 <= i <= |cities| - 1\n            invariant cities[0] == cities[|cities| - 1] ==> isValid\n            invariant forall j :: 0 <= j < i ==> cities[j] != cities[|cities| - 1]\n        {\n            if cities[i] == cities[|cities| - 1] {\n                isValid := true;\n                break;\n            }\n            i := i + 1;\n        }\n}\n}\n}",
            "parents": [
                "node_218"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 22\n        while i < |cities| - 1\n            invariant 0 <= i <= |cities| - 1\n            invariant cities[0] == cities[|cities| - 1] ==> isValid\n            invariant forall j :: 0 <= j < i ==> cities[j] != cities[|cities| - 1]\n        {\n            if cities[i] == cities[|cities| - 1] {\n                isValid := true;\n                break;\n            }\n            i := i + 1;\n        }\n// END DAFNY\n```"
        },
        {
            "id": "node_277",
            "type": "program",
            "content": "class Employee {\n    var hoursWorked: int;\n    var payRate: int;\n    constructor(hoursWorked: int, payRate: int)\n        ensures this.hoursWorked == hoursWorked && this.payRate == payRate\n    {\n        this.hoursWorked := hoursWorked;\n        this.payRate := payRate;\n    }\nmethod CalculateSalaryWithOvertime() returns (salary: int)\n    ensures salary == hoursWorked * payRate + (if hoursWorked > 40 then (hoursWorked - 40) * payRate / 2 else 0)\n{\n    var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n    var regularHours := hoursWorked - overtimeHours;\n    salary := 0;\n    var i := 0;\n    while i < regularHours\n        invariant 0 <= i <= regularHours\n        invariant salary == i * payRate\n    {\n        salary := salary + payRate;\n        i := i + 1;\n    }\n    i := 0;\n    while i < overtimeHours\n        invariant 0 <= i <= overtimeHours\n        invariant salary == regularHours * payRate + i * (payRate / 2)\n    {\n        salary := salary + payRate / 2;\n        i := i + 1;\n    }\n}\n}",
            "parents": [
                "node_216"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 10\nmethod CalculateSalaryWithOvertime() returns (salary: int)\n    ensures salary == hoursWorked * payRate + (if hoursWorked > 40 then (hoursWorked - 40) * payRate / 2 else 0)\n{\n    var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n    var regularHours := hoursWorked - overtimeHours;\n    salary := 0;\n    var i := 0;\n    while i < regularHours\n        invariant 0 <= i <= regularHours\n        invariant salary == i * payRate\n    {\n        salary := salary + payRate;\n        i := i + 1;\n    }\n    i := 0;\n    while i < overtimeHours\n        invariant 0 <= i <= overtimeHours\n        invariant salary == regularHours * payRate + i * (payRate / 2)\n    {\n        salary := salary + payRate / 2;\n        i := i + 1;\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_278",
            "type": "program",
            "content": "class PayrollSystem {\n    var hourlyRate: real;\n    var hoursWorked: real;\n    constructor(rate: real, hours: real)\n        requires rate >= 0.0 && hours >= 0.0\n    {\n        hourlyRate := rate;\n        hoursWorked := hours;\n    }\nmethod CalculateSalaryWithOvertime() returns (salary: real)\n    ensures salary == hourlyRate * hoursWorked + (if hoursWorked > 40.0 then (hoursWorked - 40.0) * hourlyRate * 0.5 else 0.0)\n{\n    var regularHours := if hoursWorked > 40.0 then 40.0 else hoursWorked;\n    var overtimeHours := if hoursWorked > 40.0 then hoursWorked - 40.0 else 0.0;\n    salary := hourlyRate * regularHours + overtimeHours * hourlyRate * 1.5;\n}\n}",
            "parents": [
                "node_132"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 10\nmethod CalculateSalaryWithOvertime() returns (salary: real)\n    ensures salary == hourlyRate * hoursWorked + (if hoursWorked > 40.0 then (hoursWorked - 40.0) * hourlyRate * 0.5 else 0.0)\n{\n    var regularHours := if hoursWorked > 40.0 then 40.0 else hoursWorked;\n    var overtimeHours := if hoursWorked > 40.0 then hoursWorked - 40.0 else 0.0;\n    salary := hourlyRate * regularHours + overtimeHours * hourlyRate * 1.5;\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_279",
            "type": "program",
            "content": "class Tournament {\n    var seeds: array<int>;\n    constructor(seeds: array<int>)\n        requires seeds.Length > 0\n        ensures this.seeds == seeds\n    {\n        this.seeds := seeds;\n    }\n    method GenerateMatchups() returns (matchups: array<(int, int)>)\n        requires seeds.Length % 2 == 0\n        ensures matchups.Length == seeds.Length / 2\n        ensures forall i :: 0 <= i < matchups.Length ==> \n            matchups[i].0 in seeds[..] && matchups[i].1 in seeds[..]\n    {\n        matchups := new (int, int)[seeds.Length / 2];\n        var i := 0;\n        while i < seeds.Length / 2\n            invariant 0 <= i <= seeds.Length / 2\n            invariant matchups.Length == seeds.Length / 2\n            invariant forall j :: 0 <= j < i ==> \n                matchups[j].0 in seeds[..] && matchups[j].1 in seeds[..]\n        {\n            matchups[i] := (seeds[i], seeds[seeds.Length - i - 1]);\n            i := i + 1;\n        }\n    }\n}",
            "parents": [
                "idea_96"
            ],
            "diff": "```\n// BEGIN DAFNY\nclass Tournament {\n    var seeds: array<int>;\n\n    constructor(seeds: array<int>)\n        requires seeds.Length > 0\n        ensures this.seeds == seeds\n    {\n        this.seeds := seeds;\n    }\n\n    method GenerateMatchups() returns (matchups: array<(int, int)>)\n        requires seeds.Length % 2 == 0\n        ensures matchups.Length == seeds.Length / 2\n        ensures forall i :: 0 <= i < matchups.Length ==> \n            matchups[i].0 in seeds[..] && matchups[i].1 in seeds[..]\n    {\n        matchups := new (int, int)[seeds.Length / 2];\n        var i := 0;\n        while i < seeds.Length / 2\n            invariant 0 <= i <= seeds.Length / 2\n            invariant matchups.Length == seeds.Length / 2\n            invariant forall j :: 0 <= j < i ==> \n                matchups[j].0 in seeds[..] && matchups[j].1 in seeds[..]\n        {\n            matchups[i] := (seeds[i], seeds[seeds.Length - i - 1]);\n            i := i + 1;\n        }\n    }\n}\n// END DAFNY\n```\n\nThis program models a basic tournament bracket generator. It includes a `Tournament` class with a constructor that initializes the seeds for the tournament. The `GenerateMatchups` method generates matchups based on the seeds, ensuring that each matchup is correctly scheduled. The loop invariant ensures that the matchups are correctly formed from the seeds."
        },
        {
            "id": "node_280",
            "type": "program",
            "content": "class Employee {\n    var hoursWorked: int;\n    var payRate: int;\n    constructor(hoursWorked: int, payRate: int)\n        ensures this.hoursWorked == hoursWorked && this.payRate == payRate\n    {\n        this.hoursWorked := hoursWorked;\n        this.payRate := payRate;\n    }\nmethod CalculateSalaryWithOvertime() returns (salary: int)\n    ensures salary >= hoursWorked * payRate\n{\n    var regularHours := if hoursWorked > 40 then 40 else hoursWorked;\n    var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n    var overtimePayRate := payRate * 3 / 2;\n    salary := 0;\n    var i := 0;\n    while i < regularHours\n        invariant 0 <= i <= regularHours\n        invariant salary == i * payRate\n    {\n        salary := salary + payRate;\n        i := i + 1;\n    }\n    i := 0;\n    while i < overtimeHours\n        invariant 0 <= i <= overtimeHours\n        invariant salary == regularHours * payRate + i * overtimePayRate\n    {\n        salary := salary + overtimePayRate;\n        i := i + 1;\n    }\n}\n}",
            "parents": [
                "node_128"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 10\nmethod CalculateSalaryWithOvertime() returns (salary: int)\n    ensures salary >= hoursWorked * payRate\n{\n    var regularHours := if hoursWorked > 40 then 40 else hoursWorked;\n    var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n    var overtimePayRate := payRate * 3 / 2;\n    salary := 0;\n    var i := 0;\n    while i < regularHours\n        invariant 0 <= i <= regularHours\n        invariant salary == i * payRate\n    {\n        salary := salary + payRate;\n        i := i + 1;\n    }\n    i := 0;\n    while i < overtimeHours\n        invariant 0 <= i <= overtimeHours\n        invariant salary == regularHours * payRate + i * overtimePayRate\n    {\n        salary := salary + overtimePayRate;\n        i := i + 1;\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_281",
            "type": "program",
            "content": "class Employee {\n    var hoursWorked: int;\n    var payRate: int;\n    constructor(hoursWorked: int, payRate: int)\n        ensures this.hoursWorked == hoursWorked && this.payRate == payRate\n    {\n        this.hoursWorked := hoursWorked;\n        this.payRate := payRate;\n    }\nmethod CalculateSalaryWithOvertime() returns (salary: int)\n    ensures salary >= hoursWorked * payRate\n{\n    var regularHours := if hoursWorked > 40 then 40 else hoursWorked;\n    var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n    var overtimePayRate := payRate * 3 / 2;\n    salary := 0;\n    var i := 0;\n    while i < regularHours\n        invariant 0 <= i <= regularHours\n        invariant salary == i * payRate\n    {\n        salary := salary + payRate;\n        i := i + 1;\n    }\n    i := 0;\n    while i < overtimeHours\n        invariant 0 <= i <= overtimeHours\n        invariant salary == regularHours * payRate + i * overtimePayRate\n    {\n        salary := salary + overtimePayRate;\n        i := i + 1;\n    }\n}\n}",
            "parents": [
                "node_152"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 10\nmethod CalculateSalaryWithOvertime() returns (salary: int)\n    ensures salary >= hoursWorked * payRate\n{\n    var regularHours := if hoursWorked > 40 then 40 else hoursWorked;\n    var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n    var overtimePayRate := payRate * 3 / 2;\n\n    salary := 0;\n    var i := 0;\n    while i < regularHours\n        invariant 0 <= i <= regularHours\n        invariant salary == i * payRate\n    {\n        salary := salary + payRate;\n        i := i + 1;\n    }\n\n    i := 0;\n    while i < overtimeHours\n        invariant 0 <= i <= overtimeHours\n        invariant salary == regularHours * payRate + i * overtimePayRate\n    {\n        salary := salary + overtimePayRate;\n        i := i + 1;\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_282",
            "type": "program",
            "content": "method GaussianElimination(a: array2<int>, b: array<int>) returns (x: array<int>)\n    requires a.Length0 == a.Length1 && a.Length0 == b.Length\n    ensures forall i :: 0 <= i < a.Length0 ==> a[i, i] * x[i] == b[i]\n{\n    var n := a.Length0;\n    x := new int[n];\n    // Forward elimination\n    for k := 0 to n - 1\n        invariant 0 <= k <= n\n        invariant forall i, j :: 0 <= i < k && 0 <= j < n ==> a[i, j] == 0\n    {\n        // Find the pivot\n        var max := k;\n        for i := k + 1 to n - 1\n            invariant k <= max < n\n            invariant forall j :: k <= j < i ==> a[max, k] >= a[j, k]\n        {\n            if a[i, k] > a[max, k] {\n                max := i;\n            }\n        }\n        // Swap rows\n        for j := 0 to n - 1\n            invariant 0 <= j <= n\n            invariant forall i :: 0 <= i < j ==> a[k, i] == a[max, i] && a[max, i] == a[k, i]\n        {\n            var temp := a[k, j];\n            a[k, j] := a[max, j];\n            a[max, j] := temp;\n        }\n        var tempB := b[k];\n        b[k] := b[max];\n        b[max] := tempB;\n        // Eliminate column\n        for i := k + 1 to n - 1\n            invariant k < i <= n\n            invariant forall j :: 0 <= j < n ==> (j < k ==> a[i, j] == 0) && (j >= k ==> a[i, j] == a[i, j])\n            invariant b[i] == b[i] - (a[i, k] / a[k, k]) * b[k]\n        {\n            var factor := a[i, k] / a[k, k];\n            b[i] := b[i] - factor * b[k];\n            for j := k to n - 1\n                invariant k <= j <= n\n                invariant forall l :: k <= l < j ==> a[i, l] == a[i, l] - factor * a[k, l]\n                invariant a[i, j] == a[i, j] - factor * a[k, j]\n            {\n                a[i, j] := a[i, j] - factor * a[k, j];\n            }\n        }\n}\n}",
            "parents": [
                "node_264"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 35\n        for i := k + 1 to n - 1\n            invariant k < i <= n\n            invariant forall j :: 0 <= j < n ==> (j < k ==> a[i, j] == 0) && (j >= k ==> a[i, j] == a[i, j])\n            invariant b[i] == b[i] - (a[i, k] / a[k, k]) * b[k]\n        {\n            var factor := a[i, k] / a[k, k];\n            b[i] := b[i] - factor * b[k];\n            for j := k to n - 1\n                invariant k <= j <= n\n                invariant forall l :: k <= l < j ==> a[i, l] == a[i, l] - factor * a[k, l]\n                invariant a[i, j] == a[i, j] - factor * a[k, j]\n            {\n                a[i, j] := a[i, j] - factor * a[k, j];\n            }\n        }\n// END DAFNY\n```"
        },
        {
            "id": "node_283",
            "type": "program",
            "content": "class VotingSystem {\n    var votes: array<int>;\n    constructor(n: int)\n        requires n > 0\n        ensures votes.Length == n\n        ensures forall i :: 0 <= i < n ==> votes[i] == 0\n    {\n        votes := new int[n];\n    }\n    method CastVote(candidate: int)\n        requires 0 <= candidate < votes.Length\n        modifies votes\n        ensures votes[candidate] == old(votes[candidate]) + 1\n    {\n        votes[candidate] := votes[candidate] + 1;\n    }\n    method GetWinner() returns (winner: int)\n        requires votes.Length > 0\n        ensures 0 <= winner < votes.Length\n        ensures forall i :: 0 <= i < votes.Length ==> votes[winner] >= votes[i]\n    {\n        var maxVotes := votes[0];\n        winner := 0;\n        for i := 1 to votes.Length - 1\n            invariant 0 <= i <= votes.Length\n            invariant 0 <= winner < votes.Length\n            invariant forall j :: 0 <= j < i ==> votes[winner] >= votes[j]\n        {\n            if votes[i] > maxVotes {\n                maxVotes := votes[i];\n                winner := i;\n            }\n        }\n}\n}",
            "parents": [
                "node_133"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 24\n        for i := 1 to votes.Length - 1\n            invariant 0 <= i <= votes.Length\n            invariant 0 <= winner < votes.Length\n            invariant forall j :: 0 <= j < i ==> votes[winner] >= votes[j]\n        {\n            if votes[i] > maxVotes {\n                maxVotes := votes[i];\n                winner := i;\n            }\n        }\n// END DAFNY\n```"
        },
        {
            "id": "node_284",
            "type": "program",
            "content": "method GaussianElimination(a: array2<int>, b: array<int>) returns (x: array<int>)\n    requires a.Length0 == a.Length1 && a.Length0 == b.Length\n    ensures forall i :: 0 <= i < a.Length0 ==> a[i, i] * x[i] == b[i]\n{\n    var n := a.Length0;\n    x := new int[n];\n    // Forward elimination\n    for k := 0 to n - 1\n        invariant 0 <= k <= n\n        invariant forall i, j :: 0 <= i < k && 0 <= j < n ==> a[i, j] == 0 || j >= i\n}",
            "parents": [
                "node_211"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 10\n        invariant forall i, j :: 0 <= i < k && 0 <= j < n ==> a[i, j] == 0 || j >= i\n// END DAFNY\n```"
        },
        {
            "id": "node_285",
            "type": "program",
            "content": "class LeapYearChecker {\n    method IsLeapYear(year: int) returns (isLeap: bool)\n        requires year > 0\n        ensures isLeap == ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)\n    {\n        var divisibleBy4 := year % 4 == 0;\n        var divisibleBy100 := year % 100 == 0;\n        var divisibleBy400 := year % 400 == 0;\n        isLeap := false;\n        if divisibleBy4 {\n            if divisibleBy100 {\n                if divisibleBy400 {\n                    isLeap := true;\n                }\n            } else {\n                isLeap := true;\n            }\n        }\n    }\n}",
            "parents": [
                "node_261"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 5\n    {\n        var divisibleBy4 := year % 4 == 0;\n        var divisibleBy100 := year % 100 == 0;\n        var divisibleBy400 := year % 400 == 0;\n\n        isLeap := false;\n\n        if divisibleBy4 {\n            if divisibleBy100 {\n                if divisibleBy400 {\n                    isLeap := true;\n                }\n            } else {\n                isLeap := true;\n            }\n        }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_286",
            "type": "program",
            "content": "class TournamentBracket {\n    method GenerateBracket(seeds: seq<int>) returns (matchups: seq<(int, int)>)\n        requires |seeds| > 0 && |seeds| % 2 == 0\n        ensures |matchups| == |seeds| / 2\n        ensures forall i :: 0 <= i < |matchups| ==> matchups[i].0 != matchups[i].1\n    {\n        var n := |seeds|;\n        matchups := [];\n        for i := 0 to n / 2 - 1\n            invariant 0 <= i <= n / 2\n            invariant |matchups| == i\n            invariant forall j :: 0 <= j < i ==> matchups[j].0 != matchups[j].1\n        {\n            var team1 := seeds[i];\n            var team2 := seeds[n - i - 1];\n            matchups := matchups + [(team1, team2)];\n        }\n}\n}",
            "parents": [
                "node_157"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 9\n        for i := 0 to n / 2 - 1\n            invariant 0 <= i <= n / 2\n            invariant |matchups| == i\n            invariant forall j :: 0 <= j < i ==> matchups[j].0 != matchups[j].1\n        {\n            var team1 := seeds[i];\n            var team2 := seeds[n - i - 1];\n            matchups := matchups + [(team1, team2)];\n        }\n// END DAFNY\n```"
        },
        {
            "id": "node_287",
            "type": "program",
            "content": "class PayrollSystem {\n    var hourlyRate: real;\n    var hoursWorked: real;\n    constructor(rate: real, hours: real)\n        requires rate >= 0.0 && hours >= 0.0\n    {\n        hourlyRate := rate;\n        hoursWorked := hours;\n    }\n    method CalculateSalaryWithOvertime() returns (salary: real)\n        ensures salary == hourlyRate * hoursWorked + (if hoursWorked > 40.0 then (hoursWorked - 40.0) * hourlyRate * 0.5 else 0.0)\n    {\n        var regularHours: real := if hoursWorked > 40.0 then 40.0 else hoursWorked;\n        var overtimeHours: real := if hoursWorked > 40.0 then hoursWorked - 40.0 else 0.0;\n        salary := hourlyRate * regularHours + overtimeHours * hourlyRate * 1.5;\n    }\n}",
            "parents": [
                "node_132"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 10\n    method CalculateSalaryWithOvertime() returns (salary: real)\n        ensures salary == hourlyRate * hoursWorked + (if hoursWorked > 40.0 then (hoursWorked - 40.0) * hourlyRate * 0.5 else 0.0)\n    {\n        var regularHours: real := if hoursWorked > 40.0 then 40.0 else hoursWorked;\n        var overtimeHours: real := if hoursWorked > 40.0 then hoursWorked - 40.0 else 0.0;\n        salary := hourlyRate * regularHours + overtimeHours * hourlyRate * 1.5;\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_288",
            "type": "program",
            "content": "module GameOfLife {\n  method NextGeneration(board: array2<bool>) returns (nextBoard: array2<bool>)\n    requires board.Length0 > 0 && board.Length1 > 0\n    ensures nextBoard.Length0 == board.Length0 && nextBoard.Length1 == board.Length1\n  {\n    var rows := board.Length0;\n    var cols := board.Length1;\n    nextBoard := new bool[rows, cols];\n    for i := 0 to rows - 1 {\n      for j := 0 to cols - 1 {\n        var liveNeighbors := CountLiveNeighbors(board, i, j);\n        if board[i, j] {\n          nextBoard[i, j] := liveNeighbors == 2 || liveNeighbors == 3;\n        } else {\n          nextBoard[i, j] := liveNeighbors == 3;\n        }\n      }\n    }\n  }\n  method CountLiveNeighbors(board: array2<bool>, x: int, y: int) returns (count: int)\n    requires 0 <= x < board.Length0 && 0 <= y < board.Length1\n    ensures 0 <= count <= 8\n  {\n    count := 0;\n    for dx := -1 to 1 {\n      for dy := -1 to 1 {\n        if dx != 0 || dy != 0 {\n          var nx := x + dx;\n          var ny := y + dy;\n          if 0 <= nx < board.Length0 && 0 <= ny < board.Length1 {\n            if board[nx, ny] {\n              count := count + 1;\n            }\n          }\n        }\n      }\n    }\n  }\n}",
            "parents": [
                "idea_38"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\nmodule GameOfLife {\n  method NextGeneration(board: array2<bool>) returns (nextBoard: array2<bool>)\n    requires board.Length0 > 0 && board.Length1 > 0\n    ensures nextBoard.Length0 == board.Length0 && nextBoard.Length1 == board.Length1\n  {\n    var rows := board.Length0;\n    var cols := board.Length1;\n    nextBoard := new bool[rows, cols];\n\n    for i := 0 to rows - 1 {\n      for j := 0 to cols - 1 {\n        var liveNeighbors := CountLiveNeighbors(board, i, j);\n        if board[i, j] {\n          nextBoard[i, j] := liveNeighbors == 2 || liveNeighbors == 3;\n        } else {\n          nextBoard[i, j] := liveNeighbors == 3;\n        }\n      }\n    }\n  }\n\n  method CountLiveNeighbors(board: array2<bool>, x: int, y: int) returns (count: int)\n    requires 0 <= x < board.Length0 && 0 <= y < board.Length1\n    ensures 0 <= count <= 8\n  {\n    count := 0;\n    for dx := -1 to 1 {\n      for dy := -1 to 1 {\n        if dx != 0 || dy != 0 {\n          var nx := x + dx;\n          var ny := y + dy;\n          if 0 <= nx < board.Length0 && 0 <= ny < board.Length1 {\n            if board[nx, ny] {\n              count := count + 1;\n            }\n          }\n        }\n      }\n    }\n  }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_289",
            "type": "program",
            "content": "class CurrencyConverter {\n    var exchangeRate: real;\n    constructor(rate: real)\n        requires rate > 0.0\n        ensures this.exchangeRate == rate\n    {\n        this.exchangeRate := rate;\n    }\n    method ConvertWithFee(amount: real, feePercentage: real) returns (convertedAmount: real)\n        requires amount >= 0.0\n        requires feePercentage >= 0.0 && feePercentage <= 100.0\n        ensures convertedAmount == amount * exchangeRate * (1.0 - feePercentage / 100.0)\n    {\n        var feeFactor := 1.0 - feePercentage / 100.0;\n        convertedAmount := amount * exchangeRate * feeFactor;\n    }\n}",
            "parents": [
                "node_179"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 9\n    method ConvertWithFee(amount: real, feePercentage: real) returns (convertedAmount: real)\n        requires amount >= 0.0\n        requires feePercentage >= 0.0 && feePercentage <= 100.0\n        ensures convertedAmount == amount * exchangeRate * (1.0 - feePercentage / 100.0)\n    {\n        var feeFactor := 1.0 - feePercentage / 100.0;\n        convertedAmount := amount * exchangeRate * feeFactor;\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_290",
            "type": "program",
            "content": "class CurrencyConverter {\n    var exchangeRate: real;\n    constructor(rate: real)\n        requires rate > 0.0\n        ensures this.exchangeRate == rate\n    {\n        this.exchangeRate := rate;\n    }\n    method ConvertWithFee(amount: real, feePercentage: real) returns (convertedAmount: real)\n        requires amount >= 0.0\n        requires feePercentage >= 0.0 && feePercentage <= 100.0\n        ensures convertedAmount == amount * exchangeRate * (1.0 - feePercentage / 100.0)\n    {\n        var feeFactor: real := 1.0 - feePercentage / 100.0;\n        convertedAmount := amount * exchangeRate * feeFactor;\n    }\n}",
            "parents": [
                "node_119"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 9\n    method ConvertWithFee(amount: real, feePercentage: real) returns (convertedAmount: real)\n        requires amount >= 0.0\n        requires feePercentage >= 0.0 && feePercentage <= 100.0\n        ensures convertedAmount == amount * exchangeRate * (1.0 - feePercentage / 100.0)\n    {\n        var feeFactor: real := 1.0 - feePercentage / 100.0;\n        convertedAmount := amount * exchangeRate * feeFactor;\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_291",
            "type": "program",
            "content": "class LinearInequalitiesSolver {\n    method SolveSingleInequality(a: int, b: int, c: int) returns (solution: bool)\n        requires a != 0\n        ensures solution == (c >= b / a)\n    {\n        if a > 0 {\n            solution := c >= b / a;\n        } else {\n            solution := c <= b / a;\n        }\n    }\n    method VerifySolution(a: int, b: int, c: int, x: int) returns (isValid: bool)\n        requires a != 0\n        ensures isValid == (a * x + b <= c)\n    {\n        isValid := a * x + b <= c;\n    }\n    method SolveMultipleInequalities(a: seq<int>, b: seq<int>, c: seq<int>) returns (solutions: seq<bool>)\n        requires |a| == |b| && |b| == |c|\n        requires forall i :: 0 <= i < |a| ==> a[i] != 0\n        ensures |solutions| == |a|\n        ensures forall i :: 0 <= i < |a| ==> solutions[i] == (if a[i] > 0 then c[i] >= b[i] / a[i] else c[i] <= b[i] / a[i])\n    {\n        solutions := [];\n        var i := 0;\n        while i < |a|\n            invariant 0 <= i <= |a|\n            invariant |solutions| == i\n            invariant forall j :: 0 <= j < i ==> solutions[j] == (if a[j] > 0 then c[j] >= b[j] / a[j] else c[j] <= b[j] / a[j])\n        {\n            if a[i] > 0 {\n                solutions := solutions + [c[i] >= b[i] / a[i]];\n            } else {\n                solutions := solutions + [c[i] <= b[i] / a[i]];\n            }\n            i := i + 1;\n        }\n    }\n}",
            "parents": [
                "node_191"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 18\n    method SolveMultipleInequalities(a: seq<int>, b: seq<int>, c: seq<int>) returns (solutions: seq<bool>)\n        requires |a| == |b| && |b| == |c|\n        requires forall i :: 0 <= i < |a| ==> a[i] != 0\n        ensures |solutions| == |a|\n        ensures forall i :: 0 <= i < |a| ==> solutions[i] == (if a[i] > 0 then c[i] >= b[i] / a[i] else c[i] <= b[i] / a[i])\n    {\n        solutions := [];\n        var i := 0;\n        while i < |a|\n            invariant 0 <= i <= |a|\n            invariant |solutions| == i\n            invariant forall j :: 0 <= j < i ==> solutions[j] == (if a[j] > 0 then c[j] >= b[j] / a[j] else c[j] <= b[j] / a[j])\n        {\n            if a[i] > 0 {\n                solutions := solutions + [c[i] >= b[i] / a[i]];\n            } else {\n                solutions := solutions + [c[i] <= b[i] / a[i]];\n            }\n            i := i + 1;\n        }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_292",
            "type": "program",
            "content": "class Matrix2x2 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    constructor(a: int, b: int, c: int, d: int)\n        ensures this.a == a && this.b == b && this.c == c && this.d == d\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n    }\n    method Determinant() returns (det: int)\n        ensures det == a * d - b * c\n    {\n        det := a * d - b * c;\n    }\nmethod MultiplyByScalar(scalar: int) returns (result: Matrix2x2)\n    ensures result.a == this.a * scalar && result.b == this.b * scalar\n    ensures result.c == this.c * scalar && result.d == this.d * scalar\n{\n    result := new Matrix2x2(this.a * scalar, this.b * scalar, this.c * scalar, this.d * scalar);\n}\nmethod Transpose() returns (result: Matrix2x2)\n    ensures result.a == this.a && result.b == this.c\n    ensures result.c == this.b && result.d == this.d\n{\n    result := new Matrix2x2(this.a, this.c, this.b, this.d);\n}\nmethod Add(other: Matrix2x2) returns (result: Matrix2x2)\n    ensures result.a == this.a + other.a && result.b == this.b + other.b\n    ensures result.c == this.c + other.c && result.d == this.d + other.d\n{\n    result := new Matrix2x2(this.a + other.a, this.b + other.b, this.c + other.c, this.d + other.d);\n}\nmethod MultiplyByMatrix(other: Matrix2x2) returns (result: Matrix2x2)\n    ensures result.a == this.a * other.a + this.b * other.c\n    ensures result.b == this.a * other.b + this.b * other.d\n    ensures result.c == this.c * other.a + this.d * other.c\n    ensures result.d == this.c * other.b + this.d * other.d\n{\n    result := new Matrix2x2(\n        this.a * other.a + this.b * other.c,\n        this.a * other.b + this.b * other.d,\n        this.c * other.a + this.d * other.c,\n        this.c * other.b + this.d * other.d\n    );\n}\n}",
            "parents": [
                "node_267"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 31\nmethod Add(other: Matrix2x2) returns (result: Matrix2x2)\n    ensures result.a == this.a + other.a && result.b == this.b + other.b\n    ensures result.c == this.c + other.c && result.d == this.d + other.d\n{\n    result := new Matrix2x2(this.a + other.a, this.b + other.b, this.c + other.c, this.d + other.d);\n}\n\nmethod MultiplyByMatrix(other: Matrix2x2) returns (result: Matrix2x2)\n    ensures result.a == this.a * other.a + this.b * other.c\n    ensures result.b == this.a * other.b + this.b * other.d\n    ensures result.c == this.c * other.a + this.d * other.c\n    ensures result.d == this.c * other.b + this.d * other.d\n{\n    result := new Matrix2x2(\n        this.a * other.a + this.b * other.c,\n        this.a * other.b + this.b * other.d,\n        this.c * other.a + this.d * other.c,\n        this.c * other.b + this.d * other.d\n    );\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_293",
            "type": "program",
            "content": "method GCD(a: nat, b: nat) returns (gcd: nat)\n    requires a > 0 && b > 0\n    ensures gcd > 0\n    ensures a % gcd == 0 && b % gcd == 0\n    ensures forall d: nat :: d > 0 && a % d == 0 && b % d == 0 ==> gcd >= d\n{\n    var x := a;\n    var y := b;\n    while y != 0\n        invariant x > 0\n        invariant y >= 0\n        invariant forall d: nat :: d > 0 && x % d == 0 && y % d == 0 ==> gcd >= d\n}",
            "parents": [
                "node_240"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 12\n        invariant forall d: nat :: d > 0 && x % d == 0 && y % d == 0 ==> gcd >= d\n// END DAFNY\n```"
        },
        {
            "id": "node_294",
            "type": "program",
            "content": "class CurrencyConverter {\n    var exchangeRate: real;\n    constructor(rate: real)\n        requires rate > 0.0\n        ensures this.exchangeRate == rate\n    {\n        this.exchangeRate := rate;\n    }\n    method ConvertWithFee(amount: real, feePercentage: real) returns (convertedAmount: real)\n        requires amount >= 0.0\n        requires feePercentage >= 0.0 && feePercentage <= 100.0\n        ensures convertedAmount == amount * exchangeRate * (1.0 - feePercentage / 100.0)\n    {\n        var feeMultiplier := 1.0 - feePercentage / 100.0;\n        convertedAmount := amount * exchangeRate * feeMultiplier;\n    }\n}",
            "parents": [
                "node_179"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 9\n    method ConvertWithFee(amount: real, feePercentage: real) returns (convertedAmount: real)\n        requires amount >= 0.0\n        requires feePercentage >= 0.0 && feePercentage <= 100.0\n        ensures convertedAmount == amount * exchangeRate * (1.0 - feePercentage / 100.0)\n    {\n        var feeMultiplier := 1.0 - feePercentage / 100.0;\n        convertedAmount := amount * exchangeRate * feeMultiplier;\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_295",
            "type": "program",
            "content": "method GaussianElimination(a: array2<int>, b: array<int>) returns (x: array<int>)\n    requires a.Length0 == a.Length1 && a.Length0 == b.Length\n    ensures forall i :: 0 <= i < a.Length0 ==> a[i, i] * x[i] == b[i]\n{\n    var n := a.Length0;\n    x := new int[n];\n    // Forward elimination\n    for k := 0 to n - 1\n        invariant 0 <= k <= n\n        invariant forall i, j :: 0 <= i < k && 0 <= j < n ==> a[i, j] == 0\n    {\n        // Find the pivot\n        var max := k;\n        for i := k + 1 to n - 1\n            invariant k <= max < n\n            invariant forall j :: k <= j < i ==> a[max, k] >= a[j, k]\n        {\n            if a[i, k] > a[max, k] {\n                max := i;\n            }\n        }\n        // Swap rows\n        for j := 0 to n - 1\n            invariant 0 <= j <= n\n            invariant forall i :: 0 <= i < j ==> a[k, i] == a[max, i] && a[max, i] == a[k, i]\n        {\n            var temp := a[k, j];\n            a[k, j] := a[max, j];\n            a[max, j] := temp;\n        }\n        var tempB := b[k];\n        b[k] := b[max];\n        b[max] := tempB;\n        // Eliminate column\n        // Eliminate column\n        for i := k + 1 to n - 1\n            invariant k < i <= n\n            invariant forall j :: 0 <= j < n ==> (j < k ==> a[i, j] == 0) && (j >= k ==> a[i, j] == a[i, j])\n            invariant b[i] == b[i] - (a[i, k] / a[k, k]) * b[k]\n            invariant forall j :: k <= j < n ==> a[i, j] == a[i, j] - (a[i, k] / a[k, k]) * a[k, j]\n        {\n            var factor := a[i, k] / a[k, k];\n            b[i] := b[i] - factor * b[k];\n            for j := k to n - 1\n                invariant k <= j <= n\n                invariant forall l :: k <= l < j ==> a[i, l] == a[i, l] - factor * a[k, l]\n                invariant a[i, j] == a[i, j] - factor * a[k, j]\n            {\n                a[i, j] := a[i, j] - factor * a[k, j];\n            }\n        }\n}\n}",
            "parents": [
                "node_252"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 35\n        // Eliminate column\n        for i := k + 1 to n - 1\n            invariant k < i <= n\n            invariant forall j :: 0 <= j < n ==> (j < k ==> a[i, j] == 0) && (j >= k ==> a[i, j] == a[i, j])\n            invariant b[i] == b[i] - (a[i, k] / a[k, k]) * b[k]\n            invariant forall j :: k <= j < n ==> a[i, j] == a[i, j] - (a[i, k] / a[k, k]) * a[k, j]\n        {\n            var factor := a[i, k] / a[k, k];\n            b[i] := b[i] - factor * b[k];\n            for j := k to n - 1\n                invariant k <= j <= n\n                invariant forall l :: k <= l < j ==> a[i, l] == a[i, l] - factor * a[k, l]\n                invariant a[i, j] == a[i, j] - factor * a[k, j]\n            {\n                a[i, j] := a[i, j] - factor * a[k, j];\n            }\n        }\n// END DAFNY\n```"
        },
        {
            "id": "node_296",
            "type": "program",
            "content": "class Employee {\n    var hoursWorked: int;\n    var payRate: int;\n    constructor(hoursWorked: int, payRate: int)\n        ensures this.hoursWorked == hoursWorked && this.payRate == payRate\n    {\n        this.hoursWorked := hoursWorked;\n        this.payRate := payRate;\n    }\nmethod CalculateSalaryWithOvertime() returns (salary: int)\n    ensures salary == hoursWorked * payRate + (if hoursWorked > 40 then (hoursWorked - 40) * payRate / 2 else 0)\n{\n    var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n    var overtimePay := overtimeHours * payRate / 2;\n    salary := hoursWorked * payRate + overtimePay;\n}\n}",
            "parents": [
                "node_178"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 10\nmethod CalculateSalaryWithOvertime() returns (salary: int)\n    ensures salary == hoursWorked * payRate + (if hoursWorked > 40 then (hoursWorked - 40) * payRate / 2 else 0)\n{\n    var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n    var overtimePay := overtimeHours * payRate / 2;\n    salary := hoursWorked * payRate + overtimePay;\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_297",
            "type": "program",
            "content": "class Tournament {\n    var seeds: array<int>;\n    constructor(seeds: array<int>)\n        requires seeds.Length > 0\n        ensures this.seeds == seeds\n    {\n        this.seeds := seeds;\n    }\n    method GenerateMatchups() returns (matchups: array<(int, int)>)\n        requires seeds.Length % 2 == 0\n        ensures matchups.Length == seeds.Length / 2\n        ensures forall i :: 0 <= i < matchups.Length ==> \n            matchups[i].0 in seeds[..] && matchups[i].1 in seeds[..]\n    {\n        matchups := new (int, int)[seeds.Length / 2];\n        var i := 0;\n        var j := 0;\n        while i < seeds.Length / 2\n            invariant 0 <= i <= seeds.Length / 2\n            invariant matchups.Length == seeds.Length / 2\n            invariant forall k :: 0 <= k < i ==> \n                matchups[k].0 in seeds[..] && matchups[k].1 in seeds[..]\n            invariant j == 2 * i\n        {\n            matchups[i] := (seeds[j], seeds[seeds.Length - j - 1]);\n            i := i + 1;\n            j := j + 2;\n        }\n}\n}",
            "parents": [
                "node_279"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 17\n        var j := 0;\n        while i < seeds.Length / 2\n            invariant 0 <= i <= seeds.Length / 2\n            invariant matchups.Length == seeds.Length / 2\n            invariant forall k :: 0 <= k < i ==> \n                matchups[k].0 in seeds[..] && matchups[k].1 in seeds[..]\n            invariant j == 2 * i\n        {\n            matchups[i] := (seeds[j], seeds[seeds.Length - j - 1]);\n            i := i + 1;\n            j := j + 2;\n        }\n// END DAFNY\n```"
        },
        {
            "id": "node_298",
            "type": "program",
            "content": "method QuickSort(a: array<int>) \n    requires a != null\n    modifies a\n    ensures forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n    ensures multiset(a[..]) == multiset(old(a[..]))\n{\n    QuickSortHelper(a, 0, a.Length - 1);\n}\nmethod QuickSortHelper(a: array<int>, low: int, high: int)\n    requires a != null && 0 <= low <= high + 1 <= a.Length\n    modifies a\n    ensures forall i, j :: low <= i < j <= high ==> a[i] <= a[j]\n    ensures multiset(a[low..high+1]) == multiset(old(a[low..high+1]))\n{\n    if low < high {\n        var pivotIndex := Partition(a, low, high);\n        QuickSortHelper(a, low, pivotIndex - 1);\n        QuickSortHelper(a, pivotIndex + 1, high);\n    }\n}\nmethod Partition(a: array<int>, low: int, high: int) returns (pivotIndex: int)\n    requires a != null && 0 <= low <= high < a.Length\n    modifies a\n    ensures low <= pivotIndex <= high\n    ensures forall i :: low <= i < pivotIndex ==> a[i] <= a[pivotIndex]\n    ensures forall i :: pivotIndex < i <= high ==> a[pivotIndex] <= a[i]\n    ensures multiset(a[low..high+1]) == multiset(old(a[low..high+1]))\n{\n    var pivot := a[high];\n    var i := low - 1;\n    for j := low to high - 1\n        invariant low <= j <= high\n        invariant low - 1 <= i < j\n        invariant forall k :: low <= k <= i ==> a[k] <= pivot\n        invariant forall k :: i < k < j ==> a[k] > pivot\n    {\n        if a[j] <= pivot {\n            i := i + 1;\n            var temp := a[i];\n            a[i] := a[j];\n            a[j] := temp;\n        }\n    }\n}",
            "parents": [
                "node_111"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 31\n    for j := low to high - 1\n        invariant low <= j <= high\n        invariant low - 1 <= i < j\n        invariant forall k :: low <= k <= i ==> a[k] <= pivot\n        invariant forall k :: i < k < j ==> a[k] > pivot\n    {\n        if a[j] <= pivot {\n            i := i + 1;\n            var temp := a[i];\n            a[i] := a[j];\n            a[j] := temp;\n        }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_299",
            "type": "program",
            "content": "class Employee {\n    var hoursWorked: int;\n    var payRate: int;\n    constructor(hoursWorked: int, payRate: int)\n        ensures this.hoursWorked == hoursWorked && this.payRate == payRate\n    {\n        this.hoursWorked := hoursWorked;\n        this.payRate := payRate;\n    }\nmethod CalculateSalaryWithOvertime() returns (salary: int)\n    ensures salary >= hoursWorked * payRate\n    ensures salary == hoursWorked * payRate + (if hoursWorked > 40 then (hoursWorked - 40) * payRate / 2 else 0)\n{\n    var regularHours := if hoursWorked > 40 then 40 else hoursWorked;\n    var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n    var overtimePayRate := payRate * 3 / 2;\n    salary := 0;\n    var i := 0;\n    while i < regularHours\n        invariant 0 <= i <= regularHours\n        invariant salary == i * payRate\n    {\n        salary := salary + payRate;\n        i := i + 1;\n    }\n    i := 0;\n    while i < overtimeHours\n        invariant 0 <= i <= overtimeHours\n        invariant salary == regularHours * payRate + i * overtimePayRate\n        invariant salary == (regularHours + i) * payRate + i * payRate / 2\n    {\n        salary := salary + overtimePayRate;\n        i := i + 1;\n    }\n}\n}",
            "parents": [
                "node_280"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 10\nmethod CalculateSalaryWithOvertime() returns (salary: int)\n    ensures salary >= hoursWorked * payRate\n    ensures salary == hoursWorked * payRate + (if hoursWorked > 40 then (hoursWorked - 40) * payRate / 2 else 0)\n{\n    var regularHours := if hoursWorked > 40 then 40 else hoursWorked;\n    var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n    var overtimePayRate := payRate * 3 / 2;\n    salary := 0;\n    var i := 0;\n    while i < regularHours\n        invariant 0 <= i <= regularHours\n        invariant salary == i * payRate\n    {\n        salary := salary + payRate;\n        i := i + 1;\n    }\n    i := 0;\n    while i < overtimeHours\n        invariant 0 <= i <= overtimeHours\n        invariant salary == regularHours * payRate + i * overtimePayRate\n        invariant salary == (regularHours + i) * payRate + i * payRate / 2\n    {\n        salary := salary + overtimePayRate;\n        i := i + 1;\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_300",
            "type": "program",
            "content": "method Median(a: array<int>) returns (median: int)\n    requires a != null && a.Length > 0\n    ensures 0 <= median < a.Length\n    ensures forall i: int :: 0 <= i < a.Length ==> a[median] <= a[i] || a[median] >= a[i]\n{\n    var n := a.Length;\n    var sorted := new int[n];\n    // Copy the array\n    for i := 0 to n - 1\n        invariant 0 <= i <= n\n        invariant forall j: int :: 0 <= j < i ==> sorted[j] == a[j]\n    {\n        sorted[i] := a[i];\n    }\n    // Sort the array (simple insertion sort for demonstration)\n    for i := 1 to n - 1\n        invariant 1 <= i <= n\n        invariant forall j: int, k: int :: 0 <= j < k < i ==> sorted[j] <= sorted[k]\n    {\n        var key := sorted[i];\n        var j := i - 1;\n        while j >= 0 && sorted[j] > key\n            invariant -1 <= j < i\n            invariant forall k: int :: 0 <= k <= j ==> sorted[k] <= key\n            invariant forall k: int :: j + 1 <= k < i ==> sorted[k] >= key\n        {\n            sorted[j + 1] := sorted[j];\n            j := j - 1;\n        }\n        sorted[j + 1] := key;\n    }\n    // Find the median\n    if n % 2 == 1 {\n        median := sorted[n / 2];\n    } else {\n        median := sorted[n / 2 - 1]; // Choose the lower median for even length\n    }\n}",
            "parents": [
                "node_238"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 19\n    {\n        var key := sorted[i];\n        var j := i - 1;\n        while j >= 0 && sorted[j] > key\n            invariant -1 <= j < i\n            invariant forall k: int :: 0 <= k <= j ==> sorted[k] <= key\n            invariant forall k: int :: j + 1 <= k < i ==> sorted[k] >= key\n        {\n            sorted[j + 1] := sorted[j];\n            j := j - 1;\n        }\n        sorted[j + 1] := key;\n    }\n    // Find the median\n    if n % 2 == 1 {\n        median := sorted[n / 2];\n    } else {\n        median := sorted[n / 2 - 1]; // Choose the lower median for even length\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_301",
            "type": "program",
            "content": "method WaysToMakeChange(amount: int, coins: seq<int>) returns (ways: int)\n    requires amount >= 0 && forall coin :: coin in coins ==> coin > 0\n    ensures ways >= 0\n{\n    var dp := new int[amount + 1];\n    dp[0] := 1;\n    // Loop invariant: \n    // 0 <= i <= |coins| \n    // && forall j :: 0 <= j <= amount ==> dp[j] >= 0\n    // && dp[j] represents the number of ways to make change for amount j using the first i coins\n    for i := 0 to |coins| {\n        var coin := coins[i];\n        // Loop invariant:\n        // 0 <= j <= amount\n        // && dp[j] represents the number of ways to make change for amount j using the first i coins\n        for j := coin to amount {\n            dp[j] := dp[j] + dp[j - coin];\n        }\n    }\n    ways := dp[amount];\n}",
            "parents": [
                "idea_69"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\nmethod WaysToMakeChange(amount: int, coins: seq<int>) returns (ways: int)\n    requires amount >= 0 && forall coin :: coin in coins ==> coin > 0\n    ensures ways >= 0\n{\n    var dp := new int[amount + 1];\n    dp[0] := 1;\n\n    // Loop invariant: \n    // 0 <= i <= |coins| \n    // && forall j :: 0 <= j <= amount ==> dp[j] >= 0\n    // && dp[j] represents the number of ways to make change for amount j using the first i coins\n    for i := 0 to |coins| {\n        var coin := coins[i];\n        // Loop invariant:\n        // 0 <= j <= amount\n        // && dp[j] represents the number of ways to make change for amount j using the first i coins\n        for j := coin to amount {\n            dp[j] := dp[j] + dp[j - coin];\n        }\n    }\n    ways := dp[amount];\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_302",
            "type": "program",
            "content": "class Matrix2x2 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    constructor(a: int, b: int, c: int, d: int)\n        ensures this.a == a && this.b == b && this.c == c && this.d == d\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n    }\n    method Determinant() returns (det: int)\n        ensures det == a * d - b * c\n    {\n        det := a * d - b * c;\n    }\nmethod MultiplyByScalar(scalar: int) returns (result: Matrix2x2)\n    ensures result.a == this.a * scalar\n    ensures result.b == this.b * scalar\n    ensures result.c == this.c * scalar\n    ensures result.d == this.d * scalar\n{\n    result := new Matrix2x2(this.a * scalar, this.b * scalar, this.c * scalar, this.d * scalar);\n}\nmethod Transpose() returns (result: Matrix2x2)\n    ensures result.a == this.a\n    ensures result.b == this.c\n    ensures result.c == this.b\n    ensures result.d == this.d\n{\n    result := new Matrix2x2(this.a, this.c, this.b, this.d);\n}\n}",
            "parents": [
                "node_190"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 19\nmethod MultiplyByScalar(scalar: int) returns (result: Matrix2x2)\n    ensures result.a == this.a * scalar\n    ensures result.b == this.b * scalar\n    ensures result.c == this.c * scalar\n    ensures result.d == this.d * scalar\n{\n    result := new Matrix2x2(this.a * scalar, this.b * scalar, this.c * scalar, this.d * scalar);\n}\n\nmethod Transpose() returns (result: Matrix2x2)\n    ensures result.a == this.a\n    ensures result.b == this.c\n    ensures result.c == this.b\n    ensures result.d == this.d\n{\n    result := new Matrix2x2(this.a, this.c, this.b, this.d);\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_303",
            "type": "program",
            "content": "class Matrix2x2 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    constructor(a: int, b: int, c: int, d: int)\n        ensures this.a == a && this.b == b && this.c == c && this.d == d\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n    }\n    method Transpose() returns (transposed: Matrix2x2)\n        ensures transposed.a == a && transposed.b == c && transposed.c == b && transposed.d == d\n    {\n        transposed := new Matrix2x2(a, c, b, d);\n    }\nmethod Multiply(other: Matrix2x2) returns (product: Matrix2x2)\n    ensures product.a == a * other.a + b * other.c\n    ensures product.b == a * other.b + b * other.d\n    ensures product.c == c * other.a + d * other.c\n    ensures product.d == c * other.b + d * other.d\n{\n    product := new Matrix2x2(\n        a * other.a + b * other.c,\n        a * other.b + b * other.d,\n        c * other.a + d * other.c,\n        c * other.b + d * other.d\n    );\n}\nmethod Determinant() returns (det: int)\n    ensures det == a * d - b * c\n{\n    det := a * d - b * c;\n}\n}",
            "parents": [
                "node_135"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 19\nmethod Multiply(other: Matrix2x2) returns (product: Matrix2x2)\n    ensures product.a == a * other.a + b * other.c\n    ensures product.b == a * other.b + b * other.d\n    ensures product.c == c * other.a + d * other.c\n    ensures product.d == c * other.b + d * other.d\n{\n    product := new Matrix2x2(\n        a * other.a + b * other.c,\n        a * other.b + b * other.d,\n        c * other.a + d * other.c,\n        c * other.b + d * other.d\n    );\n}\n\nmethod Determinant() returns (det: int)\n    ensures det == a * d - b * c\n{\n    det := a * d - b * c;\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_304",
            "type": "program",
            "content": "class Geometry {\n    method IsPointInsideRectangle(px: int, py: int, rx: int, ry: int, rw: int, rh: int) returns (inside: bool)\n        requires rw >= 0 && rh >= 0\n        ensures inside == ((px >= rx) && (px <= rx + rw) && (py >= ry) && (py <= ry + rh))\n    {\n        inside := (px >= rx) && (px <= rx + rw) && (py >= ry) && (py <= ry + rh);\n    }\n    method DoRectanglesOverlap(r1x: int, r1y: int, r1w: int, r1h: int, r2x: int, r2y: int, r2w: int, r2h: int) returns (overlap: bool)\n        requires r1w >= 0 && r1h >= 0 && r2w >= 0 && r2h >= 0\n        ensures overlap == ((r1x < r2x + r2w) && (r1x + r1w > r2x) && (r1y < r2y + r2h) && (r1y + r1h > r2y))\n    {\n        overlap := (r1x < r2x + r2w) && (r1x + r1w > r2x) && (r1y < r2y + r2h) && (r1y + r1h > r2y);\n    }\n    method CalculateRectangleArea(rx: int, ry: int, rw: int, rh: int) returns (area: int)\n        requires rw >= 0 && rh >= 0\n        ensures area == rw * rh\n    {\n        var w := rw;\n        var h := rh;\n        area := 0;\n        while h > 0\n            invariant 0 <= h <= rh\n            invariant area == (rh - h) * rw\n        {\n            area := area + w;\n            h := h - 1;\n        }\n    }\n}",
            "parents": [
                "node_209"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 14\n    method CalculateRectangleArea(rx: int, ry: int, rw: int, rh: int) returns (area: int)\n        requires rw >= 0 && rh >= 0\n        ensures area == rw * rh\n    {\n        var w := rw;\n        var h := rh;\n        area := 0;\n        while h > 0\n            invariant 0 <= h <= rh\n            invariant area == (rh - h) * rw\n        {\n            area := area + w;\n            h := h - 1;\n        }\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_305",
            "type": "program",
            "content": "module PalindromeChecker {\n  method IsPalindrome(s: string) returns (isPalin: bool)\n    ensures isPalin <==> (forall i :: 0 <= i < |s| / 2 ==> s[i] == s[|s| - i - 1])\n  {\n    var n := |s|;\n    isPalin := true;\n    for i := 0 to n / 2 - 1\n      invariant 0 <= i <= n / 2\n      invariant isPalin ==> (forall j :: 0 <= j < i ==> s[j] == s[n - j - 1])\n    {\n      if s[i] != s[n - i - 1] {\n        isPalin := false;\n        break;\n      }\n    }\n}\n}",
            "parents": [
                "node_145"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 7\n    for i := 0 to n / 2 - 1\n      invariant 0 <= i <= n / 2\n      invariant isPalin ==> (forall j :: 0 <= j < i ==> s[j] == s[n - j - 1])\n    {\n      if s[i] != s[n - i - 1] {\n        isPalin := false;\n        break;\n      }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_306",
            "type": "program",
            "content": "class VotingSystem {\n    var votes: array<int>;\n    constructor (numCandidates: int)\n        requires numCandidates > 0\n    {\n        votes := new int[numCandidates];\n    }\n    method Vote(candidate: int)\n        requires 0 <= candidate < votes.Length\n        modifies votes\n        ensures votes[candidate] == old(votes[candidate]) + 1\n    {\n        votes[candidate] := votes[candidate] + 1;\n    }\n    method GetWinner() returns (winner: int, isTie: bool)\n        requires votes.Length > 0\n        ensures 0 <= winner < votes.Length\n        ensures forall i: int :: 0 <= i < votes.Length ==> votes[winner] >= votes[i]\n        ensures isTie <==> (exists i: int :: 0 <= i < votes.Length && i != winner && votes[i] == votes[winner])\n    {\n        var maxVotes := votes[0];\n        winner := 0;\n        isTie := false;\n        for i := 1 to votes.Length - 1\n            invariant 0 <= winner < votes.Length\n            invariant 0 <= i <= votes.Length\n            invariant forall j: int :: 0 <= j < i ==> votes[winner] >= votes[j]\n            invariant isTie <==> (exists j: int :: 0 <= j < i && j != winner && votes[j] == maxVotes)\n        {\n            if votes[i] > maxVotes {\n                maxVotes := votes[i];\n                winner := i;\n                isTie := false;\n            } else if votes[i] == maxVotes && i != winner {\n                isTie := true;\n            }\n        }\n    }\n}",
            "parents": [
                "node_229"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 15\n    method GetWinner() returns (winner: int, isTie: bool)\n        requires votes.Length > 0\n        ensures 0 <= winner < votes.Length\n        ensures forall i: int :: 0 <= i < votes.Length ==> votes[winner] >= votes[i]\n        ensures isTie <==> (exists i: int :: 0 <= i < votes.Length && i != winner && votes[i] == votes[winner])\n    {\n        var maxVotes := votes[0];\n        winner := 0;\n        isTie := false;\n        for i := 1 to votes.Length - 1\n            invariant 0 <= winner < votes.Length\n            invariant 0 <= i <= votes.Length\n            invariant forall j: int :: 0 <= j < i ==> votes[winner] >= votes[j]\n            invariant isTie <==> (exists j: int :: 0 <= j < i && j != winner && votes[j] == maxVotes)\n        {\n            if votes[i] > maxVotes {\n                maxVotes := votes[i];\n                winner := i;\n                isTie := false;\n            } else if votes[i] == maxVotes && i != winner {\n                isTie := true;\n            }\n        }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_307",
            "type": "program",
            "content": "method Catalan(n: nat) returns (catalan: nat)\n    requires n >= 0\n    ensures catalan == if n == 0 then 1 else 0\n    decreases n\n{\n    if n == 0 {\n        catalan := 1;\n    } else {\n        catalan := 0;\n    }\n}",
            "parents": [
                "idea_21"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\n\nmethod Catalan(n: nat) returns (catalan: nat)\n    requires n >= 0\n    ensures catalan == if n == 0 then 1 else 0\n    decreases n\n{\n    if n == 0 {\n        catalan := 1;\n    } else {\n        catalan := 0;\n    }\n}\n\n// END DAFNY\n```\n\nThis program defines a method `Catalan` that calculates the nth Catalan number. The method currently only handles the base case where `n` is 0, returning 1, which is the first Catalan number. The recursive case is not yet implemented, but the structure is set up to ensure correctness and termination."
        },
        {
            "id": "node_308",
            "type": "program",
            "content": "method GaussianElimination(a: array2<int>, b: array<int>) returns (x: array<int>)\n    requires a.Length0 == a.Length1 && a.Length0 == b.Length\n    ensures forall i :: 0 <= i < a.Length0 ==> a[i, i] * x[i] == b[i]\n{\n    var n := a.Length0;\n    x := new int[n];\n    // Forward elimination\n    for k := 0 to n - 1\n        invariant 0 <= k <= n\n        invariant forall i, j :: 0 <= i < k && 0 <= j < n ==> a[i, j] == 0\n    {\n        // Find the pivot\n        var max := k;\n        for i := k + 1 to n - 1\n            invariant k <= max < n\n            invariant forall j :: k <= j < i ==> a[max, k] >= a[j, k]\n        {\n            if a[i, k] > a[max, k] {\n                max := i;\n            }\n        }\n        // Swap rows\n        for j := 0 to n - 1\n            invariant 0 <= j <= n\n            invariant forall i :: 0 <= i < j ==> a[k, i] == a[max, i] && a[max, i] == a[k, i]\n        {\n            var temp := a[k, j];\n            a[k, j] := a[max, j];\n            a[max, j] := temp;\n        }\n        var tempB := b[k];\n        b[k] := b[max];\n        b[max] := tempB;\n        // Eliminate column\n        // Eliminate column\n        for i := k + 1 to n - 1\n            invariant k < i <= n\n            invariant forall j :: 0 <= j < n ==> (j < k ==> a[i, j] == 0) && (j >= k ==> a[i, j] == a[i, j])\n            invariant b[i] == b[i] - (a[i, k] / a[k, k]) * b[k]\n            invariant forall j :: k <= j < n ==> a[i, j] == a[i, j] - (a[i, k] / a[k, k]) * a[k, j]\n            invariant a[i, k] == 0\n        {\n            var factor := a[i, k] / a[k, k];\n            b[i] := b[i] - factor * b[k];\n            for j := k to n - 1\n                invariant k <= j <= n\n                invariant forall l :: k <= l < j ==> a[i, l] == a[i, l] - factor * a[k, l]\n                invariant a[i, j] == a[i, j] - factor * a[k, j]\n            {\n                a[i, j] := a[i, j] - factor * a[k, j];\n            }\n            a[i, k] := 0; // Explicitly set the eliminated element to zero\n        }\n}\n}",
            "parents": [
                "node_295"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 35\n        // Eliminate column\n        for i := k + 1 to n - 1\n            invariant k < i <= n\n            invariant forall j :: 0 <= j < n ==> (j < k ==> a[i, j] == 0) && (j >= k ==> a[i, j] == a[i, j])\n            invariant b[i] == b[i] - (a[i, k] / a[k, k]) * b[k]\n            invariant forall j :: k <= j < n ==> a[i, j] == a[i, j] - (a[i, k] / a[k, k]) * a[k, j]\n            invariant a[i, k] == 0\n        {\n            var factor := a[i, k] / a[k, k];\n            b[i] := b[i] - factor * b[k];\n            for j := k to n - 1\n                invariant k <= j <= n\n                invariant forall l :: k <= l < j ==> a[i, l] == a[i, l] - factor * a[k, l]\n                invariant a[i, j] == a[i, j] - factor * a[k, j]\n            {\n                a[i, j] := a[i, j] - factor * a[k, j];\n            }\n            a[i, k] := 0; // Explicitly set the eliminated element to zero\n        }\n// END DAFNY\n```"
        },
        {
            "id": "node_309",
            "type": "program",
            "content": "class Matrix3x3 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    var e: int;\n    var f: int;\n    var g: int;\n    var h: int;\n    var i: int;\n    constructor(a: int, b: int, c: int, d: int, e: int, f: int, g: int, h: int, i: int)\n        ensures this.a == a && this.b == b && this.c == c\n        ensures this.d == d && this.e == e && this.f == f\n        ensures this.g == g && this.h == h && this.i == i\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n        this.e := e;\n        this.f := f;\n        this.g := g;\n        this.h := h;\n        this.i := i;\n    }\n    method Transpose() returns (transposed: Matrix3x3)\n        ensures transposed.a == a && transposed.b == d && transposed.c == g\n        ensures transposed.d == b && transposed.e == e && transposed.f == h\n        ensures transposed.g == c && transposed.h == f && transposed.i == i\n    {\n        transposed := new Matrix3x3(a, d, g, b, e, h, c, f, i);\n    }\nmethod Multiply(other: Matrix3x3) returns (product: Matrix3x3)\n    ensures product.a == a * other.a + b * other.d + c * other.g\n    ensures product.b == a * other.b + b * other.e + c * other.h\n    ensures product.c == a * other.c + b * other.f + c * other.i\n    ensures product.d == d * other.a + e * other.d + f * other.g\n    ensures product.e == d * other.b + e * other.e + f * other.h\n    ensures product.f == d * other.c + e * other.f + f * other.i\n    ensures product.g == g * other.a + h * other.d + i * other.g\n    ensures product.h == g * other.b + h * other.e + i * other.h\n    ensures product.i == g * other.c + h * other.f + i * other.i\n{\n    var p_a := a * other.a + b * other.d + c * other.g;\n    var p_b := a * other.b + b * other.e + c * other.h;\n    var p_c := a * other.c + b * other.f + c * other.i;\n    var p_d := d * other.a + e * other.d + f * other.g;\n    var p_e := d * other.b + e * other.e + f * other.h;\n    var p_f := d * other.c + e * other.f + f * other.i;\n    var p_g := g * other.a + h * other.d + i * other.g;\n    var p_h := g * other.b + h * other.e + i * other.h;\n    var p_i := g * other.c + h * other.f + i * other.i;\n    product := new Matrix3x3(p_a, p_b, p_c, p_d, p_e, p_f, p_g, p_h, p_i);\n}\n}",
            "parents": [
                "node_139"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 33\nmethod Multiply(other: Matrix3x3) returns (product: Matrix3x3)\n    ensures product.a == a * other.a + b * other.d + c * other.g\n    ensures product.b == a * other.b + b * other.e + c * other.h\n    ensures product.c == a * other.c + b * other.f + c * other.i\n    ensures product.d == d * other.a + e * other.d + f * other.g\n    ensures product.e == d * other.b + e * other.e + f * other.h\n    ensures product.f == d * other.c + e * other.f + f * other.i\n    ensures product.g == g * other.a + h * other.d + i * other.g\n    ensures product.h == g * other.b + h * other.e + i * other.h\n    ensures product.i == g * other.c + h * other.f + i * other.i\n{\n    var p_a := a * other.a + b * other.d + c * other.g;\n    var p_b := a * other.b + b * other.e + c * other.h;\n    var p_c := a * other.c + b * other.f + c * other.i;\n    var p_d := d * other.a + e * other.d + f * other.g;\n    var p_e := d * other.b + e * other.e + f * other.h;\n    var p_f := d * other.c + e * other.f + f * other.i;\n    var p_g := g * other.a + h * other.d + i * other.g;\n    var p_h := g * other.b + h * other.e + i * other.h;\n    var p_i := g * other.c + h * other.f + i * other.i;\n\n    product := new Matrix3x3(p_a, p_b, p_c, p_d, p_e, p_f, p_g, p_h, p_i);\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_310",
            "type": "program",
            "content": "class Recipe {\n    var name: string;\n    var ingredients: seq<string>;\n    constructor(name: string, ingredients: seq<string>)\n        ensures this.name == name\n        ensures this.ingredients == ingredients\n    {\n        this.name := name;\n        this.ingredients := ingredients;\n    }\nmethod GetIngredientCount() returns (count: nat)\n    ensures count == |ingredients|\n{\n    count := |ingredients|;\n}\n}",
            "parents": [
                "node_125"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 11\nmethod GetIngredientCount() returns (count: nat)\n    ensures count == |ingredients|\n{\n    count := |ingredients|;\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_311",
            "type": "program",
            "content": "method EuclideanGCD(a: nat, b: nat) returns (gcd: nat)\n    requires a > 0 && b > 0\n    ensures gcd > 0\n    ensures a % gcd == 0 && b % gcd == 0\n    ensures forall d: nat :: d > 0 && a % d == 0 && b % d == 0 ==> gcd >= d\n{\n    var x := a;\n    var y := b;\n    while y != 0\n        invariant x > 0\n        invariant y >= 0\n        invariant x % gcd == 0 && b % gcd == 0\n        decreases y\n    {\n        var temp := y;\n        y := x % y;\n        x := temp;\n    }\n    gcd := x;\n}",
            "parents": [
                "idea_0"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\n\nmethod EuclideanGCD(a: nat, b: nat) returns (gcd: nat)\n    requires a > 0 && b > 0\n    ensures gcd > 0\n    ensures a % gcd == 0 && b % gcd == 0\n    ensures forall d: nat :: d > 0 && a % d == 0 && b % d == 0 ==> gcd >= d\n{\n    var x := a;\n    var y := b;\n    while y != 0\n        invariant x > 0\n        invariant y >= 0\n        invariant x % gcd == 0 && b % gcd == 0\n        decreases y\n    {\n        var temp := y;\n        y := x % y;\n        x := temp;\n    }\n    gcd := x;\n}\n\n// END DAFNY\n```"
        },
        {
            "id": "node_312",
            "type": "program",
            "content": "method QuickSort(a: array<int>) \n    requires a != null\n    modifies a\n    ensures forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n    ensures multiset(a[..]) == multiset(old(a[..]))\n{\n    QuickSortHelper(a, 0, a.Length - 1);\n}\nmethod QuickSortHelper(a: array<int>, low: int, high: int)\n    requires a != null && 0 <= low <= high + 1 <= a.Length\n    modifies a\n    ensures forall i, j :: low <= i < j <= high ==> a[i] <= a[j]\n    ensures multiset(a[low..high+1]) == multiset(old(a[low..high+1]))\n{\n    if low < high {\n        var pivotIndex := Partition(a, low, high);\n        QuickSortHelper(a, low, pivotIndex - 1);\n        QuickSortHelper(a, pivotIndex + 1, high);\n    }\n}\nmethod Partition(a: array<int>, low: int, high: int) returns (pivotIndex: int)\n    requires a != null && 0 <= low <= high < a.Length\n    modifies a\n    ensures low <= pivotIndex <= high\n    ensures forall i :: low <= i < pivotIndex ==> a[i] <= a[pivotIndex]\n    ensures forall i :: pivotIndex < i <= high ==> a[pivotIndex] <= a[i]\n    ensures multiset(a[low..high+1]) == multiset(old(a[low..high+1]))\n{\n    var pivot := a[high];\n    var i := low - 1;\n    for j := low to high - 1\n        invariant low <= j <= high\n        invariant low - 1 <= i < j\n        invariant forall k :: low <= k <= i ==> a[k] <= pivot\n        invariant forall k :: i < k < j ==> a[k] > pivot\n        invariant multiset(a[low..j]) == multiset(old(a[low..j]))\n    {\n}\n}",
            "parents": [
                "node_247"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 31\n    for j := low to high - 1\n        invariant low <= j <= high\n        invariant low - 1 <= i < j\n        invariant forall k :: low <= k <= i ==> a[k] <= pivot\n        invariant forall k :: i < k < j ==> a[k] > pivot\n        invariant multiset(a[low..j]) == multiset(old(a[low..j]))\n    {\n// END DAFNY\n```"
        },
        {
            "id": "node_313",
            "type": "program",
            "content": "class Point {\n    var x: int;\n    var y: int;\n    constructor(x: int, y: int)\n        ensures this.x == x && this.y == y\n    {\n        this.x := x;\n        this.y := y;\n    }\nmethod CrossProductWithLoop(p1: Point, p2: Point, p3: Point) returns (result: int)\n    ensures result == (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x)\n{\n    var dx1 := p2.x - p1.x;\n    var dy1 := p2.y - p1.y;\n    var dx2 := p3.x - p1.x;\n    var dy2 := p3.y - p1.y;\n    result := 0;\n    var i := 0;\n    while i < 2\n        invariant 0 <= i <= 2\n        invariant result == i * (dx1 * dy2 - dy1 * dx2)\n    {\n        result := dx1 * dy2 - dy1 * dx2;\n        i := i + 1;\n    }\n}\n}",
            "parents": [
                "node_126"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 10\nmethod CrossProductWithLoop(p1: Point, p2: Point, p3: Point) returns (result: int)\n    ensures result == (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x)\n{\n    var dx1 := p2.x - p1.x;\n    var dy1 := p2.y - p1.y;\n    var dx2 := p3.x - p1.x;\n    var dy2 := p3.y - p1.y;\n    result := 0;\n    var i := 0;\n    while i < 2\n        invariant 0 <= i <= 2\n        invariant result == i * (dx1 * dy2 - dy1 * dx2)\n    {\n        result := dx1 * dy2 - dy1 * dx2;\n        i := i + 1;\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_314",
            "type": "program",
            "content": "method GaussianElimination(a: array2<int>, b: array<int>) returns (x: array<int>)\n    requires a.Length0 == a.Length1 && a.Length0 == b.Length\n    ensures forall i :: 0 <= i < a.Length0 ==> a[i, i] * x[i] == b[i]\n{\n    var n := a.Length0;\n    x := new int[n];\n    // Forward elimination\n    for k := 0 to n - 1\n        invariant 0 <= k <= n\n        invariant forall i, j :: 0 <= i < k && 0 <= j < n ==> a[i, j] == 0\n    {\n        // Find the pivot\n        var max := k;\n        for i := k + 1 to n - 1\n            invariant k <= max < n\n            invariant forall j :: k <= j < i ==> a[max, k] >= a[j, k]\n        {\n            if a[i, k] > a[max, k] {\n                max := i;\n            }\n        }\n        // Swap rows\n        for j := 0 to n - 1\n            invariant 0 <= j <= n\n            invariant forall i :: 0 <= i < j ==> a[k, i] == a[max, i] && a[max, i] == a[k, i]\n        {\n            var temp := a[k, j];\n            a[k, j] := a[max, j];\n            a[max, j] := temp;\n        }\n        var tempB := b[k];\n        b[k] := b[max];\n        b[max] := tempB;\n        // Eliminate column\n        for i := k + 1 to n - 1\n            invariant k < i <= n\n            invariant forall j :: 0 <= j < n ==> (j < k ==> a[i, j] == 0) && (j >= k ==> a[i, j] == a[i, j])\n            invariant b[i] == b[i] - (a[i, k] / a[k, k]) * b[k]\n        {\n            var factor := a[i, k] / a[k, k];\n            b[i] := b[i] - factor * b[k];\n            for j := k to n - 1\n                invariant k <= j <= n\n                invariant forall l :: k <= l < j ==> a[i, l] == a[i, l] - factor * a[k, l]\n                invariant a[i, j] == a[i, j] - factor * a[k, j]\n            {\n                a[i, j] := a[i, j] - factor * a[k, j];\n            }\n        }\n}\n}",
            "parents": [
                "node_264"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 35\n        for i := k + 1 to n - 1\n            invariant k < i <= n\n            invariant forall j :: 0 <= j < n ==> (j < k ==> a[i, j] == 0) && (j >= k ==> a[i, j] == a[i, j])\n            invariant b[i] == b[i] - (a[i, k] / a[k, k]) * b[k]\n        {\n            var factor := a[i, k] / a[k, k];\n            b[i] := b[i] - factor * b[k];\n            for j := k to n - 1\n                invariant k <= j <= n\n                invariant forall l :: k <= l < j ==> a[i, l] == a[i, l] - factor * a[k, l]\n                invariant a[i, j] == a[i, j] - factor * a[k, j]\n            {\n                a[i, j] := a[i, j] - factor * a[k, j];\n            }\n        }\n// END DAFNY\n```"
        },
        {
            "id": "node_315",
            "type": "program",
            "content": "class VotingSystem {\n    var votes: array<int>;\n    constructor(n: int)\n        requires n > 0\n        ensures votes.Length == n\n        ensures forall i :: 0 <= i < n ==> votes[i] == 0\n    {\n        votes := new int[n];\n    }\n    method CastVote(candidate: int)\n        requires 0 <= candidate < votes.Length\n        modifies votes\n        ensures votes[candidate] == old(votes[candidate]) + 1\n        ensures forall i :: 0 <= i < votes.Length && i != candidate ==> votes[i] == old(votes[i])\n    {\n        votes[candidate] := votes[candidate] + 1;\n    }\n}",
            "parents": [
                "node_220"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 10\n    method CastVote(candidate: int)\n        requires 0 <= candidate < votes.Length\n        modifies votes\n        ensures votes[candidate] == old(votes[candidate]) + 1\n        ensures forall i :: 0 <= i < votes.Length && i != candidate ==> votes[i] == old(votes[i])\n    {\n        votes[candidate] := votes[candidate] + 1;\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_316",
            "type": "program",
            "content": "class LoginSystem {\n    var username: string;\n    var password: string;\n    constructor(username: string, password: string)\n        ensures this.username == username && this.password == password\n    {\n        this.username := username;\n        this.password := password;\n    }\nmethod Authenticate(inputUsername: string, inputPassword: string) returns (isAuthenticated: bool)\n    ensures isAuthenticated == (inputUsername == username && inputPassword == password)\n{\n    var attempts: nat := 0;\n    while (attempts < 3)\n        invariant 0 <= attempts <= 3\n    {\n        if inputUsername == username && inputPassword == password {\n            isAuthenticated := true;\n            return;\n        }\n        attempts := attempts + 1;\n    }\n    isAuthenticated := false;\n}\n}",
            "parents": [
                "node_105"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 10\nmethod Authenticate(inputUsername: string, inputPassword: string) returns (isAuthenticated: bool)\n    ensures isAuthenticated == (inputUsername == username && inputPassword == password)\n{\n    var attempts: nat := 0;\n    while (attempts < 3)\n        invariant 0 <= attempts <= 3\n    {\n        if inputUsername == username && inputPassword == password {\n            isAuthenticated := true;\n            return;\n        }\n        attempts := attempts + 1;\n    }\n    isAuthenticated := false;\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_317",
            "type": "program",
            "content": "method QuickSort(a: array<int>) \n    requires a != null\n    modifies a\n    ensures forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n    ensures multiset(a[..]) == multiset(old(a[..]))\n{\n    QuickSortHelper(a, 0, a.Length - 1);\n}\nmethod QuickSortHelper(a: array<int>, low: int, high: int)\n    requires a != null && 0 <= low <= high + 1 <= a.Length\n    modifies a\n    ensures forall i, j :: low <= i < j <= high ==> a[i] <= a[j]\n    ensures multiset(a[low..high+1]) == multiset(old(a[low..high+1]))\n{\n    if low < high {\n        var pivotIndex := Partition(a, low, high);\n        QuickSortHelper(a, low, pivotIndex - 1);\n        QuickSortHelper(a, pivotIndex + 1, high);\n    }\n}\nmethod Partition(a: array<int>, low: int, high: int) returns (pivotIndex: int)\n    requires a != null && 0 <= low <= high < a.Length\n    modifies a\n    ensures low <= pivotIndex <= high\n    ensures forall i :: low <= i < pivotIndex ==> a[i] <= a[pivotIndex]\n    ensures forall i :: pivotIndex < i <= high ==> a[pivotIndex] <= a[i]\n    ensures multiset(a[low..high+1]) == multiset(old(a[low..high+1]))\n{\n    var pivot := a[high];\n    var i := low - 1;\n    for j := low to high - 1\n        invariant low <= j <= high\n        invariant low - 1 <= i < j\n        invariant forall k :: low <= k <= i ==> a[k] <= pivot\n        invariant forall k :: i < k < j ==> a[k] > pivot\n    {\n        if a[j] <= pivot {\n            i := i + 1;\n            var temp := a[i];\n            a[i] := a[j];\n            a[j] := temp;\n        }\n    }\n    a[i + 1], a[high] := a[high], a[i + 1];\n    return i + 1;\n}",
            "parents": [
                "node_298"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 44\n    a[i + 1], a[high] := a[high], a[i + 1];\n    return i + 1;\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_318",
            "type": "program",
            "content": "class LinearInequalitiesSolver {\n    method SolveSingleInequality(a: int, b: int, c: int) returns (solution: bool)\n        requires a != 0\n        ensures solution == (c >= b / a)\n    {\n        if a > 0 {\n            solution := c >= b / a;\n        } else {\n            solution := c <= b / a;\n        }\n    }\n    method VerifySolution(a: int, b: int, c: int, x: int) returns (isValid: bool)\n        requires a != 0\n        ensures isValid == (a * x + b <= c)\n    {\n        isValid := a * x + b <= c;\n    }\n    method SolveMultipleInequalities(a: seq<int>, b: seq<int>, c: seq<int>) returns (solutions: seq<bool>)\n        requires |a| == |b| && |b| == |c|\n        requires forall i :: 0 <= i < |a| ==> a[i] != 0\n        ensures |solutions| == |a|\n        ensures forall i :: 0 <= i < |a| ==> solutions[i] == (if a[i] > 0 then c[i] >= b[i] / a[i] else c[i] <= b[i] / a[i])\n    {\n        solutions := [];\n        var i := 0;\n        while i < |a|\n            invariant 0 <= i <= |a|\n            invariant |solutions| == i\n            invariant forall j :: 0 <= j < i ==> solutions[j] == (if a[j] > 0 then c[j] >= b[j] / a[j] else c[j] <= b[j] / a[j])\n        {\n            var currentSolution: bool;\n            if a[i] > 0 {\n                currentSolution := c[i] >= b[i] / a[i];\n            } else {\n                currentSolution := c[i] <= b[i] / a[i];\n            }\n            solutions := solutions + [currentSolution];\n            i := i + 1;\n        }\n    }\n}",
            "parents": [
                "node_266"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 18\n    method SolveMultipleInequalities(a: seq<int>, b: seq<int>, c: seq<int>) returns (solutions: seq<bool>)\n        requires |a| == |b| && |b| == |c|\n        requires forall i :: 0 <= i < |a| ==> a[i] != 0\n        ensures |solutions| == |a|\n        ensures forall i :: 0 <= i < |a| ==> solutions[i] == (if a[i] > 0 then c[i] >= b[i] / a[i] else c[i] <= b[i] / a[i])\n    {\n        solutions := [];\n        var i := 0;\n        while i < |a|\n            invariant 0 <= i <= |a|\n            invariant |solutions| == i\n            invariant forall j :: 0 <= j < i ==> solutions[j] == (if a[j] > 0 then c[j] >= b[j] / a[j] else c[j] <= b[j] / a[j])\n        {\n            var currentSolution: bool;\n            if a[i] > 0 {\n                currentSolution := c[i] >= b[i] / a[i];\n            } else {\n                currentSolution := c[i] <= b[i] / a[i];\n            }\n            solutions := solutions + [currentSolution];\n            i := i + 1;\n        }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_319",
            "type": "program",
            "content": "module GCDModule {\n    method EuclideanGCD(a: nat, b: nat) returns (gcd: nat)\n        requires a > 0 && b > 0\n        ensures gcd > 0\n        ensures a % gcd == 0 && b % gcd == 0\n        ensures forall d: nat :: d > 0 && a % d == 0 && b % d == 0 ==> gcd % d == 0\n    {\n        var x := a;\n        var y := b;\n        while y != 0\n            invariant x > 0\n            invariant y >= 0\n            invariant x % gcd == 0 && y % gcd == 0\n}\n}",
            "parents": [
                "node_221"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 13\n            invariant x % gcd == 0 && y % gcd == 0\n// END DAFNY\n```"
        },
        {
            "id": "node_320",
            "type": "program",
            "content": "method WaysToMakeChange(amount: int, coins: seq<int>) returns (ways: int)\n    requires amount >= 0 && forall coin :: coin in coins ==> coin > 0\n    ensures ways >= 0\n{\n    var dp := new int[amount + 1];\n    dp[0] := 1;\n    // Loop invariant: \n    // 0 <= i <= |coins| \n    // && forall j :: 0 <= j <= amount ==> dp[j] >= 0\n    // && dp[j] represents the number of ways to make change for amount j using the first i coins\n    for i := 0 to |coins| - 1 {\n}\n}",
            "parents": [
                "node_301"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 11\n    for i := 0 to |coins| - 1 {\n// END DAFNY\n```"
        },
        {
            "id": "node_321",
            "type": "program",
            "content": "class Matrix2x2 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    constructor(a: int, b: int, c: int, d: int)\n        ensures this.a == a && this.b == b && this.c == c && this.d == d\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n    }\n    method Determinant() returns (det: int)\n        ensures det == a * d - b * c\n    {\n        det := a * d - b * c;\n    }\nmethod MultiplyByScalar(scalar: int) returns (result: Matrix2x2)\n    ensures result.a == this.a * scalar\n    ensures result.b == this.b * scalar\n    ensures result.c == this.c * scalar\n    ensures result.d == this.d * scalar\n{\n    result := new Matrix2x2(this.a * scalar, this.b * scalar, this.c * scalar, this.d * scalar);\n}\nmethod Transpose() returns (result: Matrix2x2)\n    ensures result.a == this.a\n    ensures result.b == this.c\n    ensures result.c == this.b\n    ensures result.d == this.d\n{\n    result := new Matrix2x2(this.a, this.c, this.b, this.d);\n}\n}",
            "parents": [
                "node_101"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 19\nmethod MultiplyByScalar(scalar: int) returns (result: Matrix2x2)\n    ensures result.a == this.a * scalar\n    ensures result.b == this.b * scalar\n    ensures result.c == this.c * scalar\n    ensures result.d == this.d * scalar\n{\n    result := new Matrix2x2(this.a * scalar, this.b * scalar, this.c * scalar, this.d * scalar);\n}\n\nmethod Transpose() returns (result: Matrix2x2)\n    ensures result.a == this.a\n    ensures result.b == this.c\n    ensures result.c == this.b\n    ensures result.d == this.d\n{\n    result := new Matrix2x2(this.a, this.c, this.b, this.d);\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_322",
            "type": "program",
            "content": "// A simple program to transpose a 2x2 matrix with formal specifications\nmethod Transpose2x2(matrix: array2<nat>) returns (transposed: array2<nat>)\n    requires matrix.Length0 == 2 && matrix.Length1 == 2\n    ensures transposed.Length0 == 2 && transposed.Length1 == 2\n    ensures transposed[0, 0] == matrix[0, 0] && transposed[0, 1] == matrix[1, 0]\n    ensures transposed[1, 0] == matrix[0, 1] && transposed[1, 1] == matrix[1, 1]\n{\n    transposed := new nat[2, 2];\n    var i := 0;\n    while i < 2\n        invariant 0 <= i <= 2\n        invariant transposed.Length0 == 2 && transposed.Length1 == 2\n        invariant forall j: nat :: j < i ==> transposed[j, 0] == matrix[0, j] && transposed[j, 1] == matrix[1, j]\n    {\n        transposed[i, 0] := matrix[0, i];\n        transposed[i, 1] := matrix[1, i];\n        i := i + 1;\n    }\n}",
            "parents": [
                "idea_71"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\n\n// A simple program to transpose a 2x2 matrix with formal specifications\nmethod Transpose2x2(matrix: array2<nat>) returns (transposed: array2<nat>)\n    requires matrix.Length0 == 2 && matrix.Length1 == 2\n    ensures transposed.Length0 == 2 && transposed.Length1 == 2\n    ensures transposed[0, 0] == matrix[0, 0] && transposed[0, 1] == matrix[1, 0]\n    ensures transposed[1, 0] == matrix[0, 1] && transposed[1, 1] == matrix[1, 1]\n{\n    transposed := new nat[2, 2];\n    var i := 0;\n    while i < 2\n        invariant 0 <= i <= 2\n        invariant transposed.Length0 == 2 && transposed.Length1 == 2\n        invariant forall j: nat :: j < i ==> transposed[j, 0] == matrix[0, j] && transposed[j, 1] == matrix[1, j]\n    {\n        transposed[i, 0] := matrix[0, i];\n        transposed[i, 1] := matrix[1, i];\n        i := i + 1;\n    }\n}\n\n// END DAFNY\n```"
        },
        {
            "id": "node_323",
            "type": "program",
            "content": "class VotingSystem {\n    var votes: array<int>;\n    constructor(n: int)\n        requires n > 0\n        ensures votes.Length == n\n        ensures forall i :: 0 <= i < n ==> votes[i] == 0\n    {\n        votes := new int[n];\n    }\n    method CastVote(candidate: int)\n        requires 0 <= candidate < votes.Length\n        modifies votes\n        ensures votes[candidate] == old(votes[candidate]) + 1\n    {\n        votes[candidate] := votes[candidate] + 1;\n    }\n    method GetWinner() returns (winner: int)\n        requires votes.Length > 0\n        ensures 0 <= winner < votes.Length\n        ensures forall i :: 0 <= i < votes.Length ==> votes[winner] >= votes[i]\n    {\n        var maxVotes := votes[0];\n        winner := 0;\n        for i := 1 to votes.Length - 1\n            invariant 0 <= winner < votes.Length\n            invariant 0 <= i <= votes.Length\n            invariant forall j :: 0 <= j < i ==> votes[winner] >= votes[j]\n        {\n            if votes[i] > maxVotes {\n                maxVotes := votes[i];\n                winner := i;\n            }\n        }\n}\n}",
            "parents": [
                "node_133"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 24\n        for i := 1 to votes.Length - 1\n            invariant 0 <= winner < votes.Length\n            invariant 0 <= i <= votes.Length\n            invariant forall j :: 0 <= j < i ==> votes[winner] >= votes[j]\n        {\n            if votes[i] > maxVotes {\n                maxVotes := votes[i];\n                winner := i;\n            }\n        }\n// END DAFNY\n```"
        },
        {
            "id": "node_324",
            "type": "program",
            "content": "class PayrollSystem {\n    method CalculateSalary(hoursWorked: int, payRate: int) returns (salary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        ensures salary >= 0\n    {\n        salary := hoursWorked * payRate;\n    }\n    method CalculateOvertimeSalary(hoursWorked: int, payRate: int, overtimeRate: int) returns (totalSalary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        requires overtimeRate >= payRate\n        ensures totalSalary >= 0\n    {\n        var regularHours := if hoursWorked > 40 then 40 else hoursWorked;\n        var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n        var regularSalary := regularHours * payRate;\n        var overtimeSalary := overtimeHours * overtimeRate;\n        totalSalary := regularSalary + overtimeSalary;\n    }\n    method CalculateWeeklySalary(hoursWorked: int, payRate: int, overtimeRate: int) returns (weeklySalary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        requires overtimeRate >= payRate\n        ensures weeklySalary >= 0\n    {\n        var totalHours := hoursWorked;\n        var totalSalary := 0;\n        var regularHours := if hoursWorked > 40 then 40 else hoursWorked;\n        var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n        var regularSalary := regularHours * payRate;\n        var overtimeSalary := overtimeHours * overtimeRate;\n        weeklySalary := regularSalary + overtimeSalary;\n}\n}",
            "parents": [
                "node_237"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 29\n        var regularHours := if hoursWorked > 40 then 40 else hoursWorked;\n        var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n        var regularSalary := regularHours * payRate;\n        var overtimeSalary := overtimeHours * overtimeRate;\n        weeklySalary := regularSalary + overtimeSalary;\n// END DAFNY\n```"
        },
        {
            "id": "node_325",
            "type": "program",
            "content": "class VotingSystem {\n    var votes: array<int>;\n    constructor (numCandidates: int)\n        requires numCandidates > 0\n    {\n        votes := new int[numCandidates];\n    }\n    method Vote(candidate: int)\n        requires 0 <= candidate < votes.Length\n        modifies votes\n        ensures votes[candidate] == old(votes[candidate]) + 1\n    {\n        votes[candidate] := votes[candidate] + 1;\n    }\n    method GetWinner() returns (winner: int)\n        requires votes.Length > 0\n        ensures 0 <= winner < votes.Length\n        ensures forall i: int :: 0 <= i < votes.Length ==> votes[winner] >= votes[i]\n    {\n        var maxVotes := votes[0];\n        winner := 0;\n        for i := 1 to votes.Length - 1\n            invariant 0 <= winner < votes.Length\n            invariant 0 <= i <= votes.Length\n            invariant forall j: int :: 0 <= j < i ==> votes[winner] >= votes[j]\n            invariant maxVotes == votes[winner]\n        {\n            if votes[i] > maxVotes {\n                maxVotes := votes[i];\n                winner := i;\n            }\n        }\n    }\n}",
            "parents": [
                "node_229"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 15\n    method GetWinner() returns (winner: int)\n        requires votes.Length > 0\n        ensures 0 <= winner < votes.Length\n        ensures forall i: int :: 0 <= i < votes.Length ==> votes[winner] >= votes[i]\n    {\n        var maxVotes := votes[0];\n        winner := 0;\n        for i := 1 to votes.Length - 1\n            invariant 0 <= winner < votes.Length\n            invariant 0 <= i <= votes.Length\n            invariant forall j: int :: 0 <= j < i ==> votes[winner] >= votes[j]\n            invariant maxVotes == votes[winner]\n        {\n            if votes[i] > maxVotes {\n                maxVotes := votes[i];\n                winner := i;\n            }\n        }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_326",
            "type": "program",
            "content": "method QuickSort(a: array<int>) \n    requires a != null\n    modifies a\n    ensures forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n    ensures multiset(a[..]) == multiset(old(a[..]))\n{\n    QuickSortHelper(a, 0, a.Length - 1);\n}\nmethod QuickSortHelper(a: array<int>, low: int, high: int)\n    requires a != null && 0 <= low <= high + 1 <= a.Length\n    modifies a\n    ensures forall i, j :: low <= i < j <= high ==> a[i] <= a[j]\n    ensures multiset(a[low..high+1]) == multiset(old(a[low..high+1]))\n{\n    if low < high {\n        var pivotIndex := Partition(a, low, high);\n        QuickSortHelper(a, low, pivotIndex - 1);\n        QuickSortHelper(a, pivotIndex + 1, high);\n    }\n}\nmethod Partition(a: array<int>, low: int, high: int) returns (pivotIndex: int)\n    requires a != null && 0 <= low <= high < a.Length\n    modifies a\n    ensures low <= pivotIndex <= high\n    ensures forall i :: low <= i < pivotIndex ==> a[i] <= a[pivotIndex]\n    ensures forall i :: pivotIndex < i <= high ==> a[pivotIndex] <= a[i]\n    ensures multiset(a[low..high+1]) == multiset(old(a[low..high+1]))\n{\n    var pivot := a[high];\n    var i := low - 1;\n    for j := low to high - 1\n        invariant low <= j <= high\n        invariant low - 1 <= i < j\n        invariant forall k :: low <= k <= i ==> a[k] <= pivot\n        invariant forall k :: i < k < j ==> a[k] > pivot\n        invariant multiset(a[low..j]) == multiset(old(a[low..j]))\n    {\n        if a[j] <= pivot {\n            i := i + 1;\n            a[i], a[j] := a[j], a[i];\n        }\n    }\n    a[i + 1], a[high] := a[high], a[i + 1];\n    return i + 1;\n}",
            "parents": [
                "node_312"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 38\n        if a[j] <= pivot {\n            i := i + 1;\n            a[i], a[j] := a[j], a[i];\n        }\n    }\n    a[i + 1], a[high] := a[high], a[i + 1];\n    return i + 1;\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_327",
            "type": "program",
            "content": "method IntegerSquareRoot(n: nat) returns (sqrt: nat)\n    requires n >= 0\n    ensures sqrt * sqrt <= n < (sqrt + 1) * (sqrt + 1)\n{\n    var low: nat := 0;\n    var high: nat := n;\n    while low <= high\n        invariant low * low <= n\n        invariant high * high >= n\n    {\n        var mid: nat := (low + high) / 2;\n        if mid * mid <= n {\n            low := mid + 1;\n        } else {\n            high := mid - 1;\n        }\n    }\n    sqrt := high;\n}",
            "parents": [
                "idea_57"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\nmethod IntegerSquareRoot(n: nat) returns (sqrt: nat)\n    requires n >= 0\n    ensures sqrt * sqrt <= n < (sqrt + 1) * (sqrt + 1)\n{\n    var low: nat := 0;\n    var high: nat := n;\n    while low <= high\n        invariant low * low <= n\n        invariant high * high >= n\n    {\n        var mid: nat := (low + high) / 2;\n        if mid * mid <= n {\n            low := mid + 1;\n        } else {\n            high := mid - 1;\n        }\n    }\n    sqrt := high;\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_328",
            "type": "program",
            "content": "class Matrix2x2 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    constructor(a: int, b: int, c: int, d: int)\n        ensures this.a == a && this.b == b && this.c == c && this.d == d\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n    }\n    method Determinant() returns (det: int)\n        ensures det == a * d - b * c\n    {\n        det := a * d - b * c;\n    }\nmethod MultiplyByScalar(scalar: int) returns (result: Matrix2x2)\n    ensures result.a == this.a * scalar && result.b == this.b * scalar\n    ensures result.c == this.c * scalar && result.d == this.d * scalar\n{\n    result := new Matrix2x2(this.a * scalar, this.b * scalar, this.c * scalar, this.d * scalar);\n}\nmethod Transpose() returns (result: Matrix2x2)\n    ensures result.a == this.a && result.b == this.c\n    ensures result.c == this.b && result.d == this.d\n{\n    result := new Matrix2x2(this.a, this.c, this.b, this.d);\n}\nmethod Power(n: nat) returns (result: Matrix2x2)\n    requires n >= 0\n    ensures n == 0 ==> (result.a == 1 && result.b == 0 && result.c == 0 && result.d == 1)\n    ensures n > 0 ==> (result.a == this.a && result.b == this.b && result.c == this.c && result.d == this.d) // Simplified for n = 1\n{\n    var res := new Matrix2x2(1, 0, 0, 1);\n    var base := this;\n    var exp := n;\n    while exp > 0\n        invariant exp >= 0\n        invariant res.a * res.d - res.b * res.c == 1 // Preserving determinant of identity matrix\n    {\n        if exp % 2 == 1 {\n            res := new Matrix2x2(\n                res.a * base.a + res.b * base.c,\n                res.a * base.b + res.b * base.d,\n                res.c * base.a + res.d * base.c,\n                res.c * base.b + res.d * base.d\n            );\n        }\n        base := new Matrix2x2(\n            base.a * base.a + base.b * base.c,\n            base.a * base.b + base.b * base.d,\n            base.c * base.a + base.d * base.c,\n            base.c * base.b + base.d * base.d\n        );\n        exp := exp / 2;\n    }\n    result := res;\n}\n}",
            "parents": [
                "node_267"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 31\nmethod Power(n: nat) returns (result: Matrix2x2)\n    requires n >= 0\n    ensures n == 0 ==> (result.a == 1 && result.b == 0 && result.c == 0 && result.d == 1)\n    ensures n > 0 ==> (result.a == this.a && result.b == this.b && result.c == this.c && result.d == this.d) // Simplified for n = 1\n{\n    var res := new Matrix2x2(1, 0, 0, 1);\n    var base := this;\n    var exp := n;\n    while exp > 0\n        invariant exp >= 0\n        invariant res.a * res.d - res.b * res.c == 1 // Preserving determinant of identity matrix\n    {\n        if exp % 2 == 1 {\n            res := new Matrix2x2(\n                res.a * base.a + res.b * base.c,\n                res.a * base.b + res.b * base.d,\n                res.c * base.a + res.d * base.c,\n                res.c * base.b + res.d * base.d\n            );\n        }\n        base := new Matrix2x2(\n            base.a * base.a + base.b * base.c,\n            base.a * base.b + base.b * base.d,\n            base.c * base.a + base.d * base.c,\n            base.c * base.b + base.d * base.d\n        );\n        exp := exp / 2;\n    }\n    result := res;\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_329",
            "type": "program",
            "content": "class Matrix2x2 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    constructor(a: int, b: int, c: int, d: int)\n        ensures this.a == a && this.b == b && this.c == c && this.d == d\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n    }\n    method Transpose() returns (transposed: Matrix2x2)\n        ensures transposed.a == a && transposed.b == c && transposed.c == b && transposed.d == d\n    {\n        transposed := new Matrix2x2(a, c, b, d);\n    }\nmethod Multiply(other: Matrix2x2) returns (product: Matrix2x2)\n    ensures product.a == a * other.a + b * other.c\n    ensures product.b == a * other.b + b * other.d\n    ensures product.c == c * other.a + d * other.c\n    ensures product.d == c * other.b + d * other.d\n{\n    product := new Matrix2x2(\n        a * other.a + b * other.c,\n        a * other.b + b * other.d,\n        c * other.a + d * other.c,\n        c * other.b + d * other.d\n    );\n}\n}",
            "parents": [
                "node_135"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 19\nmethod Multiply(other: Matrix2x2) returns (product: Matrix2x2)\n    ensures product.a == a * other.a + b * other.c\n    ensures product.b == a * other.b + b * other.d\n    ensures product.c == c * other.a + d * other.c\n    ensures product.d == c * other.b + d * other.d\n{\n    product := new Matrix2x2(\n        a * other.a + b * other.c,\n        a * other.b + b * other.d,\n        c * other.a + d * other.c,\n        c * other.b + d * other.d\n    );\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_330",
            "type": "program",
            "content": "class MatrixOperations {\n    method Transpose(matrix: seq<seq<int>>) returns (transposed: seq<seq<int>>)\n        requires forall row :: row in matrix ==> |row| == |matrix[0]|\n        ensures |transposed| == |matrix[0]|\n        ensures forall i, j :: 0 <= i < |matrix| && 0 <= j < |matrix[0]| ==> transposed[j][i] == matrix[i][j]\n    {\n        var rows := |matrix|;\n        var cols := |matrix[0]|;\n        transposed := [];\n        for j := 0 to cols - 1\n            invariant 0 <= j <= cols\n            invariant |transposed| == j\n            invariant forall k, i :: 0 <= k < j && 0 <= i < rows ==> transposed[k][i] == matrix[i][k]\n        {\n            var newRow := [];\n            for i := 0 to rows - 1\n                invariant 0 <= i <= rows\n                invariant |newRow| == i\n                invariant forall k :: 0 <= k < i ==> newRow[k] == matrix[k][j]\n            {\n                newRow := newRow + [matrix[i][j]];\n            }\n            transposed := transposed + [newRow];\n        }\n    }\n}",
            "parents": [
                "idea_23"
            ],
            "diff": "```\n// BEGIN DAFNY\nclass MatrixOperations {\n    method Transpose(matrix: seq<seq<int>>) returns (transposed: seq<seq<int>>)\n        requires forall row :: row in matrix ==> |row| == |matrix[0]|\n        ensures |transposed| == |matrix[0]|\n        ensures forall i, j :: 0 <= i < |matrix| && 0 <= j < |matrix[0]| ==> transposed[j][i] == matrix[i][j]\n    {\n        var rows := |matrix|;\n        var cols := |matrix[0]|;\n        transposed := [];\n        for j := 0 to cols - 1\n            invariant 0 <= j <= cols\n            invariant |transposed| == j\n            invariant forall k, i :: 0 <= k < j && 0 <= i < rows ==> transposed[k][i] == matrix[i][k]\n        {\n            var newRow := [];\n            for i := 0 to rows - 1\n                invariant 0 <= i <= rows\n                invariant |newRow| == i\n                invariant forall k :: 0 <= k < i ==> newRow[k] == matrix[k][j]\n            {\n                newRow := newRow + [matrix[i][j]];\n            }\n            transposed := transposed + [newRow];\n        }\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_331",
            "type": "program",
            "content": "method Median(a: array<int>) returns (median: int)\n    requires a != null && a.Length > 0\n    ensures 0 <= median < a.Length\n    ensures forall i: int :: 0 <= i < a.Length ==> a[median] <= a[i] || a[median] >= a[i]\n{\n    var n := a.Length;\n    var sorted := new int[n];\n    // Copy the array\n    for i := 0 to n - 1\n        invariant 0 <= i <= n\n        invariant forall j: int :: 0 <= j < i ==> sorted[j] == a[j]\n    {\n        sorted[i] := a[i];\n    }\n    // Sort the array (simple insertion sort for demonstration)\n    for i := 1 to n - 1\n        invariant 1 <= i <= n\n        invariant forall j: int :: 0 <= j < i - 1 ==> sorted[j] <= sorted[j + 1]\n    {\n        var key := sorted[i];\n        var j := i - 1;\n        while j >= 0 && sorted[j] > key\n            invariant -1 <= j < i\n            invariant forall k: int :: 0 <= k <= j ==> sorted[k] <= key\n            invariant forall k: int :: j + 1 <= k < i ==> sorted[k] <= sorted[k + 1]\n        {\n            sorted[j + 1] := sorted[j];\n            j := j - 1;\n        }\n        sorted[j + 1] := key;\n    }\n    // Find the median\n    if n % 2 == 1 {\n        median := sorted[n / 2];\n    } else {\n        median := sorted[n / 2 - 1]; // Choose the lower median for even length\n    }\n}",
            "parents": [
                "node_274"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 19\n    {\n        var key := sorted[i];\n        var j := i - 1;\n        while j >= 0 && sorted[j] > key\n            invariant -1 <= j < i\n            invariant forall k: int :: 0 <= k <= j ==> sorted[k] <= key\n            invariant forall k: int :: j + 1 <= k < i ==> sorted[k] <= sorted[k + 1]\n        {\n            sorted[j + 1] := sorted[j];\n            j := j - 1;\n        }\n        sorted[j + 1] := key;\n    }\n    // Find the median\n    if n % 2 == 1 {\n        median := sorted[n / 2];\n    } else {\n        median := sorted[n / 2 - 1]; // Choose the lower median for even length\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_332",
            "type": "program",
            "content": "class Employee {\n    var hoursWorked: int;\n    var payRate: int;\n    constructor(hoursWorked: int, payRate: int)\n        ensures this.hoursWorked == hoursWorked && this.payRate == payRate\n    {\n        this.hoursWorked := hoursWorked;\n        this.payRate := payRate;\n    }\nmethod CalculateSalaryWithOvertime() returns (salary: int)\n    ensures salary == hoursWorked * payRate + (if hoursWorked > 40 then (hoursWorked - 40) * payRate / 2 else 0)\n{\n    var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n    var regularHours := hoursWorked - overtimeHours;\n    salary := 0;\n    var i := 0;\n    while i < hoursWorked\n        invariant 0 <= i <= hoursWorked\n        invariant salary == i * payRate - (if i > 40 then (i - 40) * payRate / 2 else 0)\n    {\n        if i < 40 {\n            salary := salary + payRate;\n        } else {\n            salary := salary + payRate / 2;\n        }\n        i := i + 1;\n    }\n}\n}",
            "parents": [
                "node_273"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 10\nmethod CalculateSalaryWithOvertime() returns (salary: int)\n    ensures salary == hoursWorked * payRate + (if hoursWorked > 40 then (hoursWorked - 40) * payRate / 2 else 0)\n{\n    var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n    var regularHours := hoursWorked - overtimeHours;\n    salary := 0;\n    var i := 0;\n    while i < hoursWorked\n        invariant 0 <= i <= hoursWorked\n        invariant salary == i * payRate - (if i > 40 then (i - 40) * payRate / 2 else 0)\n    {\n        if i < 40 {\n            salary := salary + payRate;\n        } else {\n            salary := salary + payRate / 2;\n        }\n        i := i + 1;\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_333",
            "type": "program",
            "content": "class Matrix3x3 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    var e: int;\n    var f: int;\n    var g: int;\n    var h: int;\n    var i: int;\n    constructor(a: int, b: int, c: int, d: int, e: int, f: int, g: int, h: int, i: int)\n        ensures this.a == a && this.b == b && this.c == c\n        ensures this.d == d && this.e == e && this.f == f\n        ensures this.g == g && this.h == h && this.i == i\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n        this.e := e;\n        this.f := f;\n        this.g := g;\n        this.h := h;\n        this.i := i;\n    }\n    method Determinant() returns (det: int)\n        ensures det == a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g)\n    {\n        det := a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g);\n    }\nmethod Transpose() returns (transposed: Matrix3x3)\n    ensures transposed.a == a && transposed.b == d && transposed.c == g\n    ensures transposed.d == b && transposed.e == e && transposed.f == h\n    ensures transposed.g == c && transposed.h == f && transposed.i == i\n{\n    transposed := new Matrix3x3(a, d, g, b, e, h, c, f, i);\n}\nmethod IsIdentity() returns (isIdentity: bool)\n    ensures isIdentity == (a == 1 && e == 1 && i == 1 && b == 0 && c == 0 && d == 0 && f == 0 && g == 0 && h == 0)\n{\n    isIdentity := (a == 1 && e == 1 && i == 1 && b == 0 && c == 0 && d == 0 && f == 0 && g == 0 && h == 0);\n}\n}",
            "parents": [
                "node_185"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 31\nmethod Transpose() returns (transposed: Matrix3x3)\n    ensures transposed.a == a && transposed.b == d && transposed.c == g\n    ensures transposed.d == b && transposed.e == e && transposed.f == h\n    ensures transposed.g == c && transposed.h == f && transposed.i == i\n{\n    transposed := new Matrix3x3(a, d, g, b, e, h, c, f, i);\n}\n\nmethod IsIdentity() returns (isIdentity: bool)\n    ensures isIdentity == (a == 1 && e == 1 && i == 1 && b == 0 && c == 0 && d == 0 && f == 0 && g == 0 && h == 0)\n{\n    isIdentity := (a == 1 && e == 1 && i == 1 && b == 0 && c == 0 && d == 0 && f == 0 && g == 0 && h == 0);\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_334",
            "type": "program",
            "content": "method GeneratePascalsTriangle(n: nat) returns (triangle: seq<seq<nat>>)\n    ensures |triangle| == n\n    ensures forall i :: 0 <= i < n ==> |triangle[i]| == i + 1\n    ensures forall i, j :: 0 <= i < n && 0 <= j <= i ==> triangle[i][j] == if j == 0 || j == i then 1 else triangle[i-1][j-1] + triangle[i-1][j]\n{\n    triangle := [];\n    var row: seq<nat>;\n    for i := 0 to n - 1\n        invariant 0 <= i <= n\n        invariant |triangle| == i\n        invariant forall k :: 0 <= k < i ==> |triangle[k]| == k + 1\n        invariant forall k, j :: 0 <= k < i && 0 <= j <= k ==> triangle[k][j] == if j == 0 || j == k then 1 else triangle[k-1][j-1] + triangle[k-1][j]\n    {\n        row := [];\n        for j := 0 to i\n            invariant 0 <= j <= i + 1\n            invariant |row| == j\n            invariant forall k :: 0 <= k < j ==> row[k] == if k == 0 || k == i then 1 else triangle[i-1][k-1] + triangle[i-1][k]\n        {\n            if j == 0 || j == i {\n                row := row + [1];\n            } else {\n                row := row + [triangle[i-1][j-1] + triangle[i-1][j]];\n            }\n        }\n        triangle := triangle + [row];\n    }\n}",
            "parents": [
                "idea_65"
            ],
            "diff": "```\n// BEGIN DAFNY\nmethod GeneratePascalsTriangle(n: nat) returns (triangle: seq<seq<nat>>)\n    ensures |triangle| == n\n    ensures forall i :: 0 <= i < n ==> |triangle[i]| == i + 1\n    ensures forall i, j :: 0 <= i < n && 0 <= j <= i ==> triangle[i][j] == if j == 0 || j == i then 1 else triangle[i-1][j-1] + triangle[i-1][j]\n{\n    triangle := [];\n    var row: seq<nat>;\n\n    for i := 0 to n - 1\n        invariant 0 <= i <= n\n        invariant |triangle| == i\n        invariant forall k :: 0 <= k < i ==> |triangle[k]| == k + 1\n        invariant forall k, j :: 0 <= k < i && 0 <= j <= k ==> triangle[k][j] == if j == 0 || j == k then 1 else triangle[k-1][j-1] + triangle[k-1][j]\n    {\n        row := [];\n        for j := 0 to i\n            invariant 0 <= j <= i + 1\n            invariant |row| == j\n            invariant forall k :: 0 <= k < j ==> row[k] == if k == 0 || k == i then 1 else triangle[i-1][k-1] + triangle[i-1][k]\n        {\n            if j == 0 || j == i {\n                row := row + [1];\n            } else {\n                row := row + [triangle[i-1][j-1] + triangle[i-1][j]];\n            }\n        }\n        triangle := triangle + [row];\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_335",
            "type": "program",
            "content": "class FlightBookingSystem {\n    var totalSeats: nat;\n    var bookedSeats: nat;\n    constructor(totalSeats: nat)\n        requires totalSeats > 0\n        ensures this.totalSeats == totalSeats && this.bookedSeats == 0\n    {\n        this.totalSeats := totalSeats;\n        this.bookedSeats := 0;\n    }\n    method BookSeat() returns (success: bool)\n        ensures success ==> bookedSeats <= totalSeats\n        ensures !success ==> bookedSeats == totalSeats\n    {\n        if bookedSeats < totalSeats {\n            bookedSeats := bookedSeats + 1;\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n    method CancelSeat() returns (success: bool)\n        ensures success ==> bookedSeats >= 0\n        ensures !success ==> bookedSeats == 0\n    {\n        if bookedSeats > 0 {\n            bookedSeats := bookedSeats - 1;\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n    method BookMultipleSeats(n: nat) returns (success: bool)\n        requires n > 0\n        ensures success ==> bookedSeats <= totalSeats\n        ensures !success ==> bookedSeats + n > totalSeats\n    {\n        var i: nat := 0;\n        success := true;\n        while i < n\n            invariant 0 <= i <= n\n            invariant bookedSeats <= totalSeats\n            invariant success ==> bookedSeats + (n - i) <= totalSeats\n        {\n            if bookedSeats < totalSeats {\n                bookedSeats := bookedSeats + 1;\n            } else {\n                success := false;\n                break;\n            }\n            i := i + 1;\n        }\n    }\n    method AvailableSeats() returns (available: nat)\n        ensures available == totalSeats - bookedSeats\n    {\n        available := totalSeats - bookedSeats;\n    }\n}",
            "parents": [
                "node_246"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 33\n    method BookMultipleSeats(n: nat) returns (success: bool)\n        requires n > 0\n        ensures success ==> bookedSeats <= totalSeats\n        ensures !success ==> bookedSeats + n > totalSeats\n    {\n        var i: nat := 0;\n        success := true;\n        while i < n\n            invariant 0 <= i <= n\n            invariant bookedSeats <= totalSeats\n            invariant success ==> bookedSeats + (n - i) <= totalSeats\n        {\n            if bookedSeats < totalSeats {\n                bookedSeats := bookedSeats + 1;\n            } else {\n                success := false;\n                break;\n            }\n            i := i + 1;\n        }\n    }\n\n    method AvailableSeats() returns (available: nat)\n        ensures available == totalSeats - bookedSeats\n    {\n        available := totalSeats - bookedSeats;\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_336",
            "type": "program",
            "content": "class Employee {\n    var hoursWorked: int;\n    var payRate: int;\n    constructor(hoursWorked: int, payRate: int)\n        ensures this.hoursWorked == hoursWorked && this.payRate == payRate\n    {\n        this.hoursWorked := hoursWorked;\n        this.payRate := payRate;\n    }\nmethod CalculateSalaryWithOvertime() returns (salary: int)\n    ensures salary == hoursWorked * payRate + (if hoursWorked > 40 then (hoursWorked - 40) * payRate / 2 else 0)\n{\n    var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n    var regularHours := hoursWorked - overtimeHours;\n    salary := 0;\n    var i := 0;\n    while i < regularHours + overtimeHours\n        invariant 0 <= i <= regularHours + overtimeHours\n        invariant salary == (if i <= regularHours then i * payRate else regularHours * payRate + (i - regularHours) * payRate / 2)\n    {\n        if i < regularHours {\n            salary := salary + payRate;\n        } else {\n            salary := salary + payRate / 2;\n        }\n        i := i + 1;\n    }\n}\n}",
            "parents": [
                "node_234"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 10\nmethod CalculateSalaryWithOvertime() returns (salary: int)\n    ensures salary == hoursWorked * payRate + (if hoursWorked > 40 then (hoursWorked - 40) * payRate / 2 else 0)\n{\n    var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n    var regularHours := hoursWorked - overtimeHours;\n    salary := 0;\n    var i := 0;\n    while i < regularHours + overtimeHours\n        invariant 0 <= i <= regularHours + overtimeHours\n        invariant salary == (if i <= regularHours then i * payRate else regularHours * payRate + (i - regularHours) * payRate / 2)\n    {\n        if i < regularHours {\n            salary := salary + payRate;\n        } else {\n            salary := salary + payRate / 2;\n        }\n        i := i + 1;\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_337",
            "type": "program",
            "content": "class SudokuValidator {\n    var grid: array2<int>;\n    constructor(grid: array2<int>)\n        requires grid.Length0 == 9 && grid.Length1 == 9\n        ensures this.grid == grid\n    {\n        this.grid := grid;\n    }\n    method IsRowValid(row: int) returns (isValid: bool)\n        requires 0 <= row < 9\n        ensures isValid == (forall i, j :: 0 <= i < j < 9 ==> grid[row, i] != grid[row, j])\n    {\n        var seen := new bool[10];\n        isValid := true;\n        for i := 0 to 8 {\n            if grid[row, i] < 1 || grid[row, i] > 9 || seen[grid[row, i]] {\n                isValid := false;\n                return;\n            }\n            seen[grid[row, i]] := true;\n        }\n    }\n    method IsColumnValid(col: int) returns (isValid: bool)\n        requires 0 <= col < 9\n        ensures isValid == (forall i, j :: 0 <= i < j < 9 ==> grid[i, col] != grid[j, col])\n    {\n        var seen := new bool[10];\n        isValid := true;\n        for i := 0 to 8 {\n            if grid[i, col] < 1 || grid[i, col] > 9 || seen[grid[i, col]] {\n                isValid := false;\n                return;\n            }\n            seen[grid[i, col]] := true;\n        }\n    }\n    method IsSubgridValid(startRow: int, startCol: int) returns (isValid: bool)\n        requires 0 <= startRow < 9 && startRow % 3 == 0\n        requires 0 <= startCol < 9 && startCol % 3 == 0\n        ensures isValid == (forall i, j :: 0 <= i < j < 9 ==> grid[startRow + i / 3, startCol + i % 3] != grid[startRow + j / 3, startCol + j % 3])\n    {\n        var seen := new bool[10];\n        isValid := true;\n        for i := 0 to 8\n            invariant 0 <= i <= 9\n            invariant forall k :: 0 <= k < i ==> 1 <= grid[startRow + k / 3, startCol + k % 3] <= 9\n            invariant forall k :: 0 <= k < i ==> seen[grid[startRow + k / 3, startCol + k % 3]]\n        {\n            var value := grid[startRow + i / 3, startCol + i % 3];\n            if value < 1 || value > 9 || seen[value] {\n                isValid := false;\n                return;\n            }\n            seen[value] := true;\n        }\n    }\n}",
            "parents": [
                "node_103"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 37\n    method IsSubgridValid(startRow: int, startCol: int) returns (isValid: bool)\n        requires 0 <= startRow < 9 && startRow % 3 == 0\n        requires 0 <= startCol < 9 && startCol % 3 == 0\n        ensures isValid == (forall i, j :: 0 <= i < j < 9 ==> grid[startRow + i / 3, startCol + i % 3] != grid[startRow + j / 3, startCol + j % 3])\n    {\n        var seen := new bool[10];\n        isValid := true;\n        for i := 0 to 8\n            invariant 0 <= i <= 9\n            invariant forall k :: 0 <= k < i ==> 1 <= grid[startRow + k / 3, startCol + k % 3] <= 9\n            invariant forall k :: 0 <= k < i ==> seen[grid[startRow + k / 3, startCol + k % 3]]\n        {\n            var value := grid[startRow + i / 3, startCol + i % 3];\n            if value < 1 || value > 9 || seen[value] {\n                isValid := false;\n                return;\n            }\n            seen[value] := true;\n        }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_338",
            "type": "program",
            "content": "class PayrollSystem {\n    method CalculateSalary(hoursWorked: int, payRate: int) returns (salary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        ensures salary >= 0\n    {\n        salary := hoursWorked * payRate;\n    }\n    method CalculateOvertimeSalary(hoursWorked: int, payRate: int, overtimeRate: int) returns (totalSalary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        requires overtimeRate >= payRate\n        ensures totalSalary >= 0\n    {\n        var regularHours := if hoursWorked > 40 then 40 else hoursWorked;\n        var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n        var regularSalary := regularHours * payRate;\n        var overtimeSalary := overtimeHours * overtimeRate;\n        totalSalary := regularSalary + overtimeSalary;\n    }\n    method CalculateWeeklySalary(hoursWorked: int, payRate: int, overtimeRate: int) returns (weeklySalary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        requires overtimeRate >= payRate\n        ensures weeklySalary >= 0\n    {\n        var totalHours := hoursWorked;\n        var totalPay := 0;\n        var i := 0;\n        while i < totalHours\n            invariant 0 <= i <= totalHours\n            invariant totalPay >= 0\n        {\n            if i < 40 {\n                totalPay := totalPay + payRate;\n            } else {\n                totalPay := totalPay + overtimeRate;\n            }\n            i := i + 1;\n        }\n        weeklySalary := totalPay;\n    }\n}",
            "parents": [
                "node_123"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 21\n    method CalculateWeeklySalary(hoursWorked: int, payRate: int, overtimeRate: int) returns (weeklySalary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        requires overtimeRate >= payRate\n        ensures weeklySalary >= 0\n    {\n        var totalHours := hoursWorked;\n        var totalPay := 0;\n        var i := 0;\n        \n        while i < totalHours\n            invariant 0 <= i <= totalHours\n            invariant totalPay >= 0\n        {\n            if i < 40 {\n                totalPay := totalPay + payRate;\n            } else {\n                totalPay := totalPay + overtimeRate;\n            }\n            i := i + 1;\n        }\n        \n        weeklySalary := totalPay;\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_339",
            "type": "program",
            "content": "method Determinant2x2(matrix: array2<int>) returns (det: int)\n    requires matrix.Length0 == 2 && matrix.Length1 == 2\n    ensures det == matrix[0, 0] * matrix[1, 1] - matrix[0, 1] * matrix[1, 0]\n{\n    det := matrix[0, 0] * matrix[1, 1] - matrix[0, 1] * matrix[1, 0];\n}\nmethod Determinant3x3(matrix: array2<int>) returns (det: int)\n    requires matrix.Length0 == 3 && matrix.Length1 == 3\n    ensures det == matrix[0, 0] * (matrix[1, 1] * matrix[2, 2] - matrix[1, 2] * matrix[2, 1])\n                  - matrix[0, 1] * (matrix[1, 0] * matrix[2, 2] - matrix[1, 2] * matrix[2, 0])\n                  + matrix[0, 2] * (matrix[1, 0] * matrix[2, 1] - matrix[1, 1] * matrix[2, 0])\n{\n    var a := matrix[0, 0];\n    var b := matrix[0, 1];\n    var c := matrix[0, 2];\n    var d := matrix[1, 0];\n    var e := matrix[1, 1];\n    var f := matrix[1, 2];\n    var g := matrix[2, 0];\n    var h := matrix[2, 1];\n    var i := matrix[2, 2];\n    det := a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g);\n}",
            "parents": [
                "idea_51"
            ],
            "diff": "```\n// BEGIN DAFNY\n\nmethod Determinant2x2(matrix: array2<int>) returns (det: int)\n    requires matrix.Length0 == 2 && matrix.Length1 == 2\n    ensures det == matrix[0, 0] * matrix[1, 1] - matrix[0, 1] * matrix[1, 0]\n{\n    det := matrix[0, 0] * matrix[1, 1] - matrix[0, 1] * matrix[1, 0];\n}\n\nmethod Determinant3x3(matrix: array2<int>) returns (det: int)\n    requires matrix.Length0 == 3 && matrix.Length1 == 3\n    ensures det == matrix[0, 0] * (matrix[1, 1] * matrix[2, 2] - matrix[1, 2] * matrix[2, 1])\n                  - matrix[0, 1] * (matrix[1, 0] * matrix[2, 2] - matrix[1, 2] * matrix[2, 0])\n                  + matrix[0, 2] * (matrix[1, 0] * matrix[2, 1] - matrix[1, 1] * matrix[2, 0])\n{\n    var a := matrix[0, 0];\n    var b := matrix[0, 1];\n    var c := matrix[0, 2];\n    var d := matrix[1, 0];\n    var e := matrix[1, 1];\n    var f := matrix[1, 2];\n    var g := matrix[2, 0];\n    var h := matrix[2, 1];\n    var i := matrix[2, 2];\n\n    det := a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g);\n}\n\n// END DAFNY\n```"
        },
        {
            "id": "node_340",
            "type": "program",
            "content": "method Median(a: array<int>) returns (median: int)\n    requires a != null && a.Length > 0\n    ensures 0 <= median < a.Length\n    ensures forall i: int :: 0 <= i < a.Length ==> a[median] <= a[i] || a[median] >= a[i]\n{\n    var n := a.Length;\n    var sorted := new int[n];\n    // Copy the array\n    for i := 0 to n - 1\n        invariant 0 <= i <= n\n        invariant forall j: int :: 0 <= j < i ==> sorted[j] == a[j]\n    {\n        sorted[i] := a[i];\n    }\n    // Sort the array (simple insertion sort for demonstration)\n    for i := 1 to n - 1\n        invariant 1 <= i <= n\n        invariant forall j: int :: 0 <= j < i - 1 ==> sorted[j] <= sorted[j + 1]\n}",
            "parents": [
                "node_212"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 18\n        invariant forall j: int :: 0 <= j < i - 1 ==> sorted[j] <= sorted[j + 1]\n// END DAFNY\n```"
        },
        {
            "id": "node_341",
            "type": "program",
            "content": "class VotingSystem {\n    var votes: array<int>;\n    constructor(n: int)\n        requires n > 0\n        ensures votes.Length == n\n        ensures forall i :: 0 <= i < n ==> votes[i] == 0\n    {\n        votes := new int[n];\n    }\n    method CastVote(candidate: int)\n        requires 0 <= candidate < votes.Length\n        modifies votes\n        ensures votes[candidate] == old(votes[candidate]) + 1\n        ensures forall i :: 0 <= i < votes.Length && i != candidate ==> votes[i] == old(votes[i])\n    {\n        votes[candidate] := votes[candidate] + 1;\n    }\n    method ResetVotes()\n        modifies votes\n        ensures forall i :: 0 <= i < votes.Length ==> votes[i] == 0\n    {\n        var i := 0;\n        while i < votes.Length\n            invariant 0 <= i <= votes.Length\n            invariant forall j :: 0 <= j < i ==> votes[j] == 0\n        {\n            votes[i] := 0;\n            i := i + 1;\n        }\n    }\n}",
            "parents": [
                "node_315"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 18\n    method ResetVotes()\n        modifies votes\n        ensures forall i :: 0 <= i < votes.Length ==> votes[i] == 0\n    {\n        var i := 0;\n        while i < votes.Length\n            invariant 0 <= i <= votes.Length\n            invariant forall j :: 0 <= j < i ==> votes[j] == 0\n        {\n            votes[i] := 0;\n            i := i + 1;\n        }\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_342",
            "type": "program",
            "content": "class Matrix2x2 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    constructor(a: int, b: int, c: int, d: int)\n        ensures this.a == a && this.b == b && this.c == c && this.d == d\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n    }\n    method Determinant() returns (det: int)\n        ensures det == a * d - b * c\n    {\n        det := a * d - b * c;\n    }\nmethod MultiplyByScalar(scalar: int) returns (result: Matrix2x2)\n    ensures result.a == this.a * scalar\n    ensures result.b == this.b * scalar\n    ensures result.c == this.c * scalar\n    ensures result.d == this.d * scalar\n{\n    result := new Matrix2x2(this.a * scalar, this.b * scalar, this.c * scalar, this.d * scalar);\n}\nmethod Transpose() returns (result: Matrix2x2)\n    ensures result.a == this.a\n    ensures result.b == this.c\n    ensures result.c == this.b\n    ensures result.d == this.d\n{\n    result := new Matrix2x2(this.a, this.c, this.b, this.d);\n}\n}",
            "parents": [
                "node_107"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 19\nmethod MultiplyByScalar(scalar: int) returns (result: Matrix2x2)\n    ensures result.a == this.a * scalar\n    ensures result.b == this.b * scalar\n    ensures result.c == this.c * scalar\n    ensures result.d == this.d * scalar\n{\n    result := new Matrix2x2(this.a * scalar, this.b * scalar, this.c * scalar, this.d * scalar);\n}\n\nmethod Transpose() returns (result: Matrix2x2)\n    ensures result.a == this.a\n    ensures result.b == this.c\n    ensures result.c == this.b\n    ensures result.d == this.d\n{\n    result := new Matrix2x2(this.a, this.c, this.b, this.d);\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_343",
            "type": "program",
            "content": "method IsPalindrome(s: seq<char>) returns (isPal: bool)\n    ensures isPal == (forall i :: 0 <= i < |s| / 2 ==> s[i] == s[|s| - i - 1])\n{\n    var n := |s|;\n    isPal := true;\n    var i := 0;\n    while i < n / 2\n        invariant 0 <= i <= n / 2\n        invariant isPal == (forall j :: 0 <= j < i ==> s[j] == s[n - j - 1])\n    {\n        if s[i] != s[n - i - 1] {\n            isPal := false;\n            break;\n        }\n        i := i + 1;\n    }\n}",
            "parents": [
                "idea_8"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\nmethod IsPalindrome(s: seq<char>) returns (isPal: bool)\n    ensures isPal == (forall i :: 0 <= i < |s| / 2 ==> s[i] == s[|s| - i - 1])\n{\n    var n := |s|;\n    isPal := true;\n    var i := 0;\n    while i < n / 2\n        invariant 0 <= i <= n / 2\n        invariant isPal == (forall j :: 0 <= j < i ==> s[j] == s[n - j - 1])\n    {\n        if s[i] != s[n - i - 1] {\n            isPal := false;\n            break;\n        }\n        i := i + 1;\n    }\n}\n// END DAFNY\n```\n\nThis Dafny program defines a method `IsPalindrome` that checks if a given sequence of characters (`seq<char>`) is a palindrome. The method uses a loop with invariants to ensure correctness. The loop invariant maintains that for all indices `j` less than `i`, the characters at positions `j` and `n - j - 1` are equal, which is a necessary condition for the sequence to be a palindrome."
        },
        {
            "id": "node_344",
            "type": "program",
            "content": "class FlightBookingSystem {\n    var totalSeats: nat;\n    var bookedSeats: nat;\n    constructor(totalSeats: nat)\n        requires totalSeats > 0\n        ensures this.totalSeats == totalSeats && this.bookedSeats == 0\n    {\n        this.totalSeats := totalSeats;\n        this.bookedSeats := 0;\n    }\n    method BookSeat() returns (success: bool)\n        ensures success ==> bookedSeats <= totalSeats\n        ensures !success ==> bookedSeats == totalSeats\n    {\n        if bookedSeats < totalSeats {\n            bookedSeats := bookedSeats + 1;\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n    method CancelSeat() returns (success: bool)\n        ensures success ==> bookedSeats >= 0\n        ensures !success ==> bookedSeats == 0\n    {\n        if bookedSeats > 0 {\n            bookedSeats := bookedSeats - 1;\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n    method BookMultipleSeats(n: nat) returns (success: bool)\n        requires n > 0\n        ensures success ==> bookedSeats <= totalSeats\n        ensures !success ==> bookedSeats + n > totalSeats\n    {\n        var i: nat := 0;\n        success := true;\n        while i < n\n            invariant 0 <= i <= n\n            invariant bookedSeats <= totalSeats\n            invariant success ==> bookedSeats + (n - i) <= totalSeats\n        {\n            if bookedSeats < totalSeats {\n                bookedSeats := bookedSeats + 1;\n            } else {\n                success := false;\n                break;\n            }\n            i := i + 1;\n        }\n    }\n}",
            "parents": [
                "node_215"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 33\n    method BookMultipleSeats(n: nat) returns (success: bool)\n        requires n > 0\n        ensures success ==> bookedSeats <= totalSeats\n        ensures !success ==> bookedSeats + n > totalSeats\n    {\n        var i: nat := 0;\n        success := true;\n        while i < n\n            invariant 0 <= i <= n\n            invariant bookedSeats <= totalSeats\n            invariant success ==> bookedSeats + (n - i) <= totalSeats\n        {\n            if bookedSeats < totalSeats {\n                bookedSeats := bookedSeats + 1;\n            } else {\n                success := false;\n                break;\n            }\n            i := i + 1;\n        }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_345",
            "type": "program",
            "content": "class Employee {\n    var hoursWorked: int;\n    var payRate: int;\n    constructor(hoursWorked: int, payRate: int)\n        ensures this.hoursWorked == hoursWorked && this.payRate == payRate\n    {\n        this.hoursWorked := hoursWorked;\n        this.payRate := payRate;\n    }\nmethod CalculateSalaryWithOvertime() returns (salary: int)\n    ensures salary >= hoursWorked * payRate\n    ensures salary == hoursWorked * payRate + (if hoursWorked > 40 then (hoursWorked - 40) * payRate / 2 else 0)\n{\n    var regularHours := if hoursWorked > 40 then 40 else hoursWorked;\n    var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n    var overtimePayRate := payRate * 3 / 2;\n    salary := 0;\n    var i := 0;\n    while i < regularHours\n        invariant 0 <= i <= regularHours\n        invariant salary == i * payRate\n    {\n        salary := salary + payRate;\n        i := i + 1;\n    }\n    i := 0;\n    while i < overtimeHours\n        invariant 0 <= i <= overtimeHours\n        invariant salary == regularHours * payRate + i * overtimePayRate\n        invariant salary == (regularHours + i) * payRate + i * payRate / 2\n    {\n        salary := salary + overtimePayRate;\n        i := i + 1;\n    }\n}\n}",
            "parents": [
                "node_281"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 10\nmethod CalculateSalaryWithOvertime() returns (salary: int)\n    ensures salary >= hoursWorked * payRate\n    ensures salary == hoursWorked * payRate + (if hoursWorked > 40 then (hoursWorked - 40) * payRate / 2 else 0)\n{\n    var regularHours := if hoursWorked > 40 then 40 else hoursWorked;\n    var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n    var overtimePayRate := payRate * 3 / 2;\n    salary := 0;\n    var i := 0;\n    while i < regularHours\n        invariant 0 <= i <= regularHours\n        invariant salary == i * payRate\n    {\n        salary := salary + payRate;\n        i := i + 1;\n    }\n    i := 0;\n    while i < overtimeHours\n        invariant 0 <= i <= overtimeHours\n        invariant salary == regularHours * payRate + i * overtimePayRate\n        invariant salary == (regularHours + i) * payRate + i * payRate / 2\n    {\n        salary := salary + overtimePayRate;\n        i := i + 1;\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_346",
            "type": "program",
            "content": "class Employee {\n    var hoursWorked: int;\n    var payRate: int;\n    constructor(hoursWorked: int, payRate: int)\n        ensures this.hoursWorked == hoursWorked && this.payRate == payRate\n    {\n        this.hoursWorked := hoursWorked;\n        this.payRate := payRate;\n    }\nmethod CalculateSalaryWithOvertime() returns (salary: int)\n    ensures salary == hoursWorked * payRate + (if hoursWorked > 40 then (hoursWorked - 40) * payRate / 2 else 0)\n{\n    var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n    var regularHours := hoursWorked - overtimeHours;\n    salary := regularHours * payRate + overtimeHours * payRate / 2;\n}\n}",
            "parents": [
                "node_178"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 10\nmethod CalculateSalaryWithOvertime() returns (salary: int)\n    ensures salary == hoursWorked * payRate + (if hoursWorked > 40 then (hoursWorked - 40) * payRate / 2 else 0)\n{\n    var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n    var regularHours := hoursWorked - overtimeHours;\n    salary := regularHours * payRate + overtimeHours * payRate / 2;\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_347",
            "type": "program",
            "content": "method IsPalindrome(s: seq<char>) returns (isPal: bool)\n    ensures isPal == (forall i :: 0 <= i < |s| / 2 ==> s[i] == s[|s| - i - 1])\n{\n    var n := |s|;\n    isPal := true;\n    var i := 0;\n    while i < n / 2\n        invariant 0 <= i <= n / 2\n        invariant isPal ==> (forall j :: 0 <= j < i ==> s[j] == s[n - j - 1])\n}",
            "parents": [
                "node_343"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 8\n        invariant 0 <= i <= n / 2\n        invariant isPal ==> (forall j :: 0 <= j < i ==> s[j] == s[n - j - 1])\n// END DAFNY\n```"
        },
        {
            "id": "node_348",
            "type": "program",
            "content": "class Geometry {\n    method IsPointInsideRectangle(px: int, py: int, rx: int, ry: int, rw: int, rh: int) returns (inside: bool)\n        requires rw >= 0 && rh >= 0\n        ensures inside == ((px >= rx) && (px <= rx + rw) && (py >= ry) && (py <= ry + rh))\n    {\n        inside := (px >= rx) && (px <= rx + rw) && (py >= ry) && (py <= ry + rh);\n    }\n    method DoRectanglesOverlap(r1x: int, r1y: int, r1w: int, r1h: int, r2x: int, r2y: int, r2w: int, r2h: int) returns (overlap: bool)\n        requires r1w >= 0 && r1h >= 0 && r2w >= 0 && r2h >= 0\n        ensures overlap == ((r1x < r2x + r2w) && (r1x + r1w > r2x) && (r1y < r2y + r2h) && (r1y + r1h > r2y))\n    {\n        overlap := (r1x < r2x + r2w) && (r1x + r1w > r2x) && (r1y < r2y + r2h) && (r1y + r1h > r2y);\n    }\n    method CalculateRectangleArea(rx: int, ry: int, rw: int, rh: int) returns (area: int)\n        requires rw >= 0 && rh >= 0\n        ensures area == rw * rh\n    {\n        area := 0;\n        var i := 0;\n        while i < rw\n            invariant 0 <= i <= rw\n            invariant area == i * rh\n        {\n            area := area + rh;\n            i := i + 1;\n        }\n    }\n}",
            "parents": [
                "node_209"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 14\n    method CalculateRectangleArea(rx: int, ry: int, rw: int, rh: int) returns (area: int)\n        requires rw >= 0 && rh >= 0\n        ensures area == rw * rh\n    {\n        area := 0;\n        var i := 0;\n        while i < rw\n            invariant 0 <= i <= rw\n            invariant area == i * rh\n        {\n            area := area + rh;\n            i := i + 1;\n        }\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_349",
            "type": "program",
            "content": "class PayrollSystem {\n    method CalculateSalary(hoursWorked: int, payRate: int) returns (salary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        ensures salary >= 0\n    {\n        salary := hoursWorked * payRate;\n    }\n    method CalculateOvertimeSalary(hoursWorked: int, payRate: int, overtimeRate: int) returns (totalSalary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        requires overtimeRate >= payRate\n        ensures totalSalary >= 0\n    {\n        var regularHours := if hoursWorked > 40 then 40 else hoursWorked;\n        var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n        var regularSalary := regularHours * payRate;\n        var overtimeSalary := overtimeHours * overtimeRate;\n        totalSalary := regularSalary + overtimeSalary;\n    }\n    method CalculateWeeklySalary(hoursWorked: int, payRate: int, overtimeRate: int) returns (weeklySalary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        requires overtimeRate >= payRate\n        ensures weeklySalary >= 0\n    {\n        var totalHours := hoursWorked;\n        var totalPay := 0;\n        var week := 0;\n        while totalHours > 0\n            invariant totalHours >= 0\n            invariant totalPay >= 0\n            invariant week >= 0\n        {\n            var currentWeekHours := if totalHours > 40 then 40 else totalHours;\n            var overtimeHours := if totalHours > 40 then totalHours - 40 else 0;\n            var regularSalary := currentWeekHours * payRate;\n            var overtimeSalary := overtimeHours * overtimeRate;\n            totalPay := totalPay + regularSalary + overtimeSalary;\n            totalHours := totalHours - currentWeekHours - overtimeHours;\n            week := week + 1;\n        }\n        weeklySalary := totalPay;\n    }\n}",
            "parents": [
                "node_123"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 21\n    method CalculateWeeklySalary(hoursWorked: int, payRate: int, overtimeRate: int) returns (weeklySalary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        requires overtimeRate >= payRate\n        ensures weeklySalary >= 0\n    {\n        var totalHours := hoursWorked;\n        var totalPay := 0;\n        var week := 0;\n        \n        while totalHours > 0\n            invariant totalHours >= 0\n            invariant totalPay >= 0\n            invariant week >= 0\n        {\n            var currentWeekHours := if totalHours > 40 then 40 else totalHours;\n            var overtimeHours := if totalHours > 40 then totalHours - 40 else 0;\n            \n            var regularSalary := currentWeekHours * payRate;\n            var overtimeSalary := overtimeHours * overtimeRate;\n            \n            totalPay := totalPay + regularSalary + overtimeSalary;\n            totalHours := totalHours - currentWeekHours - overtimeHours;\n            week := week + 1;\n        }\n        \n        weeklySalary := totalPay;\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_350",
            "type": "program",
            "content": "class VotingSystem {\n    var votes: array<int>;\n    constructor (numCandidates: int)\n        requires numCandidates > 0\n    {\n        votes := new int[numCandidates];\n    }\n    method Vote(candidate: int)\n        requires 0 <= candidate < votes.Length\n        modifies votes\n        ensures votes[candidate] == old(votes[candidate]) + 1\n    {\n        votes[candidate] := votes[candidate] + 1;\n    }\n    method GetWinner() returns (winner: int)\n        requires votes.Length > 0\n        ensures 0 <= winner < votes.Length\n        ensures forall i: int :: 0 <= i < votes.Length ==> votes[winner] >= votes[i]\n        ensures exists i: int :: 0 <= i < votes.Length && votes[i] == votes[winner]\n    {\n        var maxVotes := votes[0];\n        winner := 0;\n        for i := 1 to votes.Length - 1\n            invariant 0 <= winner < votes.Length\n            invariant 0 <= i <= votes.Length\n            invariant forall j: int :: 0 <= j < i ==> votes[winner] >= votes[j]\n            invariant maxVotes == votes[winner]\n            invariant exists j: int :: 0 <= j < i && votes[j] == maxVotes\n        {\n            if votes[i] > maxVotes {\n                maxVotes := votes[i];\n                winner := i;\n            }\n        }\n    }\n}",
            "parents": [
                "node_325"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 15\n    method GetWinner() returns (winner: int)\n        requires votes.Length > 0\n        ensures 0 <= winner < votes.Length\n        ensures forall i: int :: 0 <= i < votes.Length ==> votes[winner] >= votes[i]\n        ensures exists i: int :: 0 <= i < votes.Length && votes[i] == votes[winner]\n    {\n        var maxVotes := votes[0];\n        winner := 0;\n        for i := 1 to votes.Length - 1\n            invariant 0 <= winner < votes.Length\n            invariant 0 <= i <= votes.Length\n            invariant forall j: int :: 0 <= j < i ==> votes[winner] >= votes[j]\n            invariant maxVotes == votes[winner]\n            invariant exists j: int :: 0 <= j < i && votes[j] == maxVotes\n        {\n            if votes[i] > maxVotes {\n                maxVotes := votes[i];\n                winner := i;\n            }\n        }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_351",
            "type": "program",
            "content": "class Matrix2x2 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    constructor(a: int, b: int, c: int, d: int)\n        ensures this.a == a && this.b == b && this.c == c && this.d == d\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n    }\n    method Determinant() returns (det: int)\n        ensures det == a * d - b * c\n    {\n        det := a * d - b * c;\n    }\nmethod MultiplyByScalar(scalar: int) returns (result: Matrix2x2)\n    ensures result.a == this.a * scalar && result.b == this.b * scalar\n    ensures result.c == this.c * scalar && result.d == this.d * scalar\n{\n    result := new Matrix2x2(this.a * scalar, this.b * scalar, this.c * scalar, this.d * scalar);\n}\nmethod Transpose() returns (result: Matrix2x2)\n    ensures result.a == this.a && result.b == this.c\n    ensures result.c == this.b && result.d == this.d\n{\n    result := new Matrix2x2(this.a, this.c, this.b, this.d);\n}\nmethod Add(other: Matrix2x2) returns (result: Matrix2x2)\n    ensures result.a == this.a + other.a && result.b == this.b + other.b\n    ensures result.c == this.c + other.c && result.d == this.d + other.d\n{\n    result := new Matrix2x2(\n        this.a + other.a,\n        this.b + other.b,\n        this.c + other.c,\n        this.d + other.d\n    );\n}\n}",
            "parents": [
                "node_328"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 25\nmethod Transpose() returns (result: Matrix2x2)\n    ensures result.a == this.a && result.b == this.c\n    ensures result.c == this.b && result.d == this.d\n{\n    result := new Matrix2x2(this.a, this.c, this.b, this.d);\n}\n\nmethod Add(other: Matrix2x2) returns (result: Matrix2x2)\n    ensures result.a == this.a + other.a && result.b == this.b + other.b\n    ensures result.c == this.c + other.c && result.d == this.d + other.d\n{\n    result := new Matrix2x2(\n        this.a + other.a,\n        this.b + other.b,\n        this.c + other.c,\n        this.d + other.d\n    );\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_352",
            "type": "program",
            "content": "class Sudoku {\n    var grid: array2<int>;\n    constructor(grid: array2<int>)\n        requires grid.Length0 == 9 && grid.Length1 == 9\n        ensures this.grid == grid\n    {\n        this.grid := grid;\n    }\n    method IsValidRow(row: int) returns (isValid: bool)\n        requires 0 <= row < 9\n        ensures isValid ==> (forall i, j :: 0 <= i < j < 9 ==> grid[row, i] != grid[row, j])\n    {\n        var seen := new bool[10];\n        isValid := true;\n        for i := 0 to 8 {\n            var num := grid[row, i];\n            if num < 1 || num > 9 || seen[num] {\n                isValid := false;\n                return;\n            }\n            seen[num] := true;\n        }\n    }\n    method IsValidColumn(col: int) returns (isValid: bool)\n        requires 0 <= col < 9\n        ensures isValid ==> (forall i, j :: 0 <= i < j < 9 ==> grid[i, col] != grid[j, col])\n    {\n        var seen := new bool[10];\n        isValid := true;\n        for i := 0 to 8 {\n            var num := grid[i, col];\n            if num < 1 || num > 9 || seen[num] {\n                isValid := false;\n                return;\n            }\n            seen[num] := true;\n        }\n    }\n    method IsValidSubgrid(subgridRow: int, subgridCol: int) returns (isValid: bool)\n        requires 0 <= subgridRow < 3 && 0 <= subgridCol < 3\n        ensures isValid ==> (forall i, j :: 0 <= i < j < 9 ==> grid[subgridRow * 3 + i / 3, subgridCol * 3 + i % 3] != grid[subgridRow * 3 + j / 3, subgridCol * 3 + j % 3])\n    {\n        var seen := new bool[10];\n        isValid := true;\n        for i := 0 to 8\n            invariant 0 <= i <= 9\n            invariant forall k :: 0 <= k < i ==> 1 <= grid[subgridRow * 3 + k / 3, subgridCol * 3 + k % 3] <= 9\n            invariant forall k :: 0 <= k < i ==> seen[grid[subgridRow * 3 + k / 3, subgridCol * 3 + k % 3]]\n        {\n            var num := grid[subgridRow * 3 + i / 3, subgridCol * 3 + i % 3];\n            if num < 1 || num > 9 || seen[num] {\n                isValid := false;\n                return;\n            }\n            seen[num] := true;\n        }\n    }\n}",
            "parents": [
                "node_196"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 39\n    method IsValidSubgrid(subgridRow: int, subgridCol: int) returns (isValid: bool)\n        requires 0 <= subgridRow < 3 && 0 <= subgridCol < 3\n        ensures isValid ==> (forall i, j :: 0 <= i < j < 9 ==> grid[subgridRow * 3 + i / 3, subgridCol * 3 + i % 3] != grid[subgridRow * 3 + j / 3, subgridCol * 3 + j % 3])\n    {\n        var seen := new bool[10];\n        isValid := true;\n        for i := 0 to 8\n            invariant 0 <= i <= 9\n            invariant forall k :: 0 <= k < i ==> 1 <= grid[subgridRow * 3 + k / 3, subgridCol * 3 + k % 3] <= 9\n            invariant forall k :: 0 <= k < i ==> seen[grid[subgridRow * 3 + k / 3, subgridCol * 3 + k % 3]]\n        {\n            var num := grid[subgridRow * 3 + i / 3, subgridCol * 3 + i % 3];\n            if num < 1 || num > 9 || seen[num] {\n                isValid := false;\n                return;\n            }\n            seen[num] := true;\n        }\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_353",
            "type": "program",
            "content": "class Node {\n    var value: int;\n    var next: Node?;\n    constructor(v: int)\n        ensures this.value == v && this.next == null\n    {\n        value := v;\n        next := null;\n    }\n}\nclass LinkedList {\n    var head: Node?;\n    constructor()\n        ensures head == null\n    {\n        head := null;\n    }\n    method InsertAtHead(v: int)\n        modifies this\n        ensures head != null && head.value == v\n    {\n        var newNode := new Node(v);\n        newNode.next := head;\n        head := newNode;\n    }\n    method DeleteFromHead() returns (success: bool)\n        modifies this\n        ensures success ==> head != null\n    {\n        if (head != null) {\n            head := head.next;\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n    method Find(value: int) returns (found: bool)\n        ensures found ==> head != null\n    {\n        var current := head;\n        found := false;\n        while (current != null)\n            invariant current != null ==> head != null\n            invariant current != null ==> current.value != value ==> current.next != null || current.next == null\n        {\n            if (current.value == value) {\n                found := true;\n                return;\n            }\n            current := current.next;\n        }\n    }\n    method Length() returns (len: int)\n        ensures len >= 0\n        ensures len == 0 <==> head == null\n    {\n        var current := head;\n        len := 0;\n        while (current != null)\n            invariant len >= 0\n            invariant current != null ==> head != null\n        {\n            len := len + 1;\n            current := current.next;\n        }\n    }\n}",
            "parents": [
                "node_249"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 53\n    method Length() returns (len: int)\n        ensures len >= 0\n        ensures len == 0 <==> head == null\n    {\n        var current := head;\n        len := 0;\n        while (current != null)\n            invariant len >= 0\n            invariant current != null ==> head != null\n        {\n            len := len + 1;\n            current := current.next;\n        }\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_354",
            "type": "program",
            "content": "class User {\n    var username: string;\n    var password: string;\n    constructor(username: string, password: string)\n        ensures this.username == username\n        ensures this.password == password\n    {\n        this.username := username;\n        this.password := password;\n    }\n}\nclass LoginSystem {\n    var users: seq<User>;\n    constructor()\n        ensures users == []\n    {\n        users := [];\n    }\n    method Register(username: string, password: string)\n        modifies this\n        ensures exists u: User :: u in users && u.username == username && u.password == password\n    {\n        var newUser := new User(username, password);\n        users := users + [newUser];\n    }\n    method Authenticate(username: string, password: string) returns (success: bool)\n        ensures success ==> exists u: User :: u in users && u.username == username && u.password == password\n        ensures !success ==> forall u: User :: u in users && u.username == username ==> u.password != password\n    {\n        success := false;\n        var i: int := 0;\n        while i < |users|\n            invariant 0 <= i <= |users|\n            invariant !success ==> forall j: int :: 0 <= j < i ==> users[j].username != username || users[j].password != password\n        {\n            if users[i].username == username && users[i].password == password {\n                success := true;\n                return;\n            }\n            i := i + 1;\n        }\n    }\n}",
            "parents": [
                "idea_40"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\nclass User {\n    var username: string;\n    var password: string;\n\n    constructor(username: string, password: string)\n        ensures this.username == username\n        ensures this.password == password\n    {\n        this.username := username;\n        this.password := password;\n    }\n}\n\nclass LoginSystem {\n    var users: seq<User>;\n\n    constructor()\n        ensures users == []\n    {\n        users := [];\n    }\n\n    method Register(username: string, password: string)\n        modifies this\n        ensures exists u: User :: u in users && u.username == username && u.password == password\n    {\n        var newUser := new User(username, password);\n        users := users + [newUser];\n    }\n\n    method Authenticate(username: string, password: string) returns (success: bool)\n        ensures success ==> exists u: User :: u in users && u.username == username && u.password == password\n        ensures !success ==> forall u: User :: u in users && u.username == username ==> u.password != password\n    {\n        success := false;\n        var i: int := 0;\n        while i < |users|\n            invariant 0 <= i <= |users|\n            invariant !success ==> forall j: int :: 0 <= j < i ==> users[j].username != username || users[j].password != password\n        {\n            if users[i].username == username && users[i].password == password {\n                success := true;\n                return;\n            }\n            i := i + 1;\n        }\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_355",
            "type": "program",
            "content": "class Geometry {\n    method AreRectanglesColliding(x1: int, y1: int, w1: int, h1: int, x2: int, y2: int, w2: int, h2: int) returns (colliding: bool)\n        requires w1 > 0 && h1 > 0 && w2 > 0 && h2 > 0\n        ensures colliding == ((x1 < x2 + w2) && (x2 < x1 + w1) && (y1 < y2 + h2) && (y2 < y1 + h1))\n    {\n        colliding := (x1 < x2 + w2) && (x2 < x1 + w1) && (y1 < y2 + h2) && (y2 < y1 + h1);\n    }\n    method TranslateRectangle(x: int, y: int, dx: int, dy: int) returns (newX: int, newY: int)\n        ensures newX == x + dx && newY == y + dy\n    {\n        newX := x + dx;\n        newY := y + dy;\n    }\n    method ScaleRectangle(x: int, y: int, w: int, h: int, factor: int) returns (newW: int, newH: int)\n        requires factor > 0\n        ensures newW == w * factor && newH == h * factor\n    {\n        newW := w * factor;\n        newH := h * factor;\n    }\n    method IsPointInsideRectangle(px: int, py: int, x: int, y: int, w: int, h: int) returns (inside: bool)\n        ensures inside == (px >= x && px < x + w && py >= y && py < y + h)\n    {\n        inside := (px >= x && px < x + w && py >= y && py < y + h);\n    }\n    method RotateRectangle(x: int, y: int, w: int, h: int, angle: int) returns (newX: int, newY: int, newW: int, newH: int)\n        requires angle % 90 == 0 && angle >= 0 && angle < 360\n        ensures (angle == 90 || angle == 270) ==> (newW == h && newH == w)\n        ensures (angle == 0 || angle == 180) ==> (newW == w && newH == h)\n    {\n        if angle == 90 {\n            newX := x - h;\n            newY := y;\n            newW := h;\n            newH := w;\n        } else if angle == 180 {\n            newX := x - w;\n            newY := y - h;\n            newW := w;\n            newH := h;\n        } else if angle == 270 {\n            newX := x;\n            newY := y - w;\n            newW := h;\n            newH := w;\n        } else {\n            newX := x;\n            newY := y;\n            newW := w;\n            newH := h;\n        }\n    }\n}",
            "parents": [
                "node_270"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 26\n    method RotateRectangle(x: int, y: int, w: int, h: int, angle: int) returns (newX: int, newY: int, newW: int, newH: int)\n        requires angle % 90 == 0 && angle >= 0 && angle < 360\n        ensures (angle == 90 || angle == 270) ==> (newW == h && newH == w)\n        ensures (angle == 0 || angle == 180) ==> (newW == w && newH == h)\n    {\n        if angle == 90 {\n            newX := x - h;\n            newY := y;\n            newW := h;\n            newH := w;\n        } else if angle == 180 {\n            newX := x - w;\n            newY := y - h;\n            newW := w;\n            newH := h;\n        } else if angle == 270 {\n            newX := x;\n            newY := y - w;\n            newW := h;\n            newH := w;\n        } else {\n            newX := x;\n            newY := y;\n            newW := w;\n            newH := h;\n        }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_356",
            "type": "program",
            "content": "class Matrix2x2 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    constructor(a: int, b: int, c: int, d: int)\n        ensures this.a == a && this.b == b && this.c == c && this.d == d\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n    }\n    method Determinant() returns (det: int)\n        ensures det == a * d - b * c\n    {\n        det := a * d - b * c;\n    }\nmethod MultiplyByScalar(scalar: int) returns (result: Matrix2x2)\n    ensures result.a == this.a * scalar\n    ensures result.b == this.b * scalar\n    ensures result.c == this.c * scalar\n    ensures result.d == this.d * scalar\n{\n    result := new Matrix2x2(this.a * scalar, this.b * scalar, this.c * scalar, this.d * scalar);\n}\nmethod Transpose() returns (result: Matrix2x2)\n    ensures result.a == this.a\n    ensures result.b == this.c\n    ensures result.c == this.b\n    ensures result.d == this.d\n{\n    result := new Matrix2x2(this.a, this.c, this.b, this.d);\n}\n}",
            "parents": [
                "node_188"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 19\nmethod MultiplyByScalar(scalar: int) returns (result: Matrix2x2)\n    ensures result.a == this.a * scalar\n    ensures result.b == this.b * scalar\n    ensures result.c == this.c * scalar\n    ensures result.d == this.d * scalar\n{\n    result := new Matrix2x2(this.a * scalar, this.b * scalar, this.c * scalar, this.d * scalar);\n}\n\nmethod Transpose() returns (result: Matrix2x2)\n    ensures result.a == this.a\n    ensures result.b == this.c\n    ensures result.c == this.b\n    ensures result.d == this.d\n{\n    result := new Matrix2x2(this.a, this.c, this.b, this.d);\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_357",
            "type": "program",
            "content": "class Employee {\n    var hoursWorked: int;\n    var payRate: int;\n    constructor(hoursWorked: int, payRate: int)\n        ensures this.hoursWorked == hoursWorked && this.payRate == payRate\n    {\n        this.hoursWorked := hoursWorked;\n        this.payRate := payRate;\n    }\nmethod CalculateSalaryWithOvertimeAndBonus(bonus: int) returns (totalSalary: int)\n    requires bonus >= 0\n    ensures totalSalary >= hoursWorked * payRate + bonus\n{\n    var regularHours := if hoursWorked > 40 then 40 else hoursWorked;\n    var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n    var overtimeRate := payRate * 3 / 2;\n    totalSalary := 0;\n    var i := 0;\n    while i < regularHours\n        invariant 0 <= i <= regularHours\n        invariant totalSalary == i * payRate\n    {\n        totalSalary := totalSalary + payRate;\n        i := i + 1;\n    }\n    i := 0;\n    while i < overtimeHours\n        invariant 0 <= i <= overtimeHours\n        invariant totalSalary == regularHours * payRate + i * overtimeRate\n    {\n        totalSalary := totalSalary + overtimeRate;\n        i := i + 1;\n    }\n    totalSalary := totalSalary + bonus;\n}\n}",
            "parents": [
                "node_224"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 10\nmethod CalculateSalaryWithOvertimeAndBonus(bonus: int) returns (totalSalary: int)\n    requires bonus >= 0\n    ensures totalSalary >= hoursWorked * payRate + bonus\n{\n    var regularHours := if hoursWorked > 40 then 40 else hoursWorked;\n    var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n    var overtimeRate := payRate * 3 / 2;\n    totalSalary := 0;\n    var i := 0;\n    while i < regularHours\n        invariant 0 <= i <= regularHours\n        invariant totalSalary == i * payRate\n    {\n        totalSalary := totalSalary + payRate;\n        i := i + 1;\n    }\n    i := 0;\n    while i < overtimeHours\n        invariant 0 <= i <= overtimeHours\n        invariant totalSalary == regularHours * payRate + i * overtimeRate\n    {\n        totalSalary := totalSalary + overtimeRate;\n        i := i + 1;\n    }\n    totalSalary := totalSalary + bonus;\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_358",
            "type": "program",
            "content": "class Book {\n    var title: string;\n    var isCheckedOut: bool;\n    constructor(title: string)\n        ensures this.title == title && !this.isCheckedOut\n    {\n        this.title := title;\n        this.isCheckedOut := false;\n    }\n    method CheckOut()\n        requires !isCheckedOut\n        ensures isCheckedOut\n    {\n        isCheckedOut := true;\n    }\n    method ReturnBook()\n        requires isCheckedOut\n        ensures !isCheckedOut\n    {\n        isCheckedOut := false;\n    }\n}\nclass Library {\n    var books: seq<Book>;\n    constructor()\n        ensures books == []\n    {\n        books := [];\n    }\n    method AddBook(b: Book)\n        ensures books == old(books) + [b]\n    {\n        books := books + [b];\n    }\n    method CheckOutBook(title: string) returns (success: bool)\n        ensures success ==> exists b: Book :: b in books && b.title == title && b.isCheckedOut\n        ensures !success ==> forall b: Book :: b in books && b.title == title ==> !b.isCheckedOut\n    {\n        success := false;\n        var i := 0;\n        while i < |books|\n            invariant 0 <= i <= |books|\n            invariant forall j: int :: 0 <= j < i ==> books[j].title != title || books[j].isCheckedOut\n        {\n            if books[i].title == title && !books[i].isCheckedOut {\n                books[i].CheckOut();\n                success := true;\n                return;\n            }\n            i := i + 1;\n        }\n    }\n}",
            "parents": [
                "node_142"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 35\n    method CheckOutBook(title: string) returns (success: bool)\n        ensures success ==> exists b: Book :: b in books && b.title == title && b.isCheckedOut\n        ensures !success ==> forall b: Book :: b in books && b.title == title ==> !b.isCheckedOut\n    {\n        success := false;\n        var i := 0;\n        while i < |books|\n            invariant 0 <= i <= |books|\n            invariant forall j: int :: 0 <= j < i ==> books[j].title != title || books[j].isCheckedOut\n        {\n            if books[i].title == title && !books[i].isCheckedOut {\n                books[i].CheckOut();\n                success := true;\n                return;\n            }\n            i := i + 1;\n        }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_359",
            "type": "program",
            "content": "class VotingSystem {\n    var votes: array<int>;\n    constructor (numCandidates: int)\n        requires numCandidates > 0\n    {\n        votes := new int[numCandidates];\n    }\n    method Vote(candidate: int)\n        requires 0 <= candidate < votes.Length\n        modifies votes\n        ensures votes[candidate] == old(votes[candidate]) + 1\n    {\n        votes[candidate] := votes[candidate] + 1;\n    }\n    method GetWinner() returns (winner: int, isTie: bool)\n        requires votes.Length > 0\n        ensures 0 <= winner < votes.Length\n        ensures forall i: int :: 0 <= i < votes.Length ==> votes[winner] >= votes[i]\n        ensures isTie <==> (exists i: int :: 0 <= i < votes.Length && i != winner && votes[i] == votes[winner])\n    {\n        var maxVotes := votes[0];\n        winner := 0;\n        isTie := false;\n        for i := 1 to votes.Length - 1\n            invariant 0 <= winner < votes.Length\n            invariant 0 <= i <= votes.Length\n            invariant forall j: int :: 0 <= j < i ==> votes[winner] >= votes[j]\n            invariant isTie <==> (exists j: int :: 0 <= j < i && j != winner && votes[j] == votes[winner])\n        {\n            if votes[i] > maxVotes {\n                maxVotes := votes[i];\n                winner := i;\n                isTie := false;\n            } else if votes[i] == maxVotes && i != winner {\n                isTie := true;\n            }\n        }\n    }\n}",
            "parents": [
                "node_229"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 15\n    method GetWinner() returns (winner: int, isTie: bool)\n        requires votes.Length > 0\n        ensures 0 <= winner < votes.Length\n        ensures forall i: int :: 0 <= i < votes.Length ==> votes[winner] >= votes[i]\n        ensures isTie <==> (exists i: int :: 0 <= i < votes.Length && i != winner && votes[i] == votes[winner])\n    {\n        var maxVotes := votes[0];\n        winner := 0;\n        isTie := false;\n        for i := 1 to votes.Length - 1\n            invariant 0 <= winner < votes.Length\n            invariant 0 <= i <= votes.Length\n            invariant forall j: int :: 0 <= j < i ==> votes[winner] >= votes[j]\n            invariant isTie <==> (exists j: int :: 0 <= j < i && j != winner && votes[j] == votes[winner])\n        {\n            if votes[i] > maxVotes {\n                maxVotes := votes[i];\n                winner := i;\n                isTie := false;\n            } else if votes[i] == maxVotes && i != winner {\n                isTie := true;\n            }\n        }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_360",
            "type": "program",
            "content": "class BasicLoginSystem {\n    var storedUsername: string;\n    var storedPassword: string;\n    constructor(username: string, password: string) \n        requires username != \"\" && password != \"\"\n    {\n        storedUsername := username;\n        storedPassword := password;\n    }\n    method Authenticate(inputUsername: string, inputPassword: string) returns (isAuthenticated: bool)\n        ensures isAuthenticated == (inputUsername == storedUsername && inputPassword == storedPassword)\n    {\n        var attempts: int := 0;\n        while attempts < 3\n            invariant 0 <= attempts <= 3\n            decreases 3 - attempts\n        {\n            if inputUsername == storedUsername && inputPassword == storedPassword {\n                isAuthenticated := true;\n                return;\n            } else {\n                attempts := attempts + 1;\n            }\n        }\n        isAuthenticated := false;\n    }\n}",
            "parents": [
                "node_127"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 10\n    method Authenticate(inputUsername: string, inputPassword: string) returns (isAuthenticated: bool)\n        ensures isAuthenticated == (inputUsername == storedUsername && inputPassword == storedPassword)\n    {\n        var attempts: int := 0;\n        while attempts < 3\n            invariant 0 <= attempts <= 3\n            decreases 3 - attempts\n        {\n            if inputUsername == storedUsername && inputPassword == storedPassword {\n                isAuthenticated := true;\n                return;\n            } else {\n                attempts := attempts + 1;\n            }\n        }\n        isAuthenticated := false;\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_361",
            "type": "program",
            "content": "method QuickSort(a: array<int>) \n    requires a != null\n    modifies a\n    ensures forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n    ensures multiset(a[..]) == multiset(old(a[..]))\n{\n    QuickSortHelper(a, 0, a.Length - 1);\n}\nmethod QuickSortHelper(a: array<int>, low: int, high: int)\n    requires a != null && 0 <= low <= high + 1 <= a.Length\n    modifies a\n    ensures forall i, j :: low <= i < j <= high ==> a[i] <= a[j]\n    ensures multiset(a[low..high+1]) == multiset(old(a[low..high+1]))\n{\n    if low < high {\n        var pivotIndex := Partition(a, low, high);\n        QuickSortHelper(a, low, pivotIndex - 1);\n        QuickSortHelper(a, pivotIndex + 1, high);\n    }\n}\nmethod Partition(a: array<int>, low: int, high: int) returns (pivotIndex: int)\n    requires a != null && 0 <= low <= high < a.Length\n    modifies a\n    ensures low <= pivotIndex <= high\n    ensures forall i :: low <= i < pivotIndex ==> a[i] <= a[pivotIndex]\n    ensures forall i :: pivotIndex < i <= high ==> a[pivotIndex] <= a[i]\n    ensures multiset(a[low..high+1]) == multiset(old(a[low..high+1]))\n{\n    var pivot := a[high];\n    var i := low - 1;\n    for j := low to high - 1\n        invariant low <= j <= high\n        invariant low - 1 <= i < j\n        invariant forall k :: low <= k <= i ==> a[k] <= pivot\n        invariant forall k :: i < k < j ==> a[k] > pivot\n        invariant multiset(a[low..j]) == multiset(old(a[low..j]))\n    {\n        if a[j] <= pivot {\n            i := i + 1;\n            a[i], a[j] := a[j], a[i];\n        }\n    }\n    a[i + 1], a[high] := a[high], a[i + 1];\n    return i + 1;\n}",
            "parents": [
                "node_312"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 38\n        if a[j] <= pivot {\n            i := i + 1;\n            a[i], a[j] := a[j], a[i];\n        }\n    }\n    a[i + 1], a[high] := a[high], a[i + 1];\n    return i + 1;\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_362",
            "type": "program",
            "content": "class FlightBookingSystem {\n    var totalSeats: nat;\n    var bookedSeats: nat;\n    constructor(totalSeats: nat)\n        requires totalSeats > 0\n        ensures this.totalSeats == totalSeats && this.bookedSeats == 0\n    {\n        this.totalSeats := totalSeats;\n        this.bookedSeats := 0;\n    }\n    method BookSeat() returns (success: bool)\n        ensures success ==> bookedSeats <= totalSeats\n        ensures !success ==> bookedSeats == totalSeats\n    {\n        if bookedSeats < totalSeats {\n            bookedSeats := bookedSeats + 1;\n            success := true;\n        } else {\n            success := false;\n        }\n    }\nmethod CancelSeat() returns (success: bool)\n    ensures success ==> bookedSeats >= 0\n    ensures !success ==> bookedSeats == 0\n{\n    if bookedSeats > 0 {\n        bookedSeats := bookedSeats - 1;\n        success := true;\n    } else {\n        success := false;\n    }\n}\nmethod BookMultipleSeats(n: nat) returns (success: bool)\n    requires n > 0\n    ensures success ==> bookedSeats <= totalSeats\n    ensures !success ==> bookedSeats + n > totalSeats\n{\n    var i: nat := 0;\n    success := true;\n    while i < n\n        invariant 0 <= i <= n\n        invariant bookedSeats <= totalSeats\n    {\n        if bookedSeats < totalSeats {\n            bookedSeats := bookedSeats + 1;\n        } else {\n            success := false;\n            break;\n        }\n        i := i + 1;\n    }\n}\n}",
            "parents": [
                "node_109"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 22\nmethod CancelSeat() returns (success: bool)\n    ensures success ==> bookedSeats >= 0\n    ensures !success ==> bookedSeats == 0\n{\n    if bookedSeats > 0 {\n        bookedSeats := bookedSeats - 1;\n        success := true;\n    } else {\n        success := false;\n    }\n}\n\nmethod BookMultipleSeats(n: nat) returns (success: bool)\n    requires n > 0\n    ensures success ==> bookedSeats <= totalSeats\n    ensures !success ==> bookedSeats + n > totalSeats\n{\n    var i: nat := 0;\n    success := true;\n    while i < n\n        invariant 0 <= i <= n\n        invariant bookedSeats <= totalSeats\n    {\n        if bookedSeats < totalSeats {\n            bookedSeats := bookedSeats + 1;\n        } else {\n            success := false;\n            break;\n        }\n        i := i + 1;\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_363",
            "type": "program",
            "content": "class PayrollSystem {\n    method CalculateSalary(hoursWorked: int, payRate: int) returns (salary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        ensures salary >= 0\n    {\n        salary := hoursWorked * payRate;\n    }\n    method CalculateOvertimeSalary(hoursWorked: int, payRate: int, overtimeRate: int) returns (totalSalary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        requires overtimeRate >= payRate\n        ensures totalSalary >= 0\n    {\n        var regularHours := if hoursWorked > 40 then 40 else hoursWorked;\n        var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n        var regularSalary := regularHours * payRate;\n        var overtimeSalary := overtimeHours * overtimeRate;\n        totalSalary := regularSalary + overtimeSalary;\n    }\n    method CalculateWeeklySalary(hoursWorked: int, payRate: int, overtimeRate: int) returns (weeklySalary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        requires overtimeRate >= payRate\n        ensures weeklySalary >= 0\n    {\n        var totalHours := hoursWorked;\n        var totalSalary := 0;\n        var regularHours := if hoursWorked > 40 then 40 else hoursWorked;\n        var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n        var regularSalary := regularHours * payRate;\n        var overtimeSalary := overtimeHours * overtimeRate;\n        weeklySalary := regularSalary + overtimeSalary;\n}\n}",
            "parents": [
                "node_237"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 29\n        var regularHours := if hoursWorked > 40 then 40 else hoursWorked;\n        var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n        var regularSalary := regularHours * payRate;\n        var overtimeSalary := overtimeHours * overtimeRate;\n        weeklySalary := regularSalary + overtimeSalary;\n// END DAFNY\n```"
        },
        {
            "id": "node_364",
            "type": "program",
            "content": "class TournamentBracket {\n    method GenerateBracket(seeds: seq<int>) returns (matchups: seq<(int, int)>)\n        requires |seeds| > 0 && |seeds| % 2 == 0\n        ensures |matchups| == |seeds| / 2\n        ensures forall i :: 0 <= i < |matchups| ==> matchups[i].0 != matchups[i].1\n    {\n        var n := |seeds|;\n        matchups := [];\n        for i := 0 to n / 2 - 1\n            invariant 0 <= i <= n / 2\n            invariant |matchups| == i\n            invariant forall j :: 0 <= j < i ==> matchups[j].0 != matchups[j].1\n        {\n            var team1 := seeds[i];\n            var team2 := seeds[n - i - 1];\n            matchups := matchups + [(team1, team2)];\n        }\n}\n}",
            "parents": [
                "node_157"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 9\n        for i := 0 to n / 2 - 1\n            invariant 0 <= i <= n / 2\n            invariant |matchups| == i\n            invariant forall j :: 0 <= j < i ==> matchups[j].0 != matchups[j].1\n        {\n            var team1 := seeds[i];\n            var team2 := seeds[n - i - 1];\n            matchups := matchups + [(team1, team2)];\n        }\n// END DAFNY\n```"
        },
        {
            "id": "node_365",
            "type": "program",
            "content": "class LeapYearChecker {\n    method IsLeapYear(year: int) returns (isLeap: bool)\n        requires year > 0\n        ensures isLeap == ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)\n    {\n        var isLeapTemp := false;\n        if year % 4 == 0 {\n            if year % 100 == 0 {\n                if year % 400 == 0 {\n                    isLeapTemp := true;\n                }\n            } else {\n                isLeapTemp := true;\n            }\n        }\n        isLeap := isLeapTemp;\n}\n}",
            "parents": [
                "node_261"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 6\n        var isLeapTemp := false;\n        if year % 4 == 0 {\n            if year % 100 == 0 {\n                if year % 400 == 0 {\n                    isLeapTemp := true;\n                }\n            } else {\n                isLeapTemp := true;\n            }\n        }\n        isLeap := isLeapTemp;\n// END DAFNY\n```"
        },
        {
            "id": "node_366",
            "type": "program",
            "content": "class Matrix2x2 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    constructor(a: int, b: int, c: int, d: int)\n        ensures this.a == a && this.b == b && this.c == c && this.d == d\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n    }\n    method Determinant() returns (det: int)\n        ensures det == a * d - b * c\n    {\n        det := a * d - b * c;\n    }\nmethod MultiplyByScalar(scalar: int) returns (result: Matrix2x2)\n    ensures result.a == this.a * scalar\n    ensures result.b == this.b * scalar\n    ensures result.c == this.c * scalar\n    ensures result.d == this.d * scalar\n{\n    result := new Matrix2x2(this.a * scalar, this.b * scalar, this.c * scalar, this.d * scalar);\n}\nmethod Transpose() returns (transposed: Matrix2x2)\n    ensures transposed.a == this.a\n    ensures transposed.b == this.c\n    ensures transposed.c == this.b\n    ensures transposed.d == this.d\n{\n    transposed := new Matrix2x2(this.a, this.c, this.b, this.d);\n}\n}",
            "parents": [
                "node_130"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 19\nmethod MultiplyByScalar(scalar: int) returns (result: Matrix2x2)\n    ensures result.a == this.a * scalar\n    ensures result.b == this.b * scalar\n    ensures result.c == this.c * scalar\n    ensures result.d == this.d * scalar\n{\n    result := new Matrix2x2(this.a * scalar, this.b * scalar, this.c * scalar, this.d * scalar);\n}\n\nmethod Transpose() returns (transposed: Matrix2x2)\n    ensures transposed.a == this.a\n    ensures transposed.b == this.c\n    ensures transposed.c == this.b\n    ensures transposed.d == this.d\n{\n    transposed := new Matrix2x2(this.a, this.c, this.b, this.d);\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_367",
            "type": "program",
            "content": "class Geometry {\n    method IsPointInsideRectangle(px: int, py: int, rx: int, ry: int, rw: int, rh: int) returns (inside: bool)\n        requires rw >= 0 && rh >= 0\n        ensures inside == ((px >= rx) && (px <= rx + rw) && (py >= ry) && (py <= ry + rh))\n    {\n        inside := (px >= rx) && (px <= rx + rw) && (py >= ry) && (py <= ry + rh);\n    }\n    method DoRectanglesOverlap(r1x: int, r1y: int, r1w: int, r1h: int, r2x: int, r2y: int, r2w: int, r2h: int) returns (overlap: bool)\n        requires r1w >= 0 && r1h >= 0 && r2w >= 0 && r2h >= 0\n        ensures overlap == ((r1x < r2x + r2w) && (r1x + r1w > r2x) && (r1y < r2y + r2h) && (r1y + r1h > r2y))\n    {\n        overlap := (r1x < r2x + r2w) && (r1x + r1w > r2x) && (r1y < r2y + r2h) && (r1y + r1h > r2y);\n    }\n    method CalculateRectanglePerimeter(rx: int, ry: int, rw: int, rh: int) returns (perimeter: int)\n        requires rw >= 0 && rh >= 0\n        ensures perimeter == 2 * (rw + rh)\n    {\n        var w := rw;\n        var h := rh;\n        perimeter := 0;\n        var count := 0;\n        while count < 2\n            invariant 0 <= count <= 2\n            invariant perimeter == count * (rw + rh)\n        {\n            perimeter := perimeter + (w + h);\n            count := count + 1;\n        }\n    }\n}",
            "parents": [
                "node_304"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 14\n    method CalculateRectanglePerimeter(rx: int, ry: int, rw: int, rh: int) returns (perimeter: int)\n        requires rw >= 0 && rh >= 0\n        ensures perimeter == 2 * (rw + rh)\n    {\n        var w := rw;\n        var h := rh;\n        perimeter := 0;\n        var count := 0;\n        while count < 2\n            invariant 0 <= count <= 2\n            invariant perimeter == count * (rw + rh)\n        {\n            perimeter := perimeter + (w + h);\n            count := count + 1;\n        }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_368",
            "type": "program",
            "content": "class City {\n    var id: int;\n    constructor(id: int)\n        ensures this.id == id\n    {\n        this.id := id;\n    }\n}\nclass Tour {\n    var cities: seq<City>;\n    constructor(cities: seq<City>)\n        ensures this.cities == cities\n    {\n        this.cities := cities;\n    }\n    method IsValidTour() returns (isValid: bool)\n        ensures isValid == (|cities| > 1 && cities[0] == cities[|cities| - 1])\n    {\n        isValid := false;\n        if |cities| > 1 {\n            var i := 0;\n            while i < |cities| - 1\n                invariant 0 <= i <= |cities| - 1\n                invariant forall j :: 0 <= j < i ==> cities[j] != cities[|cities| - 1]\n                invariant !isValid ==> forall j :: 0 <= j < i ==> cities[j] != cities[|cities| - 1]\n            {\n                if cities[i] == cities[|cities| - 1] {\n                    isValid := true;\n                    break;\n                }\n                i := i + 1;\n            }\n        }\n    }\n}",
            "parents": [
                "node_244"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 16\n    method IsValidTour() returns (isValid: bool)\n        ensures isValid == (|cities| > 1 && cities[0] == cities[|cities| - 1])\n    {\n        isValid := false;\n        if |cities| > 1 {\n            var i := 0;\n            while i < |cities| - 1\n                invariant 0 <= i <= |cities| - 1\n                invariant forall j :: 0 <= j < i ==> cities[j] != cities[|cities| - 1]\n                invariant !isValid ==> forall j :: 0 <= j < i ==> cities[j] != cities[|cities| - 1]\n            {\n                if cities[i] == cities[|cities| - 1] {\n                    isValid := true;\n                    break;\n                }\n                i := i + 1;\n            }\n        }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_369",
            "type": "program",
            "content": "class Matrix3x3 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    var e: int;\n    var f: int;\n    var g: int;\n    var h: int;\n    var i: int;\n    constructor(a: int, b: int, c: int, d: int, e: int, f: int, g: int, h: int, i: int)\n        ensures this.a == a && this.b == b && this.c == c\n        ensures this.d == d && this.e == e && this.f == f\n        ensures this.g == g && this.h == h && this.i == i\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n        this.e := e;\n        this.f := f;\n        this.g := g;\n        this.h := h;\n        this.i := i;\n    }\n    method Determinant() returns (det: int)\n        ensures det == a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g)\n    {\n        det := a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g);\n    }\nmethod Transpose() returns (transposed: Matrix3x3)\n    ensures transposed.a == this.a && transposed.b == this.d && transposed.c == this.g\n    ensures transposed.d == this.b && transposed.e == this.e && transposed.f == this.h\n    ensures transposed.g == this.c && transposed.h == this.f && transposed.i == this.i\n{\n    transposed := new Matrix3x3(this.a, this.d, this.g, this.b, this.e, this.h, this.c, this.f, this.i);\n}\n    method Multiply(other: Matrix3x3) returns (product: Matrix3x3)\n        ensures product.a == this.a * other.a + this.b * other.d + this.c * other.g\n        ensures product.b == this.a * other.b + this.b * other.e + this.c * other.h\n        ensures product.c == this.a * other.c + this.b * other.f + this.c * other.i\n        ensures product.d == this.d * other.a + this.e * other.d + this.f * other.g\n        ensures product.e == this.d * other.b + this.e * other.e + this.f * other.h\n        ensures product.f == this.d * other.c + this.e * other.f + this.f * other.i\n        ensures product.g == this.g * other.a + this.h * other.d + this.i * other.g\n        ensures product.h == this.g * other.b + this.h * other.e + this.i * other.h\n        ensures product.i == this.g * other.c + this.h * other.f + this.i * other.i\n    {\n        var pa := this.a * other.a + this.b * other.d + this.c * other.g;\n        var pb := this.a * other.b + this.b * other.e + this.c * other.h;\n        var pc := this.a * other.c + this.b * other.f + this.c * other.i;\n        var pd := this.d * other.a + this.e * other.d + this.f * other.g;\n        var pe := this.d * other.b + this.e * other.e + this.f * other.h;\n        var pf := this.d * other.c + this.e * other.f + this.f * other.i;\n        var pg := this.g * other.a + this.h * other.d + this.i * other.g;\n        var ph := this.g * other.b + this.h * other.e + this.i * other.h;\n        var pi := this.g * other.c + this.h * other.f + this.i * other.i;\n        product := new Matrix3x3(pa, pb, pc, pd, pe, pf, pg, ph, pi);\n    }\n    method IsIdentity() returns (identity: bool)\n        ensures identity == (a == 1 && b == 0 && c == 0 && d == 0 && e == 1 && f == 0 && g == 0 && h == 0 && i == 1)\n    {\n        identity := (a == 1 && b == 0 && c == 0 && d == 0 && e == 1 && f == 0 && g == 0 && h == 0 && i == 1);\n    }\n}",
            "parents": [
                "node_262"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 38\n    method Multiply(other: Matrix3x3) returns (product: Matrix3x3)\n        ensures product.a == this.a * other.a + this.b * other.d + this.c * other.g\n        ensures product.b == this.a * other.b + this.b * other.e + this.c * other.h\n        ensures product.c == this.a * other.c + this.b * other.f + this.c * other.i\n        ensures product.d == this.d * other.a + this.e * other.d + this.f * other.g\n        ensures product.e == this.d * other.b + this.e * other.e + this.f * other.h\n        ensures product.f == this.d * other.c + this.e * other.f + this.f * other.i\n        ensures product.g == this.g * other.a + this.h * other.d + this.i * other.g\n        ensures product.h == this.g * other.b + this.h * other.e + this.i * other.h\n        ensures product.i == this.g * other.c + this.h * other.f + this.i * other.i\n    {\n        var pa := this.a * other.a + this.b * other.d + this.c * other.g;\n        var pb := this.a * other.b + this.b * other.e + this.c * other.h;\n        var pc := this.a * other.c + this.b * other.f + this.c * other.i;\n        var pd := this.d * other.a + this.e * other.d + this.f * other.g;\n        var pe := this.d * other.b + this.e * other.e + this.f * other.h;\n        var pf := this.d * other.c + this.e * other.f + this.f * other.i;\n        var pg := this.g * other.a + this.h * other.d + this.i * other.g;\n        var ph := this.g * other.b + this.h * other.e + this.i * other.h;\n        var pi := this.g * other.c + this.h * other.f + this.i * other.i;\n        product := new Matrix3x3(pa, pb, pc, pd, pe, pf, pg, ph, pi);\n    }\n\n    method IsIdentity() returns (identity: bool)\n        ensures identity == (a == 1 && b == 0 && c == 0 && d == 0 && e == 1 && f == 0 && g == 0 && h == 0 && i == 1)\n    {\n        identity := (a == 1 && b == 0 && c == 0 && d == 0 && e == 1 && f == 0 && g == 0 && h == 0 && i == 1);\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_370",
            "type": "program",
            "content": "class Matrix3x3 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    var e: int;\n    var f: int;\n    var g: int;\n    var h: int;\n    var i: int;\n    constructor(a: int, b: int, c: int, d: int, e: int, f: int, g: int, h: int, i: int)\n        ensures this.a == a && this.b == b && this.c == c\n        ensures this.d == d && this.e == e && this.f == f\n        ensures this.g == g && this.h == h && this.i == i\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n        this.e := e;\n        this.f := f;\n        this.g := g;\n        this.h := h;\n        this.i := i;\n    }\n    method Transpose() returns (transposed: Matrix3x3)\n        ensures transposed.a == a && transposed.b == d && transposed.c == g\n        ensures transposed.d == b && transposed.e == e && transposed.f == h\n        ensures transposed.g == c && transposed.h == f && transposed.i == i\n    {\n        transposed := new Matrix3x3(a, d, g, b, e, h, c, f, i);\n    }\nmethod Multiply(other: Matrix3x3) returns (product: Matrix3x3)\n    ensures product.a == a * other.a + b * other.d + c * other.g\n    ensures product.b == a * other.b + b * other.e + c * other.h\n    ensures product.c == a * other.c + b * other.f + c * other.i\n    ensures product.d == d * other.a + e * other.d + f * other.g\n    ensures product.e == d * other.b + e * other.e + f * other.h\n    ensures product.f == d * other.c + e * other.f + f * other.i\n    ensures product.g == g * other.a + h * other.d + i * other.g\n    ensures product.h == g * other.b + h * other.e + i * other.h\n    ensures product.i == g * other.c + h * other.f + i * other.i\n{\n    var newA := a * other.a + b * other.d + c * other.g;\n    var newB := a * other.b + b * other.e + c * other.h;\n    var newC := a * other.c + b * other.f + c * other.i;\n    var newD := d * other.a + e * other.d + f * other.g;\n    var newE := d * other.b + e * other.e + f * other.h;\n    var newF := d * other.c + e * other.f + f * other.i;\n    var newG := g * other.a + h * other.d + i * other.g;\n    var newH := g * other.b + h * other.e + i * other.h;\n    var newI := g * other.c + h * other.f + i * other.i;\n    product := new Matrix3x3(newA, newB, newC, newD, newE, newF, newG, newH, newI);\n}\n}",
            "parents": [
                "node_139"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 33\nmethod Multiply(other: Matrix3x3) returns (product: Matrix3x3)\n    ensures product.a == a * other.a + b * other.d + c * other.g\n    ensures product.b == a * other.b + b * other.e + c * other.h\n    ensures product.c == a * other.c + b * other.f + c * other.i\n    ensures product.d == d * other.a + e * other.d + f * other.g\n    ensures product.e == d * other.b + e * other.e + f * other.h\n    ensures product.f == d * other.c + e * other.f + f * other.i\n    ensures product.g == g * other.a + h * other.d + i * other.g\n    ensures product.h == g * other.b + h * other.e + i * other.h\n    ensures product.i == g * other.c + h * other.f + i * other.i\n{\n    var newA := a * other.a + b * other.d + c * other.g;\n    var newB := a * other.b + b * other.e + c * other.h;\n    var newC := a * other.c + b * other.f + c * other.i;\n    var newD := d * other.a + e * other.d + f * other.g;\n    var newE := d * other.b + e * other.e + f * other.h;\n    var newF := d * other.c + e * other.f + f * other.i;\n    var newG := g * other.a + h * other.d + i * other.g;\n    var newH := g * other.b + h * other.e + i * other.h;\n    var newI := g * other.c + h * other.f + i * other.i;\n    product := new Matrix3x3(newA, newB, newC, newD, newE, newF, newG, newH, newI);\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_371",
            "type": "program",
            "content": "method GCD(a: nat, b: nat) returns (gcd: nat)\n    requires a > 0 && b > 0\n    ensures gcd > 0\n    ensures a % gcd == 0 && b % gcd == 0\n    ensures forall d: nat :: d > 0 && a % d == 0 && b % d == 0 ==> gcd >= d\n{\n    var x := a;\n    var y := b;\n    while y != 0\n        invariant x > 0\n        invariant y >= 0\n        invariant x % gcd == 0 && y % gcd == 0\n}",
            "parents": [
                "node_137"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 12\n        invariant x % gcd == 0 && y % gcd == 0\n// END DAFNY\n```"
        },
        {
            "id": "node_372",
            "type": "program",
            "content": "class TowerOfHanoi {\n    method SolveHanoi(n: nat, source: char, target: char, auxiliary: char) \n        requires n >= 0\n        ensures true\n    {\n        if n == 0 {\n            return;\n        }\n        SolveHanoi(n - 1, source, auxiliary, target);\n        PrintMove(source, target);\n        SolveHanoi(n - 1, auxiliary, target, source);\n    }\n    method PrintMove(from: char, to: char)\n        ensures true\n    {\n        // This method would print the move from 'from' to 'to'\n        // In a real implementation, this would output something like \"Move disk from A to B\"\n    }\n}",
            "parents": [
                "idea_6"
            ],
            "diff": "```\n// BEGIN DAFNY\n\nclass TowerOfHanoi {\n    method SolveHanoi(n: nat, source: char, target: char, auxiliary: char) \n        requires n >= 0\n        ensures true\n    {\n        if n == 0 {\n            return;\n        }\n        SolveHanoi(n - 1, source, auxiliary, target);\n        PrintMove(source, target);\n        SolveHanoi(n - 1, auxiliary, target, source);\n    }\n\n    method PrintMove(from: char, to: char)\n        ensures true\n    {\n        // This method would print the move from 'from' to 'to'\n        // In a real implementation, this would output something like \"Move disk from A to B\"\n    }\n}\n\n// END DAFNY\n```\n\nThis small Dafny program defines a class `TowerOfHanoi` with a method `SolveHanoi` that solves the Tower of Hanoi puzzle recursively. The method `PrintMove` is a placeholder for printing the moves, which would be implemented in a real scenario. The program includes a basic structure and ensures clauses, but focuses on demonstrating the recursive nature of the solution."
        },
        {
            "id": "node_373",
            "type": "program",
            "content": "method EuclideanGCD(a: nat, b: nat) returns (gcd: nat)\n    requires a > 0 && b > 0\n    ensures gcd > 0\n    ensures a % gcd == 0 && b % gcd == 0\n    ensures forall d: nat :: d > 0 && a % d == 0 && b % d == 0 ==> gcd >= d\n{\n    var x := a;\n    var y := b;\n    while y != 0\n        invariant x > 0\n        invariant y >= 0\n        invariant x % gcd == 0 && y % gcd == 0\n}",
            "parents": [
                "node_311"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 12\n        invariant x % gcd == 0 && y % gcd == 0\n// END DAFNY\n```"
        },
        {
            "id": "node_374",
            "type": "program",
            "content": "method Median(a: array<int>) returns (median: int)\n    requires a != null && a.Length > 0\n    ensures 0 <= median < a.Length\n    ensures forall i: int :: 0 <= i < a.Length ==> a[median] <= a[i] || a[median] >= a[i]\n{\n    var n := a.Length;\n    var sorted := new int[n];\n    // Copy the array\n    for i := 0 to n - 1\n        invariant 0 <= i <= n\n        invariant forall j: int :: 0 <= j < i ==> sorted[j] == a[j]\n    {\n        sorted[i] := a[i];\n    }\n    // Sort the array (simple insertion sort for demonstration)\n    for i := 1 to n - 1\n        invariant 1 <= i <= n\n        invariant forall j: int :: 0 <= j < i - 1 ==> sorted[j] <= sorted[j + 1]\n    {\n        var key := sorted[i];\n        var j := i - 1;\n        while j >= 0 && sorted[j] > key\n            invariant -1 <= j < i\n            invariant forall k: int :: 0 <= k <= j ==> sorted[k] <= key\n            invariant forall k: int :: j + 1 <= k < i ==> sorted[k] >= key\n        {\n            sorted[j + 1] := sorted[j];\n            j := j - 1;\n        }\n        sorted[j + 1] := key;\n    }\n    // Find the median\n    if n % 2 == 1 {\n        median := sorted[n / 2];\n    } else {\n        median := sorted[n / 2 - 1]; // Choose the lower median for even length\n    }\n}",
            "parents": [
                "node_340"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 19\n    {\n        var key := sorted[i];\n        var j := i - 1;\n        while j >= 0 && sorted[j] > key\n            invariant -1 <= j < i\n            invariant forall k: int :: 0 <= k <= j ==> sorted[k] <= key\n            invariant forall k: int :: j + 1 <= k < i ==> sorted[k] >= key\n        {\n            sorted[j + 1] := sorted[j];\n            j := j - 1;\n        }\n        sorted[j + 1] := key;\n    }\n    // Find the median\n    if n % 2 == 1 {\n        median := sorted[n / 2];\n    } else {\n        median := sorted[n / 2 - 1]; // Choose the lower median for even length\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_375",
            "type": "program",
            "content": "class SudokuValidator {\n    var grid: array2<int>;\n    constructor(grid: array2<int>)\n        requires grid.Length0 == 9 && grid.Length1 == 9\n        ensures this.grid == grid\n    {\n        this.grid := grid;\n    }\n    method IsRowValid(row: int) returns (isValid: bool)\n        requires 0 <= row < 9\n        ensures isValid == (forall i, j :: 0 <= i < j < 9 ==> grid[row, i] != grid[row, j])\n    {\n        var seen := new bool[10];\n        isValid := true;\n        for i := 0 to 8 {\n            if grid[row, i] < 1 || grid[row, i] > 9 || seen[grid[row, i]] {\n                isValid := false;\n                return;\n            }\n            seen[grid[row, i]] := true;\n        }\n    }\n    method IsColumnValid(col: int) returns (isValid: bool)\n        requires 0 <= col < 9\n        ensures isValid == (forall i, j :: 0 <= i < j < 9 ==> grid[i, col] != grid[j, col])\n    {\n        var seen := new bool[10];\n        isValid := true;\n        for i := 0 to 8 {\n            if grid[i, col] < 1 || grid[i, col] > 9 || seen[grid[i, col]] {\n                isValid := false;\n                return;\n            }\n            seen[grid[i, col]] := true;\n        }\n    }\n    method IsSubgridValid(startRow: int, startCol: int) returns (isValid: bool)\n        requires 0 <= startRow < 9 && startRow % 3 == 0\n        requires 0 <= startCol < 9 && startCol % 3 == 0\n        ensures isValid == (forall i, j :: 0 <= i < j < 9 ==> grid[startRow + i / 3, startCol + i % 3] != grid[startRow + j / 3, startCol + j % 3])\n    {\n        var seen := new bool[10];\n        isValid := true;\n        var count := 0;\n        for i := 0 to 2\n            invariant 0 <= i <= 3\n            invariant forall k :: 0 <= k < i * 3 ==> 1 <= grid[startRow + k / 3, startCol + k % 3] <= 9\n            invariant forall k :: 0 <= k < i * 3 ==> seen[grid[startRow + k / 3, startCol + k % 3]]\n        {\n            for j := 0 to 2\n                invariant 0 <= j <= 3\n                invariant 0 <= count <= 9\n                invariant forall k :: 0 <= k < count ==> 1 <= grid[startRow + k / 3, startCol + k % 3] <= 9\n                invariant forall k :: 0 <= k < count ==> seen[grid[startRow + k / 3, startCol + k % 3]]\n            {\n                var value := grid[startRow + i, startCol + j];\n                if value < 1 || value > 9 || seen[value] {\n                    isValid := false;\n                    return;\n                }\n                seen[value] := true;\n                count := count + 1;\n            }\n        }\n    }\n}",
            "parents": [
                "node_337"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 37\n    method IsSubgridValid(startRow: int, startCol: int) returns (isValid: bool)\n        requires 0 <= startRow < 9 && startRow % 3 == 0\n        requires 0 <= startCol < 9 && startCol % 3 == 0\n        ensures isValid == (forall i, j :: 0 <= i < j < 9 ==> grid[startRow + i / 3, startCol + i % 3] != grid[startRow + j / 3, startCol + j % 3])\n    {\n        var seen := new bool[10];\n        isValid := true;\n        var count := 0;\n        for i := 0 to 2\n            invariant 0 <= i <= 3\n            invariant forall k :: 0 <= k < i * 3 ==> 1 <= grid[startRow + k / 3, startCol + k % 3] <= 9\n            invariant forall k :: 0 <= k < i * 3 ==> seen[grid[startRow + k / 3, startCol + k % 3]]\n        {\n            for j := 0 to 2\n                invariant 0 <= j <= 3\n                invariant 0 <= count <= 9\n                invariant forall k :: 0 <= k < count ==> 1 <= grid[startRow + k / 3, startCol + k % 3] <= 9\n                invariant forall k :: 0 <= k < count ==> seen[grid[startRow + k / 3, startCol + k % 3]]\n            {\n                var value := grid[startRow + i, startCol + j];\n                if value < 1 || value > 9 || seen[value] {\n                    isValid := false;\n                    return;\n                }\n                seen[value] := true;\n                count := count + 1;\n            }\n        }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_376",
            "type": "program",
            "content": "class FlightBookingSystem {\n    var totalSeats: nat;\n    var bookedSeats: nat;\n    constructor(totalSeats: nat)\n        requires totalSeats > 0\n        ensures this.totalSeats == totalSeats && this.bookedSeats == 0\n    {\n        this.totalSeats := totalSeats;\n        this.bookedSeats := 0;\n    }\n    method BookSeat() returns (success: bool)\n        ensures success ==> bookedSeats <= totalSeats\n        ensures !success ==> bookedSeats == totalSeats\n    {\n        if bookedSeats < totalSeats {\n            bookedSeats := bookedSeats + 1;\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n    method CancelSeat() returns (success: bool)\n        ensures success ==> bookedSeats >= 0\n        ensures !success ==> bookedSeats == 0\n    {\n        if bookedSeats > 0 {\n            bookedSeats := bookedSeats - 1;\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n    method BookMultipleSeats(n: nat) returns (success: bool)\n        requires n > 0\n        ensures success ==> bookedSeats <= totalSeats\n        ensures !success ==> bookedSeats + n > totalSeats\n    {\n        var i := 0;\n        success := true;\n        while i < n\n            invariant 0 <= i <= n\n            invariant bookedSeats <= totalSeats\n            invariant success ==> bookedSeats + i <= totalSeats\n            invariant !success ==> bookedSeats + i > totalSeats\n        {\n            if bookedSeats < totalSeats {\n                bookedSeats := bookedSeats + 1;\n            } else {\n                success := false;\n                break;\n            }\n            i := i + 1;\n        }\n    }\n}",
            "parents": [
                "node_250"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 33\n    method BookMultipleSeats(n: nat) returns (success: bool)\n        requires n > 0\n        ensures success ==> bookedSeats <= totalSeats\n        ensures !success ==> bookedSeats + n > totalSeats\n    {\n        var i := 0;\n        success := true;\n        while i < n\n            invariant 0 <= i <= n\n            invariant bookedSeats <= totalSeats\n            invariant success ==> bookedSeats + i <= totalSeats\n            invariant !success ==> bookedSeats + i > totalSeats\n        {\n            if bookedSeats < totalSeats {\n                bookedSeats := bookedSeats + 1;\n            } else {\n                success := false;\n                break;\n            }\n            i := i + 1;\n        }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_377",
            "type": "program",
            "content": "class Thermostat {\n    var currentTemperature: int;\n    var setpoint: int;\n    constructor(initTemp: int, setpoint: int)\n        ensures this.currentTemperature == initTemp\n        ensures this.setpoint == setpoint\n    {\n        this.currentTemperature := initTemp;\n        this.setpoint := setpoint;\n    }\nmethod AdjustTemperatureWithHistory() returns (adjustment: int, history: seq<int>)\n    ensures adjustment == if currentTemperature < setpoint then 1 else if currentTemperature > setpoint then -1 else 0\n    ensures history == if currentTemperature < setpoint then [currentTemperature, setpoint] else if currentTemperature > setpoint then [currentTemperature, setpoint] else [currentTemperature]\n{\n    var tempHistory: seq<int> := [];\n    if currentTemperature < setpoint {\n        adjustment := 1;\n        tempHistory := tempHistory + [currentTemperature, setpoint];\n    } else if currentTemperature > setpoint {\n        adjustment := -1;\n        tempHistory := tempHistory + [currentTemperature, setpoint];\n    } else {\n        adjustment := 0;\n        tempHistory := tempHistory + [currentTemperature];\n    }\n    history := tempHistory;\n}\n}",
            "parents": [
                "node_138"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 11\nmethod AdjustTemperatureWithHistory() returns (adjustment: int, history: seq<int>)\n    ensures adjustment == if currentTemperature < setpoint then 1 else if currentTemperature > setpoint then -1 else 0\n    ensures history == if currentTemperature < setpoint then [currentTemperature, setpoint] else if currentTemperature > setpoint then [currentTemperature, setpoint] else [currentTemperature]\n{\n    var tempHistory: seq<int> := [];\n    if currentTemperature < setpoint {\n        adjustment := 1;\n        tempHistory := tempHistory + [currentTemperature, setpoint];\n    } else if currentTemperature > setpoint {\n        adjustment := -1;\n        tempHistory := tempHistory + [currentTemperature, setpoint];\n    } else {\n        adjustment := 0;\n        tempHistory := tempHistory + [currentTemperature];\n    }\n    history := tempHistory;\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_378",
            "type": "program",
            "content": "class PayrollSystem {\n    method CalculateSalary(hoursWorked: int, payRate: int) returns (salary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        ensures salary >= 0\n    {\n        salary := hoursWorked * payRate;\n    }\n    method CalculateOvertimeSalary(hoursWorked: int, payRate: int, overtimeRate: int) returns (totalSalary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        requires overtimeRate >= payRate\n        ensures totalSalary >= 0\n    {\n        var regularHours := if hoursWorked > 40 then 40 else hoursWorked;\n        var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n        var regularSalary := regularHours * payRate;\n        var overtimeSalary := overtimeHours * overtimeRate;\n        totalSalary := regularSalary + overtimeSalary;\n    }\n    method CalculateWeeklySalary(hoursWorked: int, payRate: int, overtimeRate: int) returns (weeklySalary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        requires overtimeRate >= payRate\n        ensures weeklySalary >= 0\n    {\n        var totalHours := hoursWorked;\n        var totalPay := 0;\n        var i := 0;\n        var regularHours := if hoursWorked > 40 then 40 else hoursWorked;\n        var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n        var regularPay := regularHours * payRate;\n        var overtimePay := overtimeHours * overtimeRate;\n        weeklySalary := regularPay + overtimePay;\n}\n}",
            "parents": [
                "node_338"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 30\n        var regularHours := if hoursWorked > 40 then 40 else hoursWorked;\n        var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n        var regularPay := regularHours * payRate;\n        var overtimePay := overtimeHours * overtimeRate;\n        weeklySalary := regularPay + overtimePay;\n// END DAFNY\n```"
        },
        {
            "id": "node_379",
            "type": "program",
            "content": "class Book {\n    var title: string;\n    var isCheckedOut: bool;\n    constructor(title: string)\n        ensures this.title == title && !this.isCheckedOut\n    {\n        this.title := title;\n        this.isCheckedOut := false;\n    }\n    method CheckOut()\n        requires !isCheckedOut\n        ensures isCheckedOut\n    {\n        isCheckedOut := true;\n    }\n    method ReturnBook()\n        requires isCheckedOut\n        ensures !isCheckedOut\n    {\n        isCheckedOut := false;\n    }\n}\nclass Library {\n    var books: seq<Book>;\n    constructor()\n        ensures books == []\n    {\n        books := [];\n    }\n    method AddBook(b: Book)\n        ensures books == old(books) + [b]\n    {\n        books := books + [b];\n    }\n    method CheckOutBook(title: string) returns (success: bool)\n        ensures success ==> exists b: Book :: b in books && b.title == title && b.isCheckedOut\n        ensures !success ==> forall b: Book :: b in books && b.title == title ==> !b.isCheckedOut\n    {\n        success := false;\n        var i := 0;\n        while i < |books|\n            invariant 0 <= i <= |books|\n            invariant forall j: int :: 0 <= j < i ==> books[j].title != title || books[j].isCheckedOut\n            invariant !success ==> forall j: int :: 0 <= j < i ==> books[j].title != title || books[j].isCheckedOut\n        {\n            if books[i].title == title && !books[i].isCheckedOut {\n                books[i].CheckOut();\n                success := true;\n                return;\n            }\n            i := i + 1;\n        }\n    }\n    method ReturnBook(title: string) returns (success: bool)\n        ensures success ==> exists b: Book :: b in books && b.title == title && !b.isCheckedOut\n        ensures !success ==> forall b: Book :: b in books && b.title == title ==> b.isCheckedOut\n    {\n        success := false;\n        var i := 0;\n        while i < |books|\n            invariant 0 <= i <= |books|\n            invariant forall j: int :: 0 <= j < i ==> books[j].title != title || !books[j].isCheckedOut\n            invariant !success ==> forall j: int :: 0 <= j < i ==> books[j].title != title || !books[j].isCheckedOut\n        {\n            if books[i].title == title && books[i].isCheckedOut {\n                books[i].ReturnBook();\n                success := true;\n                return;\n            }\n            i := i + 1;\n        }\n    }\n}",
            "parents": [
                "node_358"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 35\n    method CheckOutBook(title: string) returns (success: bool)\n        ensures success ==> exists b: Book :: b in books && b.title == title && b.isCheckedOut\n        ensures !success ==> forall b: Book :: b in books && b.title == title ==> !b.isCheckedOut\n    {\n        success := false;\n        var i := 0;\n        while i < |books|\n            invariant 0 <= i <= |books|\n            invariant forall j: int :: 0 <= j < i ==> books[j].title != title || books[j].isCheckedOut\n            invariant !success ==> forall j: int :: 0 <= j < i ==> books[j].title != title || books[j].isCheckedOut\n        {\n            if books[i].title == title && !books[i].isCheckedOut {\n                books[i].CheckOut();\n                success := true;\n                return;\n            }\n            i := i + 1;\n        }\n    }\n\n    method ReturnBook(title: string) returns (success: bool)\n        ensures success ==> exists b: Book :: b in books && b.title == title && !b.isCheckedOut\n        ensures !success ==> forall b: Book :: b in books && b.title == title ==> b.isCheckedOut\n    {\n        success := false;\n        var i := 0;\n        while i < |books|\n            invariant 0 <= i <= |books|\n            invariant forall j: int :: 0 <= j < i ==> books[j].title != title || !books[j].isCheckedOut\n            invariant !success ==> forall j: int :: 0 <= j < i ==> books[j].title != title || !books[j].isCheckedOut\n        {\n            if books[i].title == title && books[i].isCheckedOut {\n                books[i].ReturnBook();\n                success := true;\n                return;\n            }\n            i := i + 1;\n        }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_380",
            "type": "program",
            "content": "class CurrencyConverter {\n    var exchangeRate: real;\n    constructor(rate: real)\n        requires rate > 0.0\n        ensures this.exchangeRate == rate\n    {\n        this.exchangeRate := rate;\n    }\n    method ConvertWithFee(amount: real, feePercentage: real) returns (convertedAmount: real)\n        requires amount >= 0.0\n        requires feePercentage >= 0.0 && feePercentage <= 100.0\n        ensures convertedAmount == amount * exchangeRate * (1.0 - feePercentage / 100.0)\n    {\n        var feeFactor := 1.0 - feePercentage / 100.0;\n        convertedAmount := amount * exchangeRate * feeFactor;\n    }\n}",
            "parents": [
                "node_179"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 9\n    method ConvertWithFee(amount: real, feePercentage: real) returns (convertedAmount: real)\n        requires amount >= 0.0\n        requires feePercentage >= 0.0 && feePercentage <= 100.0\n        ensures convertedAmount == amount * exchangeRate * (1.0 - feePercentage / 100.0)\n    {\n        var feeFactor := 1.0 - feePercentage / 100.0;\n        convertedAmount := amount * exchangeRate * feeFactor;\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_381",
            "type": "program",
            "content": "class Matrix3x3 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    var e: int;\n    var f: int;\n    var g: int;\n    var h: int;\n    var i: int;\n    constructor(a: int, b: int, c: int, d: int, e: int, f: int, g: int, h: int, i: int)\n        ensures this.a == a && this.b == b && this.c == c\n        ensures this.d == d && this.e == e && this.f == f\n        ensures this.g == g && this.h == h && this.i == i\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n        this.e := e;\n        this.f := f;\n        this.g := g;\n        this.h := h;\n        this.i := i;\n    }\n    method Determinant() returns (det: int)\n        ensures det == a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g)\n    {\n        det := a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g);\n    }\nmethod Transpose() returns (t: Matrix3x3)\n    ensures t.a == a && t.b == d && t.c == g\n    ensures t.d == b && t.e == e && t.f == h\n    ensures t.g == c && t.h == f && t.i == i\n{\n    t := new Matrix3x3(a, d, g, b, e, h, c, f, i);\n}\nmethod IsSymmetric() returns (symmetric: bool)\n    ensures symmetric == (a == a && b == d && c == g && d == b && e == e && f == h && g == c && h == f && i == i)\n{\n    symmetric := true;\n    if b != d || c != g || f != h {\n        symmetric := false;\n    }\n}\n}",
            "parents": [
                "node_153"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 31\nmethod Transpose() returns (t: Matrix3x3)\n    ensures t.a == a && t.b == d && t.c == g\n    ensures t.d == b && t.e == e && t.f == h\n    ensures t.g == c && t.h == f && t.i == i\n{\n    t := new Matrix3x3(a, d, g, b, e, h, c, f, i);\n}\n\nmethod IsSymmetric() returns (symmetric: bool)\n    ensures symmetric == (a == a && b == d && c == g && d == b && e == e && f == h && g == c && h == f && i == i)\n{\n    symmetric := true;\n    if b != d || c != g || f != h {\n        symmetric := false;\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_382",
            "type": "program",
            "content": "method WaysToMakeChange(amount: int, coins: seq<int>) returns (ways: int)\n    requires amount >= 0 && forall coin :: coin in coins ==> coin > 0\n    ensures ways >= 0\n{\n    var dp := new int[amount + 1];\n    dp[0] := 1;\n    // Loop invariant: \n    // 0 <= i <= |coins| \n    // && forall j :: 0 <= j <= amount ==> dp[j] >= 0\n    // && dp[j] represents the number of ways to make change for amount j using the first i coins\n    for i := 0 to |coins| - 1 {\n    for j := coins[i] to amount {\n        dp[j] := dp[j] + dp[j - coins[i]];\n    }\n}\n}",
            "parents": [
                "node_320"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 12\n    for j := coins[i] to amount {\n        dp[j] := dp[j] + dp[j - coins[i]];\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_383",
            "type": "program",
            "content": "class FlightBookingSystem {\n    var totalSeats: nat;\n    var bookedSeats: nat;\n    constructor(totalSeats: nat)\n        requires totalSeats > 0\n        ensures this.totalSeats == totalSeats && this.bookedSeats == 0\n    {\n        this.totalSeats := totalSeats;\n        this.bookedSeats := 0;\n    }\n    method BookSeat() returns (success: bool)\n        ensures success ==> bookedSeats <= totalSeats\n        ensures !success ==> bookedSeats == totalSeats\n    {\n        if bookedSeats < totalSeats {\n            bookedSeats := bookedSeats + 1;\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n    method CancelSeat() returns (success: bool)\n        ensures success ==> bookedSeats >= 0\n        ensures !success ==> bookedSeats == 0\n    {\n        if bookedSeats > 0 {\n            bookedSeats := bookedSeats - 1;\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n    method BookMultipleSeats(n: nat) returns (success: bool)\n        requires n > 0\n        ensures success ==> bookedSeats <= totalSeats\n        ensures !success ==> bookedSeats + n > totalSeats\n    {\n        var i: nat := 0;\n        success := true;\n        while i < n\n            invariant 0 <= i <= n\n            invariant bookedSeats <= totalSeats\n            decreases n - i\n        {\n            if bookedSeats < totalSeats {\n                bookedSeats := bookedSeats + 1;\n            } else {\n                success := false;\n                break;\n            }\n            i := i + 1;\n        }\n    }\n}",
            "parents": [
                "node_109"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 22\n    method CancelSeat() returns (success: bool)\n        ensures success ==> bookedSeats >= 0\n        ensures !success ==> bookedSeats == 0\n    {\n        if bookedSeats > 0 {\n            bookedSeats := bookedSeats - 1;\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n\n    method BookMultipleSeats(n: nat) returns (success: bool)\n        requires n > 0\n        ensures success ==> bookedSeats <= totalSeats\n        ensures !success ==> bookedSeats + n > totalSeats\n    {\n        var i: nat := 0;\n        success := true;\n        while i < n\n            invariant 0 <= i <= n\n            invariant bookedSeats <= totalSeats\n            decreases n - i\n        {\n            if bookedSeats < totalSeats {\n                bookedSeats := bookedSeats + 1;\n            } else {\n                success := false;\n                break;\n            }\n            i := i + 1;\n        }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_384",
            "type": "program",
            "content": "class MatrixOperations {\n    method Transpose(matrix: seq<seq<int>>) returns (transposed: seq<seq<int>>)\n        requires |matrix| > 0 && |matrix[0]| > 0\n        requires forall row :: row in matrix ==> |row| == |matrix[0]|\n        ensures |transposed| == |matrix[0]|\n        ensures forall i, j :: 0 <= i < |matrix| && 0 <= j < |matrix[0]| ==> transposed[j][i] == matrix[i][j]\n    {\n        var rows := |matrix|;\n        var cols := |matrix[0]|;\n        transposed := [];\n        for j := 0 to cols - 1\n            invariant 0 <= j <= cols\n            invariant |transposed| == j\n            invariant forall k, i :: 0 <= k < j && 0 <= i < rows ==> transposed[k][i] == matrix[i][k]\n        {\n            var newRow := [];\n            for i := 0 to rows - 1\n                invariant 0 <= i <= rows\n                invariant |newRow| == i\n                invariant forall k :: 0 <= k < i ==> newRow[k] == matrix[k][j]\n            {\n                newRow := newRow + [matrix[i][j]];\n            }\n            transposed := transposed + [newRow];\n        }\n    }\n    method IsSquare(matrix: seq<seq<int>>) returns (isSquare: bool)\n        requires |matrix| > 0 && |matrix[0]| > 0\n        requires forall row :: row in matrix ==> |row| == |matrix[0]|\n        ensures isSquare <==> |matrix| == |matrix[0]|\n    {\n        isSquare := |matrix| == |matrix[0]|;\n    }\n}",
            "parents": [
                "node_330"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 2\n    method Transpose(matrix: seq<seq<int>>) returns (transposed: seq<seq<int>>)\n        requires |matrix| > 0 && |matrix[0]| > 0\n        requires forall row :: row in matrix ==> |row| == |matrix[0]|\n        ensures |transposed| == |matrix[0]|\n        ensures forall i, j :: 0 <= i < |matrix| && 0 <= j < |matrix[0]| ==> transposed[j][i] == matrix[i][j]\n    {\n        var rows := |matrix|;\n        var cols := |matrix[0]|;\n        transposed := [];\n        for j := 0 to cols - 1\n            invariant 0 <= j <= cols\n            invariant |transposed| == j\n            invariant forall k, i :: 0 <= k < j && 0 <= i < rows ==> transposed[k][i] == matrix[i][k]\n        {\n            var newRow := [];\n            for i := 0 to rows - 1\n                invariant 0 <= i <= rows\n                invariant |newRow| == i\n                invariant forall k :: 0 <= k < i ==> newRow[k] == matrix[k][j]\n            {\n                newRow := newRow + [matrix[i][j]];\n            }\n            transposed := transposed + [newRow];\n        }\n    }\n\n    method IsSquare(matrix: seq<seq<int>>) returns (isSquare: bool)\n        requires |matrix| > 0 && |matrix[0]| > 0\n        requires forall row :: row in matrix ==> |row| == |matrix[0]|\n        ensures isSquare <==> |matrix| == |matrix[0]|\n    {\n        isSquare := |matrix| == |matrix[0]|;\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_385",
            "type": "program",
            "content": "class SudokuValidator {\n    var grid: array2<int>;\n    constructor(grid: array2<int>)\n        requires grid.Length0 == 9 && grid.Length1 == 9\n        ensures this.grid == grid\n    {\n        this.grid := grid;\n    }\n    method IsRowValid(row: int) returns (isValid: bool)\n        requires 0 <= row < 9\n        ensures isValid == (forall i, j :: 0 <= i < j < 9 ==> grid[row, i] != grid[row, j])\n    {\n        var seen := new bool[10];\n        isValid := true;\n        for i := 0 to 8 {\n            if grid[row, i] < 1 || grid[row, i] > 9 || seen[grid[row, i]] {\n                isValid := false;\n                return;\n            }\n            seen[grid[row, i]] := true;\n        }\n    }\n    method IsColumnValid(col: int) returns (isValid: bool)\n        requires 0 <= col < 9\n        ensures isValid == (forall i, j :: 0 <= i < j < 9 ==> grid[i, col] != grid[j, col])\n    {\n        var seen := new bool[10];\n        isValid := true;\n        for i := 0 to 8 {\n            if grid[i, col] < 1 || grid[i, col] > 9 || seen[grid[i, col]] {\n                isValid := false;\n                return;\n            }\n            seen[grid[i, col]] := true;\n        }\n    }\n    method IsSubgridValid(subgridRow: int, subgridCol: int) returns (isValid: bool)\n        requires 0 <= subgridRow < 3 && 0 <= subgridCol < 3\n        ensures isValid == (forall i, j :: 0 <= i < j < 9 ==> grid[subgridRow * 3 + i / 3, subgridCol * 3 + i % 3] != grid[subgridRow * 3 + j / 3, subgridCol * 3 + j % 3])\n    {\n        var seen := new bool[10];\n        isValid := true;\n        for i := 0 to 8\n            invariant 0 <= i <= 9\n            invariant forall k :: 0 <= k < i ==> 1 <= grid[subgridRow * 3 + k / 3, subgridCol * 3 + k % 3] <= 9\n            invariant forall k :: 0 <= k < i ==> !seen[grid[subgridRow * 3 + k / 3, subgridCol * 3 + k % 3]]\n            invariant forall k :: 0 <= k < i ==> seen[grid[subgridRow * 3 + k / 3, subgridCol * 3 + k % 3]] == true\n        {\n            var value := grid[subgridRow * 3 + i / 3, subgridCol * 3 + i % 3];\n            if value < 1 || value > 9 || seen[value] {\n                isValid := false;\n                return;\n            }\n            seen[value] := true;\n        }\n}\n}",
            "parents": [
                "node_254"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 43\n        for i := 0 to 8\n            invariant 0 <= i <= 9\n            invariant forall k :: 0 <= k < i ==> 1 <= grid[subgridRow * 3 + k / 3, subgridCol * 3 + k % 3] <= 9\n            invariant forall k :: 0 <= k < i ==> !seen[grid[subgridRow * 3 + k / 3, subgridCol * 3 + k % 3]]\n            invariant forall k :: 0 <= k < i ==> seen[grid[subgridRow * 3 + k / 3, subgridCol * 3 + k % 3]] == true\n        {\n            var value := grid[subgridRow * 3 + i / 3, subgridCol * 3 + i % 3];\n            if value < 1 || value > 9 || seen[value] {\n                isValid := false;\n                return;\n            }\n            seen[value] := true;\n        }\n// END DAFNY\n```"
        },
        {
            "id": "node_386",
            "type": "program",
            "content": "class VotingSystem {\n    var votes: array<int>;\n    constructor (numCandidates: int)\n        requires numCandidates > 0\n    {\n        votes := new int[numCandidates];\n    }\n    method Vote(candidate: int)\n        requires 0 <= candidate < votes.Length\n        modifies votes\n        ensures votes[candidate] == old(votes[candidate]) + 1\n    {\n        votes[candidate] := votes[candidate] + 1;\n    }\n    method GetWinner() returns (winner: int, isTie: bool)\n        requires votes.Length > 0\n        ensures 0 <= winner < votes.Length\n        ensures forall i: int :: 0 <= i < votes.Length ==> votes[winner] >= votes[i]\n        ensures isTie == (exists i: int :: 0 <= i < votes.Length && i != winner && votes[i] == votes[winner])\n    {\n        var maxVotes := votes[0];\n        winner := 0;\n        isTie := false;\n        for i := 1 to votes.Length - 1\n            invariant 0 <= winner < votes.Length\n            invariant 0 <= i <= votes.Length\n            invariant forall j: int :: 0 <= j < i ==> votes[winner] >= votes[j]\n            invariant maxVotes == votes[winner]\n            invariant isTie == (exists j: int :: 0 <= j < i && j != winner && votes[j] == maxVotes)\n        {\n            if votes[i] > maxVotes {\n                maxVotes := votes[i];\n                winner := i;\n                isTie := false;\n            } else if votes[i] == maxVotes && i != winner {\n                isTie := true;\n            }\n        }\n    }\n}",
            "parents": [
                "node_325"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 15\n    method GetWinner() returns (winner: int, isTie: bool)\n        requires votes.Length > 0\n        ensures 0 <= winner < votes.Length\n        ensures forall i: int :: 0 <= i < votes.Length ==> votes[winner] >= votes[i]\n        ensures isTie == (exists i: int :: 0 <= i < votes.Length && i != winner && votes[i] == votes[winner])\n    {\n        var maxVotes := votes[0];\n        winner := 0;\n        isTie := false;\n        for i := 1 to votes.Length - 1\n            invariant 0 <= winner < votes.Length\n            invariant 0 <= i <= votes.Length\n            invariant forall j: int :: 0 <= j < i ==> votes[winner] >= votes[j]\n            invariant maxVotes == votes[winner]\n            invariant isTie == (exists j: int :: 0 <= j < i && j != winner && votes[j] == maxVotes)\n        {\n            if votes[i] > maxVotes {\n                maxVotes := votes[i];\n                winner := i;\n                isTie := false;\n            } else if votes[i] == maxVotes && i != winner {\n                isTie := true;\n            }\n        }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_387",
            "type": "program",
            "content": "class BasicLoginSystem {\n    var storedUsername: string;\n    var storedPassword: string;\n    constructor(username: string, password: string) \n        requires username != \"\" && password != \"\"\n    {\n        storedUsername := username;\n        storedPassword := password;\n    }\n    method Authenticate(inputUsername: string, inputPassword: string) returns (isAuthenticated: bool)\n        ensures isAuthenticated == (inputUsername == storedUsername && inputPassword == storedPassword)\n    {\n        var attempts: int := 0;\n        while attempts < 3\n            invariant 0 <= attempts <= 3\n            invariant isAuthenticated == false\n            decreases 3 - attempts\n        {\n            if inputUsername == storedUsername && inputPassword == storedPassword {\n                isAuthenticated := true;\n                return;\n            } else {\n                attempts := attempts + 1;\n            }\n        }\n        isAuthenticated := false;\n    }\n}",
            "parents": [
                "node_360"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 10\n    method Authenticate(inputUsername: string, inputPassword: string) returns (isAuthenticated: bool)\n        ensures isAuthenticated == (inputUsername == storedUsername && inputPassword == storedPassword)\n    {\n        var attempts: int := 0;\n        while attempts < 3\n            invariant 0 <= attempts <= 3\n            invariant isAuthenticated == false\n            decreases 3 - attempts\n        {\n            if inputUsername == storedUsername && inputPassword == storedPassword {\n                isAuthenticated := true;\n                return;\n            } else {\n                attempts := attempts + 1;\n            }\n        }\n        isAuthenticated := false;\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_388",
            "type": "program",
            "content": "class FlightBookingSystem {\n    var totalSeats: nat;\n    var bookedSeats: nat;\n    constructor(totalSeats: nat)\n        requires totalSeats > 0\n        ensures this.totalSeats == totalSeats && this.bookedSeats == 0\n    {\n        this.totalSeats := totalSeats;\n        this.bookedSeats := 0;\n    }\n    method BookSeat() returns (success: bool)\n        ensures success ==> bookedSeats <= totalSeats\n        ensures !success ==> bookedSeats == totalSeats\n    {\n        if bookedSeats < totalSeats {\n            bookedSeats := bookedSeats + 1;\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n    method CancelSeat() returns (success: bool)\n        ensures success ==> bookedSeats >= 0\n        ensures !success ==> bookedSeats == 0\n    {\n        if bookedSeats > 0 {\n            bookedSeats := bookedSeats - 1;\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n    method BookMultipleSeats(n: nat) returns (success: bool)\n        requires n > 0\n        ensures success ==> bookedSeats <= totalSeats\n        ensures !success ==> bookedSeats + n > totalSeats\n    {\n        var i: nat := 0;\n        success := true;\n        while i < n\n            invariant 0 <= i <= n\n            invariant bookedSeats <= totalSeats\n            invariant success ==> bookedSeats + (n - i) <= totalSeats\n        {\n            if bookedSeats < totalSeats {\n                bookedSeats := bookedSeats + 1;\n            } else {\n                success := false;\n                break;\n            }\n            i := i + 1;\n        }\n    }\n    method CancelMultipleSeats(n: nat) returns (success: bool)\n        requires n > 0\n        ensures success ==> bookedSeats >= 0\n        ensures !success ==> bookedSeats < n\n    {\n        var i: nat := 0;\n        success := true;\n        while i < n\n            invariant 0 <= i <= n\n            invariant bookedSeats >= 0\n            invariant success ==> bookedSeats >= (n - i)\n        {\n            if bookedSeats > 0 {\n                bookedSeats := bookedSeats - 1;\n            } else {\n                success := false;\n                break;\n            }\n            i := i + 1;\n        }\n    }\n}",
            "parents": [
                "node_246"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 33\n    method BookMultipleSeats(n: nat) returns (success: bool)\n        requires n > 0\n        ensures success ==> bookedSeats <= totalSeats\n        ensures !success ==> bookedSeats + n > totalSeats\n    {\n        var i: nat := 0;\n        success := true;\n        while i < n\n            invariant 0 <= i <= n\n            invariant bookedSeats <= totalSeats\n            invariant success ==> bookedSeats + (n - i) <= totalSeats\n        {\n            if bookedSeats < totalSeats {\n                bookedSeats := bookedSeats + 1;\n            } else {\n                success := false;\n                break;\n            }\n            i := i + 1;\n        }\n    }\n\n    method CancelMultipleSeats(n: nat) returns (success: bool)\n        requires n > 0\n        ensures success ==> bookedSeats >= 0\n        ensures !success ==> bookedSeats < n\n    {\n        var i: nat := 0;\n        success := true;\n        while i < n\n            invariant 0 <= i <= n\n            invariant bookedSeats >= 0\n            invariant success ==> bookedSeats >= (n - i)\n        {\n            if bookedSeats > 0 {\n                bookedSeats := bookedSeats - 1;\n            } else {\n                success := false;\n                break;\n            }\n            i := i + 1;\n        }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_389",
            "type": "program",
            "content": "method WaysToMakeChange(amount: int, coins: seq<int>) returns (ways: int)\n    requires amount >= 0 && forall coin :: coin in coins ==> coin > 0\n    ensures ways >= 0\n{\n    var dp := new int[amount + 1];\n    dp[0] := 1;\n    // Loop invariant: \n    // 0 <= i <= |coins| \n    // && forall j :: 0 <= j <= amount ==> dp[j] >= 0\n    // && dp[j] represents the number of ways to make change for amount j using the first i coins\n    for i := 0 to |coins| - 1 {\n}\n}",
            "parents": [
                "node_301"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 11\n    for i := 0 to |coins| - 1 {\n// END DAFNY\n```"
        },
        {
            "id": "node_390",
            "type": "program",
            "content": "class Matrix2x2 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    constructor(a: int, b: int, c: int, d: int)\n        ensures this.a == a && this.b == b && this.c == c && this.d == d\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n    }\n    method Determinant() returns (det: int)\n        ensures det == a * d - b * c\n    {\n        det := a * d - b * c;\n    }\nmethod MultiplyByScalar(scalar: int) returns (result: Matrix2x2)\n    ensures result.a == this.a * scalar && result.b == this.b * scalar\n    ensures result.c == this.c * scalar && result.d == this.d * scalar\n{\n    result := new Matrix2x2(this.a * scalar, this.b * scalar, this.c * scalar, this.d * scalar);\n}\nmethod Transpose() returns (result: Matrix2x2)\n    ensures result.a == this.a && result.b == this.c\n    ensures result.c == this.b && result.d == this.d\n{\n    result := new Matrix2x2(this.a, this.c, this.b, this.d);\n}\nmethod Add(other: Matrix2x2) returns (result: Matrix2x2)\n    ensures result.a == this.a + other.a && result.b == this.b + other.b\n    ensures result.c == this.c + other.c && result.d == this.d + other.d\n{\n    result := new Matrix2x2(\n        this.a + other.a,\n        this.b + other.b,\n        this.c + other.c,\n        this.d + other.d\n    );\n}\nmethod Multiply(other: Matrix2x2) returns (result: Matrix2x2)\n    ensures result.a == this.a * other.a + this.b * other.c\n    ensures result.b == this.a * other.b + this.b * other.d\n    ensures result.c == this.c * other.a + this.d * other.c\n    ensures result.d == this.c * other.b + this.d * other.d\n{\n    var newA := this.a * other.a + this.b * other.c;\n    var newB := this.a * other.b + this.b * other.d;\n    var newC := this.c * other.a + this.d * other.c;\n    var newD := this.c * other.b + this.d * other.d;\n    result := new Matrix2x2(newA, newB, newC, newD);\n}\n}",
            "parents": [
                "node_351"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 42\nmethod Multiply(other: Matrix2x2) returns (result: Matrix2x2)\n    ensures result.a == this.a * other.a + this.b * other.c\n    ensures result.b == this.a * other.b + this.b * other.d\n    ensures result.c == this.c * other.a + this.d * other.c\n    ensures result.d == this.c * other.b + this.d * other.d\n{\n    var newA := this.a * other.a + this.b * other.c;\n    var newB := this.a * other.b + this.b * other.d;\n    var newC := this.c * other.a + this.d * other.c;\n    var newD := this.c * other.b + this.d * other.d;\n    result := new Matrix2x2(newA, newB, newC, newD);\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_391",
            "type": "program",
            "content": "class Matrix2x2 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    constructor(a: int, b: int, c: int, d: int)\n        ensures this.a == a && this.b == b && this.c == c && this.d == d\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n    }\n    method Determinant() returns (det: int)\n        ensures det == a * d - b * c\n    {\n        det := a * d - b * c;\n    }\nmethod MultiplyByScalar(scalar: int) returns (result: Matrix2x2)\n    ensures result.a == this.a * scalar\n    ensures result.b == this.b * scalar\n    ensures result.c == this.c * scalar\n    ensures result.d == this.d * scalar\n{\n    result := new Matrix2x2(this.a * scalar, this.b * scalar, this.c * scalar, this.d * scalar);\n}\nmethod Transpose() returns (result: Matrix2x2)\n    ensures result.a == this.a\n    ensures result.b == this.c\n    ensures result.c == this.b\n    ensures result.d == this.d\n{\n    result := new Matrix2x2(this.a, this.c, this.b, this.d);\n}\n}",
            "parents": [
                "node_101"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 19\nmethod MultiplyByScalar(scalar: int) returns (result: Matrix2x2)\n    ensures result.a == this.a * scalar\n    ensures result.b == this.b * scalar\n    ensures result.c == this.c * scalar\n    ensures result.d == this.d * scalar\n{\n    result := new Matrix2x2(this.a * scalar, this.b * scalar, this.c * scalar, this.d * scalar);\n}\n\nmethod Transpose() returns (result: Matrix2x2)\n    ensures result.a == this.a\n    ensures result.b == this.c\n    ensures result.c == this.b\n    ensures result.d == this.d\n{\n    result := new Matrix2x2(this.a, this.c, this.b, this.d);\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_392",
            "type": "program",
            "content": "class LeapYearChecker {\n    method IsLeapYear(year: int) returns (isLeap: bool)\n        requires year > 0\n        ensures isLeap == ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)\n    {\n        isLeap := false;\n        var i := 0;\n        while i < 3\n            invariant 0 <= i <= 3\n            invariant isLeap == ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0) || i == 0\n        {\n            if i == 0 {\n                if year % 4 != 0 {\n                    break;\n                }\n            } else if i == 1 {\n                if year % 100 == 0 {\n                    if year % 400 != 0 {\n                        break;\n                    }\n                }\n            } else if i == 2 {\n                isLeap := true;\n            }\n            i := i + 1;\n        }\n    }\n}",
            "parents": [
                "node_285"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 2\n    method IsLeapYear(year: int) returns (isLeap: bool)\n        requires year > 0\n        ensures isLeap == ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)\n    {\n        isLeap := false;\n        var i := 0;\n        while i < 3\n            invariant 0 <= i <= 3\n            invariant isLeap == ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0) || i == 0\n        {\n            if i == 0 {\n                if year % 4 != 0 {\n                    break;\n                }\n            } else if i == 1 {\n                if year % 100 == 0 {\n                    if year % 400 != 0 {\n                        break;\n                    }\n                }\n            } else if i == 2 {\n                isLeap := true;\n            }\n            i := i + 1;\n        }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_393",
            "type": "program",
            "content": "method WaysToMakeChange(amount: int, coins: seq<int>) returns (ways: int)\n    requires amount >= 0 && forall coin :: coin in coins ==> coin > 0\n    ensures ways >= 0\n{\n    var dp := new int[amount + 1];\n    dp[0] := 1;\n    // Loop invariant: \n    // 0 <= i <= |coins| \n    // && forall j :: 0 <= j <= amount ==> dp[j] >= 0\n    // && dp[j] represents the number of ways to make change for amount j using the first i coins\n    // && dp[0] == 1\n}",
            "parents": [
                "node_382"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 7\n    // Loop invariant: \n    // 0 <= i <= |coins| \n    // && forall j :: 0 <= j <= amount ==> dp[j] >= 0\n    // && dp[j] represents the number of ways to make change for amount j using the first i coins\n    // && dp[0] == 1\n// END DAFNY\n```"
        },
        {
            "id": "node_394",
            "type": "program",
            "content": "class LinearInequalitySolver {\n    method SolveInequality(a: int, b: int, c: int) returns (x: int)\n        requires a != 0\n        ensures a * x + b <= c\n    {\n        // A simple approach to find a solution for ax + b <= c\n        x := (c - b) / a;\n        if a * x + b > c {\n            x := x - 1;\n        }\n    }\n    method VerifySolution(a: int, b: int, c: int, x: int) returns (isValid: bool)\n        ensures isValid == (a * x + b <= c)\n    {\n        isValid := a * x + b <= c;\n    }\n}\n    method SolveStrictInequality(a: int, b: int, c: int) returns (x: int)\n        requires a != 0\n        ensures a * x + b < c\n    {\n        // A simple approach to find a solution for ax + b < c\n        x := (c - b) / a;\n        if a * x + b >= c {\n            x := x - 1;\n        }\n    }\n    method VerifyStrictSolution(a: int, b: int, c: int, x: int) returns (isValid: bool)\n        ensures isValid == (a * x + b < c)\n    {\n        isValid := a * x + b < c;\n    }\nmethod SolveInequalityWithLoop(a: int, b: int, c: int) returns (x: int)\n    requires a != 0\n    ensures a * x + b <= c\n{\n    var lowerBound := (c - b) / a;\n    x := lowerBound;\n    while a * x + b > c\n        invariant a * x + b > c\n        invariant x <= lowerBound\n        decreases x\n    {\n        x := x - 1;\n    }\n}\nmethod SolveStrictInequalityWithLoop(a: int, b: int, c: int) returns (x: int)\n    requires a != 0\n    ensures a * x + b < c\n{\n    var lowerBound := (c - b) / a;\n    x := lowerBound;\n    while a * x + b >= c\n        invariant a * x + b >= c\n        invariant x <= lowerBound\n        decreases x\n    {\n        x := x - 1;\n    }\n}",
            "parents": [
                "node_205"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 33\nmethod SolveInequalityWithLoop(a: int, b: int, c: int) returns (x: int)\n    requires a != 0\n    ensures a * x + b <= c\n{\n    var lowerBound := (c - b) / a;\n    x := lowerBound;\n    while a * x + b > c\n        invariant a * x + b > c\n        invariant x <= lowerBound\n        decreases x\n    {\n        x := x - 1;\n    }\n}\n\nmethod SolveStrictInequalityWithLoop(a: int, b: int, c: int) returns (x: int)\n    requires a != 0\n    ensures a * x + b < c\n{\n    var lowerBound := (c - b) / a;\n    x := lowerBound;\n    while a * x + b >= c\n        invariant a * x + b >= c\n        invariant x <= lowerBound\n        decreases x\n    {\n        x := x - 1;\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_395",
            "type": "program",
            "content": "class BasicLoginSystem {\n    var storedUsername: string;\n    var storedPassword: string;\n    constructor(username: string, password: string) \n        requires username != \"\" && password != \"\"\n    {\n        storedUsername := username;\n        storedPassword := password;\n    }\n    method Authenticate(inputUsername: string, inputPassword: string) returns (isAuthenticated: bool)\n        ensures isAuthenticated == (inputUsername == storedUsername && inputPassword == storedPassword)\n    {\n        var attempts: int := 0;\n        isAuthenticated := false;\n        while attempts < 3 && !isAuthenticated\n            invariant 0 <= attempts <= 3\n            invariant !isAuthenticated ==> attempts <= 3\n            decreases 3 - attempts\n        {\n            if inputUsername == storedUsername && inputPassword == storedPassword {\n                isAuthenticated := true;\n            } else {\n                attempts := attempts + 1;\n            }\n        }\n    }\n}",
            "parents": [
                "node_387"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 10\n    method Authenticate(inputUsername: string, inputPassword: string) returns (isAuthenticated: bool)\n        ensures isAuthenticated == (inputUsername == storedUsername && inputPassword == storedPassword)\n    {\n        var attempts: int := 0;\n        isAuthenticated := false;\n        while attempts < 3 && !isAuthenticated\n            invariant 0 <= attempts <= 3\n            invariant !isAuthenticated ==> attempts <= 3\n            decreases 3 - attempts\n        {\n            if inputUsername == storedUsername && inputPassword == storedPassword {\n                isAuthenticated := true;\n            } else {\n                attempts := attempts + 1;\n            }\n        }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_396",
            "type": "program",
            "content": "class Matrix3x3 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    var e: int;\n    var f: int;\n    var g: int;\n    var h: int;\n    var i: int;\n    constructor(a: int, b: int, c: int, d: int, e: int, f: int, g: int, h: int, i: int)\n        ensures this.a == a && this.b == b && this.c == c\n        ensures this.d == d && this.e == e && this.f == f\n        ensures this.g == g && this.h == h && this.i == i\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n        this.e := e;\n        this.f := f;\n        this.g := g;\n        this.h := h;\n        this.i := i;\n    }\n    method Determinant() returns (det: int)\n        ensures det == a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g)\n    {\n        det := a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g);\n    }\nmethod Transpose() returns (transposed: Matrix3x3)\n    ensures transposed.a == this.a && transposed.b == this.d && transposed.c == this.g\n    ensures transposed.d == this.b && transposed.e == this.e && transposed.f == this.h\n    ensures transposed.g == this.c && transposed.h == this.f && transposed.i == this.i\n{\n    transposed := new Matrix3x3(a, d, g, b, e, h, c, f, i);\n}\nmethod Multiply(other: Matrix3x3) returns (product: Matrix3x3)\n    ensures product.a == a * other.a + b * other.d + c * other.g\n    ensures product.b == a * other.b + b * other.e + c * other.h\n    ensures product.c == a * other.c + b * other.f + c * other.i\n    ensures product.d == d * other.a + e * other.d + f * other.g\n    ensures product.e == d * other.b + e * other.e + f * other.h\n    ensures product.f == d * other.c + e * other.f + f * other.i\n    ensures product.g == g * other.a + h * other.d + i * other.g\n    ensures product.h == g * other.b + h * other.e + i * other.h\n    ensures product.i == g * other.c + h * other.f + i * other.i\n{\n    product := new Matrix3x3(\n        a * other.a + b * other.d + c * other.g,\n        a * other.b + b * other.e + c * other.h,\n        a * other.c + b * other.f + c * other.i,\n        d * other.a + e * other.d + f * other.g,\n        d * other.b + e * other.e + f * other.h,\n        d * other.c + e * other.f + f * other.i,\n        g * other.a + h * other.d + i * other.g,\n        g * other.b + h * other.e + i * other.h,\n        g * other.c + h * other.f + i * other.i\n    );\n}\n}",
            "parents": [
                "node_155"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 31\nmethod Transpose() returns (transposed: Matrix3x3)\n    ensures transposed.a == this.a && transposed.b == this.d && transposed.c == this.g\n    ensures transposed.d == this.b && transposed.e == this.e && transposed.f == this.h\n    ensures transposed.g == this.c && transposed.h == this.f && transposed.i == this.i\n{\n    transposed := new Matrix3x3(a, d, g, b, e, h, c, f, i);\n}\n\nmethod Multiply(other: Matrix3x3) returns (product: Matrix3x3)\n    ensures product.a == a * other.a + b * other.d + c * other.g\n    ensures product.b == a * other.b + b * other.e + c * other.h\n    ensures product.c == a * other.c + b * other.f + c * other.i\n    ensures product.d == d * other.a + e * other.d + f * other.g\n    ensures product.e == d * other.b + e * other.e + f * other.h\n    ensures product.f == d * other.c + e * other.f + f * other.i\n    ensures product.g == g * other.a + h * other.d + i * other.g\n    ensures product.h == g * other.b + h * other.e + i * other.h\n    ensures product.i == g * other.c + h * other.f + i * other.i\n{\n    product := new Matrix3x3(\n        a * other.a + b * other.d + c * other.g,\n        a * other.b + b * other.e + c * other.h,\n        a * other.c + b * other.f + c * other.i,\n        d * other.a + e * other.d + f * other.g,\n        d * other.b + e * other.e + f * other.h,\n        d * other.c + e * other.f + f * other.i,\n        g * other.a + h * other.d + i * other.g,\n        g * other.b + h * other.e + i * other.h,\n        g * other.c + h * other.f + i * other.i\n    );\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_397",
            "type": "program",
            "content": "class Task {\n    var priority: int;\n    var description: string;\n    constructor(priority: int, description: string)\n        ensures this.priority == priority && this.description == description\n    {\n        this.priority := priority;\n        this.description := description;\n    }\n}\nclass TaskScheduler {\n    var tasks: seq<Task>;\n    constructor()\n        ensures tasks == []\n    {\n        tasks := [];\n    }\n    method AddTask(t: Task)\n        modifies tasks\n        ensures tasks == old(tasks) + [t]\n    {\n        tasks := tasks + [t];\n    }\n    method GetNextTask() returns (nextTask: Task?)\n        requires |tasks| > 0\n        ensures nextTask != null ==> forall t: Task :: t in tasks ==> nextTask.priority <= t.priority\n    {\n        var highestPriority := tasks[0].priority;\n        var index := 0;\n        for i := 1 to |tasks|\n            invariant 0 <= index < |tasks|\n            invariant 0 <= i <= |tasks|\n            invariant forall j: int :: 0 <= j < i ==> tasks[index].priority <= tasks[j].priority\n        {\n            if tasks[i].priority < highestPriority {\n                highestPriority := tasks[i].priority;\n                index := i;\n            }\n        }\n}\n}",
            "parents": [
                "node_134"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 30\n        for i := 1 to |tasks|\n            invariant 0 <= index < |tasks|\n            invariant 0 <= i <= |tasks|\n            invariant forall j: int :: 0 <= j < i ==> tasks[index].priority <= tasks[j].priority\n        {\n            if tasks[i].priority < highestPriority {\n                highestPriority := tasks[i].priority;\n                index := i;\n            }\n        }\n// END DAFNY\n```"
        },
        {
            "id": "node_398",
            "type": "program",
            "content": "class Book {\n    var title: string;\n    var isCheckedOut: bool;\n    constructor(title: string)\n        ensures this.title == title && !this.isCheckedOut\n    {\n        this.title := title;\n        this.isCheckedOut := false;\n    }\n    method CheckOut()\n        requires !isCheckedOut\n        ensures isCheckedOut\n    {\n        isCheckedOut := true;\n    }\n    method ReturnBook()\n        requires isCheckedOut\n        ensures !isCheckedOut\n    {\n        isCheckedOut := false;\n    }\n}\nclass Library {\n    var books: seq<Book>;\n    constructor()\n        ensures books == []\n    {\n        books := [];\n    }\n    method AddBook(b: Book)\n        ensures books == old(books) + [b]\n    {\n        books := books + [b];\n    }\n    method CheckOutBook(title: string) returns (success: bool)\n        ensures success ==> exists b: Book :: b in books && b.title == title && b.isCheckedOut\n        ensures !success ==> forall b: Book :: b in books && b.title == title ==> !b.isCheckedOut\n    {\n        success := false;\n        var i := 0;\n        while i < |books|\n            invariant 0 <= i <= |books|\n            invariant forall j: int :: 0 <= j < i ==> books[j].title != title || books[j].isCheckedOut\n        {\n            if books[i].title == title && !books[i].isCheckedOut {\n                books[i].CheckOut();\n                success := true;\n                return;\n            }\n            i := i + 1;\n        }\n    }\n}",
            "parents": [
                "node_142"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 35\n    method CheckOutBook(title: string) returns (success: bool)\n        ensures success ==> exists b: Book :: b in books && b.title == title && b.isCheckedOut\n        ensures !success ==> forall b: Book :: b in books && b.title == title ==> !b.isCheckedOut\n    {\n        success := false;\n        var i := 0;\n        while i < |books|\n            invariant 0 <= i <= |books|\n            invariant forall j: int :: 0 <= j < i ==> books[j].title != title || books[j].isCheckedOut\n        {\n            if books[i].title == title && !books[i].isCheckedOut {\n                books[i].CheckOut();\n                success := true;\n                return;\n            }\n            i := i + 1;\n        }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_399",
            "type": "program",
            "content": "class Employee {\n    var hoursWorked: int;\n    var payRate: int;\n    constructor(hoursWorked: int, payRate: int)\n        ensures this.hoursWorked == hoursWorked && this.payRate == payRate\n    {\n        this.hoursWorked := hoursWorked;\n        this.payRate := payRate;\n    }\n    method CalculateSalary() returns (salary: int)\n        ensures salary == hoursWorked * payRate\n    {\n        salary := hoursWorked * payRate;\n    }\nmethod CalculateSalaryWithOvertime() returns (salary: int)\n    ensures salary == hoursWorked * payRate + (if hoursWorked > 40 then (hoursWorked - 40) * (payRate / 2) else 0)\n{\n    var regularHours := if hoursWorked > 40 then 40 else hoursWorked;\n    var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n    salary := regularHours * payRate + overtimeHours * (payRate / 2);\n}\n}",
            "parents": [
                "node_118"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 15\nmethod CalculateSalaryWithOvertime() returns (salary: int)\n    ensures salary == hoursWorked * payRate + (if hoursWorked > 40 then (hoursWorked - 40) * (payRate / 2) else 0)\n{\n    var regularHours := if hoursWorked > 40 then 40 else hoursWorked;\n    var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n    salary := regularHours * payRate + overtimeHours * (payRate / 2);\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_400",
            "type": "program",
            "content": "class LeapYearChecker {\n    method IsLeapYear(year: int) returns (isLeap: bool)\n        requires year > 0\n        ensures isLeap == ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)\n    {\n        var isLeapTemp := false;\n        var i := 0;\n        while i < 3\n            invariant 0 <= i <= 3\n            invariant isLeapTemp == ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0 && i == 3))\n        {\n            if i == 0 && year % 4 != 0 {\n                break;\n            }\n            if i == 1 && year % 100 == 0 {\n                break;\n            }\n            if i == 2 && year % 400 == 0 {\n                isLeapTemp := true;\n            }\n            i := i + 1;\n        }\n        isLeap := isLeapTemp;\n}\n}",
            "parents": [
                "node_365"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 6\n        var isLeapTemp := false;\n        var i := 0;\n        while i < 3\n            invariant 0 <= i <= 3\n            invariant isLeapTemp == ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0 && i == 3))\n        {\n            if i == 0 && year % 4 != 0 {\n                break;\n            }\n            if i == 1 && year % 100 == 0 {\n                break;\n            }\n            if i == 2 && year % 400 == 0 {\n                isLeapTemp := true;\n            }\n            i := i + 1;\n        }\n        isLeap := isLeapTemp;\n// END DAFNY\n```"
        },
        {
            "id": "node_401",
            "type": "program",
            "content": "method Median(a: array<int>) returns (median: int)\n    requires a != null && a.Length > 0\n    ensures 0 <= median < a.Length\n    ensures forall i: int :: 0 <= i < a.Length ==> a[median] <= a[i] || a[median] >= a[i]\n{\n    var n := a.Length;\n    var sorted := new int[n];\n    // Copy the array\n    for i := 0 to n - 1\n        invariant 0 <= i <= n\n        invariant forall j: int :: 0 <= j < i ==> sorted[j] == a[j]\n    {\n        sorted[i] := a[i];\n    }\n    // Sort the array (simple insertion sort for demonstration)\n    // Sort the array (using bubble sort for demonstration)\n    for i := 0 to n - 1\n        invariant 0 <= i < n\n        invariant forall j: int, k: int :: 0 <= j < k < n - i ==> sorted[j] <= sorted[k]\n    {\n        for j := 0 to n - i - 2\n            invariant 0 <= j < n - i - 1\n            invariant forall k: int :: 0 <= k < j ==> sorted[k] <= sorted[k + 1]\n        {\n            if sorted[j] > sorted[j + 1] {\n                var temp := sorted[j];\n                sorted[j] := sorted[j + 1];\n                sorted[j + 1] := temp;\n            }\n        }\n    }\n}",
            "parents": [
                "node_300"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 16\n    // Sort the array (using bubble sort for demonstration)\n    for i := 0 to n - 1\n        invariant 0 <= i < n\n        invariant forall j: int, k: int :: 0 <= j < k < n - i ==> sorted[j] <= sorted[k]\n    {\n        for j := 0 to n - i - 2\n            invariant 0 <= j < n - i - 1\n            invariant forall k: int :: 0 <= k < j ==> sorted[k] <= sorted[k + 1]\n        {\n            if sorted[j] > sorted[j + 1] {\n                var temp := sorted[j];\n                sorted[j] := sorted[j + 1];\n                sorted[j + 1] := temp;\n            }\n        }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_402",
            "type": "program",
            "content": "class Matrix3x3 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    var e: int;\n    var f: int;\n    var g: int;\n    var h: int;\n    var i: int;\n    constructor(a: int, b: int, c: int, d: int, e: int, f: int, g: int, h: int, i: int)\n        ensures this.a == a && this.b == b && this.c == c\n        ensures this.d == d && this.e == e && this.f == f\n        ensures this.g == g && this.h == h && this.i == i\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n        this.e := e;\n        this.f := f;\n        this.g := g;\n        this.h := h;\n        this.i := i;\n    }\n    method Transpose() returns (transposed: Matrix3x3)\n        ensures transposed.a == a && transposed.b == d && transposed.c == g\n        ensures transposed.d == b && transposed.e == e && transposed.f == h\n        ensures transposed.g == c && transposed.h == f && transposed.i == i\n    {\n        transposed := new Matrix3x3(a, d, g, b, e, h, c, f, i);\n    }\nmethod Multiply(other: Matrix3x3) returns (product: Matrix3x3)\n    ensures product.a == a * other.a + b * other.d + c * other.g\n    ensures product.b == a * other.b + b * other.e + c * other.h\n    ensures product.c == a * other.c + b * other.f + c * other.i\n    ensures product.d == d * other.a + e * other.d + f * other.g\n    ensures product.e == d * other.b + e * other.e + f * other.h\n    ensures product.f == d * other.c + e * other.f + f * other.i\n    ensures product.g == g * other.a + h * other.d + i * other.g\n    ensures product.h == g * other.b + h * other.e + i * other.h\n    ensures product.i == g * other.c + h * other.f + i * other.i\n{\n    var newA := a * other.a + b * other.d + c * other.g;\n    var newB := a * other.b + b * other.e + c * other.h;\n    var newC := a * other.c + b * other.f + c * other.i;\n    var newD := d * other.a + e * other.d + f * other.g;\n    var newE := d * other.b + e * other.e + f * other.h;\n    var newF := d * other.c + e * other.f + f * other.i;\n    var newG := g * other.a + h * other.d + i * other.g;\n    var newH := g * other.b + h * other.e + i * other.h;\n    var newI := g * other.c + h * other.f + i * other.i;\n    product := new Matrix3x3(newA, newB, newC, newD, newE, newF, newG, newH, newI);\n}\nmethod Determinant() returns (det: int)\n    ensures det == a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g)\n{\n    det := a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g);\n}\nmethod IsIdentity() returns (isIdentity: bool)\n    ensures isIdentity == (a == 1 && e == 1 && i == 1 && b == 0 && c == 0 && d == 0 && f == 0 && g == 0 && h == 0)\n{\n    isIdentity := (a == 1 && e == 1 && i == 1 && b == 0 && c == 0 && d == 0 && f == 0 && g == 0 && h == 0);\n}\n}",
            "parents": [
                "node_370"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 55\nmethod Determinant() returns (det: int)\n    ensures det == a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g)\n{\n    det := a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g);\n}\n\nmethod IsIdentity() returns (isIdentity: bool)\n    ensures isIdentity == (a == 1 && e == 1 && i == 1 && b == 0 && c == 0 && d == 0 && f == 0 && g == 0 && h == 0)\n{\n    isIdentity := (a == 1 && e == 1 && i == 1 && b == 0 && c == 0 && d == 0 && f == 0 && g == 0 && h == 0);\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_403",
            "type": "program",
            "content": "class Matrix2x2 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    constructor(a: int, b: int, c: int, d: int)\n        ensures this.a == a && this.b == b && this.c == c && this.d == d\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n    }\n    method Determinant() returns (det: int)\n        ensures det == a * d - b * c\n    {\n        det := a * d - b * c;\n    }\nmethod MultiplyByScalar(scalar: int) returns (result: Matrix2x2)\n    ensures result.a == this.a * scalar\n    ensures result.b == this.b * scalar\n    ensures result.c == this.c * scalar\n    ensures result.d == this.d * scalar\n{\n    result := new Matrix2x2(this.a * scalar, this.b * scalar, this.c * scalar, this.d * scalar);\n}\nmethod Transpose() returns (result: Matrix2x2)\n    ensures result.a == this.a\n    ensures result.b == this.c\n    ensures result.c == this.b\n    ensures result.d == this.d\n{\n    result := new Matrix2x2(this.a, this.c, this.b, this.d);\n}\n}",
            "parents": [
                "node_202"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 19\nmethod MultiplyByScalar(scalar: int) returns (result: Matrix2x2)\n    ensures result.a == this.a * scalar\n    ensures result.b == this.b * scalar\n    ensures result.c == this.c * scalar\n    ensures result.d == this.d * scalar\n{\n    result := new Matrix2x2(this.a * scalar, this.b * scalar, this.c * scalar, this.d * scalar);\n}\n\nmethod Transpose() returns (result: Matrix2x2)\n    ensures result.a == this.a\n    ensures result.b == this.c\n    ensures result.c == this.b\n    ensures result.d == this.d\n{\n    result := new Matrix2x2(this.a, this.c, this.b, this.d);\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_404",
            "type": "program",
            "content": "class VotingSystem {\n    var votes: array<int>;\n    constructor(n: int)\n        requires n > 0\n        ensures votes.Length == n\n        ensures forall i :: 0 <= i < n ==> votes[i] == 0\n    {\n        votes := new int[n];\n    }\n    method CastVote(candidate: int, count: int)\n        requires 0 <= candidate < votes.Length\n        requires count > 0\n        modifies votes\n        ensures votes[candidate] == old(votes[candidate]) + count\n    {\n        votes[candidate] := votes[candidate] + count;\n    }\n}",
            "parents": [
                "node_220"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 10\n    method CastVote(candidate: int, count: int)\n        requires 0 <= candidate < votes.Length\n        requires count > 0\n        modifies votes\n        ensures votes[candidate] == old(votes[candidate]) + count\n    {\n        votes[candidate] := votes[candidate] + count;\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_405",
            "type": "program",
            "content": "class LoginSystem {\n    var username: string;\n    var password: string;\n    constructor(username: string, password: string)\n        ensures this.username == username && this.password == password\n    {\n        this.username := username;\n        this.password := password;\n    }\nmethod Authenticate(inputUsername: string, inputPassword: string) returns (isAuthenticated: bool)\n    ensures isAuthenticated == (inputUsername == username && inputPassword == password)\n{\n    isAuthenticated := false;\n    var attempts: int := 0;\n    while (attempts < 3)\n        invariant 0 <= attempts <= 3\n        decreases 3 - attempts\n    {\n        if inputUsername == username && inputPassword == password {\n            isAuthenticated := true;\n            break;\n        }\n        attempts := attempts + 1;\n    }\n}\n}",
            "parents": [
                "node_105"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 10\nmethod Authenticate(inputUsername: string, inputPassword: string) returns (isAuthenticated: bool)\n    ensures isAuthenticated == (inputUsername == username && inputPassword == password)\n{\n    isAuthenticated := false;\n    var attempts: int := 0;\n    while (attempts < 3)\n        invariant 0 <= attempts <= 3\n        decreases 3 - attempts\n    {\n        if inputUsername == username && inputPassword == password {\n            isAuthenticated := true;\n            break;\n        }\n        attempts := attempts + 1;\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_406",
            "type": "program",
            "content": "class Rectangle {\n    var x: int;\n    var y: int;\n    var width: int;\n    var height: int;\n    constructor(x: int, y: int, width: int, height: int)\n        requires width > 0 && height > 0\n        ensures this.x == x && this.y == y\n        ensures this.width == width && this.height == height\n    {\n        this.x := x;\n        this.y := y;\n        this.width := width;\n        this.height := height;\n    }\n    method Intersects(other: Rectangle) returns (intersects: bool)\n        ensures intersects == ((this.x < other.x + other.width) && (this.x + this.width > other.x) &&\n                               (this.y < other.y + other.height) && (this.y + this.height > other.y))\n    {\n        intersects := (this.x < other.x + other.width) && (this.x + this.width > other.x) &&\n                      (this.y < other.y + other.height) && (this.y + this.height > other.y);\n    }\n    method Area() returns (area: int)\n        ensures area == this.width * this.height\n    {\n        area := this.width * this.height;\n    }\n    method Scale(factor: int)\n        requires factor > 0\n        modifies this\n        ensures this.width == old(this.width) * factor\n        ensures this.height == old(this.height) * factor\n    {\n        this.width := this.width * factor;\n        this.height := this.height * factor;\n    }\n    method Translate(dx: int, dy: int)\n        modifies this\n        ensures this.x == old(this.x) + dx\n        ensures this.y == old(this.y) + dy\n    {\n        this.x := this.x + dx;\n        this.y := this.y + dy;\n    }\n}",
            "parents": [
                "node_115"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 24\n    method Area() returns (area: int)\n        ensures area == this.width * this.height\n    {\n        area := this.width * this.height;\n    }\n\n    method Scale(factor: int)\n        requires factor > 0\n        modifies this\n        ensures this.width == old(this.width) * factor\n        ensures this.height == old(this.height) * factor\n    {\n        this.width := this.width * factor;\n        this.height := this.height * factor;\n    }\n\n    method Translate(dx: int, dy: int)\n        modifies this\n        ensures this.x == old(this.x) + dx\n        ensures this.y == old(this.y) + dy\n    {\n        this.x := this.x + dx;\n        this.y := this.y + dy;\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_407",
            "type": "program",
            "content": "module PalindromeChecker {\n  method IsPalindrome(s: string) returns (isPalin: bool)\n    ensures isPalin <==> (forall i :: 0 <= i < |s| / 2 ==> s[i] == s[|s| - i - 1])\n  {\n    var n := |s|;\n    isPalin := true;\n    for i := 0 to n / 2\n      invariant 0 <= i <= n / 2\n      invariant isPalin ==> (forall j :: 0 <= j < i ==> s[j] == s[n - j - 1])\n    {\n      if s[i] != s[n - i - 1] {\n        isPalin := false;\n        break;\n      }\n    }\n}\n}",
            "parents": [
                "node_305"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 7\n    for i := 0 to n / 2\n      invariant 0 <= i <= n / 2\n      invariant isPalin ==> (forall j :: 0 <= j < i ==> s[j] == s[n - j - 1])\n    {\n      if s[i] != s[n - i - 1] {\n        isPalin := false;\n        break;\n      }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_408",
            "type": "program",
            "content": "class Sudoku {\n    var grid: array2<int>;\n    constructor(grid: array2<int>)\n        requires grid.Length0 == 9 && grid.Length1 == 9\n        ensures this.grid == grid\n    {\n        this.grid := grid;\n    }\n    method IsValidRow(row: int) returns (isValid: bool)\n        requires 0 <= row < 9\n        ensures isValid ==> (forall i, j :: 0 <= i < j < 9 ==> grid[row, i] != grid[row, j])\n    {\n        var seen := new bool[10];\n        isValid := true;\n        for i := 0 to 8 {\n            var num := grid[row, i];\n            if num < 1 || num > 9 || seen[num] {\n                isValid := false;\n                return;\n            }\n            seen[num] := true;\n        }\n    }\n    method IsValidColumn(col: int) returns (isValid: bool)\n        requires 0 <= col < 9\n        ensures isValid ==> (forall i, j :: 0 <= i < j < 9 ==> grid[i, col] != grid[j, col])\n    {\n        var seen := new bool[10];\n        isValid := true;\n        for i := 0 to 8 {\n            var num := grid[i, col];\n            if num < 1 || num > 9 || seen[num] {\n                isValid := false;\n                return;\n            }\n            seen[num] := true;\n        }\n    }\n    method IsValidSubgrid(subgridRow: int, subgridCol: int) returns (isValid: bool)\n        requires 0 <= subgridRow < 3 && 0 <= subgridCol < 3\n        ensures isValid ==> (forall i, j :: 0 <= i < j < 9 ==> grid[(subgridRow * 3) + (i / 3), (subgridCol * 3) + (i % 3)] != grid[(subgridRow * 3) + (j / 3), (subgridCol * 3) + (j % 3)])\n    {\n        var seen := new bool[10];\n        isValid := true;\n        for i := 0 to 8\n            invariant 0 <= i <= 9\n            invariant forall k :: 0 <= k < i ==> 1 <= grid[(subgridRow * 3) + (k / 3), (subgridCol * 3) + (k % 3)] <= 9 && seen[grid[(subgridRow * 3) + (k / 3), (subgridCol * 3) + (k % 3)]]\n        {\n            var num := grid[(subgridRow * 3) + (i / 3), (subgridCol * 3) + (i % 3)];\n            if num < 1 || num > 9 || seen[num] {\n                isValid := false;\n                return;\n            }\n            seen[num] := true;\n        }\n    }\n}",
            "parents": [
                "node_196"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 39\n    method IsValidSubgrid(subgridRow: int, subgridCol: int) returns (isValid: bool)\n        requires 0 <= subgridRow < 3 && 0 <= subgridCol < 3\n        ensures isValid ==> (forall i, j :: 0 <= i < j < 9 ==> grid[(subgridRow * 3) + (i / 3), (subgridCol * 3) + (i % 3)] != grid[(subgridRow * 3) + (j / 3), (subgridCol * 3) + (j % 3)])\n    {\n        var seen := new bool[10];\n        isValid := true;\n        for i := 0 to 8\n            invariant 0 <= i <= 9\n            invariant forall k :: 0 <= k < i ==> 1 <= grid[(subgridRow * 3) + (k / 3), (subgridCol * 3) + (k % 3)] <= 9 && seen[grid[(subgridRow * 3) + (k / 3), (subgridCol * 3) + (k % 3)]]\n        {\n            var num := grid[(subgridRow * 3) + (i / 3), (subgridCol * 3) + (i % 3)];\n            if num < 1 || num > 9 || seen[num] {\n                isValid := false;\n                return;\n            }\n            seen[num] := true;\n        }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_409",
            "type": "program",
            "content": "method GCD(a: nat, b: nat) returns (gcd: nat)\n    requires a > 0 && b > 0\n    ensures gcd > 0\n    ensures a % gcd == 0 && b % gcd == 0\n    ensures forall d: nat :: d > 0 && a % d == 0 && b % d == 0 ==> gcd >= d\n{\n    var x := a;\n    var y := b;\n    while y != 0\n        invariant x > 0\n        invariant y >= 0\n        invariant forall d: nat :: d > 0 && x % d == 0 && y % d == 0 ==> x >= d\n}",
            "parents": [
                "node_293"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 12\n        invariant forall d: nat :: d > 0 && x % d == 0 && y % d == 0 ==> x >= d\n// END DAFNY\n```"
        },
        {
            "id": "node_410",
            "type": "program",
            "content": "class MatrixOperations {\n    method Transpose(matrix: array2<int>) returns (transposed: array2<int>)\n        requires matrix.Length0 > 0 && matrix.Length1 > 0\n        ensures transposed.Length0 == matrix.Length1 && transposed.Length1 == matrix.Length0\n        ensures forall i: int, j: int :: 0 <= i < matrix.Length0 && 0 <= j < matrix.Length1 ==> transposed[j, i] == matrix[i, j]\n    {\n        var rows := matrix.Length0;\n        var cols := matrix.Length1;\n        transposed := new int[cols, rows];\n        for i := 0 to rows - 1\n            invariant 0 <= i <= rows\n            invariant forall k: int, l: int :: 0 <= k < i && 0 <= l < cols ==> transposed[l, k] == matrix[k, l]\n        {\n            for j := 0 to cols - 1\n                invariant 0 <= j <= cols\n                invariant forall l: int :: 0 <= l < j ==> transposed[l, i] == matrix[i, l]\n            {\n                transposed[j, i] := matrix[i, j];\n            }\n        }\n}\n}",
            "parents": [
                "node_144"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 10\n        for i := 0 to rows - 1\n            invariant 0 <= i <= rows\n            invariant forall k: int, l: int :: 0 <= k < i && 0 <= l < cols ==> transposed[l, k] == matrix[k, l]\n        {\n            for j := 0 to cols - 1\n                invariant 0 <= j <= cols\n                invariant forall l: int :: 0 <= l < j ==> transposed[l, i] == matrix[i, l]\n            {\n                transposed[j, i] := matrix[i, j];\n            }\n        }\n// END DAFNY\n```"
        },
        {
            "id": "node_411",
            "type": "program",
            "content": "class PayrollSystem {\n    method CalculateSalary(hoursWorked: int, payRate: int) returns (salary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        ensures salary >= 0\n    {\n        salary := hoursWorked * payRate;\n    }\n    method CalculateOvertimeSalary(hoursWorked: int, payRate: int, overtimeRate: int) returns (totalSalary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        requires overtimeRate >= payRate\n        ensures totalSalary >= 0\n    {\n        var regularHours := if hoursWorked > 40 then 40 else hoursWorked;\n        var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n        var regularSalary := regularHours * payRate;\n        var overtimeSalary := overtimeHours * overtimeRate;\n        totalSalary := regularSalary + overtimeSalary;\n    }\n}\n    method CalculateWeeklySalary(hoursWorked: int, payRate: int, overtimeRate: int) returns (weeklySalary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        requires overtimeRate >= payRate\n        ensures weeklySalary >= 0\n    {\n        var totalSalary := 0;\n        var weekHours := 0;\n        while (weekHours < hoursWorked)\n            invariant 0 <= weekHours <= hoursWorked\n            invariant totalSalary >= 0\n            invariant totalSalary == weekHours * payRate + (if weekHours > 40 then (weekHours - 40) * (overtimeRate - payRate) else 0)\n        {\n            if (weekHours < 40) {\n                totalSalary := totalSalary + payRate;\n            } else {\n                totalSalary := totalSalary + overtimeRate;\n            }\n            weekHours := weekHours + 1;\n        }\n        weeklySalary := totalSalary;\n    }",
            "parents": [
                "node_207"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 22\n    method CalculateWeeklySalary(hoursWorked: int, payRate: int, overtimeRate: int) returns (weeklySalary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        requires overtimeRate >= payRate\n        ensures weeklySalary >= 0\n    {\n        var totalSalary := 0;\n        var weekHours := 0;\n        while (weekHours < hoursWorked)\n            invariant 0 <= weekHours <= hoursWorked\n            invariant totalSalary >= 0\n            invariant totalSalary == weekHours * payRate + (if weekHours > 40 then (weekHours - 40) * (overtimeRate - payRate) else 0)\n        {\n            if (weekHours < 40) {\n                totalSalary := totalSalary + payRate;\n            } else {\n                totalSalary := totalSalary + overtimeRate;\n            }\n            weekHours := weekHours + 1;\n        }\n        weeklySalary := totalSalary;\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_412",
            "type": "program",
            "content": "class PayrollSystem {\n    method CalculateSalary(hoursWorked: int, payRate: int) returns (salary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        ensures salary >= 0\n    {\n        salary := hoursWorked * payRate;\n    }\n    method CalculateOvertimeSalary(hoursWorked: int, payRate: int, overtimeRate: int) returns (totalSalary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        requires overtimeRate >= payRate\n        ensures totalSalary >= 0\n    {\n        var regularHours := if hoursWorked > 40 then 40 else hoursWorked;\n        var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n        var regularSalary := regularHours * payRate;\n        var overtimeSalary := overtimeHours * overtimeRate;\n        totalSalary := regularSalary + overtimeSalary;\n    }\n    method CalculateWeeklySalaryWithBonus(hoursWorked: int, payRate: int, overtimeRate: int, bonus: int) returns (weeklySalary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        requires overtimeRate >= payRate\n        requires bonus >= 0\n        ensures weeklySalary >= 0\n    {\n        var totalHours := hoursWorked;\n        var totalSalary := 0;\n        var regularHours := if hoursWorked > 40 then 40 else hoursWorked;\n        var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n        var regularSalary := regularHours * payRate;\n        var overtimeSalary := overtimeHours * overtimeRate;\n        var baseSalary := regularSalary + overtimeSalary;\n        weeklySalary := baseSalary + bonus;\n        // Loop to simulate weekly salary calculation over multiple weeks\n        var weeks := 4;\n        var accumulatedSalary := 0;\n        while weeks > 0\n            invariant weeks >= 0\n            invariant accumulatedSalary >= 0\n        {\n            accumulatedSalary := accumulatedSalary + weeklySalary;\n            weeks := weeks - 1;\n        }\n        weeklySalary := accumulatedSalary;\n    }\n}",
            "parents": [
                "node_363"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 21\n    method CalculateWeeklySalaryWithBonus(hoursWorked: int, payRate: int, overtimeRate: int, bonus: int) returns (weeklySalary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        requires overtimeRate >= payRate\n        requires bonus >= 0\n        ensures weeklySalary >= 0\n    {\n        var totalHours := hoursWorked;\n        var totalSalary := 0;\n        var regularHours := if hoursWorked > 40 then 40 else hoursWorked;\n        var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n        var regularSalary := regularHours * payRate;\n        var overtimeSalary := overtimeHours * overtimeRate;\n        var baseSalary := regularSalary + overtimeSalary;\n        weeklySalary := baseSalary + bonus;\n\n        // Loop to simulate weekly salary calculation over multiple weeks\n        var weeks := 4;\n        var accumulatedSalary := 0;\n        while weeks > 0\n            invariant weeks >= 0\n            invariant accumulatedSalary >= 0\n        {\n            accumulatedSalary := accumulatedSalary + weeklySalary;\n            weeks := weeks - 1;\n        }\n        weeklySalary := accumulatedSalary;\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_413",
            "type": "program",
            "content": "class Matrix3x3 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    var e: int;\n    var f: int;\n    var g: int;\n    var h: int;\n    var i: int;\n    constructor(a: int, b: int, c: int, d: int, e: int, f: int, g: int, h: int, i: int)\n        ensures this.a == a && this.b == b && this.c == c\n        ensures this.d == d && this.e == e && this.f == f\n        ensures this.g == g && this.h == h && this.i == i\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n        this.e := e;\n        this.f := f;\n        this.g := g;\n        this.h := h;\n        this.i := i;\n    }\n    method Transpose() returns (transposed: Matrix3x3)\n        ensures transposed.a == a && transposed.b == d && transposed.c == g\n        ensures transposed.d == b && transposed.e == e && transposed.f == h\n        ensures transposed.g == c && transposed.h == f && transposed.i == i\n    {\n        transposed := new Matrix3x3(a, d, g, b, e, h, c, f, i);\n    }\nmethod Multiply(other: Matrix3x3) returns (product: Matrix3x3)\n    ensures product.a == a * other.a + b * other.d + c * other.g\n    ensures product.b == a * other.b + b * other.e + c * other.h\n    ensures product.c == a * other.c + b * other.f + c * other.i\n    ensures product.d == d * other.a + e * other.d + f * other.g\n    ensures product.e == d * other.b + e * other.e + f * other.h\n    ensures product.f == d * other.c + e * other.f + f * other.i\n    ensures product.g == g * other.a + h * other.d + i * other.g\n    ensures product.h == g * other.b + h * other.e + i * other.h\n    ensures product.i == g * other.c + h * other.f + i * other.i\n{\n    var p_a := a * other.a + b * other.d + c * other.g;\n    var p_b := a * other.b + b * other.e + c * other.h;\n    var p_c := a * other.c + b * other.f + c * other.i;\n    var p_d := d * other.a + e * other.d + f * other.g;\n    var p_e := d * other.b + e * other.e + f * other.h;\n    var p_f := d * other.c + e * other.f + f * other.i;\n    var p_g := g * other.a + h * other.d + i * other.g;\n    var p_h := g * other.b + h * other.e + i * other.h;\n    var p_i := g * other.c + h * other.f + i * other.i;\n    product := new Matrix3x3(p_a, p_b, p_c, p_d, p_e, p_f, p_g, p_h, p_i);\n}\nmethod Determinant() returns (det: int)\n    ensures det == a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g)\n{\n    det := a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g);\n}\nmethod IsIdentity() returns (isIdentity: bool)\n    ensures isIdentity == (a == 1 && b == 0 && c == 0 &&\n                           d == 0 && e == 1 && f == 0 &&\n                           g == 0 && h == 0 && i == 1)\n{\n    isIdentity := (a == 1 && b == 0 && c == 0 &&\n                   d == 0 && e == 1 && f == 0 &&\n                   g == 0 && h == 0 && i == 1);\n}\n}",
            "parents": [
                "node_243"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 55\nmethod Determinant() returns (det: int)\n    ensures det == a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g)\n{\n    det := a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g);\n}\n\nmethod IsIdentity() returns (isIdentity: bool)\n    ensures isIdentity == (a == 1 && b == 0 && c == 0 &&\n                           d == 0 && e == 1 && f == 0 &&\n                           g == 0 && h == 0 && i == 1)\n{\n    isIdentity := (a == 1 && b == 0 && c == 0 &&\n                   d == 0 && e == 1 && f == 0 &&\n                   g == 0 && h == 0 && i == 1);\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_414",
            "type": "program",
            "content": "class FlightBookingSystem {\n    var totalSeats: nat;\n    var bookedSeats: nat;\n    constructor(totalSeats: nat)\n        requires totalSeats > 0\n        ensures this.totalSeats == totalSeats && this.bookedSeats == 0\n    {\n        this.totalSeats := totalSeats;\n        this.bookedSeats := 0;\n    }\n    method BookSeat() returns (success: bool)\n        ensures success ==> bookedSeats <= totalSeats\n        ensures !success ==> bookedSeats == totalSeats\n    {\n        if bookedSeats < totalSeats {\n            bookedSeats := bookedSeats + 1;\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n    method CancelSeat() returns (success: bool)\n        ensures success ==> bookedSeats >= 0\n        ensures !success ==> bookedSeats == 0\n    {\n        if bookedSeats > 0 {\n            bookedSeats := bookedSeats - 1;\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n    method BookMultipleSeats(n: nat) returns (success: bool)\n        requires n > 0\n        ensures success ==> bookedSeats <= totalSeats\n        ensures !success ==> bookedSeats + n > totalSeats\n    {\n        var i := 0;\n        success := true;\n        while i < n\n            invariant 0 <= i <= n\n            invariant bookedSeats <= totalSeats\n            invariant success ==> bookedSeats + i <= totalSeats\n            invariant !success ==> bookedSeats + i > totalSeats\n        {\n            if bookedSeats < totalSeats {\n                bookedSeats := bookedSeats + 1;\n            } else {\n                success := false;\n                break;\n            }\n            i := i + 1;\n        }\n    }\n}",
            "parents": [
                "node_250"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 33\n    method BookMultipleSeats(n: nat) returns (success: bool)\n        requires n > 0\n        ensures success ==> bookedSeats <= totalSeats\n        ensures !success ==> bookedSeats + n > totalSeats\n    {\n        var i := 0;\n        success := true;\n        while i < n\n            invariant 0 <= i <= n\n            invariant bookedSeats <= totalSeats\n            invariant success ==> bookedSeats + i <= totalSeats\n            invariant !success ==> bookedSeats + i > totalSeats\n        {\n            if bookedSeats < totalSeats {\n                bookedSeats := bookedSeats + 1;\n            } else {\n                success := false;\n                break;\n            }\n            i := i + 1;\n        }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_415",
            "type": "program",
            "content": "class CurrencyConverter {\n    var exchangeRate: real;\n    constructor(rate: real)\n        requires rate > 0.0\n        ensures this.exchangeRate == rate\n    {\n        this.exchangeRate := rate;\n    }\n    method ConvertWithFee(amount: real, feePercentage: real) returns (convertedAmount: real)\n        requires amount >= 0.0\n        requires feePercentage >= 0.0 && feePercentage <= 100.0\n        ensures convertedAmount == amount * exchangeRate * (1.0 - feePercentage / 100.0)\n    {\n        var feeFactor := 1.0 - feePercentage / 100.0;\n        convertedAmount := amount * exchangeRate * feeFactor;\n    }\n}",
            "parents": [
                "node_119"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 9\n    method ConvertWithFee(amount: real, feePercentage: real) returns (convertedAmount: real)\n        requires amount >= 0.0\n        requires feePercentage >= 0.0 && feePercentage <= 100.0\n        ensures convertedAmount == amount * exchangeRate * (1.0 - feePercentage / 100.0)\n    {\n        var feeFactor := 1.0 - feePercentage / 100.0;\n        convertedAmount := amount * exchangeRate * feeFactor;\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_416",
            "type": "program",
            "content": "class FlightBookingSystem {\n    var totalSeats: nat;\n    var bookedSeats: nat;\n    constructor(totalSeats: nat)\n        requires totalSeats > 0\n        ensures this.totalSeats == totalSeats && this.bookedSeats == 0\n    {\n        this.totalSeats := totalSeats;\n        this.bookedSeats := 0;\n    }\n    method BookSeat() returns (success: bool)\n        ensures success ==> bookedSeats <= totalSeats\n        ensures !success ==> bookedSeats == totalSeats\n    {\n        if bookedSeats < totalSeats {\n            bookedSeats := bookedSeats + 1;\n            success := true;\n        } else {\n            success := false;\n        }\n    }\nmethod CancelSeat() returns (success: bool)\n    ensures success ==> bookedSeats >= 0\n    ensures !success ==> bookedSeats == 0\n{\n    if bookedSeats > 0 {\n        bookedSeats := bookedSeats - 1;\n        success := true;\n    } else {\n        success := false;\n    }\n}\nmethod BookMultipleSeats(n: nat) returns (success: bool)\n    requires n > 0\n    ensures success ==> bookedSeats <= totalSeats\n    ensures !success ==> bookedSeats + n > totalSeats\n{\n    var i: nat := 0;\n    success := true;\n    while i < n\n        invariant 0 <= i <= n\n        invariant bookedSeats <= totalSeats\n        invariant success ==> bookedSeats + (n - i) <= totalSeats\n    {\n        if bookedSeats < totalSeats {\n            bookedSeats := bookedSeats + 1;\n        } else {\n            success := false;\n            break;\n        }\n        i := i + 1;\n    }\n}\n}",
            "parents": [
                "node_362"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 33\nmethod BookMultipleSeats(n: nat) returns (success: bool)\n    requires n > 0\n    ensures success ==> bookedSeats <= totalSeats\n    ensures !success ==> bookedSeats + n > totalSeats\n{\n    var i: nat := 0;\n    success := true;\n    while i < n\n        invariant 0 <= i <= n\n        invariant bookedSeats <= totalSeats\n        invariant success ==> bookedSeats + (n - i) <= totalSeats\n    {\n        if bookedSeats < totalSeats {\n            bookedSeats := bookedSeats + 1;\n        } else {\n            success := false;\n            break;\n        }\n        i := i + 1;\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_417",
            "type": "program",
            "content": "class City {\n    var id: int;\n    constructor(id: int)\n        ensures this.id == id\n    {\n        this.id := id;\n    }\n}\nclass Tour {\n    var cities: seq<City>;\n    constructor(cities: seq<City>)\n        ensures this.cities == cities\n    {\n        this.cities := cities;\n    }\nmethod IsValidTour() returns (isValid: bool)\n    ensures isValid == (|cities| > 1 && cities[0] == cities[|cities| - 1])\n{\n    isValid := false;\n    if |cities| > 1 {\n        var firstCity := cities[0];\n        var lastCity := cities[|cities| - 1];\n        var i := 0;\n        while i < |cities| - 1\n            invariant 0 <= i <= |cities| - 1\n            invariant cities[0] == firstCity\n            invariant cities[|cities| - 1] == lastCity\n            invariant isValid == (firstCity == lastCity)\n        {\n            if cities[i] == lastCity {\n                isValid := true;\n                break;\n            }\n            i := i + 1;\n        }\n    }\n}\n}",
            "parents": [
                "node_218"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 16\nmethod IsValidTour() returns (isValid: bool)\n    ensures isValid == (|cities| > 1 && cities[0] == cities[|cities| - 1])\n{\n    isValid := false;\n    if |cities| > 1 {\n        var firstCity := cities[0];\n        var lastCity := cities[|cities| - 1];\n        var i := 0;\n        while i < |cities| - 1\n            invariant 0 <= i <= |cities| - 1\n            invariant cities[0] == firstCity\n            invariant cities[|cities| - 1] == lastCity\n            invariant isValid == (firstCity == lastCity)\n        {\n            if cities[i] == lastCity {\n                isValid := true;\n                break;\n            }\n            i := i + 1;\n        }\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_418",
            "type": "program",
            "content": "method WaysToMakeChange(amount: int, coins: seq<int>) returns (ways: int)\n    requires amount >= 0 && forall coin :: coin in coins ==> coin > 0\n    ensures ways >= 0\n{\n    var dp := new int[amount + 1];\n    dp[0] := 1;\n    // Loop invariant: \n    // 0 <= i <= |coins| \n    // && forall j :: 0 <= j <= amount ==> dp[j] >= 0\n    // && dp[j] represents the number of ways to make change for amount j using the first i coins\n    // && dp[0] == 1\n    for i := 0 to |coins| - 1 {\n        var coin := coins[i];\n        // Loop invariant: \n        // 0 <= i <= |coins| \n        // && forall j :: 0 <= j <= amount ==> dp[j] >= 0\n        // && dp[j] represents the number of ways to make change for amount j using the first i coins\n        // && dp[0] == 1\n        for j := coin to amount {\n            dp[j] := dp[j] + dp[j - coin];\n        }\n    }\n    ways := dp[amount];\n}",
            "parents": [
                "node_393"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 12\n    for i := 0 to |coins| - 1 {\n        var coin := coins[i];\n        // Loop invariant: \n        // 0 <= i <= |coins| \n        // && forall j :: 0 <= j <= amount ==> dp[j] >= 0\n        // && dp[j] represents the number of ways to make change for amount j using the first i coins\n        // && dp[0] == 1\n        for j := coin to amount {\n            dp[j] := dp[j] + dp[j - coin];\n        }\n    }\n    ways := dp[amount];\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_419",
            "type": "program",
            "content": "class Matrix2x2 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    constructor(a: int, b: int, c: int, d: int)\n        ensures this.a == a && this.b == b && this.c == c && this.d == d\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n    }\n    method Determinant() returns (det: int)\n        ensures det == a * d - b * c\n    {\n        det := a * d - b * c;\n    }\nmethod MultiplyByScalar(scalar: int) returns (result: Matrix2x2)\n    ensures result.a == this.a * scalar\n    ensures result.b == this.b * scalar\n    ensures result.c == this.c * scalar\n    ensures result.d == this.d * scalar\n{\n    result := new Matrix2x2(this.a * scalar, this.b * scalar, this.c * scalar, this.d * scalar);\n}\nmethod Transpose() returns (result: Matrix2x2)\n    ensures result.a == this.a\n    ensures result.b == this.c\n    ensures result.c == this.b\n    ensures result.d == this.d\n{\n    result := new Matrix2x2(this.a, this.c, this.b, this.d);\n}\n}",
            "parents": [
                "node_202"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 19\nmethod MultiplyByScalar(scalar: int) returns (result: Matrix2x2)\n    ensures result.a == this.a * scalar\n    ensures result.b == this.b * scalar\n    ensures result.c == this.c * scalar\n    ensures result.d == this.d * scalar\n{\n    result := new Matrix2x2(this.a * scalar, this.b * scalar, this.c * scalar, this.d * scalar);\n}\n\nmethod Transpose() returns (result: Matrix2x2)\n    ensures result.a == this.a\n    ensures result.b == this.c\n    ensures result.c == this.b\n    ensures result.d == this.d\n{\n    result := new Matrix2x2(this.a, this.c, this.b, this.d);\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_420",
            "type": "program",
            "content": "class Sudoku {\n    var grid: array2<int>;\n    constructor(grid: array2<int>)\n        requires grid.Length0 == 9 && grid.Length1 == 9\n        ensures this.grid == grid\n    {\n        this.grid := grid;\n    }\n    method IsValidRow(row: int) returns (isValid: bool)\n        requires 0 <= row < 9\n        ensures isValid ==> (forall i, j :: 0 <= i < j < 9 ==> grid[row, i] != grid[row, j])\n    {\n        var seen := new bool[10];\n        isValid := true;\n        for i := 0 to 8 {\n            var num := grid[row, i];\n            if num < 1 || num > 9 || seen[num] {\n                isValid := false;\n                return;\n            }\n            seen[num] := true;\n        }\n    }\n    method IsValidColumn(col: int) returns (isValid: bool)\n        requires 0 <= col < 9\n        ensures isValid ==> (forall i, j :: 0 <= i < j < 9 ==> grid[i, col] != grid[j, col])\n    {\n        var seen := new bool[10];\n        isValid := true;\n        for i := 0 to 8 {\n            var num := grid[i, col];\n            if num < 1 || num > 9 || seen[num] {\n                isValid := false;\n                return;\n            }\n            seen[num] := true;\n        }\n    }\n    method IsValidSubgrid(subgridRow: int, subgridCol: int) returns (isValid: bool)\n        requires 0 <= subgridRow < 3 && 0 <= subgridCol < 3\n        ensures isValid ==> (forall i, j :: 0 <= i < j < 9 ==> grid[subgridRow * 3 + i / 3, subgridCol * 3 + i % 3] != grid[subgridRow * 3 + j / 3, subgridCol * 3 + j % 3])\n    {\n        var seen := new bool[10];\n        isValid := true;\n        for i := 0 to 8\n            invariant 0 <= i <= 9\n            invariant forall k :: 0 <= k < i ==> 1 <= grid[subgridRow * 3 + k / 3, subgridCol * 3 + k % 3] <= 9\n            invariant forall k :: 0 <= k < i ==> seen[grid[subgridRow * 3 + k / 3, subgridCol * 3 + k % 3]]\n            invariant forall k :: 0 <= k < i ==> (forall l :: 0 <= l < k ==> grid[subgridRow * 3 + k / 3, subgridCol * 3 + k % 3] != grid[subgridRow * 3 + l / 3, subgridCol * 3 + l % 3])\n        {\n            var num := grid[subgridRow * 3 + i / 3, subgridCol * 3 + i % 3];\n            if num < 1 || num > 9 || seen[num] {\n                isValid := false;\n                return;\n            }\n            seen[num] := true;\n        }\n}\n}",
            "parents": [
                "node_352"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 45\n        for i := 0 to 8\n            invariant 0 <= i <= 9\n            invariant forall k :: 0 <= k < i ==> 1 <= grid[subgridRow * 3 + k / 3, subgridCol * 3 + k % 3] <= 9\n            invariant forall k :: 0 <= k < i ==> seen[grid[subgridRow * 3 + k / 3, subgridCol * 3 + k % 3]]\n            invariant forall k :: 0 <= k < i ==> (forall l :: 0 <= l < k ==> grid[subgridRow * 3 + k / 3, subgridCol * 3 + k % 3] != grid[subgridRow * 3 + l / 3, subgridCol * 3 + l % 3])\n        {\n            var num := grid[subgridRow * 3 + i / 3, subgridCol * 3 + i % 3];\n            if num < 1 || num > 9 || seen[num] {\n                isValid := false;\n                return;\n            }\n            seen[num] := true;\n        }\n// END DAFNY\n```"
        },
        {
            "id": "node_421",
            "type": "program",
            "content": "class PayrollSystem {\n    method CalculateSalary(hoursWorked: int, payRate: int) returns (salary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        ensures salary >= 0\n    {\n        salary := hoursWorked * payRate;\n    }\n    method CalculateOvertimeSalary(hoursWorked: int, payRate: int, overtimeRate: int) returns (totalSalary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        requires overtimeRate >= payRate\n        ensures totalSalary >= 0\n    {\n        var regularHours := if hoursWorked > 40 then 40 else hoursWorked;\n        var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n        var regularSalary := regularHours * payRate;\n        var overtimeSalary := overtimeHours * overtimeRate;\n        totalSalary := regularSalary + overtimeSalary;\n    }\n    method CalculateWeeklySalary(hoursWorked: int, payRate: int, overtimeRate: int) returns (weeklySalary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        requires overtimeRate >= payRate\n        ensures weeklySalary >= 0\n    {\n        var totalHours := hoursWorked;\n        var totalPay := 0;\n        var i := 0;\n        while i < totalHours\n            invariant 0 <= i <= totalHours\n            invariant totalPay >= 0\n        {\n            if i < 40 {\n                totalPay := totalPay + payRate;\n            } else {\n                totalPay := totalPay + overtimeRate;\n            }\n            i := i + 1;\n        }\n        weeklySalary := totalPay;\n    }\n}",
            "parents": [
                "node_123"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 21\n    method CalculateWeeklySalary(hoursWorked: int, payRate: int, overtimeRate: int) returns (weeklySalary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        requires overtimeRate >= payRate\n        ensures weeklySalary >= 0\n    {\n        var totalHours := hoursWorked;\n        var totalPay := 0;\n        var i := 0;\n        while i < totalHours\n            invariant 0 <= i <= totalHours\n            invariant totalPay >= 0\n        {\n            if i < 40 {\n                totalPay := totalPay + payRate;\n            } else {\n                totalPay := totalPay + overtimeRate;\n            }\n            i := i + 1;\n        }\n        weeklySalary := totalPay;\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_422",
            "type": "program",
            "content": "method EuclideanGCD(a: nat, b: nat) returns (gcd: nat)\n    requires a > 0 && b > 0\n    ensures gcd > 0\n    ensures a % gcd == 0 && b % gcd == 0\n    ensures forall d: nat :: d > 0 && a % d == 0 && b % d == 0 ==> gcd >= d\n{\n    var x := a;\n    var y := b;\n    while y != 0\n        invariant x > 0\n        invariant y >= 0\n        invariant gcd > 0\n        invariant x % y == x % gcd\n        decreases y\n    {\n        var temp := y;\n        y := x % y;\n        x := temp;\n    }\n    gcd := x;\n}",
            "parents": [
                "node_373"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 12\n        invariant gcd > 0\n        invariant x % y == x % gcd\n        decreases y\n    {\n        var temp := y;\n        y := x % y;\n        x := temp;\n    }\n    gcd := x;\n// END DAFNY\n```"
        },
        {
            "id": "node_423",
            "type": "program",
            "content": "method Median(a: array<int>) returns (median: int)\n    requires a != null && a.Length > 0\n    ensures 0 <= median < a.Length\n    ensures forall i: int :: 0 <= i < a.Length ==> a[median] <= a[i] || a[median] >= a[i]\n{\n    var n := a.Length;\n    var sorted := new int[n];\n    // Copy the array\n    for i := 0 to n - 1\n        invariant 0 <= i <= n\n        invariant forall j: int :: 0 <= j < i ==> sorted[j] == a[j]\n    {\n        sorted[i] := a[i];\n    }\n    // Sort the array (simple insertion sort for demonstration)\n    // Sort the array (using selection sort for demonstration)\n    for i := 0 to n - 1\n        invariant 0 <= i <= n\n        invariant forall j: int, k: int :: 0 <= j < k < n ==> sorted[j] <= sorted[k]\n    {\n        var minIndex := i;\n        for j := i + 1 to n - 1\n            invariant i + 1 <= j <= n\n            invariant i <= minIndex < n\n            invariant forall k: int :: i <= k < j ==> sorted[minIndex] <= sorted[k]\n        {\n            if sorted[j] < sorted[minIndex] {\n                minIndex := j;\n            }\n        }\n        if minIndex != i {\n            var temp := sorted[i];\n            sorted[i] := sorted[minIndex];\n            sorted[minIndex] := temp;\n        }\n    }\n}",
            "parents": [
                "node_401"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 16\n    // Sort the array (using selection sort for demonstration)\n    for i := 0 to n - 1\n        invariant 0 <= i <= n\n        invariant forall j: int, k: int :: 0 <= j < k < n ==> sorted[j] <= sorted[k]\n    {\n        var minIndex := i;\n        for j := i + 1 to n - 1\n            invariant i + 1 <= j <= n\n            invariant i <= minIndex < n\n            invariant forall k: int :: i <= k < j ==> sorted[minIndex] <= sorted[k]\n        {\n            if sorted[j] < sorted[minIndex] {\n                minIndex := j;\n            }\n        }\n        if minIndex != i {\n            var temp := sorted[i];\n            sorted[i] := sorted[minIndex];\n            sorted[minIndex] := temp;\n        }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_424",
            "type": "program",
            "content": "class Matrix3x3 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    var e: int;\n    var f: int;\n    var g: int;\n    var h: int;\n    var i: int;\n    constructor(a: int, b: int, c: int, d: int, e: int, f: int, g: int, h: int, i: int)\n        ensures this.a == a && this.b == b && this.c == c\n        ensures this.d == d && this.e == e && this.f == f\n        ensures this.g == g && this.h == h && this.i == i\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n        this.e := e;\n        this.f := f;\n        this.g := g;\n        this.h := h;\n        this.i := i;\n    }\n    method Determinant() returns (det: int)\n        ensures det == a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g)\n    {\n        det := a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g);\n    }\nmethod Transpose() returns (transposed: Matrix3x3)\n    ensures transposed.a == this.a && transposed.b == this.d && transposed.c == this.g\n    ensures transposed.d == this.b && transposed.e == this.e && transposed.f == this.h\n    ensures transposed.g == this.c && transposed.h == this.f && transposed.i == this.i\n{\n    transposed := new Matrix3x3(a, d, g, b, e, h, c, f, i);\n}\nmethod IsIdentity() returns (isIdentity: bool)\n    ensures isIdentity == (a == 1 && b == 0 && c == 0 &&\n                           d == 0 && e == 1 && f == 0 &&\n                           g == 0 && h == 0 && i == 1)\n{\n    isIdentity := (a == 1 && b == 0 && c == 0 &&\n                   d == 0 && e == 1 && f == 0 &&\n                   g == 0 && h == 0 && i == 1);\n}\n}",
            "parents": [
                "node_185"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 31\nmethod Transpose() returns (transposed: Matrix3x3)\n    ensures transposed.a == this.a && transposed.b == this.d && transposed.c == this.g\n    ensures transposed.d == this.b && transposed.e == this.e && transposed.f == this.h\n    ensures transposed.g == this.c && transposed.h == this.f && transposed.i == this.i\n{\n    transposed := new Matrix3x3(a, d, g, b, e, h, c, f, i);\n}\n\nmethod IsIdentity() returns (isIdentity: bool)\n    ensures isIdentity == (a == 1 && b == 0 && c == 0 &&\n                           d == 0 && e == 1 && f == 0 &&\n                           g == 0 && h == 0 && i == 1)\n{\n    isIdentity := (a == 1 && b == 0 && c == 0 &&\n                   d == 0 && e == 1 && f == 0 &&\n                   g == 0 && h == 0 && i == 1);\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_425",
            "type": "program",
            "content": "class FlightBookingSystem {\n    var totalSeats: nat;\n    var bookedSeats: nat;\n    constructor(totalSeats: nat)\n        requires totalSeats > 0\n        ensures this.totalSeats == totalSeats && this.bookedSeats == 0\n    {\n        this.totalSeats := totalSeats;\n        this.bookedSeats := 0;\n    }\n    method BookSeat() returns (success: bool)\n        ensures success ==> bookedSeats <= totalSeats\n        ensures !success ==> bookedSeats == totalSeats\n    {\n        if bookedSeats < totalSeats {\n            bookedSeats := bookedSeats + 1;\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n    method CancelSeat() returns (success: bool)\n        ensures success ==> bookedSeats >= 0\n        ensures !success ==> bookedSeats == 0\n    {\n        if bookedSeats > 0 {\n            bookedSeats := bookedSeats - 1;\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n    method BookMultipleSeats(n: nat) returns (success: bool)\n        requires n > 0\n        ensures success ==> bookedSeats <= totalSeats\n        ensures !success ==> bookedSeats + n > totalSeats\n    {\n        var i: nat := 0;\n        success := true;\n        while i < n\n            invariant 0 <= i <= n\n            invariant bookedSeats <= totalSeats\n            invariant success ==> bookedSeats + (n - i) <= totalSeats\n            decreases n - i\n        {\n            if bookedSeats < totalSeats {\n                bookedSeats := bookedSeats + 1;\n            } else {\n                success := false;\n                break;\n            }\n            i := i + 1;\n        }\n    }\n}",
            "parents": [
                "node_383"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 33\n    method BookMultipleSeats(n: nat) returns (success: bool)\n        requires n > 0\n        ensures success ==> bookedSeats <= totalSeats\n        ensures !success ==> bookedSeats + n > totalSeats\n    {\n        var i: nat := 0;\n        success := true;\n        while i < n\n            invariant 0 <= i <= n\n            invariant bookedSeats <= totalSeats\n            invariant success ==> bookedSeats + (n - i) <= totalSeats\n            decreases n - i\n        {\n            if bookedSeats < totalSeats {\n                bookedSeats := bookedSeats + 1;\n            } else {\n                success := false;\n                break;\n            }\n            i := i + 1;\n        }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_426",
            "type": "program",
            "content": "class Geometry {\n    method AreRectanglesColliding(x1: int, y1: int, w1: int, h1: int, x2: int, y2: int, w2: int, h2: int) returns (colliding: bool)\n        requires w1 > 0 && h1 > 0 && w2 > 0 && h2 > 0\n        ensures colliding == ((x1 < x2 + w2) && (x2 < x1 + w1) && (y1 < y2 + h2) && (y2 < y1 + h1))\n    {\n        colliding := (x1 < x2 + w2) && (x2 < x1 + w1) && (y1 < y2 + h2) && (y2 < y1 + h1);\n    }\n    method TranslateRectangle(x: int, y: int, dx: int, dy: int) returns (newX: int, newY: int)\n        ensures newX == x + dx && newY == y + dy\n    {\n        newX := x + dx;\n        newY := y + dy;\n    }\n    method ScaleRectangle(x: int, y: int, w: int, h: int, factor: int) returns (newW: int, newH: int)\n        requires factor > 0\n        ensures newW == w * factor && newH == h * factor\n    {\n        var i := 0;\n        newW := 0;\n        newH := 0;\n        while i < factor\n            invariant 0 <= i <= factor\n            invariant newW == w * i\n            invariant newH == h * i\n        {\n            newW := newW + w;\n            newH := newH + h;\n            i := i + 1;\n        }\n    }\n}",
            "parents": [
                "node_270"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 14\n    method ScaleRectangle(x: int, y: int, w: int, h: int, factor: int) returns (newW: int, newH: int)\n        requires factor > 0\n        ensures newW == w * factor && newH == h * factor\n    {\n        var i := 0;\n        newW := 0;\n        newH := 0;\n        while i < factor\n            invariant 0 <= i <= factor\n            invariant newW == w * i\n            invariant newH == h * i\n        {\n            newW := newW + w;\n            newH := newH + h;\n            i := i + 1;\n        }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_427",
            "type": "program",
            "content": "class Matrix3x3 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    var e: int;\n    var f: int;\n    var g: int;\n    var h: int;\n    var i: int;\n    constructor(a: int, b: int, c: int, d: int, e: int, f: int, g: int, h: int, i: int)\n        ensures this.a == a && this.b == b && this.c == c\n        ensures this.d == d && this.e == e && this.f == f\n        ensures this.g == g && this.h == h && this.i == i\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n        this.e := e;\n        this.f := f;\n        this.g := g;\n        this.h := h;\n        this.i := i;\n    }\n    method Transpose() returns (transposed: Matrix3x3)\n        ensures transposed.a == a && transposed.b == d && transposed.c == g\n        ensures transposed.d == b && transposed.e == e && transposed.f == h\n        ensures transposed.g == c && transposed.h == f && transposed.i == i\n    {\n        transposed := new Matrix3x3(a, d, g, b, e, h, c, f, i);\n    }\nmethod Multiply(other: Matrix3x3) returns (product: Matrix3x3)\n    ensures product.a == a * other.a + b * other.d + c * other.g\n    ensures product.b == a * other.b + b * other.e + c * other.h\n    ensures product.c == a * other.c + b * other.f + c * other.i\n    ensures product.d == d * other.a + e * other.d + f * other.g\n    ensures product.e == d * other.b + e * other.e + f * other.h\n    ensures product.f == d * other.c + e * other.f + f * other.i\n    ensures product.g == g * other.a + h * other.d + i * other.g\n    ensures product.h == g * other.b + h * other.e + i * other.h\n    ensures product.i == g * other.c + h * other.f + i * other.i\n{\n    var newA := a * other.a + b * other.d + c * other.g;\n    var newB := a * other.b + b * other.e + c * other.h;\n    var newC := a * other.c + b * other.f + c * other.i;\n    var newD := d * other.a + e * other.d + f * other.g;\n    var newE := d * other.b + e * other.e + f * other.h;\n    var newF := d * other.c + e * other.f + f * other.i;\n    var newG := g * other.a + h * other.d + i * other.g;\n    var newH := g * other.b + h * other.e + i * other.h;\n    var newI := g * other.c + h * other.f + i * other.i;\n    product := new Matrix3x3(newA, newB, newC, newD, newE, newF, newG, newH, newI);\n}\nmethod Determinant() returns (det: int)\n    ensures det == a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g)\n{\n    det := a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g);\n}\nmethod IsIdentity() returns (isIdentity: bool)\n    ensures isIdentity == (a == 1 && e == 1 && i == 1 && b == 0 && c == 0 && d == 0 && f == 0 && g == 0 && h == 0)\n{\n    isIdentity := (a == 1 && e == 1 && i == 1 && b == 0 && c == 0 && d == 0 && f == 0 && g == 0 && h == 0);\n}\n}",
            "parents": [
                "node_370"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 55\nmethod Determinant() returns (det: int)\n    ensures det == a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g)\n{\n    det := a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g);\n}\n\nmethod IsIdentity() returns (isIdentity: bool)\n    ensures isIdentity == (a == 1 && e == 1 && i == 1 && b == 0 && c == 0 && d == 0 && f == 0 && g == 0 && h == 0)\n{\n    isIdentity := (a == 1 && e == 1 && i == 1 && b == 0 && c == 0 && d == 0 && f == 0 && g == 0 && h == 0);\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_428",
            "type": "program",
            "content": "class FlightBookingSystem {\n    var totalSeats: nat;\n    var bookedSeats: nat;\n    constructor(totalSeats: nat)\n        requires totalSeats > 0\n        ensures this.totalSeats == totalSeats && this.bookedSeats == 0\n    {\n        this.totalSeats := totalSeats;\n        this.bookedSeats := 0;\n    }\n    method BookSeat() returns (success: bool)\n        ensures success ==> bookedSeats <= totalSeats\n        ensures !success ==> bookedSeats == totalSeats\n    {\n        if bookedSeats < totalSeats {\n            bookedSeats := bookedSeats + 1;\n            success := true;\n        } else {\n            success := false;\n        }\n    }\nmethod CancelSeat() returns (success: bool)\n    ensures success ==> bookedSeats >= 0\n    ensures !success ==> bookedSeats == 0\n{\n    if bookedSeats > 0 {\n        bookedSeats := bookedSeats - 1;\n        success := true;\n    } else {\n        success := false;\n    }\n}\nmethod BookMultipleSeats(n: nat) returns (success: bool)\n    requires n > 0\n    ensures success ==> bookedSeats <= totalSeats\n    ensures !success ==> bookedSeats + n > totalSeats\n{\n    var i: nat := 0;\n    success := true;\n    while i < n\n        invariant 0 <= i <= n\n        invariant bookedSeats <= totalSeats\n        invariant success ==> bookedSeats + (n - i) <= totalSeats\n        invariant !success ==> bookedSeats + i == totalSeats\n    {\n        if bookedSeats < totalSeats {\n            bookedSeats := bookedSeats + 1;\n        } else {\n            success := false;\n            break;\n        }\n        i := i + 1;\n    }\n}\n}",
            "parents": [
                "node_416"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 33\nmethod BookMultipleSeats(n: nat) returns (success: bool)\n    requires n > 0\n    ensures success ==> bookedSeats <= totalSeats\n    ensures !success ==> bookedSeats + n > totalSeats\n{\n    var i: nat := 0;\n    success := true;\n    while i < n\n        invariant 0 <= i <= n\n        invariant bookedSeats <= totalSeats\n        invariant success ==> bookedSeats + (n - i) <= totalSeats\n        invariant !success ==> bookedSeats + i == totalSeats\n    {\n        if bookedSeats < totalSeats {\n            bookedSeats := bookedSeats + 1;\n        } else {\n            success := false;\n            break;\n        }\n        i := i + 1;\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_429",
            "type": "program",
            "content": "class VotingSystem {\n    var votes: array<int>;\n    constructor (numCandidates: int)\n        requires numCandidates > 0\n    {\n        votes := new int[numCandidates];\n    }\n    method Vote(candidate: int)\n        requires 0 <= candidate < votes.Length\n        modifies votes\n        ensures votes[candidate] == old(votes[candidate]) + 1\n    {\n        votes[candidate] := votes[candidate] + 1;\n    }\n    method GetWinner() returns (winner: int)\n        requires votes.Length > 0\n        ensures 0 <= winner < votes.Length\n        ensures forall i: int :: 0 <= i < votes.Length ==> votes[winner] >= votes[i]\n        ensures exists i: int :: 0 <= i < votes.Length && votes[i] == votes[winner]\n    {\n        var maxVotes := votes[0];\n        winner := 0;\n        var tieExists := false;\n        for i := 1 to votes.Length - 1\n            invariant 0 <= winner < votes.Length\n            invariant 0 <= i <= votes.Length\n            invariant forall j: int :: 0 <= j < i ==> votes[winner] >= votes[j]\n            invariant maxVotes == votes[winner]\n            invariant exists j: int :: 0 <= j < i && votes[j] == maxVotes\n            invariant tieExists == (exists j: int :: 0 <= j < i && votes[j] == maxVotes && j != winner)\n        {\n            if votes[i] > maxVotes {\n                maxVotes := votes[i];\n                winner := i;\n                tieExists := false;\n            } else if votes[i] == maxVotes {\n                tieExists := true;\n            }\n        }\n    }\n}",
            "parents": [
                "node_350"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 15\n    method GetWinner() returns (winner: int)\n        requires votes.Length > 0\n        ensures 0 <= winner < votes.Length\n        ensures forall i: int :: 0 <= i < votes.Length ==> votes[winner] >= votes[i]\n        ensures exists i: int :: 0 <= i < votes.Length && votes[i] == votes[winner]\n    {\n        var maxVotes := votes[0];\n        winner := 0;\n        var tieExists := false;\n        for i := 1 to votes.Length - 1\n            invariant 0 <= winner < votes.Length\n            invariant 0 <= i <= votes.Length\n            invariant forall j: int :: 0 <= j < i ==> votes[winner] >= votes[j]\n            invariant maxVotes == votes[winner]\n            invariant exists j: int :: 0 <= j < i && votes[j] == maxVotes\n            invariant tieExists == (exists j: int :: 0 <= j < i && votes[j] == maxVotes && j != winner)\n        {\n            if votes[i] > maxVotes {\n                maxVotes := votes[i];\n                winner := i;\n                tieExists := false;\n            } else if votes[i] == maxVotes {\n                tieExists := true;\n            }\n        }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_430",
            "type": "program",
            "content": "class PayrollSystem {\n    method CalculateSalary(hoursWorked: int, payRate: int) returns (salary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        ensures salary >= 0\n    {\n        salary := hoursWorked * payRate;\n    }\n    method CalculateOvertimeSalary(hoursWorked: int, payRate: int, overtimeRate: int) returns (totalSalary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        requires overtimeRate >= payRate\n        ensures totalSalary >= 0\n    {\n        var regularHours := if hoursWorked > 40 then 40 else hoursWorked;\n        var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n        var regularSalary := regularHours * payRate;\n        var overtimeSalary := overtimeHours * overtimeRate;\n        totalSalary := regularSalary + overtimeSalary;\n    }\n}\n    method CalculateWeeklySalary(hoursWorked: int, payRate: int, overtimeRate: int) returns (weeklySalary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        requires overtimeRate >= payRate\n        ensures weeklySalary >= 0\n    {\n        var totalSalary := 0;\n        var weekHours := 0;\n        var regularHours := 0;\n        var overtimeHours := 0;\n        while (weekHours < hoursWorked)\n            invariant 0 <= weekHours <= hoursWorked\n            invariant totalSalary >= 0\n            invariant regularHours + overtimeHours == weekHours\n            invariant regularHours <= 40\n        {\n            if (weekHours < 40) {\n                totalSalary := totalSalary + payRate;\n                regularHours := regularHours + 1;\n            } else {\n                totalSalary := totalSalary + overtimeRate;\n                overtimeHours := overtimeHours + 1;\n            }\n            weekHours := weekHours + 1;\n        }\n        weeklySalary := totalSalary;\n    }",
            "parents": [
                "node_207"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 22\n    method CalculateWeeklySalary(hoursWorked: int, payRate: int, overtimeRate: int) returns (weeklySalary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        requires overtimeRate >= payRate\n        ensures weeklySalary >= 0\n    {\n        var totalSalary := 0;\n        var weekHours := 0;\n        var regularHours := 0;\n        var overtimeHours := 0;\n        while (weekHours < hoursWorked)\n            invariant 0 <= weekHours <= hoursWorked\n            invariant totalSalary >= 0\n            invariant regularHours + overtimeHours == weekHours\n            invariant regularHours <= 40\n        {\n            if (weekHours < 40) {\n                totalSalary := totalSalary + payRate;\n                regularHours := regularHours + 1;\n            } else {\n                totalSalary := totalSalary + overtimeRate;\n                overtimeHours := overtimeHours + 1;\n            }\n            weekHours := weekHours + 1;\n        }\n        weeklySalary := totalSalary;\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_431",
            "type": "program",
            "content": "method Median(a: array<int>) returns (median: int)\n    requires a != null && a.Length > 0\n    ensures 0 <= median < a.Length\n    ensures forall i: int :: 0 <= i < a.Length ==> a[median] <= a[i] || a[median] >= a[i]\n{\n    var n := a.Length;\n    var sorted := new int[n];\n    // Copy the array\n    for i := 0 to n - 1\n        invariant 0 <= i <= n\n        invariant forall j: int :: 0 <= j < i ==> sorted[j] == a[j]\n    {\n        sorted[i] := a[i];\n    }\n    // Sort the array (simple insertion sort for demonstration)\n    for i := 1 to n - 1\n        invariant 1 <= i <= n\n        invariant forall j: int :: 0 <= j < i - 1 ==> sorted[j] <= sorted[j + 1]\n    {\n        var key := sorted[i];\n        var j := i - 1;\n        while j >= 0 && sorted[j] > key\n            invariant -1 <= j < i\n            invariant forall k: int :: 0 <= k <= j ==> sorted[k] <= key\n            invariant forall k: int :: j + 1 <= k < i ==> sorted[k] >= key\n        {\n            sorted[j + 1] := sorted[j];\n            j := j - 1;\n        }\n        sorted[j + 1] := key;\n    }\n    // Find the median\n    if n % 2 == 1 {\n        median := sorted[n / 2];\n    } else {\n        median := sorted[n / 2 - 1]; // Choose the lower median for even length\n    }\n}",
            "parents": [
                "node_274"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 19\n    {\n        var key := sorted[i];\n        var j := i - 1;\n        while j >= 0 && sorted[j] > key\n            invariant -1 <= j < i\n            invariant forall k: int :: 0 <= k <= j ==> sorted[k] <= key\n            invariant forall k: int :: j + 1 <= k < i ==> sorted[k] >= key\n        {\n            sorted[j + 1] := sorted[j];\n            j := j - 1;\n        }\n        sorted[j + 1] := key;\n    }\n    // Find the median\n    if n % 2 == 1 {\n        median := sorted[n / 2];\n    } else {\n        median := sorted[n / 2 - 1]; // Choose the lower median for even length\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_432",
            "type": "program",
            "content": "class VotingSystem {\n    var votes: array<int>;\n    constructor (numCandidates: int)\n        requires numCandidates > 0\n    {\n        votes := new int[numCandidates];\n    }\n    method Vote(candidate: int)\n        requires 0 <= candidate < votes.Length\n        modifies votes\n        ensures votes[candidate] == old(votes[candidate]) + 1\n    {\n        votes[candidate] := votes[candidate] + 1;\n    }\n    method GetWinner() returns (winner: int)\n        requires votes.Length > 0\n        ensures 0 <= winner < votes.Length\n        ensures forall i: int :: 0 <= i < votes.Length ==> votes[winner] >= votes[i]\n    {\n        var maxVotes := votes[0];\n        winner := 0;\n        for i := 1 to votes.Length - 1\n            invariant 0 <= winner < votes.Length\n            invariant 0 <= i <= votes.Length\n            invariant forall j: int :: 0 <= j < i ==> votes[winner] >= votes[j]\n        {\n            if votes[i] > maxVotes {\n                maxVotes := votes[i];\n                winner := i;\n            }\n        }\n}\n}",
            "parents": [
                "node_193"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 22\n        for i := 1 to votes.Length - 1\n            invariant 0 <= winner < votes.Length\n            invariant 0 <= i <= votes.Length\n            invariant forall j: int :: 0 <= j < i ==> votes[winner] >= votes[j]\n        {\n            if votes[i] > maxVotes {\n                maxVotes := votes[i];\n                winner := i;\n            }\n        }\n// END DAFNY\n```"
        },
        {
            "id": "node_433",
            "type": "program",
            "content": "class Point {\n    var x: int;\n    var y: int;\n    constructor(x: int, y: int)\n        ensures this.x == x && this.y == y\n    {\n        this.x := x;\n        this.y := y;\n    }\n}\nmethod CrossProduct(p1: Point, p2: Point, p3: Point) returns (result: int)\n    ensures result == (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x)\n{\n    result := (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x);\n}\nmethod CrossProductWithLoop(p1: Point, p2: Point, p3: Point) returns (result: int)\n    ensures result == (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x)\n{\n    var dx1 := p2.x - p1.x;\n    var dy1 := p2.y - p1.y;\n    var dx2 := p3.x - p1.x;\n    var dy2 := p3.y - p1.y;\n    result := 0;\n    var i := 0;\n    while i < 1\n        invariant 0 <= i <= 1\n        invariant result == i * (dx1 * dy2 - dy1 * dx2)\n    {\n        result := dx1 * dy2 - dy1 * dx2;\n        i := i + 1;\n    }\n}",
            "parents": [
                "node_260"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 16\nmethod CrossProductWithLoop(p1: Point, p2: Point, p3: Point) returns (result: int)\n    ensures result == (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x)\n{\n    var dx1 := p2.x - p1.x;\n    var dy1 := p2.y - p1.y;\n    var dx2 := p3.x - p1.x;\n    var dy2 := p3.y - p1.y;\n    result := 0;\n    var i := 0;\n    while i < 1\n        invariant 0 <= i <= 1\n        invariant result == i * (dx1 * dy2 - dy1 * dx2)\n    {\n        result := dx1 * dy2 - dy1 * dx2;\n        i := i + 1;\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_434",
            "type": "program",
            "content": "method QuickSort(a: array<int>) \n    requires a != null\n    modifies a\n    ensures forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n    ensures multiset(a[..]) == multiset(old(a[..]))\n{\n    QuickSortHelper(a, 0, a.Length - 1);\n}\nmethod QuickSortHelper(a: array<int>, low: int, high: int)\n    requires a != null && 0 <= low <= high + 1 <= a.Length\n    modifies a\n    ensures forall i, j :: low <= i < j <= high ==> a[i] <= a[j]\n    ensures multiset(a[low..high+1]) == multiset(old(a[low..high+1]))\n{\n    if low < high {\n        var pivotIndex := Partition(a, low, high);\n        QuickSortHelper(a, low, pivotIndex - 1);\n        QuickSortHelper(a, pivotIndex + 1, high);\n    }\n}\nmethod Partition(a: array<int>, low: int, high: int) returns (pivotIndex: int)\n    requires a != null && 0 <= low <= high < a.Length\n    modifies a\n    ensures low <= pivotIndex <= high\n    ensures forall i :: low <= i < pivotIndex ==> a[i] <= a[pivotIndex]\n    ensures forall i :: pivotIndex < i <= high ==> a[pivotIndex] <= a[i]\n    ensures multiset(a[low..high+1]) == multiset(old(a[low..high+1]))\n{\n    var pivot := a[high];\n    var i := low - 1;\n    for j := low to high - 1\n        invariant low <= j <= high\n        invariant low - 1 <= i < j\n        invariant forall k :: low <= k <= i ==> a[k] <= pivot\n        invariant forall k :: i < k < j ==> a[k] > pivot\n        invariant multiset(a[low..j]) + multiset(a[j..high]) == multiset(old(a[low..high]))\n    {\n}\n}",
            "parents": [
                "node_247"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 31\n    for j := low to high - 1\n        invariant low <= j <= high\n        invariant low - 1 <= i < j\n        invariant forall k :: low <= k <= i ==> a[k] <= pivot\n        invariant forall k :: i < k < j ==> a[k] > pivot\n        invariant multiset(a[low..j]) + multiset(a[j..high]) == multiset(old(a[low..high]))\n    {\n// END DAFNY\n```"
        },
        {
            "id": "node_435",
            "type": "program",
            "content": "class BasicLoginSystem {\n    var storedUsername: string;\n    var storedPassword: string;\n    constructor(username: string, password: string) \n        requires username != \"\" && password != \"\"\n    {\n        storedUsername := username;\n        storedPassword := password;\n    }\n    method Authenticate(inputUsername: string, inputPassword: string) returns (isAuthenticated: bool)\n        ensures isAuthenticated == (inputUsername == storedUsername && inputPassword == storedPassword)\n    {\n    {\n        var attempts: int := 0;\n        isAuthenticated := false;\n        while attempts < 3 && !isAuthenticated\n            invariant 0 <= attempts <= 3\n            invariant !isAuthenticated ==> attempts < 3\n            decreases 3 - attempts\n        {\n            if inputUsername == storedUsername && inputPassword == storedPassword {\n                isAuthenticated := true;\n            } else {\n                attempts := attempts + 1;\n            }\n        }\n    }\n}\n}",
            "parents": [
                "node_387"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 13\n    {\n        var attempts: int := 0;\n        isAuthenticated := false;\n        while attempts < 3 && !isAuthenticated\n            invariant 0 <= attempts <= 3\n            invariant !isAuthenticated ==> attempts < 3\n            decreases 3 - attempts\n        {\n            if inputUsername == storedUsername && inputPassword == storedPassword {\n                isAuthenticated := true;\n            } else {\n                attempts := attempts + 1;\n            }\n        }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_436",
            "type": "program",
            "content": "class LeapYearChecker {\n    method IsLeapYear(year: int) returns (isLeap: bool)\n        requires year > 0\n        ensures isLeap == ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)\n    {\n        var isLeapTemp := false;\n        var i := 0;\n        while i < 4\n            invariant 0 <= i <= 4\n            invariant isLeapTemp == ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0 && i == 3))\n        {\n            if i == 0 && year % 4 != 0 {\n                break;\n            }\n            if i == 1 && year % 100 == 0 {\n                break;\n            }\n            if i == 2 && year % 400 == 0 {\n                isLeapTemp := true;\n            }\n            if i == 3 {\n                isLeapTemp := (year % 4 == 0 && year % 100 != 0) || year % 400 == 0;\n            }\n            i := i + 1;\n        }\n}\n}",
            "parents": [
                "node_400"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 8\n        while i < 4\n            invariant 0 <= i <= 4\n            invariant isLeapTemp == ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0 && i == 3))\n        {\n            if i == 0 && year % 4 != 0 {\n                break;\n            }\n            if i == 1 && year % 100 == 0 {\n                break;\n            }\n            if i == 2 && year % 400 == 0 {\n                isLeapTemp := true;\n            }\n            if i == 3 {\n                isLeapTemp := (year % 4 == 0 && year % 100 != 0) || year % 400 == 0;\n            }\n            i := i + 1;\n        }\n// END DAFNY\n```"
        },
        {
            "id": "node_437",
            "type": "program",
            "content": "class PayrollSystem {\n    method CalculateSalary(hoursWorked: int, payRate: int) returns (salary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        ensures salary >= 0\n    {\n        salary := hoursWorked * payRate;\n    }\n    method CalculateOvertimeSalary(hoursWorked: int, payRate: int, overtimeRate: int) returns (totalSalary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        requires overtimeRate >= payRate\n        ensures totalSalary >= 0\n    {\n        var regularHours := if hoursWorked > 40 then 40 else hoursWorked;\n        var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n        var regularSalary := regularHours * payRate;\n        var overtimeSalary := overtimeHours * overtimeRate;\n        totalSalary := regularSalary + overtimeSalary;\n    }\n    method CalculateWeeklySalary(hoursWorked: int, payRate: int, overtimeRate: int) returns (weeklySalary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        requires overtimeRate >= payRate\n        ensures weeklySalary >= 0\n    {\n        var totalHours := hoursWorked;\n        var totalPay := 0;\n        var week := 0;\n        var totalWeeks := 0;\n        while totalHours > 0\n            invariant totalHours >= 0\n            invariant totalPay >= 0\n            invariant week >= 0\n            invariant totalWeeks == week\n        {\n            var currentWeekHours := if totalHours > 40 then 40 else totalHours;\n            var overtimeHours := if totalHours > 40 then totalHours - 40 else 0;\n            var regularSalary := currentWeekHours * payRate;\n            var overtimeSalary := overtimeHours * overtimeRate;\n            totalPay := totalPay + regularSalary + overtimeSalary;\n            totalHours := totalHours - currentWeekHours - overtimeHours;\n            week := week + 1;\n            totalWeeks := totalWeeks + 1;\n        }\n        weeklySalary := totalPay;\n}\n}",
            "parents": [
                "node_349"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 30\n        var totalWeeks := 0;\n        while totalHours > 0\n            invariant totalHours >= 0\n            invariant totalPay >= 0\n            invariant week >= 0\n            invariant totalWeeks == week\n        {\n            var currentWeekHours := if totalHours > 40 then 40 else totalHours;\n            var overtimeHours := if totalHours > 40 then totalHours - 40 else 0;\n            var regularSalary := currentWeekHours * payRate;\n            var overtimeSalary := overtimeHours * overtimeRate;\n            totalPay := totalPay + regularSalary + overtimeSalary;\n            totalHours := totalHours - currentWeekHours - overtimeHours;\n            week := week + 1;\n            totalWeeks := totalWeeks + 1;\n        }\n        weeklySalary := totalPay;\n// END DAFNY\n```"
        },
        {
            "id": "node_438",
            "type": "program",
            "content": "class LinearInequalitiesSolver {\n    method SolveSingleInequality(a: int, b: int, c: int) returns (solution: bool)\n        requires a != 0\n        ensures solution == (c >= b / a)\n    {\n        if a > 0 {\n            solution := c >= b / a;\n        } else {\n            solution := c <= b / a;\n        }\n    }\n    method VerifySolution(a: int, b: int, c: int, x: int) returns (isValid: bool)\n        requires a != 0\n        ensures isValid == (a * x + b <= c)\n    {\n        isValid := a * x + b <= c;\n    }\n    method SolveMultipleInequalities(a: seq<int>, b: seq<int>, c: seq<int>) returns (solutions: seq<bool>)\n        requires |a| == |b| && |b| == |c|\n        requires forall i :: 0 <= i < |a| ==> a[i] != 0\n        ensures |solutions| == |a|\n        ensures forall i :: 0 <= i < |a| ==> solutions[i] == (if a[i] > 0 then c[i] >= b[i] / a[i] else c[i] <= b[i] / a[i])\n    {\n        solutions := [];\n        var i := 0;\n        while i < |a|\n            invariant 0 <= i <= |a|\n            invariant |solutions| == i\n            invariant forall j :: 0 <= j < i ==> solutions[j] == (if a[j] > 0 then c[j] >= b[j] / a[j] else c[j] <= b[j] / a[j])\n        {\n            if a[i] > 0 {\n                solutions := solutions + [c[i] >= b[i] / a[i]];\n            } else {\n                solutions := solutions + [c[i] <= b[i] / a[i]];\n            }\n            i := i + 1;\n        }\n    }\n}",
            "parents": [
                "node_191"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 18\n    method SolveMultipleInequalities(a: seq<int>, b: seq<int>, c: seq<int>) returns (solutions: seq<bool>)\n        requires |a| == |b| && |b| == |c|\n        requires forall i :: 0 <= i < |a| ==> a[i] != 0\n        ensures |solutions| == |a|\n        ensures forall i :: 0 <= i < |a| ==> solutions[i] == (if a[i] > 0 then c[i] >= b[i] / a[i] else c[i] <= b[i] / a[i])\n    {\n        solutions := [];\n        var i := 0;\n        while i < |a|\n            invariant 0 <= i <= |a|\n            invariant |solutions| == i\n            invariant forall j :: 0 <= j < i ==> solutions[j] == (if a[j] > 0 then c[j] >= b[j] / a[j] else c[j] <= b[j] / a[j])\n        {\n            if a[i] > 0 {\n                solutions := solutions + [c[i] >= b[i] / a[i]];\n            } else {\n                solutions := solutions + [c[i] <= b[i] / a[i]];\n            }\n            i := i + 1;\n        }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_439",
            "type": "program",
            "content": "class PayrollSystem {\n    var hourlyRate: real;\n    var hoursWorked: real;\n    constructor(rate: real, hours: real)\n        requires rate >= 0.0 && hours >= 0.0\n    {\n        hourlyRate := rate;\n        hoursWorked := hours;\n    }\n    method CalculateSalaryWithOvertime() returns (salary: real)\n        ensures salary == hourlyRate * hoursWorked + (if hoursWorked > 40.0 then (hoursWorked - 40.0) * hourlyRate * 0.5 else 0.0)\n    {\n        var regularHours := if hoursWorked > 40.0 then 40.0 else hoursWorked;\n        var overtimeHours := if hoursWorked > 40.0 then hoursWorked - 40.0 else 0.0;\n        salary := hourlyRate * regularHours + overtimeHours * hourlyRate * 1.5;\n    }\n}",
            "parents": [
                "node_132"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 10\n    method CalculateSalaryWithOvertime() returns (salary: real)\n        ensures salary == hourlyRate * hoursWorked + (if hoursWorked > 40.0 then (hoursWorked - 40.0) * hourlyRate * 0.5 else 0.0)\n    {\n        var regularHours := if hoursWorked > 40.0 then 40.0 else hoursWorked;\n        var overtimeHours := if hoursWorked > 40.0 then hoursWorked - 40.0 else 0.0;\n        salary := hourlyRate * regularHours + overtimeHours * hourlyRate * 1.5;\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_440",
            "type": "program",
            "content": "class Matrix3x3 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    var e: int;\n    var f: int;\n    var g: int;\n    var h: int;\n    var i: int;\n    constructor(a: int, b: int, c: int, d: int, e: int, f: int, g: int, h: int, i: int)\n        ensures this.a == a && this.b == b && this.c == c\n        ensures this.d == d && this.e == e && this.f == f\n        ensures this.g == g && this.h == h && this.i == i\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n        this.e := e;\n        this.f := f;\n        this.g := g;\n        this.h := h;\n        this.i := i;\n    }\n    method Determinant() returns (det: int)\n        ensures det == a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g)\n    {\n        det := a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g);\n    }\nmethod Transpose() returns (t: Matrix3x3)\n    ensures t.a == this.a && t.b == this.d && t.c == this.g\n    ensures t.d == this.b && t.e == this.e && t.f == this.h\n    ensures t.g == this.c && t.h == this.f && t.i == this.i\n{\n    t := new Matrix3x3(this.a, this.d, this.g, this.b, this.e, this.h, this.c, this.f, this.i);\n}\nmethod IsIdentity() returns (isId: bool)\n    ensures isId == (a == 1 && b == 0 && c == 0 && d == 0 && e == 1 && f == 0 && g == 0 && h == 0 && i == 1)\n{\n    isId := a == 1 && b == 0 && c == 0 && d == 0 && e == 1 && f == 0 && g == 0 && h == 0 && i == 1;\n}\n}",
            "parents": [
                "node_185"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 31\nmethod Transpose() returns (t: Matrix3x3)\n    ensures t.a == this.a && t.b == this.d && t.c == this.g\n    ensures t.d == this.b && t.e == this.e && t.f == this.h\n    ensures t.g == this.c && t.h == this.f && t.i == this.i\n{\n    t := new Matrix3x3(this.a, this.d, this.g, this.b, this.e, this.h, this.c, this.f, this.i);\n}\n\nmethod IsIdentity() returns (isId: bool)\n    ensures isId == (a == 1 && b == 0 && c == 0 && d == 0 && e == 1 && f == 0 && g == 0 && h == 0 && i == 1)\n{\n    isId := a == 1 && b == 0 && c == 0 && d == 0 && e == 1 && f == 0 && g == 0 && h == 0 && i == 1;\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_441",
            "type": "program",
            "content": "class PayrollSystem {\n    method CalculateSalary(hoursWorked: int, payRate: int) returns (salary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        ensures salary >= 0\n    {\n        salary := hoursWorked * payRate;\n    }\n    method CalculateOvertimeSalary(hoursWorked: int, payRate: int, overtimeRate: int) returns (totalSalary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        requires overtimeRate >= payRate\n        ensures totalSalary >= 0\n    {\n        var regularHours := if hoursWorked > 40 then 40 else hoursWorked;\n        var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n        var regularSalary := regularHours * payRate;\n        var overtimeSalary := overtimeHours * overtimeRate;\n        totalSalary := regularSalary + overtimeSalary;\n    }\n    method CalculateWeeklySalary(hoursWorked: int, payRate: int, overtimeRate: int) returns (weeklySalary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        requires overtimeRate >= payRate\n        ensures weeklySalary >= 0\n    {\n        var totalHours := hoursWorked;\n        var totalPay := 0;\n        var i := 0;\n        var regularHours := if hoursWorked > 40 then 40 else hoursWorked;\n        var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n        var regularPay := regularHours * payRate;\n        var overtimePay := overtimeHours * overtimeRate;\n        weeklySalary := regularPay + overtimePay;\n}\n}",
            "parents": [
                "node_338"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 30\n        var regularHours := if hoursWorked > 40 then 40 else hoursWorked;\n        var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n        var regularPay := regularHours * payRate;\n        var overtimePay := overtimeHours * overtimeRate;\n        weeklySalary := regularPay + overtimePay;\n// END DAFNY\n```"
        },
        {
            "id": "node_442",
            "type": "program",
            "content": "class PayrollSystem {\n    var hourlyRate: real;\n    constructor(rate: real)\n        requires rate > 0.0\n        ensures this.hourlyRate == rate\n    {\n        this.hourlyRate := rate;\n    }\n    method CalculateWeeklySalary(hoursWorked: real) returns (salary: real)\n        requires hoursWorked >= 0.0\n        ensures salary == hoursWorked * hourlyRate\n    {\n        salary := hoursWorked * hourlyRate;\n    }\n    method CalculateTotalSalary(hours: seq<real>) returns (totalSalary: real)\n        requires forall h :: h in hours ==> h >= 0.0\n        ensures totalSalary == sum(hours) * hourlyRate\n    {\n        totalSalary := 0.0;\n        var i: int := 0;\n        while i < |hours|\n            invariant 0 <= i <= |hours|\n            invariant totalSalary == sum(hours[..i]) * hourlyRate\n        {\n            totalSalary := totalSalary + hours[i] * hourlyRate;\n            i := i + 1;\n        }\n    }\n    function sum(s: seq<real>): real\n        decreases |s|\n    {\n        if |s| == 0 then 0.0 else s[0] + sum(s[1..])\n    }\n}",
            "parents": [
                "idea_56"
            ],
            "diff": "```dafny\n// BEGIN DAFNY\nclass PayrollSystem {\n    var hourlyRate: real;\n\n    constructor(rate: real)\n        requires rate > 0.0\n        ensures this.hourlyRate == rate\n    {\n        this.hourlyRate := rate;\n    }\n\n    method CalculateWeeklySalary(hoursWorked: real) returns (salary: real)\n        requires hoursWorked >= 0.0\n        ensures salary == hoursWorked * hourlyRate\n    {\n        salary := hoursWorked * hourlyRate;\n    }\n\n    method CalculateTotalSalary(hours: seq<real>) returns (totalSalary: real)\n        requires forall h :: h in hours ==> h >= 0.0\n        ensures totalSalary == sum(hours) * hourlyRate\n    {\n        totalSalary := 0.0;\n        var i: int := 0;\n        while i < |hours|\n            invariant 0 <= i <= |hours|\n            invariant totalSalary == sum(hours[..i]) * hourlyRate\n        {\n            totalSalary := totalSalary + hours[i] * hourlyRate;\n            i := i + 1;\n        }\n    }\n\n    function sum(s: seq<real>): real\n        decreases |s|\n    {\n        if |s| == 0 then 0.0 else s[0] + sum(s[1..])\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_443",
            "type": "program",
            "content": "class Matrix2x2 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    constructor(a: int, b: int, c: int, d: int)\n        ensures this.a == a && this.b == b && this.c == c && this.d == d\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n    }\n    method Determinant() returns (det: int)\n        ensures det == a * d - b * c\n    {\n        det := a * d - b * c;\n    }\nmethod MultiplyByScalar(scalar: int) returns (result: Matrix2x2)\n    ensures result.a == this.a * scalar\n    ensures result.b == this.b * scalar\n    ensures result.c == this.c * scalar\n    ensures result.d == this.d * scalar\n{\n    result := new Matrix2x2(this.a * scalar, this.b * scalar, this.c * scalar, this.d * scalar);\n}\nmethod Transpose() returns (transposed: Matrix2x2)\n    ensures transposed.a == this.a\n    ensures transposed.b == this.c\n    ensures transposed.c == this.b\n    ensures transposed.d == this.d\n{\n    transposed := new Matrix2x2(this.a, this.c, this.b, this.d);\n}\nmethod Multiply(matrix: Matrix2x2) returns (result: Matrix2x2)\n    ensures result.a == this.a * matrix.a + this.b * matrix.c\n    ensures result.b == this.a * matrix.b + this.b * matrix.d\n    ensures result.c == this.c * matrix.a + this.d * matrix.c\n    ensures result.d == this.c * matrix.b + this.d * matrix.d\n{\n    var newA := this.a * matrix.a + this.b * matrix.c;\n    var newB := this.a * matrix.b + this.b * matrix.d;\n    var newC := this.c * matrix.a + this.d * matrix.c;\n    var newD := this.c * matrix.b + this.d * matrix.d;\n    result := new Matrix2x2(newA, newB, newC, newD);\n}\n}",
            "parents": [
                "node_230"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 35\nmethod Multiply(matrix: Matrix2x2) returns (result: Matrix2x2)\n    ensures result.a == this.a * matrix.a + this.b * matrix.c\n    ensures result.b == this.a * matrix.b + this.b * matrix.d\n    ensures result.c == this.c * matrix.a + this.d * matrix.c\n    ensures result.d == this.c * matrix.b + this.d * matrix.d\n{\n    var newA := this.a * matrix.a + this.b * matrix.c;\n    var newB := this.a * matrix.b + this.b * matrix.d;\n    var newC := this.c * matrix.a + this.d * matrix.c;\n    var newD := this.c * matrix.b + this.d * matrix.d;\n    result := new Matrix2x2(newA, newB, newC, newD);\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_444",
            "type": "program",
            "content": "method QuickSort(a: array<int>) \n    requires a != null\n    modifies a\n    ensures forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n    ensures multiset(a[..]) == multiset(old(a[..]))\n{\n    QuickSortHelper(a, 0, a.Length - 1);\n}\nmethod QuickSortHelper(a: array<int>, low: int, high: int)\n    requires a != null && 0 <= low <= high + 1 <= a.Length\n    modifies a\n    ensures forall i, j :: low <= i < j <= high ==> a[i] <= a[j]\n    ensures multiset(a[low..high+1]) == multiset(old(a[low..high+1]))\n{\n    if low < high {\n        var pivotIndex := Partition(a, low, high);\n        QuickSortHelper(a, low, pivotIndex - 1);\n        QuickSortHelper(a, pivotIndex + 1, high);\n    }\n}\nmethod Partition(a: array<int>, low: int, high: int) returns (pivotIndex: int)\n    requires a != null && 0 <= low <= high < a.Length\n    modifies a\n    ensures low <= pivotIndex <= high\n    ensures forall i :: low <= i < pivotIndex ==> a[i] <= a[pivotIndex]\n    ensures forall i :: pivotIndex < i <= high ==> a[pivotIndex] <= a[i]\n    ensures multiset(a[low..high+1]) == multiset(old(a[low..high+1]))\n{\n    var pivot := a[high];\n    var i := low - 1;\n    for j := low to high - 1\n        invariant low <= j <= high\n        invariant low - 1 <= i < j\n        invariant forall k :: low <= k <= i ==> a[k] <= pivot\n        invariant forall k :: i < k < j ==> a[k] > pivot\n        invariant multiset(a[low..j]) == multiset(old(a[low..j]))\n    {\n        if a[j] <= pivot {\n            i := i + 1;\n            var temp := a[i];\n            a[i] := a[j];\n            a[j] := temp;\n        }\n    }\n    var temp := a[i + 1];\n    a[i + 1] := a[high];\n    a[high] := temp;\n    pivotIndex := i + 1;\n}",
            "parents": [
                "node_298"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 31\n    for j := low to high - 1\n        invariant low <= j <= high\n        invariant low - 1 <= i < j\n        invariant forall k :: low <= k <= i ==> a[k] <= pivot\n        invariant forall k :: i < k < j ==> a[k] > pivot\n        invariant multiset(a[low..j]) == multiset(old(a[low..j]))\n    {\n        if a[j] <= pivot {\n            i := i + 1;\n            var temp := a[i];\n            a[i] := a[j];\n            a[j] := temp;\n        }\n    }\n    var temp := a[i + 1];\n    a[i + 1] := a[high];\n    a[high] := temp;\n    pivotIndex := i + 1;\n// END DAFNY\n```"
        },
        {
            "id": "node_445",
            "type": "program",
            "content": "class LinearInequalitySolver {\n    method SolveInequality(a: int, b: int, c: int) returns (x: int)\n        requires a != 0\n        ensures a * x + b <= c\n    {\n        // A simple approach to find a solution for ax + b <= c\n        x := (c - b) / a;\n        if a * x + b > c {\n            x := x - 1;\n        }\n    }\n    method VerifySolution(a: int, b: int, c: int, x: int) returns (isValid: bool)\n        ensures isValid == (a * x + b <= c)\n    {\n        isValid := a * x + b <= c;\n    }\n}\n    method SolveStrictInequality(a: int, b: int, c: int) returns (x: int)\n        requires a != 0\n        ensures a * x + b < c\n    {\n        // A simple approach to find a solution for ax + b < c\n        x := (c - b) / a;\n        if a * x + b >= c {\n            x := x - 1;\n        }\n    }\n    method VerifyStrictSolution(a: int, b: int, c: int, x: int) returns (isValid: bool)\n        ensures isValid == (a * x + b < c)\n    {\n        isValid := a * x + b < c;\n    }\nmethod SolveInequalityWithLoop(a: int, b: int, c: int) returns (x: int)\n    requires a != 0\n    ensures a * x + b <= c\n{\n    var lowerBound := (c - b) / a;\n    x := lowerBound;\n    while a * x + b > c\n        invariant a * x + b > c\n        invariant x <= lowerBound\n        invariant a * x + b >= a * lowerBound + b\n        decreases x\n    {\n        x := x - 1;\n    }\n}",
            "parents": [
                "node_394"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 33\nmethod SolveInequalityWithLoop(a: int, b: int, c: int) returns (x: int)\n    requires a != 0\n    ensures a * x + b <= c\n{\n    var lowerBound := (c - b) / a;\n    x := lowerBound;\n    while a * x + b > c\n        invariant a * x + b > c\n        invariant x <= lowerBound\n        invariant a * x + b >= a * lowerBound + b\n        decreases x\n    {\n        x := x - 1;\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_446",
            "type": "program",
            "content": "class Point {\n    var x: int;\n    var y: int;\n    constructor(x: int, y: int)\n        ensures this.x == x && this.y == y\n    {\n        this.x := x;\n        this.y := y;\n    }\n}\nmethod CrossProduct(p1: Point, p2: Point, p3: Point) returns (result: int)\n    ensures result == (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x)\n{\n    result := (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x);\n}\nmethod CrossProductWithLoop(p1: Point, p2: Point, p3: Point) returns (result: int)\n    ensures result == (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x)\n{\n    var dx1 := p2.x - p1.x;\n    var dy1 := p2.y - p1.y;\n    var dx2 := p3.x - p1.x;\n    var dy2 := p3.y - p1.y;\n    result := 0;\n    var i := 0;\n    while i < 2\n        invariant 0 <= i <= 2\n        invariant result == i * (dx1 * dy2 - dy1 * dx2)\n    {\n        if i == 0 {\n            result := dx1 * dy2 - dy1 * dx2;\n        }\n        i := i + 1;\n    }\n}",
            "parents": [
                "node_260"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 16\nmethod CrossProductWithLoop(p1: Point, p2: Point, p3: Point) returns (result: int)\n    ensures result == (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x)\n{\n    var dx1 := p2.x - p1.x;\n    var dy1 := p2.y - p1.y;\n    var dx2 := p3.x - p1.x;\n    var dy2 := p3.y - p1.y;\n    result := 0;\n    var i := 0;\n    while i < 2\n        invariant 0 <= i <= 2\n        invariant result == i * (dx1 * dy2 - dy1 * dx2)\n    {\n        if i == 0 {\n            result := dx1 * dy2 - dy1 * dx2;\n        }\n        i := i + 1;\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_447",
            "type": "program",
            "content": "class Point {\n    var x: int;\n    var y: int;\n    constructor(x: int, y: int)\n        ensures this.x == x && this.y == y\n    {\n        this.x := x;\n        this.y := y;\n    }\nmethod CrossProductWithLoop(p1: Point, p2: Point, p3: Point) returns (result: int)\n    ensures result == (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x)\n{\n    var dx1 := p2.x - p1.x;\n    var dy1 := p2.y - p1.y;\n    var dx2 := p3.x - p1.x;\n    var dy2 := p3.y - p1.y;\n    result := 0;\n    var i := 0;\n    while i < 2\n        invariant 0 <= i <= 2\n        invariant result == i * (dx1 * dy2 - dy1 * dx2)\n    {\n        if i == 0 {\n            result := dx1 * dy2 - dy1 * dx2;\n        }\n        i := i + 1;\n    }\n}\n}",
            "parents": [
                "node_313"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 19\n    while i < 2\n        invariant 0 <= i <= 2\n        invariant result == i * (dx1 * dy2 - dy1 * dx2)\n    {\n        if i == 0 {\n            result := dx1 * dy2 - dy1 * dx2;\n        }\n        i := i + 1;\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_448",
            "type": "program",
            "content": "method Median(a: array<int>) returns (median: int)\n    requires a != null && a.Length > 0\n    ensures 0 <= median < a.Length\n    ensures forall i: int :: 0 <= i < a.Length ==> a[median] <= a[i] || a[median] >= a[i]\n{\n    var n := a.Length;\n    var sorted := new int[n];\n    // Copy the array\n    for i := 0 to n - 1\n        invariant 0 <= i <= n\n        invariant forall j: int :: 0 <= j < i ==> sorted[j] == a[j]\n    {\n        sorted[i] := a[i];\n    }\n    // Sort the array (simple insertion sort for demonstration)\n    for i := 1 to n - 1\n        invariant 1 <= i <= n\n        invariant forall j: int, k: int :: 0 <= j < k < i ==> sorted[j] <= sorted[k]\n    {\n        var key := sorted[i];\n        var j := i - 1;\n        // Shift elements of sorted[0..i-1] that are greater than key\n        // to one position ahead of their current position\n        while j >= 0 && sorted[j] > key\n            invariant -1 <= j < i\n            invariant forall k: int :: 0 <= k <= j ==> sorted[k] > key\n            invariant forall k: int :: j < k < i ==> sorted[k] <= key\n        {\n            sorted[j + 1] := sorted[j];\n            j := j - 1;\n        }\n        sorted[j + 1] := key;\n    }\n    // Find the median\n    if n % 2 == 1 {\n        median := sorted[n / 2];\n    } else {\n        median := sorted[n / 2 - 1]; // Choose the lower median for even length\n    }\n}",
            "parents": [
                "node_238"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 19\n    {\n        var key := sorted[i];\n        var j := i - 1;\n        // Shift elements of sorted[0..i-1] that are greater than key\n        // to one position ahead of their current position\n        while j >= 0 && sorted[j] > key\n            invariant -1 <= j < i\n            invariant forall k: int :: 0 <= k <= j ==> sorted[k] > key\n            invariant forall k: int :: j < k < i ==> sorted[k] <= key\n        {\n            sorted[j + 1] := sorted[j];\n            j := j - 1;\n        }\n        sorted[j + 1] := key;\n    }\n    // Find the median\n    if n % 2 == 1 {\n        median := sorted[n / 2];\n    } else {\n        median := sorted[n / 2 - 1]; // Choose the lower median for even length\n    }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_449",
            "type": "program",
            "content": "class FlightBookingSystem {\n    var totalSeats: nat;\n    var bookedSeats: nat;\n    constructor(totalSeats: nat)\n        requires totalSeats > 0\n        ensures this.totalSeats == totalSeats && this.bookedSeats == 0\n    {\n        this.totalSeats := totalSeats;\n        this.bookedSeats := 0;\n    }\n    method BookSeat() returns (success: bool)\n        ensures success ==> bookedSeats <= totalSeats\n        ensures !success ==> bookedSeats == totalSeats\n    {\n        if bookedSeats < totalSeats {\n            bookedSeats := bookedSeats + 1;\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n    method CancelSeat() returns (success: bool)\n        ensures success ==> bookedSeats >= 0\n        ensures !success ==> bookedSeats == 0\n    {\n        if bookedSeats > 0 {\n            bookedSeats := bookedSeats - 1;\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n    method BookMultipleSeats(n: nat) returns (success: bool)\n        requires n > 0\n        ensures success ==> bookedSeats <= totalSeats\n        ensures !success ==> bookedSeats + n > totalSeats\n    {\n        var i: nat := 0;\n        success := true;\n        while i < n\n            invariant 0 <= i <= n\n            invariant bookedSeats <= totalSeats\n            invariant success ==> bookedSeats + (n - i) <= totalSeats\n            invariant success ==> i <= n\n        {\n            if bookedSeats < totalSeats {\n                bookedSeats := bookedSeats + 1;\n            } else {\n                success := false;\n                break;\n            }\n            i := i + 1;\n        }\n    }\n    method AvailableSeats() returns (available: nat)\n        ensures available == totalSeats - bookedSeats\n    {\n        available := totalSeats - bookedSeats;\n    }\n}",
            "parents": [
                "node_344"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 33\n    method BookMultipleSeats(n: nat) returns (success: bool)\n        requires n > 0\n        ensures success ==> bookedSeats <= totalSeats\n        ensures !success ==> bookedSeats + n > totalSeats\n    {\n        var i: nat := 0;\n        success := true;\n        while i < n\n            invariant 0 <= i <= n\n            invariant bookedSeats <= totalSeats\n            invariant success ==> bookedSeats + (n - i) <= totalSeats\n            invariant success ==> i <= n\n        {\n            if bookedSeats < totalSeats {\n                bookedSeats := bookedSeats + 1;\n            } else {\n                success := false;\n                break;\n            }\n            i := i + 1;\n        }\n    }\n\n    method AvailableSeats() returns (available: nat)\n        ensures available == totalSeats - bookedSeats\n    {\n        available := totalSeats - bookedSeats;\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_450",
            "type": "program",
            "content": "class Hotel {\n    var rooms: array<bool>;\n    constructor(numRooms: int)\n        requires numRooms > 0\n        ensures rooms.Length == numRooms\n        ensures forall i :: 0 <= i < numRooms ==> !rooms[i]\n    {\n        rooms := new bool[numRooms];\n    }\n    method BookRoom(roomNumber: int) returns (success: bool)\n        requires 0 <= roomNumber < rooms.Length\n        ensures success ==> rooms[roomNumber]\n        ensures !success ==> !rooms[roomNumber]\n    {\n        if (!rooms[roomNumber]) {\n            rooms[roomNumber] := true;\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n    method CancelBooking(roomNumber: int) returns (success: bool)\n        requires 0 <= roomNumber < rooms.Length\n        ensures success ==> !rooms[roomNumber]\n        ensures !success ==> rooms[roomNumber]\n    {\n        if (rooms[roomNumber]) {\n            rooms[roomNumber] := false;\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n    method BookMultipleRooms(startRoom: int, endRoom: int) returns (success: bool)\n        requires 0 <= startRoom <= endRoom < rooms.Length\n        ensures success ==> forall i :: startRoom <= i <= endRoom ==> rooms[i]\n        ensures !success ==> exists i :: startRoom <= i <= endRoom && !rooms[i]\n    {\n        success := true;\n        var i := startRoom;\n        while i <= endRoom\n            invariant startRoom <= i <= endRoom + 1\n            invariant forall j :: startRoom <= j < i ==> rooms[j]\n            invariant success ==> forall j :: startRoom <= j < i ==> rooms[j]\n        {\n            if (!rooms[i]) {\n                rooms[i] := true;\n            } else {\n                success := false;\n                break;\n            }\n            i := i + 1;\n        }\n    }\n}",
            "parents": [
                "node_180"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 34\n    method BookMultipleRooms(startRoom: int, endRoom: int) returns (success: bool)\n        requires 0 <= startRoom <= endRoom < rooms.Length\n        ensures success ==> forall i :: startRoom <= i <= endRoom ==> rooms[i]\n        ensures !success ==> exists i :: startRoom <= i <= endRoom && !rooms[i]\n    {\n        success := true;\n        var i := startRoom;\n        while i <= endRoom\n            invariant startRoom <= i <= endRoom + 1\n            invariant forall j :: startRoom <= j < i ==> rooms[j]\n            invariant success ==> forall j :: startRoom <= j < i ==> rooms[j]\n        {\n            if (!rooms[i]) {\n                rooms[i] := true;\n            } else {\n                success := false;\n                break;\n            }\n            i := i + 1;\n        }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_451",
            "type": "program",
            "content": "class Employee {\n    var hoursWorked: int;\n    var payRate: int;\n    constructor(hoursWorked: int, payRate: int)\n        ensures this.hoursWorked == hoursWorked && this.payRate == payRate\n    {\n        this.hoursWorked := hoursWorked;\n        this.payRate := payRate;\n    }\nmethod CalculateSalaryWithOvertime() returns (salary: int)\n    ensures salary == hoursWorked * payRate + (if hoursWorked > 40 then (hoursWorked - 40) * payRate / 2 else 0)\n{\n    var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n    var overtimePay := overtimeHours * payRate / 2;\n    salary := hoursWorked * payRate + overtimePay;\n}\n}",
            "parents": [
                "node_178"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 10\nmethod CalculateSalaryWithOvertime() returns (salary: int)\n    ensures salary == hoursWorked * payRate + (if hoursWorked > 40 then (hoursWorked - 40) * payRate / 2 else 0)\n{\n    var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n    var overtimePay := overtimeHours * payRate / 2;\n    salary := hoursWorked * payRate + overtimePay;\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_452",
            "type": "program",
            "content": "class Task {\n    var priority: int;\n    var description: string;\n    constructor(priority: int, description: string)\n        ensures this.priority == priority && this.description == description\n    {\n        this.priority := priority;\n        this.description := description;\n    }\n}\nclass TaskScheduler {\n    var tasks: seq<Task>;\n    constructor()\n        ensures tasks == []\n    {\n        tasks := [];\n    }\n    method AddTask(t: Task)\n        modifies tasks\n        ensures tasks == old(tasks) + [t]\n    {\n        tasks := tasks + [t];\n    }\n    method GetNextTask() returns (nextTask: Task?)\n        requires |tasks| > 0\n        ensures nextTask != null ==> forall t: Task :: t in tasks ==> nextTask.priority <= t.priority\n    {\n        var highestPriority := tasks[0].priority;\n        var index := 0;\n        for i := 1 to |tasks|\n            invariant 0 <= index < |tasks|\n            invariant forall j: int :: 0 <= j < i ==> tasks[index].priority <= tasks[j].priority\n        {\n            if tasks[i].priority < highestPriority {\n                highestPriority := tasks[i].priority;\n                index := i;\n            }\n        }\n}\n}",
            "parents": [
                "node_134"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 30\n        for i := 1 to |tasks|\n            invariant 0 <= index < |tasks|\n            invariant forall j: int :: 0 <= j < i ==> tasks[index].priority <= tasks[j].priority\n        {\n            if tasks[i].priority < highestPriority {\n                highestPriority := tasks[i].priority;\n                index := i;\n            }\n        }\n// END DAFNY\n```"
        },
        {
            "id": "node_453",
            "type": "program",
            "content": "class Matrix2x2 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    constructor(a: int, b: int, c: int, d: int)\n        ensures this.a == a && this.b == b && this.c == c && this.d == d\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n    }\n    method Determinant() returns (det: int)\n        ensures det == a * d - b * c\n    {\n        det := a * d - b * c;\n    }\nmethod MultiplyByScalar(scalar: int) returns (result: Matrix2x2)\n    ensures result.a == this.a * scalar\n    ensures result.b == this.b * scalar\n    ensures result.c == this.c * scalar\n    ensures result.d == this.d * scalar\n{\n    result := new Matrix2x2(this.a * scalar, this.b * scalar, this.c * scalar, this.d * scalar);\n}\nmethod Transpose() returns (result: Matrix2x2)\n    ensures result.a == this.a\n    ensures result.b == this.c\n    ensures result.c == this.b\n    ensures result.d == this.d\n{\n    result := new Matrix2x2(this.a, this.c, this.b, this.d);\n}\n}",
            "parents": [
                "node_164"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 19\nmethod MultiplyByScalar(scalar: int) returns (result: Matrix2x2)\n    ensures result.a == this.a * scalar\n    ensures result.b == this.b * scalar\n    ensures result.c == this.c * scalar\n    ensures result.d == this.d * scalar\n{\n    result := new Matrix2x2(this.a * scalar, this.b * scalar, this.c * scalar, this.d * scalar);\n}\n\nmethod Transpose() returns (result: Matrix2x2)\n    ensures result.a == this.a\n    ensures result.b == this.c\n    ensures result.c == this.b\n    ensures result.d == this.d\n{\n    result := new Matrix2x2(this.a, this.c, this.b, this.d);\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_454",
            "type": "program",
            "content": "class Employee {\n    var hoursWorked: int;\n    var payRate: int;\n    constructor(hoursWorked: int, payRate: int)\n        ensures this.hoursWorked == hoursWorked && this.payRate == payRate\n    {\n        this.hoursWorked := hoursWorked;\n        this.payRate := payRate;\n    }\n    method CalculateSalary() returns (salary: int)\n        ensures salary == hoursWorked * payRate\n    {\n        salary := hoursWorked * payRate;\n    }\nmethod CalculateSalaryWithOvertime() returns (salary: int)\n    ensures salary == hoursWorked * payRate + (if hoursWorked > 40 then (hoursWorked - 40) * (payRate / 2) else 0)\n{\n    var regularHours := if hoursWorked > 40 then 40 else hoursWorked;\n    var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n    salary := regularHours * payRate + overtimeHours * (payRate / 2);\n}\n}",
            "parents": [
                "node_118"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 15\nmethod CalculateSalaryWithOvertime() returns (salary: int)\n    ensures salary == hoursWorked * payRate + (if hoursWorked > 40 then (hoursWorked - 40) * (payRate / 2) else 0)\n{\n    var regularHours := if hoursWorked > 40 then 40 else hoursWorked;\n    var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n    salary := regularHours * payRate + overtimeHours * (payRate / 2);\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_455",
            "type": "program",
            "content": "class Sudoku {\n    var grid: array2<int>;\n    constructor(grid: array2<int>)\n        requires grid.Length0 == 9 && grid.Length1 == 9\n        ensures this.grid == grid\n    {\n        this.grid := grid;\n    }\n    method IsValidRow(row: int) returns (isValid: bool)\n        requires 0 <= row < 9\n        ensures isValid ==> (forall i, j :: 0 <= i < j < 9 ==> grid[row, i] != grid[row, j])\n    {\n        var seen := new bool[10];\n        isValid := true;\n        for i := 0 to 8 {\n            var num := grid[row, i];\n            if num < 1 || num > 9 || seen[num] {\n                isValid := false;\n                return;\n            }\n            seen[num] := true;\n        }\n    }\n    method IsValidColumn(col: int) returns (isValid: bool)\n        requires 0 <= col < 9\n        ensures isValid ==> (forall i, j :: 0 <= i < j < 9 ==> grid[i, col] != grid[j, col])\n    {\n        var seen := new bool[10];\n        isValid := true;\n        for i := 0 to 8 {\n            var num := grid[i, col];\n            if num < 1 || num > 9 || seen[num] {\n                isValid := false;\n                return;\n            }\n            seen[num] := true;\n        }\n    }\n    method IsValidSubgrid(subgridRow: int, subgridCol: int) returns (isValid: bool)\n        requires 0 <= subgridRow < 3 && 0 <= subgridCol < 3\n        ensures isValid ==> (forall i, j :: 0 <= i < j < 9 ==> grid[subgridRow * 3 + i / 3, subgridCol * 3 + i % 3] != grid[subgridRow * 3 + j / 3, subgridCol * 3 + j % 3])\n    {\n        var seen := new bool[10];\n        isValid := true;\n        for i := 0 to 8\n            invariant 0 <= i <= 9\n            invariant forall k :: 0 <= k < i ==> 1 <= grid[subgridRow * 3 + k / 3, subgridCol * 3 + k % 3] <= 9\n            invariant forall k :: 0 <= k < i ==> seen[grid[subgridRow * 3 + k / 3, subgridCol * 3 + k % 3]]\n            invariant forall k :: 0 <= k < i ==> (forall l :: 0 <= l < k ==> grid[subgridRow * 3 + k / 3, subgridCol * 3 + k % 3] != grid[subgridRow * 3 + l / 3, subgridCol * 3 + l % 3])\n        {\n            var num := grid[subgridRow * 3 + i / 3, subgridCol * 3 + i % 3];\n            if num < 1 || num > 9 || seen[num] {\n                isValid := false;\n                return;\n            }\n            seen[num] := true;\n        }\n}\n}",
            "parents": [
                "node_352"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 45\n        for i := 0 to 8\n            invariant 0 <= i <= 9\n            invariant forall k :: 0 <= k < i ==> 1 <= grid[subgridRow * 3 + k / 3, subgridCol * 3 + k % 3] <= 9\n            invariant forall k :: 0 <= k < i ==> seen[grid[subgridRow * 3 + k / 3, subgridCol * 3 + k % 3]]\n            invariant forall k :: 0 <= k < i ==> (forall l :: 0 <= l < k ==> grid[subgridRow * 3 + k / 3, subgridCol * 3 + k % 3] != grid[subgridRow * 3 + l / 3, subgridCol * 3 + l % 3])\n        {\n            var num := grid[subgridRow * 3 + i / 3, subgridCol * 3 + i % 3];\n            if num < 1 || num > 9 || seen[num] {\n                isValid := false;\n                return;\n            }\n            seen[num] := true;\n        }\n// END DAFNY\n```"
        },
        {
            "id": "node_456",
            "type": "program",
            "content": "class Matrix2x2 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    constructor(a: int, b: int, c: int, d: int)\n        ensures this.a == a && this.b == b && this.c == c && this.d == d\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n    }\n    method Determinant() returns (det: int)\n        ensures det == a * d - b * c\n    {\n        det := a * d - b * c;\n    }\nmethod MultiplyByScalar(scalar: int) returns (result: Matrix2x2)\n    ensures result.a == this.a * scalar\n    ensures result.b == this.b * scalar\n    ensures result.c == this.c * scalar\n    ensures result.d == this.d * scalar\n{\n    result := new Matrix2x2(this.a * scalar, this.b * scalar, this.c * scalar, this.d * scalar);\n}\nmethod Transpose() returns (result: Matrix2x2)\n    ensures result.a == this.a\n    ensures result.b == this.c\n    ensures result.c == this.b\n    ensures result.d == this.d\n{\n    result := new Matrix2x2(this.a, this.c, this.b, this.d);\n}\n}",
            "parents": [
                "node_201"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 19\nmethod MultiplyByScalar(scalar: int) returns (result: Matrix2x2)\n    ensures result.a == this.a * scalar\n    ensures result.b == this.b * scalar\n    ensures result.c == this.c * scalar\n    ensures result.d == this.d * scalar\n{\n    result := new Matrix2x2(this.a * scalar, this.b * scalar, this.c * scalar, this.d * scalar);\n}\n\nmethod Transpose() returns (result: Matrix2x2)\n    ensures result.a == this.a\n    ensures result.b == this.c\n    ensures result.c == this.b\n    ensures result.d == this.d\n{\n    result := new Matrix2x2(this.a, this.c, this.b, this.d);\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_457",
            "type": "program",
            "content": "module PalindromeChecker {\n  method IsPalindrome(s: string) returns (isPalin: bool)\n    ensures isPalin <==> (forall i :: 0 <= i < |s| / 2 ==> s[i] == s[|s| - i - 1])\n  {\n    var n := |s|;\n    isPalin := true;\n    for i := 0 to n / 2\n      invariant 0 <= i <= n / 2\n      invariant isPalin ==> (forall j :: 0 <= j < i ==> s[j] == s[n - j - 1])\n      invariant !isPalin ==> (exists k :: 0 <= k < i && s[k] != s[n - k - 1])\n    {\n      if s[i] != s[n - i - 1] {\n        isPalin := false;\n        break;\n      }\n    }\n}\n}",
            "parents": [
                "node_407"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 7\n    for i := 0 to n / 2\n      invariant 0 <= i <= n / 2\n      invariant isPalin ==> (forall j :: 0 <= j < i ==> s[j] == s[n - j - 1])\n      invariant !isPalin ==> (exists k :: 0 <= k < i && s[k] != s[n - k - 1])\n    {\n      if s[i] != s[n - i - 1] {\n        isPalin := false;\n        break;\n      }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_458",
            "type": "program",
            "content": "class LoginSystem {\n    var username: string;\n    var password: string;\n    constructor(username: string, password: string)\n        ensures this.username == username && this.password == password\n    {\n        this.username := username;\n        this.password := password;\n    }\nmethod Authenticate(inputUsername: string, inputPassword: string) returns (isAuthenticated: bool)\n    ensures isAuthenticated == (inputUsername == username && inputPassword == password)\n{\n    var attempts: nat := 0;\n    var locked: bool := false;\n    while (attempts < 3 && !locked)\n        invariant 0 <= attempts <= 3\n        invariant !locked ==> attempts < 3\n    {\n        if inputUsername == username && inputPassword == password {\n            isAuthenticated := true;\n            return;\n        }\n        attempts := attempts + 1;\n        if attempts == 3 {\n            locked := true;\n        }\n    }\n    isAuthenticated := false;\n}\n}",
            "parents": [
                "node_316"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 13\n    var attempts: nat := 0;\n    var locked: bool := false;\n    while (attempts < 3 && !locked)\n        invariant 0 <= attempts <= 3\n        invariant !locked ==> attempts < 3\n    {\n        if inputUsername == username && inputPassword == password {\n            isAuthenticated := true;\n            return;\n        }\n        attempts := attempts + 1;\n        if attempts == 3 {\n            locked := true;\n        }\n    }\n    isAuthenticated := false;\n// END DAFNY\n```"
        },
        {
            "id": "node_459",
            "type": "program",
            "content": "class TournamentBracket {\n    method GenerateBracket(seeds: seq<int>) returns (matchups: seq<(int, int)>)\n        requires |seeds| > 0 && |seeds| % 2 == 0\n        ensures |matchups| == |seeds| / 2\n        ensures forall i :: 0 <= i < |matchups| ==> matchups[i].0 != matchups[i].1\n    {\n        var n := |seeds|;\n        matchups := [];\n        for i := 0 to n / 2 - 1\n            invariant 0 <= i <= n / 2\n            invariant |matchups| == i\n            invariant forall j :: 0 <= j < i ==> matchups[j].0 != matchups[j].1\n        {\n            var team1 := seeds[i];\n            var team2 := seeds[n - i - 1];\n            if team1 > team2 {\n                matchups := matchups + [(team1, team2)];\n            } else {\n                matchups := matchups + [(team2, team1)];\n            }\n}\n}\n}",
            "parents": [
                "node_257"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 14\n            var team1 := seeds[i];\n            var team2 := seeds[n - i - 1];\n            if team1 > team2 {\n                matchups := matchups + [(team1, team2)];\n            } else {\n                matchups := matchups + [(team2, team1)];\n            }\n// END DAFNY\n```"
        },
        {
            "id": "node_460",
            "type": "program",
            "content": "class LeapYearChecker {\n    method IsLeapYear(year: int) returns (isLeap: bool)\n        requires year > 0\n        ensures isLeap == ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)\n    {\n        var divisibleBy4 := year % 4 == 0;\n        var divisibleBy100 := year % 100 == 0;\n        var divisibleBy400 := year % 400 == 0;\n        if divisibleBy4 {\n            if divisibleBy100 {\n                if divisibleBy400 {\n                    isLeap := true;\n                } else {\n                    isLeap := false;\n                }\n            } else {\n                isLeap := true;\n            }\n        } else {\n            isLeap := false;\n        }\n}\n}",
            "parents": [
                "node_261"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 6\n        var divisibleBy4 := year % 4 == 0;\n        var divisibleBy100 := year % 100 == 0;\n        var divisibleBy400 := year % 400 == 0;\n\n        if divisibleBy4 {\n            if divisibleBy100 {\n                if divisibleBy400 {\n                    isLeap := true;\n                } else {\n                    isLeap := false;\n                }\n            } else {\n                isLeap := true;\n            }\n        } else {\n            isLeap := false;\n        }\n// END DAFNY\n```"
        },
        {
            "id": "node_461",
            "type": "program",
            "content": "class FlightBookingSystem {\n    var totalSeats: nat;\n    var bookedSeats: nat;\n    constructor(totalSeats: nat)\n        requires totalSeats > 0\n        ensures this.totalSeats == totalSeats && this.bookedSeats == 0\n    {\n        this.totalSeats := totalSeats;\n        this.bookedSeats := 0;\n    }\n    method BookSeat() returns (success: bool)\n        ensures success ==> bookedSeats <= totalSeats\n        ensures !success ==> bookedSeats == totalSeats\n    {\n        if bookedSeats < totalSeats {\n            bookedSeats := bookedSeats + 1;\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n    method CancelSeat() returns (success: bool)\n        ensures success ==> bookedSeats >= 0\n        ensures !success ==> bookedSeats == 0\n    {\n        if bookedSeats > 0 {\n            bookedSeats := bookedSeats - 1;\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n    method BookMultipleSeats(n: nat) returns (success: bool)\n        requires n > 0\n        ensures success ==> bookedSeats <= totalSeats\n        ensures !success ==> bookedSeats + n > totalSeats\n    {\n        var i: nat := 0;\n        success := true;\n        while i < n\n            invariant 0 <= i <= n\n            invariant bookedSeats <= totalSeats\n            decreases n - i\n        {\n            if bookedSeats < totalSeats {\n                bookedSeats := bookedSeats + 1;\n            } else {\n                success := false;\n                break;\n            }\n            i := i + 1;\n        }\n    }\n}",
            "parents": [
                "node_109"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 22\n    method CancelSeat() returns (success: bool)\n        ensures success ==> bookedSeats >= 0\n        ensures !success ==> bookedSeats == 0\n    {\n        if bookedSeats > 0 {\n            bookedSeats := bookedSeats - 1;\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n\n    method BookMultipleSeats(n: nat) returns (success: bool)\n        requires n > 0\n        ensures success ==> bookedSeats <= totalSeats\n        ensures !success ==> bookedSeats + n > totalSeats\n    {\n        var i: nat := 0;\n        success := true;\n        while i < n\n            invariant 0 <= i <= n\n            invariant bookedSeats <= totalSeats\n            decreases n - i\n        {\n            if bookedSeats < totalSeats {\n                bookedSeats := bookedSeats + 1;\n            } else {\n                success := false;\n                break;\n            }\n            i := i + 1;\n        }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_462",
            "type": "program",
            "content": "class City {\n    var id: int;\n    constructor(id: int)\n        ensures this.id == id\n    {\n        this.id := id;\n    }\n}\nclass Tour {\n    var cities: seq<City>;\n    constructor(cities: seq<City>)\n        ensures this.cities == cities\n    {\n        this.cities := cities;\n    }\n    method IsValidTour() returns (isValid: bool)\n        ensures isValid == (|cities| > 1 && cities[0] == cities[|cities| - 1])\n    {\n        if |cities| > 1 && cities[0] == cities[|cities| - 1] {\n            isValid := true;\n        } else {\n            isValid := false;\n        }\n    }\n    method TotalCities() returns (count: int)\n        ensures count == |cities|\n    {\n        count := |cities|;\n    }\n    method ReverseTour() returns (reversed: seq<City>)\n        ensures |reversed| == |cities|\n        ensures forall i :: 0 <= i < |cities| ==> reversed[i] == cities[|cities| - 1 - i]\n    {\n        reversed := [];\n        var i := |cities| - 1;\n        while i >= 0\n            invariant 0 <= i + 1 <= |cities|\n            invariant |reversed| == |cities| - (i + 1)\n            invariant forall j :: 0 <= j < |reversed| ==> reversed[j] == cities[|cities| - 1 - j]\n        {\n            reversed := reversed + [cities[i]];\n            i := i - 1;\n        }\n    }\n}",
            "parents": [
                "node_198"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 30\n    method ReverseTour() returns (reversed: seq<City>)\n        ensures |reversed| == |cities|\n        ensures forall i :: 0 <= i < |cities| ==> reversed[i] == cities[|cities| - 1 - i]\n    {\n        reversed := [];\n        var i := |cities| - 1;\n        while i >= 0\n            invariant 0 <= i + 1 <= |cities|\n            invariant |reversed| == |cities| - (i + 1)\n            invariant forall j :: 0 <= j < |reversed| ==> reversed[j] == cities[|cities| - 1 - j]\n        {\n            reversed := reversed + [cities[i]];\n            i := i - 1;\n        }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_463",
            "type": "program",
            "content": "class Matrix3x3 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    var e: int;\n    var f: int;\n    var g: int;\n    var h: int;\n    var i: int;\n    constructor(a: int, b: int, c: int, d: int, e: int, f: int, g: int, h: int, i: int)\n        ensures this.a == a && this.b == b && this.c == c\n        ensures this.d == d && this.e == e && this.f == f\n        ensures this.g == g && this.h == h && this.i == i\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n        this.e := e;\n        this.f := f;\n        this.g := g;\n        this.h := h;\n        this.i := i;\n    }\n    method Determinant() returns (det: int)\n        ensures det == a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g)\n    {\n        det := a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g);\n    }\nmethod Transpose() returns (transposed: Matrix3x3)\n    ensures transposed.a == this.a && transposed.b == this.d && transposed.c == this.g\n    ensures transposed.d == this.b && transposed.e == this.e && transposed.f == this.h\n    ensures transposed.g == this.c && transposed.h == this.f && transposed.i == this.i\n{\n    transposed := new Matrix3x3(\n        this.a, this.d, this.g,\n        this.b, this.e, this.h,\n        this.c, this.f, this.i\n    );\n}\n    method Multiply(other: Matrix3x3) returns (product: Matrix3x3)\n        ensures product.a == this.a * other.a + this.b * other.d + this.c * other.g\n        ensures product.b == this.a * other.b + this.b * other.e + this.c * other.h\n        ensures product.c == this.a * other.c + this.b * other.f + this.c * other.i\n        ensures product.d == this.d * other.a + this.e * other.d + this.f * other.g\n        ensures product.e == this.d * other.b + this.e * other.e + this.f * other.h\n        ensures product.f == this.d * other.c + this.e * other.f + this.f * other.i\n        ensures product.g == this.g * other.a + this.h * other.d + this.i * other.g\n        ensures product.h == this.g * other.b + this.h * other.e + this.i * other.h\n        ensures product.i == this.g * other.c + this.h * other.f + this.i * other.i\n    {\n        var pa, pb, pc, pd, pe, pf, pg, ph, pi: int;\n        pa := this.a * other.a + this.b * other.d + this.c * other.g;\n        pb := this.a * other.b + this.b * other.e + this.c * other.h;\n        pc := this.a * other.c + this.b * other.f + this.c * other.i;\n        pd := this.d * other.a + this.e * other.d + this.f * other.g;\n        pe := this.d * other.b + this.e * other.e + this.f * other.h;\n        pf := this.d * other.c + this.e * other.f + this.f * other.i;\n        pg := this.g * other.a + this.h * other.d + this.i * other.g;\n        ph := this.g * other.b + this.h * other.e + this.i * other.h;\n        pi := this.g * other.c + this.h * other.f + this.i * other.i;\n        product := new Matrix3x3(pa, pb, pc, pd, pe, pf, pg, ph, pi);\n    }\n}",
            "parents": [
                "node_255"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 42\n    method Multiply(other: Matrix3x3) returns (product: Matrix3x3)\n        ensures product.a == this.a * other.a + this.b * other.d + this.c * other.g\n        ensures product.b == this.a * other.b + this.b * other.e + this.c * other.h\n        ensures product.c == this.a * other.c + this.b * other.f + this.c * other.i\n        ensures product.d == this.d * other.a + this.e * other.d + this.f * other.g\n        ensures product.e == this.d * other.b + this.e * other.e + this.f * other.h\n        ensures product.f == this.d * other.c + this.e * other.f + this.f * other.i\n        ensures product.g == this.g * other.a + this.h * other.d + this.i * other.g\n        ensures product.h == this.g * other.b + this.h * other.e + this.i * other.h\n        ensures product.i == this.g * other.c + this.h * other.f + this.i * other.i\n    {\n        var pa, pb, pc, pd, pe, pf, pg, ph, pi: int;\n        pa := this.a * other.a + this.b * other.d + this.c * other.g;\n        pb := this.a * other.b + this.b * other.e + this.c * other.h;\n        pc := this.a * other.c + this.b * other.f + this.c * other.i;\n        pd := this.d * other.a + this.e * other.d + this.f * other.g;\n        pe := this.d * other.b + this.e * other.e + this.f * other.h;\n        pf := this.d * other.c + this.e * other.f + this.f * other.i;\n        pg := this.g * other.a + this.h * other.d + this.i * other.g;\n        ph := this.g * other.b + this.h * other.e + this.i * other.h;\n        pi := this.g * other.c + this.h * other.f + this.i * other.i;\n        product := new Matrix3x3(pa, pb, pc, pd, pe, pf, pg, ph, pi);\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_464",
            "type": "program",
            "content": "method GCD(a: nat, b: nat) returns (gcd: nat)\n    requires a > 0 && b > 0\n    ensures gcd > 0\n    ensures a % gcd == 0 && b % gcd == 0\n    ensures forall d: nat :: d > 0 && a % d == 0 && b % d == 0 ==> gcd >= d\n{\n    var x := a;\n    var y := b;\n    while y != 0\n        invariant x > 0\n        invariant y >= 0\n        invariant x % gcd == 0 && y % gcd == 0\n}",
            "parents": [
                "node_137"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 12\n        invariant x % gcd == 0 && y % gcd == 0\n// END DAFNY\n```"
        },
        {
            "id": "node_465",
            "type": "program",
            "content": "class SudokuValidator {\n    var grid: array2<int>;\n    constructor(grid: array2<int>)\n        requires grid.Length0 == 9 && grid.Length1 == 9\n        ensures this.grid == grid\n    {\n        this.grid := grid;\n    }\n    method IsRowValid(row: int) returns (isValid: bool)\n        requires 0 <= row < 9\n        ensures isValid == (forall i, j :: 0 <= i < j < 9 ==> grid[row, i] != grid[row, j])\n    {\n        var seen := new bool[10];\n        isValid := true;\n        for i := 0 to 8 {\n            if grid[row, i] < 1 || grid[row, i] > 9 || seen[grid[row, i]] {\n                isValid := false;\n                return;\n            }\n            seen[grid[row, i]] := true;\n        }\n    }\n    method IsColumnValid(col: int) returns (isValid: bool)\n        requires 0 <= col < 9\n        ensures isValid == (forall i, j :: 0 <= i < j < 9 ==> grid[i, col] != grid[j, col])\n    {\n        var seen := new bool[10];\n        isValid := true;\n        for i := 0 to 8 {\n            if grid[i, col] < 1 || grid[i, col] > 9 || seen[grid[i, col]] {\n                isValid := false;\n                return;\n            }\n            seen[grid[i, col]] := true;\n        }\n    }\n    method IsSubgridValid(row: int, col: int) returns (isValid: bool)\n        requires 0 <= row < 9 && 0 <= col < 9\n        requires row % 3 == 0 && col % 3 == 0\n        ensures isValid == (forall i, j :: 0 <= i < j < 9 ==> grid[row + i / 3, col + i % 3] != grid[row + j / 3, col + j % 3])\n    {\n        var seen := new bool[10];\n        isValid := true;\n        for i := 0 to 8\n            invariant 0 <= i <= 9\n            invariant forall k :: 0 <= k < i ==> 1 <= grid[row + k / 3, col + k % 3] <= 9\n            invariant forall k :: 0 <= k < i ==> seen[grid[row + k / 3, col + k % 3]]\n        {\n            var value := grid[row + i / 3, col + i % 3];\n            if value < 1 || value > 9 || seen[value] {\n                isValid := false;\n                return;\n            }\n            seen[value] := true;\n        }\n    }\n}",
            "parents": [
                "node_103"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 37\n    method IsSubgridValid(row: int, col: int) returns (isValid: bool)\n        requires 0 <= row < 9 && 0 <= col < 9\n        requires row % 3 == 0 && col % 3 == 0\n        ensures isValid == (forall i, j :: 0 <= i < j < 9 ==> grid[row + i / 3, col + i % 3] != grid[row + j / 3, col + j % 3])\n    {\n        var seen := new bool[10];\n        isValid := true;\n        for i := 0 to 8\n            invariant 0 <= i <= 9\n            invariant forall k :: 0 <= k < i ==> 1 <= grid[row + k / 3, col + k % 3] <= 9\n            invariant forall k :: 0 <= k < i ==> seen[grid[row + k / 3, col + k % 3]]\n        {\n            var value := grid[row + i / 3, col + i % 3];\n            if value < 1 || value > 9 || seen[value] {\n                isValid := false;\n                return;\n            }\n            seen[value] := true;\n        }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_466",
            "type": "program",
            "content": "class FlightBookingSystem {\n    var totalSeats: nat;\n    var bookedSeats: nat;\n    constructor(totalSeats: nat)\n        requires totalSeats > 0\n        ensures this.totalSeats == totalSeats && this.bookedSeats == 0\n    {\n        this.totalSeats := totalSeats;\n        this.bookedSeats := 0;\n    }\n    method BookSeat() returns (success: bool)\n        ensures success ==> bookedSeats <= totalSeats\n        ensures !success ==> bookedSeats == totalSeats\n    {\n        if bookedSeats < totalSeats {\n            bookedSeats := bookedSeats + 1;\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n    method CancelSeat() returns (success: bool)\n        ensures success ==> bookedSeats >= 0\n        ensures !success ==> bookedSeats == 0\n    {\n        if bookedSeats > 0 {\n            bookedSeats := bookedSeats - 1;\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n    method BookMultipleSeats(n: nat) returns (success: bool)\n        requires n > 0\n        ensures success ==> bookedSeats <= totalSeats\n        ensures !success ==> bookedSeats + n > totalSeats\n    {\n        var i := 0;\n        success := true;\n        while i < n\n            invariant 0 <= i <= n\n            invariant bookedSeats <= totalSeats\n            invariant success ==> bookedSeats + i <= totalSeats\n            invariant !success ==> bookedSeats + i > totalSeats\n        {\n            if bookedSeats < totalSeats {\n                bookedSeats := bookedSeats + 1;\n            } else {\n                success := false;\n                break;\n            }\n            i := i + 1;\n        }\n    }\n    method CancelMultipleSeats(n: nat) returns (success: bool)\n        requires n > 0\n        ensures success ==> bookedSeats >= 0\n        ensures !success ==> bookedSeats < n\n    {\n        var i := 0;\n        success := true;\n        while i < n\n            invariant 0 <= i <= n\n            invariant bookedSeats >= 0\n            invariant success ==> bookedSeats >= i\n            invariant !success ==> bookedSeats < i\n        {\n            if bookedSeats > 0 {\n                bookedSeats := bookedSeats - 1;\n            } else {\n                success := false;\n                break;\n            }\n            i := i + 1;\n        }\n    }\n}",
            "parents": [
                "node_250"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 33\n    method BookMultipleSeats(n: nat) returns (success: bool)\n        requires n > 0\n        ensures success ==> bookedSeats <= totalSeats\n        ensures !success ==> bookedSeats + n > totalSeats\n    {\n        var i := 0;\n        success := true;\n        while i < n\n            invariant 0 <= i <= n\n            invariant bookedSeats <= totalSeats\n            invariant success ==> bookedSeats + i <= totalSeats\n            invariant !success ==> bookedSeats + i > totalSeats\n        {\n            if bookedSeats < totalSeats {\n                bookedSeats := bookedSeats + 1;\n            } else {\n                success := false;\n                break;\n            }\n            i := i + 1;\n        }\n    }\n\n    method CancelMultipleSeats(n: nat) returns (success: bool)\n        requires n > 0\n        ensures success ==> bookedSeats >= 0\n        ensures !success ==> bookedSeats < n\n    {\n        var i := 0;\n        success := true;\n        while i < n\n            invariant 0 <= i <= n\n            invariant bookedSeats >= 0\n            invariant success ==> bookedSeats >= i\n            invariant !success ==> bookedSeats < i\n        {\n            if bookedSeats > 0 {\n                bookedSeats := bookedSeats - 1;\n            } else {\n                success := false;\n                break;\n            }\n            i := i + 1;\n        }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_467",
            "type": "program",
            "content": "method Median(a: array<int>) returns (median: int)\n    requires a != null && a.Length > 0\n    ensures 0 <= median < a.Length\n    ensures forall i: int :: 0 <= i < a.Length ==> a[median] <= a[i] || a[median] >= a[i]\n{\n    var n := a.Length;\n    var sorted := new int[n];\n    // Copy the array\n    for i := 0 to n - 1\n        invariant 0 <= i <= n\n        invariant forall j: int :: 0 <= j < i ==> sorted[j] == a[j]\n    {\n        sorted[i] := a[i];\n    }\n    // Sort the array (simple insertion sort for demonstration)\n    for i := 1 to n - 1\n        invariant 1 <= i <= n\n        invariant forall j: int, k: int :: 0 <= j < k < i ==> sorted[j] <= sorted[k]\n}",
            "parents": [
                "node_212"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 18\n        invariant forall j: int, k: int :: 0 <= j < k < i ==> sorted[j] <= sorted[k]\n// END DAFNY\n```"
        },
        {
            "id": "node_468",
            "type": "program",
            "content": "class FlightBookingSystem {\n    var totalSeats: nat;\n    var bookedSeats: nat;\n    constructor(totalSeats: nat)\n        requires totalSeats > 0\n        ensures this.totalSeats == totalSeats && this.bookedSeats == 0\n    {\n        this.totalSeats := totalSeats;\n        this.bookedSeats := 0;\n    }\n    method BookSeat() returns (success: bool)\n        ensures success ==> bookedSeats <= totalSeats\n        ensures !success ==> bookedSeats == totalSeats\n    {\n        if bookedSeats < totalSeats {\n            bookedSeats := bookedSeats + 1;\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n    method CancelSeat() returns (success: bool)\n        ensures success ==> bookedSeats >= 0\n        ensures !success ==> bookedSeats == 0\n    {\n        if bookedSeats > 0 {\n            bookedSeats := bookedSeats - 1;\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n    method BookMultipleSeats(n: nat) returns (success: bool)\n        requires n > 0\n        ensures success ==> bookedSeats <= totalSeats\n        ensures !success ==> bookedSeats + n > totalSeats\n    {\n        var initialBookedSeats := bookedSeats;\n        var i := 0;\n        success := true;\n        while i < n\n            invariant 0 <= i <= n\n            invariant bookedSeats <= totalSeats\n            invariant success ==> bookedSeats + i <= totalSeats\n            invariant !success ==> bookedSeats + i > totalSeats\n            invariant bookedSeats == initialBookedSeats + i\n        {\n            if bookedSeats < totalSeats {\n                bookedSeats := bookedSeats + 1;\n            } else {\n                success := false;\n                break;\n            }\n            i := i + 1;\n        }\n    }\n}",
            "parents": [
                "node_414"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 33\n    method BookMultipleSeats(n: nat) returns (success: bool)\n        requires n > 0\n        ensures success ==> bookedSeats <= totalSeats\n        ensures !success ==> bookedSeats + n > totalSeats\n    {\n        var initialBookedSeats := bookedSeats;\n        var i := 0;\n        success := true;\n        while i < n\n            invariant 0 <= i <= n\n            invariant bookedSeats <= totalSeats\n            invariant success ==> bookedSeats + i <= totalSeats\n            invariant !success ==> bookedSeats + i > totalSeats\n            invariant bookedSeats == initialBookedSeats + i\n        {\n            if bookedSeats < totalSeats {\n                bookedSeats := bookedSeats + 1;\n            } else {\n                success := false;\n                break;\n            }\n            i := i + 1;\n        }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_469",
            "type": "program",
            "content": "class Matrix2x2 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    constructor(a: int, b: int, c: int, d: int)\n        ensures this.a == a && this.b == b && this.c == c && this.d == d\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n    }\n    method Determinant() returns (det: int)\n        ensures det == a * d - b * c\n    {\n        det := a * d - b * c;\n    }\nmethod MultiplyByScalar(scalar: int) returns (result: Matrix2x2)\n    ensures result.a == this.a * scalar\n    ensures result.b == this.b * scalar\n    ensures result.c == this.c * scalar\n    ensures result.d == this.d * scalar\n{\n    result := new Matrix2x2(this.a * scalar, this.b * scalar, this.c * scalar, this.d * scalar);\n}\nmethod Transpose() returns (transposed: Matrix2x2)\n    ensures transposed.a == this.a\n    ensures transposed.b == this.c\n    ensures transposed.c == this.b\n    ensures transposed.d == this.d\n{\n    transposed := new Matrix2x2(this.a, this.c, this.b, this.d);\n}\n}",
            "parents": [
                "node_130"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 19\nmethod MultiplyByScalar(scalar: int) returns (result: Matrix2x2)\n    ensures result.a == this.a * scalar\n    ensures result.b == this.b * scalar\n    ensures result.c == this.c * scalar\n    ensures result.d == this.d * scalar\n{\n    result := new Matrix2x2(this.a * scalar, this.b * scalar, this.c * scalar, this.d * scalar);\n}\n\nmethod Transpose() returns (transposed: Matrix2x2)\n    ensures transposed.a == this.a\n    ensures transposed.b == this.c\n    ensures transposed.c == this.b\n    ensures transposed.d == this.d\n{\n    transposed := new Matrix2x2(this.a, this.c, this.b, this.d);\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_470",
            "type": "program",
            "content": "method QuickSort(a: array<int>) \n    requires a != null\n    modifies a\n    ensures forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n    ensures multiset(a[..]) == multiset(old(a[..]))\n{\n    QuickSortHelper(a, 0, a.Length - 1);\n}\nmethod QuickSortHelper(a: array<int>, low: int, high: int)\n    requires a != null && 0 <= low <= high + 1 <= a.Length\n    modifies a\n    ensures forall i, j :: low <= i < j <= high ==> a[i] <= a[j]\n    ensures multiset(a[low..high+1]) == multiset(old(a[low..high+1]))\n{\n    if low < high {\n        var pivotIndex := Partition(a, low, high);\n        QuickSortHelper(a, low, pivotIndex - 1);\n        QuickSortHelper(a, pivotIndex + 1, high);\n    }\n}\nmethod Partition(a: array<int>, low: int, high: int) returns (pivotIndex: int)\n    requires a != null && 0 <= low <= high < a.Length\n    modifies a\n    ensures low <= pivotIndex <= high\n    ensures forall i :: low <= i < pivotIndex ==> a[i] <= a[pivotIndex]\n    ensures forall i :: pivotIndex < i <= high ==> a[pivotIndex] <= a[i]\n    ensures multiset(a[low..high+1]) == multiset(old(a[low..high+1]))\n{\n    var pivot := a[high];\n    var i := low - 1;\n    for j := low to high - 1\n        invariant low <= j <= high\n        invariant low - 1 <= i < j\n        invariant forall k :: low <= k <= i ==> a[k] <= pivot\n        invariant forall k :: i < k < j ==> a[k] > pivot\n        invariant multiset(a[low..j]) + multiset(a[j..high]) == multiset(old(a[low..high]))\n    {\n        if a[j] <= pivot {\n            i := i + 1;\n            a[i], a[j] := a[j], a[i];\n        }\n    }\n    a[i + 1], a[high] := a[high], a[i + 1];\n    return i + 1;\n}",
            "parents": [
                "node_434"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 38\n        if a[j] <= pivot {\n            i := i + 1;\n            a[i], a[j] := a[j], a[i];\n        }\n    }\n    a[i + 1], a[high] := a[high], a[i + 1];\n    return i + 1;\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_471",
            "type": "program",
            "content": "class Matrix2x2 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    constructor(a: int, b: int, c: int, d: int)\n        ensures this.a == a && this.b == b && this.c == c && this.d == d\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n    }\n    method Determinant() returns (det: int)\n        ensures det == a * d - b * c\n    {\n        det := a * d - b * c;\n    }\nmethod MultiplyByScalar(scalar: int) returns (result: Matrix2x2)\n    ensures result.a == this.a * scalar\n    ensures result.b == this.b * scalar\n    ensures result.c == this.c * scalar\n    ensures result.d == this.d * scalar\n{\n    result := new Matrix2x2(this.a * scalar, this.b * scalar, this.c * scalar, this.d * scalar);\n}\nmethod Transpose() returns (result: Matrix2x2)\n    ensures result.a == this.a\n    ensures result.b == this.c\n    ensures result.c == this.b\n    ensures result.d == this.d\n{\n    result := new Matrix2x2(this.a, this.c, this.b, this.d);\n}\nmethod Multiply(matrix: Matrix2x2) returns (result: Matrix2x2)\n    ensures result.a == this.a * matrix.a + this.b * matrix.c\n    ensures result.b == this.a * matrix.b + this.b * matrix.d\n    ensures result.c == this.c * matrix.a + this.d * matrix.c\n    ensures result.d == this.c * matrix.b + this.d * matrix.d\n{\n    var newA := this.a * matrix.a + this.b * matrix.c;\n    var newB := this.a * matrix.b + this.b * matrix.d;\n    var newC := this.c * matrix.a + this.d * matrix.c;\n    var newD := this.c * matrix.b + this.d * matrix.d;\n    result := new Matrix2x2(newA, newB, newC, newD);\n}\n}",
            "parents": [
                "node_391"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 35\nmethod Multiply(matrix: Matrix2x2) returns (result: Matrix2x2)\n    ensures result.a == this.a * matrix.a + this.b * matrix.c\n    ensures result.b == this.a * matrix.b + this.b * matrix.d\n    ensures result.c == this.c * matrix.a + this.d * matrix.c\n    ensures result.d == this.c * matrix.b + this.d * matrix.d\n{\n    var newA := this.a * matrix.a + this.b * matrix.c;\n    var newB := this.a * matrix.b + this.b * matrix.d;\n    var newC := this.c * matrix.a + this.d * matrix.c;\n    var newD := this.c * matrix.b + this.d * matrix.d;\n    result := new Matrix2x2(newA, newB, newC, newD);\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_472",
            "type": "program",
            "content": "class Hotel {\n    var rooms: array<bool>;\n    constructor(numRooms: int)\n        requires numRooms > 0\n        ensures rooms.Length == numRooms\n        ensures forall i :: 0 <= i < numRooms ==> !rooms[i]\n    {\n        rooms := new bool[numRooms];\n    }\n    method BookRoom(roomNumber: int) returns (success: bool)\n        requires 0 <= roomNumber < rooms.Length\n        ensures success ==> rooms[roomNumber]\n        ensures !success ==> !rooms[roomNumber]\n    {\n        if (!rooms[roomNumber]) {\n            rooms[roomNumber] := true;\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n    method CancelBooking(roomNumber: int) returns (success: bool)\n        requires 0 <= roomNumber < rooms.Length\n        ensures success ==> !rooms[roomNumber]\n        ensures !success ==> rooms[roomNumber]\n    {\n        if (rooms[roomNumber]) {\n            rooms[roomNumber] := false;\n            success := true;\n        } else {\n            success := false;\n        }\n    }\n    method BookMultipleRooms(startRoom: int, endRoom: int) returns (success: bool)\n        requires 0 <= startRoom <= endRoom < rooms.Length\n        ensures success ==> forall i :: startRoom <= i <= endRoom ==> rooms[i]\n        ensures !success ==> exists i :: startRoom <= i <= endRoom && !rooms[i]\n    {\n        success := true;\n        var i := startRoom;\n        while i <= endRoom\n            invariant startRoom <= i <= endRoom + 1\n            invariant forall j :: startRoom <= j < i ==> rooms[j]\n            invariant success ==> forall j :: startRoom <= j < i ==> rooms[j]\n            invariant !success ==> exists j :: startRoom <= j <= endRoom && !rooms[j]\n        {\n            if (!rooms[i]) {\n                rooms[i] := true;\n            } else {\n                success := false;\n                break;\n            }\n            i := i + 1;\n        }\n    }\n}",
            "parents": [
                "node_450"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 34\n    method BookMultipleRooms(startRoom: int, endRoom: int) returns (success: bool)\n        requires 0 <= startRoom <= endRoom < rooms.Length\n        ensures success ==> forall i :: startRoom <= i <= endRoom ==> rooms[i]\n        ensures !success ==> exists i :: startRoom <= i <= endRoom && !rooms[i]\n    {\n        success := true;\n        var i := startRoom;\n        while i <= endRoom\n            invariant startRoom <= i <= endRoom + 1\n            invariant forall j :: startRoom <= j < i ==> rooms[j]\n            invariant success ==> forall j :: startRoom <= j < i ==> rooms[j]\n            invariant !success ==> exists j :: startRoom <= j <= endRoom && !rooms[j]\n        {\n            if (!rooms[i]) {\n                rooms[i] := true;\n            } else {\n                success := false;\n                break;\n            }\n            i := i + 1;\n        }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_473",
            "type": "program",
            "content": "class Thermostat {\n    var currentTemperature: int;\n    var setpoint: int;\n    constructor(initTemp: int, setpoint: int)\n        ensures this.currentTemperature == initTemp\n        ensures this.setpoint == setpoint\n    {\n        this.currentTemperature := initTemp;\n        this.setpoint := setpoint;\n    }\nmethod AdjustTemperatureWithHistoryAndLog() returns (adjustment: int, history: seq<int>, log: seq<string>)\n    ensures adjustment == if currentTemperature < setpoint then 1 else if currentTemperature > setpoint then -1 else 0\n    ensures history == if currentTemperature < setpoint then [currentTemperature, setpoint] else if currentTemperature > setpoint then [currentTemperature, setpoint] else [currentTemperature]\n    ensures log == if currentTemperature < setpoint then [\"Heating\"] else if currentTemperature > setpoint then [\"Cooling\"] else [\"Stable\"]\n{\n    var tempHistory: seq<int> := [];\n    var actionLog: seq<string> := [];\n    if currentTemperature < setpoint {\n        adjustment := 1;\n        tempHistory := tempHistory + [currentTemperature, setpoint];\n        actionLog := actionLog + [\"Heating\"];\n    } else if currentTemperature > setpoint {\n        adjustment := -1;\n        tempHistory := tempHistory + [currentTemperature, setpoint];\n        actionLog := actionLog + [\"Cooling\"];\n    } else {\n        adjustment := 0;\n        tempHistory := tempHistory + [currentTemperature];\n        actionLog := actionLog + [\"Stable\"];\n    }\n    history := tempHistory;\n    log := actionLog;\n}\n}",
            "parents": [
                "node_377"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 11\nmethod AdjustTemperatureWithHistoryAndLog() returns (adjustment: int, history: seq<int>, log: seq<string>)\n    ensures adjustment == if currentTemperature < setpoint then 1 else if currentTemperature > setpoint then -1 else 0\n    ensures history == if currentTemperature < setpoint then [currentTemperature, setpoint] else if currentTemperature > setpoint then [currentTemperature, setpoint] else [currentTemperature]\n    ensures log == if currentTemperature < setpoint then [\"Heating\"] else if currentTemperature > setpoint then [\"Cooling\"] else [\"Stable\"]\n{\n    var tempHistory: seq<int> := [];\n    var actionLog: seq<string> := [];\n    if currentTemperature < setpoint {\n        adjustment := 1;\n        tempHistory := tempHistory + [currentTemperature, setpoint];\n        actionLog := actionLog + [\"Heating\"];\n    } else if currentTemperature > setpoint {\n        adjustment := -1;\n        tempHistory := tempHistory + [currentTemperature, setpoint];\n        actionLog := actionLog + [\"Cooling\"];\n    } else {\n        adjustment := 0;\n        tempHistory := tempHistory + [currentTemperature];\n        actionLog := actionLog + [\"Stable\"];\n    }\n    history := tempHistory;\n    log := actionLog;\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_474",
            "type": "program",
            "content": "module GCDModule {\n  method EuclideanGCD(a: nat, b: nat) returns (gcd: nat)\n    requires a > 0 && b > 0\n    ensures gcd > 0\n    ensures a % gcd == 0 && b % gcd == 0\n    ensures forall d: nat :: d > 0 && a % d == 0 && b % d == 0 ==> gcd >= d\n  {\n    var x := a;\n    var y := b;\n    while y != 0\n      invariant x > 0\n      invariant x % gcd == 0 && b % gcd == 0\n      decreases y\n    {\n      var temp := y;\n      y := x % y;\n      x := temp;\n    }\n    gcd := x;\n  }\n}",
            "parents": [
                "idea_0"
            ],
            "diff": "```\n// BEGIN DAFNY\nmodule GCDModule {\n  method EuclideanGCD(a: nat, b: nat) returns (gcd: nat)\n    requires a > 0 && b > 0\n    ensures gcd > 0\n    ensures a % gcd == 0 && b % gcd == 0\n    ensures forall d: nat :: d > 0 && a % d == 0 && b % d == 0 ==> gcd >= d\n  {\n    var x := a;\n    var y := b;\n    while y != 0\n      invariant x > 0\n      invariant x % gcd == 0 && b % gcd == 0\n      decreases y\n    {\n      var temp := y;\n      y := x % y;\n      x := temp;\n    }\n    gcd := x;\n  }\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_475",
            "type": "program",
            "content": "method IsPalindrome(s: seq<char>) returns (isPal: bool)\n    ensures isPal == (forall i :: 0 <= i < |s| / 2 ==> s[i] == s[|s| - i - 1])\n{\n    var n := |s|;\n    isPal := true;\n    var i := 0;\n    while i < n / 2\n        invariant 0 <= i <= n / 2\n        invariant isPal ==> (forall j :: 0 <= j < i ==> s[j] == s[n - j - 1])\n}",
            "parents": [
                "node_343"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 8\n        invariant 0 <= i <= n / 2\n        invariant isPal ==> (forall j :: 0 <= j < i ==> s[j] == s[n - j - 1])\n// END DAFNY\n```"
        },
        {
            "id": "node_476",
            "type": "program",
            "content": "class Matrix3x3 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    var e: int;\n    var f: int;\n    var g: int;\n    var h: int;\n    var i: int;\n    constructor(a: int, b: int, c: int, d: int, e: int, f: int, g: int, h: int, i: int)\n        ensures this.a == a && this.b == b && this.c == c\n        ensures this.d == d && this.e == e && this.f == f\n        ensures this.g == g && this.h == h && this.i == i\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n        this.e := e;\n        this.f := f;\n        this.g := g;\n        this.h := h;\n        this.i := i;\n    }\n    method Determinant() returns (det: int)\n        ensures det == a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g)\n    {\n        det := a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g);\n    }\nmethod Transpose() returns (transposed: Matrix3x3)\n    ensures transposed.a == this.a && transposed.b == this.d && transposed.c == this.g\n    ensures transposed.d == this.b && transposed.e == this.e && transposed.f == this.h\n    ensures transposed.g == this.c && transposed.h == this.f && transposed.i == this.i\n{\n    transposed := new Matrix3x3(a, d, g, b, e, h, c, f, i);\n}\nmethod IsIdentity() returns (isIdentity: bool)\n    ensures isIdentity == (a == 1 && b == 0 && c == 0 &&\n                           d == 0 && e == 1 && f == 0 &&\n                           g == 0 && h == 0 && i == 1)\n{\n    isIdentity := (a == 1 && b == 0 && c == 0 &&\n                   d == 0 && e == 1 && f == 0 &&\n                   g == 0 && h == 0 && i == 1);\n}\nmethod Multiply(other: Matrix3x3) returns (product: Matrix3x3)\n    ensures product.a == a * other.a + b * other.d + c * other.g\n    ensures product.b == a * other.b + b * other.e + c * other.h\n    ensures product.c == a * other.c + b * other.f + c * other.i\n    ensures product.d == d * other.a + e * other.d + f * other.g\n    ensures product.e == d * other.b + e * other.e + f * other.h\n    ensures product.f == d * other.c + e * other.f + f * other.i\n    ensures product.g == g * other.a + h * other.d + i * other.g\n    ensures product.h == g * other.b + h * other.e + i * other.h\n    ensures product.i == g * other.c + h * other.f + i * other.i\n{\n    var newA := a * other.a + b * other.d + c * other.g;\n    var newB := a * other.b + b * other.e + c * other.h;\n    var newC := a * other.c + b * other.f + c * other.i;\n    var newD := d * other.a + e * other.d + f * other.g;\n    var newE := d * other.b + e * other.e + f * other.h;\n    var newF := d * other.c + e * other.f + f * other.i;\n    var newG := g * other.a + h * other.d + i * other.g;\n    var newH := g * other.b + h * other.e + i * other.h;\n    var newI := g * other.c + h * other.f + i * other.i;\n    product := new Matrix3x3(newA, newB, newC, newD, newE, newF, newG, newH, newI);\n}\n}",
            "parents": [
                "node_424"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 48\nmethod Multiply(other: Matrix3x3) returns (product: Matrix3x3)\n    ensures product.a == a * other.a + b * other.d + c * other.g\n    ensures product.b == a * other.b + b * other.e + c * other.h\n    ensures product.c == a * other.c + b * other.f + c * other.i\n    ensures product.d == d * other.a + e * other.d + f * other.g\n    ensures product.e == d * other.b + e * other.e + f * other.h\n    ensures product.f == d * other.c + e * other.f + f * other.i\n    ensures product.g == g * other.a + h * other.d + i * other.g\n    ensures product.h == g * other.b + h * other.e + i * other.h\n    ensures product.i == g * other.c + h * other.f + i * other.i\n{\n    var newA := a * other.a + b * other.d + c * other.g;\n    var newB := a * other.b + b * other.e + c * other.h;\n    var newC := a * other.c + b * other.f + c * other.i;\n    var newD := d * other.a + e * other.d + f * other.g;\n    var newE := d * other.b + e * other.e + f * other.h;\n    var newF := d * other.c + e * other.f + f * other.i;\n    var newG := g * other.a + h * other.d + i * other.g;\n    var newH := g * other.b + h * other.e + i * other.h;\n    var newI := g * other.c + h * other.f + i * other.i;\n    \n    product := new Matrix3x3(newA, newB, newC, newD, newE, newF, newG, newH, newI);\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_477",
            "type": "program",
            "content": "class Geometry {\n    method IsPointInsideRectangle(px: int, py: int, rx: int, ry: int, rw: int, rh: int) returns (inside: bool)\n        requires rw >= 0 && rh >= 0\n        ensures inside == ((px >= rx) && (px <= rx + rw) && (py >= ry) && (py <= ry + rh))\n    {\n        inside := (px >= rx) && (px <= rx + rw) && (py >= ry) && (py <= ry + rh);\n    }\n    method DoRectanglesOverlap(r1x: int, r1y: int, r1w: int, r1h: int, r2x: int, r2y: int, r2w: int, r2h: int) returns (overlap: bool)\n        requires r1w >= 0 && r1h >= 0 && r2w >= 0 && r2h >= 0\n        ensures overlap == ((r1x < r2x + r2w) && (r1x + r1w > r2x) && (r1y < r2y + r2h) && (r1y + r1h > r2y))\n    {\n        overlap := (r1x < r2x + r2w) && (r1x + r1w > r2x) && (r1y < r2y + r2h) && (r1y + r1h > r2y);\n    }\n    method CalculateRectanglePerimeter(rx: int, ry: int, rw: int, rh: int) returns (perimeter: int)\n        requires rw >= 0 && rh >= 0\n        ensures perimeter == 2 * (rw + rh)\n    {\n        var w := rw;\n        var h := rh;\n        perimeter := 0;\n        var count := 0;\n        while count < 2\n            invariant 0 <= count <= 2\n            invariant perimeter == count * (rw + rh)\n        {\n            perimeter := perimeter + (w + h);\n            count := count + 1;\n        }\n    }\n    method CalculateRectangleArea(rx: int, ry: int, rw: int, rh: int) returns (area: int)\n        requires rw >= 0 && rh >= 0\n        ensures area == rw * rh\n    {\n        var w := rw;\n        var h := rh;\n        area := 0;\n        var count := 0;\n        while count < h\n            invariant 0 <= count <= h\n            invariant area == count * rw\n        {\n            area := area + w;\n            count := count + 1;\n        }\n    }\n}",
            "parents": [
                "node_367"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 31\n    method CalculateRectangleArea(rx: int, ry: int, rw: int, rh: int) returns (area: int)\n        requires rw >= 0 && rh >= 0\n        ensures area == rw * rh\n    {\n        var w := rw;\n        var h := rh;\n        area := 0;\n        var count := 0;\n        while count < h\n            invariant 0 <= count <= h\n            invariant area == count * rw\n        {\n            area := area + w;\n            count := count + 1;\n        }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_478",
            "type": "program",
            "content": "class SudokuValidator {\n    var grid: array2<int>;\n    constructor(grid: array2<int>)\n        requires grid.Length0 == 9 && grid.Length1 == 9\n        ensures this.grid == grid\n    {\n        this.grid := grid;\n    }\n    method IsRowValid(row: int) returns (isValid: bool)\n        requires 0 <= row < 9\n        ensures isValid == (forall i, j :: 0 <= i < j < 9 ==> grid[row, i] != grid[row, j])\n    {\n        var seen := new bool[10];\n        isValid := true;\n        for i := 0 to 8 {\n            if grid[row, i] < 1 || grid[row, i] > 9 || seen[grid[row, i]] {\n                isValid := false;\n                return;\n            }\n            seen[grid[row, i]] := true;\n        }\n    }\n    method IsColumnValid(col: int) returns (isValid: bool)\n        requires 0 <= col < 9\n        ensures isValid == (forall i, j :: 0 <= i < j < 9 ==> grid[i, col] != grid[j, col])\n    {\n        var seen := new bool[10];\n        isValid := true;\n        for i := 0 to 8 {\n            if grid[i, col] < 1 || grid[i, col] > 9 || seen[grid[i, col]] {\n                isValid := false;\n                return;\n            }\n            seen[grid[i, col]] := true;\n        }\n    }\n    method IsSubgridValid(subgridRow: int, subgridCol: int) returns (isValid: bool)\n        requires 0 <= subgridRow < 3 && 0 <= subgridCol < 3\n        ensures isValid == (forall i, j :: 0 <= i < j < 9 ==> grid[subgridRow * 3 + i / 3, subgridCol * 3 + i % 3] != grid[subgridRow * 3 + j / 3, subgridCol * 3 + j % 3])\n    {\n        var seen := new bool[10];\n        isValid := true;\n        for i := 0 to 8\n            invariant 0 <= i <= 9\n            invariant forall k :: 0 <= k < i ==> 1 <= grid[subgridRow * 3 + k / 3, subgridCol * 3 + k % 3] <= 9\n            invariant forall k :: 0 <= k < i ==> !seen[grid[subgridRow * 3 + k / 3, subgridCol * 3 + k % 3]]\n            invariant isValid == (forall k :: 0 <= k < i ==> !seen[grid[subgridRow * 3 + k / 3, subgridCol * 3 + k % 3]])\n        {\n            var value := grid[subgridRow * 3 + i / 3, subgridCol * 3 + i % 3];\n            if value < 1 || value > 9 || seen[value] {\n                isValid := false;\n                return;\n            }\n            seen[value] := true;\n        }\n}\n}",
            "parents": [
                "node_254"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 43\n        for i := 0 to 8\n            invariant 0 <= i <= 9\n            invariant forall k :: 0 <= k < i ==> 1 <= grid[subgridRow * 3 + k / 3, subgridCol * 3 + k % 3] <= 9\n            invariant forall k :: 0 <= k < i ==> !seen[grid[subgridRow * 3 + k / 3, subgridCol * 3 + k % 3]]\n            invariant isValid == (forall k :: 0 <= k < i ==> !seen[grid[subgridRow * 3 + k / 3, subgridCol * 3 + k % 3]])\n        {\n            var value := grid[subgridRow * 3 + i / 3, subgridCol * 3 + i % 3];\n            if value < 1 || value > 9 || seen[value] {\n                isValid := false;\n                return;\n            }\n            seen[value] := true;\n        }\n// END DAFNY\n```"
        },
        {
            "id": "node_479",
            "type": "program",
            "content": "class VotingSystem {\n    var votes: array<int>;\n    constructor (numCandidates: int)\n        requires numCandidates > 0\n    {\n        votes := new int[numCandidates];\n    }\n    method Vote(candidate: int)\n        requires 0 <= candidate < votes.Length\n        modifies votes\n        ensures votes[candidate] == old(votes[candidate]) + 1\n    {\n        votes[candidate] := votes[candidate] + 1;\n    }\n    method GetWinner() returns (winner: int)\n        requires votes.Length > 0\n        ensures 0 <= winner < votes.Length\n        ensures forall i: int :: 0 <= i < votes.Length ==> votes[winner] >= votes[i]\n        ensures exists i: int :: 0 <= i < votes.Length && votes[i] == votes[winner]\n    {\n        var maxVotes := votes[0];\n        winner := 0;\n        for i := 1 to votes.Length - 1\n            invariant 0 <= winner < votes.Length\n            invariant 0 <= i <= votes.Length\n            invariant forall j: int :: 0 <= j < i ==> votes[winner] >= votes[j]\n            invariant exists j: int :: 0 <= j < i && votes[j] == maxVotes\n        {\n            if votes[i] > maxVotes {\n                maxVotes := votes[i];\n                winner := i;\n            }\n        }\n    }\n}",
            "parents": [
                "node_432"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 15\n    method GetWinner() returns (winner: int)\n        requires votes.Length > 0\n        ensures 0 <= winner < votes.Length\n        ensures forall i: int :: 0 <= i < votes.Length ==> votes[winner] >= votes[i]\n        ensures exists i: int :: 0 <= i < votes.Length && votes[i] == votes[winner]\n    {\n        var maxVotes := votes[0];\n        winner := 0;\n        for i := 1 to votes.Length - 1\n            invariant 0 <= winner < votes.Length\n            invariant 0 <= i <= votes.Length\n            invariant forall j: int :: 0 <= j < i ==> votes[winner] >= votes[j]\n            invariant exists j: int :: 0 <= j < i && votes[j] == maxVotes\n        {\n            if votes[i] > maxVotes {\n                maxVotes := votes[i];\n                winner := i;\n            }\n        }\n    }\n// END DAFNY\n```"
        },
        {
            "id": "node_480",
            "type": "program",
            "content": "class Matrix3x3 {\n    var a: int;\n    var b: int;\n    var c: int;\n    var d: int;\n    var e: int;\n    var f: int;\n    var g: int;\n    var h: int;\n    var i: int;\n    constructor(a: int, b: int, c: int, d: int, e: int, f: int, g: int, h: int, i: int)\n        ensures this.a == a && this.b == b && this.c == c\n        ensures this.d == d && this.e == e && this.f == f\n        ensures this.g == g && this.h == h && this.i == i\n    {\n        this.a := a;\n        this.b := b;\n        this.c := c;\n        this.d := d;\n        this.e := e;\n        this.f := f;\n        this.g := g;\n        this.h := h;\n        this.i := i;\n    }\n    method Transpose() returns (transposed: Matrix3x3)\n        ensures transposed.a == a && transposed.b == d && transposed.c == g\n        ensures transposed.d == b && transposed.e == e && transposed.f == h\n        ensures transposed.g == c && transposed.h == f && transposed.i == i\n    {\n        transposed := new Matrix3x3(a, d, g, b, e, h, c, f, i);\n    }\nmethod Multiply(other: Matrix3x3) returns (product: Matrix3x3)\n    ensures product.a == a * other.a + b * other.d + c * other.g\n    ensures product.b == a * other.b + b * other.e + c * other.h\n    ensures product.c == a * other.c + b * other.f + c * other.i\n    ensures product.d == d * other.a + e * other.d + f * other.g\n    ensures product.e == d * other.b + e * other.e + f * other.h\n    ensures product.f == d * other.c + e * other.f + f * other.i\n    ensures product.g == g * other.a + h * other.d + i * other.g\n    ensures product.h == g * other.b + h * other.e + i * other.h\n    ensures product.i == g * other.c + h * other.f + i * other.i\n{\n    var newA := a * other.a + b * other.d + c * other.g;\n    var newB := a * other.b + b * other.e + c * other.h;\n    var newC := a * other.c + b * other.f + c * other.i;\n    var newD := d * other.a + e * other.d + f * other.g;\n    var newE := d * other.b + e * other.e + f * other.h;\n    var newF := d * other.c + e * other.f + f * other.i;\n    var newG := g * other.a + h * other.d + i * other.g;\n    var newH := g * other.b + h * other.e + i * other.h;\n    var newI := g * other.c + h * other.f + i * other.i;\n    product := new Matrix3x3(newA, newB, newC, newD, newE, newF, newG, newH, newI);\n}\nmethod Determinant() returns (det: int)\n    ensures det == a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g)\n{\n    det := a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g);\n}\nmethod IsIdentity() returns (isIdentity: bool)\n    ensures isIdentity == (a == 1 && e == 1 && i == 1 && b == 0 && c == 0 && d == 0 && f == 0 && g == 0 && h == 0)\n{\n    isIdentity := (a == 1 && e == 1 && i == 1 && b == 0 && c == 0 && d == 0 && f == 0 && g == 0 && h == 0);\n}\nmethod ScalarMultiply(scalar: int) returns (result: Matrix3x3)\n    ensures result.a == a * scalar && result.b == b * scalar && result.c == c * scalar\n    ensures result.d == d * scalar && result.e == e * scalar && result.f == f * scalar\n    ensures result.g == g * scalar && result.h == h * scalar && result.i == i * scalar\n{\n    var newA := a * scalar;\n    var newB := b * scalar;\n    var newC := c * scalar;\n    var newD := d * scalar;\n    var newE := e * scalar;\n    var newF := f * scalar;\n    var newG := g * scalar;\n    var newH := h * scalar;\n    var newI := i * scalar;\n    result := new Matrix3x3(newA, newB, newC, newD, newE, newF, newG, newH, newI);\n}\n}",
            "parents": [
                "node_427"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 65\nmethod ScalarMultiply(scalar: int) returns (result: Matrix3x3)\n    ensures result.a == a * scalar && result.b == b * scalar && result.c == c * scalar\n    ensures result.d == d * scalar && result.e == e * scalar && result.f == f * scalar\n    ensures result.g == g * scalar && result.h == h * scalar && result.i == i * scalar\n{\n    var newA := a * scalar;\n    var newB := b * scalar;\n    var newC := c * scalar;\n    var newD := d * scalar;\n    var newE := e * scalar;\n    var newF := f * scalar;\n    var newG := g * scalar;\n    var newH := h * scalar;\n    var newI := i * scalar;\n    result := new Matrix3x3(newA, newB, newC, newD, newE, newF, newG, newH, newI);\n}\n// END DAFNY\n```"
        },
        {
            "id": "node_481",
            "type": "program",
            "content": "class PayrollSystem {\n    method CalculateSalary(hoursWorked: int, payRate: int) returns (salary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        ensures salary >= 0\n    {\n        salary := hoursWorked * payRate;\n    }\n    method CalculateOvertimeSalary(hoursWorked: int, payRate: int, overtimeRate: int) returns (totalSalary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        requires overtimeRate >= payRate\n        ensures totalSalary >= 0\n    {\n        var regularHours := if hoursWorked > 40 then 40 else hoursWorked;\n        var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n        var regularSalary := regularHours * payRate;\n        var overtimeSalary := overtimeHours * overtimeRate;\n        totalSalary := regularSalary + overtimeSalary;\n    }\n    method CalculateWeeklySalaryWithBonus(hoursWorked: int, payRate: int, overtimeRate: int, bonus: int) returns (weeklySalary: int)\n        requires hoursWorked >= 0\n        requires payRate >= 0\n        requires overtimeRate >= payRate\n        requires bonus >= 0\n        ensures weeklySalary >= 0\n    {\n        var totalHours := hoursWorked;\n        var totalSalary := 0;\n        var regularHours := if hoursWorked > 40 then 40 else hoursWorked;\n        var overtimeHours := if hoursWorked > 40 then hoursWorked - 40 else 0;\n        var regularSalary := regularHours * payRate;\n        var overtimeSalary := overtimeHours * overtimeRate;\n        var baseSalary := regularSalary + overtimeSalary;\n        weeklySalary := baseSalary + bonus;\n        // Loop to simulate weekly salary calculation over multiple weeks\n        var weeks := 4;\n        var accumulatedSalary := 0;\n        var totalBonus := 0;\n        while weeks > 0\n            invariant weeks >= 0\n            invariant accumulatedSalary >= 0\n            invariant totalBonus >= 0\n        {\n            accumulatedSalary := accumulatedSalary + baseSalary;\n            totalBonus := totalBonus + bonus;\n            weeks := weeks - 1;\n        }\n        weeklySalary := accumulatedSalary + totalBonus;\n}\n}",
            "parents": [
                "node_412"
            ],
            "diff": "```dafny\n// BEGIN DAFNY AT LINE 37\n        var weeks := 4;\n        var accumulatedSalary := 0;\n        var totalBonus := 0;\n        while weeks > 0\n            invariant weeks >= 0\n            invariant accumulatedSalary >= 0\n            invariant totalBonus >= 0\n        {\n            accumulatedSalary := accumulatedSalary + baseSalary;\n            totalBonus := totalBonus + bonus;\n            weeks := weeks - 1;\n        }\n        weeklySalary := accumulatedSalary + totalBonus;\n// END DAFNY\n```"
        }
    ]
}